; ModuleID = 'onelua.c'
source_filename = "onelua.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.luaL_Reg = type { i8*, i32 (%struct.lua_State*)* }
%struct.lua_State = type { %struct.GCObject*, i8, i8, i8, i8, i16, %union.StackValue*, %struct.global_State*, %struct.CallInfo*, i32*, %union.StackValue*, %union.StackValue*, %struct.UpVal*, %struct.GCObject*, %struct.lua_State*, %struct.lua_longjmp*, %struct.CallInfo, void (%struct.lua_State*, %struct.lua_Debug*)*, i64, i32, i32, i32, i32, i32 }
%struct.global_State = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable, %struct.TValue, %struct.TValue, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %struct.GCObject*, %struct.GCObject**, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.lua_State*, i32 (%struct.lua_State*)*, %struct.lua_State*, %struct.TString*, [25 x %struct.TString*], [9 x %struct.Table*], [53 x [2 x %struct.TString*]], void (i8*, i8*, i32)*, i8* }
%struct.stringtable = type { %struct.TString**, i32, i32 }
%struct.TValue = type { %union.Value, i8 }
%union.Value = type { %struct.GCObject* }
%struct.TString = type { %struct.GCObject*, i8, i8, i8, i8, i32, %union.anon }
%union.anon = type { i64 }
%struct.Table = type { %struct.GCObject*, i8, i8, i8, i8, i32, %struct.TValue*, %union.Node*, %union.Node*, %struct.Table*, %struct.GCObject* }
%union.Node = type { %struct.NodeKey }
%struct.NodeKey = type { %union.Value, i8, i8, i32, %union.Value }
%union.StackValue = type { %struct.TValue }
%struct.UpVal = type { %struct.GCObject*, i8, i8, %struct.TValue*, %union.anon.4 }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %struct.UpVal*, %struct.UpVal** }
%struct.GCObject = type { %struct.GCObject*, i8, i8 }
%struct.lua_longjmp = type { %struct.lua_longjmp*, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.CallInfo = type { %union.StackValue*, %union.StackValue*, %struct.CallInfo*, %struct.CallInfo*, %union.anon.0, %union.anon.2, i16, i16 }
%union.anon.0 = type { %struct.anon.1 }
%struct.anon.1 = type { i32 (%struct.lua_State*, i32, i64)*, i64, i64 }
%union.anon.2 = type { i32 }
%struct.lua_Debug = type { i32, i8*, i8*, i8*, i8*, i64, i32, i32, i32, i8, i8, i8, i8, i16, i16, [60 x i8], %struct.CallInfo* }
%struct.anon.10 = type { i8, i8 }
%struct.expdesc = type { i32, %union.anon.8, i32, i32 }
%union.anon.8 = type { i64 }
%struct.LClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, %struct.Proto*, [1 x %struct.UpVal*] }
%struct.Proto = type { %struct.GCObject*, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.TValue*, i32*, %struct.Proto**, %struct.Upvaldesc*, i8*, %struct.AbsLineInfo*, %struct.LocVar*, %struct.TString*, %struct.GCObject* }
%struct.Upvaldesc = type { %struct.TString*, i8, i8 }
%struct.AbsLineInfo = type { i32, i32 }
%struct.LocVar = type { %struct.TString*, i32, i32 }
%struct.anon = type { i32*, i32, i32 }
%union.Closure = type { %struct.CClosure }
%struct.CClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, i32 (%struct.lua_State*)*, [1 x %struct.TValue] }
%struct.anon.3 = type { i16, i16 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.Udata = type { %struct.GCObject*, i8, i8, i16, i64, %struct.Table*, %struct.GCObject*, [1 x %union.UValue] }
%union.UValue = type { %struct.TValue }
%struct.lconv = type { i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.BuffFS = type { %struct.lua_State*, i32, i32, [400 x i8] }
%union.GCUnion = type { %struct.lua_State }
%struct.CallS = type { %union.StackValue*, i32 }
%struct.SParser = type { %struct.Zio*, %struct.Mbuffer, %struct.Dyndata, i8*, i8* }
%struct.Zio = type { i64, i8*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, %struct.lua_State* }
%struct.Mbuffer = type { i8*, i64, i64 }
%struct.Dyndata = type { %struct.anon.7, %struct.Labellist, %struct.Labellist }
%struct.anon.7 = type { %struct.Vardesc*, i32, i32 }
%struct.Vardesc = type { i16 }
%struct.Labellist = type { %struct.Labeldesc*, i32, i32 }
%struct.Labeldesc = type { %struct.TString*, i32, i32, i8, i8 }
%struct.DumpState = type { %struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32, i32 }
%struct.luaL_Buffer = type { i8*, i64, i64, %struct.lua_State*, %union.anon.6 }
%union.anon.6 = type { double, [1016 x i8] }
%struct.LoadF = type { i32, %struct._IO_FILE*, [8192 x i8] }
%struct.LoadS = type { i8*, i64 }
%struct.luaL_Stream = type { %struct._IO_FILE*, i32 (%struct.lua_State*)* }
%struct.RanState = type { [4 x i64] }
%struct.BlockCnt = type { %struct.BlockCnt*, i32, i32, i8, i8, i8, i8 }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState*, %struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Table*, %struct.Dyndata*, %struct.TString*, %struct.TString* }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.FuncState = type { %struct.Proto*, %struct.FuncState*, %struct.LexState*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8, i8, i8 }
%struct.LoadState = type { %struct.lua_State*, %struct.Zio*, i8* }
%struct.LHS_assign = type { %struct.LHS_assign*, %struct.expdesc }
%struct.anon.9 = type { i16, i8 }
%struct.ConsControl = type { %struct.expdesc, %struct.expdesc*, i32, i32, i32 }
%struct.RN = type { %struct._IO_FILE*, i32, i32, [201 x i8] }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.MatchState = type { i8*, i8*, i8*, %struct.lua_State*, i32, i8, [32 x %struct.anon.11] }
%struct.anon.11 = type { i8*, i64 }
%struct.Header = type { %struct.lua_State*, i32, i32 }
%union.Ftypes = type { double, [32 x i8] }

@.str = private unnamed_addr constant [38 x i8] c"cannot resume non-suspended coroutine\00", align 1
@.str.1 = private unnamed_addr constant [29 x i8] c"cannot resume dead coroutine\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str.3 = private unnamed_addr constant [42 x i8] c"attempt to yield across a C-call boundary\00", align 1
@.str.4 = private unnamed_addr constant [42 x i8] c"attempt to yield from outside a coroutine\00", align 1
@lua_ident = local_unnamed_addr constant [129 x i8] c"$LuaVersion: Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio $$LuaAuthors: R. Ierusalimschy, L. H. de Figueiredo, W. Celes $\00", align 16
@luaT_typenames_ = internal unnamed_addr constant [12 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.182, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.183, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.187, i32 0, i32 0)], align 16
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.8 = private unnamed_addr constant [17 x i8] c"stack traceback:\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"\0A\09...\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"Slnt\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"\0A\09%s:\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c" in \00", align 1
@.str.14 = private unnamed_addr constant [21 x i8] c"\0A\09(...tail calls...)\00", align 1
@.str.15 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str.16 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.18 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str.19 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"__name\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"light userdata\00", align 1
@.str.22 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str.23 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str.25 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str.26 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"invalid option '%s'\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str.29 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str.31 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@stdin = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.32 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str.33 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.39 = private unnamed_addr constant [32 x i8] c"object length is not an integer\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str.41 = private unnamed_addr constant [34 x i8] c"'__tostring' must return a string\00", align 1
@.str.42 = private unnamed_addr constant [3 x i8] c"%I\00", align 1
@.str.43 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.44 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.45 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.46 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"%s: %p\00", align 1
@.str.48 = private unnamed_addr constant [18 x i8] c"too many upvalues\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.50 = private unnamed_addr constant [49 x i8] c"core and library have incompatible numeric types\00", align 1
@.str.51 = private unnamed_addr constant [54 x i8] c"version mismatch: app. needs %f, Lua core provides %f\00", align 1
@base_funcs = internal constant [26 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.301, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_assert }, %struct.luaL_Reg { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.302, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_collectgarbage }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.303, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_dofile }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.304, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_error }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.306, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_ipairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.307, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_loadfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.308, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_load }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.309, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_next }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.310, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.311, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_print }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.313, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_warn }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.314, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawequal }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.315, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawlen }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.316, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawget }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.317, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawset }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.318, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_select }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.320, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tonumber }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.321, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tostring }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.323, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_xpcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.52 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"Lua 5.4\00", align 1
@.str.54 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@co_funcs = internal constant [9 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.347, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cocreate }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.348, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_coresume }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_corunning }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.350, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_costatus }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.351, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cowrap }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.352, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yield }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.353, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yieldable }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.354, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_kill }, %struct.luaL_Reg zeroinitializer], align 16
@dblib = internal constant [17 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @db_debug }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.362, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.363, i32 0, i32 0), i32 (%struct.lua_State*)* @db_gethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.364, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getinfo }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.365, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.366, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getregistry }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.367, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.368, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvaluejoin }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.369, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvalueid }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.370, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.371, i32 0, i32 0), i32 (%struct.lua_State*)* @db_sethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.372, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.373, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.374, i32 0, i32 0), i32 (%struct.lua_State*)* @db_traceback }, %struct.luaL_Reg zeroinitializer], align 16
@iolib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @io_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @io_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.406, i32 0, i32 0), i32 (%struct.lua_State*)* @io_input }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @io_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i32 0, i32 0), i32 (%struct.lua_State*)* @io_open }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.407, i32 0, i32 0), i32 (%struct.lua_State*)* @io_output }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.408, i32 0, i32 0), i32 (%struct.lua_State*)* @io_popen }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @io_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.409, i32 0, i32 0), i32 (%struct.lua_State*)* @io_tmpfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @io_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @io_write }, %struct.luaL_Reg zeroinitializer], align 16
@.str.55 = private unnamed_addr constant [10 x i8] c"_IO_input\00", align 1
@.str.56 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@stdout = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.57 = private unnamed_addr constant [11 x i8] c"_IO_output\00", align 1
@.str.58 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@stderr = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.59 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@mathlib = internal constant [28 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.438, i32 0, i32 0), i32 (%struct.lua_State*)* @math_abs }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.439, i32 0, i32 0), i32 (%struct.lua_State*)* @math_acos }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.440, i32 0, i32 0), i32 (%struct.lua_State*)* @math_asin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.441, i32 0, i32 0), i32 (%struct.lua_State*)* @math_atan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.442, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ceil }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.443, i32 0, i32 0), i32 (%struct.lua_State*)* @math_cos }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.444, i32 0, i32 0), i32 (%struct.lua_State*)* @math_deg }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.445, i32 0, i32 0), i32 (%struct.lua_State*)* @math_exp }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.446, i32 0, i32 0), i32 (%struct.lua_State*)* @math_toint }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.447, i32 0, i32 0), i32 (%struct.lua_State*)* @math_floor }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.448, i32 0, i32 0), i32 (%struct.lua_State*)* @math_fmod }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.449, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ult }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.450, i32 0, i32 0), i32 (%struct.lua_State*)* @math_log }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.451, i32 0, i32 0), i32 (%struct.lua_State*)* @math_max }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i32 0, i32 0), i32 (%struct.lua_State*)* @math_min }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.453, i32 0, i32 0), i32 (%struct.lua_State*)* @math_modf }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.454, i32 0, i32 0), i32 (%struct.lua_State*)* @math_rad }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.455, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.456, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sqrt }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.457, i32 0, i32 0), i32 (%struct.lua_State*)* @math_tan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @math_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.60 = private unnamed_addr constant [3 x i8] c"pi\00", align 1
@.str.61 = private unnamed_addr constant [5 x i8] c"huge\00", align 1
@.str.62 = private unnamed_addr constant [11 x i8] c"maxinteger\00", align 1
@.str.63 = private unnamed_addr constant [11 x i8] c"mininteger\00", align 1
@pk_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.465, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_loadlib }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.466, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_searchpath }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.64 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.65 = private unnamed_addr constant [9 x i8] c"LUA_PATH\00", align 1
@.str.66 = private unnamed_addr constant [151 x i8] c"/usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"cpath\00", align 1
@.str.68 = private unnamed_addr constant [10 x i8] c"LUA_CPATH\00", align 1
@.str.69 = private unnamed_addr constant [69 x i8] c"/usr/local/lib/lua/5.4/?.so;/usr/local/lib/lua/5.4/loadall.so;./?.so\00", align 1
@.str.70 = private unnamed_addr constant [11 x i8] c"/\0A;\0A?\0A!\0A-\0A\00", align 1
@.str.71 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str.72 = private unnamed_addr constant [7 x i8] c"loaded\00", align 1
@.str.73 = private unnamed_addr constant [9 x i8] c"_PRELOAD\00", align 1
@.str.74 = private unnamed_addr constant [8 x i8] c"preload\00", align 1
@ll_funcs = internal constant [2 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_require }, %struct.luaL_Reg zeroinitializer], align 16
@syslib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.491, i32 0, i32 0), i32 (%struct.lua_State*)* @os_clock }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.492, i32 0, i32 0), i32 (%struct.lua_State*)* @os_date }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.493, i32 0, i32 0), i32 (%struct.lua_State*)* @os_difftime }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.494, i32 0, i32 0), i32 (%struct.lua_State*)* @os_execute }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i32 0, i32 0), i32 (%struct.lua_State*)* @os_exit }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.495, i32 0, i32 0), i32 (%struct.lua_State*)* @os_getenv }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @os_remove }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.497, i32 0, i32 0), i32 (%struct.lua_State*)* @os_rename }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.498, i32 0, i32 0), i32 (%struct.lua_State*)* @os_setlocale }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i32 (%struct.lua_State*)* @os_time }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.500, i32 0, i32 0), i32 (%struct.lua_State*)* @os_tmpname }, %struct.luaL_Reg zeroinitializer], align 16
@strlib = internal constant [18 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.524, i32 0, i32 0), i32 (%struct.lua_State*)* @str_byte }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @str_char }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.526, i32 0, i32 0), i32 (%struct.lua_State*)* @str_dump }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.527, i32 0, i32 0), i32 (%struct.lua_State*)* @str_find }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.528, i32 0, i32 0), i32 (%struct.lua_State*)* @str_format }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.529, i32 0, i32 0), i32 (%struct.lua_State*)* @gmatch }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.530, i32 0, i32 0), i32 (%struct.lua_State*)* @str_gsub }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @str_len }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.532, i32 0, i32 0), i32 (%struct.lua_State*)* @str_lower }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.533, i32 0, i32 0), i32 (%struct.lua_State*)* @str_match }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.534, i32 0, i32 0), i32 (%struct.lua_State*)* @str_rep }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.535, i32 0, i32 0), i32 (%struct.lua_State*)* @str_reverse }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.536, i32 0, i32 0), i32 (%struct.lua_State*)* @str_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.537, i32 0, i32 0), i32 (%struct.lua_State*)* @str_upper }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @str_pack }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.539, i32 0, i32 0), i32 (%struct.lua_State*)* @str_packsize }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @str_unpack }, %struct.luaL_Reg zeroinitializer], align 16
@tab_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.589, i32 0, i32 0), i32 (%struct.lua_State*)* @tconcat }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.590, i32 0, i32 0), i32 (%struct.lua_State*)* @tinsert }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @tpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @tunpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @tremove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.591, i32 0, i32 0), i32 (%struct.lua_State*)* @tmove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.592, i32 0, i32 0), i32 (%struct.lua_State*)* @sort }, %struct.luaL_Reg zeroinitializer], align 16
@funcs = internal constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.601, i32 0, i32 0), i32 (%struct.lua_State*)* @byteoffset }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.602, i32 0, i32 0), i32 (%struct.lua_State*)* @codepoint }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @utfchar }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @utflen }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.603, i32 0, i32 0), i32 (%struct.lua_State*)* @iter_codes }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.75 = private unnamed_addr constant [15 x i8] c"[\00-\7F\C2-\FD][\80-\BF]*\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"charpattern\00", align 1
@loadedlibs = internal unnamed_addr constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_base }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.610, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_package }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.611, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_coroutine }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_table }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.612, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_io }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.613, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_os }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_string }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.614, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_math }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.615, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_utf8 }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_debug }, %struct.luaL_Reg zeroinitializer], align 16
@.str.77 = private unnamed_addr constant [39 x i8] c"cannot create state: not enough memory\00", align 1
@.str.78 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@luaT_init.luaT_eventname = internal unnamed_addr constant [25 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.92, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.94, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.95, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.96, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0)], align 16
@.str.79 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.80 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str.81 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.83 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str.85 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str.86 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str.87 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str.88 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str.89 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str.90 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"__idiv\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"__band\00", align 1
@.str.93 = private unnamed_addr constant [6 x i8] c"__bor\00", align 1
@.str.94 = private unnamed_addr constant [7 x i8] c"__bxor\00", align 1
@.str.95 = private unnamed_addr constant [6 x i8] c"__shl\00", align 1
@.str.96 = private unnamed_addr constant [6 x i8] c"__shr\00", align 1
@.str.97 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str.98 = private unnamed_addr constant [7 x i8] c"__bnot\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str.101 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str.102 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@.str.103 = private unnamed_addr constant [8 x i8] c"__close\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"_ENV\00", align 1
@luaX_tokens = internal unnamed_addr constant [37 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.105, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.107, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.113, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.115, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.117, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.118, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.119, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.121, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.122, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.125, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.127, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.129, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.130, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.131, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.132, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.133, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.135, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.136, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.138, i32 0, i32 0)], align 16
@.str.105 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.108 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.109 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str.110 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.111 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.112 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"goto\00", align 1
@.str.114 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.115 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.116 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.117 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.118 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.119 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str.120 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.121 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str.122 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.123 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.124 = private unnamed_addr constant [3 x i8] c"//\00", align 1
@.str.125 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.127 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str.128 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.129 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.130 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str.131 = private unnamed_addr constant [3 x i8] c"<<\00", align 1
@.str.132 = private unnamed_addr constant [3 x i8] c">>\00", align 1
@.str.133 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str.134 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str.135 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str.136 = private unnamed_addr constant [10 x i8] c"<integer>\00", align 1
@.str.137 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str.138 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@.str.139 = private unnamed_addr constant [29 x i8] c"error object is not a string\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"error in __gc metamethod (\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c")\00", align 1
@absentkey = internal constant %struct.TValue { %union.Value zeroinitializer, i8 32 }, align 8
@sweepgen.nextage = internal unnamed_addr constant [7 x i8] c"\01\03\03\04\04\05\06", align 1
@.str.142 = private unnamed_addr constant [12 x i8] c"(temporary)\00", align 1
@.str.143 = private unnamed_addr constant [14 x i8] c"(C temporary)\00", align 1
@.str.144 = private unnamed_addr constant [9 x i8] c"(vararg)\00", align 1
@.str.145 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str.146 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.147 = private unnamed_addr constant [3 x i8] c"=?\00", align 1
@.str.148 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str.150 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str.151 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@.str.152 = private unnamed_addr constant [11 x i8] c"metamethod\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"hook\00", align 1
@.str.154 = private unnamed_addr constant [13 x i8] c"for iterator\00", align 1
@.str.155 = private unnamed_addr constant [6 x i8] c"order\00", align 1
@.str.156 = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str.157 = private unnamed_addr constant [14 x i8] c"integer index\00", align 1
@.str.158 = private unnamed_addr constant [6 x i8] c"field\00", align 1
@.str.159 = private unnamed_addr constant [8 x i8] c"upvalue\00", align 1
@.str.160 = private unnamed_addr constant [9 x i8] c"constant\00", align 1
@luaP_opmodes = internal unnamed_addr constant [84 x i8] c"\08\0A\0A\09\09\08\08\08\00\08\08\08\08\00\00\00\00\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\00\00\04\10\10\10\10\10\10\10\10\10\10\18hh \00\00\09\09\01\00\09 \09H\08\03", align 16
@.str.161 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str.162 = private unnamed_addr constant [44 x i8] c"attempt to close non-closable variable '%s'\00", align 1
@.str.163 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@luaV_execute.disptab = internal unnamed_addr constant [84 x i8*] [i8* blockaddress(@luaV_execute, %89), i8* blockaddress(@luaV_execute, %135), i8* blockaddress(@luaV_execute, %151), i8* blockaddress(@luaV_execute, %115), i8* blockaddress(@luaV_execute, %167), i8* blockaddress(@luaV_execute, %189), i8* blockaddress(@luaV_execute, %207), i8* blockaddress(@luaV_execute, %228), i8* blockaddress(@luaV_execute, %252), i8* blockaddress(@luaV_execute, %294), i8* blockaddress(@luaV_execute, %340), i8* blockaddress(@luaV_execute, %413), i8* blockaddress(@luaV_execute, %467), i8* blockaddress(@luaV_execute, %510), i8* blockaddress(@luaV_execute, %582), i8* blockaddress(@luaV_execute, %678), i8* blockaddress(@luaV_execute, %755), i8* blockaddress(@luaV_execute, %821), i8* blockaddress(@luaV_execute, %870), i8* blockaddress(@luaV_execute, %923), i8* blockaddress(@luaV_execute, %964), i8* blockaddress(@luaV_execute, %1003), i8* blockaddress(@luaV_execute, %1044), i8* blockaddress(@luaV_execute, %1083), i8* blockaddress(@luaV_execute, %1121), i8* blockaddress(@luaV_execute, %1159), i8* blockaddress(@luaV_execute, %1199), i8* blockaddress(@luaV_execute, %1260), i8* blockaddress(@luaV_execute, %1319), i8* blockaddress(@luaV_execute, %1380), i8* blockaddress(@luaV_execute, %1439), i8* blockaddress(@luaV_execute, %1487), i8* blockaddress(@luaV_execute, %1535), i8* blockaddress(@luaV_execute, %1987), i8* blockaddress(@luaV_execute, %2029), i8* blockaddress(@luaV_execute, %2071), i8* blockaddress(@luaV_execute, %2263), i8* blockaddress(@luaV_execute, %2311), i8* blockaddress(@luaV_execute, %1595), i8* blockaddress(@luaV_execute, %1654), i8* blockaddress(@luaV_execute, %1713), i8* blockaddress(@luaV_execute, %1772), i8* blockaddress(@luaV_execute, %1831), i8* blockaddress(@luaV_execute, %1879), i8* blockaddress(@luaV_execute, %1927), i8* blockaddress(@luaV_execute, %2113), i8* blockaddress(@luaV_execute, %2163), i8* blockaddress(@luaV_execute, %2213), i8* blockaddress(@luaV_execute, %2402), i8* blockaddress(@luaV_execute, %2351), i8* blockaddress(@luaV_execute, %2452), i8* blockaddress(@luaV_execute, %2486), i8* blockaddress(@luaV_execute, %2522), i8* blockaddress(@luaV_execute, %2552), i8* blockaddress(@luaV_execute, %2569), i8* blockaddress(@luaV_execute, %2591), i8* blockaddress(@luaV_execute, %2605), i8* blockaddress(@luaV_execute, %2616), i8* blockaddress(@luaV_execute, %2632), i8* blockaddress(@luaV_execute, %2662), i8* blockaddress(@luaV_execute, %2726), i8* blockaddress(@luaV_execute, %2790), i8* blockaddress(@luaV_execute, %2822), i8* blockaddress(@luaV_execute, %2868), i8* blockaddress(@luaV_execute, %2920), i8* blockaddress(@luaV_execute, %2972), i8* blockaddress(@luaV_execute, %3024), i8* blockaddress(@luaV_execute, %3076), i8* blockaddress(@luaV_execute, %3118), i8* blockaddress(@luaV_execute, %3169), i8* blockaddress(@luaV_execute, %3190), i8* blockaddress(@luaV_execute, %3313), i8* blockaddress(@luaV_execute, %3344), i8* blockaddress(@luaV_execute, %3366), i8* blockaddress(@luaV_execute, %3399), i8* blockaddress(@luaV_execute, %3458), i8* blockaddress(@luaV_execute, %3610), i8* blockaddress(@luaV_execute, %3623), i8* blockaddress(@luaV_execute, %3646), i8* blockaddress(@luaV_execute, %3678), i8* blockaddress(@luaV_execute, %3771), i8* blockaddress(@luaV_execute, %3845), i8* blockaddress(@luaV_execute, %3921), i8* blockaddress(@luaV_execute, %3999)], align 16
@.str.164 = private unnamed_addr constant [19 x i8] c"'for' step is zero\00", align 1
@.str.165 = private unnamed_addr constant [6 x i8] c"limit\00", align 1
@.str.166 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@.str.167 = private unnamed_addr constant [14 x i8] c"initial value\00", align 1
@.str.168 = private unnamed_addr constant [26 x i8] c"attempt to perform 'n%%0'\00", align 1
@.str.169 = private unnamed_addr constant [26 x i8] c"attempt to divide by zero\00", align 1
@.str.170 = private unnamed_addr constant [29 x i8] c"perform bitwise operation on\00", align 1
@.str.171 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str.172 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@.str.173 = private unnamed_addr constant [27 x i8] c"attempt to %s a %s value%s\00", align 1
@.str.174 = private unnamed_addr constant [11 x i8] c" (%s '%s')\00", align 1
@.str.175 = private unnamed_addr constant [39 x i8] c"number%s has no integer representation\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str.177 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.179 = private unnamed_addr constant [39 x i8] c"bad 'for' %s (number expected, got %s)\00", align 1
@.str.180 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.181 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str.182 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@udatatypename = internal constant [9 x i8] c"userdata\00", align 1
@.str.183 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.184 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.185 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.186 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str.187 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@luai_ctype_ = internal unnamed_addr constant [257 x i8] c"\00\00\00\00\00\00\00\00\00\00\08\08\08\08\08\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0C\04\04\04\04\04\04\04\04\04\04\04\04\04\04\04\16\16\16\16\16\16\16\16\16\16\04\04\04\04\04\04\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\05\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 16
@.str.188 = private unnamed_addr constant [6 x i8] c".xXnN\00", align 1
@.str.189 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.190 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str.191 = private unnamed_addr constant [12 x i8] c"-0123456789\00", align 1
@.str.192 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@.str.193 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.194 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.195 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.196 = private unnamed_addr constant [43 x i8] c"invalid option '%%%c' to 'lua_pushfstring'\00", align 1
@.str.197 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.198 = private unnamed_addr constant [40 x i8] c"'__index' chain too long; possible loop\00", align 1
@dummynode_ = internal constant %union.Node { %struct.NodeKey { %union.Value zeroinitializer, i8 16, i8 0, i32 0, %union.Value zeroinitializer } }, align 8
@.str.199 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@luaO_ceillog2.log_2 = internal unnamed_addr constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str.200 = private unnamed_addr constant [43 x i8] c"'__newindex' chain too long; possible loop\00", align 1
@.str.201 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str.202 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@.str.203 = private unnamed_addr constant [7 x i8] c"binary\00", align 1
@.str.204 = private unnamed_addr constant [5 x i8] c"text\00", align 1
@.str.205 = private unnamed_addr constant [42 x i8] c"attempt to load a %s chunk (mode is '%s')\00", align 1
@.str.206 = private unnamed_addr constant [14 x i8] c"binary string\00", align 1
@.str.207 = private unnamed_addr constant [19 x i8] c"not a binary chunk\00", align 1
@.str.208 = private unnamed_addr constant [17 x i8] c"version mismatch\00", align 1
@.str.209 = private unnamed_addr constant [16 x i8] c"format mismatch\00", align 1
@.str.210 = private unnamed_addr constant [7 x i8] c"\19\93\0D\0A\1A\0A\00", align 1
@.str.211 = private unnamed_addr constant [16 x i8] c"corrupted chunk\00", align 1
@.str.212 = private unnamed_addr constant [12 x i8] c"Instruction\00", align 1
@.str.213 = private unnamed_addr constant [12 x i8] c"lua_Integer\00", align 1
@.str.214 = private unnamed_addr constant [11 x i8] c"lua_Number\00", align 1
@.str.215 = private unnamed_addr constant [24 x i8] c"integer format mismatch\00", align 1
@.str.216 = private unnamed_addr constant [22 x i8] c"float format mismatch\00", align 1
@.str.217 = private unnamed_addr constant [16 x i8] c"truncated chunk\00", align 1
@.str.218 = private unnamed_addr constant [17 x i8] c"integer overflow\00", align 1
@.str.219 = private unnamed_addr constant [27 x i8] c"%s: bad binary format (%s)\00", align 1
@.str.220 = private unnamed_addr constant [17 x i8] c"%s size mismatch\00", align 1
@.str.221 = private unnamed_addr constant [31 x i8] c"bad format for constant string\00", align 1
@.str.222 = private unnamed_addr constant [8 x i8] c"opcodes\00", align 1
@.str.223 = private unnamed_addr constant [26 x i8] c"too many %s (limit is %d)\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.225 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str.226 = private unnamed_addr constant [14 x i8] c"main function\00", align 1
@.str.227 = private unnamed_addr constant [20 x i8] c"function at line %d\00", align 1
@.str.228 = private unnamed_addr constant [32 x i8] c"too many %s (limit is %d) in %s\00", align 1
@.str.229 = private unnamed_addr constant [11 x i8] c"%s near %s\00", align 1
@.str.230 = private unnamed_addr constant [5 x i8] c"'%s'\00", align 1
@.str.231 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str.232 = private unnamed_addr constant [5 x i8] c"'%c'\00", align 1
@.str.233 = private unnamed_addr constant [8 x i8] c"'<\5C%d>'\00", align 1
@.str.234 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str.235 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str.236 = private unnamed_addr constant [8 x i8] c"comment\00", align 1
@.str.237 = private unnamed_addr constant [41 x i8] c"unfinished long %s (starting at line %d)\00", align 1
@.str.238 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str.239 = private unnamed_addr constant [24 x i8] c"invalid escape sequence\00", align 1
@.str.240 = private unnamed_addr constant [27 x i8] c"hexadecimal digit expected\00", align 1
@.str.241 = private unnamed_addr constant [12 x i8] c"missing '{'\00", align 1
@.str.242 = private unnamed_addr constant [22 x i8] c"UTF-8 value too large\00", align 1
@.str.243 = private unnamed_addr constant [12 x i8] c"missing '}'\00", align 1
@.str.244 = private unnamed_addr constant [25 x i8] c"decimal escape too large\00", align 1
@.str.245 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str.246 = private unnamed_addr constant [3 x i8] c"xX\00", align 1
@.str.247 = private unnamed_addr constant [3 x i8] c"Pp\00", align 1
@.str.248 = private unnamed_addr constant [3 x i8] c"-+\00", align 1
@.str.249 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@priority = internal unnamed_addr constant [21 x %struct.anon.10] [%struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 14, i8 13 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 6, i8 6 }, %struct.anon.10 { i8 4, i8 4 }, %struct.anon.10 { i8 5, i8 5 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 9, i8 8 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 2, i8 2 }, %struct.anon.10 { i8 1, i8 1 }], align 16
@luaK_prefix.ef = internal constant %struct.expdesc { i32 6, %union.anon.8 zeroinitializer, i32 -1, i32 -1 }, align 8
@previousinstruction.invalidinstruction = internal constant i32 -1, align 4
@.str.250 = private unnamed_addr constant [10 x i8] c"constants\00", align 1
@.str.251 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@.str.252 = private unnamed_addr constant [48 x i8] c"function or expression needs too many registers\00", align 1
@.str.253 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str.254 = private unnamed_addr constant [21 x i8] c"constructor too long\00", align 1
@.str.255 = private unnamed_addr constant [23 x i8] c"items in a constructor\00", align 1
@.str.256 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str.257 = private unnamed_addr constant [10 x i8] c"functions\00", align 1
@.str.258 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str.259 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str.260 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str.261 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str.262 = private unnamed_addr constant [13 x i8] c"labels/gotos\00", align 1
@.str.263 = private unnamed_addr constant [56 x i8] c"<goto %s> at line %d jumps into the scope of local '%s'\00", align 1
@.str.264 = private unnamed_addr constant [30 x i8] c"break outside loop at line %d\00", align 1
@.str.265 = private unnamed_addr constant [44 x i8] c"no visible label '%s' for <goto> at line %d\00", align 1
@.str.266 = private unnamed_addr constant [37 x i8] c"%s expected (to close %s at line %d)\00", align 1
@.str.267 = private unnamed_addr constant [12 x i8] c"%s expected\00", align 1
@.str.268 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str.269 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str.270 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str.271 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@forbody.forprep = internal unnamed_addr constant [2 x i32] [i32 75, i32 76], align 4
@forbody.forloop = internal unnamed_addr constant [2 x i32] [i32 74, i32 78], align 4
@.str.272 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str.273 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str.274 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str.275 = private unnamed_addr constant [14 x i8] c"(for toclose)\00", align 1
@.str.276 = private unnamed_addr constant [8 x i8] c"toclose\00", align 1
@.str.277 = private unnamed_addr constant [23 x i8] c"unknown attribute '%s'\00", align 1
@.str.278 = private unnamed_addr constant [38 x i8] c"label '%s' already defined on line %d\00", align 1
@.str.279 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.280 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@.str.281 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@.str.282 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str.283 = private unnamed_addr constant [10 x i8] c"(no name)\00", align 1
@.str.284 = private unnamed_addr constant [14 x i8] c"function '%s'\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"%s '%s'\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"main chunk\00", align 1
@.str.287 = private unnamed_addr constant [17 x i8] c"function <%s:%d>\00", align 1
@.str.288 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.289 = private unnamed_addr constant [4 x i8] c"_G.\00", align 1
@.str.290 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.291 = private unnamed_addr constant [37 x i8] c"number has no integer representation\00", align 1
@.str.292 = private unnamed_addr constant [17 x i8] c"buffer too large\00", align 1
@.str.293 = private unnamed_addr constant [40 x i8] c"not enough memory for buffer allocation\00", align 1
@.str.294 = private unnamed_addr constant [7 x i8] c"_UBOX*\00", align 1
@boxmt = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg zeroinitializer], align 16
@.str.295 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str.296 = private unnamed_addr constant [4 x i8] c"\EF\BB\BF\00", align 1
@.str.297 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@.str.298 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.299 = private unnamed_addr constant [14 x i8] c"Lua warning: \00", align 1
@.str.300 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.301 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str.302 = private unnamed_addr constant [15 x i8] c"collectgarbage\00", align 1
@.str.303 = private unnamed_addr constant [7 x i8] c"dofile\00", align 1
@.str.304 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.305 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str.306 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str.307 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str.308 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.310 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str.311 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str.312 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.313 = private unnamed_addr constant [5 x i8] c"warn\00", align 1
@.str.314 = private unnamed_addr constant [9 x i8] c"rawequal\00", align 1
@.str.315 = private unnamed_addr constant [7 x i8] c"rawlen\00", align 1
@.str.316 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str.317 = private unnamed_addr constant [7 x i8] c"rawset\00", align 1
@.str.318 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.319 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.320 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str.321 = private unnamed_addr constant [9 x i8] c"tostring\00", align 1
@.str.322 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.323 = private unnamed_addr constant [7 x i8] c"xpcall\00", align 1
@.str.324 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@luaB_collectgarbage.opts = internal constant [11 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.325, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.326, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.329, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.330, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.331, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i32 0, i32 0), i8* null], align 16
@.str.325 = private unnamed_addr constant [5 x i8] c"stop\00", align 1
@.str.326 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str.327 = private unnamed_addr constant [8 x i8] c"collect\00", align 1
@.str.328 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"setpause\00", align 1
@.str.330 = private unnamed_addr constant [11 x i8] c"setstepmul\00", align 1
@.str.331 = private unnamed_addr constant [10 x i8] c"isrunning\00", align 1
@.str.332 = private unnamed_addr constant [13 x i8] c"generational\00", align 1
@.str.333 = private unnamed_addr constant [12 x i8] c"incremental\00", align 1
@luaB_collectgarbage.optsnum = internal unnamed_addr constant [10 x i32] [i32 0, i32 1, i32 2, i32 3, i32 5, i32 6, i32 7, i32 9, i32 10, i32 11], align 16
@.str.334 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str.335 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str.336 = private unnamed_addr constant [8 x i8] c"=(load)\00", align 1
@.str.337 = private unnamed_addr constant [26 x i8] c"too many nested functions\00", align 1
@.str.338 = private unnamed_addr constant [37 x i8] c"reader function must return a string\00", align 1
@.str.339 = private unnamed_addr constant [8 x i8] c"__pairs\00", align 1
@.str.341 = private unnamed_addr constant [16 x i8] c"table or string\00", align 1
@.str.342 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@.str.343 = private unnamed_addr constant [13 x i8] c"nil or table\00", align 1
@.str.344 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str.345 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str.346 = private unnamed_addr constant [7 x i8] c" \0C\0A\0D\09\0B\00", align 1
@.str.347 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str.348 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@.str.349 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str.350 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str.351 = private unnamed_addr constant [5 x i8] c"wrap\00", align 1
@.str.352 = private unnamed_addr constant [6 x i8] c"yield\00", align 1
@.str.353 = private unnamed_addr constant [12 x i8] c"isyieldable\00", align 1
@.str.354 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@.str.355 = private unnamed_addr constant [29 x i8] c"too many arguments to resume\00", align 1
@.str.356 = private unnamed_addr constant [27 x i8] c"too many results to resume\00", align 1
@statname = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.357, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.358, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.359, i32 0, i32 0)], align 16
@.str.357 = private unnamed_addr constant [5 x i8] c"dead\00", align 1
@.str.358 = private unnamed_addr constant [10 x i8] c"suspended\00", align 1
@.str.359 = private unnamed_addr constant [7 x i8] c"normal\00", align 1
@.str.360 = private unnamed_addr constant [27 x i8] c"cannot kill a %s coroutine\00", align 1
@.str.361 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.362 = private unnamed_addr constant [13 x i8] c"getuservalue\00", align 1
@.str.363 = private unnamed_addr constant [8 x i8] c"gethook\00", align 1
@.str.364 = private unnamed_addr constant [8 x i8] c"getinfo\00", align 1
@.str.365 = private unnamed_addr constant [9 x i8] c"getlocal\00", align 1
@.str.366 = private unnamed_addr constant [12 x i8] c"getregistry\00", align 1
@.str.367 = private unnamed_addr constant [11 x i8] c"getupvalue\00", align 1
@.str.368 = private unnamed_addr constant [12 x i8] c"upvaluejoin\00", align 1
@.str.369 = private unnamed_addr constant [10 x i8] c"upvalueid\00", align 1
@.str.370 = private unnamed_addr constant [13 x i8] c"setuservalue\00", align 1
@.str.371 = private unnamed_addr constant [8 x i8] c"sethook\00", align 1
@.str.372 = private unnamed_addr constant [9 x i8] c"setlocal\00", align 1
@.str.373 = private unnamed_addr constant [11 x i8] c"setupvalue\00", align 1
@.str.374 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str.375 = private unnamed_addr constant [12 x i8] c"lua_debug> \00", align 1
@.str.376 = private unnamed_addr constant [6 x i8] c"cont\0A\00", align 1
@.str.377 = private unnamed_addr constant [17 x i8] c"=(debug command)\00", align 1
@.str.378 = private unnamed_addr constant [14 x i8] c"external hook\00", align 1
@HOOKKEY = internal constant i32 0, align 4
@hookf.hooknames = internal unnamed_addr constant [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.380, i32 0, i32 0)], align 16
@.str.379 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str.380 = private unnamed_addr constant [10 x i8] c"tail call\00", align 1
@.str.381 = private unnamed_addr constant [8 x i8] c"flnSrtu\00", align 1
@.str.382 = private unnamed_addr constant [4 x i8] c">%s\00", align 1
@.str.383 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.384 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str.385 = private unnamed_addr constant [10 x i8] c"short_src\00", align 1
@.str.386 = private unnamed_addr constant [12 x i8] c"linedefined\00", align 1
@.str.387 = private unnamed_addr constant [16 x i8] c"lastlinedefined\00", align 1
@.str.388 = private unnamed_addr constant [5 x i8] c"what\00", align 1
@.str.389 = private unnamed_addr constant [12 x i8] c"currentline\00", align 1
@.str.390 = private unnamed_addr constant [5 x i8] c"nups\00", align 1
@.str.391 = private unnamed_addr constant [8 x i8] c"nparams\00", align 1
@.str.392 = private unnamed_addr constant [9 x i8] c"isvararg\00", align 1
@.str.393 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.394 = private unnamed_addr constant [9 x i8] c"namewhat\00", align 1
@.str.395 = private unnamed_addr constant [10 x i8] c"ftransfer\00", align 1
@.str.396 = private unnamed_addr constant [10 x i8] c"ntransfer\00", align 1
@.str.397 = private unnamed_addr constant [11 x i8] c"istailcall\00", align 1
@.str.398 = private unnamed_addr constant [12 x i8] c"activelines\00", align 1
@.str.399 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.400 = private unnamed_addr constant [19 x i8] c"level out of range\00", align 1
@.str.401 = private unnamed_addr constant [22 x i8] c"Lua function expected\00", align 1
@.str.402 = private unnamed_addr constant [22 x i8] c"invalid upvalue index\00", align 1
@.str.403 = private unnamed_addr constant [2 x i8] c"k\00", align 1
@.str.404 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.405 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.406 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.407 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.408 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str.409 = private unnamed_addr constant [8 x i8] c"tmpfile\00", align 1
@.str.410 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.411 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@.str.412 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@.str.413 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@.str.414 = private unnamed_addr constant [27 x i8] c"cannot open file '%s' (%s)\00", align 1
@.str.415 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str.416 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str.417 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str.418 = private unnamed_addr constant [3 x i8] c"00\00", align 1
@.str.419 = private unnamed_addr constant [3 x i8] c"pP\00", align 1
@.str.420 = private unnamed_addr constant [3 x i8] c"eE\00", align 1
@.str.421 = private unnamed_addr constant [13 x i8] c"invalid mode\00", align 1
@.str.422 = private unnamed_addr constant [4 x i8] c"rwa\00", align 1
@.str.423 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@.str.424 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.425 = private unnamed_addr constant [22 x i8] c"'popen' not supported\00", align 1
@.str.426 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str.427 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@flib = internal constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @f_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @f_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @f_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @f_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.428, i32 0, i32 0), i32 (%struct.lua_State*)* @f_seek }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.429, i32 0, i32 0), i32 (%struct.lua_State*)* @f_setvbuf }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @f_write }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i32 (%struct.lua_State*)* @f_tostring }, %struct.luaL_Reg zeroinitializer], align 16
@.str.428 = private unnamed_addr constant [5 x i8] c"seek\00", align 1
@.str.429 = private unnamed_addr constant [8 x i8] c"setvbuf\00", align 1
@f_seek.mode = internal unnamed_addr constant [3 x i32] [i32 0, i32 1, i32 2], align 4
@f_seek.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.430, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* null], align 16
@.str.430 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.431 = private unnamed_addr constant [4 x i8] c"cur\00", align 1
@f_setvbuf.mode = internal unnamed_addr constant [3 x i32] [i32 2, i32 0, i32 1], align 4
@f_setvbuf.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.433, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.434, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* null], align 16
@.str.433 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.434 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str.435 = private unnamed_addr constant [14 x i8] c"file (closed)\00", align 1
@.str.436 = private unnamed_addr constant [10 x i8] c"file (%p)\00", align 1
@.str.437 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@.str.438 = private unnamed_addr constant [4 x i8] c"abs\00", align 1
@.str.439 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str.440 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str.441 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str.442 = private unnamed_addr constant [5 x i8] c"ceil\00", align 1
@.str.443 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str.444 = private unnamed_addr constant [4 x i8] c"deg\00", align 1
@.str.445 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str.446 = private unnamed_addr constant [10 x i8] c"tointeger\00", align 1
@.str.447 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str.448 = private unnamed_addr constant [5 x i8] c"fmod\00", align 1
@.str.449 = private unnamed_addr constant [4 x i8] c"ult\00", align 1
@.str.450 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str.451 = private unnamed_addr constant [4 x i8] c"max\00", align 1
@.str.452 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str.453 = private unnamed_addr constant [5 x i8] c"modf\00", align 1
@.str.454 = private unnamed_addr constant [4 x i8] c"rad\00", align 1
@.str.455 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str.456 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str.457 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str.458 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.459 = private unnamed_addr constant [11 x i8] c"randomseed\00", align 1
@.str.460 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
@.str.461 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.462 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@randfuncs = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* @math_random }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* @math_randomseed }, %struct.luaL_Reg zeroinitializer], align 16
@.str.463 = private unnamed_addr constant [26 x i8] c"wrong number of arguments\00", align 1
@.str.464 = private unnamed_addr constant [18 x i8] c"interval is empty\00", align 1
@CLIBS = internal constant i32 0, align 4
@.str.465 = private unnamed_addr constant [8 x i8] c"loadlib\00", align 1
@.str.466 = private unnamed_addr constant [11 x i8] c"searchpath\00", align 1
@.str.467 = private unnamed_addr constant [10 x i8] c"searchers\00", align 1
@.str.468 = private unnamed_addr constant [7 x i8] c"absent\00", align 1
@.str.469 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.470 = private unnamed_addr constant [59 x i8] c"dynamic libraries not enabled; check your Lua installation\00", align 1
@.str.471 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.472 = private unnamed_addr constant [2 x i8] c";\00", align 1
@.str.473 = private unnamed_addr constant [12 x i8] c"\0A\09no file '\00", align 1
@.str.474 = private unnamed_addr constant [13 x i8] c"'\0A\09no file '\00", align 1
@.str.475 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@createsearcherstable.searchers = internal unnamed_addr constant [5 x i32 (%struct.lua_State*)*] [i32 (%struct.lua_State*)* @searcher_preload, i32 (%struct.lua_State*)* @searcher_Lua, i32 (%struct.lua_State*)* @searcher_C, i32 (%struct.lua_State*)* @searcher_Croot, i32 (%struct.lua_State*)* null], align 16
@.str.476 = private unnamed_addr constant [33 x i8] c"\0A\09no field package.preload['%s']\00", align 1
@.str.477 = private unnamed_addr constant [10 x i8] c":preload:\00", align 1
@.str.478 = private unnamed_addr constant [30 x i8] c"'package.%s' must be a string\00", align 1
@.str.479 = private unnamed_addr constant [46 x i8] c"error loading module '%s' from file '%s':\0A\09%s\00", align 1
@.str.480 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.481 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.482 = private unnamed_addr constant [11 x i8] c"luaopen_%s\00", align 1
@.str.483 = private unnamed_addr constant [30 x i8] c"\0A\09no module '%s' in file '%s'\00", align 1
@.str.484 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@.str.485 = private unnamed_addr constant [5 x i8] c"_5_4\00", align 1
@.str.486 = private unnamed_addr constant [3 x i8] c";;\00", align 1
@.str.487 = private unnamed_addr constant [10 x i8] c"LUA_NOENV\00", align 1
@.str.488 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.489 = private unnamed_addr constant [36 x i8] c"'package.searchers' must be a table\00", align 1
@.str.490 = private unnamed_addr constant [25 x i8] c"module '%s' not found:%s\00", align 1
@.str.491 = private unnamed_addr constant [6 x i8] c"clock\00", align 1
@.str.492 = private unnamed_addr constant [5 x i8] c"date\00", align 1
@.str.493 = private unnamed_addr constant [9 x i8] c"difftime\00", align 1
@.str.494 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str.495 = private unnamed_addr constant [7 x i8] c"getenv\00", align 1
@.str.496 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.497 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@.str.498 = private unnamed_addr constant [10 x i8] c"setlocale\00", align 1
@.str.499 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str.500 = private unnamed_addr constant [8 x i8] c"tmpname\00", align 1
@.str.501 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.502 = private unnamed_addr constant [55 x i8] c"time result cannot be represented in this installation\00", align 1
@.str.503 = private unnamed_addr constant [3 x i8] c"*t\00", align 1
@.str.505 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
@.str.506 = private unnamed_addr constant [5 x i8] c"hour\00", align 1
@.str.507 = private unnamed_addr constant [4 x i8] c"day\00", align 1
@.str.508 = private unnamed_addr constant [6 x i8] c"month\00", align 1
@.str.509 = private unnamed_addr constant [5 x i8] c"year\00", align 1
@.str.510 = private unnamed_addr constant [5 x i8] c"wday\00", align 1
@.str.511 = private unnamed_addr constant [5 x i8] c"yday\00", align 1
@.str.512 = private unnamed_addr constant [6 x i8] c"isdst\00", align 1
@.str.513 = private unnamed_addr constant [78 x i8] c"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy\00", align 1
@.str.514 = private unnamed_addr constant [36 x i8] c"invalid conversion specifier '%%%s'\00", align 1
@os_setlocale.cat = internal unnamed_addr constant [6 x i32] [i32 6, i32 3, i32 0, i32 4, i32 1, i32 2], align 16
@os_setlocale.catnames = internal constant [7 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.516, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.517, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.518, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.519, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i8* null], align 16
@.str.515 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.516 = private unnamed_addr constant [8 x i8] c"collate\00", align 1
@.str.517 = private unnamed_addr constant [6 x i8] c"ctype\00", align 1
@.str.518 = private unnamed_addr constant [9 x i8] c"monetary\00", align 1
@.str.519 = private unnamed_addr constant [8 x i8] c"numeric\00", align 1
@.str.520 = private unnamed_addr constant [29 x i8] c"field '%s' is not an integer\00", align 1
@.str.521 = private unnamed_addr constant [33 x i8] c"field '%s' missing in date table\00", align 1
@.str.522 = private unnamed_addr constant [27 x i8] c"field '%s' is out-of-bound\00", align 1
@.str.523 = private unnamed_addr constant [37 x i8] c"unable to generate a unique filename\00", align 1
@.str.524 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str.525 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str.526 = private unnamed_addr constant [5 x i8] c"dump\00", align 1
@.str.527 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.528 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str.529 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str.530 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str.531 = private unnamed_addr constant [4 x i8] c"len\00", align 1
@.str.532 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str.533 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str.534 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str.535 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str.536 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.537 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str.538 = private unnamed_addr constant [5 x i8] c"pack\00", align 1
@.str.539 = private unnamed_addr constant [9 x i8] c"packsize\00", align 1
@.str.540 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str.541 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str.542 = private unnamed_addr constant [19 x i8] c"value out of range\00", align 1
@.str.543 = private unnamed_addr constant [30 x i8] c"unable to dump given function\00", align 1
@.str.544 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str.545 = private unnamed_addr constant [20 x i8] c"pattern too complex\00", align 1
@.str.546 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str.547 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str.548 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str.549 = private unnamed_addr constant [47 x i8] c"malformed pattern (missing arguments to '%%b')\00", align 1
@.str.550 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str.551 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str.552 = private unnamed_addr constant [27 x i8] c"invalid capture index %%%d\00", align 1
@.str.553 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str.554 = private unnamed_addr constant [3 x i8] c"ll\00", align 1
@.str.555 = private unnamed_addr constant [38 x i8] c"specifier '%%q' cannot have modifiers\00", align 1
@.str.556 = private unnamed_addr constant [22 x i8] c"string contains zeros\00", align 1
@.str.557 = private unnamed_addr constant [36 x i8] c"invalid conversion '%s' to 'format'\00", align 1
@.str.559 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str.560 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str.561 = private unnamed_addr constant [7 x i8] c"0x%llx\00", align 1
@.str.562 = private unnamed_addr constant [26 x i8] c"value has no literal form\00", align 1
@.str.563 = private unnamed_addr constant [4 x i8] c"\5C%d\00", align 1
@.str.564 = private unnamed_addr constant [6 x i8] c"\5C%03d\00", align 1
@.str.565 = private unnamed_addr constant [7 x i8] c"1e9999\00", align 1
@.str.566 = private unnamed_addr constant [8 x i8] c"-1e9999\00", align 1
@.str.567 = private unnamed_addr constant [6 x i8] c"(0/0)\00", align 1
@.str.568 = private unnamed_addr constant [3 x i8] c"%a\00", align 1
@.str.569 = private unnamed_addr constant [22 x i8] c"string/function/table\00", align 1
@.str.570 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str.571 = private unnamed_addr constant [42 x i8] c"invalid use of '%c' in replacement string\00", align 1
@.str.572 = private unnamed_addr constant [27 x i8] c"resulting string too large\00", align 1
@.str.573 = private unnamed_addr constant [18 x i8] c"unsigned overflow\00", align 1
@.str.574 = private unnamed_addr constant [30 x i8] c"string longer than given size\00", align 1
@.str.575 = private unnamed_addr constant [41 x i8] c"string length does not fit in given size\00", align 1
@.str.576 = private unnamed_addr constant [35 x i8] c"invalid next option for option 'X'\00", align 1
@.str.577 = private unnamed_addr constant [41 x i8] c"format asks for alignment not power of 2\00", align 1
@.str.578 = private unnamed_addr constant [35 x i8] c"missing size for format option 'c'\00", align 1
@.str.579 = private unnamed_addr constant [27 x i8] c"invalid format option '%c'\00", align 1
@.str.580 = private unnamed_addr constant [40 x i8] c"integral size (%d) out of limits [1,%d]\00", align 1
@.str.581 = private unnamed_addr constant [23 x i8] c"variable-length format\00", align 1
@.str.582 = private unnamed_addr constant [24 x i8] c"format result too large\00", align 1
@.str.583 = private unnamed_addr constant [31 x i8] c"initial position out of string\00", align 1
@.str.584 = private unnamed_addr constant [22 x i8] c"data string too short\00", align 1
@.str.585 = private unnamed_addr constant [17 x i8] c"too many results\00", align 1
@.str.586 = private unnamed_addr constant [33 x i8] c"unfinished string for format 'z'\00", align 1
@.str.587 = private unnamed_addr constant [46 x i8] c"%d-byte integer does not fit into Lua Integer\00", align 1
@stringmetamethods = internal constant [10 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_add }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mul }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mod }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_pow }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_div }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_idiv }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_unm }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.588 = private unnamed_addr constant [33 x i8] c"attempt to %s a '%s' with a '%s'\00", align 1
@.str.589 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.590 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.591 = private unnamed_addr constant [5 x i8] c"move\00", align 1
@.str.592 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str.593 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str.594 = private unnamed_addr constant [23 x i8] c"position out of bounds\00", align 1
@.str.595 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str.596 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str.597 = private unnamed_addr constant [26 x i8] c"too many elements to move\00", align 1
@.str.598 = private unnamed_addr constant [24 x i8] c"destination wrap around\00", align 1
@.str.599 = private unnamed_addr constant [14 x i8] c"array too big\00", align 1
@.str.600 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@.str.601 = private unnamed_addr constant [7 x i8] c"offset\00", align 1
@.str.602 = private unnamed_addr constant [10 x i8] c"codepoint\00", align 1
@.str.603 = private unnamed_addr constant [6 x i8] c"codes\00", align 1
@.str.604 = private unnamed_addr constant [22 x i8] c"position out of range\00", align 1
@.str.605 = private unnamed_addr constant [40 x i8] c"initial position is a continuation byte\00", align 1
@.str.606 = private unnamed_addr constant [13 x i8] c"out of range\00", align 1
@.str.607 = private unnamed_addr constant [19 x i8] c"invalid UTF-8 code\00", align 1
@utf8_decode.limits = internal unnamed_addr constant [6 x i32] [i32 -1, i32 128, i32 2048, i32 65536, i32 2097152, i32 67108864], align 16
@.str.608 = private unnamed_addr constant [3 x i8] c"%U\00", align 1
@.str.609 = private unnamed_addr constant [29 x i8] c"final position out of string\00", align 1
@.str.610 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@.str.611 = private unnamed_addr constant [10 x i8] c"coroutine\00", align 1
@.str.612 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.613 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str.614 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@.str.615 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str.616 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@progname = internal unnamed_addr global i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.617, i64 0, i64 0), align 8
@.str.617 = private unnamed_addr constant [4 x i8] c"lua\00", align 1
@.str.618 = private unnamed_addr constant [21 x i8] c"'%s' needs argument\0A\00", align 1
@.str.619 = private unnamed_addr constant [26 x i8] c"unrecognized option '%s'\0A\00", align 1
@.str.620 = private unnamed_addr constant [365 x i8] c"usage: %s [options] [script [args]]\0AAvailable options are:\0A  -e stat  execute string 'stat'\0A  -i       enter interactive mode after executing 'script'\0A  -l name  require library 'name' into global 'name'\0A  -v       show version information\0A  -E       ignore environment variables\0A  --       stop handling options\0A  -        stop handling options and execute stdin\0A\00", align 1
@.str.621 = private unnamed_addr constant [52 x i8] c"Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio\00", align 1
@.str.622 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str.623 = private unnamed_addr constant [14 x i8] c"=LUA_INIT_5_4\00", align 1
@.str.624 = private unnamed_addr constant [10 x i8] c"=LUA_INIT\00", align 1
@globalL = internal unnamed_addr global %struct.lua_State* null, align 8
@.str.625 = private unnamed_addr constant [29 x i8] c"(error object is a %s value)\00", align 1
@.str.626 = private unnamed_addr constant [13 x i8] c"interrupted!\00", align 1
@.str.627 = private unnamed_addr constant [16 x i8] c"=(command line)\00", align 1
@.str.628 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str.629 = private unnamed_addr constant [21 x i8] c"'arg' is not a table\00", align 1
@.str.630 = private unnamed_addr constant [29 x i8] c"too many arguments to script\00", align 1
@.str.631 = private unnamed_addr constant [10 x i8] c"return %s\00", align 1
@.str.632 = private unnamed_addr constant [8 x i8] c"_PROMPT\00", align 1
@.str.633 = private unnamed_addr constant [9 x i8] c"_PROMPT2\00", align 1
@.str.634 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str.635 = private unnamed_addr constant [4 x i8] c">> \00", align 1
@.str.636 = private unnamed_addr constant [11 x i8] c"return %s;\00", align 1
@.str.637 = private unnamed_addr constant [26 x i8] c"too many results to print\00", align 1
@.str.638 = private unnamed_addr constant [27 x i8] c"error calling 'print' (%s)\00", align 1

; Function Attrs: minsize nounwind optsize uwtable
define nonnull %struct.lua_State* @lua_newthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %5 = load i64, i64* %4, align 8, !tbaa !11
  %6 = icmp sgt i64 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %8

; <label>:8:                                      ; preds = %7, %1
  %9 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* nonnull %0, i64 208, i32 8) #16
  %10 = getelementptr inbounds i8, i8* %9, i64 8
  %11 = bitcast i8* %10 to %struct.lua_State*
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %13 = load i8, i8* %12, align 4, !tbaa !15
  %14 = and i8 %13, 24
  %15 = getelementptr inbounds i8, i8* %9, i64 17
  store i8 %14, i8* %15, align 1, !tbaa !16
  %16 = getelementptr inbounds i8, i8* %9, i64 16
  store i8 8, i8* %16, align 8, !tbaa !17
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %18 = bitcast %struct.GCObject** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !18
  %20 = bitcast i8* %10 to i64*
  store i64 %19, i64* %20, align 8, !tbaa !19
  %21 = bitcast %struct.GCObject** %17 to i8**
  store i8* %10, i8** %21, align 8, !tbaa !18
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = bitcast %union.StackValue** %22 to %struct.TValue**
  %24 = load %struct.TValue*, %struct.TValue** %23, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i8**
  store i8* %10, i8** %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 72, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %22, align 8, !tbaa !20
  tail call fastcc void @preinit_thread(%struct.lua_State* nonnull %11, %struct.global_State* %3) #16
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %30 = load i32, i32* %29, align 8, !tbaa !23
  %31 = getelementptr inbounds i8, i8* %9, i64 200
  %32 = bitcast i8* %31 to i32*
  store i32 %30, i32* %32, align 8, !tbaa !23
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %34 = load i32, i32* %33, align 8, !tbaa !24
  %35 = getelementptr inbounds i8, i8* %9, i64 192
  %36 = bitcast i8* %35 to i32*
  store i32 %34, i32* %36, align 8, !tbaa !24
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %38 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %37, align 8, !tbaa !25
  %39 = getelementptr inbounds i8, i8* %9, i64 168
  %40 = bitcast i8* %39 to void (%struct.lua_State*, %struct.lua_Debug*)**
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %38, void (%struct.lua_State*, %struct.lua_Debug*)** %40, align 8, !tbaa !25
  %41 = getelementptr inbounds i8, i8* %9, i64 196
  %42 = bitcast i8* %41 to i32*
  store i32 %34, i32* %42, align 4, !tbaa !26
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %44 = bitcast %struct.lua_State** %43 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !27
  %46 = getelementptr inbounds i8, i8* %45, i64 -8
  %47 = bitcast i8* %46 to i64*
  %48 = bitcast i8* %9 to i64*
  %49 = load i64, i64* %47, align 1
  store i64 %49, i64* %48, align 1
  tail call fastcc void @stack_init(%struct.lua_State* nonnull %11, %struct.lua_State* nonnull %0) #16
  ret %struct.lua_State* %11
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_step(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 15
  %5 = load i8, i8* %4, align 1, !tbaa !28
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %133, label %7

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 12
  %9 = load i8, i8* %8, align 2, !tbaa !29
  %10 = icmp eq i8 %9, 1
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 5
  %12 = load i64, i64* %11, align 8, !tbaa !30
  %13 = icmp eq i64 %12, 0
  br i1 %10, label %15, label %14

; <label>:14:                                     ; preds = %7
  br i1 %13, label %98, label %17

; <label>:15:                                     ; preds = %7
  br i1 %13, label %30, label %16

; <label>:16:                                     ; preds = %15
  tail call fastcc void @enterinc(%struct.global_State* nonnull %3) #17
  br label %17

; <label>:17:                                     ; preds = %14, %16
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* nonnull %0, i32 1) #17
  %18 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0) #17
  %19 = lshr i64 %12, 3
  %20 = add i64 %19, %12
  %21 = icmp ult i64 %18, %20
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call fastcc void @atomic2gen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3) #17
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %3) #17
  br label %133

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %25 = load i64, i64* %24, align 8, !tbaa !31
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %27 = load i64, i64* %26, align 8, !tbaa !11
  %28 = add nsw i64 %27, %25
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  store i64 %28, i64* %29, align 8, !tbaa !32
  tail call fastcc void @entersweep(%struct.lua_State* nonnull %0) #17
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* nonnull %0, i32 256) #17
  tail call fastcc void @setpause(%struct.global_State* nonnull %3) #17
  store i64 %18, i64* %11, align 8, !tbaa !30
  br label %133

; <label>:30:                                     ; preds = %15
  %31 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  %32 = load i64, i64* %31, align 8, !tbaa !32
  %33 = udiv i64 %32, 100
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 14
  %35 = load i8, i8* %34, align 8, !tbaa !33
  %36 = zext i8 %35 to i64
  %37 = shl nuw nsw i64 %36, 2
  %38 = mul i64 %37, %33
  %39 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %40 = load i64, i64* %39, align 8, !tbaa !11
  %41 = icmp sgt i64 %40, 0
  br i1 %41, label %42, label %58

; <label>:42:                                     ; preds = %30
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %44 = load i64, i64* %43, align 8, !tbaa !31
  %45 = add nsw i64 %44, %40
  %46 = add i64 %38, %32
  %47 = icmp ugt i64 %45, %46
  br i1 %47, label %48, label %58

; <label>:48:                                     ; preds = %42
  %49 = tail call fastcc i64 @fullgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3) #17
  %50 = load i64, i64* %43, align 8, !tbaa !31
  %51 = load i64, i64* %39, align 8, !tbaa !11
  %52 = add nsw i64 %51, %50
  %53 = lshr exact i64 %38, 1
  %54 = add i64 %53, %32
  %55 = icmp ult i64 %52, %54
  br i1 %55, label %56, label %57

; <label>:56:                                     ; preds = %48
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %3) #17
  br label %133

; <label>:57:                                     ; preds = %48
  store i64 %49, i64* %11, align 8, !tbaa !30
  tail call fastcc void @setpause(%struct.global_State* nonnull %3) #17
  br label %133

; <label>:58:                                     ; preds = %42, %30
  %59 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 30
  %60 = load %struct.GCObject*, %struct.GCObject** %59, align 8, !tbaa !34
  %61 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 32
  %62 = load %struct.GCObject*, %struct.GCObject** %61, align 8, !tbaa !35
  tail call fastcc void @markold(%struct.global_State* nonnull %3, %struct.GCObject* %60, %struct.GCObject* %62) #17
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %64 = load %struct.GCObject*, %struct.GCObject** %63, align 8, !tbaa !36
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 35
  %66 = load %struct.GCObject*, %struct.GCObject** %65, align 8, !tbaa !37
  tail call fastcc void @markold(%struct.global_State* nonnull %3, %struct.GCObject* %64, %struct.GCObject* %66) #17
  %67 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0) #17
  %68 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %69 = load %struct.GCObject*, %struct.GCObject** %59, align 8, !tbaa !34
  %70 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %68, %struct.GCObject* %69) #17
  %71 = load %struct.GCObject*, %struct.GCObject** %61, align 8, !tbaa !35
  %72 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** %70, %struct.GCObject* %71) #17
  %73 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 31
  %74 = bitcast %struct.GCObject** %73 to i64*
  %75 = load i64, i64* %74, align 8, !tbaa !38
  %76 = bitcast %struct.GCObject** %61 to i64*
  store i64 %75, i64* %76, align 8, !tbaa !35
  %77 = bitcast %struct.GCObject** %70 to i64*
  %78 = load i64, i64* %77, align 8, !tbaa !39
  store i64 %78, i64* %74, align 8, !tbaa !38
  %79 = bitcast %struct.GCObject** %68 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !18
  %81 = bitcast %struct.GCObject** %59 to i64*
  store i64 %80, i64* %81, align 8, !tbaa !34
  %82 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 33
  %83 = load %struct.GCObject*, %struct.GCObject** %82, align 8, !tbaa !40
  %84 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %63, %struct.GCObject* %83) #17
  %85 = load %struct.GCObject*, %struct.GCObject** %65, align 8, !tbaa !37
  %86 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** %84, %struct.GCObject* %85) #17
  %87 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 34
  %88 = bitcast %struct.GCObject** %87 to i64*
  %89 = load i64, i64* %88, align 8, !tbaa !41
  %90 = bitcast %struct.GCObject** %65 to i64*
  store i64 %89, i64* %90, align 8, !tbaa !37
  %91 = bitcast %struct.GCObject** %84 to i64*
  %92 = load i64, i64* %91, align 8, !tbaa !39
  store i64 %92, i64* %88, align 8, !tbaa !41
  %93 = bitcast %struct.GCObject** %63 to i64*
  %94 = load i64, i64* %93, align 8, !tbaa !36
  %95 = bitcast %struct.GCObject** %82 to i64*
  store i64 %94, i64* %95, align 8, !tbaa !40
  %96 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %97 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %96, %struct.GCObject* null) #17
  tail call fastcc void @finishgencycle(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3) #17
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %3) #17
  store i64 %32, i64* %31, align 8, !tbaa !32
  br label %133

; <label>:98:                                     ; preds = %14
  %99 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 18
  %100 = load i8, i8* %99, align 4, !tbaa !42
  %101 = zext i8 %100 to i64
  %102 = shl nuw nsw i64 %101, 2
  %103 = or i64 %102, 1
  %104 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %105 = load i64, i64* %104, align 8, !tbaa !11
  %106 = lshr i64 %105, 4
  %107 = mul i64 %103, %106
  %108 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 19
  %109 = load i8, i8* %108, align 1, !tbaa !43
  %110 = icmp ult i8 %109, 63
  br i1 %110, label %111, label %117

; <label>:111:                                    ; preds = %98
  %112 = zext i8 %109 to i64
  %113 = shl i64 1, %112
  %114 = lshr i64 %113, 4
  %115 = sub nsw i64 0, %103
  %116 = mul i64 %114, %115
  br label %117

; <label>:117:                                    ; preds = %111, %98
  %118 = phi i64 [ %116, %111 ], [ -9223372036854775807, %98 ]
  %119 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  br label %120

; <label>:120:                                    ; preds = %127, %117
  %121 = phi i64 [ %107, %117 ], [ %123, %127 ]
  %122 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %123 = sub i64 %121, %122
  %124 = icmp sgt i64 %123, %118
  %125 = load i8, i8* %119, align 1, !tbaa !44
  %126 = icmp eq i8 %125, 8
  br i1 %124, label %127, label %128

; <label>:127:                                    ; preds = %120
  br i1 %126, label %129, label %120

; <label>:128:                                    ; preds = %120
  br i1 %126, label %129, label %130

; <label>:129:                                    ; preds = %127, %128
  tail call fastcc void @setpause(%struct.global_State* nonnull %3) #17
  br label %133

; <label>:130:                                    ; preds = %128
  %131 = sdiv i64 %123, %103
  %132 = shl i64 %131, 4
  tail call fastcc void @luaE_setdebt(%struct.global_State* nonnull %3, i64 %132) #17
  br label %133

; <label>:133:                                    ; preds = %130, %129, %58, %57, %56, %23, %22, %1
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaM_malloc_(%struct.lua_State*, i64, i32) unnamed_addr #0 {
  %4 = icmp eq i64 %1, 0
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %9 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %8, align 8, !tbaa !45
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %11 = load i8*, i8** %10, align 8, !tbaa !46
  %12 = sext i32 %2 to i64
  %13 = tail call i8* %9(i8* %11, i8* null, i64 %12, i64 %1) #17
  %14 = icmp eq i8* %13, null
  br i1 %14, label %15, label %19, !prof !47

; <label>:15:                                     ; preds = %5
  %16 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* null, i64 %12, i64 %1) #16
  %17 = icmp eq i8* %16, null
  br i1 %17, label %18, label %19

; <label>:18:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:19:                                     ; preds = %15, %5
  %20 = phi i8* [ %16, %15 ], [ %13, %5 ]
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %22 = load i64, i64* %21, align 8, !tbaa !11
  %23 = add i64 %22, %1
  store i64 %23, i64* %21, align 8, !tbaa !11
  br label %24

; <label>:24:                                     ; preds = %3, %19
  %25 = phi i8* [ %20, %19 ], [ null, %3 ]
  ret i8* %25
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @preinit_thread(%struct.lua_State*, %struct.global_State*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  store %struct.global_State* %1, %struct.global_State** %3, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !48
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* null, %struct.CallInfo** %5, align 8, !tbaa !49
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  store i16 0, i16* %6, align 4, !tbaa !50
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  store i32 0, i32* %7, align 4, !tbaa !51
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 14
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !52
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  store %struct.lua_longjmp* null, %struct.lua_longjmp** %9, align 8, !tbaa !53
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 0, i32* %10, align 8, !tbaa !54
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %11, align 8, !tbaa !25
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  store i32 0, i32* %12, align 8, !tbaa !23
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  store i32 0, i32* %13, align 8, !tbaa !24
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  store i8 1, i8* %14, align 1, !tbaa !55
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  store i32 0, i32* %15, align 4, !tbaa !26
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  store %struct.UpVal* null, %struct.UpVal** %16, align 8, !tbaa !56
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 0, i8* %17, align 2, !tbaa !57
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 0, i64* %18, align 8, !tbaa !58
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @stack_init(%struct.lua_State*, %struct.lua_State*) unnamed_addr #0 {
  %3 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %1, i64 640, i32 0) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = bitcast %union.StackValue** %4 to i8**
  store i8* %3, i8** %5, align 8, !tbaa !48
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  store i32 40, i32* %6, align 4, !tbaa !51
  %7 = bitcast i8* %3 to %union.StackValue*
  br label %8

; <label>:8:                                      ; preds = %12, %2
  %9 = phi %union.StackValue* [ %15, %12 ], [ %7, %2 ]
  %10 = phi i64 [ %14, %12 ], [ 0, %2 ]
  %11 = icmp eq i64 %10, 40
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %8
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %10, i32 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = add nuw nsw i64 %10, 1
  %15 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !48
  br label %8

; <label>:16:                                     ; preds = %8
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %9, %union.StackValue** %17, align 8, !tbaa !20
  %18 = load i32, i32* %6, align 4, !tbaa !51
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %19
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 -5
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %21, %union.StackValue** %22, align 8, !tbaa !59
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 2
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  %26 = bitcast %struct.CallInfo** %24 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %26, i8 0, i64 16, i32 8, i1 false)
  store i16 2, i16* %25, align 2, !tbaa !60
  %27 = ptrtoint %union.StackValue* %9 to i64
  %28 = bitcast %struct.CallInfo* %23 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !61
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* null, i32 (%struct.lua_State*, i32, i64)** %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 6
  store i16 0, i16* %30, align 4, !tbaa !62
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0, i32 1
  store i8 0, i8* %31, align 8, !tbaa !21
  %32 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 1
  store %union.StackValue* %33, %union.StackValue** %17, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 21
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %34, %union.StackValue** %35, align 8, !tbaa !63
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %23, %struct.CallInfo** %36, align 8, !tbaa !49
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_resetthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !48
  %5 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4, i32 -2) #16
  %6 = bitcast %union.StackValue** %3 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !48
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = icmp eq i32 %5, -2
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !48
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  br i1 %9, label %17, label %12

; <label>:12:                                     ; preds = %1
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %5, %union.StackValue* nonnull %11) #16
  %13 = bitcast %union.StackValue** %3 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !48
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %16 = load %union.StackValue*, %union.StackValue** %15, align 8, !tbaa !20
  br label %20

; <label>:17:                                     ; preds = %1
  %18 = ptrtoint %union.StackValue* %10 to i64
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %11, %union.StackValue** %19, align 8, !tbaa !20
  br label %20

; <label>:20:                                     ; preds = %17, %12
  %21 = phi %union.StackValue* [ %16, %12 ], [ %11, %17 ]
  %22 = phi i64 [ %14, %12 ], [ %18, %17 ]
  %23 = phi i32 [ %5, %12 ], [ 0, %17 ]
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  store i16 2, i16* %24, align 2, !tbaa !60
  %25 = bitcast %struct.CallInfo* %2 to i64*
  store i64 %22, i64* %25, align 8, !tbaa !61
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 20
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %26, %union.StackValue** %27, align 8, !tbaa !63
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %2, %struct.CallInfo** %28, align 8, !tbaa !49
  %29 = trunc i32 %23 to i8
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %29, i8* %30, align 2, !tbaa !57
  ret i32 %23
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaF_close(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = bitcast %union.StackValue** %5 to i8**
  br label %9

; <label>:9:                                      ; preds = %98, %3
  %10 = phi i32 [ %99, %98 ], [ %2, %3 ]
  %11 = phi %union.StackValue* [ %102, %98 ], [ %1, %3 ]
  %12 = icmp ne i32 %10, -1
  br label %13

; <label>:13:                                     ; preds = %9, %53
  %14 = load %struct.UpVal*, %struct.UpVal** %4, align 8, !tbaa !56
  %15 = icmp eq %struct.UpVal* %14, null
  br i1 %15, label %103, label %16

; <label>:16:                                     ; preds = %13
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 3
  %18 = bitcast %struct.TValue** %17 to %union.StackValue**
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !64
  %20 = icmp ult %union.StackValue* %19, %11
  br i1 %20, label %103, label %21

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 4
  tail call fastcc void @luaF_unlinkupval(%struct.UpVal* nonnull %14) #16
  %23 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !64
  %24 = bitcast %struct.TValue* %23 to i64*
  %25 = bitcast %union.anon.4* %22 to i64*
  %26 = load i64, i64* %24, align 8
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 4, i32 0, i32 1
  %30 = bitcast %struct.UpVal*** %29 to i8*
  store i8 %28, i8* %30, align 8, !tbaa !22
  %31 = bitcast %struct.TValue** %17 to %union.anon.4**
  store %union.anon.4* %22, %union.anon.4** %31, align 8, !tbaa !64
  %32 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 2
  %33 = load i8, i8* %32, align 1, !tbaa !66
  %34 = and i8 %33, 24
  %35 = icmp eq i8 %34, 0
  %36 = inttoptr i64 %26 to %struct.GCObject*
  br i1 %35, label %37, label %39

; <label>:37:                                     ; preds = %21
  %38 = or i8 %33, 32
  store i8 %38, i8* %32, align 1, !tbaa !66
  br label %39

; <label>:39:                                     ; preds = %21, %37
  %40 = phi i8 [ %33, %21 ], [ %38, %37 ]
  %41 = and i8 %28, 64
  %42 = icmp eq i8 %41, 0
  %43 = and i8 %40, 32
  %44 = icmp eq i8 %43, 0
  %45 = or i1 %42, %44
  br i1 %45, label %53, label %46

; <label>:46:                                     ; preds = %39
  %47 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %36, i64 0, i32 2
  %48 = load i8, i8* %47, align 1, !tbaa !67
  %49 = and i8 %48, 24
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %53, label %51

; <label>:51:                                     ; preds = %46
  %52 = bitcast %struct.UpVal* %14 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %52, %struct.GCObject* nonnull %36) #16
  br label %53

; <label>:53:                                     ; preds = %46, %39, %51
  %54 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 1
  %55 = load i8, i8* %54, align 8, !tbaa !69
  %56 = icmp eq i8 %55, 25
  %57 = and i1 %12, %56
  br i1 %57, label %58, label %13

; <label>:58:                                     ; preds = %53
  %59 = load i64, i64* %6, align 8, !tbaa !48
  %60 = ptrtoint %union.StackValue* %11 to i64
  %61 = sub i64 %60, %59
  %62 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !64
  %63 = icmp eq i32 %10, 0
  br i1 %63, label %64, label %87, !prof !70

; <label>:64:                                     ; preds = %58
  %65 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 8
  %67 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* nonnull %0, %struct.TValue* %62, %struct.TValue* nonnull %66) #17
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %70, label %69

; <label>:69:                                     ; preds = %64
  tail call void @callclose(%struct.lua_State* nonnull %0, i8* null) #17
  br label %98

; <label>:70:                                     ; preds = %64
  %71 = getelementptr inbounds %struct.TValue, %struct.TValue* %62, i64 0, i32 1
  %72 = load i8, i8* %71, align 8, !tbaa !22
  %73 = and i8 %72, 15
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %98, label %75

; <label>:75:                                     ; preds = %70
  %76 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %77 = load %struct.CallInfo*, %struct.CallInfo** %76, align 8, !tbaa !49
  %78 = bitcast %struct.CallInfo* %77 to i64*
  %79 = load i64, i64* %78, align 8, !tbaa !61
  %80 = ptrtoint %union.StackValue* %19 to i64
  %81 = sub i64 %80, %79
  %82 = lshr exact i64 %81, 4
  %83 = trunc i64 %82 to i32
  %84 = tail call fastcc i8* @luaG_findlocal(%struct.lua_State* nonnull %0, %struct.CallInfo* %77, i32 %83, %union.StackValue** null) #17
  %85 = icmp eq i8* %84, null
  %86 = select i1 %85, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %84
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.162, i64 0, i64 0), i8* %86) #19
  unreachable

; <label>:87:                                     ; preds = %58
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %10, %union.StackValue* %19) #17
  %88 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 0, i32 0
  %89 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* nonnull %0, %struct.TValue* %62, %struct.TValue* %88) #17
  %90 = icmp eq i32 %89, 0
  br i1 %90, label %98, label %91

; <label>:91:                                     ; preds = %87
  %92 = load i64, i64* %6, align 8, !tbaa !48
  %93 = ptrtoint %union.StackValue* %19 to i64
  %94 = sub i64 %93, %92
  %95 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @callclose, i8* null, i64 %94, i64 0) #17
  %96 = icmp eq i32 %95, 0
  %97 = select i1 %96, i32 %10, i32 %95
  br label %98

; <label>:98:                                     ; preds = %69, %70, %87, %91
  %99 = phi i32 [ 0, %69 ], [ 0, %70 ], [ %97, %91 ], [ %10, %87 ]
  %100 = load i8*, i8** %8, align 8, !tbaa !48
  %101 = getelementptr inbounds i8, i8* %100, i64 %61
  %102 = bitcast i8* %101 to %union.StackValue*
  br label %9

; <label>:103:                                    ; preds = %16, %13
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_seterrorobj(%struct.lua_State*, i32, %union.StackValue*) unnamed_addr #0 {
  switch i32 %1, label %19 [
    i32 4, label %4
    i32 5, label %13
    i32 -2, label %28
  ]

; <label>:4:                                      ; preds = %3
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 39
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !71
  %9 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %8, %struct.TString** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %8, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !72
  %12 = or i8 %11, 64
  br label %28

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.163, i64 0, i64 0), i64 23) #16
  %15 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %14, %struct.TString** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %14, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !72
  %18 = or i8 %17, 64
  br label %28

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = bitcast %struct.TValue* %22 to i64*
  %24 = bitcast %union.StackValue* %2 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  br label %28

; <label>:28:                                     ; preds = %3, %19, %13, %4
  %29 = phi i8 [ %27, %19 ], [ %18, %13 ], [ %12, %4 ], [ 0, %3 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %31, %union.StackValue** %32, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)*, i8*) #0 {
  %3 = alloca [24 x i8], align 16
  %4 = alloca i32, align 4
  %5 = tail call i8* %0(i8* %1, i8* null, i64 8, i64 1616) #17
  %6 = icmp eq i8* %5, null
  br i1 %6, label %73, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds i8, i8* %5, i64 8
  %9 = bitcast i8* %8 to %struct.lua_State*
  %10 = getelementptr inbounds i8, i8* %5, i64 208
  %11 = bitcast i8* %10 to %struct.global_State*
  %12 = getelementptr inbounds i8, i8* %5, i64 16
  store i8 8, i8* %12, align 8, !tbaa !17
  %13 = getelementptr inbounds i8, i8* %5, i64 308
  store i8 8, i8* %13, align 4, !tbaa !15
  %14 = getelementptr inbounds i8, i8* %5, i64 17
  store i8 8, i8* %14, align 1, !tbaa !16
  tail call fastcc void @preinit_thread(%struct.lua_State* nonnull %9, %struct.global_State* nonnull %11) #16
  %15 = getelementptr inbounds i8, i8* %5, i64 320
  %16 = bitcast i8* %15 to i8**
  store i8* %8, i8** %16, align 8, !tbaa !18
  %17 = bitcast i8* %8 to %struct.GCObject**
  store %struct.GCObject* null, %struct.GCObject** %17, align 8, !tbaa !19
  %18 = bitcast i8* %10 to i8* (i8*, i8*, i64, i64)**
  store i8* (i8*, i8*, i64, i64)* %0, i8* (i8*, i8*, i64, i64)** %18, align 8, !tbaa !45
  %19 = getelementptr inbounds i8, i8* %5, i64 216
  %20 = bitcast i8* %19 to i8**
  store i8* %1, i8** %20, align 8, !tbaa !46
  %21 = getelementptr inbounds i8, i8* %5, i64 1600
  %22 = getelementptr inbounds i8, i8* %5, i64 464
  %23 = bitcast i8* %22 to i8**
  call void @llvm.memset.p0i8.i64(i8* nonnull %21, i8 0, i64 16, i32 8, i1 false)
  store i8* %8, i8** %23, align 8, !tbaa !27
  %24 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %24) #7
  %25 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %25) #7
  %26 = tail call i64 @time(i64* null) #17
  %27 = trunc i64 %26 to i32
  store i32 %27, i32* %4, align 4, !tbaa !74
  %28 = ptrtoint i8* %8 to i64
  %29 = bitcast [24 x i8]* %3 to i64*
  store i64 %28, i64* %29, align 16
  %30 = ptrtoint i32* %4 to i64
  %31 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 8
  %32 = bitcast i8* %31 to i64*
  store i64 %30, i64* %32, align 8
  %33 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 16
  %34 = bitcast i8* %33 to i64*
  store i64 ptrtoint (%struct.lua_State* (i8* (i8*, i8*, i64, i64)*, i8*)* @lua_newstate to i64), i64* %34, align 16
  %35 = call fastcc i32 @luaS_hash(i8* nonnull %24, i64 24, i32 %27) #17
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %25) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %24) #7
  %36 = getelementptr inbounds i8, i8* %5, i64 304
  %37 = bitcast i8* %36 to i32*
  store i32 %35, i32* %37, align 8, !tbaa !75
  %38 = getelementptr inbounds i8, i8* %5, i64 313
  store i8 0, i8* %38, align 1, !tbaa !28
  %39 = getelementptr inbounds i8, i8* %5, i64 256
  %40 = getelementptr inbounds i8, i8* %5, i64 280
  store i8 0, i8* %40, align 8, !tbaa !76
  %41 = getelementptr inbounds i8, i8* %5, i64 456
  %42 = bitcast i8* %41 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %42, align 8, !tbaa !77
  %43 = getelementptr inbounds i8, i8* %5, i64 309
  call void @llvm.memset.p0i8.i64(i8* nonnull %39, i8 0, i64 16, i32 8, i1 false)
  store i8 8, i8* %43, align 1, !tbaa !44
  %44 = getelementptr inbounds i8, i8* %5, i64 310
  store i8 0, i8* %44, align 2, !tbaa !29
  %45 = getelementptr inbounds i8, i8* %5, i64 314
  store i8 0, i8* %45, align 2, !tbaa !78
  %46 = getelementptr inbounds i8, i8* %5, i64 328
  %47 = getelementptr inbounds i8, i8* %5, i64 224
  %48 = bitcast i8* %47 to i64*
  call void @llvm.memset.p0i8.i64(i8* nonnull %46, i8 0, i64 128, i32 8, i1 false)
  store i64 1616, i64* %48, align 8, !tbaa !31
  %49 = getelementptr inbounds i8, i8* %5, i64 232
  %50 = bitcast i8* %49 to i64*
  store i64 0, i64* %50, align 8, !tbaa !11
  %51 = getelementptr inbounds i8, i8* %5, i64 248
  %52 = bitcast i8* %51 to i64*
  store i64 0, i64* %52, align 8, !tbaa !30
  %53 = getelementptr inbounds i8, i8* %5, i64 288
  %54 = bitcast i8* %53 to i64*
  store i64 0, i64* %54, align 8, !tbaa !21
  %55 = getelementptr inbounds i8, i8* %5, i64 296
  store i8 35, i8* %55, align 8, !tbaa !22
  %56 = getelementptr inbounds i8, i8* %5, i64 315
  store i8 50, i8* %56, align 1, !tbaa !79
  %57 = getelementptr inbounds i8, i8* %5, i64 316
  store i8 25, i8* %57, align 4, !tbaa !42
  %58 = getelementptr inbounds i8, i8* %5, i64 317
  store i8 13, i8* %58, align 1, !tbaa !43
  %59 = getelementptr inbounds i8, i8* %5, i64 312
  store i8 25, i8* %59, align 8, !tbaa !33
  %60 = getelementptr inbounds i8, i8* %5, i64 311
  store i8 20, i8* %60, align 1, !tbaa !80
  %61 = getelementptr inbounds i8, i8* %5, i64 680
  %62 = bitcast i8* %61 to [9 x %struct.Table*]*
  br label %63

; <label>:63:                                     ; preds = %66, %7
  %64 = phi i64 [ %68, %66 ], [ 0, %7 ]
  %65 = icmp eq i64 %64, 9
  br i1 %65, label %69, label %66

; <label>:66:                                     ; preds = %63
  %67 = getelementptr inbounds [9 x %struct.Table*], [9 x %struct.Table*]* %62, i64 0, i64 %64
  store %struct.Table* null, %struct.Table** %67, align 8, !tbaa !39
  %68 = add nuw nsw i64 %64, 1
  br label %63

; <label>:69:                                     ; preds = %63
  %70 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %9, void (%struct.lua_State*, i8*)* nonnull @f_luaopen, i8* null) #16
  %71 = icmp eq i32 %70, 0
  br i1 %71, label %73, label %72

; <label>:72:                                     ; preds = %69
  call fastcc void @close_state(%struct.lua_State* nonnull %9) #16
  br label %73

; <label>:73:                                     ; preds = %72, %69, %2
  %74 = phi %struct.lua_State* [ null, %2 ], [ null, %72 ], [ %9, %69 ]
  ret %struct.lua_State* %74
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaD_rawrunprotected(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*) unnamed_addr #0 {
  %4 = alloca %struct.lua_longjmp, align 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %6 = load i32, i32* %5, align 8, !tbaa !54
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %8 = load i16, i16* %7, align 4, !tbaa !50
  %9 = zext i16 %8 to i32
  %10 = sub i32 %6, %9
  %11 = bitcast %struct.lua_longjmp* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 216, i8* nonnull %11) #7
  %12 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 0, i32* %12, align 8, !tbaa !81
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %14 = bitcast %struct.lua_longjmp** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !53
  %16 = bitcast %struct.lua_longjmp* %4 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !83
  store %struct.lua_longjmp* %4, %struct.lua_longjmp** %13, align 8, !tbaa !53
  %17 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  %18 = call i32 @_setjmp(%struct.__jmp_buf_tag* nonnull %17) #20
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %3
  call void %1(%struct.lua_State* nonnull %0, i8* %2) #17
  br label %21

; <label>:21:                                     ; preds = %20, %3
  %22 = load i64, i64* %16, align 8, !tbaa !83
  store i64 %22, i64* %14, align 8, !tbaa !53
  %23 = load i16, i16* %7, align 4, !tbaa !50
  %24 = zext i16 %23 to i32
  %25 = add i32 %10, %24
  store i32 %25, i32* %5, align 8, !tbaa !54
  %26 = load volatile i32, i32* %12, align 8, !tbaa !81
  call void @llvm.lifetime.end.p0i8(i64 216, i8* nonnull %11) #7
  ret i32 %26
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @f_luaopen(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  tail call fastcc void @stack_init(%struct.lua_State* %0, %struct.lua_State* %0) #16
  %6 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #17
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 7
  %9 = bitcast %struct.TValue* %8 to %struct.Table**
  store %struct.Table* %7, %struct.Table** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 7, i32 1
  store i8 69, i8* %10, align 8, !tbaa !22
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %7, i32 2, i32 0) #17
  %11 = bitcast %struct.TValue* %3 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %11, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 72, i8* %12, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %7, i64 1, %struct.TValue* nonnull %3) #17
  %13 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #17
  %14 = bitcast %struct.TValue* %3 to %struct.Table**
  store %struct.Table* %13, %struct.Table** %14, align 8, !tbaa !21
  store i8 69, i8* %12, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %7, i64 2, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  %15 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 6
  %17 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 1024, i32 0) #17
  %18 = bitcast i8* %17 to %struct.TString**
  %19 = bitcast %struct.stringtable* %16 to i8**
  store i8* %17, i8** %19, align 8, !tbaa !84
  tail call fastcc void @tablerehash(%struct.TString** %18, i32 0, i32 128) #17
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 6, i32 2
  store i32 128, i32* %20, align 4, !tbaa !85
  %21 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.78, i64 0, i64 0), i64 17) #17
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 39
  store %struct.TString* %21, %struct.TString** %22, align 8, !tbaa !71
  %23 = bitcast %struct.TString* %21 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %23) #17
  %24 = bitcast %struct.TString** %22 to i64*
  br label %25

; <label>:25:                                     ; preds = %38, %2
  %26 = phi i64 [ %39, %38 ], [ 0, %2 ]
  %27 = icmp eq i64 %26, 53
  br i1 %27, label %29, label %28

; <label>:28:                                     ; preds = %25
  br label %30

; <label>:29:                                     ; preds = %25
  br label %40

; <label>:30:                                     ; preds = %28, %33
  %31 = phi i64 [ %37, %33 ], [ 0, %28 ]
  %32 = icmp eq i64 %31, 2
  br i1 %32, label %38, label %33

; <label>:33:                                     ; preds = %30
  %34 = load i64, i64* %24, align 8, !tbaa !71
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 42, i64 %26, i64 %31
  %36 = bitcast %struct.TString** %35 to i64*
  store i64 %34, i64* %36, align 8, !tbaa !39
  %37 = add nuw nsw i64 %31, 1
  br label %30

; <label>:38:                                     ; preds = %30
  %39 = add nuw nsw i64 %26, 1
  br label %25

; <label>:40:                                     ; preds = %29, %43
  %41 = phi i64 [ %53, %43 ], [ 0, %29 ]
  %42 = icmp eq i64 %41, 25
  br i1 %42, label %54, label %43

; <label>:43:                                     ; preds = %40
  %44 = getelementptr inbounds [25 x i8*], [25 x i8*]* @luaT_init.luaT_eventname, i64 0, i64 %41
  %45 = load i8*, i8** %44, align 8, !tbaa !39
  %46 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %45) #17
  %47 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %47, i64 0, i32 40, i64 %41
  store %struct.TString* %46, %struct.TString** %48, align 8, !tbaa !39
  %49 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %50 = getelementptr inbounds %struct.global_State, %struct.global_State* %49, i64 0, i32 40, i64 %41
  %51 = bitcast %struct.TString** %50 to %struct.GCObject**
  %52 = load %struct.GCObject*, %struct.GCObject** %51, align 8, !tbaa !39
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %52) #17
  %53 = add nuw nsw i64 %41, 1
  br label %40

; <label>:54:                                     ; preds = %40
  %55 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4) #17
  %56 = bitcast %struct.TString* %55 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %56) #17
  br label %57

; <label>:57:                                     ; preds = %60, %54
  %58 = phi i64 [ %65, %60 ], [ 0, %54 ]
  %59 = icmp eq i64 %58, 22
  br i1 %59, label %68, label %60

; <label>:60:                                     ; preds = %57
  %61 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %58
  %62 = load i8*, i8** %61, align 8, !tbaa !39
  %63 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %62) #17
  %64 = bitcast %struct.TString* %63 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %64) #17
  %65 = add nuw nsw i64 %58, 1
  %66 = getelementptr inbounds %struct.TString, %struct.TString* %63, i64 0, i32 3
  %67 = trunc i64 %65 to i8
  store i8 %67, i8* %66, align 2, !tbaa !86
  br label %57

; <label>:68:                                     ; preds = %57
  %69 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 15
  store i8 1, i8* %69, align 1, !tbaa !28
  %70 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 8, i32 1
  store i8 0, i8* %70, align 8, !tbaa !87
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @close_state(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !48
  %6 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %5, i32 -2) #16
  %7 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  tail call fastcc void @luaC_changemode(%struct.lua_State* %0, i32 0) #17
  tail call fastcc void @separatetobefnz(%struct.global_State* %7, i32 1) #17
  tail call fastcc void @callallpendingfinalizers(%struct.lua_State* %0) #17
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 20
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !18
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 38
  %11 = bitcast %struct.lua_State** %10 to %struct.GCObject**
  %12 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !27
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %9, %struct.GCObject* %12) #17
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 22
  %14 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !36
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %14, %struct.GCObject* null) #17
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 29
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !88
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %16, %struct.GCObject* null) #17
  %17 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 6
  %19 = bitcast %struct.stringtable* %18 to i8**
  %20 = load i8*, i8** %19, align 8, !tbaa !89
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 6, i32 2
  %22 = load i32, i32* %21, align 4, !tbaa !90
  %23 = sext i32 %22 to i64
  %24 = shl nsw i64 %23, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %20, i64 %24) #16
  tail call fastcc void @freestack(%struct.lua_State* %0) #16
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 0
  %26 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %25, align 8, !tbaa !45
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 1
  %28 = load i8*, i8** %27, align 8, !tbaa !46
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 -1, i32 23
  %30 = bitcast i32* %29 to i8*
  %31 = tail call i8* %26(i8* %28, i8* nonnull %30, i64 1616, i64 0) #17
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_close(%struct.lua_State* nocapture readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !27
  tail call fastcc void @close_state(%struct.lua_State* %5) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_sethook(%struct.lua_State*, void (%struct.lua_State*, %struct.lua_Debug*)*, i32, i32) local_unnamed_addr #2 {
  %5 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %1, null
  %6 = icmp eq i32 %2, 0
  %7 = or i1 %5, %6
  %8 = select i1 %7, i32 0, i32 %2
  %9 = select i1 %7, void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)* %1
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !49
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 7
  %13 = load i16, i16* %12, align 2, !tbaa !60
  %14 = and i16 %13, 2
  %15 = icmp eq i16 %14, 0
  br i1 %15, label %16, label %22

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 4
  %18 = bitcast %union.anon.0* %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %21 = bitcast i32** %20 to i64*
  store i64 %19, i64* %21, align 8, !tbaa !91
  br label %22

; <label>:22:                                     ; preds = %4, %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %9, void (%struct.lua_State*, %struct.lua_Debug*)** %23, align 8, !tbaa !25
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  store i32 %3, i32* %24, align 8, !tbaa !24
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  store i32 %3, i32* %25, align 4, !tbaa !26
  %26 = and i32 %8, 255
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  store i32 %26, i32* %27, align 8, !tbaa !23
  %28 = icmp eq i32 %8, 0
  br i1 %28, label %44, label %29

; <label>:29:                                     ; preds = %22
  br label %30

; <label>:30:                                     ; preds = %29, %41
  %31 = phi %struct.CallInfo* [ %43, %41 ], [ %11, %29 ]
  %32 = icmp eq %struct.CallInfo* %31, null
  br i1 %32, label %44, label %33

; <label>:33:                                     ; preds = %30
  %34 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 7
  %35 = load i16, i16* %34, align 2, !tbaa !60
  %36 = and i16 %35, 2
  %37 = icmp eq i16 %36, 0
  br i1 %37, label %38, label %41

; <label>:38:                                     ; preds = %33
  %39 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 4, i32 0, i32 1
  %40 = bitcast i64* %39 to i32*
  store i32 1, i32* %40, align 8, !tbaa !21
  br label %41

; <label>:41:                                     ; preds = %38, %33
  %42 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 2
  %43 = load %struct.CallInfo*, %struct.CallInfo** %42, align 8, !tbaa !92
  br label %30

; <label>:44:                                     ; preds = %30, %22
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void (%struct.lua_State*, %struct.lua_Debug*)* @lua_gethook(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %3 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %2, align 8, !tbaa !25
  ret void (%struct.lua_State*, %struct.lua_Debug*)* %3
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_gethookmask(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %3 = load i32, i32* %2, align 8, !tbaa !23
  ret i32 %3
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_gethookcount(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %3 = load i32, i32* %2, align 8, !tbaa !24
  ret i32 %3
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_getstack(%struct.lua_State* readonly, i32, %struct.lua_Debug* nocapture) local_unnamed_addr #2 {
  %4 = icmp slt i32 %1, 0
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  br label %8

; <label>:8:                                      ; preds = %15, %5
  %9 = phi i32 [ %1, %5 ], [ %16, %15 ]
  %10 = phi %struct.CallInfo** [ %6, %5 ], [ %17, %15 ]
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !39
  %12 = icmp sgt i32 %9, 0
  %13 = icmp ne %struct.CallInfo* %11, %7
  %14 = and i1 %12, %13
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %8
  %16 = add nsw i32 %9, -1
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 2
  br label %8

; <label>:18:                                     ; preds = %8
  %19 = icmp ne i32 %9, 0
  %20 = icmp eq %struct.CallInfo* %11, %7
  %21 = or i1 %19, %20
  br i1 %21, label %24, label %22

; <label>:22:                                     ; preds = %18
  %23 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %11, %struct.CallInfo** %23, align 8, !tbaa !93
  br label %24

; <label>:24:                                     ; preds = %22, %18, %3
  %25 = phi i32 [ 0, %3 ], [ 1, %22 ], [ 0, %18 ]
  ret i32 %25
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_getlocal(%struct.lua_State* nocapture, %struct.lua_Debug* readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = icmp eq %struct.lua_Debug* %1, null
  br i1 %5, label %6, label %19

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !21
  %11 = icmp eq i8 %10, 86
  br i1 %11, label %12, label %40

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 0, i32 0
  %14 = bitcast %struct.GCObject** %13 to %struct.LClosure**
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %17, i32 %2, i32 0) #16
  br label %40

; <label>:19:                                     ; preds = %3
  %20 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !39
  %21 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %22 = load %struct.CallInfo*, %struct.CallInfo** %21, align 8, !tbaa !93
  %23 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %22, i32 %2, %union.StackValue** nonnull %4) #16
  %24 = icmp eq i8* %23, null
  br i1 %24, label %39, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %union.StackValue** %4 to %struct.TValue**
  %30 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !39
  %31 = bitcast %struct.TValue* %30 to i64*
  %32 = bitcast %struct.TValue* %28 to i64*
  %33 = load i64, i64* %31, align 8
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !22
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %26, align 8, !tbaa !20
  br label %39

; <label>:39:                                     ; preds = %19, %25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %40

; <label>:40:                                     ; preds = %6, %12, %39
  %41 = phi i8* [ %18, %12 ], [ %23, %39 ], [ null, %6 ]
  ret i8* %41
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i8* @luaF_getlocalname(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %5 = load i32, i32* %4, align 4, !tbaa !95
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %7 = sext i32 %5 to i64
  br label %8

; <label>:8:                                      ; preds = %30, %3
  %9 = phi i64 [ %32, %30 ], [ 0, %3 ]
  %10 = phi i32 [ %31, %30 ], [ %1, %3 ]
  %11 = icmp slt i64 %9, %7
  br i1 %11, label %12, label %33

; <label>:12:                                     ; preds = %8
  %13 = load %struct.LocVar*, %struct.LocVar** %6, align 8, !tbaa !97
  %14 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %13, i64 %9, i32 1
  %15 = load i32, i32* %14, align 8, !tbaa !98
  %16 = icmp sgt i32 %15, %2
  br i1 %16, label %33, label %17

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %13, i64 %9, i32 2
  %19 = load i32, i32* %18, align 4, !tbaa !100
  %20 = icmp sgt i32 %19, %2
  br i1 %20, label %21, label %30

; <label>:21:                                     ; preds = %17
  %22 = add nsw i32 %10, -1
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %21
  %25 = and i64 %9, 4294967295
  %26 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %13, i64 %25, i32 0
  %27 = bitcast %struct.TString** %26 to i8**
  %28 = load i8*, i8** %27, align 8, !tbaa !101
  %29 = getelementptr inbounds i8, i8* %28, i64 24
  br label %33

; <label>:30:                                     ; preds = %17, %21
  %31 = phi i32 [ %22, %21 ], [ %10, %17 ]
  %32 = add nuw nsw i64 %9, 1
  br label %8

; <label>:33:                                     ; preds = %8, %12, %24
  %34 = phi i8* [ %29, %24 ], [ null, %12 ], [ null, %8 ]
  ret i8* %34
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i8* @luaG_findlocal(%struct.lua_State* nocapture readonly, %struct.CallInfo* readonly, i32, %union.StackValue**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !61
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !60
  %10 = and i16 %9, 2
  %11 = icmp eq i16 %10, 0
  br i1 %11, label %12, label %40

; <label>:12:                                     ; preds = %4
  %13 = icmp slt i32 %2, 0
  %14 = bitcast %union.StackValue* %6 to %struct.LClosure**
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  br i1 %13, label %18, label %36

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 4
  %20 = load i8, i8* %19, align 1, !tbaa !102
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %70, label %22

; <label>:22:                                     ; preds = %18
  %23 = sub nsw i32 0, %2
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %25 = bitcast %union.anon.0* %24 to %struct.anon*
  %26 = getelementptr inbounds %struct.anon, %struct.anon* %25, i64 0, i32 2
  %27 = load i32, i32* %26, align 4, !tbaa !21
  %28 = icmp slt i32 %27, %23
  br i1 %28, label %70, label %29

; <label>:29:                                     ; preds = %22
  %30 = sext i32 %27 to i64
  %31 = sub nsw i64 0, %30
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %31
  %33 = xor i32 %2, -1
  %34 = sext i32 %33 to i64
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 %34
  store %union.StackValue* %35, %union.StackValue** %3, align 8, !tbaa !39
  br label %70

; <label>:36:                                     ; preds = %12
  %37 = tail call fastcc i32 @currentpc(%struct.CallInfo* nonnull %1) #16
  %38 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %17, i32 %2, i32 %37) #16
  %39 = icmp eq i8* %38, null
  br i1 %39, label %40, label %63

; <label>:40:                                     ; preds = %4, %36
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %42 = load %struct.CallInfo*, %struct.CallInfo** %41, align 8, !tbaa !49
  %43 = icmp eq %struct.CallInfo* %42, %1
  br i1 %43, label %44, label %46

; <label>:44:                                     ; preds = %40
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %50

; <label>:46:                                     ; preds = %40
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 3
  %48 = load %struct.CallInfo*, %struct.CallInfo** %47, align 8, !tbaa !103
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %48, i64 0, i32 0
  br label %50

; <label>:50:                                     ; preds = %46, %44
  %51 = phi %union.StackValue** [ %45, %44 ], [ %49, %46 ]
  %52 = bitcast %union.StackValue** %51 to i64*
  %53 = load i64, i64* %52, align 8, !tbaa !39
  %54 = ptrtoint %union.StackValue* %7 to i64
  %55 = sub i64 %53, %54
  %56 = ashr exact i64 %55, 4
  %57 = sext i32 %2 to i64
  %58 = icmp sge i64 %56, %57
  %59 = icmp sgt i32 %2, 0
  %60 = and i1 %59, %58
  br i1 %60, label %61, label %70

; <label>:61:                                     ; preds = %50
  %62 = select i1 %11, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.142, i64 0, i64 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.143, i64 0, i64 0)
  br label %63

; <label>:63:                                     ; preds = %61, %36
  %64 = phi i8* [ %38, %36 ], [ %62, %61 ]
  %65 = icmp eq %union.StackValue** %3, null
  br i1 %65, label %70, label %66

; <label>:66:                                     ; preds = %63
  %67 = add nsw i32 %2, -1
  %68 = sext i32 %67 to i64
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %68
  store %union.StackValue* %69, %union.StackValue** %3, align 8, !tbaa !39
  br label %70

; <label>:70:                                     ; preds = %50, %29, %22, %18, %66, %63
  %71 = phi i8* [ %64, %63 ], [ %64, %66 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.144, i64 0, i64 0), %29 ], [ null, %22 ], [ null, %18 ], [ null, %50 ]
  ret i8* %71
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_setlocal(%struct.lua_State* nocapture, %struct.lua_Debug* nocapture readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !39
  %6 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !93
  %8 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %7, i32 %2, %union.StackValue** nonnull %4) #16
  %9 = icmp eq i8* %8, null
  br i1 %9, label %24, label %10

; <label>:10:                                     ; preds = %3
  %11 = bitcast %union.StackValue** %4 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !39
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0
  %16 = bitcast %struct.TValue* %15 to i64*
  %17 = bitcast %struct.TValue* %12 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1
  store %union.StackValue* %23, %union.StackValue** %13, align 8, !tbaa !20
  br label %24

; <label>:24:                                     ; preds = %3, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %8
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_getinfo(%struct.lua_State*, i8* readonly, %struct.lua_Debug* nocapture) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 62
  br i1 %6, label %7, label %13

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1, i32 0
  %11 = getelementptr inbounds i8, i8* %1, i64 1
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1
  store %union.StackValue* %12, %union.StackValue** %8, align 8, !tbaa !20
  br label %18

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  %15 = load %struct.CallInfo*, %struct.CallInfo** %14, align 8, !tbaa !93
  %16 = bitcast %struct.CallInfo* %15 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !61
  br label %18

; <label>:18:                                     ; preds = %13, %7
  %19 = phi %struct.TValue* [ %10, %7 ], [ %17, %13 ]
  %20 = phi %struct.CallInfo* [ null, %7 ], [ %15, %13 ]
  %21 = phi i8* [ %11, %7 ], [ %1, %13 ]
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = and i8 %23, 31
  %25 = icmp eq i8 %24, 22
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %18
  %27 = bitcast %struct.TValue* %19 to %union.Closure**
  %28 = load %union.Closure*, %union.Closure** %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %18, %26
  %30 = phi %union.Closure* [ %28, %26 ], [ null, %18 ]
  %31 = icmp eq %union.Closure* %30, null
  %32 = icmp eq %struct.CallInfo* %20, null
  %33 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %34 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 4
  %35 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 5
  %36 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 7
  %37 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 8
  %38 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 3
  %39 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 15, i64 0
  %40 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 1
  %41 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %42 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 7
  %43 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %44 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %45 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %46 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 3
  %47 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %48 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %49 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %50 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %51 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 5
  %52 = bitcast i32 (%struct.lua_State*)** %51 to %struct.Proto**
  %53 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 5
  %54 = bitcast %union.anon.2* %53 to %struct.anon.3*
  %55 = bitcast %union.anon.2* %53 to i16*
  %56 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %54, i64 0, i32 1
  %57 = bitcast i8** %34 to %struct.TString**
  %58 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 2
  %59 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %60 = bitcast i8** %33 to <2 x i8*>*
  br label %61

; <label>:61:                                     ; preds = %209, %29
  %62 = phi i8* [ %21, %29 ], [ %211, %209 ]
  %63 = phi i32 [ 1, %29 ], [ %210, %209 ]
  %64 = load i8, i8* %62, align 1, !tbaa !21
  %65 = icmp eq i8 %64, 0
  br i1 %65, label %212, label %66

; <label>:66:                                     ; preds = %61
  %67 = sext i8 %64 to i32
  switch i32 %67, label %208 [
    i32 83, label %68
    i32 108, label %105
    i32 117, label %114
    i32 116, label %128
    i32 110, label %135
    i32 114, label %199
    i32 76, label %209
    i32 102, label %209
  ]

; <label>:68:                                     ; preds = %66
  br i1 %31, label %72, label %69

; <label>:69:                                     ; preds = %68
  %70 = load i8, i8* %40, align 8, !tbaa !21
  %71 = icmp eq i8 %70, 54
  br i1 %71, label %72, label %73

; <label>:72:                                     ; preds = %69, %68
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.145, i64 0, i64 0), i8** %34, align 8, !tbaa !104
  store i64 4, i64* %35, align 8, !tbaa !105
  store i32 -1, i32* %36, align 4, !tbaa !106
  store i32 -1, i32* %37, align 8, !tbaa !107
  br label %101

; <label>:73:                                     ; preds = %69
  %74 = load %struct.Proto*, %struct.Proto** %52, align 8, !tbaa !21
  %75 = getelementptr inbounds %struct.Proto, %struct.Proto* %74, i64 0, i32 22
  %76 = load %struct.TString*, %struct.TString** %75, align 8, !tbaa !108
  %77 = icmp eq %struct.TString* %76, null
  br i1 %77, label %91, label %78

; <label>:78:                                     ; preds = %73
  %79 = getelementptr inbounds %struct.TString, %struct.TString* %76, i64 1
  store %struct.TString* %79, %struct.TString** %57, align 8, !tbaa !104
  %80 = getelementptr inbounds %struct.TString, %struct.TString* %76, i64 0, i32 1
  %81 = load i8, i8* %80, align 8, !tbaa !72
  %82 = icmp eq i8 %81, 20
  %83 = bitcast %struct.TString* %79 to i8*
  br i1 %82, label %84, label %88

; <label>:84:                                     ; preds = %78
  %85 = getelementptr inbounds %struct.TString, %struct.TString* %76, i64 0, i32 4
  %86 = load i8, i8* %85, align 1, !tbaa !109
  %87 = zext i8 %86 to i64
  br label %92

; <label>:88:                                     ; preds = %78
  %89 = getelementptr inbounds %struct.TString, %struct.TString* %76, i64 0, i32 6, i32 0
  %90 = load i64, i64* %89, align 8, !tbaa !21
  br label %92

; <label>:91:                                     ; preds = %73
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.147, i64 0, i64 0), i8** %34, align 8, !tbaa !104
  br label %92

; <label>:92:                                     ; preds = %91, %88, %84
  %93 = phi i64 [ 2, %91 ], [ %87, %84 ], [ %90, %88 ]
  %94 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.147, i64 0, i64 0), %91 ], [ %83, %84 ], [ %83, %88 ]
  store i64 %93, i64* %35, align 8, !tbaa !105
  %95 = getelementptr inbounds %struct.Proto, %struct.Proto* %74, i64 0, i32 13
  %96 = load i32, i32* %95, align 4, !tbaa !110
  store i32 %96, i32* %36, align 4, !tbaa !106
  %97 = getelementptr inbounds %struct.Proto, %struct.Proto* %74, i64 0, i32 14
  %98 = load i32, i32* %97, align 8, !tbaa !111
  store i32 %98, i32* %37, align 8, !tbaa !107
  %99 = icmp eq i32 %96, 0
  %100 = select i1 %99, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.148, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.149, i64 0, i64 0)
  br label %101

; <label>:101:                                    ; preds = %92, %72
  %102 = phi i8* [ %100, %92 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.146, i64 0, i64 0), %72 ]
  %103 = phi i64 [ %93, %92 ], [ 4, %72 ]
  %104 = phi i8* [ %94, %92 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.145, i64 0, i64 0), %72 ]
  store i8* %102, i8** %38, align 8, !tbaa !112
  tail call fastcc void @luaO_chunkid(i8* nonnull %39, i8* %104, i64 %103) #17
  br label %209

; <label>:105:                                    ; preds = %66
  br i1 %32, label %112, label %106

; <label>:106:                                    ; preds = %105
  %107 = load i16, i16* %42, align 2, !tbaa !60
  %108 = and i16 %107, 2
  %109 = icmp eq i16 %108, 0
  br i1 %109, label %110, label %112

; <label>:110:                                    ; preds = %106
  %111 = tail call fastcc i32 @currentline(%struct.CallInfo* nonnull %20) #17
  br label %112

; <label>:112:                                    ; preds = %110, %106, %105
  %113 = phi i32 [ %111, %110 ], [ -1, %106 ], [ -1, %105 ]
  store i32 %113, i32* %41, align 8, !tbaa !113
  br label %209

; <label>:114:                                    ; preds = %66
  br i1 %31, label %119, label %115

; <label>:115:                                    ; preds = %114
  %116 = load i8, i8* %46, align 2, !tbaa !21
  store i8 %116, i8* %43, align 4, !tbaa !114
  %117 = load i8, i8* %40, align 8, !tbaa !21
  %118 = icmp eq i8 %117, 54
  br i1 %118, label %120, label %121

; <label>:119:                                    ; preds = %114
  store i8 0, i8* %43, align 4, !tbaa !114
  br label %120

; <label>:120:                                    ; preds = %119, %115
  store i8 1, i8* %44, align 2, !tbaa !115
  store i8 0, i8* %45, align 1, !tbaa !116
  br label %209

; <label>:121:                                    ; preds = %115
  %122 = load %struct.Proto*, %struct.Proto** %52, align 8, !tbaa !21
  %123 = getelementptr inbounds %struct.Proto, %struct.Proto* %122, i64 0, i32 4
  %124 = load i8, i8* %123, align 1, !tbaa !102
  store i8 %124, i8* %44, align 2, !tbaa !115
  %125 = load %struct.Proto*, %struct.Proto** %52, align 8, !tbaa !21
  %126 = getelementptr inbounds %struct.Proto, %struct.Proto* %125, i64 0, i32 3
  %127 = load i8, i8* %126, align 2, !tbaa !117
  store i8 %127, i8* %45, align 1, !tbaa !116
  br label %209

; <label>:128:                                    ; preds = %66
  br i1 %32, label %133, label %129

; <label>:129:                                    ; preds = %128
  %130 = load i16, i16* %42, align 2, !tbaa !60
  %131 = trunc i16 %130 to i8
  %132 = and i8 %131, 16
  br label %133

; <label>:133:                                    ; preds = %129, %128
  %134 = phi i8 [ %132, %129 ], [ 0, %128 ]
  store i8 %134, i8* %47, align 1, !tbaa !118
  br label %209

; <label>:135:                                    ; preds = %66
  br i1 %32, label %192, label %136

; <label>:136:                                    ; preds = %135
  %137 = load i16, i16* %42, align 2, !tbaa !60
  %138 = zext i16 %137 to i32
  %139 = and i32 %138, 64
  %140 = icmp eq i32 %139, 0
  br i1 %140, label %141, label %189

; <label>:141:                                    ; preds = %136
  %142 = and i32 %138, 16
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %144, label %192

; <label>:144:                                    ; preds = %141
  %145 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !92
  %146 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %145, i64 0, i32 7
  %147 = load i16, i16* %146, align 2, !tbaa !60
  %148 = and i16 %147, 2
  %149 = icmp eq i16 %148, 0
  br i1 %149, label %150, label %192

; <label>:150:                                    ; preds = %144
  %151 = bitcast %struct.CallInfo* %145 to %struct.LClosure***
  %152 = load %struct.LClosure**, %struct.LClosure*** %151, align 8, !tbaa !61
  %153 = load %struct.LClosure*, %struct.LClosure** %152, align 8, !tbaa !21
  %154 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %153, i64 0, i32 5
  %155 = load %struct.Proto*, %struct.Proto** %154, align 8, !tbaa !21
  %156 = tail call fastcc i32 @currentpc(%struct.CallInfo* %145) #17
  %157 = getelementptr inbounds %struct.Proto, %struct.Proto* %155, i64 0, i32 16
  %158 = load i32*, i32** %157, align 8, !tbaa !119
  %159 = sext i32 %156 to i64
  %160 = getelementptr inbounds i32, i32* %158, i64 %159
  %161 = load i32, i32* %160, align 4, !tbaa !74
  %162 = and i16 %147, 4
  %163 = icmp eq i16 %162, 0
  br i1 %163, label %164, label %189

; <label>:164:                                    ; preds = %150
  %165 = and i32 %161, 127
  %166 = trunc i32 %161 to i7
  switch i7 %166, label %192 [
    i7 -59, label %193
    i7 -58, label %193
    i7 -51, label %189
    i7 18, label %181
    i7 9, label %181
    i7 10, label %181
    i7 11, label %181
    i7 12, label %181
    i7 13, label %167
    i7 14, label %167
    i7 15, label %167
    i7 16, label %167
    i7 19, label %168
    i7 20, label %168
    i7 21, label %168
    i7 22, label %168
    i7 23, label %168
    i7 24, label %168
    i7 25, label %168
    i7 26, label %170
    i7 27, label %170
    i7 28, label %170
    i7 29, label %170
    i7 30, label %170
    i7 31, label %170
    i7 32, label %170
    i7 33, label %170
    i7 34, label %170
    i7 35, label %170
    i7 38, label %172
    i7 39, label %172
    i7 40, label %172
    i7 41, label %172
    i7 42, label %172
    i7 43, label %172
    i7 44, label %172
    i7 45, label %172
    i7 46, label %172
    i7 47, label %172
    i7 48, label %172
    i7 49, label %172
    i7 50, label %174
    i7 51, label %175
    i7 53, label %176
    i7 54, label %177
    i7 58, label %178
    i7 59, label %179
    i7 60, label %179
    i7 63, label %179
    i7 -64, label %179
    i7 36, label %180
    i7 37, label %180
  ]

; <label>:167:                                    ; preds = %164, %164, %164, %164
  br label %181

; <label>:168:                                    ; preds = %164, %164, %164, %164, %164, %164, %164
  %169 = add nsw i32 %165, -13
  br label %181

; <label>:170:                                    ; preds = %164, %164, %164, %164, %164, %164, %164, %164, %164, %164
  %171 = add nsw i32 %165, -20
  br label %181

; <label>:172:                                    ; preds = %164, %164, %164, %164, %164, %164, %164, %164, %164, %164, %164, %164
  %173 = add nsw i32 %165, -32
  br label %181

; <label>:174:                                    ; preds = %164
  br label %181

; <label>:175:                                    ; preds = %164
  br label %181

; <label>:176:                                    ; preds = %164
  br label %181

; <label>:177:                                    ; preds = %164
  br label %181

; <label>:178:                                    ; preds = %164
  br label %181

; <label>:179:                                    ; preds = %164, %164, %164, %164
  br label %189

; <label>:180:                                    ; preds = %164, %164
  br label %189

; <label>:181:                                    ; preds = %178, %177, %176, %175, %174, %172, %170, %168, %167, %164, %164, %164, %164, %164
  %182 = phi i32 [ 5, %178 ], [ 22, %177 ], [ 4, %176 ], [ 19, %175 ], [ 18, %174 ], [ %173, %172 ], [ %171, %170 ], [ %169, %168 ], [ 1, %167 ], [ 0, %164 ], [ 0, %164 ], [ 0, %164 ], [ 0, %164 ], [ 0, %164 ]
  %183 = load %struct.global_State*, %struct.global_State** %59, align 8, !tbaa !2
  %184 = zext i32 %182 to i64
  %185 = getelementptr inbounds %struct.global_State, %struct.global_State* %183, i64 0, i32 40, i64 %184
  %186 = bitcast %struct.TString** %185 to i8**
  %187 = load i8*, i8** %186, align 8, !tbaa !39
  %188 = getelementptr inbounds i8, i8* %187, i64 26
  br label %189

; <label>:189:                                    ; preds = %164, %150, %136, %181, %180, %179
  %190 = phi i8* [ %188, %181 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.156, i64 0, i64 0), %180 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.155, i64 0, i64 0), %179 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0), %136 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %150 ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), %164 ]
  %191 = phi i8* [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %181 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %180 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %179 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %136 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.153, i64 0, i64 0), %150 ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), %164 ]
  store i8* %190, i8** %33, align 8, !tbaa !39
  store i8* %191, i8** %48, align 8, !tbaa !120
  br label %209

; <label>:192:                                    ; preds = %164, %144, %141, %135
  store i8* null, i8** %48, align 8, !tbaa !120
  br label %198

; <label>:193:                                    ; preds = %164, %164
  %194 = lshr i32 %161, 7
  %195 = and i32 %194, 255
  %196 = tail call fastcc i8* @getobjname(%struct.Proto* %155, i32 %156, i32 %195, i8** nonnull %33) #17
  store i8* %196, i8** %48, align 8, !tbaa !120
  %197 = icmp eq i8* %196, null
  br i1 %197, label %198, label %209

; <label>:198:                                    ; preds = %193, %192
  store <2 x i8*> <i8* null, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)>, <2 x i8*>* %60, align 8, !tbaa !39
  br label %209

; <label>:199:                                    ; preds = %66
  br i1 %32, label %204, label %200

; <label>:200:                                    ; preds = %199
  %201 = load i16, i16* %42, align 2, !tbaa !60
  %202 = trunc i16 %201 to i8
  %203 = icmp slt i8 %202, 0
  br i1 %203, label %205, label %204

; <label>:204:                                    ; preds = %200, %199
  store i16 0, i16* %49, align 2, !tbaa !121
  store i16 0, i16* %50, align 8, !tbaa !122
  br label %209

; <label>:205:                                    ; preds = %200
  %206 = load i16, i16* %55, align 8, !tbaa !21
  store i16 %206, i16* %50, align 8, !tbaa !122
  %207 = load i16, i16* %56, align 2, !tbaa !21
  store i16 %207, i16* %49, align 2, !tbaa !121
  br label %209

; <label>:208:                                    ; preds = %66
  br label %209

; <label>:209:                                    ; preds = %208, %205, %204, %198, %193, %189, %133, %121, %120, %112, %101, %66, %66
  %210 = phi i32 [ 0, %208 ], [ %63, %66 ], [ %63, %66 ], [ %63, %204 ], [ %63, %205 ], [ %63, %198 ], [ %63, %193 ], [ %63, %133 ], [ %63, %120 ], [ %63, %121 ], [ %63, %112 ], [ %63, %101 ], [ %63, %189 ]
  %211 = getelementptr inbounds i8, i8* %62, i64 1
  br label %61

; <label>:212:                                    ; preds = %61
  %213 = tail call i8* @strchr(i8* %21, i32 102) #21
  %214 = icmp eq i8* %213, null
  br i1 %214, label %226, label %215

; <label>:215:                                    ; preds = %212
  %216 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %217 = bitcast %union.StackValue** %216 to %struct.TValue**
  %218 = load %struct.TValue*, %struct.TValue** %217, align 8, !tbaa !20
  %219 = bitcast %struct.TValue* %19 to i64*
  %220 = bitcast %struct.TValue* %218 to i64*
  %221 = load i64, i64* %219, align 8
  store i64 %221, i64* %220, align 8
  %222 = load i8, i8* %22, align 8, !tbaa !22
  %223 = getelementptr inbounds %struct.TValue, %struct.TValue* %218, i64 0, i32 1
  store i8 %222, i8* %223, align 8, !tbaa !22
  %224 = load %union.StackValue*, %union.StackValue** %216, align 8, !tbaa !20
  %225 = getelementptr inbounds %union.StackValue, %union.StackValue* %224, i64 1
  store %union.StackValue* %225, %union.StackValue** %216, align 8, !tbaa !20
  br label %226

; <label>:226:                                    ; preds = %212, %215
  %227 = tail call i8* @strchr(i8* %21, i32 76) #21
  %228 = icmp eq i8* %227, null
  br i1 %228, label %279, label %229

; <label>:229:                                    ; preds = %226
  br i1 %31, label %233, label %230

; <label>:230:                                    ; preds = %229
  %231 = load i8, i8* %40, align 8, !tbaa !21
  %232 = icmp eq i8 %231, 54
  br i1 %232, label %233, label %240

; <label>:233:                                    ; preds = %230, %229
  %234 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %235 = bitcast %union.StackValue** %234 to %struct.TValue**
  %236 = load %struct.TValue*, %struct.TValue** %235, align 8, !tbaa !20
  %237 = getelementptr inbounds %struct.TValue, %struct.TValue* %236, i64 0, i32 1
  store i8 0, i8* %237, align 8, !tbaa !21
  %238 = load %union.StackValue*, %union.StackValue** %234, align 8, !tbaa !20
  %239 = getelementptr inbounds %union.StackValue, %union.StackValue* %238, i64 1
  store %union.StackValue* %239, %union.StackValue** %234, align 8, !tbaa !20
  br label %279

; <label>:240:                                    ; preds = %230
  %241 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %241) #7
  %242 = load %struct.Proto*, %struct.Proto** %52, align 8, !tbaa !21
  %243 = getelementptr inbounds %struct.Proto, %struct.Proto* %242, i64 0, i32 13
  %244 = load i32, i32* %243, align 4, !tbaa !110
  %245 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #17
  %246 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %247 = bitcast %union.StackValue** %246 to %struct.TValue**
  %248 = load %struct.TValue*, %struct.TValue** %247, align 8, !tbaa !20
  %249 = bitcast %struct.TValue* %248 to %struct.Table**
  store %struct.Table* %245, %struct.Table** %249, align 8, !tbaa !21
  %250 = getelementptr inbounds %struct.TValue, %struct.TValue* %248, i64 0, i32 1
  store i8 69, i8* %250, align 8, !tbaa !22
  %251 = load %union.StackValue*, %union.StackValue** %246, align 8, !tbaa !20
  %252 = getelementptr inbounds %union.StackValue, %union.StackValue* %251, i64 1
  store %union.StackValue* %252, %union.StackValue** %246, align 8, !tbaa !20
  %253 = bitcast %struct.TValue* %4 to i32*
  store i32 1, i32* %253, align 8, !tbaa !21
  %254 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 1, i8* %254, align 8, !tbaa !22
  %255 = getelementptr inbounds %struct.Proto, %struct.Proto* %242, i64 0, i32 9
  %256 = getelementptr inbounds %struct.Proto, %struct.Proto* %242, i64 0, i32 19
  br label %257

; <label>:257:                                    ; preds = %274, %240
  %258 = phi i64 [ %277, %274 ], [ 0, %240 ]
  %259 = phi i32 [ %275, %274 ], [ %244, %240 ]
  %260 = load i32, i32* %255, align 4, !tbaa !123
  %261 = sext i32 %260 to i64
  %262 = icmp slt i64 %258, %261
  br i1 %262, label %263, label %278

; <label>:263:                                    ; preds = %257
  %264 = load i8*, i8** %256, align 8, !tbaa !124
  %265 = getelementptr inbounds i8, i8* %264, i64 %258
  %266 = load i8, i8* %265, align 1, !tbaa !21
  %267 = icmp eq i8 %266, -128
  br i1 %267, label %271, label %268

; <label>:268:                                    ; preds = %263
  %269 = sext i8 %266 to i32
  %270 = add nsw i32 %259, %269
  br label %274

; <label>:271:                                    ; preds = %263
  %272 = trunc i64 %258 to i32
  %273 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %242, i32 %272) #17
  br label %274

; <label>:274:                                    ; preds = %271, %268
  %275 = phi i32 [ %270, %268 ], [ %273, %271 ]
  %276 = sext i32 %275 to i64
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %245, i64 %276, %struct.TValue* nonnull %4) #17
  %277 = add nuw nsw i64 %258, 1
  br label %257

; <label>:278:                                    ; preds = %257
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %241) #7
  br label %279

; <label>:279:                                    ; preds = %278, %233, %226
  ret i32 %63
}

; Function Attrs: minsize nounwind optsize readonly
declare i8* @strchr(i8*, i32) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_resume(%struct.lua_State*, %struct.lua_State* readonly, i32, i32* nocapture) local_unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  store i32 %2, i32* %5, align 4, !tbaa !74
  %7 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %9 = load i8, i8* %8, align 2, !tbaa !57
  switch i8 %9, label %16 [
    i8 0, label %10
    i8 1, label %17
  ]

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %14 = icmp eq %struct.CallInfo* %12, %13
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %10
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str, i64 0, i64 0), i32 %2) #16
  br label %113

; <label>:16:                                     ; preds = %4
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0), i32 %2) #16
  br label %113

; <label>:17:                                     ; preds = %4, %10
  %18 = icmp eq %struct.lua_State* %1, null
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %17
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 1, i32* %20, align 8
  br label %37

; <label>:21:                                     ; preds = %17
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 19
  %23 = load i32, i32* %22, align 8, !tbaa !54
  %24 = and i32 %23, 65535
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 5
  %26 = load i16, i16* %25, align 4, !tbaa !50
  %27 = zext i16 %26 to i32
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %29 = load i16, i16* %28, align 4, !tbaa !50
  %30 = zext i16 %29 to i32
  %31 = add nuw nsw i32 %24, 10
  %32 = sub nsw i32 %31, %27
  %33 = add nsw i32 %32, %30
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 %33, i32* %34, align 8
  %35 = icmp ugt i32 %33, 2199
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %21
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0), i32 %2) #16
  br label %113

; <label>:37:                                     ; preds = %19, %21
  %38 = bitcast i32* %5 to i8*
  %39 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @resume, i8* nonnull %38) #16
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %42 = bitcast %union.StackValue** %41 to i8**
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  br label %45

; <label>:45:                                     ; preds = %60, %37
  %46 = phi i32 [ %39, %37 ], [ %79, %60 ]
  store i32 %46, i32* %6, align 4, !tbaa !74
  %47 = icmp sgt i32 %46, 1
  br i1 %47, label %48, label %92

; <label>:48:                                     ; preds = %45
  br label %49

; <label>:49:                                     ; preds = %48, %58
  %50 = phi %struct.CallInfo** [ %59, %58 ], [ %40, %48 ]
  %51 = load %struct.CallInfo*, %struct.CallInfo** %50, align 8, !tbaa !39
  %52 = icmp eq %struct.CallInfo* %51, null
  br i1 %52, label %80, label %53

; <label>:53:                                     ; preds = %49
  %54 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %51, i64 0, i32 7
  %55 = load i16, i16* %54, align 2, !tbaa !60
  %56 = and i16 %55, 8
  %57 = icmp eq i16 %56, 0
  br i1 %57, label %58, label %60

; <label>:58:                                     ; preds = %53
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %51, i64 0, i32 2
  br label %49

; <label>:60:                                     ; preds = %53
  %61 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %51, i64 0, i32 7
  %62 = load i8*, i8** %42, align 8, !tbaa !48
  %63 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %51, i64 0, i32 5, i32 0
  %64 = load i32, i32* %63, align 8, !tbaa !21
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds i8, i8* %62, i64 %65
  %67 = bitcast i8* %66 to %union.StackValue*
  %68 = call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %67, i32 %46) #17
  %69 = load i8*, i8** %42, align 8, !tbaa !48
  %70 = load i32, i32* %63, align 8, !tbaa !21
  %71 = sext i32 %70 to i64
  %72 = getelementptr inbounds i8, i8* %69, i64 %71
  %73 = bitcast i8* %72 to %union.StackValue*
  call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %46, %union.StackValue* %73) #17
  store %struct.CallInfo* %51, %struct.CallInfo** %40, align 8, !tbaa !49
  %74 = load i16, i16* %61, align 2, !tbaa !60
  %75 = trunc i16 %74 to i8
  %76 = and i8 %75, 1
  store i8 %76, i8* %43, align 1, !tbaa !55
  call fastcc void @luaD_shrinkstack(%struct.lua_State* %0) #17
  %77 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %51, i64 0, i32 4, i32 0, i32 1
  %78 = load i64, i64* %77, align 8, !tbaa !21
  store i64 %78, i64* %44, align 8, !tbaa !58
  %79 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @unroll, i8* nonnull %7) #16
  br label %45

; <label>:80:                                     ; preds = %49
  %81 = icmp slt i32 %46, 2
  br i1 %81, label %92, label %82, !prof !70

; <label>:82:                                     ; preds = %80
  %83 = trunc i32 %46 to i8
  store i8 %83, i8* %8, align 2, !tbaa !57
  %84 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %85 = load %union.StackValue*, %union.StackValue** %84, align 8, !tbaa !20
  call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %46, %union.StackValue* %85) #16
  %86 = bitcast %union.StackValue** %84 to i64*
  %87 = load i64, i64* %86, align 8, !tbaa !20
  %88 = load %struct.CallInfo*, %struct.CallInfo** %40, align 8, !tbaa !49
  %89 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %88, i64 0, i32 1
  %90 = bitcast %union.StackValue** %89 to i64*
  store i64 %87, i64* %90, align 8, !tbaa !63
  %91 = load i32, i32* %6, align 4, !tbaa !74
  br label %92

; <label>:92:                                     ; preds = %45, %80, %82
  %93 = phi i32 [ %46, %80 ], [ %91, %82 ], [ %46, %45 ]
  %94 = icmp eq i32 %93, 1
  br i1 %94, label %95, label %99

; <label>:95:                                     ; preds = %92
  %96 = load %struct.CallInfo*, %struct.CallInfo** %40, align 8, !tbaa !49
  %97 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %96, i64 0, i32 5, i32 0
  %98 = load i32, i32* %97, align 8, !tbaa !21
  br label %111

; <label>:99:                                     ; preds = %92
  %100 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %101 = bitcast %union.StackValue** %100 to i64*
  %102 = load i64, i64* %101, align 8, !tbaa !20
  %103 = load %struct.CallInfo*, %struct.CallInfo** %40, align 8, !tbaa !49
  %104 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %103, i64 0, i32 0
  %105 = load %union.StackValue*, %union.StackValue** %104, align 8, !tbaa !61
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %105, i64 1
  %107 = ptrtoint %union.StackValue* %106 to i64
  %108 = sub i64 %102, %107
  %109 = lshr exact i64 %108, 4
  %110 = trunc i64 %109 to i32
  br label %111

; <label>:111:                                    ; preds = %99, %95
  %112 = phi i32 [ %98, %95 ], [ %110, %99 ]
  store i32 %112, i32* %3, align 4, !tbaa !74
  br label %113

; <label>:113:                                    ; preds = %111, %36, %16, %15
  %114 = phi i32 [ 2, %15 ], [ 2, %36 ], [ %93, %111 ], [ 2, %16 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  ret i32 %114
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @resume_error(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = sext i32 %2 to i64
  %7 = sub nsw i64 0, %6
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 %7
  store %union.StackValue* %8, %union.StackValue** %4, align 8, !tbaa !20
  %9 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %1) #16
  %10 = bitcast %union.StackValue* %8 to %struct.TString**
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !72
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 %7, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @resume(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !74
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %8 = load i8, i8* %7, align 2, !tbaa !57
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = sext i32 %4 to i64
  %14 = sub nsw i64 0, %13
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 %14
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %16, i32 -1) #16
  br label %34

; <label>:17:                                     ; preds = %2
  store i8 0, i8* %7, align 2, !tbaa !57
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %19 = load i16, i16* %18, align 2, !tbaa !60
  %20 = and i16 %19, 2
  %21 = icmp eq i16 %20, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6) #16
  br label %33

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  %25 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %24, align 8, !tbaa !21
  %26 = icmp eq i32 (%struct.lua_State*, i32, i64)* %25, null
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %23
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %25(%struct.lua_State* nonnull %0, i32 1, i64 %29) #17
  br label %31

; <label>:31:                                     ; preds = %23, %27
  %32 = phi i32 [ %30, %27 ], [ %4, %23 ]
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6, i32 %32) #16
  br label %33

; <label>:33:                                     ; preds = %31, %22
  tail call void @unroll(%struct.lua_State* nonnull %0, i8* null) #16
  br label %34

; <label>:34:                                     ; preds = %33, %10
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @unroll(%struct.lua_State*, i8* readonly) #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %7, label %4

; <label>:4:                                      ; preds = %2
  %5 = bitcast i8* %1 to i32*
  %6 = load i32, i32* %5, align 4, !tbaa !74
  tail call fastcc void @finishCcall(%struct.lua_State* %0, i32 %6) #16
  br label %7

; <label>:7:                                      ; preds = %2, %4
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %11

; <label>:11:                                     ; preds = %89, %7
  %12 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !49
  %13 = icmp eq %struct.CallInfo* %12, %9
  br i1 %13, label %90, label %14

; <label>:14:                                     ; preds = %11
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 7
  %16 = load i16, i16* %15, align 2, !tbaa !60
  %17 = and i16 %16, 2
  %18 = icmp eq i16 %17, 0
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %14
  tail call fastcc void @finishCcall(%struct.lua_State* nonnull %0, i32 1) #16
  br label %89

; <label>:20:                                     ; preds = %14
  %21 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !61
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 4
  %25 = bitcast %union.anon.0* %24 to i32**
  %26 = load i32*, i32** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds i32, i32* %26, i64 -1
  %28 = load i32, i32* %27, align 4, !tbaa !74
  %29 = trunc i32 %28 to i7
  switch i7 %29, label %88 [
    i7 19, label %30
    i7 20, label %30
    i7 21, label %30
    i7 24, label %30
    i7 25, label %30
    i7 22, label %30
    i7 23, label %30
    i7 38, label %30
    i7 39, label %30
    i7 40, label %30
    i7 43, label %30
    i7 44, label %30
    i7 33, label %30
    i7 34, label %30
    i7 35, label %30
    i7 45, label %30
    i7 46, label %30
    i7 47, label %30
    i7 36, label %30
    i7 48, label %30
    i7 49, label %30
    i7 41, label %30
    i7 42, label %30
    i7 50, label %30
    i7 51, label %30
    i7 53, label %30
    i7 9, label %30
    i7 10, label %30
    i7 11, label %30
    i7 12, label %30
    i7 18, label %30
    i7 59, label %43
    i7 60, label %43
    i7 63, label %43
    i7 -64, label %43
    i7 -63, label %43
    i7 -62, label %43
    i7 58, label %43
    i7 54, label %66
  ]

; <label>:30:                                     ; preds = %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20
  %31 = lshr i32 %28, 7
  %32 = and i32 %31, 255
  %33 = zext i32 %32 to i64
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 %33
  %35 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 -1
  store %union.StackValue* %36, %union.StackValue** %10, align 8, !tbaa !20
  %37 = bitcast %union.StackValue* %36 to i64*
  %38 = bitcast %union.StackValue* %34 to i64*
  %39 = load i64, i64* %37, align 8
  store i64 %39, i64* %38, align 8
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 -1, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 0, i32 0, i32 1
  store i8 %41, i8* %42, align 8, !tbaa !22
  br label %88

; <label>:43:                                     ; preds = %20, %20, %20, %20, %20, %20, %20
  %44 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 -1, i32 0, i32 1
  %46 = load i8, i8* %45, align 8, !tbaa !21
  %47 = and i8 %46, 15
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %57, label %49

; <label>:49:                                     ; preds = %43
  %50 = icmp eq i8 %46, 1
  br i1 %50, label %51, label %57

; <label>:51:                                     ; preds = %49
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 -1, i32 0, i32 0
  %53 = bitcast %union.Value* %52 to i32*
  %54 = load i32, i32* %53, align 8, !tbaa !21
  %55 = icmp ne i32 %54, 0
  %56 = zext i1 %55 to i32
  br label %57

; <label>:57:                                     ; preds = %51, %49, %43
  %58 = phi i32 [ 0, %43 ], [ 1, %49 ], [ %56, %51 ]
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 -1
  store %union.StackValue* %59, %union.StackValue** %10, align 8, !tbaa !20
  %60 = lshr i32 %28, 15
  %61 = and i32 %60, 1
  %62 = icmp eq i32 %58, %61
  br i1 %62, label %88, label %63

; <label>:63:                                     ; preds = %57
  %64 = load i32*, i32** %25, align 8, !tbaa !21
  %65 = getelementptr inbounds i32, i32* %64, i64 1
  store i32* %65, i32** %25, align 8, !tbaa !21
  br label %88

; <label>:66:                                     ; preds = %20
  %67 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %68 = lshr i32 %28, 7
  %69 = and i32 %68, 255
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 -2
  %71 = zext i32 %69 to i64
  %72 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 %71
  %73 = ptrtoint %union.StackValue* %70 to i64
  %74 = ptrtoint %union.StackValue* %72 to i64
  %75 = sub i64 %73, %74
  %76 = lshr exact i64 %75, 4
  %77 = trunc i64 %76 to i32
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 -3, i32 0
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 -1, i32 0
  %80 = bitcast %struct.TValue* %79 to i64*
  %81 = bitcast %struct.TValue* %78 to i64*
  %82 = load i64, i64* %80, align 8
  store i64 %82, i64* %81, align 8
  %83 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 -1, i32 0, i32 1
  %84 = load i8, i8* %83, align 8, !tbaa !22
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 -3, i32 0, i32 1
  store i8 %84, i8* %85, align 8, !tbaa !22
  %86 = icmp sgt i32 %77, 1
  br i1 %86, label %87, label %88

; <label>:87:                                     ; preds = %66
  store %union.StackValue* %70, %union.StackValue** %10, align 8, !tbaa !20
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %0, i32 %77) #17
  br label %88

; <label>:88:                                     ; preds = %20, %30, %57, %63, %66, %87
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %12) #16
  br label %89

; <label>:89:                                     ; preds = %88, %19
  br label %11

; <label>:90:                                     ; preds = %11
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_isyieldable(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !54
  %4 = icmp ult i32 %3, 65536
  %5 = zext i1 %4 to i32
  ret i32 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_yieldk(%struct.lua_State*, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %8 = load i32, i32* %7, align 8, !tbaa !54
  %9 = icmp ugt i32 %8, 65535
  br i1 %9, label %10, label %18, !prof !47

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 38
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !27
  %15 = icmp eq %struct.lua_State* %14, %0
  br i1 %15, label %17, label %16

; <label>:16:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3, i64 0, i64 0)) #18
  unreachable

; <label>:17:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.4, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 1, i8* %19, align 2, !tbaa !57
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %21 = load i16, i16* %20, align 2, !tbaa !60
  %22 = and i16 %21, 2
  %23 = icmp eq i16 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 0, i32* %25, align 8, !tbaa !21
  ret i32 0

; <label>:26:                                     ; preds = %18
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %3, i32 (%struct.lua_State*, i32, i64)** %27, align 8, !tbaa !21
  %28 = icmp eq i32 (%struct.lua_State*, i32, i64)* %3, null
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  store i64 %2, i64* %30, align 8, !tbaa !21
  br label %31

; <label>:31:                                     ; preds = %26, %29
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 %1, i32* %32, align 8, !tbaa !21
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal void @luaG_runerror(%struct.lua_State*, i8*, ...) unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !49
  %6 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %13

; <label>:13:                                     ; preds = %12, %2
  %14 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %6)
  %15 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* nonnull %0, i8* %1, %struct.__va_list_tag* nonnull %14) #16
  call void @llvm.va_end(i8* nonnull %6)
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 7
  %17 = load i16, i16* %16, align 2, !tbaa !60
  %18 = and i16 %17, 2
  %19 = icmp eq i16 %18, 0
  br i1 %19, label %20, label %30

; <label>:20:                                     ; preds = %13
  %21 = bitcast %struct.CallInfo* %5 to %struct.LClosure***
  %22 = load %struct.LClosure**, %struct.LClosure*** %21, align 8, !tbaa !61
  %23 = load %struct.LClosure*, %struct.LClosure** %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %23, i64 0, i32 5
  %25 = load %struct.Proto*, %struct.Proto** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %25, i64 0, i32 22
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !108
  %28 = call fastcc i32 @currentline(%struct.CallInfo* nonnull %5) #16
  %29 = call fastcc i8* @luaG_addinfo(%struct.lua_State* nonnull %0, i8* nonnull %15, %struct.TString* %27, i32 %28) #16
  br label %30

; <label>:30:                                     ; preds = %13, %20
  call fastcc void @luaG_errormsg(%struct.lua_State* nonnull %0) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaD_throw(%struct.lua_State*, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %4 = load %struct.lua_longjmp*, %struct.lua_longjmp** %3, align 8, !tbaa !53
  %5 = icmp eq %struct.lua_longjmp* %4, null
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 %1, i32* %7, align 8, !tbaa !81
  %8 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  tail call void @longjmp(%struct.__jmp_buf_tag* nonnull %8, i32 1) #19
  unreachable

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !48
  %14 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %13, i32 %1) #16
  %15 = trunc i32 %14 to i8
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %15, i8* %16, align 2, !tbaa !57
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 38
  %18 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !27
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 15
  %20 = load %struct.lua_longjmp*, %struct.lua_longjmp** %19, align 8, !tbaa !53
  %21 = icmp eq %struct.lua_longjmp* %20, null
  br i1 %21, label %36, label %22

; <label>:22:                                     ; preds = %9
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %23, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0
  %29 = bitcast %struct.TValue* %28 to i64*
  %30 = bitcast %union.StackValue* %24 to i64*
  %31 = load i64, i64* %29, align 8
  store i64 %31, i64* %30, align 8
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 0, i32 0, i32 1
  store i8 %33, i8* %34, align 8, !tbaa !22
  %35 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !27
  tail call fastcc void @luaD_throw(%struct.lua_State* %35, i32 %14) #18
  unreachable

; <label>:36:                                     ; preds = %9
  %37 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 37
  %38 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !77
  %39 = icmp eq i32 (%struct.lua_State*)* %38, null
  br i1 %39, label %53, label %40

; <label>:40:                                     ; preds = %36
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %42 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %14, %union.StackValue* %42) #16
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %44 = load %struct.CallInfo*, %struct.CallInfo** %43, align 8, !tbaa !49
  %45 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %44, i64 0, i32 1
  %46 = load %union.StackValue*, %union.StackValue** %45, align 8, !tbaa !63
  %47 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %48 = icmp ult %union.StackValue* %46, %47
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %40
  store %union.StackValue* %47, %union.StackValue** %45, align 8, !tbaa !63
  br label %50

; <label>:50:                                     ; preds = %49, %40
  %51 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !77
  %52 = tail call i32 %51(%struct.lua_State* nonnull %0) #17
  br label %53

; <label>:53:                                     ; preds = %36, %50
  tail call void @abort() #19
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_checkstack(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !49
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !59
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = sub i64 %7, %10
  %12 = ashr exact i64 %11, 4
  %13 = sext i32 %1 to i64
  %14 = icmp sgt i64 %12, %13
  %15 = inttoptr i64 %10 to %union.StackValue*
  br i1 %14, label %31, label %16

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !48
  %20 = sub i64 %10, %19
  %21 = lshr exact i64 %20, 4
  %22 = trunc i64 %21 to i32
  %23 = add nsw i32 %22, 5
  %24 = sub nsw i32 1000000, %1
  %25 = icmp sgt i32 %23, %24
  br i1 %25, label %39, label %26

; <label>:26:                                     ; preds = %16
  %27 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %1, i32 0) #16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %39, label %29

; <label>:29:                                     ; preds = %26
  %30 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  br label %31

; <label>:31:                                     ; preds = %29, %2
  %32 = phi %union.StackValue* [ %30, %29 ], [ %15, %2 ]
  %33 = phi i32 [ %27, %29 ], [ 1, %2 ]
  %34 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %35 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !63
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 %13
  %37 = icmp ult %union.StackValue* %35, %36
  br i1 %37, label %38, label %39

; <label>:38:                                     ; preds = %31
  store %union.StackValue* %36, %union.StackValue** %34, align 8, !tbaa !63
  br label %39

; <label>:39:                                     ; preds = %16, %26, %38, %31
  %40 = phi i32 [ 0, %26 ], [ %33, %38 ], [ %33, %31 ], [ 0, %16 ]
  ret i32 %40
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaD_growstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !51
  %6 = icmp sgt i32 %5, 1000000
  br i1 %6, label %7, label %10, !prof !47

; <label>:7:                                      ; preds = %3
  %8 = icmp eq i32 %2, 0
  br i1 %8, label %34, label %9

; <label>:9:                                      ; preds = %7
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #18
  unreachable

; <label>:10:                                     ; preds = %3
  %11 = shl nsw i32 %5, 1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %16 = bitcast %union.StackValue** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !48
  %18 = sub i64 %14, %17
  %19 = lshr exact i64 %18, 4
  %20 = trunc i64 %19 to i32
  %21 = add i32 %1, 5
  %22 = add i32 %21, %20
  %23 = icmp sgt i32 %5, 500000
  %24 = select i1 %23, i32 1000000, i32 %11
  %25 = icmp slt i32 %24, %22
  %26 = select i1 %25, i32 %22, i32 %24
  %27 = icmp sgt i32 %26, 1000000
  br i1 %27, label %28, label %32, !prof !47

; <label>:28:                                     ; preds = %10
  %29 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 1000200, i32 %2) #16
  %30 = icmp eq i32 %2, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #18
  unreachable

; <label>:32:                                     ; preds = %10
  %33 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %26, i32 %2) #16
  br label %34

; <label>:34:                                     ; preds = %28, %7, %32
  %35 = phi i32 [ %33, %32 ], [ 0, %7 ], [ 0, %28 ]
  ret i32 %35
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_xmove(%struct.lua_State*, %struct.lua_State*, i32) local_unnamed_addr #2 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %29, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = sext i32 %2 to i64
  %9 = sub nsw i64 0, %8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %9
  store %union.StackValue* %10, %union.StackValue** %6, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  br label %13

; <label>:13:                                     ; preds = %16, %5
  %14 = phi i64 [ %28, %16 ], [ 0, %5 ]
  %15 = icmp slt i64 %14, %8
  br i1 %15, label %16, label %29

; <label>:16:                                     ; preds = %13
  %17 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %18 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 %14, i32 0
  %20 = bitcast %struct.TValue* %19 to i64*
  %21 = bitcast %struct.TValue* %17 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 %14, i32 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  %26 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 1
  store %union.StackValue* %27, %union.StackValue** %11, align 8, !tbaa !20
  %28 = add nuw nsw i64 %14, 1
  br label %13

; <label>:29:                                     ; preds = %13, %3
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 (%struct.lua_State*)* @lua_atpanic(%struct.lua_State* nocapture readonly, i32 (%struct.lua_State*)*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 37
  %6 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %5, align 8, !tbaa !77
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %5, align 8, !tbaa !77
  ret i32 (%struct.lua_State*)* %6
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define double @lua_version(%struct.lua_State* nocapture readnone) local_unnamed_addr #6 {
  ret double 5.040000e+02
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_absindex(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = add i32 %1, 1000999
  %4 = icmp ugt i32 %3, 1000999
  br i1 %4, label %17, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = bitcast %struct.CallInfo** %9 to i64**
  %11 = load i64*, i64** %10, align 8, !tbaa !49
  %12 = load i64, i64* %11, align 8, !tbaa !61
  %13 = sub i64 %8, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, %1
  br label %17

; <label>:17:                                     ; preds = %2, %5
  %18 = phi i32 [ %16, %5 ], [ %1, %2 ]
  ret i32 %18
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_gettop(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  ret i32 %13
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_settop(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, -1
  br i1 %3, label %4, label %20

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = sext i32 %1 to i64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %10
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %13

; <label>:13:                                     ; preds = %16, %4
  %14 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %15 = icmp ult %union.StackValue* %14, %11
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %13
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %17, %union.StackValue** %12, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 0, i32 0, i32 1
  store i8 0, i8* %18, align 8, !tbaa !21
  br label %13

; <label>:19:                                     ; preds = %13
  store %union.StackValue* %11, %union.StackValue** %12, align 8, !tbaa !20
  br label %26

; <label>:20:                                     ; preds = %2
  %21 = add nsw i32 %1, 1
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %24 = sext i32 %21 to i64
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 %24
  store %union.StackValue* %25, %union.StackValue** %22, align 8, !tbaa !20
  br label %26

; <label>:26:                                     ; preds = %20, %19
  %27 = phi %union.StackValue* [ %25, %20 ], [ %11, %19 ]
  %28 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %27, i32 0) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_rotate(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  %7 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %1) #16
  %8 = icmp sgt i32 %2, -1
  %9 = sext i32 %2 to i64
  %10 = sub nsw i64 0, %9
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %10
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %10
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 -1
  %14 = select i1 %8, %union.StackValue* %11, %union.StackValue* %13
  tail call fastcc void @reverse(%union.StackValue* %7, %union.StackValue* nonnull %14) #16
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  tail call fastcc void @reverse(%union.StackValue* nonnull %15, %union.StackValue* nonnull %6) #16
  tail call fastcc void @reverse(%union.StackValue* %7, %union.StackValue* nonnull %6) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %union.StackValue* @index2stack(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %4, label %8

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  br label %10

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %10

; <label>:10:                                     ; preds = %8, %4
  %11 = phi %union.StackValue** [ %9, %8 ], [ %7, %4 ]
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !39
  %13 = sext i32 %1 to i64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 %13
  ret %union.StackValue* %14
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @reverse(%union.StackValue*, %union.StackValue*) unnamed_addr #2 {
  br label %3

; <label>:3:                                      ; preds = %7, %2
  %4 = phi %union.StackValue* [ %1, %2 ], [ %17, %7 ]
  %5 = phi %union.StackValue* [ %0, %2 ], [ %16, %7 ]
  %6 = icmp ult %union.StackValue* %5, %4
  br i1 %6, label %7, label %18

; <label>:7:                                      ; preds = %3
  %8 = bitcast %union.StackValue* %5 to i64*
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 0, i32 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = bitcast %union.StackValue* %4 to i64*
  %13 = load i64, i64* %12, align 8
  store i64 %13, i64* %8, align 8
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 0, i32 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  store i8 %15, i8* %10, align 8, !tbaa !22
  store i64 %9, i64* %12, align 8
  store i8 %11, i8* %14, align 8, !tbaa !22
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -1
  br label %3

; <label>:18:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_copy(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %6 = bitcast %struct.TValue* %4 to i64*
  %7 = bitcast %struct.TValue* %5 to i64*
  %8 = load i64, i64* %6, align 8
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  %12 = icmp slt i32 %2, -1001000
  br i1 %12, label %13, label %36

; <label>:13:                                     ; preds = %3
  %14 = load i8, i8* %9, align 8, !tbaa !22
  %15 = and i8 %14, 64
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %36, label %17

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = bitcast %struct.CallInfo** %18 to %struct.CClosure****
  %20 = load %struct.CClosure***, %struct.CClosure**** %19, align 8, !tbaa !49
  %21 = load %struct.CClosure**, %struct.CClosure*** %20, align 8, !tbaa !61
  %22 = load %struct.CClosure*, %struct.CClosure** %21, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %22, i64 0, i32 2
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = and i8 %24, 32
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %36, label %27

; <label>:27:                                     ; preds = %17
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %29 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !67
  %32 = and i8 %31, 24
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %27
  %35 = bitcast %struct.CClosure* %22 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %35, %struct.GCObject* %29) #16
  br label %36

; <label>:36:                                     ; preds = %27, %17, %13, %34, %3
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @index2value(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !49
  %5 = icmp sgt i32 %1, 0
  br i1 %5, label %6, label %20

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %9
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = icmp ult %union.StackValue* %10, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  br label %59

; <label>:18:                                     ; preds = %6
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  br label %59

; <label>:20:                                     ; preds = %2
  %21 = icmp slt i32 %1, -1000999
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %20
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = sext i32 %1 to i64
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %25, i32 0
  br label %59

; <label>:27:                                     ; preds = %20
  %28 = icmp eq i32 %1, -1001000
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %27
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %31 = load %struct.global_State*, %struct.global_State** %30, align 8, !tbaa !2
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %31, i64 0, i32 7
  br label %59

; <label>:33:                                     ; preds = %27
  %34 = sub nsw i32 -1001000, %1
  %35 = bitcast %struct.CallInfo* %4 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !61
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !21
  %39 = icmp eq i8 %38, 38
  br i1 %39, label %40, label %44

; <label>:40:                                     ; preds = %33
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %42 = load %struct.global_State*, %struct.global_State** %41, align 8, !tbaa !2
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %42, i64 0, i32 8
  br label %59

; <label>:44:                                     ; preds = %33
  %45 = bitcast %struct.TValue* %36 to %struct.CClosure**
  %46 = load %struct.CClosure*, %struct.CClosure** %45, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 3
  %48 = load i8, i8* %47, align 2, !tbaa !125
  %49 = zext i8 %48 to i32
  %50 = icmp sgt i32 %34, %49
  br i1 %50, label %55, label %51

; <label>:51:                                     ; preds = %44
  %52 = add nsw i32 %34, -1
  %53 = sext i32 %52 to i64
  %54 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 6, i64 %53
  br label %59

; <label>:55:                                     ; preds = %44
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %57 = load %struct.global_State*, %struct.global_State** %56, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 8
  br label %59

; <label>:59:                                     ; preds = %51, %55, %14, %18, %40, %29, %22
  %60 = phi %struct.TValue* [ %32, %29 ], [ %43, %40 ], [ %26, %22 ], [ %17, %14 ], [ %19, %18 ], [ %54, %51 ], [ %58, %55 ]
  ret %struct.TValue* %60
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_barrier_(%struct.lua_State* nocapture readonly, %struct.GCObject* nocapture, %struct.GCObject*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %7 = load i8, i8* %6, align 1, !tbaa !44
  %8 = icmp ult i8 %7, 3
  br i1 %8, label %9, label %18

; <label>:9:                                      ; preds = %3
  tail call fastcc void @reallymarkobject(%struct.global_State* %5, %struct.GCObject* %2) #16
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !67
  %12 = and i8 %11, 6
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %30, label %14

; <label>:14:                                     ; preds = %9
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !67
  %17 = and i8 %16, -8
  br label %25

; <label>:18:                                     ; preds = %3
  %19 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !67
  %21 = and i8 %20, -64
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %23 = load i8, i8* %22, align 4, !tbaa !15
  %24 = and i8 %23, 24
  br label %25

; <label>:25:                                     ; preds = %18, %14
  %26 = phi i8 [ 2, %14 ], [ %21, %18 ]
  %27 = phi i8 [ %17, %14 ], [ %24, %18 ]
  %28 = phi i8* [ %15, %14 ], [ %19, %18 ]
  %29 = or i8 %27, %26
  store i8 %29, i8* %28, align 1, !tbaa !67
  br label %30

; <label>:30:                                     ; preds = %25, %9
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushvalue(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_type(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 8
  %12 = icmp eq %struct.TValue* %3, %11
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %8, %2
  %14 = zext i8 %6 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %13
  %16 = phi i32 [ %14, %13 ], [ -1, %8 ]
  ret i32 %16
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define i8* @lua_typename(%struct.lua_State* nocapture readnone, i32) local_unnamed_addr #6 {
  %3 = add nsw i32 %1, 1
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !39
  ret i8* %6
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_iscfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 38
  %7 = icmp eq i8 %5, 118
  %8 = or i1 %6, %7
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_isinteger(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 35
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_isnumber(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #0 {
  %3 = alloca double, align 8
  %4 = bitcast double* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 19
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %5 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  %12 = bitcast double* %3 to i64*
  store i64 %11, i64* %12, align 8, !tbaa !127
  br label %15

; <label>:13:                                     ; preds = %2
  %14 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %5, double* nonnull %3) #16
  br label %15

; <label>:15:                                     ; preds = %13, %9
  %16 = phi i32 [ 1, %9 ], [ %14, %13 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaV_tonumber_(%struct.TValue* nocapture readonly, double* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 35
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %0 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !21
  %11 = sitofp i64 %10 to double
  store double %11, double* %1, align 8, !tbaa !127
  br label %45

; <label>:12:                                     ; preds = %2
  %13 = and i8 %6, 15
  %14 = icmp eq i8 %13, 4
  br i1 %14, label %15, label %45

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %0 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds i8, i8* %17, i64 24
  %19 = call fastcc i64 @luaO_str2num(i8* nonnull %18, %struct.TValue* nonnull %3) #16
  %20 = bitcast %struct.TValue* %0 to %struct.TString**
  %21 = load %struct.TString*, %struct.TString** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !21
  %24 = icmp eq i8 %23, 20
  br i1 %24, label %25, label %29

; <label>:25:                                     ; preds = %15
  %26 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 4
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = zext i8 %27 to i64
  br label %32

; <label>:29:                                     ; preds = %15
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 6, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %29, %25
  %33 = phi i64 [ %28, %25 ], [ %31, %29 ]
  %34 = add i64 %33, 1
  %35 = icmp eq i64 %19, %34
  br i1 %35, label %36, label %45

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 35
  %40 = bitcast %struct.TValue* %3 to i64*
  %41 = load i64, i64* %40, align 8
  %42 = sitofp i64 %41 to double
  %43 = bitcast i64 %41 to double
  %44 = select i1 %39, double %42, double %43
  store double %44, double* %1, align 8, !tbaa !127
  br label %45

; <label>:45:                                     ; preds = %12, %32, %36, %8
  %46 = phi i32 [ 1, %8 ], [ 1, %36 ], [ 0, %32 ], [ 0, %12 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %46
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_isstring(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_isuserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 7
  %8 = icmp eq i8 %5, 2
  %9 = or i1 %8, %7
  %10 = zext i1 %9 to i32
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_rawequal(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  %14 = icmp eq %struct.TValue* %4, %13
  br i1 %14, label %27, label %15

; <label>:15:                                     ; preds = %10, %3
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %25

; <label>:20:                                     ; preds = %15
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 8
  %24 = icmp eq %struct.TValue* %5, %23
  br i1 %24, label %27, label %25

; <label>:25:                                     ; preds = %20, %15
  %26 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %4, %struct.TValue* nonnull %5) #16
  br label %27

; <label>:27:                                     ; preds = %10, %20, %25
  %28 = phi i32 [ %26, %25 ], [ 0, %20 ], [ 0, %10 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaV_equalobj(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = xor i8 %9, %7
  %11 = and i8 %10, 63
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %49, label %13

; <label>:13:                                     ; preds = %3
  %14 = and i8 %7, 15
  %15 = and i8 %9, 15
  %16 = icmp eq i8 %14, %15
  %17 = icmp eq i8 %14, 3
  %18 = and i1 %17, %16
  br i1 %18, label %19, label %203

; <label>:19:                                     ; preds = %13
  %20 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %21 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %21) #7
  %22 = icmp eq i8 %7, 35
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %19
  %24 = bitcast %struct.TValue* %1 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !21
  store i64 %25, i64* %4, align 8, !tbaa !129
  br label %31

; <label>:26:                                     ; preds = %19
  %27 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %1, i64* nonnull %4, i32 0) #16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %47, label %29

; <label>:29:                                     ; preds = %26
  %30 = load i8, i8* %8, align 8, !tbaa !22
  br label %31

; <label>:31:                                     ; preds = %29, %23
  %32 = phi i8 [ %30, %29 ], [ %9, %23 ]
  %33 = icmp eq i8 %32, 35
  br i1 %33, label %34, label %37

; <label>:34:                                     ; preds = %31
  %35 = bitcast %struct.TValue* %2 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !21
  store i64 %36, i64* %5, align 8, !tbaa !129
  br label %42

; <label>:37:                                     ; preds = %31
  %38 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2, i64* nonnull %5, i32 0) #16
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %47, label %40

; <label>:40:                                     ; preds = %37
  %41 = load i64, i64* %5, align 8, !tbaa !129
  br label %42

; <label>:42:                                     ; preds = %40, %34
  %43 = phi i64 [ %41, %40 ], [ %36, %34 ]
  %44 = load i64, i64* %4, align 8, !tbaa !129
  %45 = icmp eq i64 %44, %43
  %46 = zext i1 %45 to i32
  br label %47

; <label>:47:                                     ; preds = %37, %26, %42
  %48 = phi i32 [ 0, %37 ], [ 0, %26 ], [ %46, %42 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %21) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %203

; <label>:49:                                     ; preds = %3
  %50 = trunc i8 %7 to i6
  switch i6 %50, label %171 [
    i6 0, label %203
    i6 -29, label %51
    i6 19, label %58
    i6 1, label %65
    i6 2, label %72
    i6 -26, label %79
    i6 20, label %86
    i6 -28, label %93
    i6 7, label %99
    i6 5, label %135
  ]

; <label>:51:                                     ; preds = %49
  %52 = bitcast %struct.TValue* %1 to i64*
  %53 = load i64, i64* %52, align 8, !tbaa !21
  %54 = bitcast %struct.TValue* %2 to i64*
  %55 = load i64, i64* %54, align 8, !tbaa !21
  %56 = icmp eq i64 %53, %55
  %57 = zext i1 %56 to i32
  br label %203

; <label>:58:                                     ; preds = %49
  %59 = bitcast %struct.TValue* %1 to double*
  %60 = load double, double* %59, align 8, !tbaa !21
  %61 = bitcast %struct.TValue* %2 to double*
  %62 = load double, double* %61, align 8, !tbaa !21
  %63 = fcmp oeq double %60, %62
  %64 = zext i1 %63 to i32
  br label %203

; <label>:65:                                     ; preds = %49
  %66 = bitcast %struct.TValue* %1 to i32*
  %67 = load i32, i32* %66, align 8, !tbaa !21
  %68 = bitcast %struct.TValue* %2 to i32*
  %69 = load i32, i32* %68, align 8, !tbaa !21
  %70 = icmp eq i32 %67, %69
  %71 = zext i1 %70 to i32
  br label %203

; <label>:72:                                     ; preds = %49
  %73 = bitcast %struct.TValue* %1 to i8**
  %74 = load i8*, i8** %73, align 8, !tbaa !21
  %75 = bitcast %struct.TValue* %2 to i8**
  %76 = load i8*, i8** %75, align 8, !tbaa !21
  %77 = icmp eq i8* %74, %76
  %78 = zext i1 %77 to i32
  br label %203

; <label>:79:                                     ; preds = %49
  %80 = bitcast %struct.TValue* %1 to i32 (%struct.lua_State*)**
  %81 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %80, align 8, !tbaa !21
  %82 = bitcast %struct.TValue* %2 to i32 (%struct.lua_State*)**
  %83 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %82, align 8, !tbaa !21
  %84 = icmp eq i32 (%struct.lua_State*)* %81, %83
  %85 = zext i1 %84 to i32
  br label %203

; <label>:86:                                     ; preds = %49
  %87 = bitcast %struct.TValue* %1 to %struct.TString**
  %88 = load %struct.TString*, %struct.TString** %87, align 8, !tbaa !21
  %89 = bitcast %struct.TValue* %2 to %struct.TString**
  %90 = load %struct.TString*, %struct.TString** %89, align 8, !tbaa !21
  %91 = icmp eq %struct.TString* %88, %90
  %92 = zext i1 %91 to i32
  br label %203

; <label>:93:                                     ; preds = %49
  %94 = bitcast %struct.TValue* %1 to %struct.TString**
  %95 = load %struct.TString*, %struct.TString** %94, align 8, !tbaa !21
  %96 = bitcast %struct.TValue* %2 to %struct.TString**
  %97 = load %struct.TString*, %struct.TString** %96, align 8, !tbaa !21
  %98 = tail call fastcc i32 @luaS_eqlngstr(%struct.TString* %95, %struct.TString* %97) #16
  br label %203

; <label>:99:                                     ; preds = %49
  %100 = bitcast %struct.TValue* %1 to %struct.Udata**
  %101 = load %struct.Udata*, %struct.Udata** %100, align 8, !tbaa !21
  %102 = bitcast %struct.TValue* %2 to %struct.Udata**
  %103 = load %struct.Udata*, %struct.Udata** %102, align 8, !tbaa !21
  %104 = icmp eq %struct.Udata* %101, %103
  br i1 %104, label %203, label %105

; <label>:105:                                    ; preds = %99
  %106 = icmp eq %struct.lua_State* %0, null
  br i1 %106, label %203, label %107

; <label>:107:                                    ; preds = %105
  %108 = getelementptr inbounds %struct.Udata, %struct.Udata* %101, i64 0, i32 5
  %109 = load %struct.Table*, %struct.Table** %108, align 8, !tbaa !21
  %110 = icmp eq %struct.Table* %109, null
  br i1 %110, label %125, label %111

; <label>:111:                                    ; preds = %107
  %112 = getelementptr inbounds %struct.Table, %struct.Table* %109, i64 0, i32 3
  %113 = load i8, i8* %112, align 2, !tbaa !131
  %114 = and i8 %113, 32
  %115 = icmp eq i8 %114, 0
  br i1 %115, label %116, label %125

; <label>:116:                                    ; preds = %111
  %117 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %118 = load %struct.global_State*, %struct.global_State** %117, align 8, !tbaa !2
  %119 = getelementptr inbounds %struct.global_State, %struct.global_State* %118, i64 0, i32 40, i64 5
  %120 = load %struct.TString*, %struct.TString** %119, align 8, !tbaa !39
  %121 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %109, i32 5, %struct.TString* %120) #16
  %122 = icmp eq %struct.TValue* %121, null
  br i1 %122, label %123, label %186

; <label>:123:                                    ; preds = %116
  %124 = load %struct.Udata*, %struct.Udata** %102, align 8, !tbaa !21
  br label %125

; <label>:125:                                    ; preds = %123, %111, %107
  %126 = phi %struct.Udata* [ %124, %123 ], [ %103, %111 ], [ %103, %107 ]
  %127 = getelementptr inbounds %struct.Udata, %struct.Udata* %126, i64 0, i32 5
  %128 = load %struct.Table*, %struct.Table** %127, align 8, !tbaa !21
  %129 = icmp eq %struct.Table* %128, null
  br i1 %129, label %203, label %130

; <label>:130:                                    ; preds = %125
  %131 = getelementptr inbounds %struct.Table, %struct.Table* %128, i64 0, i32 3
  %132 = load i8, i8* %131, align 2, !tbaa !131
  %133 = and i8 %132, 32
  %134 = icmp eq i8 %133, 0
  br i1 %134, label %178, label %203

; <label>:135:                                    ; preds = %49
  %136 = bitcast %struct.TValue* %1 to %struct.Table**
  %137 = load %struct.Table*, %struct.Table** %136, align 8, !tbaa !21
  %138 = bitcast %struct.TValue* %2 to %struct.Table**
  %139 = load %struct.Table*, %struct.Table** %138, align 8, !tbaa !21
  %140 = icmp eq %struct.Table* %137, %139
  br i1 %140, label %203, label %141

; <label>:141:                                    ; preds = %135
  %142 = icmp eq %struct.lua_State* %0, null
  br i1 %142, label %203, label %143

; <label>:143:                                    ; preds = %141
  %144 = getelementptr inbounds %struct.Table, %struct.Table* %137, i64 0, i32 9
  %145 = load %struct.Table*, %struct.Table** %144, align 8, !tbaa !21
  %146 = icmp eq %struct.Table* %145, null
  br i1 %146, label %161, label %147

; <label>:147:                                    ; preds = %143
  %148 = getelementptr inbounds %struct.Table, %struct.Table* %145, i64 0, i32 3
  %149 = load i8, i8* %148, align 2, !tbaa !131
  %150 = and i8 %149, 32
  %151 = icmp eq i8 %150, 0
  br i1 %151, label %152, label %161

; <label>:152:                                    ; preds = %147
  %153 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %154 = load %struct.global_State*, %struct.global_State** %153, align 8, !tbaa !2
  %155 = getelementptr inbounds %struct.global_State, %struct.global_State* %154, i64 0, i32 40, i64 5
  %156 = load %struct.TString*, %struct.TString** %155, align 8, !tbaa !39
  %157 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %145, i32 5, %struct.TString* %156) #16
  %158 = icmp eq %struct.TValue* %157, null
  br i1 %158, label %159, label %186

; <label>:159:                                    ; preds = %152
  %160 = load %struct.Table*, %struct.Table** %138, align 8, !tbaa !21
  br label %161

; <label>:161:                                    ; preds = %159, %147, %143
  %162 = phi %struct.Table* [ %160, %159 ], [ %139, %147 ], [ %139, %143 ]
  %163 = getelementptr inbounds %struct.Table, %struct.Table* %162, i64 0, i32 9
  %164 = load %struct.Table*, %struct.Table** %163, align 8, !tbaa !21
  %165 = icmp eq %struct.Table* %164, null
  br i1 %165, label %203, label %166

; <label>:166:                                    ; preds = %161
  %167 = getelementptr inbounds %struct.Table, %struct.Table* %164, i64 0, i32 3
  %168 = load i8, i8* %167, align 2, !tbaa !131
  %169 = and i8 %168, 32
  %170 = icmp eq i8 %169, 0
  br i1 %170, label %178, label %203

; <label>:171:                                    ; preds = %49
  %172 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %173 = load %struct.GCObject*, %struct.GCObject** %172, align 8, !tbaa !21
  %174 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %175 = load %struct.GCObject*, %struct.GCObject** %174, align 8, !tbaa !21
  %176 = icmp eq %struct.GCObject* %173, %175
  %177 = zext i1 %176 to i32
  br label %203

; <label>:178:                                    ; preds = %166, %130
  %179 = phi %struct.Table* [ %128, %130 ], [ %164, %166 ]
  %180 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %181 = load %struct.global_State*, %struct.global_State** %180, align 8, !tbaa !2
  %182 = getelementptr inbounds %struct.global_State, %struct.global_State* %181, i64 0, i32 40, i64 5
  %183 = load %struct.TString*, %struct.TString** %182, align 8, !tbaa !39
  %184 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %179, i32 5, %struct.TString* %183) #16
  %185 = icmp eq %struct.TValue* %184, null
  br i1 %185, label %203, label %186

; <label>:186:                                    ; preds = %116, %152, %178
  %187 = phi %struct.TValue* [ %184, %178 ], [ %121, %116 ], [ %157, %152 ]
  %188 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %189 = load %union.StackValue*, %union.StackValue** %188, align 8, !tbaa !20
  tail call fastcc void @luaT_callTMres(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %187, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2, %union.StackValue* %189) #16
  %190 = bitcast %union.StackValue** %188 to %struct.TValue**
  %191 = load %struct.TValue*, %struct.TValue** %190, align 8, !tbaa !20
  %192 = getelementptr inbounds %struct.TValue, %struct.TValue* %191, i64 0, i32 1
  %193 = load i8, i8* %192, align 8, !tbaa !21
  %194 = and i8 %193, 15
  %195 = icmp eq i8 %194, 0
  br i1 %195, label %203, label %196

; <label>:196:                                    ; preds = %186
  %197 = icmp eq i8 %193, 1
  br i1 %197, label %198, label %203

; <label>:198:                                    ; preds = %196
  %199 = bitcast %struct.TValue* %191 to i32*
  %200 = load i32, i32* %199, align 8, !tbaa !21
  %201 = icmp ne i32 %200, 0
  %202 = zext i1 %201 to i32
  br label %203

; <label>:203:                                    ; preds = %166, %161, %130, %125, %186, %198, %196, %178, %141, %135, %105, %99, %49, %13, %171, %93, %86, %79, %72, %65, %58, %51, %47
  %204 = phi i32 [ %48, %47 ], [ %177, %171 ], [ %98, %93 ], [ %92, %86 ], [ %85, %79 ], [ %78, %72 ], [ %71, %65 ], [ %64, %58 ], [ %57, %51 ], [ 0, %13 ], [ 1, %49 ], [ 1, %99 ], [ 0, %105 ], [ 1, %135 ], [ 0, %141 ], [ 0, %178 ], [ 0, %186 ], [ 1, %196 ], [ %202, %198 ], [ 0, %125 ], [ 0, %130 ], [ 0, %161 ], [ 0, %166 ]
  ret i32 %204
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_arith(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = or i32 %1, 1
  %4 = icmp eq i32 %3, 13
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  br i1 %4, label %7, label %17

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0
  %9 = bitcast %struct.TValue* %8 to i64*
  %10 = bitcast %union.StackValue* %6 to i64*
  %11 = load i64, i64* %9, align 8
  store i64 %11, i64* %10, align 8
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %5, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %2, %7
  %18 = phi %union.StackValue* [ %16, %7 ], [ %6, %2 ]
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -2
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 0, i32 0
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -1, i32 0
  %22 = tail call fastcc i32 @luaO_rawarith(%struct.lua_State* nonnull %0, i32 %1, %struct.TValue* nonnull %20, %struct.TValue* nonnull %21, %struct.TValue* nonnull %20) #17
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %17
  %25 = add nsw i32 %1, 6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %20, %struct.TValue* nonnull %21, %union.StackValue* nonnull %19, i32 %25) #17
  br label %26

; <label>:26:                                     ; preds = %17, %24
  %27 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  store %union.StackValue* %28, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_compare(%struct.lua_State*, i32, i32, i32) local_unnamed_addr #0 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  %15 = icmp eq %struct.TValue* %5, %14
  br i1 %15, label %45, label %16

; <label>:16:                                     ; preds = %11, %4
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 8
  %25 = icmp eq %struct.TValue* %6, %24
  br i1 %25, label %45, label %26

; <label>:26:                                     ; preds = %21, %16
  switch i32 %3, label %45 [
    i32 0, label %27
    i32 1, label %29
    i32 2, label %37
  ]

; <label>:27:                                     ; preds = %26
  %28 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %6) #16
  br label %45

; <label>:29:                                     ; preds = %26
  %30 = icmp eq i8 %9, 3
  %31 = icmp eq i8 %19, 3
  %32 = and i1 %30, %31
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %29
  %34 = tail call fastcc i32 @LTnum(%struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:35:                                     ; preds = %29
  %36 = tail call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:37:                                     ; preds = %26
  %38 = icmp eq i8 %9, 3
  %39 = icmp eq i8 %19, 3
  %40 = and i1 %38, %39
  br i1 %40, label %41, label %43

; <label>:41:                                     ; preds = %37
  %42 = tail call fastcc i32 @LEnum(%struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:43:                                     ; preds = %37
  %44 = tail call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:45:                                     ; preds = %43, %41, %35, %33, %11, %21, %27, %26
  %46 = phi i32 [ 0, %26 ], [ %28, %27 ], [ 0, %21 ], [ 0, %11 ], [ %34, %33 ], [ %36, %35 ], [ %42, %41 ], [ %44, %43 ]
  ret i32 %46
}

; Function Attrs: minsize nounwind optsize uwtable
define i64 @lua_stringtonumber(%struct.lua_State* nocapture, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc i64 @luaO_str2num(i8* %1, %struct.TValue* %5) #16
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %2
  %9 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %3, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %2, %8
  ret i64 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @luaO_str2num(i8*, %struct.TValue* nocapture) unnamed_addr #0 {
  %3 = alloca [201 x i8], align 16
  %4 = alloca double, align 8
  %5 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  br label %6

; <label>:6:                                      ; preds = %6, %2
  %7 = phi i8* [ %0, %2 ], [ %15, %6 ]
  %8 = load i8, i8* %7, align 1, !tbaa !21
  %9 = zext i8 %8 to i64
  %10 = add nuw nsw i64 %9, 1
  %11 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %10
  %12 = load i8, i8* %11, align 1, !tbaa !21
  %13 = and i8 %12, 8
  %14 = icmp eq i8 %13, 0
  %15 = getelementptr inbounds i8, i8* %7, i64 1
  br i1 %14, label %16, label %6

; <label>:16:                                     ; preds = %6
  switch i8 %8, label %19 [
    i8 45, label %17
    i8 43, label %18
  ]

; <label>:17:                                     ; preds = %16
  br label %19

; <label>:18:                                     ; preds = %16
  br label %19

; <label>:19:                                     ; preds = %18, %17, %16
  %20 = phi i8* [ %7, %16 ], [ %15, %18 ], [ %15, %17 ]
  %21 = phi i32 [ 0, %16 ], [ 0, %18 ], [ 1, %17 ]
  %22 = load i8, i8* %20, align 1, !tbaa !21
  %23 = icmp eq i8 %22, 48
  br i1 %23, label %24, label %47

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds i8, i8* %20, i64 1
  %26 = load i8, i8* %25, align 1, !tbaa !21
  switch i8 %26, label %47 [
    i8 120, label %27
    i8 88, label %27
  ]

; <label>:27:                                     ; preds = %24, %24
  %28 = getelementptr inbounds i8, i8* %20, i64 2
  br label %29

; <label>:29:                                     ; preds = %40, %27
  %30 = phi i8* [ %28, %27 ], [ %46, %40 ]
  %31 = phi i32 [ 1, %27 ], [ 0, %40 ]
  %32 = phi i64 [ 0, %27 ], [ %45, %40 ]
  %33 = load i8, i8* %30, align 1, !tbaa !21
  %34 = zext i8 %33 to i64
  %35 = add nuw nsw i64 %34, 1
  %36 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %35
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = and i8 %37, 16
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %71, label %40

; <label>:40:                                     ; preds = %29
  %41 = shl i64 %32, 4
  %42 = sext i8 %33 to i32
  %43 = tail call fastcc i32 @luaO_hexavalue(i32 %42) #17
  %44 = sext i32 %43 to i64
  %45 = add i64 %41, %44
  %46 = getelementptr inbounds i8, i8* %30, i64 1
  br label %29

; <label>:47:                                     ; preds = %24, %19
  %48 = add nuw nsw i32 %21, 7
  br label %49

; <label>:49:                                     ; preds = %65, %47
  %50 = phi i8 [ %22, %47 ], [ %70, %65 ]
  %51 = phi i8* [ %20, %47 ], [ %69, %65 ]
  %52 = phi i32 [ 1, %47 ], [ 0, %65 ]
  %53 = phi i64 [ 0, %47 ], [ %68, %65 ]
  %54 = zext i8 %50 to i64
  %55 = add nsw i64 %54, -48
  %56 = icmp ult i64 %55, 10
  br i1 %56, label %57, label %71

; <label>:57:                                     ; preds = %49
  %58 = sext i8 %50 to i32
  %59 = add nsw i32 %58, -48
  %60 = icmp ugt i64 %53, 922337203685477579
  br i1 %60, label %61, label %65

; <label>:61:                                     ; preds = %57
  %62 = icmp ne i64 %53, 922337203685477580
  %63 = icmp sgt i32 %59, %48
  %64 = or i1 %63, %62
  br i1 %64, label %98, label %65

; <label>:65:                                     ; preds = %61, %57
  %66 = mul i64 %53, 10
  %67 = sext i32 %59 to i64
  %68 = add i64 %66, %67
  %69 = getelementptr inbounds i8, i8* %51, i64 1
  %70 = load i8, i8* %69, align 1, !tbaa !21
  br label %49

; <label>:71:                                     ; preds = %29, %49
  %72 = phi i8 [ %50, %49 ], [ %33, %29 ]
  %73 = phi i8* [ %51, %49 ], [ %30, %29 ]
  %74 = phi i32 [ %52, %49 ], [ %31, %29 ]
  %75 = phi i64 [ %53, %49 ], [ %32, %29 ]
  br label %76

; <label>:76:                                     ; preds = %86, %71
  %77 = phi i8 [ %72, %71 ], [ %87, %86 ]
  %78 = phi i8* [ %73, %71 ], [ %85, %86 ]
  %79 = zext i8 %77 to i64
  %80 = add nuw nsw i64 %79, 1
  %81 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %80
  %82 = load i8, i8* %81, align 1, !tbaa !21
  %83 = and i8 %82, 8
  %84 = icmp eq i8 %83, 0
  %85 = getelementptr inbounds i8, i8* %78, i64 1
  br i1 %84, label %88, label %86

; <label>:86:                                     ; preds = %76
  %87 = load i8, i8* %85, align 1, !tbaa !21
  br label %76

; <label>:88:                                     ; preds = %76
  %89 = icmp ne i32 %74, 0
  %90 = icmp ne i8 %77, 0
  %91 = or i1 %90, %89
  %92 = icmp eq i8* %78, null
  %93 = or i1 %91, %92
  br i1 %93, label %98, label %94

; <label>:94:                                     ; preds = %88
  %95 = icmp eq i32 %21, 0
  %96 = sub i64 0, %75
  %97 = select i1 %95, i64 %75, i64 %96
  br label %138

; <label>:98:                                     ; preds = %61, %88
  %99 = tail call i8* @strpbrk(i8* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.188, i64 0, i64 0)) #21
  %100 = icmp eq i8* %99, null
  br i1 %100, label %105, label %101

; <label>:101:                                    ; preds = %98
  %102 = load i8, i8* %99, align 1, !tbaa !21
  %103 = or i8 %102, 32
  %104 = icmp eq i8 %103, 110
  br i1 %104, label %148, label %105

; <label>:105:                                    ; preds = %101, %98
  %106 = call fastcc i8* @l_str2dloc(i8* %0, double* nonnull %4) #17
  %107 = icmp eq i8* %106, null
  br i1 %107, label %108, label %134

; <label>:108:                                    ; preds = %105
  %109 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 201, i8* nonnull %109) #7
  %110 = tail call i8* @strchr(i8* %0, i32 46) #21
  %111 = tail call i64 @strlen(i8* %0) #21
  %112 = icmp ugt i64 %111, 200
  %113 = icmp eq i8* %110, null
  %114 = or i1 %113, %112
  br i1 %114, label %133, label %115

; <label>:115:                                    ; preds = %108
  %116 = call i8* @strcpy(i8* nonnull %109, i8* %0) #17
  %117 = call %struct.lconv* @localeconv() #17
  %118 = getelementptr inbounds %struct.lconv, %struct.lconv* %117, i64 0, i32 0
  %119 = load i8*, i8** %118, align 8, !tbaa !133
  %120 = load i8, i8* %119, align 1, !tbaa !21
  %121 = ptrtoint i8* %110 to i64
  %122 = ptrtoint i8* %0 to i64
  %123 = sub i64 %121, %122
  %124 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 %123
  store i8 %120, i8* %124, align 1, !tbaa !21
  %125 = call fastcc i8* @l_str2dloc(i8* nonnull %109, double* nonnull %4) #17
  %126 = icmp eq i8* %125, null
  %127 = ptrtoint i8* %125 to i64
  %128 = ptrtoint [201 x i8]* %3 to i64
  %129 = sub i64 %127, %128
  %130 = getelementptr inbounds i8, i8* %0, i64 %129
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %109) #7
  %131 = icmp eq i8* %130, null
  %132 = or i1 %126, %131
  br i1 %132, label %148, label %134

; <label>:133:                                    ; preds = %108
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %109) #7
  br label %148

; <label>:134:                                    ; preds = %115, %105
  %135 = phi i8* [ %106, %105 ], [ %130, %115 ]
  %136 = bitcast double* %4 to i64*
  %137 = load i64, i64* %136, align 8, !tbaa !127
  br label %138

; <label>:138:                                    ; preds = %134, %94
  %139 = phi i64 [ %137, %134 ], [ %97, %94 ]
  %140 = phi i8 [ 19, %134 ], [ 35, %94 ]
  %141 = phi i8* [ %135, %134 ], [ %78, %94 ]
  %142 = bitcast %struct.TValue* %1 to i64*
  store i64 %139, i64* %142, align 8, !tbaa !21
  %143 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 %140, i8* %143, align 8, !tbaa !22
  %144 = ptrtoint i8* %141 to i64
  %145 = ptrtoint i8* %0 to i64
  %146 = sub i64 1, %145
  %147 = add i64 %146, %144
  br label %148

; <label>:148:                                    ; preds = %115, %101, %133, %138
  %149 = phi i64 [ %147, %138 ], [ 0, %133 ], [ 0, %101 ], [ 0, %115 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %149
}

; Function Attrs: minsize nounwind optsize uwtable
define double @lua_tonumberx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca double, align 8
  %5 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 19
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = bitcast double* %4 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !127
  br label %18

; <label>:14:                                     ; preds = %3
  %15 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %6, double* nonnull %4) #16
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  store double 0.000000e+00, double* %4, align 8, !tbaa !127
  br label %18

; <label>:18:                                     ; preds = %10, %14, %17
  %19 = phi i32 [ 1, %10 ], [ %15, %14 ], [ 0, %17 ]
  %20 = icmp eq i32* %2, null
  br i1 %20, label %22, label %21

; <label>:21:                                     ; preds = %18
  store i32 %19, i32* %2, align 4, !tbaa !74
  br label %22

; <label>:22:                                     ; preds = %18, %21
  %23 = load double, double* %4, align 8, !tbaa !127
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret double %23
}

; Function Attrs: minsize nounwind optsize uwtable
define i64 @lua_tointegerx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 35
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %4, align 8, !tbaa !129
  br label %17

; <label>:13:                                     ; preds = %3
  %14 = call fastcc i32 @luaV_tointeger(%struct.TValue* %6, i64* nonnull %4, i32 0) #16
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %13
  store i64 0, i64* %4, align 8, !tbaa !129
  br label %17

; <label>:17:                                     ; preds = %10, %13, %16
  %18 = phi i32 [ 1, %10 ], [ %14, %13 ], [ 0, %16 ]
  %19 = icmp eq i32* %2, null
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %17
  store i32 %18, i32* %2, align 4, !tbaa !74
  br label %21

; <label>:21:                                     ; preds = %17, %20
  %22 = load i64, i64* %4, align 8, !tbaa !129
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %22
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaV_tointeger(%struct.TValue* nocapture readonly, i64* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 4
  br i1 %9, label %10, label %32

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %0 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds i8, i8* %12, i64 24
  %14 = call fastcc i64 @luaO_str2num(i8* nonnull %13, %struct.TValue* nonnull %4) #16
  %15 = bitcast %struct.TValue* %0 to %struct.TString**
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !21
  %19 = icmp eq i8 %18, 20
  br i1 %19, label %20, label %24

; <label>:20:                                     ; preds = %10
  %21 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 4
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  br label %27

; <label>:24:                                     ; preds = %10
  %25 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 6, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !21
  br label %27

; <label>:27:                                     ; preds = %24, %20
  %28 = phi i64 [ %23, %20 ], [ %26, %24 ]
  %29 = add i64 %28, 1
  %30 = icmp eq i64 %14, %29
  %31 = select i1 %30, %struct.TValue* %4, %struct.TValue* %0
  br label %32

; <label>:32:                                     ; preds = %27, %3
  %33 = phi %struct.TValue* [ %0, %3 ], [ %31, %27 ]
  %34 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %33, i64* %1, i32 %2) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %34
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_toboolean(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %15, label %8

; <label>:8:                                      ; preds = %2
  %9 = icmp eq i8 %5, 1
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %8
  %11 = bitcast %struct.TValue* %3 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = icmp ne i32 %12, 0
  %14 = zext i1 %13 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %10, %2
  %16 = phi i32 [ 0, %2 ], [ 1, %8 ], [ %14, %10 ]
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i4
  switch i4 %7, label %8 [
    i4 4, label %20
    i4 3, label %11
  ]

; <label>:8:                                      ; preds = %3
  %9 = icmp eq i64* %2, null
  br i1 %9, label %42, label %10

; <label>:10:                                     ; preds = %8
  store i64 0, i64* %2, align 8, !tbaa !135
  br label %42

; <label>:11:                                     ; preds = %3
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* %4) #16
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 3
  %15 = load i64, i64* %14, align 8, !tbaa !11
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %11
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %18

; <label>:18:                                     ; preds = %17, %11
  %19 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %1) #16
  br label %20

; <label>:20:                                     ; preds = %3, %18
  %21 = phi %struct.TValue* [ %4, %3 ], [ %19, %18 ]
  %22 = icmp eq i64* %2, null
  br i1 %22, label %38, label %23

; <label>:23:                                     ; preds = %20
  %24 = bitcast %struct.TValue* %21 to %struct.TString**
  %25 = load %struct.TString*, %struct.TString** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !21
  %28 = icmp eq i8 %27, 20
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 4
  %31 = load i8, i8* %30, align 1, !tbaa !21
  %32 = zext i8 %31 to i64
  br label %36

; <label>:33:                                     ; preds = %23
  %34 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 6, i32 0
  %35 = load i64, i64* %34, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %33, %29
  %37 = phi i64 [ %32, %29 ], [ %35, %33 ]
  store i64 %37, i64* %2, align 8, !tbaa !135
  br label %38

; <label>:38:                                     ; preds = %20, %36
  %39 = bitcast %struct.TValue* %21 to i8**
  %40 = load i8*, i8** %39, align 8, !tbaa !21
  %41 = getelementptr inbounds i8, i8* %40, i64 24
  br label %42

; <label>:42:                                     ; preds = %10, %8, %38
  %43 = phi i8* [ %41, %38 ], [ null, %8 ], [ null, %10 ]
  ret i8* %43
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaO_tostring(%struct.lua_State*, %struct.TValue* nocapture) unnamed_addr #0 {
  %3 = alloca [50 x i8], align 16
  %4 = getelementptr inbounds [50 x i8], [50 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %4) #7
  %5 = call fastcc i64 @tostringbuff(%struct.TValue* %1, i8* nonnull %4) #16
  %6 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %4, i64 %5) #16
  %7 = bitcast %struct.TValue* %1 to %struct.TString**
  store %struct.TString* %6, %struct.TString** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %6, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !72
  %10 = or i8 %9, 64
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %4) #7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i64 @lua_rawlen(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %27 [
    i6 20, label %7
    i6 -28, label %13
    i6 7, label %18
    i6 5, label %23
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.TString**
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = zext i8 %11 to i64
  br label %27

; <label>:13:                                     ; preds = %2
  %14 = bitcast %struct.TValue* %3 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 0, i32 6, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !21
  br label %27

; <label>:18:                                     ; preds = %2
  %19 = bitcast %struct.TValue* %3 to %struct.Udata**
  %20 = load %struct.Udata*, %struct.Udata** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.Udata, %struct.Udata* %20, i64 0, i32 4
  %22 = load i64, i64* %21, align 8, !tbaa !21
  br label %27

; <label>:23:                                     ; preds = %2
  %24 = bitcast %struct.TValue* %3 to %struct.Table**
  %25 = load %struct.Table*, %struct.Table** %24, align 8, !tbaa !21
  %26 = tail call fastcc i64 @luaH_getn(%struct.Table* %25) #16
  br label %27

; <label>:27:                                     ; preds = %2, %23, %18, %13, %7
  %28 = phi i64 [ %26, %23 ], [ %22, %18 ], [ %17, %13 ], [ %12, %7 ], [ 0, %2 ]
  ret i64 %28
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i64 @luaH_getn(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %3 = load i32, i32* %2, align 4, !tbaa !136
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %54, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !137
  %8 = add i32 %3, -1
  %9 = zext i32 %8 to i64
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %9, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = and i8 %11, 15
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %54

; <label>:14:                                     ; preds = %5
  %15 = icmp ugt i32 %3, 1
  br i1 %15, label %16, label %38

; <label>:16:                                     ; preds = %14
  %17 = add i32 %3, -2
  %18 = zext i32 %17 to i64
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %18, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %38, label %23

; <label>:23:                                     ; preds = %16
  %24 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !138
  %26 = icmp slt i8 %25, 0
  br i1 %26, label %33, label %27

; <label>:27:                                     ; preds = %23
  %28 = and i32 %8, %3
  %29 = icmp ne i32 %28, 0
  %30 = and i32 %8, %17
  %31 = icmp eq i32 %30, 0
  %32 = or i1 %29, %31
  br i1 %32, label %134, label %36

; <label>:33:                                     ; preds = %23
  %34 = and i32 %8, %17
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %134, label %36

; <label>:36:                                     ; preds = %27, %33
  store i32 %8, i32* %2, align 4, !tbaa !136
  %37 = or i8 %25, -128
  store i8 %37, i8* %24, align 1, !tbaa !138
  br label %134

; <label>:38:                                     ; preds = %16, %14
  %39 = tail call fastcc i32 @binsearch(%struct.TValue* %7, i32 0, i32 %3) #16
  %40 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %41 = load i8, i8* %40, align 1, !tbaa !138
  %42 = icmp slt i8 %41, 0
  %43 = and i32 %8, %3
  %44 = icmp eq i32 %43, 0
  %45 = or i1 %44, %42
  br i1 %45, label %46, label %52

; <label>:46:                                     ; preds = %38
  %47 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %48 = lshr i32 %47, 1
  %49 = icmp ugt i32 %39, %48
  br i1 %49, label %50, label %52

; <label>:50:                                     ; preds = %46
  store i32 %39, i32* %2, align 4, !tbaa !136
  %51 = or i8 %41, -128
  store i8 %51, i8* %40, align 1, !tbaa !138
  br label %52

; <label>:52:                                     ; preds = %38, %50, %46
  %53 = zext i32 %39 to i64
  br label %134

; <label>:54:                                     ; preds = %1, %5
  %55 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %56 = load i8, i8* %55, align 1, !tbaa !138
  %57 = icmp slt i8 %56, 0
  br i1 %57, label %58, label %81

; <label>:58:                                     ; preds = %54
  %59 = add i32 %3, -1
  %60 = and i32 %59, %3
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %81, label %62

; <label>:62:                                     ; preds = %58
  %63 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %64 = load %struct.TValue*, %struct.TValue** %63, align 8, !tbaa !137
  %65 = zext i32 %3 to i64
  %66 = getelementptr inbounds %struct.TValue, %struct.TValue* %64, i64 %65, i32 1
  %67 = load i8, i8* %66, align 8, !tbaa !22
  %68 = and i8 %67, 15
  %69 = icmp eq i8 %68, 0
  br i1 %69, label %134, label %70

; <label>:70:                                     ; preds = %62
  %71 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %72 = add i32 %71, -1
  %73 = zext i32 %72 to i64
  %74 = getelementptr inbounds %struct.TValue, %struct.TValue* %64, i64 %73, i32 1
  %75 = load i8, i8* %74, align 8, !tbaa !22
  %76 = and i8 %75, 15
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %78, label %81

; <label>:78:                                     ; preds = %70
  %79 = tail call fastcc i32 @binsearch(%struct.TValue* nonnull %64, i32 %3, i32 %71) #16
  store i32 %79, i32* %2, align 4, !tbaa !136
  %80 = zext i32 %79 to i64
  br label %134

; <label>:81:                                     ; preds = %70, %58, %54
  %82 = phi i32 [ %3, %58 ], [ %71, %70 ], [ %3, %54 ]
  %83 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 8
  %84 = load %union.Node*, %union.Node** %83, align 8, !tbaa !139
  %85 = icmp eq %union.Node* %84, null
  br i1 %85, label %94, label %86

; <label>:86:                                     ; preds = %81
  %87 = add i32 %82, 1
  %88 = zext i32 %87 to i64
  %89 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* nonnull %0, i64 %88) #16
  %90 = getelementptr inbounds %struct.TValue, %struct.TValue* %89, i64 0, i32 1
  %91 = load i8, i8* %90, align 8, !tbaa !22
  %92 = and i8 %91, 15
  %93 = icmp eq i8 %92, 0
  br i1 %93, label %94, label %96

; <label>:94:                                     ; preds = %86, %81
  %95 = zext i32 %82 to i64
  br label %134

; <label>:96:                                     ; preds = %86
  %97 = zext i32 %82 to i64
  %98 = icmp eq i32 %82, 0
  %99 = zext i1 %98 to i64
  %100 = add nuw nsw i64 %99, %97
  br label %101

; <label>:101:                                    ; preds = %104, %96
  %102 = phi i64 [ %100, %96 ], [ %105, %104 ]
  %103 = icmp ult i64 %102, 4611686018427387904
  br i1 %103, label %104, label %111

; <label>:104:                                    ; preds = %101
  %105 = shl i64 %102, 1
  %106 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %105) #17
  %107 = getelementptr inbounds %struct.TValue, %struct.TValue* %106, i64 0, i32 1
  %108 = load i8, i8* %107, align 8, !tbaa !22
  %109 = and i8 %108, 15
  %110 = icmp eq i8 %109, 0
  br i1 %110, label %117, label %101

; <label>:111:                                    ; preds = %101
  %112 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 9223372036854775807) #17
  %113 = getelementptr inbounds %struct.TValue, %struct.TValue* %112, i64 0, i32 1
  %114 = load i8, i8* %113, align 8, !tbaa !22
  %115 = and i8 %114, 15
  %116 = icmp eq i8 %115, 0
  br i1 %116, label %117, label %134

; <label>:117:                                    ; preds = %104, %111
  %118 = phi i64 [ 9223372036854775807, %111 ], [ %105, %104 ]
  br label %119

; <label>:119:                                    ; preds = %117, %124
  %120 = phi i64 [ %132, %124 ], [ %118, %117 ]
  %121 = phi i64 [ %133, %124 ], [ %102, %117 ]
  %122 = sub i64 %120, %121
  %123 = icmp ugt i64 %122, 1
  br i1 %123, label %124, label %134

; <label>:124:                                    ; preds = %119
  %125 = add i64 %121, %120
  %126 = lshr i64 %125, 1
  %127 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %126) #17
  %128 = getelementptr inbounds %struct.TValue, %struct.TValue* %127, i64 0, i32 1
  %129 = load i8, i8* %128, align 8, !tbaa !22
  %130 = and i8 %129, 15
  %131 = icmp eq i8 %130, 0
  %132 = select i1 %131, i64 %126, i64 %120
  %133 = select i1 %131, i64 %121, i64 %126
  br label %119

; <label>:134:                                    ; preds = %119, %111, %62, %33, %36, %27, %94, %78, %52
  %135 = phi i64 [ %53, %52 ], [ %95, %94 ], [ %80, %78 ], [ %9, %27 ], [ %9, %36 ], [ %9, %33 ], [ %65, %62 ], [ 9223372036854775807, %111 ], [ %121, %119 ]
  ret i64 %135
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 (%struct.lua_State*)* @lua_tocfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %15 [
    i8 38, label %6
    i8 118, label %8
  ]

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %3 to i32 (%struct.lua_State*)**
  br label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %3 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %12

; <label>:12:                                     ; preds = %6, %8
  %13 = phi i32 (%struct.lua_State*)** [ %11, %8 ], [ %7, %6 ]
  %14 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %2
  %16 = phi i32 (%struct.lua_State*)* [ null, %2 ], [ %14, %12 ]
  ret i32 (%struct.lua_State*)* %16
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i8* @lua_touserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = tail call fastcc i8* @touserdata(%struct.TValue* %3) #16
  ret i8* %4
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i8* @touserdata(%struct.TValue* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %3 = load i8, i8* %2, align 8, !tbaa !22
  %4 = trunc i8 %3 to i4
  switch i4 %4, label %20 [
    i4 7, label %5
    i4 2, label %17
  ]

; <label>:5:                                      ; preds = %1
  %6 = bitcast %struct.TValue* %0 to %struct.Udata**
  %7 = load %struct.Udata*, %struct.Udata** %6, align 8, !tbaa !21
  %8 = bitcast %struct.Udata* %7 to i8*
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %7, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = icmp eq i16 %10, 0
  %12 = zext i16 %10 to i64
  %13 = shl nuw nsw i64 %12, 4
  %14 = add nuw nsw i64 %13, 40
  %15 = select i1 %11, i64 32, i64 %14
  %16 = getelementptr inbounds i8, i8* %8, i64 %15
  br label %20

; <label>:17:                                     ; preds = %1
  %18 = bitcast %struct.TValue* %0 to i8**
  %19 = load i8*, i8** %18, align 8, !tbaa !21
  br label %20

; <label>:20:                                     ; preds = %1, %17, %5
  %21 = phi i8* [ %19, %17 ], [ %16, %5 ], [ null, %1 ]
  ret i8* %21
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define %struct.lua_State* @lua_tothread(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 72
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.lua_State**
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !21
  br label %10

; <label>:10:                                     ; preds = %2, %7
  %11 = phi %struct.lua_State* [ %9, %7 ], [ null, %2 ]
  ret %struct.lua_State* %11
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i8* @lua_topointer(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %12 [
    i6 -26, label %7
    i6 7, label %10
    i6 2, label %10
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !21
  br label %18

; <label>:10:                                     ; preds = %2, %2
  %11 = tail call fastcc i8* @touserdata(%struct.TValue* %3) #16
  br label %18

; <label>:12:                                     ; preds = %2
  %13 = and i8 %5, 64
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %18, label %15

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %3 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !21
  br label %18

; <label>:18:                                     ; preds = %12, %15, %10, %7
  %19 = phi i8* [ %17, %15 ], [ %11, %10 ], [ %9, %7 ], [ null, %12 ]
  ret i8* %19
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushnil(%struct.lua_State* nocapture) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 0, i8* %5, align 8, !tbaa !21
  %6 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %2, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushnumber(%struct.lua_State* nocapture, double) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to double*
  store double %1, double* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 19, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushinteger(%struct.lua_State* nocapture, i64) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i64*
  store i64 %1, i64* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define nonnull i8* @lua_pushlstring(%struct.lua_State*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %2) #16
  br label %9

; <label>:9:                                      ; preds = %7, %5
  %10 = phi %struct.TString* [ %6, %5 ], [ %8, %7 ]
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !72
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %11, align 8, !tbaa !20
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = icmp sgt i64 %24, 0
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %9
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %27

; <label>:27:                                     ; preds = %26, %9
  %28 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %29 = bitcast %struct.TString* %28 to i8*
  ret i8* %29
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @luaS_new(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = ptrtoint i8* %1 to i64
  %4 = trunc i64 %3 to i32
  %5 = urem i32 %4, 53
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = zext i32 %5 to i64
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 0
  br label %10

; <label>:10:                                     ; preds = %14, %2
  %11 = phi i64 [ %21, %14 ], [ 0, %2 ]
  %12 = icmp ult i64 %11, 2
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %10
  br label %22

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 %11
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !39
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = tail call i32 @strcmp(i8* %1, i8* nonnull %18) #21
  %20 = icmp eq i32 %19, 0
  %21 = add nuw nsw i64 %11, 1
  br i1 %20, label %35, label %10

; <label>:22:                                     ; preds = %13, %25
  %23 = phi i64 [ %26, %25 ], [ 1, %13 ]
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %32, label %25

; <label>:25:                                     ; preds = %22
  %26 = add nsw i64 %23, -1
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 %26
  %28 = bitcast %struct.TString** %27 to i64*
  %29 = load i64, i64* %28, align 8, !tbaa !39
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 %23
  %31 = bitcast %struct.TString** %30 to i64*
  store i64 %29, i64* %31, align 8, !tbaa !39
  br label %22

; <label>:32:                                     ; preds = %22
  %33 = tail call i64 @strlen(i8* %1) #21
  %34 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %33) #16
  store %struct.TString* %34, %struct.TString** %9, align 8, !tbaa !39
  br label %35

; <label>:35:                                     ; preds = %14, %32
  %36 = phi %struct.TString* [ %34, %32 ], [ %16, %14 ]
  ret %struct.TString* %36
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @luaS_newlstr(%struct.lua_State*, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 41
  br i1 %4, label %5, label %83

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 9
  %9 = load i32, i32* %8, align 8, !tbaa !75
  %10 = tail call fastcc i32 @luaS_hash(i8* %1, i64 %2, i32 %9) #17
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 0
  %12 = load %struct.TString**, %struct.TString*** %11, align 8, !tbaa !84
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 2
  %14 = load i32, i32* %13, align 4, !tbaa !85
  %15 = add nsw i32 %14, -1
  %16 = and i32 %15, %10
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds %struct.TString*, %struct.TString** %12, i64 %17
  br label %19

; <label>:19:                                     ; preds = %43, %5
  %20 = phi %struct.TString** [ %18, %5 ], [ %45, %43 ]
  %21 = load %struct.TString*, %struct.TString** %20, align 8, !tbaa !21
  %22 = icmp eq %struct.TString* %21, null
  br i1 %22, label %46, label %23

; <label>:23:                                     ; preds = %19
  %24 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 4
  %25 = load i8, i8* %24, align 1, !tbaa !109
  %26 = zext i8 %25 to i64
  %27 = icmp eq i64 %26, %2
  br i1 %27, label %28, label %43

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 1
  %30 = bitcast %struct.TString* %29 to i8*
  %31 = tail call i32 @memcmp(i8* %1, i8* nonnull %30, i64 %2) #21
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %43

; <label>:33:                                     ; preds = %28
  %34 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !140
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 10
  %37 = load i8, i8* %36, align 4, !tbaa !15
  %38 = xor i8 %37, 24
  %39 = and i8 %38, %35
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %90, label %41

; <label>:41:                                     ; preds = %33
  %42 = xor i8 %35, 24
  store i8 %42, i8* %34, align 1, !tbaa !140
  br label %90

; <label>:43:                                     ; preds = %28, %23
  %44 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 6
  %45 = bitcast %union.anon* %44 to %struct.TString**
  br label %19

; <label>:46:                                     ; preds = %19
  %47 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 1
  %48 = load i32, i32* %47, align 8, !tbaa !141
  %49 = icmp slt i32 %48, %14
  br i1 %49, label %71, label %50

; <label>:50:                                     ; preds = %46
  %51 = icmp eq i32 %48, 2147483647
  br i1 %51, label %52, label %58, !prof !47

; <label>:52:                                     ; preds = %50
  tail call fastcc void @luaC_fullgc(%struct.lua_State* %0, i32 1) #17
  %53 = load i32, i32* %47, align 8, !tbaa !141
  %54 = icmp eq i32 %53, 2147483647
  br i1 %54, label %57, label %55

; <label>:55:                                     ; preds = %52
  %56 = load i32, i32* %13, align 4, !tbaa !85
  br label %58

; <label>:57:                                     ; preds = %52
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #19
  unreachable

; <label>:58:                                     ; preds = %55, %50
  %59 = phi i32 [ %56, %55 ], [ %14, %50 ]
  %60 = icmp slt i32 %59, 1073741824
  br i1 %60, label %61, label %64

; <label>:61:                                     ; preds = %58
  %62 = shl nsw i32 %59, 1
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %62) #17
  %63 = load i32, i32* %13, align 4, !tbaa !85
  br label %64

; <label>:64:                                     ; preds = %61, %58
  %65 = phi i32 [ %63, %61 ], [ %59, %58 ]
  %66 = load %struct.TString**, %struct.TString*** %11, align 8, !tbaa !84
  %67 = add nsw i32 %65, -1
  %68 = and i32 %67, %10
  %69 = sext i32 %68 to i64
  %70 = getelementptr inbounds %struct.TString*, %struct.TString** %66, i64 %69
  br label %71

; <label>:71:                                     ; preds = %64, %46
  %72 = phi %struct.TString** [ %70, %64 ], [ %18, %46 ]
  %73 = tail call fastcc %struct.TString* @createstrobj(%struct.lua_State* %0, i64 %2, i32 20, i32 %10) #17
  %74 = getelementptr inbounds %struct.TString, %struct.TString* %73, i64 1
  %75 = bitcast %struct.TString* %74 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %75, i8* %1, i64 %2, i32 1, i1 false) #7
  %76 = trunc i64 %2 to i8
  %77 = getelementptr inbounds %struct.TString, %struct.TString* %73, i64 0, i32 4
  store i8 %76, i8* %77, align 1, !tbaa !109
  %78 = bitcast %struct.TString** %72 to i64*
  %79 = load i64, i64* %78, align 8, !tbaa !39
  %80 = getelementptr inbounds %struct.TString, %struct.TString* %73, i64 0, i32 6, i32 0
  store i64 %79, i64* %80, align 8, !tbaa !21
  store %struct.TString* %73, %struct.TString** %72, align 8, !tbaa !39
  %81 = load i32, i32* %47, align 8, !tbaa !141
  %82 = add nsw i32 %81, 1
  store i32 %82, i32* %47, align 8, !tbaa !141
  br label %90

; <label>:83:                                     ; preds = %3
  %84 = icmp ugt i64 %2, 9223372036854775782
  br i1 %84, label %85, label %86, !prof !47

; <label>:85:                                     ; preds = %83
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #18
  unreachable

; <label>:86:                                     ; preds = %83
  %87 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %0, i64 %2) #16
  %88 = getelementptr inbounds %struct.TString, %struct.TString* %87, i64 1
  %89 = bitcast %struct.TString* %88 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %89, i8* %1, i64 %2, i32 1, i1 false)
  br label %90

; <label>:90:                                     ; preds = %71, %41, %33, %86
  %91 = phi %struct.TString* [ %87, %86 ], [ %73, %71 ], [ %21, %33 ], [ %21, %41 ]
  ret %struct.TString* %91
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_pushstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  br label %21

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* nonnull %1) #16
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !72
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %20 = bitcast %struct.TString* %19 to i8*
  br label %21

; <label>:21:                                     ; preds = %9, %4
  %22 = phi %union.StackValue** [ %11, %9 ], [ %5, %4 ]
  %23 = phi i8* [ %20, %9 ], [ null, %4 ]
  %24 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %22, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %32

; <label>:31:                                     ; preds = %21
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %32

; <label>:32:                                     ; preds = %31, %21
  ret i8* %23
}

; Function Attrs: minsize nounwind optsize uwtable
define nonnull i8* @lua_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) local_unnamed_addr #0 {
  %4 = tail call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* %2) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = icmp sgt i64 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %3
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %11

; <label>:11:                                     ; preds = %10, %3
  ret i8* %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc nonnull i8* @luaO_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) unnamed_addr #0 {
  %4 = alloca %struct.BuffFS, align 8
  %5 = alloca i8, align 1
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = alloca [8 x i8], align 1
  %10 = bitcast %struct.BuffFS* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 416, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 2
  store i32 0, i32* %11, align 4, !tbaa !142
  %12 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 1
  store i32 0, i32* %12, align 8, !tbaa !144
  %13 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %13, align 8, !tbaa !145
  %14 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %15 = bitcast %struct.TValue* %6 to i8*
  %16 = bitcast %struct.TValue* %7 to i8*
  %17 = bitcast %struct.TValue* %8 to i8*
  %18 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 1
  %19 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 0
  %20 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %21 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %22 = bitcast %struct.TValue* %6 to i64*
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %24 = bitcast %struct.TValue* %7 to i64*
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %26 = bitcast %struct.TValue* %8 to i64*
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %28 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 8
  br label %29

; <label>:29:                                     ; preds = %161, %3
  %30 = phi i8* [ %1, %3 ], [ %162, %161 ]
  %31 = call i8* @strchr(i8* %30, i32 37) #21
  %32 = icmp eq i8* %31, null
  br i1 %32, label %163, label %33

; <label>:33:                                     ; preds = %29
  %34 = ptrtoint i8* %31 to i64
  %35 = ptrtoint i8* %30 to i64
  %36 = sub i64 %34, %35
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %30, i64 %36) #16
  %37 = getelementptr inbounds i8, i8* %31, i64 1
  %38 = load i8, i8* %37, align 1, !tbaa !21
  %39 = sext i8 %38 to i32
  switch i32 %39, label %159 [
    i32 115, label %40
    i32 99, label %58
    i32 100, label %74
    i32 73, label %90
    i32 102, label %105
    i32 112, label %120
    i32 85, label %139
    i32 37, label %158
  ]

; <label>:40:                                     ; preds = %33
  %41 = load i32, i32* %14, align 8
  %42 = icmp ult i32 %41, 41
  br i1 %42, label %43, label %48

; <label>:43:                                     ; preds = %40
  %44 = load i8*, i8** %20, align 8
  %45 = sext i32 %41 to i64
  %46 = getelementptr i8, i8* %44, i64 %45
  %47 = add i32 %41, 8
  store i32 %47, i32* %14, align 8
  br label %51

; <label>:48:                                     ; preds = %40
  %49 = load i8*, i8** %21, align 8
  %50 = getelementptr i8, i8* %49, i64 8
  store i8* %50, i8** %21, align 8
  br label %51

; <label>:51:                                     ; preds = %48, %43
  %52 = phi i8* [ %46, %43 ], [ %49, %48 ]
  %53 = bitcast i8* %52 to i8**
  %54 = load i8*, i8** %53, align 8
  %55 = icmp eq i8* %54, null
  %56 = select i1 %55, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.193, i64 0, i64 0), i8* %54
  %57 = call i64 @strlen(i8* %56) #21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %56, i64 %57) #16
  br label %161

; <label>:58:                                     ; preds = %33
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #7
  %59 = load i32, i32* %14, align 8
  %60 = icmp ult i32 %59, 41
  br i1 %60, label %61, label %66

; <label>:61:                                     ; preds = %58
  %62 = load i8*, i8** %20, align 8
  %63 = sext i32 %59 to i64
  %64 = getelementptr i8, i8* %62, i64 %63
  %65 = add i32 %59, 8
  store i32 %65, i32* %14, align 8
  br label %69

; <label>:66:                                     ; preds = %58
  %67 = load i8*, i8** %21, align 8
  %68 = getelementptr i8, i8* %67, i64 8
  store i8* %68, i8** %21, align 8
  br label %69

; <label>:69:                                     ; preds = %66, %61
  %70 = phi i8* [ %64, %61 ], [ %67, %66 ]
  %71 = bitcast i8* %70 to i32*
  %72 = load i32, i32* %71, align 4
  %73 = trunc i32 %72 to i8
  store i8 %73, i8* %5, align 1, !tbaa !21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %5, i64 1) #16
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #7
  br label %161

; <label>:74:                                     ; preds = %33
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %15) #7
  %75 = load i32, i32* %14, align 8
  %76 = icmp ult i32 %75, 41
  br i1 %76, label %77, label %82

; <label>:77:                                     ; preds = %74
  %78 = load i8*, i8** %20, align 8
  %79 = sext i32 %75 to i64
  %80 = getelementptr i8, i8* %78, i64 %79
  %81 = add i32 %75, 8
  store i32 %81, i32* %14, align 8
  br label %85

; <label>:82:                                     ; preds = %74
  %83 = load i8*, i8** %21, align 8
  %84 = getelementptr i8, i8* %83, i64 8
  store i8* %84, i8** %21, align 8
  br label %85

; <label>:85:                                     ; preds = %82, %77
  %86 = phi i8* [ %80, %77 ], [ %83, %82 ]
  %87 = bitcast i8* %86 to i32*
  %88 = load i32, i32* %87, align 4
  %89 = sext i32 %88 to i64
  store i64 %89, i64* %22, align 8, !tbaa !21
  store i8 35, i8* %23, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %6) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %15) #7
  br label %161

; <label>:90:                                     ; preds = %33
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #7
  %91 = load i32, i32* %14, align 8
  %92 = icmp ult i32 %91, 41
  br i1 %92, label %93, label %98

; <label>:93:                                     ; preds = %90
  %94 = load i8*, i8** %20, align 8
  %95 = sext i32 %91 to i64
  %96 = getelementptr i8, i8* %94, i64 %95
  %97 = add i32 %91, 8
  store i32 %97, i32* %14, align 8
  br label %101

; <label>:98:                                     ; preds = %90
  %99 = load i8*, i8** %21, align 8
  %100 = getelementptr i8, i8* %99, i64 8
  store i8* %100, i8** %21, align 8
  br label %101

; <label>:101:                                    ; preds = %98, %93
  %102 = phi i8* [ %96, %93 ], [ %99, %98 ]
  %103 = bitcast i8* %102 to i64*
  %104 = load i64, i64* %103, align 8
  store i64 %104, i64* %24, align 8, !tbaa !21
  store i8 35, i8* %25, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %7) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #7
  br label %161

; <label>:105:                                    ; preds = %33
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %17) #7
  %106 = load i32, i32* %18, align 4
  %107 = icmp ult i32 %106, 161
  br i1 %107, label %108, label %113

; <label>:108:                                    ; preds = %105
  %109 = load i8*, i8** %20, align 8
  %110 = sext i32 %106 to i64
  %111 = getelementptr i8, i8* %109, i64 %110
  %112 = add i32 %106, 16
  store i32 %112, i32* %18, align 4
  br label %116

; <label>:113:                                    ; preds = %105
  %114 = load i8*, i8** %21, align 8
  %115 = getelementptr i8, i8* %114, i64 8
  store i8* %115, i8** %21, align 8
  br label %116

; <label>:116:                                    ; preds = %113, %108
  %117 = phi i8* [ %111, %108 ], [ %114, %113 ]
  %118 = bitcast i8* %117 to i64*
  %119 = load i64, i64* %118, align 8
  store i64 %119, i64* %26, align 8, !tbaa !21
  store i8 19, i8* %27, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %8) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %17) #7
  br label %161

; <label>:120:                                    ; preds = %33
  %121 = call fastcc i8* @getbuff(%struct.BuffFS* nonnull %4, i64 32) #16
  %122 = load i32, i32* %14, align 8
  %123 = icmp ult i32 %122, 41
  br i1 %123, label %124, label %129

; <label>:124:                                    ; preds = %120
  %125 = load i8*, i8** %20, align 8
  %126 = sext i32 %122 to i64
  %127 = getelementptr i8, i8* %125, i64 %126
  %128 = add i32 %122, 8
  store i32 %128, i32* %14, align 8
  br label %132

; <label>:129:                                    ; preds = %120
  %130 = load i8*, i8** %21, align 8
  %131 = getelementptr i8, i8* %130, i64 8
  store i8* %131, i8** %21, align 8
  br label %132

; <label>:132:                                    ; preds = %129, %124
  %133 = phi i8* [ %127, %124 ], [ %130, %129 ]
  %134 = bitcast i8* %133 to i8**
  %135 = load i8*, i8** %134, align 8
  %136 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %121, i64 32, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.194, i64 0, i64 0), i8* %135) #17
  %137 = load i32, i32* %11, align 4, !tbaa !142
  %138 = add nsw i32 %137, %136
  store i32 %138, i32* %11, align 4, !tbaa !142
  br label %161

; <label>:139:                                    ; preds = %33
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %19) #7
  %140 = load i32, i32* %14, align 8
  %141 = icmp ult i32 %140, 41
  br i1 %141, label %142, label %147

; <label>:142:                                    ; preds = %139
  %143 = load i8*, i8** %20, align 8
  %144 = sext i32 %140 to i64
  %145 = getelementptr i8, i8* %143, i64 %144
  %146 = add i32 %140, 8
  store i32 %146, i32* %14, align 8
  br label %150

; <label>:147:                                    ; preds = %139
  %148 = load i8*, i8** %21, align 8
  %149 = getelementptr i8, i8* %148, i64 8
  store i8* %149, i8** %21, align 8
  br label %150

; <label>:150:                                    ; preds = %147, %142
  %151 = phi i8* [ %145, %142 ], [ %148, %147 ]
  %152 = bitcast i8* %151 to i64*
  %153 = load i64, i64* %152, align 8
  %154 = call fastcc i32 @luaO_utf8esc(i8* nonnull %19, i64 %153) #16
  %155 = sext i32 %154 to i64
  %156 = sub nsw i64 0, %155
  %157 = getelementptr inbounds i8, i8* %28, i64 %156
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %157, i64 %155) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %19) #7
  br label %161

; <label>:158:                                    ; preds = %33
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.195, i64 0, i64 0), i64 1) #16
  br label %161

; <label>:159:                                    ; preds = %33
  %160 = sext i8 %38 to i32
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.196, i64 0, i64 0), i32 %160) #18
  unreachable

; <label>:161:                                    ; preds = %158, %150, %132, %116, %101, %85, %69, %51
  %162 = getelementptr inbounds i8, i8* %31, i64 2
  br label %29

; <label>:163:                                    ; preds = %29
  %164 = call i64 @strlen(i8* %30) #21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %30, i64 %164) #16
  call fastcc void @clearbuff(%struct.BuffFS* nonnull %4) #16
  %165 = load i32, i32* %12, align 8, !tbaa !144
  %166 = icmp sgt i32 %165, 1
  br i1 %166, label %167, label %168

; <label>:167:                                    ; preds = %163
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %165) #16
  br label %168

; <label>:168:                                    ; preds = %167, %163
  %169 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %170 = load %union.StackValue*, %union.StackValue** %169, align 8, !tbaa !20
  %171 = getelementptr inbounds %union.StackValue, %union.StackValue* %170, i64 -1, i32 0, i32 0, i32 0
  %172 = bitcast %struct.GCObject** %171 to i8**
  %173 = load i8*, i8** %172, align 8, !tbaa !21
  %174 = getelementptr inbounds i8, i8* %173, i64 24
  call void @llvm.lifetime.end.p0i8(i64 416, i8* nonnull %10) #7
  ret i8* %174
}

; Function Attrs: minsize nounwind optsize uwtable
define nonnull i8* @lua_pushfstring(%struct.lua_State*, i8*, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %13

; <label>:13:                                     ; preds = %12, %2
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_pushcclosure(%struct.lua_State*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 38, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  br label %56

; <label>:13:                                     ; preds = %3
  %14 = shl i32 %2, 4
  %15 = add nsw i32 %14, 32
  %16 = sext i32 %15 to i64
  %17 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 54, i64 %16) #17
  %18 = bitcast %struct.GCObject* %17 to %struct.CClosure*
  %19 = trunc i32 %2 to i8
  %20 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %18, i64 0, i32 3
  store i8 %19, i8* %20, align 2, !tbaa !125
  %21 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %17, i64 1, i32 1
  %22 = bitcast i8* %21 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %22, align 8, !tbaa !146
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = sext i32 %2 to i64
  %26 = sub nsw i64 0, %25
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %26
  store %union.StackValue* %27, %union.StackValue** %23, align 8, !tbaa !20
  br label %28

; <label>:28:                                     ; preds = %33, %13
  %29 = phi i64 [ %30, %33 ], [ %25, %13 ]
  %30 = add nsw i64 %29, -1
  %31 = trunc i64 %29 to i32
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %43, label %33

; <label>:33:                                     ; preds = %28
  %34 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %18, i64 0, i32 6, i64 %30
  %35 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 %30, i32 0
  %37 = bitcast %struct.TValue* %36 to i64*
  %38 = bitcast %struct.TValue* %34 to i64*
  %39 = load i64, i64* %37, align 8
  store i64 %39, i64* %38, align 8
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 %30, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %18, i64 0, i32 6, i64 %30, i32 1
  store i8 %41, i8* %42, align 8, !tbaa !22
  br label %28

; <label>:43:                                     ; preds = %28
  %44 = bitcast %union.StackValue** %23 to %struct.TValue**
  %45 = load %struct.TValue*, %struct.TValue** %44, align 8, !tbaa !20
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 0, i32 0
  store %struct.GCObject* %17, %struct.GCObject** %46, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  store i8 118, i8* %47, align 8, !tbaa !22
  %48 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1
  store %union.StackValue* %49, %union.StackValue** %23, align 8, !tbaa !20
  %50 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %51 = load %struct.global_State*, %struct.global_State** %50, align 8, !tbaa !2
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %51, i64 0, i32 3
  %53 = load i64, i64* %52, align 8, !tbaa !11
  %54 = icmp sgt i64 %53, 0
  br i1 %54, label %55, label %56

; <label>:55:                                     ; preds = %43
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %56

; <label>:56:                                     ; preds = %43, %55, %5
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushboolean(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %1, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_pushlightuserdata(%struct.lua_State* nocapture, i8*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i8**
  store i8* %1, i8** %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 2, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_pushthread(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 72, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 38
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !27
  %13 = icmp eq %struct.lua_State* %12, %0
  %14 = zext i1 %13 to i32
  ret i32 %14
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_getglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2) #16
  %9 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1) #16
  ret i32 %9
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @auxgetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %27

; <label>:8:                                      ; preds = %3
  %9 = bitcast %struct.TValue* %1 to %struct.Table**
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %10, %struct.TString* %4) #16
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %27, label %16

; <label>:16:                                     ; preds = %8
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to %struct.TValue**
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %11 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = load i8, i8* %12, align 8, !tbaa !22
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %23, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %17, align 8, !tbaa !20
  br label %41

; <label>:27:                                     ; preds = %3, %8
  %28 = phi %struct.TValue* [ %11, %8 ], [ null, %3 ]
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %30 = bitcast %union.StackValue** %29 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !72
  %35 = or i8 %34, 64
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %29, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %39, %union.StackValue* %37, %struct.TValue* %28) #16
  %40 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  br label %41

; <label>:41:                                     ; preds = %27, %16
  %42 = phi %union.StackValue* [ %40, %27 ], [ %26, %16 ]
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -1, i32 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !21
  %45 = and i8 %44, 15
  %46 = zext i8 %45 to i32
  ret i32 %46
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_getint(%struct.Table* nocapture, i64) unnamed_addr #2 {
  %3 = add i64 %1, -1
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %5 = load i32, i32* %4, align 4, !tbaa !136
  %6 = zext i32 %5 to i64
  %7 = icmp ult i64 %3, %6
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !137
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 %3
  br label %62

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %14 = load i8, i8* %13, align 1, !tbaa !138
  %15 = icmp slt i8 %14, 0
  br i1 %15, label %16, label %33

; <label>:16:                                     ; preds = %12
  %17 = add i32 %5, -1
  %18 = and i32 %17, %5
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %33, label %20

; <label>:20:                                     ; preds = %16
  %21 = add i32 %5, 1
  %22 = zext i32 %21 to i64
  %23 = icmp eq i64 %22, %1
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %20
  %25 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %26 = zext i32 %25 to i64
  %27 = icmp ult i64 %3, %26
  br i1 %27, label %28, label %33

; <label>:28:                                     ; preds = %24, %20
  %29 = trunc i64 %1 to i32
  store i32 %29, i32* %4, align 4, !tbaa !136
  %30 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !137
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 %3
  br label %62

; <label>:33:                                     ; preds = %24, %16, %12
  %34 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %35 = load %union.Node*, %union.Node** %34, align 8, !tbaa !147
  %36 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %37 = load i8, i8* %36, align 1, !tbaa !148
  %38 = zext i8 %37 to i32
  %39 = shl i32 1, %38
  %40 = add nsw i32 %39, -1
  %41 = trunc i64 %1 to i32
  %42 = and i32 %40, %41
  br label %43

; <label>:43:                                     ; preds = %58, %33
  %44 = phi i32 [ %42, %33 ], [ %60, %58 ]
  %45 = phi %union.Node* [ %35, %33 ], [ %47, %58 ]
  %46 = sext i32 %44 to i64
  %47 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46
  %48 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !21
  %50 = icmp eq i8 %49, 35
  br i1 %50, label %51, label %58

; <label>:51:                                     ; preds = %43
  %52 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 4
  %53 = bitcast %union.Value* %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21
  %55 = icmp eq i64 %54, %1
  br i1 %55, label %56, label %58

; <label>:56:                                     ; preds = %51
  %57 = bitcast %union.Node* %47 to %struct.TValue*
  br label %62

; <label>:58:                                     ; preds = %51, %43
  %59 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 3
  %60 = load i32, i32* %59, align 4, !tbaa !21
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %62, label %43

; <label>:62:                                     ; preds = %58, %56, %28, %8
  %63 = phi %struct.TValue* [ %11, %8 ], [ %32, %28 ], [ %57, %56 ], [ @absentkey, %58 ]
  ret %struct.TValue* %63
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_gettable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %28

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %3 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  %15 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %11, %struct.TValue* nonnull %14) #16
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %9
  %21 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = bitcast %struct.TValue* %15 to i64*
  %24 = bitcast %struct.TValue* %22 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = load i8, i8* %16, align 8, !tbaa !22
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  store i8 %26, i8* %27, align 8, !tbaa !22
  br label %34

; <label>:28:                                     ; preds = %7, %9
  %29 = phi %union.StackValue** [ %8, %7 ], [ %12, %9 ]
  %30 = phi %struct.TValue* [ null, %7 ], [ %15, %9 ]
  %31 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -1
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %33, %union.StackValue* nonnull %32, %struct.TValue* %30) #16
  br label %34

; <label>:34:                                     ; preds = %28, %20
  %35 = phi %union.StackValue** [ %29, %28 ], [ %12, %20 ]
  %36 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !21
  %39 = and i8 %38, 15
  %40 = zext i8 %39 to i32
  ret i32 %40
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_get(%struct.Table* nocapture, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = trunc i8 %4 to i6
  switch i6 %5, label %26 [
    i6 20, label %6
    i6 -29, label %10
    i6 0, label %28
    i6 19, label %14
  ]

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %1 to %struct.TString**
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !21
  %9 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* %8) #16
  br label %28

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %12) #16
  br label %28

; <label>:14:                                     ; preds = %2
  %15 = bitcast %struct.TValue* %1 to double*
  %16 = load double, double* %15, align 8, !tbaa !21
  %17 = tail call double @llvm.floor.f64(double %16) #7
  %18 = fcmp une double %17, %16
  br i1 %18, label %26, label %19

; <label>:19:                                     ; preds = %14
  %20 = fcmp oge double %17, 0xC3E0000000000000
  %21 = fcmp olt double %17, 0x43E0000000000000
  %22 = and i1 %20, %21
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %19
  %24 = fptosi double %17 to i64
  %25 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %24) #16
  br label %28

; <label>:26:                                     ; preds = %19, %14, %2
  %27 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %1) #16
  br label %28

; <label>:28:                                     ; preds = %23, %2, %26, %10, %6
  %29 = phi %struct.TValue* [ %27, %26 ], [ %25, %23 ], [ %13, %10 ], [ %9, %6 ], [ @absentkey, %2 ]
  ret %struct.TValue* %29
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaV_finishget(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, %struct.TValue* readnone) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %66, %5
  %8 = phi i32 [ 0, %5 ], [ %68, %66 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %67, %66 ]
  %10 = phi %struct.TValue* [ %1, %5 ], [ %45, %66 ]
  %11 = icmp ult i32 %8, 2000
  br i1 %11, label %12, label %69

; <label>:12:                                     ; preds = %7
  %13 = icmp eq %struct.TValue* %9, null
  br i1 %13, label %14, label %21

; <label>:14:                                     ; preds = %12
  %15 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %10, i32 0) #16
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %43, !prof !47

; <label>:20:                                     ; preds = %14
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #18
  unreachable

; <label>:21:                                     ; preds = %12
  %22 = bitcast %struct.TValue* %10 to %struct.Table**
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.Table, %struct.Table* %23, i64 0, i32 9
  %25 = load %struct.Table*, %struct.Table** %24, align 8, !tbaa !21
  %26 = icmp eq %struct.Table* %25, null
  br i1 %26, label %41, label %27

; <label>:27:                                     ; preds = %21
  %28 = getelementptr inbounds %struct.Table, %struct.Table* %25, i64 0, i32 3
  %29 = load i8, i8* %28, align 2, !tbaa !131
  %30 = and i8 %29, 1
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %41

; <label>:32:                                     ; preds = %27
  %33 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 40, i64 0
  %35 = load %struct.TString*, %struct.TString** %34, align 8, !tbaa !39
  %36 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %25, i32 0, %struct.TString* %35) #16
  %37 = icmp eq %struct.TValue* %36, null
  br i1 %37, label %41, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  %40 = load i8, i8* %39, align 8, !tbaa !22
  br label %43

; <label>:41:                                     ; preds = %27, %21, %32
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 0, i8* %42, align 8, !tbaa !21
  br label %70

; <label>:43:                                     ; preds = %38, %14
  %44 = phi i8 [ %17, %14 ], [ %40, %38 ]
  %45 = phi %struct.TValue* [ %15, %14 ], [ %36, %38 ]
  %46 = and i8 %44, 15
  %47 = icmp eq i8 %46, 6
  br i1 %47, label %48, label %49

; <label>:48:                                     ; preds = %43
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %45, %struct.TValue* %10, %struct.TValue* %2, %union.StackValue* %3) #16
  br label %70

; <label>:49:                                     ; preds = %43
  %50 = icmp eq i8 %44, 69
  br i1 %50, label %51, label %66

; <label>:51:                                     ; preds = %49
  %52 = bitcast %struct.TValue* %45 to %struct.Table**
  %53 = load %struct.Table*, %struct.Table** %52, align 8, !tbaa !21
  %54 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %53, %struct.TValue* %2) #16
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !22
  %57 = and i8 %56, 15
  %58 = icmp eq i8 %57, 0
  br i1 %58, label %66, label %59

; <label>:59:                                     ; preds = %51
  %60 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 0, i32 1
  %61 = bitcast %struct.TValue* %54 to i64*
  %62 = bitcast %union.StackValue* %3 to i64*
  %63 = load i64, i64* %61, align 8
  store i64 %63, i64* %62, align 8
  %64 = load i8, i8* %60, align 8, !tbaa !22
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 %64, i8* %65, align 8, !tbaa !22
  br label %70

; <label>:66:                                     ; preds = %49, %51
  %67 = phi %struct.TValue* [ %54, %51 ], [ null, %49 ]
  %68 = add nuw nsw i32 %8, 1
  br label %7

; <label>:69:                                     ; preds = %7
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.198, i64 0, i64 0)) #18
  unreachable

; <label>:70:                                     ; preds = %59, %48, %41
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_getfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2) #16
  ret i32 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_geti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %38

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = bitcast %struct.TValue* %5 to %struct.Table**
  %12 = load %struct.Table*, %struct.Table** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 5
  %14 = load i32, i32* %13, align 4, !tbaa !21
  %15 = zext i32 %14 to i64
  %16 = icmp ult i64 %10, %15
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 6
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %10
  br label %23

; <label>:21:                                     ; preds = %9
  %22 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %12, i64 %2) #16
  br label %23

; <label>:23:                                     ; preds = %21, %17
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %38, label %29

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = bitcast %union.StackValue** %30 to %struct.TValue**
  %32 = load %struct.TValue*, %struct.TValue** %31, align 8, !tbaa !20
  %33 = bitcast %struct.TValue* %24 to i64*
  %34 = bitcast %struct.TValue* %32 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = load i8, i8* %25, align 8, !tbaa !22
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  store i8 %36, i8* %37, align 8, !tbaa !22
  br label %45

; <label>:38:                                     ; preds = %3, %23
  %39 = phi %struct.TValue* [ %24, %23 ], [ null, %3 ]
  %40 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %40) #7
  %41 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %44 = load %union.StackValue*, %union.StackValue** %43, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %union.StackValue* %44, %struct.TValue* %39) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %40) #7
  br label %45

; <label>:45:                                     ; preds = %38, %29
  %46 = phi %union.StackValue** [ %43, %38 ], [ %30, %29 ]
  %47 = load %union.StackValue*, %union.StackValue** %46, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 1
  store %union.StackValue* %48, %union.StackValue** %46, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 0, i32 0, i32 1
  %50 = load i8, i8* %49, align 8, !tbaa !21
  %51 = and i8 %50, 15
  %52 = zext i8 %51 to i32
  ret i32 %52
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_rawget(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0
  %7 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %3, %struct.TValue* nonnull %6) #16
  %8 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1
  store %union.StackValue* %9, %union.StackValue** %4, align 8, !tbaa !20
  %10 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %7) #16
  ret i32 %10
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.Table* @gettable(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = bitcast %struct.TValue* %3 to %struct.Table**
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !21
  ret %struct.Table* %5
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @finishrawget(%struct.lua_State* nocapture, %struct.TValue* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = and i8 %4, 15
  %6 = icmp eq i8 %5, 0
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  br i1 %6, label %15, label %10

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = bitcast %struct.TValue* %9 to i64*
  %13 = load i64, i64* %11, align 8
  store i64 %13, i64* %12, align 8
  %14 = load i8, i8* %3, align 8, !tbaa !22
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi i8 [ %14, %10 ], [ 0, %2 ]
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 %16, i8* %17, align 8
  %18 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %7, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 0, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 15
  %23 = zext i8 %22 to i32
  ret i32 %23
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_rawgeti(%struct.lua_State* nocapture, i32, i64) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %4, i64 %2) #16
  %6 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %5) #16
  ret i32 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_rawgetp(%struct.lua_State* nocapture, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %6, %struct.TValue* nonnull %4) #16
  %10 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %9) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_createtable(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to %struct.Table**
  store %struct.Table* %4, %struct.Table** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 69, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  %12 = icmp sgt i32 %1, 0
  %13 = icmp sgt i32 %2, 0
  %14 = or i1 %12, %13
  br i1 %14, label %15, label %16

; <label>:15:                                     ; preds = %3
  tail call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %4, i32 %1, i32 %2) #16
  br label %16

; <label>:16:                                     ; preds = %3, %15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 3
  %20 = load i64, i64* %19, align 8, !tbaa !11
  %21 = icmp sgt i64 %20, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %16
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %23

; <label>:23:                                     ; preds = %22, %16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.Table* @luaH_new(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 5, i64 56) #16
  %3 = bitcast %struct.GCObject* %2 to %struct.Table*
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2, i32 1
  %5 = bitcast i8* %4 to %struct.Table**
  store %struct.Table* null, %struct.Table** %5, align 8, !tbaa !149
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 3
  store i8 -1, i8* %6, align 2, !tbaa !131
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1
  %8 = bitcast %struct.GCObject* %7 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %8, align 8, !tbaa !137
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 5
  store i32 0, i32* %9, align 4, !tbaa !136
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1, i32 1
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 4
  store i8 0, i8* %11, align 1, !tbaa !148
  %12 = bitcast i8* %10 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %12, align 8, !tbaa !39
  ret %struct.Table* %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaH_resize(%struct.lua_State*, %struct.Table*, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.Table, align 8
  %7 = bitcast %struct.Table* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %7) #7
  %8 = tail call fastcc i32 @setlimittosize(%struct.Table* %1) #16
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %12 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 0, i8* %12, align 1, !tbaa !148
  %13 = bitcast %union.Node** %11 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %13, align 8, !tbaa !39
  br label %55

; <label>:14:                                     ; preds = %4
  %15 = add i32 %3, -1
  br label %16

; <label>:16:                                     ; preds = %20, %14
  %17 = phi i32 [ %15, %14 ], [ %22, %20 ]
  %18 = phi i32 [ 0, %14 ], [ %21, %20 ]
  %19 = icmp ugt i32 %17, 255
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %16
  %21 = add nuw nsw i32 %18, 8
  %22 = lshr i32 %17, 8
  br label %16

; <label>:23:                                     ; preds = %16
  %24 = zext i32 %17 to i64
  %25 = getelementptr inbounds [256 x i8], [256 x i8]* @luaO_ceillog2.log_2, i64 0, i64 %24
  %26 = load i8, i8* %25, align 1, !tbaa !21
  %27 = zext i8 %26 to i32
  %28 = add nuw nsw i32 %18, %27
  %29 = icmp ugt i32 %28, 30
  br i1 %29, label %40, label %30

; <label>:30:                                     ; preds = %23
  %31 = shl i32 1, %28
  %32 = zext i32 %31 to i64
  %33 = mul nuw nsw i64 %32, 24
  %34 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %33, i32 0) #17
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %36 = bitcast %union.Node** %35 to i8**
  store i8* %34, i8** %36, align 8, !tbaa !147
  %37 = bitcast i8* %34 to %union.Node*
  %38 = sext i32 %31 to i64
  %39 = ptrtoint i8* %34 to i64
  br label %41

; <label>:40:                                     ; preds = %23
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.199, i64 0, i64 0)) #19
  unreachable

; <label>:41:                                     ; preds = %44, %30
  %42 = phi i64 [ %48, %44 ], [ 0, %30 ]
  %43 = icmp slt i64 %42, %38
  br i1 %43, label %44, label %49

; <label>:44:                                     ; preds = %41
  %45 = getelementptr inbounds %union.Node, %union.Node* %37, i64 %42, i32 0, i32 3
  store i32 0, i32* %45, align 4, !tbaa !21
  %46 = getelementptr inbounds %union.Node, %union.Node* %37, i64 %42, i32 0, i32 2
  store i8 0, i8* %46, align 1, !tbaa !21
  %47 = getelementptr inbounds %union.Node, %union.Node* %37, i64 %42, i32 0, i32 1
  store i8 16, i8* %47, align 8, !tbaa !21
  %48 = add nuw nsw i64 %42, 1
  br label %41

; <label>:49:                                     ; preds = %41
  %50 = trunc i32 %28 to i8
  %51 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %50, i8* %51, align 1, !tbaa !148
  %52 = getelementptr inbounds %union.Node, %union.Node* %37, i64 %32
  %53 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 8
  store %union.Node* %52, %union.Node** %53, align 8, !tbaa !139
  %54 = ptrtoint %union.Node* %52 to i64
  br label %55

; <label>:55:                                     ; preds = %10, %49
  %56 = phi i64 [ 0, %10 ], [ %54, %49 ]
  %57 = phi i64 [ ptrtoint (%union.Node* @dummynode_ to i64), %10 ], [ %39, %49 ]
  %58 = phi i8 [ 0, %10 ], [ %50, %49 ]
  %59 = icmp ugt i32 %8, %2
  br i1 %59, label %64, label %60

; <label>:60:                                     ; preds = %55
  %61 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %62 = zext i32 %8 to i64
  %63 = zext i32 %2 to i64
  br label %101

; <label>:64:                                     ; preds = %55
  %65 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %2, i32* %65, align 4, !tbaa !136
  %66 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %67 = load i8, i8* %66, align 1, !tbaa !148
  %68 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %69 = bitcast %union.Node** %68 to i64*
  %70 = load i64, i64* %69, align 8, !tbaa !147
  %71 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %72 = bitcast %union.Node** %71 to i64*
  %73 = load i64, i64* %72, align 8, !tbaa !139
  %74 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %58, i8* %66, align 1, !tbaa !148
  %75 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %76 = bitcast %union.Node** %75 to i64*
  store i64 %57, i64* %69, align 8, !tbaa !147
  %77 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 8
  %78 = bitcast %union.Node** %77 to i64*
  store i64 %56, i64* %72, align 8, !tbaa !139
  store i8 %67, i8* %74, align 1, !tbaa !148
  store i64 %70, i64* %76, align 8, !tbaa !147
  store i64 %73, i64* %78, align 8, !tbaa !139
  %79 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %80 = zext i32 %2 to i64
  %81 = zext i32 %8 to i64
  br label %82

; <label>:82:                                     ; preds = %95, %64
  %83 = phi i64 [ %96, %95 ], [ %80, %64 ]
  %84 = icmp ult i64 %83, %81
  br i1 %84, label %85, label %97

; <label>:85:                                     ; preds = %82
  %86 = load %struct.TValue*, %struct.TValue** %79, align 8, !tbaa !137
  %87 = getelementptr inbounds %struct.TValue, %struct.TValue* %86, i64 %83, i32 1
  %88 = load i8, i8* %87, align 8, !tbaa !22
  %89 = and i8 %88, 15
  %90 = icmp eq i8 %89, 0
  br i1 %90, label %95, label %91

; <label>:91:                                     ; preds = %85
  %92 = getelementptr inbounds %struct.TValue, %struct.TValue* %86, i64 %83
  %93 = add nuw i64 %83, 1
  %94 = and i64 %93, 4294967295
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* nonnull %1, i64 %94, %struct.TValue* %92) #16
  br label %95

; <label>:95:                                     ; preds = %85, %91
  %96 = add nuw nsw i64 %83, 1
  br label %82

; <label>:97:                                     ; preds = %82
  store i32 %8, i32* %65, align 4, !tbaa !136
  %98 = load i8, i8* %66, align 1, !tbaa !148
  %99 = load i64, i64* %69, align 8, !tbaa !147
  %100 = load i64, i64* %72, align 8, !tbaa !139
  store i8 %67, i8* %66, align 1, !tbaa !148
  store i64 %70, i64* %69, align 8, !tbaa !147
  store i64 %73, i64* %72, align 8, !tbaa !139
  store i8 %98, i8* %74, align 1, !tbaa !148
  store i64 %99, i64* %76, align 8, !tbaa !147
  store i64 %100, i64* %78, align 8, !tbaa !139
  br label %101

; <label>:101:                                    ; preds = %60, %97
  %102 = phi i64 [ %63, %60 ], [ %80, %97 ]
  %103 = phi i64 [ %62, %60 ], [ %81, %97 ]
  %104 = phi %struct.TValue** [ %61, %60 ], [ %79, %97 ]
  %105 = phi i64 [ %56, %60 ], [ %100, %97 ]
  %106 = phi i64 [ %57, %60 ], [ %99, %97 ]
  %107 = phi i8 [ %58, %60 ], [ %98, %97 ]
  %108 = bitcast %struct.TValue** %104 to i8**
  %109 = load i8*, i8** %108, align 8, !tbaa !137
  %110 = shl nuw nsw i64 %103, 4
  %111 = shl nuw nsw i64 %102, 4
  %112 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %109, i64 %110, i64 %111) #16
  %113 = icmp eq i8* %112, null
  %114 = icmp ne i32 %2, 0
  %115 = and i1 %114, %113
  br i1 %115, label %116, label %117, !prof !47

; <label>:116:                                    ; preds = %101
  call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* nonnull %6) #16
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:117:                                    ; preds = %101
  %118 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %119 = load i8, i8* %118, align 1, !tbaa !148
  %120 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %121 = bitcast %union.Node** %120 to i64*
  %122 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %123 = bitcast %union.Node** %122 to i64*
  %124 = bitcast %union.Node** %120 to <2 x i64>*
  %125 = load <2 x i64>, <2 x i64>* %124, align 8, !tbaa !39
  %126 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %107, i8* %118, align 1, !tbaa !148
  %127 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  store i64 %106, i64* %121, align 8, !tbaa !147
  store i64 %105, i64* %123, align 8, !tbaa !139
  store i8 %119, i8* %126, align 1, !tbaa !148
  %128 = bitcast %union.Node** %127 to <2 x i64>*
  store <2 x i64> %125, <2 x i64>* %128, align 8, !tbaa !39
  store i8* %112, i8** %108, align 8, !tbaa !137
  %129 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %2, i32* %129, align 4, !tbaa !136
  %130 = extractelement <2 x i64> %125, i32 0
  %131 = inttoptr i64 %130 to %union.Node*
  %132 = bitcast i8* %112 to %struct.TValue*
  br label %133

; <label>:133:                                    ; preds = %136, %117
  %134 = phi i32 [ %8, %117 ], [ %139, %136 ]
  %135 = icmp ult i32 %134, %2
  br i1 %135, label %136, label %140

; <label>:136:                                    ; preds = %133
  %137 = zext i32 %134 to i64
  %138 = getelementptr inbounds %struct.TValue, %struct.TValue* %132, i64 %137, i32 1
  store i8 16, i8* %138, align 8, !tbaa !22
  %139 = add i32 %134, 1
  br label %133

; <label>:140:                                    ; preds = %133
  %141 = zext i8 %119 to i32
  %142 = shl i32 1, %141
  %143 = bitcast %struct.TValue* %5 to i8*
  %144 = bitcast %struct.TValue* %5 to i64*
  %145 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %146 = sext i32 %142 to i64
  br label %147

; <label>:147:                                    ; preds = %168, %140
  %148 = phi i64 [ %169, %168 ], [ 0, %140 ]
  %149 = icmp slt i64 %148, %146
  br i1 %149, label %150, label %170

; <label>:150:                                    ; preds = %147
  %151 = getelementptr inbounds %union.Node, %union.Node* %131, i64 %148, i32 0, i32 1
  %152 = load i8, i8* %151, align 8, !tbaa !21
  %153 = and i8 %152, 15
  %154 = icmp eq i8 %153, 0
  br i1 %154, label %168, label %155

; <label>:155:                                    ; preds = %150
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %143) #7
  %156 = getelementptr inbounds %union.Node, %union.Node* %131, i64 %148, i32 0, i32 4
  %157 = bitcast %union.Value* %156 to i64*
  %158 = load i64, i64* %157, align 8
  store i64 %158, i64* %144, align 8
  %159 = getelementptr inbounds %union.Node, %union.Node* %131, i64 %148, i32 0, i32 2
  %160 = load i8, i8* %159, align 1, !tbaa !21
  store i8 %160, i8* %145, align 8, !tbaa !22
  %161 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %5) #17
  %162 = getelementptr inbounds %union.Node, %union.Node* %131, i64 %148, i32 0, i32 0
  %163 = bitcast %union.Value* %162 to i64*
  %164 = bitcast %struct.TValue* %161 to i64*
  %165 = load i64, i64* %163, align 8
  store i64 %165, i64* %164, align 8
  %166 = load i8, i8* %151, align 8, !tbaa !22
  %167 = getelementptr inbounds %struct.TValue, %struct.TValue* %161, i64 0, i32 1
  store i8 %166, i8* %167, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %143) #7
  br label %168

; <label>:168:                                    ; preds = %155, %150
  %169 = add nuw nsw i64 %148, 1
  br label %147

; <label>:170:                                    ; preds = %147
  call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* nonnull %6) #16
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_getmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %3 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %2
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  br i1 %24, label %33, label %25

; <label>:25:                                     ; preds = %21
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %28 to %struct.Table**
  store %struct.Table* %23, %struct.Table** %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 69, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %26, align 8, !tbaa !20
  br label %33

; <label>:33:                                     ; preds = %21, %25
  %34 = phi i32 [ 1, %25 ], [ 0, %21 ]
  ret i32 %34
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_getiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = icmp slt i32 %2, 1
  br i1 %4, label %13, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %6 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp slt i32 %11, %2
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %5, %3
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 0, i8* %17, align 8, !tbaa !21
  %18 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  br label %38

; <label>:19:                                     ; preds = %5
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = bitcast %union.StackValue** %20 to %struct.TValue**
  %22 = load %struct.TValue*, %struct.TValue** %21, align 8, !tbaa !20
  %23 = add nsw i32 %2, -1
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %24, i32 0
  %26 = bitcast %struct.TValue* %25 to i64*
  %27 = bitcast %struct.TValue* %22 to i64*
  %28 = load i64, i64* %26, align 8
  store i64 %28, i64* %27, align 8
  %29 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %24, i32 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %22, i64 0, i32 1
  store i8 %30, i8* %31, align 8, !tbaa !22
  %32 = load %struct.TValue*, %struct.TValue** %21, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !21
  %35 = and i8 %34, 15
  %36 = zext i8 %35 to i32
  %37 = bitcast %struct.TValue* %32 to %union.StackValue*
  br label %38

; <label>:38:                                     ; preds = %19, %13
  %39 = phi %union.StackValue** [ %20, %19 ], [ %14, %13 ]
  %40 = phi %union.StackValue* [ %37, %19 ], [ %18, %13 ]
  %41 = phi i32 [ %36, %19 ], [ -1, %13 ]
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %42, %union.StackValue** %39, align 8, !tbaa !20
  ret i32 %41
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_setglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2) #16
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @auxsetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %49

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %10 = bitcast %struct.TValue* %1 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %11, %struct.TString* %4) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %49, label %17

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %12 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  store i8 %25, i8* %13, align 8, !tbaa !22
  %26 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !21
  %29 = and i8 %28, 64
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %46, label %31

; <label>:31:                                     ; preds = %17
  %32 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !67
  %35 = and i8 %34, 32
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %46, label %37

; <label>:37:                                     ; preds = %31
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 0, i32 0
  %39 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %39, i64 0, i32 2
  %41 = load i8, i8* %40, align 1, !tbaa !67
  %42 = and i8 %41, 24
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %46, label %44

; <label>:44:                                     ; preds = %37
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %32) #16
  %45 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  br label %46

; <label>:46:                                     ; preds = %37, %31, %17, %44
  %47 = phi %union.StackValue* [ %26, %37 ], [ %26, %31 ], [ %26, %17 ], [ %45, %44 ]
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  br label %65

; <label>:49:                                     ; preds = %3, %8
  %50 = phi %struct.TValue* [ %12, %8 ], [ null, %3 ]
  %51 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %52 = bitcast %union.StackValue** %51 to %struct.TValue**
  %53 = load %struct.TValue*, %struct.TValue** %52, align 8, !tbaa !20
  %54 = bitcast %struct.TValue* %53 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %54, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !72
  %57 = or i8 %56, 64
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  store i8 %57, i8* %58, align 8, !tbaa !22
  %59 = load %union.StackValue*, %union.StackValue** %51, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 1
  store %union.StackValue* %60, %union.StackValue** %51, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 0, i32 0
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %61, %struct.TValue* nonnull %62, %struct.TValue* %50) #16
  %63 = load %union.StackValue*, %union.StackValue** %51, align 8, !tbaa !20
  %64 = getelementptr inbounds %union.StackValue, %union.StackValue* %63, i64 -2
  br label %65

; <label>:65:                                     ; preds = %49, %46
  %66 = phi %union.StackValue** [ %51, %49 ], [ %18, %46 ]
  %67 = phi %union.StackValue* [ %64, %49 ], [ %48, %46 ]
  store %union.StackValue* %67, %union.StackValue** %66, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_settable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %48

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %11 = bitcast %struct.TValue* %3 to %struct.Table**
  %12 = load %struct.Table*, %struct.Table** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -2, i32 0
  %16 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %12, %struct.TValue* nonnull %15) #16
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %48, label %21

; <label>:21:                                     ; preds = %9
  %22 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1, i32 0
  %24 = bitcast %struct.TValue* %23 to i64*
  %25 = bitcast %struct.TValue* %16 to i64*
  %26 = load i64, i64* %24, align 8
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  store i8 %28, i8* %17, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !21
  %32 = and i8 %31, 64
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %54, label %34

; <label>:34:                                     ; preds = %21
  %35 = load %struct.GCObject*, %struct.GCObject** %10, align 8, !tbaa !21
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %35, i64 0, i32 2
  %37 = load i8, i8* %36, align 1, !tbaa !67
  %38 = and i8 %37, 32
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %54, label %40

; <label>:40:                                     ; preds = %34
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 0, i32 0
  %42 = load %struct.GCObject*, %struct.GCObject** %41, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %42, i64 0, i32 2
  %44 = load i8, i8* %43, align 1, !tbaa !67
  %45 = and i8 %44, 24
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %54, label %47

; <label>:47:                                     ; preds = %40
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %35) #16
  br label %54

; <label>:48:                                     ; preds = %7, %9
  %49 = phi %union.StackValue** [ %8, %7 ], [ %13, %9 ]
  %50 = phi %struct.TValue* [ null, %7 ], [ %16, %9 ]
  %51 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !20
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 -2, i32 0
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %52, %struct.TValue* nonnull %53, %struct.TValue* %50) #16
  br label %54

; <label>:54:                                     ; preds = %40, %34, %21, %47, %48
  %55 = phi %union.StackValue** [ %13, %40 ], [ %13, %34 ], [ %13, %21 ], [ %13, %47 ], [ %49, %48 ]
  %56 = load %union.StackValue*, %union.StackValue** %55, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 -2
  store %union.StackValue* %57, %union.StackValue** %55, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @luaC_barrierback_(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %4 = load i8, i8* %3, align 1, !tbaa !67
  %5 = and i8 %4, 7
  %6 = icmp eq i8 %5, 6
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %9, i64 0, i32 24
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !150
  %13 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %1) #16
  %14 = bitcast %struct.GCObject** %13 to i64*
  store i64 %12, i64* %14, align 8, !tbaa !39
  store %struct.GCObject* %1, %struct.GCObject** %10, align 8, !tbaa !150
  br label %15

; <label>:15:                                     ; preds = %2, %7
  %16 = and i8 %4, -40
  %17 = or i8 %16, 5
  store i8 %17, i8* %3, align 1, !tbaa !67
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaV_finishset(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %154, %5
  %8 = phi i32 [ 0, %5 ], [ %156, %154 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %155, %154 ]
  %10 = phi %struct.TValue* [ %1, %5 ], [ %78, %154 ]
  %11 = icmp ult i32 %8, 2000
  br i1 %11, label %12, label %157

; <label>:12:                                     ; preds = %7
  %13 = icmp eq %struct.TValue* %9, null
  br i1 %13, label %68, label %14

; <label>:14:                                     ; preds = %12
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 0, i32 0
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %16, i64 2, i32 1
  %18 = bitcast i8* %17 to %struct.Table**
  %19 = load %struct.Table*, %struct.Table** %18, align 8, !tbaa !149
  %20 = icmp eq %struct.Table* %19, null
  br i1 %20, label %35, label %21

; <label>:21:                                     ; preds = %14
  %22 = getelementptr inbounds %struct.Table, %struct.Table* %19, i64 0, i32 3
  %23 = load i8, i8* %22, align 2, !tbaa !131
  %24 = and i8 %23, 2
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %26, label %35

; <label>:26:                                     ; preds = %21
  %27 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 40, i64 1
  %29 = load %struct.TString*, %struct.TString** %28, align 8, !tbaa !39
  %30 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %19, i32 1, %struct.TString* %29) #16
  %31 = icmp eq %struct.TValue* %30, null
  br i1 %31, label %35, label %32

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  br label %75

; <label>:35:                                     ; preds = %21, %14, %26
  %36 = bitcast %struct.GCObject* %16 to %struct.Table*
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 32
  br i1 %39, label %40, label %43

; <label>:40:                                     ; preds = %35
  %41 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %36, %struct.TValue* %2) #16
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %41, i64 0, i32 1
  br label %43

; <label>:43:                                     ; preds = %40, %35
  %44 = phi i8* [ %42, %40 ], [ %37, %35 ]
  %45 = phi %struct.TValue* [ %41, %40 ], [ %9, %35 ]
  %46 = bitcast %struct.TValue* %3 to i64*
  %47 = bitcast %struct.TValue* %45 to i64*
  %48 = load i64, i64* %46, align 8
  store i64 %48, i64* %47, align 8
  %49 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %50 = load i8, i8* %49, align 8, !tbaa !22
  store i8 %50, i8* %44, align 8, !tbaa !22
  %51 = getelementptr inbounds %struct.Table, %struct.Table* %36, i64 0, i32 3
  store i8 0, i8* %51, align 2, !tbaa !131
  %52 = load i8, i8* %49, align 8, !tbaa !22
  %53 = and i8 %52, 64
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %158, label %55

; <label>:55:                                     ; preds = %43
  %56 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %16, i64 0, i32 2
  %57 = load i8, i8* %56, align 1, !tbaa !21
  %58 = and i8 %57, 32
  %59 = icmp eq i8 %58, 0
  br i1 %59, label %158, label %60

; <label>:60:                                     ; preds = %55
  %61 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %62 = load %struct.GCObject*, %struct.GCObject** %61, align 8, !tbaa !21
  %63 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %62, i64 0, i32 2
  %64 = load i8, i8* %63, align 1, !tbaa !67
  %65 = and i8 %64, 24
  %66 = icmp eq i8 %65, 0
  br i1 %66, label %158, label %67

; <label>:67:                                     ; preds = %60
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %16) #16
  br label %158

; <label>:68:                                     ; preds = %12
  %69 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %10, i32 1) #16
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %69, i64 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  %72 = and i8 %71, 15
  %73 = icmp eq i8 %72, 0
  br i1 %73, label %74, label %75, !prof !47

; <label>:74:                                     ; preds = %68
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #18
  unreachable

; <label>:75:                                     ; preds = %32, %68
  %76 = phi i8* [ %33, %32 ], [ %70, %68 ]
  %77 = phi i8 [ %34, %32 ], [ %71, %68 ]
  %78 = phi %struct.TValue* [ %30, %32 ], [ %69, %68 ]
  %79 = and i8 %77, 15
  %80 = icmp eq i8 %79, 6
  br i1 %80, label %81, label %119

; <label>:81:                                     ; preds = %75
  %82 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %83 = load %union.StackValue*, %union.StackValue** %82, align 8, !tbaa !20
  %84 = bitcast %struct.TValue* %78 to i64*
  %85 = bitcast %union.StackValue* %83 to i64*
  %86 = load i64, i64* %84, align 8
  store i64 %86, i64* %85, align 8
  %87 = load i8, i8* %76, align 8, !tbaa !22
  %88 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 0, i32 0, i32 1
  store i8 %87, i8* %88, align 8, !tbaa !22
  %89 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 1, i32 0
  %90 = bitcast %struct.TValue* %10 to i64*
  %91 = bitcast %struct.TValue* %89 to i64*
  %92 = load i64, i64* %90, align 8
  store i64 %92, i64* %91, align 8
  %93 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  %94 = load i8, i8* %93, align 8, !tbaa !22
  %95 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 1, i32 0, i32 1
  store i8 %94, i8* %95, align 8, !tbaa !22
  %96 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 2, i32 0
  %97 = bitcast %struct.TValue* %2 to i64*
  %98 = bitcast %struct.TValue* %96 to i64*
  %99 = load i64, i64* %97, align 8
  store i64 %99, i64* %98, align 8
  %100 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %101 = load i8, i8* %100, align 8, !tbaa !22
  %102 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 2, i32 0, i32 1
  store i8 %101, i8* %102, align 8, !tbaa !22
  %103 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 3, i32 0
  %104 = bitcast %struct.TValue* %3 to i64*
  %105 = bitcast %struct.TValue* %103 to i64*
  %106 = load i64, i64* %104, align 8
  store i64 %106, i64* %105, align 8
  %107 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %108 = load i8, i8* %107, align 8, !tbaa !22
  %109 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 3, i32 0, i32 1
  store i8 %108, i8* %109, align 8, !tbaa !22
  %110 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 4
  store %union.StackValue* %110, %union.StackValue** %82, align 8, !tbaa !20
  %111 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %112 = load %struct.CallInfo*, %struct.CallInfo** %111, align 8, !tbaa !49
  %113 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %112, i64 0, i32 7
  %114 = load i16, i16* %113, align 2, !tbaa !60
  %115 = and i16 %114, 6
  %116 = icmp eq i16 %115, 0
  br i1 %116, label %117, label %118

; <label>:117:                                    ; preds = %81
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %83, i32 0) #17
  br label %158

; <label>:118:                                    ; preds = %81
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %83, i32 0) #17
  br label %158

; <label>:119:                                    ; preds = %75
  %120 = icmp eq i8 %77, 69
  br i1 %120, label %121, label %154

; <label>:121:                                    ; preds = %119
  %122 = bitcast %struct.TValue* %78 to %struct.Table**
  %123 = load %struct.Table*, %struct.Table** %122, align 8, !tbaa !21
  %124 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %123, %struct.TValue* %2) #16
  %125 = getelementptr inbounds %struct.TValue, %struct.TValue* %124, i64 0, i32 1
  %126 = load i8, i8* %125, align 8, !tbaa !22
  %127 = and i8 %126, 15
  %128 = icmp eq i8 %127, 0
  br i1 %128, label %154, label %129

; <label>:129:                                    ; preds = %121
  %130 = getelementptr inbounds %struct.TValue, %struct.TValue* %124, i64 0, i32 1
  %131 = bitcast %struct.TValue* %3 to i64*
  %132 = bitcast %struct.TValue* %124 to i64*
  %133 = load i64, i64* %131, align 8
  store i64 %133, i64* %132, align 8
  %134 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %135 = load i8, i8* %134, align 8, !tbaa !22
  store i8 %135, i8* %130, align 8, !tbaa !22
  %136 = load i8, i8* %134, align 8, !tbaa !22
  %137 = and i8 %136, 64
  %138 = icmp eq i8 %137, 0
  br i1 %138, label %158, label %139

; <label>:139:                                    ; preds = %129
  %140 = getelementptr inbounds %struct.TValue, %struct.TValue* %78, i64 0, i32 0, i32 0
  %141 = load %struct.GCObject*, %struct.GCObject** %140, align 8, !tbaa !21
  %142 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %141, i64 0, i32 2
  %143 = load i8, i8* %142, align 1, !tbaa !67
  %144 = and i8 %143, 32
  %145 = icmp eq i8 %144, 0
  br i1 %145, label %158, label %146

; <label>:146:                                    ; preds = %139
  %147 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %148 = load %struct.GCObject*, %struct.GCObject** %147, align 8, !tbaa !21
  %149 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %148, i64 0, i32 2
  %150 = load i8, i8* %149, align 1, !tbaa !67
  %151 = and i8 %150, 24
  %152 = icmp eq i8 %151, 0
  br i1 %152, label %158, label %153

; <label>:153:                                    ; preds = %146
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %141) #16
  br label %158

; <label>:154:                                    ; preds = %119, %121
  %155 = phi %struct.TValue* [ %124, %121 ], [ null, %119 ]
  %156 = add nuw nsw i32 %8, 1
  br label %7

; <label>:157:                                    ; preds = %7
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.200, i64 0, i64 0)) #18
  unreachable

; <label>:158:                                    ; preds = %67, %43, %55, %60, %146, %139, %129, %153, %117, %118
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_setfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_seti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %58

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 0, i32 0
  %12 = bitcast %struct.TValue* %5 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !21
  %16 = zext i32 %15 to i64
  %17 = icmp ult i64 %10, %16
  br i1 %17, label %18, label %22

; <label>:18:                                     ; preds = %9
  %19 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 6
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 %10
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %13, i64 %2) #16
  br label %24

; <label>:24:                                     ; preds = %22, %18
  %25 = phi %struct.TValue* [ %21, %18 ], [ %23, %22 ]
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = and i8 %27, 15
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %58, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0
  %34 = bitcast %struct.TValue* %33 to i64*
  %35 = bitcast %struct.TValue* %25 to i64*
  %36 = load i64, i64* %34, align 8
  store i64 %36, i64* %35, align 8
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  store i8 %38, i8* %26, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !21
  %42 = and i8 %41, 64
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %66, label %44

; <label>:44:                                     ; preds = %30
  %45 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %45, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !67
  %48 = and i8 %47, 32
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %66, label %50

; <label>:50:                                     ; preds = %44
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 0, i32 0
  %52 = load %struct.GCObject*, %struct.GCObject** %51, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %52, i64 0, i32 2
  %54 = load i8, i8* %53, align 1, !tbaa !67
  %55 = and i8 %54, 24
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %66, label %57

; <label>:57:                                     ; preds = %50
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %45) #16
  br label %66

; <label>:58:                                     ; preds = %3, %24
  %59 = phi %struct.TValue* [ %25, %24 ], [ null, %3 ]
  %60 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %60) #7
  %61 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %61, align 8, !tbaa !21
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %62, align 8, !tbaa !22
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %64 = load %union.StackValue*, %union.StackValue** %63, align 8, !tbaa !20
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 -1, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %struct.TValue* nonnull %65, %struct.TValue* %59) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %60) #7
  br label %66

; <label>:66:                                     ; preds = %50, %44, %30, %57, %58
  %67 = phi %union.StackValue** [ %31, %50 ], [ %31, %44 ], [ %31, %30 ], [ %31, %57 ], [ %63, %58 ]
  %68 = load %union.StackValue*, %union.StackValue** %67, align 8, !tbaa !20
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1
  store %union.StackValue* %69, %union.StackValue** %67, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_rawset(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -2, i32 0
  %7 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %3, %struct.TValue* nonnull %6) #16
  %8 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %10 = bitcast %struct.TValue* %9 to i64*
  %11 = bitcast %struct.TValue* %7 to i64*
  %12 = load i64, i64* %10, align 8
  store i64 %12, i64* %11, align 8
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 %14, i8* %15, align 8, !tbaa !22
  %16 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 3
  store i8 0, i8* %16, align 2, !tbaa !131
  %17 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !21
  %20 = and i8 %19, 64
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %37, label %22

; <label>:22:                                     ; preds = %2
  %23 = bitcast %struct.Table* %3 to %struct.GCObject*
  %24 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = and i8 %25, 32
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %37, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0, i32 0, i32 0
  %30 = load %struct.GCObject*, %struct.GCObject** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %30, i64 0, i32 2
  %32 = load i8, i8* %31, align 1, !tbaa !67
  %33 = and i8 %32, 24
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %37, label %35

; <label>:35:                                     ; preds = %28
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %23) #16
  %36 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  br label %37

; <label>:37:                                     ; preds = %28, %22, %2, %35
  %38 = phi %union.StackValue* [ %17, %28 ], [ %17, %22 ], [ %17, %2 ], [ %36, %35 ]
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -2
  store %union.StackValue* %39, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_set(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %1, %struct.TValue* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 32
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %2) #16
  br label %10

; <label>:10:                                     ; preds = %3, %8
  %11 = phi %struct.TValue* [ %9, %8 ], [ %4, %3 ]
  ret %struct.TValue* %11
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_rawseti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %4, i64 %2, %struct.TValue* nonnull %7) #16
  %8 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !21
  %11 = and i8 %10, 64
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %28, label %13

; <label>:13:                                     ; preds = %3
  %14 = bitcast %struct.Table* %4 to %struct.GCObject*
  %15 = getelementptr inbounds %struct.Table, %struct.Table* %4, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !21
  %17 = and i8 %16, 32
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %28, label %19

; <label>:19:                                     ; preds = %13
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 0, i32 0
  %21 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !67
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %28, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %14) #16
  %27 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  br label %28

; <label>:28:                                     ; preds = %19, %13, %3, %26
  %29 = phi %union.StackValue* [ %8, %19 ], [ %8, %13 ], [ %8, %3 ], [ %27, %26 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1
  store %union.StackValue* %30, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaH_setint(%struct.lua_State*, %struct.Table*, i64, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %1, i64 %2) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 32
  br i1 %9, label %10, label %16

; <label>:10:                                     ; preds = %4
  %11 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #7
  %12 = bitcast %struct.TValue* %5 to i64*
  store i64 %2, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #7
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  br label %16

; <label>:16:                                     ; preds = %4, %10
  %17 = phi i8* [ %7, %4 ], [ %15, %10 ]
  %18 = phi %struct.TValue* [ %6, %4 ], [ %14, %10 ]
  %19 = bitcast %struct.TValue* %3 to i64*
  %20 = bitcast %struct.TValue* %18 to i64*
  %21 = load i64, i64* %19, align 8
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  store i8 %23, i8* %17, align 8, !tbaa !22
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_rawsetp(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %6, %struct.TValue* nonnull %4) #16
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = bitcast %struct.TValue* %12 to i64*
  %14 = bitcast %struct.TValue* %9 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %39, label %24

; <label>:24:                                     ; preds = %3
  %25 = bitcast %struct.Table* %6 to %struct.GCObject*
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = and i8 %27, 32
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %39, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !67
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %39, label %37

; <label>:37:                                     ; preds = %30
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %25) #16
  %38 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  br label %39

; <label>:39:                                     ; preds = %30, %24, %3, %37
  %40 = phi %union.StackValue* [ %19, %30 ], [ %19, %24 ], [ %19, %3 ], [ %38, %37 ]
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 -1
  store %union.StackValue* %41, %union.StackValue** %10, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_setmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !21
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %15, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 0, i32 0
  %12 = bitcast %struct.GCObject** %11 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = bitcast %struct.Table* %13 to %union.GCUnion*
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi %union.GCUnion* [ %14, %10 ], [ null, %2 ]
  %17 = phi %struct.Table* [ %13, %10 ], [ null, %2 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = trunc i8 %19 to i4
  switch i4 %20, label %66 [
    i4 5, label %21
    i4 7, label %44
  ]

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %23 = bitcast %struct.TValue* %3 to %struct.Table**
  %24 = load %struct.Table*, %struct.Table** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.Table, %struct.Table* %24, i64 0, i32 9
  %26 = bitcast %struct.Table** %25 to %union.GCUnion**
  store %union.GCUnion* %16, %union.GCUnion** %26, align 8, !tbaa !21
  %27 = icmp eq %struct.Table* %17, null
  br i1 %27, label %72, label %28

; <label>:28:                                     ; preds = %21
  %29 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !67
  %32 = and i8 %31, 32
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %42, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %36 = load i8, i8* %35, align 1, !tbaa !138
  %37 = and i8 %36, 24
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %42, label %39

; <label>:39:                                     ; preds = %34
  %40 = bitcast %struct.Table* %17 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %29, %struct.GCObject* %40) #16
  %41 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  br label %42

; <label>:42:                                     ; preds = %34, %28, %39
  %43 = phi %struct.GCObject* [ %29, %34 ], [ %29, %28 ], [ %41, %39 ]
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %43, %struct.Table* nonnull %17) #16
  br label %72

; <label>:44:                                     ; preds = %15
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %46 = bitcast %struct.TValue* %3 to %struct.Udata**
  %47 = load %struct.Udata*, %struct.Udata** %46, align 8, !tbaa !21
  %48 = getelementptr inbounds %struct.Udata, %struct.Udata* %47, i64 0, i32 5
  store %struct.Table* %17, %struct.Table** %48, align 8, !tbaa !21
  %49 = icmp eq %struct.Table* %17, null
  br i1 %49, label %72, label %50

; <label>:50:                                     ; preds = %44
  %51 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !21
  %52 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %51, i64 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !21
  %54 = and i8 %53, 32
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %64, label %56

; <label>:56:                                     ; preds = %50
  %57 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %58 = load i8, i8* %57, align 1, !tbaa !138
  %59 = and i8 %58, 24
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %64, label %61

; <label>:61:                                     ; preds = %56
  %62 = bitcast %union.GCUnion* %16 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %51, %struct.GCObject* %62) #16
  %63 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !21
  br label %64

; <label>:64:                                     ; preds = %56, %50, %61
  %65 = phi %struct.GCObject* [ %51, %56 ], [ %51, %50 ], [ %63, %61 ]
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %65, %struct.Table* nonnull %17) #16
  br label %72

; <label>:66:                                     ; preds = %15
  %67 = and i8 %19, 15
  %68 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %69 = load %struct.global_State*, %struct.global_State** %68, align 8, !tbaa !2
  %70 = zext i8 %67 to i64
  %71 = getelementptr inbounds %struct.global_State, %struct.global_State* %69, i64 0, i32 41, i64 %70
  store %struct.Table* %17, %struct.Table** %71, align 8, !tbaa !39
  br label %72

; <label>:72:                                     ; preds = %21, %44, %64, %42, %66
  %73 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %73, i64 -1
  store %union.StackValue* %74, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_checkfinalizer(%struct.lua_State* nocapture readonly, %struct.GCObject*, %struct.Table*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %7 = load i8, i8* %6, align 1, !tbaa !67
  %8 = and i8 %7, 64
  %9 = icmp ne i8 %8, 0
  %10 = icmp eq %struct.Table* %2, null
  %11 = or i1 %10, %9
  br i1 %11, label %80, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %2, i64 0, i32 3
  %14 = load i8, i8* %13, align 2, !tbaa !131
  %15 = and i8 %14, 4
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %17, label %80

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 40, i64 2
  %19 = load %struct.TString*, %struct.TString** %18, align 8, !tbaa !39
  %20 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %2, i32 2, %struct.TString* %19) #16
  %21 = icmp eq %struct.TValue* %20, null
  br i1 %21, label %80, label %22

; <label>:22:                                     ; preds = %17
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %24 = load i8, i8* %23, align 1, !tbaa !44
  %25 = add i8 %24, -3
  %26 = icmp ult i8 %25, 4
  br i1 %26, label %27, label %40

; <label>:27:                                     ; preds = %22
  %28 = load i8, i8* %6, align 1, !tbaa !67
  %29 = and i8 %28, -64
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %31 = load i8, i8* %30, align 4, !tbaa !15
  %32 = and i8 %31, 24
  %33 = or i8 %32, %29
  store i8 %33, i8* %6, align 1, !tbaa !67
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 21
  %35 = load %struct.GCObject**, %struct.GCObject*** %34, align 8, !tbaa !151
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 0
  %37 = icmp eq %struct.GCObject** %35, %36
  br i1 %37, label %38, label %64

; <label>:38:                                     ; preds = %27
  %39 = tail call fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* nonnull %0, %struct.GCObject** %35) #16
  store %struct.GCObject** %39, %struct.GCObject*** %34, align 8, !tbaa !151
  br label %64

; <label>:40:                                     ; preds = %22
  %41 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 30
  %42 = load %struct.GCObject*, %struct.GCObject** %41, align 8, !tbaa !34
  %43 = icmp eq %struct.GCObject* %42, %1
  br i1 %43, label %44, label %48

; <label>:44:                                     ; preds = %40
  %45 = bitcast %struct.GCObject* %1 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !152
  %47 = bitcast %struct.GCObject** %41 to i64*
  store i64 %46, i64* %47, align 8, !tbaa !34
  br label %48

; <label>:48:                                     ; preds = %44, %40
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 31
  %50 = load %struct.GCObject*, %struct.GCObject** %49, align 8, !tbaa !38
  %51 = icmp eq %struct.GCObject* %50, %1
  br i1 %51, label %52, label %56

; <label>:52:                                     ; preds = %48
  %53 = bitcast %struct.GCObject* %1 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !152
  %55 = bitcast %struct.GCObject** %49 to i64*
  store i64 %54, i64* %55, align 8, !tbaa !38
  br label %56

; <label>:56:                                     ; preds = %52, %48
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 32
  %58 = load %struct.GCObject*, %struct.GCObject** %57, align 8, !tbaa !35
  %59 = icmp eq %struct.GCObject* %58, %1
  br i1 %59, label %60, label %64

; <label>:60:                                     ; preds = %56
  %61 = bitcast %struct.GCObject* %1 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !152
  %63 = bitcast %struct.GCObject** %57 to i64*
  store i64 %62, i64* %63, align 8, !tbaa !35
  br label %64

; <label>:64:                                     ; preds = %56, %60, %27, %38
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  br label %66

; <label>:66:                                     ; preds = %66, %64
  %67 = phi %struct.GCObject** [ %65, %64 ], [ %70, %66 ]
  %68 = load %struct.GCObject*, %struct.GCObject** %67, align 8, !tbaa !39
  %69 = icmp eq %struct.GCObject* %68, %1
  %70 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %68, i64 0, i32 0
  br i1 %69, label %71, label %66

; <label>:71:                                     ; preds = %66
  %72 = bitcast %struct.GCObject* %1 to i64*
  %73 = load i64, i64* %72, align 8, !tbaa !152
  %74 = bitcast %struct.GCObject** %67 to i64*
  store i64 %73, i64* %74, align 8, !tbaa !39
  %75 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 22
  %76 = bitcast %struct.GCObject** %75 to i64*
  %77 = load i64, i64* %76, align 8, !tbaa !36
  store i64 %77, i64* %72, align 8, !tbaa !152
  store %struct.GCObject* %1, %struct.GCObject** %75, align 8, !tbaa !36
  %78 = load i8, i8* %6, align 1, !tbaa !67
  %79 = or i8 %78, 64
  store i8 %79, i8* %6, align 1, !tbaa !67
  br label %80

; <label>:80:                                     ; preds = %3, %12, %17, %71
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i32 @lua_setiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = add i32 %2, -1
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %7 = bitcast %struct.TValue* %4 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp ult i32 %5, %11
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %46

; <label>:15:                                     ; preds = %3
  %16 = sext i32 %5 to i64
  %17 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %16, i32 0
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %17 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %16, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !21
  %30 = and i8 %29, 64
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %46, label %32

; <label>:32:                                     ; preds = %15
  %33 = load %struct.GCObject*, %struct.GCObject** %6, align 8, !tbaa !21
  %34 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %33, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !67
  %36 = and i8 %35, 32
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %46, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 0, i32 0
  %40 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !21
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %40, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !67
  %43 = and i8 %42, 24
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %46, label %45

; <label>:45:                                     ; preds = %38
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %33) #16
  br label %46

; <label>:46:                                     ; preds = %13, %45, %15, %32, %38
  %47 = phi %union.StackValue** [ %14, %13 ], [ %18, %45 ], [ %18, %15 ], [ %18, %32 ], [ %18, %38 ]
  %48 = phi i32 [ 0, %13 ], [ 1, %45 ], [ 1, %15 ], [ 1, %32 ], [ 1, %38 ]
  %49 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !20
  %50 = getelementptr inbounds %union.StackValue, %union.StackValue* %49, i64 -1
  store %union.StackValue* %50, %union.StackValue** %47, align 8, !tbaa !20
  ret i32 %48
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_callk(%struct.lua_State*, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = add nsw i32 %1, 1
  %9 = sext i32 %8 to i64
  %10 = sub nsw i64 0, %9
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %10
  %12 = icmp eq i32 (%struct.lua_State*, i32, i64)* %4, null
  br i1 %12, label %23, label %13

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %15 = load i32, i32* %14, align 8, !tbaa !54
  %16 = icmp ult i32 %15, 65536
  br i1 %16, label %17, label %23

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !49
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %4, i32 (%struct.lua_State*, i32, i64)** %20, align 8, !tbaa !21
  %21 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !49
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %21, i64 0, i32 4, i32 0, i32 2
  store i64 %3, i64* %22, align 8, !tbaa !21
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2) #16
  br label %24

; <label>:23:                                     ; preds = %5, %13
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2) #16
  br label %24

; <label>:24:                                     ; preds = %23, %17
  %25 = icmp slt i32 %2, 0
  br i1 %25, label %26, label %34

; <label>:26:                                     ; preds = %24
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %28 = load %struct.CallInfo*, %struct.CallInfo** %27, align 8, !tbaa !49
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %28, i64 0, i32 1
  %30 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !63
  %31 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %32 = icmp ult %union.StackValue* %30, %31
  br i1 %32, label %33, label %34

; <label>:33:                                     ; preds = %26
  store %union.StackValue* %31, %union.StackValue** %29, align 8, !tbaa !63
  br label %34

; <label>:34:                                     ; preds = %33, %26, %24
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_call(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  br label %5

; <label>:5:                                      ; preds = %149, %3
  %6 = load i8, i8* %4, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %149 [
    i6 -10, label %8
    i6 -26, label %12
    i6 22, label %74
  ]

; <label>:8:                                      ; preds = %5
  %9 = bitcast %union.StackValue* %1 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %14

; <label>:12:                                     ; preds = %5
  %13 = bitcast %union.StackValue* %1 to i32 (%struct.lua_State*)**
  br label %14

; <label>:14:                                     ; preds = %12, %8
  %15 = phi i32 (%struct.lua_State*)** [ %13, %12 ], [ %11, %8 ]
  %16 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !59
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !20
  %23 = sub i64 %19, %22
  %24 = icmp slt i64 %23, 336
  br i1 %24, label %25, label %43

; <label>:25:                                     ; preds = %14
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %27 = bitcast %union.StackValue** %26 to i64*
  %28 = load i64, i64* %27, align 8, !tbaa !48
  %29 = ptrtoint %union.StackValue* %1 to i64
  %30 = sub i64 %29, %28
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %32 = load %struct.global_State*, %struct.global_State** %31, align 8, !tbaa !2
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %32, i64 0, i32 3
  %34 = load i64, i64* %33, align 8, !tbaa !11
  %35 = icmp sgt i64 %34, 0
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %25
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %37

; <label>:37:                                     ; preds = %36, %25
  %38 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1) #16
  %39 = bitcast %union.StackValue** %26 to i8**
  %40 = load i8*, i8** %39, align 8, !tbaa !48
  %41 = getelementptr inbounds i8, i8* %40, i64 %30
  %42 = bitcast i8* %41 to %union.StackValue*
  br label %43

; <label>:43:                                     ; preds = %14, %37
  %44 = phi %union.StackValue* [ %42, %37 ], [ %1, %14 ]
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %46 = load %struct.CallInfo*, %struct.CallInfo** %45, align 8, !tbaa !49
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %46, i64 0, i32 3
  %48 = load %struct.CallInfo*, %struct.CallInfo** %47, align 8, !tbaa !103
  %49 = icmp eq %struct.CallInfo* %48, null
  br i1 %49, label %50, label %52

; <label>:50:                                     ; preds = %43
  %51 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0) #16
  br label %52

; <label>:52:                                     ; preds = %43, %50
  %53 = phi %struct.CallInfo* [ %51, %50 ], [ %48, %43 ]
  store %struct.CallInfo* %53, %struct.CallInfo** %45, align 8, !tbaa !49
  %54 = trunc i32 %2 to i16
  %55 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 6
  store i16 %54, i16* %55, align 4, !tbaa !62
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 7
  store i16 2, i16* %56, align 2, !tbaa !60
  %57 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 20
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 1
  store %union.StackValue* %58, %union.StackValue** %59, align 8, !tbaa !63
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 0
  store %union.StackValue* %44, %union.StackValue** %60, align 8, !tbaa !61
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %62 = load i32, i32* %61, align 8, !tbaa !23
  %63 = and i32 %62, 1
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %72, label %65

; <label>:65:                                     ; preds = %52
  %66 = ptrtoint %union.StackValue* %57 to i64
  %67 = ptrtoint %union.StackValue* %44 to i64
  %68 = sub i64 %66, %67
  %69 = lshr exact i64 %68, 4
  %70 = trunc i64 %69 to i32
  %71 = add nsw i32 %70, -1
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 0, i32 -1, i32 1, i32 %71) #16
  br label %72

; <label>:72:                                     ; preds = %52, %65
  %73 = tail call i32 %16(%struct.lua_State* nonnull %0) #17
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %53, i32 %73) #16
  br label %150

; <label>:74:                                     ; preds = %5
  %75 = bitcast %union.StackValue* %1 to %struct.LClosure**
  %76 = load %struct.LClosure*, %struct.LClosure** %75, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %76, i64 0, i32 5
  %78 = load %struct.Proto*, %struct.Proto** %77, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %80 = bitcast %union.StackValue** %79 to i64*
  %81 = load i64, i64* %80, align 8, !tbaa !20
  %82 = ptrtoint %union.StackValue* %1 to i64
  %83 = sub i64 %81, %82
  %84 = lshr exact i64 %83, 4
  %85 = trunc i64 %84 to i32
  %86 = add nsw i32 %85, -1
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 3
  %88 = load i8, i8* %87, align 2, !tbaa !117
  %89 = zext i8 %88 to i32
  %90 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 5
  %91 = load i8, i8* %90, align 4, !tbaa !153
  %92 = zext i8 %91 to i32
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %94 = bitcast %union.StackValue** %93 to i64*
  %95 = load i64, i64* %94, align 8, !tbaa !59
  %96 = sub i64 %95, %81
  %97 = ashr exact i64 %96, 4
  %98 = zext i8 %91 to i64
  %99 = icmp sgt i64 %97, %98
  br i1 %99, label %117, label %100

; <label>:100:                                    ; preds = %74
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %102 = bitcast %union.StackValue** %101 to i64*
  %103 = load i64, i64* %102, align 8, !tbaa !48
  %104 = sub i64 %82, %103
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %106 = load %struct.global_State*, %struct.global_State** %105, align 8, !tbaa !2
  %107 = getelementptr inbounds %struct.global_State, %struct.global_State* %106, i64 0, i32 3
  %108 = load i64, i64* %107, align 8, !tbaa !11
  %109 = icmp sgt i64 %108, 0
  br i1 %109, label %110, label %111

; <label>:110:                                    ; preds = %100
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %111

; <label>:111:                                    ; preds = %110, %100
  %112 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %92, i32 1) #16
  %113 = bitcast %union.StackValue** %101 to i8**
  %114 = load i8*, i8** %113, align 8, !tbaa !48
  %115 = getelementptr inbounds i8, i8* %114, i64 %104
  %116 = bitcast i8* %115 to %union.StackValue*
  br label %117

; <label>:117:                                    ; preds = %74, %111
  %118 = phi %union.StackValue* [ %116, %111 ], [ %1, %74 ]
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %120 = load %struct.CallInfo*, %struct.CallInfo** %119, align 8, !tbaa !49
  %121 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %120, i64 0, i32 3
  %122 = load %struct.CallInfo*, %struct.CallInfo** %121, align 8, !tbaa !103
  %123 = icmp eq %struct.CallInfo* %122, null
  br i1 %123, label %124, label %126

; <label>:124:                                    ; preds = %117
  %125 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0) #16
  br label %126

; <label>:126:                                    ; preds = %117, %124
  %127 = phi %struct.CallInfo* [ %125, %124 ], [ %122, %117 ]
  store %struct.CallInfo* %127, %struct.CallInfo** %119, align 8, !tbaa !49
  %128 = trunc i32 %2 to i16
  %129 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 6
  store i16 %128, i16* %129, align 4, !tbaa !62
  %130 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 16
  %131 = bitcast i32** %130 to i64*
  %132 = load i64, i64* %131, align 8, !tbaa !119
  %133 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 4
  %134 = bitcast %union.anon.0* %133 to i64*
  store i64 %132, i64* %134, align 8, !tbaa !21
  %135 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 7
  store i16 0, i16* %135, align 2, !tbaa !60
  %136 = getelementptr inbounds %union.StackValue, %union.StackValue* %118, i64 1
  %137 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 %98
  %138 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 1
  store %union.StackValue* %137, %union.StackValue** %138, align 8, !tbaa !63
  %139 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 0
  store %union.StackValue* %118, %union.StackValue** %139, align 8, !tbaa !61
  br label %140

; <label>:140:                                    ; preds = %143, %126
  %141 = phi i32 [ %86, %126 ], [ %147, %143 ]
  %142 = icmp slt i32 %141, %89
  br i1 %142, label %143, label %148

; <label>:143:                                    ; preds = %140
  %144 = load %union.StackValue*, %union.StackValue** %79, align 8, !tbaa !20
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 1
  store %union.StackValue* %145, %union.StackValue** %79, align 8, !tbaa !20
  %146 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 0, i32 0, i32 1
  store i8 0, i8* %146, align 8, !tbaa !21
  %147 = add nsw i32 %141, 1
  br label %140

; <label>:148:                                    ; preds = %140
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* %127) #16
  br label %150

; <label>:149:                                    ; preds = %5
  tail call fastcc void @luaD_tryfuncTM(%struct.lua_State* %0, %union.StackValue* nonnull %1) #16
  br label %5

; <label>:150:                                    ; preds = %148, %72
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_callnoyield(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %5 = load i32, i32* %4, align 8, !tbaa !54
  %6 = add i32 %5, 65546
  store i32 %6, i32* %4, align 8, !tbaa !54
  %7 = and i32 %6, 65528
  %8 = icmp ugt i32 %7, 2199
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %3
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  br label %10

; <label>:10:                                     ; preds = %9, %3
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %1, i32 %2) #16
  %11 = load i32, i32* %4, align 8, !tbaa !54
  %12 = add i32 %11, -65546
  store i32 %12, i32* %4, align 8, !tbaa !54
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_pcallk(%struct.lua_State*, i32, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %7 = alloca %struct.CallS, align 8
  %8 = bitcast %struct.CallS* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %17, label %10

; <label>:10:                                     ; preds = %6
  %11 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %3) #16
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %13 = bitcast %union.StackValue** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !48
  %15 = ptrtoint %union.StackValue* %11 to i64
  %16 = sub i64 %15, %14
  br label %17

; <label>:17:                                     ; preds = %6, %10
  %18 = phi i64 [ %16, %10 ], [ 0, %6 ]
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %21 = add nsw i32 %1, 1
  %22 = sext i32 %21 to i64
  %23 = sub nsw i64 0, %22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 %23
  %25 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 0
  store %union.StackValue* %24, %union.StackValue** %25, align 8, !tbaa !154
  %26 = icmp eq i32 (%struct.lua_State*, i32, i64)* %5, null
  %27 = ptrtoint %union.StackValue* %24 to i64
  br i1 %26, label %32, label %28

; <label>:28:                                     ; preds = %17
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %30 = load i32, i32* %29, align 8, !tbaa !54
  %31 = icmp ult i32 %30, 65536
  br i1 %31, label %39, label %32

; <label>:32:                                     ; preds = %28, %17
  %33 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 1
  store i32 %2, i32* %33, align 8, !tbaa !156
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %35 = bitcast %union.StackValue** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !48
  %37 = sub i64 %27, %36
  %38 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %8, i64 %37, i64 %18) #16
  br label %64

; <label>:39:                                     ; preds = %28
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %41 = load %struct.CallInfo*, %struct.CallInfo** %40, align 8, !tbaa !49
  %42 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %41, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %5, i32 (%struct.lua_State*, i32, i64)** %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %41, i64 0, i32 4, i32 0, i32 2
  store i64 %4, i64* %43, align 8, !tbaa !21
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %45 = bitcast %union.StackValue** %44 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !48
  %47 = sub i64 %27, %46
  %48 = trunc i64 %47 to i32
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %41, i64 0, i32 5, i32 0
  store i32 %48, i32* %49, align 8, !tbaa !21
  %50 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %51 = load i64, i64* %50, align 8, !tbaa !58
  %52 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %41, i64 0, i32 4, i32 0, i32 1
  store i64 %51, i64* %52, align 8, !tbaa !21
  store i64 %18, i64* %50, align 8, !tbaa !58
  %53 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %41, i64 0, i32 7
  %54 = load i16, i16* %53, align 2, !tbaa !60
  %55 = and i16 %54, -10
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %57 = load i8, i8* %56, align 1, !tbaa !55
  %58 = zext i8 %57 to i16
  %59 = or i16 %55, %58
  %60 = or i16 %59, 8
  store i16 %60, i16* %53, align 2, !tbaa !60
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %24, i32 %2) #16
  %61 = load i16, i16* %53, align 2, !tbaa !60
  %62 = and i16 %61, -9
  store i16 %62, i16* %53, align 2, !tbaa !60
  %63 = load i64, i64* %52, align 8, !tbaa !21
  store i64 %63, i64* %50, align 8, !tbaa !58
  br label %64

; <label>:64:                                     ; preds = %39, %32
  %65 = phi i32 [ %38, %32 ], [ 0, %39 ]
  %66 = icmp slt i32 %2, 0
  br i1 %66, label %67, label %75

; <label>:67:                                     ; preds = %64
  %68 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %69 = load %struct.CallInfo*, %struct.CallInfo** %68, align 8, !tbaa !49
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %69, i64 0, i32 1
  %71 = load %union.StackValue*, %union.StackValue** %70, align 8, !tbaa !63
  %72 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %73 = icmp ult %union.StackValue* %71, %72
  br i1 %73, label %74, label %75

; <label>:74:                                     ; preds = %67
  store %union.StackValue* %72, %union.StackValue** %70, align 8, !tbaa !63
  br label %75

; <label>:75:                                     ; preds = %74, %67, %64
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %65
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaD_pcall(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*, i64, i64) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = bitcast %struct.CallInfo** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !49
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !55
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %12 = load i64, i64* %11, align 8, !tbaa !58
  store i64 %4, i64* %11, align 8, !tbaa !58
  %13 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* %1, i8* %2) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %25, label %15, !prof !70

; <label>:15:                                     ; preds = %5
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %17 = bitcast %union.StackValue** %16 to i8**
  %18 = load i8*, i8** %17, align 8, !tbaa !48
  %19 = getelementptr inbounds i8, i8* %18, i64 %3
  %20 = bitcast i8* %19 to %union.StackValue*
  store i64 %8, i64* %7, align 8, !tbaa !49
  store i8 %10, i8* %9, align 1, !tbaa !55
  %21 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %20, i32 %13) #16
  %22 = load i8*, i8** %17, align 8, !tbaa !48
  %23 = getelementptr inbounds i8, i8* %22, i64 %3
  %24 = bitcast i8* %23 to %union.StackValue*
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %21, %union.StackValue* %24) #16
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* nonnull %0) #16
  br label %25

; <label>:25:                                     ; preds = %5, %15
  %26 = phi i32 [ %21, %15 ], [ 0, %5 ]
  store i64 %12, i64* %11, align 8, !tbaa !58
  ret i32 %26
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @f_call(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to %union.StackValue**
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !154
  %5 = getelementptr inbounds i8, i8* %1, i64 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6, align 8, !tbaa !156
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* %4, i32 %7) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_load(%struct.lua_State*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.SParser, align 8
  %7 = alloca %struct.Zio, align 8
  %8 = bitcast %struct.Zio* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %8) #7
  %9 = icmp eq i8* %3, null
  %10 = select i1 %9, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %3
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 4
  store %struct.lua_State* %0, %struct.lua_State** %11, align 8, !tbaa !157
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 2
  store i8* (%struct.lua_State*, i8*, i64*)* %1, i8* (%struct.lua_State*, i8*, i64*)** %12, align 8, !tbaa !159
  %13 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 3
  store i8* %2, i8** %13, align 8, !tbaa !160
  call void @llvm.memset.p0i8.i64(i8* nonnull %8, i8 0, i64 16, i32 8, i1 false) #7
  %14 = bitcast %struct.SParser* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* nonnull %14) #7
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %16 = load i32, i32* %15, align 8, !tbaa !54
  %17 = add i32 %16, 65536
  store i32 %17, i32* %15, align 8, !tbaa !54
  %18 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 0
  store %struct.Zio* %7, %struct.Zio** %18, align 8, !tbaa !161
  %19 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 4
  store i8* %10, i8** %19, align 8, !tbaa !167
  %20 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 3
  store i8* %4, i8** %20, align 8, !tbaa !168
  %21 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 0, i32 0
  %22 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 0, i32 2
  store i32 0, i32* %22, align 4, !tbaa !169
  %23 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 1, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %23, align 8, !tbaa !170
  %24 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 1, i32 2
  store i32 0, i32* %24, align 4, !tbaa !171
  %25 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 2, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %25, align 8, !tbaa !172
  %26 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 2, i32 2
  store i32 0, i32* %26, align 4, !tbaa !173
  %27 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 1, i32 0
  store i8* null, i8** %27, align 8, !tbaa !174
  %28 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 1, i32 2
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %30 = bitcast %union.StackValue** %29 to i64*
  %31 = bitcast i64* %28 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %31, i8 0, i64 16, i32 8, i1 false) #7
  %32 = load i64, i64* %30, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %34 = bitcast %union.StackValue** %33 to i64*
  %35 = load i64, i64* %34, align 8, !tbaa !48
  %36 = sub i64 %32, %35
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %38 = load i64, i64* %37, align 8, !tbaa !58
  %39 = call fastcc i32 @luaD_pcall(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @f_parser, i8* nonnull %14, i64 %36, i64 %38) #17
  %40 = load i8*, i8** %27, align 8, !tbaa !174
  %41 = load i64, i64* %28, align 8, !tbaa !175
  %42 = call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %0, i8* %40, i64 %41, i64 0) #17
  store i8* %42, i8** %27, align 8, !tbaa !174
  store i64 0, i64* %28, align 8, !tbaa !175
  %43 = bitcast %struct.Vardesc** %21 to i8**
  %44 = load i8*, i8** %43, align 8, !tbaa !176
  %45 = load i32, i32* %22, align 4, !tbaa !169
  %46 = sext i32 %45 to i64
  %47 = shl nsw i64 %46, 1
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %44, i64 %47) #17
  %48 = bitcast %struct.Labeldesc** %23 to i8**
  %49 = load i8*, i8** %48, align 8, !tbaa !170
  %50 = load i32, i32* %24, align 4, !tbaa !171
  %51 = sext i32 %50 to i64
  %52 = mul nsw i64 %51, 24
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %49, i64 %52) #17
  %53 = bitcast %struct.Labeldesc** %25 to i8**
  %54 = load i8*, i8** %53, align 8, !tbaa !172
  %55 = load i32, i32* %26, align 4, !tbaa !173
  %56 = sext i32 %55 to i64
  %57 = mul nsw i64 %56, 24
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %54, i64 %57) #17
  %58 = load i32, i32* %15, align 8, !tbaa !54
  %59 = add i32 %58, -65536
  store i32 %59, i32* %15, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0i8(i64 96, i8* nonnull %14) #7
  %60 = icmp eq i32 %39, 0
  br i1 %60, label %61, label %104

; <label>:61:                                     ; preds = %5
  %62 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %62, i64 -1, i32 0, i32 0, i32 0
  %64 = bitcast %struct.GCObject** %63 to %struct.LClosure**
  %65 = load %struct.LClosure*, %struct.LClosure** %64, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %65, i64 0, i32 3
  %67 = load i8, i8* %66, align 2, !tbaa !177
  %68 = icmp eq i8 %67, 0
  br i1 %68, label %104, label %69

; <label>:69:                                     ; preds = %61
  %70 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %71 = load %struct.global_State*, %struct.global_State** %70, align 8, !tbaa !2
  %72 = getelementptr inbounds %struct.global_State, %struct.global_State* %71, i64 0, i32 7, i32 0, i32 0
  %73 = bitcast %struct.GCObject** %72 to %struct.Table**
  %74 = load %struct.Table*, %struct.Table** %73, align 8, !tbaa !21
  %75 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %74, i64 2) #16
  %76 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %65, i64 0, i32 6, i64 0
  %77 = load %struct.UpVal*, %struct.UpVal** %76, align 8, !tbaa !39
  %78 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %77, i64 0, i32 3
  %79 = load %struct.TValue*, %struct.TValue** %78, align 8, !tbaa !64
  %80 = bitcast %struct.TValue* %75 to i64*
  %81 = bitcast %struct.TValue* %79 to i64*
  %82 = load i64, i64* %80, align 8
  store i64 %82, i64* %81, align 8
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 1
  %84 = load i8, i8* %83, align 8, !tbaa !22
  %85 = getelementptr inbounds %struct.TValue, %struct.TValue* %79, i64 0, i32 1
  store i8 %84, i8* %85, align 8, !tbaa !22
  %86 = load i8, i8* %83, align 8, !tbaa !22
  %87 = and i8 %86, 64
  %88 = icmp eq i8 %87, 0
  br i1 %88, label %104, label %89

; <label>:89:                                     ; preds = %69
  %90 = load %struct.UpVal*, %struct.UpVal** %76, align 8, !tbaa !39
  %91 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %90, i64 0, i32 2
  %92 = load i8, i8* %91, align 1, !tbaa !66
  %93 = and i8 %92, 32
  %94 = icmp eq i8 %93, 0
  br i1 %94, label %104, label %95

; <label>:95:                                     ; preds = %89
  %96 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 0, i32 0
  %97 = load %struct.GCObject*, %struct.GCObject** %96, align 8, !tbaa !21
  %98 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %97, i64 0, i32 2
  %99 = load i8, i8* %98, align 1, !tbaa !67
  %100 = and i8 %99, 24
  %101 = icmp eq i8 %100, 0
  br i1 %101, label %104, label %102

; <label>:102:                                    ; preds = %95
  %103 = bitcast %struct.UpVal* %90 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %103, %struct.GCObject* %97) #16
  br label %104

; <label>:104:                                    ; preds = %61, %95, %89, %69, %102, %5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %8) #7
  ret i32 %39
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_dump(%struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32) local_unnamed_addr #0 {
  %5 = alloca %struct.DumpState, align 8
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = icmp eq i8 %9, 86
  br i1 %10, label %11, label %35

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0, i32 0, i32 0
  %13 = bitcast %struct.GCObject** %12 to %struct.LClosure**
  %14 = load %struct.LClosure*, %struct.LClosure** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 5
  %16 = load %struct.Proto*, %struct.Proto** %15, align 8, !tbaa !21
  %17 = bitcast %struct.DumpState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %17) #7
  %18 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %5, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %18, align 8, !tbaa !179
  %19 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %5, i64 0, i32 1
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %1, i32 (%struct.lua_State*, i8*, i64, i8*)** %19, align 8, !tbaa !181
  %20 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %5, i64 0, i32 2
  store i8* %2, i8** %20, align 8, !tbaa !182
  %21 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %5, i64 0, i32 3
  store i32 %3, i32* %21, align 8, !tbaa !183
  %22 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %5, i64 0, i32 4
  %23 = tail call i32 %1(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 0), i64 4, i8* %2) #17
  store i32 %23, i32* %22, align 4, !tbaa !184
  call fastcc void @DumpSize(i64 504, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpByte(i32 0, %struct.DumpState* nonnull %5) #17
  %24 = load i32, i32* %22, align 4, !tbaa !184
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %11
  %27 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %19, align 8, !tbaa !181
  %28 = load %struct.lua_State*, %struct.lua_State** %18, align 8, !tbaa !179
  %29 = load i8*, i8** %20, align 8, !tbaa !182
  %30 = tail call i32 %27(%struct.lua_State* %28, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i64 6, i8* %29) #17
  store i32 %30, i32* %22, align 4, !tbaa !184
  br label %31

; <label>:31:                                     ; preds = %11, %26
  call fastcc void @DumpByte(i32 4, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpByte(i32 8, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpByte(i32 8, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpInteger(i64 22136, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpNumber(double 3.705000e+02, %struct.DumpState* nonnull %5) #17
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 6
  %33 = load i32, i32* %32, align 8, !tbaa !185
  call fastcc void @DumpByte(i32 %33, %struct.DumpState* nonnull %5) #17
  call fastcc void @DumpFunction(%struct.Proto* %16, %struct.TString* null, %struct.DumpState* nonnull %5) #17
  %34 = load i32, i32* %22, align 4, !tbaa !184
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %17) #7
  br label %35

; <label>:35:                                     ; preds = %4, %31
  %36 = phi i32 [ %34, %31 ], [ 1, %4 ]
  ret i32 %36
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define i32 @lua_status(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %3 = load i8, i8* %2, align 2, !tbaa !57
  %4 = zext i8 %3 to i32
  ret i32 %4
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_gc(%struct.lua_State*, i32, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  call void @llvm.va_start(i8* nonnull %4)
  switch i32 %1, label %256 [
    i32 0, label %7
    i32 1, label %9
    i32 2, label %11
    i32 3, label %12
    i32 4, label %20
    i32 5, label %28
    i32 6, label %68
    i32 7, label %92
    i32 9, label %116
    i32 10, label %120
    i32 11, label %176
  ]

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 0, i8* %8, align 1, !tbaa !28
  br label %256

; <label>:9:                                      ; preds = %2
  call fastcc void @luaE_setdebt(%struct.global_State* %6, i64 0) #16
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 1, i8* %10, align 1, !tbaa !28
  br label %256

; <label>:11:                                     ; preds = %2
  call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 0) #16
  br label %256

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %14 = load i64, i64* %13, align 8, !tbaa !31
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %16 = load i64, i64* %15, align 8, !tbaa !11
  %17 = add nsw i64 %16, %14
  %18 = lshr i64 %17, 10
  %19 = trunc i64 %18 to i32
  br label %256

; <label>:20:                                     ; preds = %2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %22 = load i64, i64* %21, align 8, !tbaa !31
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = add nsw i64 %24, %22
  %26 = trunc i64 %25 to i32
  %27 = and i32 %26, 1023
  br label %256

; <label>:28:                                     ; preds = %2
  %29 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %30 = load i32, i32* %29, align 16
  %31 = icmp ult i32 %30, 41
  br i1 %31, label %32, label %38

; <label>:32:                                     ; preds = %28
  %33 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %34 = load i8*, i8** %33, align 16
  %35 = sext i32 %30 to i64
  %36 = getelementptr i8, i8* %34, i64 %35
  %37 = add i32 %30, 8
  store i32 %37, i32* %29, align 16
  br label %42

; <label>:38:                                     ; preds = %28
  %39 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %40 = load i8*, i8** %39, align 8
  %41 = getelementptr i8, i8* %40, i64 8
  store i8* %41, i8** %39, align 8
  br label %42

; <label>:42:                                     ; preds = %38, %32
  %43 = phi i8* [ %36, %32 ], [ %40, %38 ]
  %44 = bitcast i8* %43 to i32*
  %45 = load i32, i32* %44, align 4
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %47 = load i8, i8* %46, align 1, !tbaa !28
  store i8 1, i8* %46, align 1, !tbaa !28
  %48 = icmp eq i32 %45, 0
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %42
  call fastcc void @luaE_setdebt(%struct.global_State* nonnull %6, i64 0) #16
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  store i8 %47, i8* %46, align 1, !tbaa !28
  br label %63

; <label>:50:                                     ; preds = %42
  %51 = sext i32 %45 to i64
  %52 = shl nsw i64 %51, 10
  %53 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %54 = load i64, i64* %53, align 8, !tbaa !11
  %55 = add nsw i64 %54, %52
  call fastcc void @luaE_setdebt(%struct.global_State* nonnull %6, i64 %55) #16
  %56 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 3
  %58 = load i64, i64* %57, align 8, !tbaa !11
  %59 = icmp sgt i64 %58, 0
  br i1 %59, label %60, label %61

; <label>:60:                                     ; preds = %50
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %61

; <label>:61:                                     ; preds = %50, %60
  store i8 %47, i8* %46, align 1, !tbaa !28
  %62 = icmp sgt i64 %55, 0
  br i1 %62, label %63, label %256

; <label>:63:                                     ; preds = %49, %61
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 11
  %65 = load i8, i8* %64, align 1, !tbaa !44
  %66 = icmp eq i8 %65, 8
  %67 = zext i1 %66 to i32
  br label %256

; <label>:68:                                     ; preds = %2
  %69 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %70 = load i32, i32* %69, align 16
  %71 = icmp ult i32 %70, 41
  br i1 %71, label %72, label %78

; <label>:72:                                     ; preds = %68
  %73 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %74 = load i8*, i8** %73, align 16
  %75 = sext i32 %70 to i64
  %76 = getelementptr i8, i8* %74, i64 %75
  %77 = add i32 %70, 8
  store i32 %77, i32* %69, align 16
  br label %82

; <label>:78:                                     ; preds = %68
  %79 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %80 = load i8*, i8** %79, align 8
  %81 = getelementptr i8, i8* %80, i64 8
  store i8* %81, i8** %79, align 8
  br label %82

; <label>:82:                                     ; preds = %78, %72
  %83 = phi i8* [ %76, %72 ], [ %80, %78 ]
  %84 = bitcast i8* %83 to i32*
  %85 = load i32, i32* %84, align 4
  %86 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  %87 = load i8, i8* %86, align 1, !tbaa !79
  %88 = zext i8 %87 to i32
  %89 = shl nuw nsw i32 %88, 2
  %90 = sdiv i32 %85, 4
  %91 = trunc i32 %90 to i8
  store i8 %91, i8* %86, align 1, !tbaa !79
  br label %256

; <label>:92:                                     ; preds = %2
  %93 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %94 = load i32, i32* %93, align 16
  %95 = icmp ult i32 %94, 41
  br i1 %95, label %96, label %102

; <label>:96:                                     ; preds = %92
  %97 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %98 = load i8*, i8** %97, align 16
  %99 = sext i32 %94 to i64
  %100 = getelementptr i8, i8* %98, i64 %99
  %101 = add i32 %94, 8
  store i32 %101, i32* %93, align 16
  br label %106

; <label>:102:                                    ; preds = %92
  %103 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %104 = load i8*, i8** %103, align 8
  %105 = getelementptr i8, i8* %104, i64 8
  store i8* %105, i8** %103, align 8
  br label %106

; <label>:106:                                    ; preds = %102, %96
  %107 = phi i8* [ %100, %96 ], [ %104, %102 ]
  %108 = bitcast i8* %107 to i32*
  %109 = load i32, i32* %108, align 4
  %110 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  %111 = load i8, i8* %110, align 4, !tbaa !42
  %112 = zext i8 %111 to i32
  %113 = shl nuw nsw i32 %112, 2
  %114 = sdiv i32 %109, 4
  %115 = trunc i32 %114 to i8
  store i8 %115, i8* %110, align 4, !tbaa !42
  br label %256

; <label>:116:                                    ; preds = %2
  %117 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %118 = load i8, i8* %117, align 1, !tbaa !28
  %119 = zext i8 %118 to i32
  br label %256

; <label>:120:                                    ; preds = %2
  %121 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %122 = load i32, i32* %121, align 16
  %123 = icmp ult i32 %122, 41
  br i1 %123, label %130, label %124

; <label>:124:                                    ; preds = %120
  %125 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %126 = load i8*, i8** %125, align 8
  %127 = getelementptr i8, i8* %126, i64 8
  store i8* %127, i8** %125, align 8
  %128 = bitcast i8* %126 to i32*
  %129 = load i32, i32* %128, align 4
  br label %145

; <label>:130:                                    ; preds = %120
  %131 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %132 = load i8*, i8** %131, align 16
  %133 = sext i32 %122 to i64
  %134 = getelementptr i8, i8* %132, i64 %133
  %135 = add i32 %122, 8
  store i32 %135, i32* %121, align 16
  %136 = bitcast i8* %134 to i32*
  %137 = load i32, i32* %136, align 4
  %138 = icmp ult i32 %135, 41
  br i1 %138, label %139, label %145

; <label>:139:                                    ; preds = %130
  %140 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %141 = load i8*, i8** %140, align 16
  %142 = sext i32 %135 to i64
  %143 = getelementptr i8, i8* %141, i64 %142
  %144 = add i32 %122, 16
  store i32 %144, i32* %121, align 16
  br label %150

; <label>:145:                                    ; preds = %124, %130
  %146 = phi i32 [ %129, %124 ], [ %137, %130 ]
  %147 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %148 = load i8*, i8** %147, align 8
  %149 = getelementptr i8, i8* %148, i64 8
  store i8* %149, i8** %147, align 8
  br label %150

; <label>:150:                                    ; preds = %145, %139
  %151 = phi i32 [ %137, %139 ], [ %146, %145 ]
  %152 = phi i8* [ %143, %139 ], [ %148, %145 ]
  %153 = bitcast i8* %152 to i32*
  %154 = load i32, i32* %153, align 4
  %155 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %156 = load i8, i8* %155, align 2, !tbaa !29
  %157 = icmp eq i8 %156, 1
  br i1 %157, label %163, label %158

; <label>:158:                                    ; preds = %150
  %159 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %160 = load i64, i64* %159, align 8, !tbaa !30
  %161 = icmp eq i64 %160, 0
  %162 = select i1 %161, i32 11, i32 10
  br label %163

; <label>:163:                                    ; preds = %158, %150
  %164 = phi i32 [ 10, %150 ], [ %162, %158 ]
  %165 = icmp eq i32 %151, 0
  br i1 %165, label %169, label %166

; <label>:166:                                    ; preds = %163
  %167 = trunc i32 %151 to i8
  %168 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 13
  store i8 %167, i8* %168, align 1, !tbaa !80
  br label %169

; <label>:169:                                    ; preds = %163, %166
  %170 = icmp eq i32 %154, 0
  br i1 %170, label %175, label %171

; <label>:171:                                    ; preds = %169
  %172 = sdiv i32 %154, 4
  %173 = trunc i32 %172 to i8
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 14
  store i8 %173, i8* %174, align 8, !tbaa !33
  br label %175

; <label>:175:                                    ; preds = %169, %171
  call fastcc void @luaC_changemode(%struct.lua_State* nonnull %0, i32 1) #16
  br label %256

; <label>:176:                                    ; preds = %2
  %177 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %178 = load i32, i32* %177, align 16
  %179 = icmp ult i32 %178, 41
  br i1 %179, label %186, label %180

; <label>:180:                                    ; preds = %176
  %181 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %182 = load i8*, i8** %181, align 8
  %183 = getelementptr i8, i8* %182, i64 8
  store i8* %183, i8** %181, align 8
  %184 = bitcast i8* %182 to i32*
  %185 = load i32, i32* %184, align 4
  br label %195

; <label>:186:                                    ; preds = %176
  %187 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %188 = load i8*, i8** %187, align 16
  %189 = sext i32 %178 to i64
  %190 = getelementptr i8, i8* %188, i64 %189
  %191 = add i32 %178, 8
  store i32 %191, i32* %177, align 16
  %192 = bitcast i8* %190 to i32*
  %193 = load i32, i32* %192, align 4
  %194 = icmp ult i32 %191, 41
  br i1 %194, label %202, label %195

; <label>:195:                                    ; preds = %186, %180
  %196 = phi i32 [ %185, %180 ], [ %193, %186 ]
  %197 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %198 = load i8*, i8** %197, align 8
  %199 = getelementptr i8, i8* %198, i64 8
  store i8* %199, i8** %197, align 8
  %200 = bitcast i8* %198 to i32*
  %201 = load i32, i32* %200, align 4
  br label %217

; <label>:202:                                    ; preds = %186
  %203 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %204 = load i8*, i8** %203, align 16
  %205 = sext i32 %191 to i64
  %206 = getelementptr i8, i8* %204, i64 %205
  %207 = add i32 %178, 16
  store i32 %207, i32* %177, align 16
  %208 = bitcast i8* %206 to i32*
  %209 = load i32, i32* %208, align 4
  %210 = icmp ult i32 %207, 41
  br i1 %210, label %211, label %217

; <label>:211:                                    ; preds = %202
  %212 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %213 = load i8*, i8** %212, align 16
  %214 = sext i32 %207 to i64
  %215 = getelementptr i8, i8* %213, i64 %214
  %216 = add i32 %178, 24
  store i32 %216, i32* %177, align 16
  br label %223

; <label>:217:                                    ; preds = %195, %202
  %218 = phi i32 [ %201, %195 ], [ %209, %202 ]
  %219 = phi i32 [ %196, %195 ], [ %193, %202 ]
  %220 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %221 = load i8*, i8** %220, align 8
  %222 = getelementptr i8, i8* %221, i64 8
  store i8* %222, i8** %220, align 8
  br label %223

; <label>:223:                                    ; preds = %217, %211
  %224 = phi i32 [ %209, %211 ], [ %218, %217 ]
  %225 = phi i32 [ %193, %211 ], [ %219, %217 ]
  %226 = phi i8* [ %215, %211 ], [ %221, %217 ]
  %227 = bitcast i8* %226 to i32*
  %228 = load i32, i32* %227, align 4
  %229 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %230 = load i8, i8* %229, align 2, !tbaa !29
  %231 = icmp eq i8 %230, 1
  br i1 %231, label %237, label %232

; <label>:232:                                    ; preds = %223
  %233 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %234 = load i64, i64* %233, align 8, !tbaa !30
  %235 = icmp eq i64 %234, 0
  %236 = select i1 %235, i32 11, i32 10
  br label %237

; <label>:237:                                    ; preds = %232, %223
  %238 = phi i32 [ 10, %223 ], [ %236, %232 ]
  %239 = icmp eq i32 %225, 0
  br i1 %239, label %244, label %240

; <label>:240:                                    ; preds = %237
  %241 = sdiv i32 %225, 4
  %242 = trunc i32 %241 to i8
  %243 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  store i8 %242, i8* %243, align 1, !tbaa !79
  br label %244

; <label>:244:                                    ; preds = %237, %240
  %245 = icmp eq i32 %224, 0
  br i1 %245, label %250, label %246

; <label>:246:                                    ; preds = %244
  %247 = sdiv i32 %224, 4
  %248 = trunc i32 %247 to i8
  %249 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  store i8 %248, i8* %249, align 4, !tbaa !42
  br label %250

; <label>:250:                                    ; preds = %244, %246
  %251 = icmp eq i32 %228, 0
  br i1 %251, label %255, label %252

; <label>:252:                                    ; preds = %250
  %253 = trunc i32 %228 to i8
  %254 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 19
  store i8 %253, i8* %254, align 1, !tbaa !43
  br label %255

; <label>:255:                                    ; preds = %250, %252
  call fastcc void @luaC_changemode(%struct.lua_State* nonnull %0, i32 0) #16
  br label %256

; <label>:256:                                    ; preds = %63, %2, %61, %255, %175, %116, %106, %82, %20, %12, %11, %9, %7
  %257 = phi i32 [ %238, %255 ], [ %164, %175 ], [ %119, %116 ], [ %113, %106 ], [ %89, %82 ], [ %27, %20 ], [ %19, %12 ], [ 0, %11 ], [ 0, %9 ], [ 0, %7 ], [ 0, %61 ], [ %67, %63 ], [ -1, %2 ]
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i32 %257
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @luaE_setdebt(%struct.global_State* nocapture, i64) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %4 = load i64, i64* %3, align 8, !tbaa !31
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %6 = load i64, i64* %5, align 8, !tbaa !11
  %7 = add nsw i64 %6, %4
  %8 = add nsw i64 %7, -9223372036854775807
  %9 = icmp sgt i64 %8, %1
  %10 = select i1 %9, i64 %8, i64 %1
  %11 = sub nsw i64 %7, %10
  store i64 %11, i64* %3, align 8, !tbaa !31
  store i64 %10, i64* %5, align 8, !tbaa !11
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_fullgc(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = trunc i32 %1 to i8
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 16
  store i8 %5, i8* %6, align 2, !tbaa !78
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 12
  %8 = load i8, i8* %7, align 2, !tbaa !29
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %16

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %12 = load i8, i8* %11, align 1, !tbaa !44
  %13 = icmp ult i8 %12, 3
  br i1 %13, label %14, label %15

; <label>:14:                                     ; preds = %10
  tail call fastcc void @entersweep(%struct.lua_State* nonnull %0) #17
  br label %15

; <label>:15:                                     ; preds = %10, %14
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* nonnull %0, i32 256) #17
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* nonnull %0, i32 128) #17
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* nonnull %0, i32 256) #17
  tail call fastcc void @setpause(%struct.global_State* nonnull %4) #17
  br label %18

; <label>:16:                                     ; preds = %2
  %17 = tail call fastcc i64 @fullgen(%struct.lua_State* nonnull %0, %struct.global_State* %4) #16
  br label %18

; <label>:18:                                     ; preds = %16, %15
  store i8 0, i8* %6, align 2, !tbaa !78
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_changemode(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 12
  %6 = load i8, i8* %5, align 2, !tbaa !29
  %7 = zext i8 %6 to i32
  %8 = icmp eq i32 %7, %1
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %2
  %10 = icmp eq i32 %1, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %9
  %12 = tail call fastcc i64 @entergen(%struct.lua_State* nonnull %0, %struct.global_State* %4) #16
  br label %14

; <label>:13:                                     ; preds = %9
  tail call fastcc void @enterinc(%struct.global_State* %4) #16
  br label %14

; <label>:14:                                     ; preds = %2, %11, %13
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 5
  store i64 0, i64* %15, align 8, !tbaa !30
  ret void
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define i32 @lua_error(%struct.lua_State*) local_unnamed_addr #5 {
  tail call fastcc void @luaG_errormsg(%struct.lua_State* %0) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_errormsg(%struct.lua_State*) unnamed_addr #5 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %3 = load i64, i64* %2, align 8, !tbaa !58
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !48
  %9 = getelementptr inbounds i8, i8* %8, i64 %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = bitcast %struct.TValue* %12 to i64*
  %14 = bitcast %union.StackValue* %11 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast i8* %9 to i64*
  %22 = bitcast %struct.TValue* %20 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds i8, i8* %9, i64 8
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %10, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %29, i32 1) #16
  br label %30

; <label>:30:                                     ; preds = %1, %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 2) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @lua_next(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  %7 = tail call fastcc i32 @luaH_realasize(%struct.Table* %3) #17
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %42, label %13

; <label>:13:                                     ; preds = %2
  %14 = icmp eq i8 %10, 35
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %13
  %16 = bitcast %union.StackValue* %6 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !21
  %18 = add i64 %17, -1
  %19 = icmp ult i64 %18, 2147483648
  %20 = trunc i64 %17 to i32
  %21 = select i1 %19, i32 %20, i32 0
  br label %22

; <label>:22:                                     ; preds = %15, %13
  %23 = phi i32 [ %21, %15 ], [ 0, %13 ]
  %24 = add i32 %23, -1
  %25 = icmp ult i32 %24, %7
  br i1 %25, label %42, label %26

; <label>:26:                                     ; preds = %22
  %27 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %3, %struct.TValue* nonnull %8) #17
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = icmp eq i8 %29, 32
  br i1 %30, label %31, label %32, !prof !47

; <label>:31:                                     ; preds = %26
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.280, i64 0, i64 0)) #19
  unreachable

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 7
  %34 = bitcast %union.Node** %33 to i64*
  %35 = load i64, i64* %34, align 8, !tbaa !147
  %36 = ptrtoint %struct.TValue* %27 to i64
  %37 = sub i64 %36, %35
  %38 = sdiv exact i64 %37, 24
  %39 = trunc i64 %38 to i32
  %40 = add i32 %7, 1
  %41 = add i32 %40, %39
  br label %42

; <label>:42:                                     ; preds = %32, %22, %2
  %43 = phi i32 [ %41, %32 ], [ 0, %2 ], [ %23, %22 ]
  %44 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 6
  br label %45

; <label>:45:                                     ; preds = %48, %42
  %46 = phi i32 [ %43, %42 ], [ %55, %48 ]
  %47 = icmp ult i32 %46, %7
  br i1 %47, label %48, label %66

; <label>:48:                                     ; preds = %45
  %49 = load %struct.TValue*, %struct.TValue** %44, align 8, !tbaa !137
  %50 = zext i32 %46 to i64
  %51 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 %50, i32 1
  %52 = load i8, i8* %51, align 8, !tbaa !22
  %53 = and i8 %52, 15
  %54 = icmp eq i8 %53, 0
  %55 = add i32 %46, 1
  br i1 %54, label %45, label %56

; <label>:56:                                     ; preds = %48
  %57 = zext i32 %46 to i64
  %58 = zext i32 %55 to i64
  %59 = bitcast %union.StackValue* %6 to i64*
  store i64 %58, i64* %59, align 8, !tbaa !21
  store i8 35, i8* %9, align 8, !tbaa !22
  %60 = load %struct.TValue*, %struct.TValue** %44, align 8, !tbaa !137
  %61 = getelementptr inbounds %struct.TValue, %struct.TValue* %60, i64 %57
  %62 = bitcast %struct.TValue* %61 to i64*
  %63 = bitcast %union.StackValue* %5 to i64*
  %64 = load i64, i64* %62, align 8
  store i64 %64, i64* %63, align 8
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %60, i64 %57, i32 1
  br label %96

; <label>:66:                                     ; preds = %45
  %67 = sub i32 %46, %7
  %68 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 4
  %69 = load i8, i8* %68, align 1, !tbaa !148
  %70 = zext i8 %69 to i32
  %71 = shl i32 1, %70
  %72 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 7
  br label %73

; <label>:73:                                     ; preds = %76, %66
  %74 = phi i32 [ %67, %66 ], [ %83, %76 ]
  %75 = icmp slt i32 %74, %71
  br i1 %75, label %76, label %100

; <label>:76:                                     ; preds = %73
  %77 = load %union.Node*, %union.Node** %72, align 8, !tbaa !147
  %78 = zext i32 %74 to i64
  %79 = getelementptr inbounds %union.Node, %union.Node* %77, i64 %78, i32 0, i32 1
  %80 = load i8, i8* %79, align 8, !tbaa !21
  %81 = and i8 %80, 15
  %82 = icmp eq i8 %81, 0
  %83 = add i32 %74, 1
  br i1 %82, label %73, label %84

; <label>:84:                                     ; preds = %76
  %85 = zext i32 %74 to i64
  %86 = getelementptr inbounds %union.Node, %union.Node* %77, i64 %85, i32 0, i32 4
  %87 = bitcast %union.Value* %86 to i64*
  %88 = bitcast %union.StackValue* %6 to i64*
  %89 = load i64, i64* %87, align 8
  store i64 %89, i64* %88, align 8
  %90 = getelementptr inbounds %union.Node, %union.Node* %77, i64 %85, i32 0, i32 2
  %91 = load i8, i8* %90, align 1, !tbaa !21
  store i8 %91, i8* %9, align 8, !tbaa !22
  %92 = getelementptr inbounds %union.Node, %union.Node* %77, i64 %85, i32 0, i32 0
  %93 = bitcast %union.Value* %92 to i64*
  %94 = bitcast %union.StackValue* %5 to i64*
  %95 = load i64, i64* %93, align 8
  store i64 %95, i64* %94, align 8
  br label %96

; <label>:96:                                     ; preds = %56, %84
  %97 = phi i8* [ %65, %56 ], [ %79, %84 ]
  %98 = load i8, i8* %97, align 8, !tbaa !22
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 0, i32 0, i32 1
  store i8 %98, i8* %99, align 8, !tbaa !22
  br label %100

; <label>:100:                                    ; preds = %73, %96
  %101 = phi i64 [ 1, %96 ], [ -1, %73 ]
  %102 = phi i32 [ 1, %96 ], [ 0, %73 ]
  %103 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %104 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 %101
  store %union.StackValue* %104, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 %102
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_toclose(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !49
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 6
  %7 = load i16, i16* %6, align 4, !tbaa !62
  tail call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* %3) #16
  %8 = icmp slt i16 %7, -1
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %2
  %10 = sub i16 -3, %7
  %11 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !49
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 6
  store i16 %10, i16* %12, align 4, !tbaa !62
  br label %13

; <label>:13:                                     ; preds = %9, %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaF_newtbcupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = bitcast %union.StackValue* %1 to i8*
  %4 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @trynewtbcupval, i8* %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %25, label %6, !prof !70

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %9, i64 0, i32 39
  %11 = load %struct.TString*, %struct.TString** %10, align 8, !tbaa !71
  %12 = bitcast %union.StackValue* %7 to %struct.TString**
  store %struct.TString* %11, %struct.TString** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !72
  %15 = or i8 %14, 64
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1, i32 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 2
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %17, %union.StackValue** %18, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  %21 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* %0, %struct.TValue* %19, %struct.TValue* nonnull %20) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %24, label %23

; <label>:23:                                     ; preds = %6
  tail call void @callclose(%struct.lua_State* nonnull %0, i8* null) #16
  br label %24

; <label>:24:                                     ; preds = %6, %23
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:25:                                     ; preds = %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_concat(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, 1
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %1) #16
  br label %19

; <label>:5:                                      ; preds = %2
  %6 = icmp eq i32 %1, 0
  br i1 %6, label %7, label %19

; <label>:7:                                      ; preds = %5
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64 0) #16
  %12 = bitcast %struct.TValue* %10 to %struct.TString**
  store %struct.TString* %11, %struct.TString** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !72
  %15 = or i8 %14, 64
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %8, align 8, !tbaa !20
  br label %19

; <label>:19:                                     ; preds = %5, %7, %4
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = icmp sgt i64 %23, 0
  br i1 %24, label %25, label %26

; <label>:25:                                     ; preds = %19
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %26

; <label>:26:                                     ; preds = %25, %19
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaV_concat(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [40 x i8], align 16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = getelementptr inbounds [40 x i8], [40 x i8]* %3, i64 0, i64 0
  %6 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  br label %7

; <label>:7:                                      ; preds = %121, %2
  %8 = phi %union.StackValue* [ %6, %2 ], [ %128, %121 ]
  %9 = phi i32 [ %1, %2 ], [ %124, %121 ]
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -2
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -2, i32 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = and i8 %13, 15
  %15 = add nsw i8 %14, -3
  %16 = icmp ult i8 %15, 2
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  br i1 %16, label %18, label %24

; <label>:18:                                     ; preds = %7
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !21
  %21 = trunc i8 %20 to i4
  switch i4 %21, label %24 [
    i4 4, label %25
    i4 3, label %22
  ]

; <label>:22:                                     ; preds = %18
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %17) #16
  %23 = load i8, i8* %19, align 8, !tbaa !21
  br label %25

; <label>:24:                                     ; preds = %7, %18
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %11, %struct.TValue* nonnull %17, %union.StackValue* nonnull %10, i32 22) #16
  br label %121

; <label>:25:                                     ; preds = %18, %22
  %26 = phi i8 [ %20, %18 ], [ %23, %22 ]
  %27 = icmp eq i8 %26, 84
  br i1 %27, label %28, label %39

; <label>:28:                                     ; preds = %25
  %29 = bitcast %struct.TValue* %17 to %struct.TString**
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.TString, %struct.TString* %30, i64 0, i32 4
  %32 = load i8, i8* %31, align 1, !tbaa !21
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %39

; <label>:34:                                     ; preds = %28
  %35 = load i8, i8* %12, align 8, !tbaa !21
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 3
  br i1 %37, label %38, label %121

; <label>:38:                                     ; preds = %34
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %11) #16
  br label %121

; <label>:39:                                     ; preds = %28, %25
  %40 = load i8, i8* %12, align 8, !tbaa !21
  %41 = icmp eq i8 %40, 84
  br i1 %41, label %42, label %52

; <label>:42:                                     ; preds = %39
  %43 = bitcast %union.StackValue* %10 to %struct.TString**
  %44 = load %struct.TString*, %struct.TString** %43, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 4
  %46 = load i8, i8* %45, align 1, !tbaa !21
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %48, label %52

; <label>:48:                                     ; preds = %42
  %49 = bitcast %struct.TValue* %17 to i64*
  %50 = bitcast %union.StackValue* %10 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  store i8 %26, i8* %12, align 8, !tbaa !22
  br label %121

; <label>:52:                                     ; preds = %42, %39
  %53 = bitcast %struct.TValue* %17 to %struct.TString**
  %54 = load %struct.TString*, %struct.TString** %53, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !21
  %57 = icmp eq i8 %56, 20
  br i1 %57, label %58, label %62

; <label>:58:                                     ; preds = %52
  %59 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 4
  %60 = load i8, i8* %59, align 1, !tbaa !21
  %61 = zext i8 %60 to i64
  br label %65

; <label>:62:                                     ; preds = %52
  %63 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 6, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !21
  br label %65

; <label>:65:                                     ; preds = %62, %58
  %66 = phi i64 [ %61, %58 ], [ %64, %62 ]
  %67 = sext i32 %9 to i64
  br label %68

; <label>:68:                                     ; preds = %99, %65
  %69 = phi i64 [ %101, %99 ], [ 1, %65 ]
  %70 = phi i64 [ %100, %99 ], [ %66, %65 ]
  %71 = icmp slt i64 %69, %67
  br i1 %71, label %72, label %102

; <label>:72:                                     ; preds = %68
  %73 = sub nsw i64 0, %69
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %73
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %74, i64 -1
  %76 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 0, i32 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !21
  %78 = trunc i8 %77 to i4
  switch i4 %78, label %102 [
    i4 4, label %81
    i4 3, label %79
  ]

; <label>:79:                                     ; preds = %72
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 0, i32 0
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %80) #16
  br label %81

; <label>:81:                                     ; preds = %72, %79
  %82 = bitcast %union.StackValue* %75 to %struct.TString**
  %83 = load %struct.TString*, %struct.TString** %82, align 8, !tbaa !21
  %84 = getelementptr inbounds %struct.TString, %struct.TString* %83, i64 0, i32 1
  %85 = load i8, i8* %84, align 8, !tbaa !21
  %86 = icmp eq i8 %85, 20
  br i1 %86, label %87, label %91

; <label>:87:                                     ; preds = %81
  %88 = getelementptr inbounds %struct.TString, %struct.TString* %83, i64 0, i32 4
  %89 = load i8, i8* %88, align 1, !tbaa !21
  %90 = zext i8 %89 to i64
  br label %94

; <label>:91:                                     ; preds = %81
  %92 = getelementptr inbounds %struct.TString, %struct.TString* %83, i64 0, i32 6, i32 0
  %93 = load i64, i64* %92, align 8, !tbaa !21
  br label %94

; <label>:94:                                     ; preds = %91, %87
  %95 = phi i64 [ %90, %87 ], [ %93, %91 ]
  %96 = sub i64 9223372036854775807, %70
  %97 = icmp ult i64 %95, %96
  br i1 %97, label %99, label %98, !prof !70

; <label>:98:                                     ; preds = %94
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.281, i64 0, i64 0)) #18
  unreachable

; <label>:99:                                     ; preds = %94
  %100 = add i64 %95, %70
  %101 = add nuw nsw i64 %69, 1
  br label %68

; <label>:102:                                    ; preds = %72, %68
  %103 = trunc i64 %69 to i32
  %104 = icmp ult i64 %70, 41
  br i1 %104, label %105, label %107

; <label>:105:                                    ; preds = %102
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %5) #7
  call fastcc void @copy2buff(%union.StackValue* nonnull %8, i32 %103, i8* nonnull %5) #16
  %106 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %5, i64 %70) #16
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %5) #7
  br label %111

; <label>:107:                                    ; preds = %102
  %108 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %0, i64 %70) #16
  %109 = getelementptr inbounds %struct.TString, %struct.TString* %108, i64 1
  %110 = bitcast %struct.TString* %109 to i8*
  tail call fastcc void @copy2buff(%union.StackValue* nonnull %8, i32 %103, i8* nonnull %110) #16
  br label %111

; <label>:111:                                    ; preds = %107, %105
  %112 = phi %struct.TString* [ %106, %105 ], [ %108, %107 ]
  %113 = and i64 %69, 4294967295
  %114 = sub nsw i64 0, %113
  %115 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %114, i32 0
  %116 = bitcast %struct.TValue* %115 to %struct.TString**
  store %struct.TString* %112, %struct.TString** %116, align 8, !tbaa !21
  %117 = getelementptr inbounds %struct.TString, %struct.TString* %112, i64 0, i32 1
  %118 = load i8, i8* %117, align 8, !tbaa !72
  %119 = or i8 %118, 64
  %120 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %114, i32 0, i32 1
  store i8 %119, i8* %120, align 8, !tbaa !22
  br label %121

; <label>:121:                                    ; preds = %34, %38, %111, %48, %24
  %122 = phi i32 [ 2, %48 ], [ %103, %111 ], [ 2, %24 ], [ 2, %34 ], [ 2, %38 ]
  %123 = add nsw i32 %122, -1
  %124 = sub nsw i32 %9, %123
  %125 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %126 = sext i32 %123 to i64
  %127 = sub nsw i64 0, %126
  %128 = getelementptr inbounds %union.StackValue, %union.StackValue* %125, i64 %127
  store %union.StackValue* %128, %union.StackValue** %4, align 8, !tbaa !20
  %129 = icmp sgt i32 %124, 1
  br i1 %129, label %7, label %130

; <label>:130:                                    ; preds = %121
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  tail call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %5, %struct.TValue* %3) #16
  %6 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaV_objlen(%struct.lua_State*, %union.StackValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %44 [
    i6 5, label %7
    i6 20, label %29
    i6 -28, label %37
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %2 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !149
  %12 = icmp eq %struct.Table* %11, null
  br i1 %12, label %25, label %13

; <label>:13:                                     ; preds = %7
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %11, i64 0, i32 3
  %15 = load i8, i8* %14, align 2, !tbaa !131
  %16 = and i8 %15, 16
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %13
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %20 = load %struct.global_State*, %struct.global_State** %19, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 40, i64 4
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !39
  %23 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %11, i32 4, %struct.TString* %22) #16
  %24 = icmp eq %struct.TValue* %23, null
  br i1 %24, label %25, label %51

; <label>:25:                                     ; preds = %13, %7, %18
  %26 = tail call fastcc i64 @luaH_getn(%struct.Table* %9) #16
  %27 = bitcast %union.StackValue* %1 to i64*
  store i64 %26, i64* %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %28, align 8, !tbaa !22
  br label %53

; <label>:29:                                     ; preds = %3
  %30 = bitcast %struct.TValue* %2 to %struct.TString**
  %31 = load %struct.TString*, %struct.TString** %30, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.TString, %struct.TString* %31, i64 0, i32 4
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = zext i8 %33 to i64
  %35 = bitcast %union.StackValue* %1 to i64*
  store i64 %34, i64* %35, align 8, !tbaa !21
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %36, align 8, !tbaa !22
  br label %53

; <label>:37:                                     ; preds = %3
  %38 = bitcast %struct.TValue* %2 to %struct.TString**
  %39 = load %struct.TString*, %struct.TString** %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TString, %struct.TString* %39, i64 0, i32 6, i32 0
  %41 = load i64, i64* %40, align 8, !tbaa !21
  %42 = bitcast %union.StackValue* %1 to i64*
  store i64 %41, i64* %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %43, align 8, !tbaa !22
  br label %53

; <label>:44:                                     ; preds = %3
  %45 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* nonnull %2, i32 4) #16
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %50, label %51, !prof !47

; <label>:50:                                     ; preds = %44
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* nonnull %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.282, i64 0, i64 0)) #18
  unreachable

; <label>:51:                                     ; preds = %18, %44
  %52 = phi %struct.TValue* [ %45, %44 ], [ %23, %18 ]
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %52, %struct.TValue* nonnull %2, %struct.TValue* nonnull %2, %union.StackValue* %1) #16
  br label %53

; <label>:53:                                     ; preds = %25, %51, %37, %29
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i8* (i8*, i8*, i64, i64)* @lua_getallocf(%struct.lua_State* nocapture readonly, i8**) local_unnamed_addr #2 {
  %3 = icmp eq i8** %1, null
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br i1 %3, label %11, label %5

; <label>:5:                                      ; preds = %2
  %6 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %8 = bitcast i8** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !46
  %10 = bitcast i8** %1 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !39
  br label %11

; <label>:11:                                     ; preds = %2, %5
  %12 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 0
  %14 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %13, align 8, !tbaa !45
  ret i8* (i8*, i8*, i64, i64)* %14
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_setallocf(%struct.lua_State* nocapture readonly, i8* (i8*, i8*, i64, i64)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  store i8* %2, i8** %6, align 8, !tbaa !46
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  store i8* (i8*, i8*, i64, i64)* %1, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !45
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @lua_setwarnf(%struct.lua_State* nocapture readonly, void (i8*, i8*, i32)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  store i8* %2, i8** %6, align 8, !tbaa !186
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  store void (i8*, i8*, i32)* %1, void (i8*, i8*, i32)** %7, align 8, !tbaa !187
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_warning(%struct.lua_State* nocapture readonly, i8*, i32) local_unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  %7 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %6, align 8, !tbaa !187
  %8 = icmp eq void (i8*, i8*, i32)* %7, null
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  %11 = load i8*, i8** %10, align 8, !tbaa !186
  tail call void %7(i8* %11, i8* %1, i32 %2) #17
  br label %12

; <label>:12:                                     ; preds = %3, %9
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define nonnull i8* @lua_newuserdatauv(%struct.lua_State*, i64, i32) local_unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %3
  %6 = sext i32 %2 to i64
  %7 = shl nsw i64 %6, 4
  %8 = sub i64 9223372036854775767, %7
  br label %9

; <label>:9:                                      ; preds = %5, %3
  %10 = phi i64 [ %8, %5 ], [ 9223372036854775775, %3 ]
  %11 = icmp ult i64 %10, %1
  br i1 %11, label %12, label %13, !prof !47

; <label>:12:                                     ; preds = %9
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #19
  unreachable

; <label>:13:                                     ; preds = %9
  br i1 %4, label %18, label %14

; <label>:14:                                     ; preds = %13
  %15 = sext i32 %2 to i64
  %16 = shl nsw i64 %15, 4
  %17 = add nsw i64 %16, 40
  br label %18

; <label>:18:                                     ; preds = %14, %13
  %19 = phi i64 [ %15, %14 ], [ 0, %13 ]
  %20 = phi i64 [ %17, %14 ], [ 32, %13 ]
  %21 = add i64 %20, %1
  %22 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 7, i64 %21) #17
  %23 = bitcast %struct.GCObject* %22 to %struct.Udata*
  %24 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %22, i64 1
  %25 = bitcast %struct.GCObject* %24 to i64*
  store i64 %1, i64* %25, align 8, !tbaa !188
  %26 = trunc i32 %2 to i16
  %27 = getelementptr inbounds %struct.Udata, %struct.Udata* %23, i64 0, i32 3
  store i16 %26, i16* %27, align 2, !tbaa !190
  %28 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %22, i64 1, i32 1
  %29 = bitcast i8* %28 to %struct.Table**
  store %struct.Table* null, %struct.Table** %29, align 8, !tbaa !191
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %22, i64 2, i32 1
  %31 = bitcast i8* %30 to [1 x %union.UValue]*
  br label %32

; <label>:32:                                     ; preds = %35, %18
  %33 = phi i64 [ %37, %35 ], [ 0, %18 ]
  %34 = icmp slt i64 %33, %19
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %32
  %36 = getelementptr inbounds [1 x %union.UValue], [1 x %union.UValue]* %31, i64 0, i64 %33, i32 0, i32 1
  store i8 0, i8* %36, align 8, !tbaa !21
  %37 = add nuw nsw i64 %33, 1
  br label %32

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %40 = bitcast %union.StackValue** %39 to %struct.TValue**
  %41 = load %struct.TValue*, %struct.TValue** %40, align 8, !tbaa !20
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %41, i64 0, i32 0, i32 0
  store %struct.GCObject* %22, %struct.GCObject** %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %41, i64 0, i32 1
  store i8 71, i8* %43, align 8, !tbaa !22
  %44 = load %union.StackValue*, %union.StackValue** %39, align 8, !tbaa !20
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 1
  store %union.StackValue* %45, %union.StackValue** %39, align 8, !tbaa !20
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %47 = load %struct.global_State*, %struct.global_State** %46, align 8, !tbaa !2
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %47, i64 0, i32 3
  %49 = load i64, i64* %48, align 8, !tbaa !11
  %50 = icmp sgt i64 %49, 0
  br i1 %50, label %51, label %52

; <label>:51:                                     ; preds = %38
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %52

; <label>:52:                                     ; preds = %51, %38
  %53 = bitcast %struct.GCObject* %22 to i8*
  %54 = load i16, i16* %27, align 2, !tbaa !190
  %55 = icmp eq i16 %54, 0
  %56 = zext i16 %54 to i64
  %57 = shl nuw nsw i64 %56, 4
  %58 = add nuw nsw i64 %57, 40
  %59 = select i1 %55, i64 32, i64 %58
  %60 = getelementptr inbounds i8, i8* %53, i64 %59
  ret i8* %60
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_getupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !39
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = call fastcc i8* @aux_upvalue(%struct.TValue* %6, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** null) #16
  %8 = icmp eq i8* %7, null
  br i1 %8, label %22, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !39
  %14 = bitcast %struct.TValue* %13 to i64*
  %15 = bitcast %struct.TValue* %12 to i64*
  %16 = load i64, i64* %14, align 8
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %18, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %10, align 8, !tbaa !20
  br label %22

; <label>:22:                                     ; preds = %3, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %7
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i8* @aux_upvalue(%struct.TValue* nocapture readonly, i32, %struct.TValue** nocapture, %struct.GCObject**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %53 [
    i6 -10, label %8
    i6 22, label %22
  ]

; <label>:8:                                      ; preds = %4
  %9 = bitcast %struct.TValue* %0 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = add i32 %1, -1
  %12 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 3
  %13 = load i8, i8* %12, align 2, !tbaa !125
  %14 = zext i8 %13 to i32
  %15 = icmp ult i32 %11, %14
  br i1 %15, label %16, label %53

; <label>:16:                                     ; preds = %8
  %17 = sext i32 %11 to i64
  %18 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 6, i64 %17
  store %struct.TValue* %18, %struct.TValue** %2, align 8, !tbaa !39
  %19 = icmp eq %struct.GCObject** %3, null
  br i1 %19, label %53, label %20

; <label>:20:                                     ; preds = %16
  %21 = bitcast %struct.GCObject** %3 to %struct.CClosure**
  store %struct.CClosure* %10, %struct.CClosure** %21, align 8, !tbaa !39
  br label %53

; <label>:22:                                     ; preds = %4
  %23 = bitcast %struct.TValue* %0 to %struct.LClosure**
  %24 = load %struct.LClosure*, %struct.LClosure** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 5
  %26 = load %struct.Proto*, %struct.Proto** %25, align 8, !tbaa !192
  %27 = add i32 %1, -1
  %28 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 6
  %29 = load i32, i32* %28, align 8, !tbaa !185
  %30 = icmp ult i32 %27, %29
  br i1 %30, label %31, label %53

; <label>:31:                                     ; preds = %22
  %32 = sext i32 %27 to i64
  %33 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 6, i64 %32
  %34 = load %struct.UpVal*, %struct.UpVal** %33, align 8, !tbaa !39
  %35 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %34, i64 0, i32 3
  %36 = bitcast %struct.TValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !64
  %38 = bitcast %struct.TValue** %2 to i64*
  store i64 %37, i64* %38, align 8, !tbaa !39
  %39 = icmp eq %struct.GCObject** %3, null
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %31
  %41 = bitcast %struct.UpVal** %33 to i64*
  %42 = load i64, i64* %41, align 8, !tbaa !39
  %43 = bitcast %struct.GCObject** %3 to i64*
  store i64 %42, i64* %43, align 8, !tbaa !39
  br label %44

; <label>:44:                                     ; preds = %31, %40
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 18
  %46 = load %struct.Upvaldesc*, %struct.Upvaldesc** %45, align 8, !tbaa !193
  %47 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %46, i64 %32, i32 0
  %48 = load %struct.TString*, %struct.TString** %47, align 8, !tbaa !194
  %49 = icmp eq %struct.TString* %48, null
  %50 = getelementptr inbounds %struct.TString, %struct.TString* %48, i64 1
  %51 = bitcast %struct.TString* %50 to i8*
  %52 = select i1 %49, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.283, i64 0, i64 0), i8* %51
  br label %53

; <label>:53:                                     ; preds = %4, %44, %22, %8, %16, %20
  %54 = phi i8* [ null, %8 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %16 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %20 ], [ %52, %44 ], [ null, %22 ], [ null, %4 ]
  ret i8* %54
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @lua_setupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = alloca %struct.GCObject*, align 8
  %6 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !39
  %7 = bitcast %struct.GCObject** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  store %struct.GCObject* null, %struct.GCObject** %5, align 8, !tbaa !39
  %8 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %9 = call fastcc i8* @aux_upvalue(%struct.TValue* %8, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** nonnull %5) #16
  %10 = icmp eq i8* %9, null
  br i1 %10, label %37, label %11

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1
  store %union.StackValue* %14, %union.StackValue** %12, align 8, !tbaa !20
  %15 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !39
  %16 = bitcast %union.StackValue* %14 to i64*
  %17 = bitcast %struct.TValue* %15 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = and i8 %20, 64
  %23 = icmp eq i8 %22, 0
  %24 = inttoptr i64 %18 to %struct.GCObject*
  br i1 %23, label %37, label %25

; <label>:25:                                     ; preds = %11
  %26 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !39
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !67
  %29 = and i8 %28, 32
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %37, label %31

; <label>:31:                                     ; preds = %25
  %32 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %24, i64 0, i32 2
  %33 = load i8, i8* %32, align 1, !tbaa !67
  %34 = and i8 %33, 24
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %37, label %36

; <label>:36:                                     ; preds = %31
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %26, %struct.GCObject* nonnull %24) #16
  br label %37

; <label>:37:                                     ; preds = %31, %25, %11, %3, %36
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i8* %9
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define i8* @lua_upvalueid(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %19 [
    i6 22, label %8
    i6 -10, label %12
  ]

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %1, i32 %2, %struct.LClosure** null) #16
  %10 = bitcast %struct.UpVal** %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !39
  br label %19

; <label>:12:                                     ; preds = %3
  %13 = bitcast %struct.TValue* %4 to %struct.CClosure**
  %14 = load %struct.CClosure*, %struct.CClosure** %13, align 8, !tbaa !21
  %15 = add nsw i32 %2, -1
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %14, i64 0, i32 6, i64 %16
  %18 = bitcast %struct.TValue* %17 to i8*
  br label %19

; <label>:19:                                     ; preds = %3, %12, %8
  %20 = phi i8* [ %18, %12 ], [ %11, %8 ], [ null, %3 ]
  ret i8* %20
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc nonnull %struct.UpVal** @getupvalref(%struct.lua_State* nocapture readonly, i32, i32, %struct.LClosure**) unnamed_addr #2 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = bitcast %struct.TValue* %5 to %struct.LClosure**
  %7 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !21
  %8 = icmp eq %struct.LClosure** %3, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %4
  store %struct.LClosure* %7, %struct.LClosure** %3, align 8, !tbaa !39
  br label %10

; <label>:10:                                     ; preds = %4, %9
  %11 = add nsw i32 %2, -1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 6, i64 %12
  ret %struct.UpVal** %13
}

; Function Attrs: minsize nounwind optsize uwtable
define void @lua_upvaluejoin(%struct.lua_State* nocapture readonly, i32, i32, i32, i32) local_unnamed_addr #0 {
  %6 = alloca %struct.LClosure*, align 8
  %7 = bitcast %struct.LClosure** %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %1, i32 %2, %struct.LClosure** nonnull %6) #16
  %9 = call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %3, i32 %4, %struct.LClosure** null) #16
  %10 = load %struct.UpVal*, %struct.UpVal** %9, align 8, !tbaa !39
  store %struct.UpVal* %10, %struct.UpVal** %8, align 8, !tbaa !39
  %11 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !39
  %12 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %11, i64 0, i32 2
  %13 = load i8, i8* %12, align 1, !tbaa !196
  %14 = and i8 %13, 32
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %24, label %16

; <label>:16:                                     ; preds = %5
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %10, i64 0, i32 2
  %18 = load i8, i8* %17, align 1, !tbaa !66
  %19 = and i8 %18, 24
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %24, label %21

; <label>:21:                                     ; preds = %16
  %22 = bitcast %struct.LClosure* %11 to %struct.GCObject*
  %23 = bitcast %struct.UpVal* %10 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %22, %struct.GCObject* %23) #16
  br label %24

; <label>:24:                                     ; preds = %16, %5, %21
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_traceback(%struct.lua_State*, %struct.lua_State*, i8*, i32) local_unnamed_addr #0 {
  %5 = alloca %struct.lua_Debug, align 8
  %6 = alloca %struct.lua_Debug, align 8
  %7 = bitcast %struct.lua_Debug* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = bitcast %struct.lua_Debug* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %19) #7
  br label %20

; <label>:20:                                     ; preds = %20, %4
  %21 = phi i32 [ 1, %4 ], [ %25, %20 ]
  %22 = phi i32 [ 1, %4 ], [ %21, %20 ]
  %23 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %21, %struct.lua_Debug* nonnull %5) #17
  %24 = icmp eq i32 %23, 0
  %25 = shl nsw i32 %21, 1
  br i1 %24, label %26, label %20

; <label>:26:                                     ; preds = %20
  %27 = trunc i64 %18 to i32
  br label %28

; <label>:28:                                     ; preds = %32, %26
  %29 = phi i32 [ %21, %26 ], [ %38, %32 ]
  %30 = phi i32 [ %22, %26 ], [ %39, %32 ]
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %32, label %40

; <label>:32:                                     ; preds = %28
  %33 = add nsw i32 %30, %29
  %34 = sdiv i32 %33, 2
  %35 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %34, %struct.lua_Debug* nonnull %5) #17
  %36 = icmp eq i32 %35, 0
  %37 = add nsw i32 %34, 1
  %38 = select i1 %36, i32 %34, i32 %29
  %39 = select i1 %36, i32 %30, i32 %37
  br label %28

; <label>:40:                                     ; preds = %28
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %19) #7
  %41 = xor i32 %3, -1
  %42 = add i32 %29, %41
  %43 = icmp sgt i32 %42, 21
  %44 = select i1 %43, i32 10, i32 -1
  %45 = icmp eq i8* %2, null
  br i1 %45, label %48, label %46

; <label>:46:                                     ; preds = %40
  %47 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* nonnull %2) #16
  br label %48

; <label>:48:                                     ; preds = %40, %46
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 10, i8* null) #16
  %49 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.8, i64 0, i64 0)) #16
  %50 = add nsw i32 %29, -12
  %51 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 15, i64 0
  %52 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 6
  %53 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 2
  %54 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 12
  %55 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 3
  %56 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 1
  %57 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 7
  br label %58

; <label>:58:                                     ; preds = %115, %48
  %59 = phi i32 [ %3, %48 ], [ %117, %115 ]
  %60 = phi i32 [ %44, %48 ], [ %64, %115 ]
  %61 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %59, %struct.lua_Debug* nonnull %6) #16
  %62 = icmp eq i32 %61, 0
  br i1 %62, label %118, label %63

; <label>:63:                                     ; preds = %58
  %64 = add nsw i32 %60, -1
  %65 = icmp eq i32 %60, 0
  br i1 %65, label %66, label %68

; <label>:66:                                     ; preds = %63
  %67 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i64 0, i64 0)) #16
  br label %115

; <label>:68:                                     ; preds = %63
  %69 = call i32 @lua_getinfo(%struct.lua_State* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i64 0, i64 0), %struct.lua_Debug* nonnull %6) #16
  %70 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i64 0, i64 0), i8* nonnull %51) #16
  %71 = load i32, i32* %52, align 8, !tbaa !113
  %72 = icmp sgt i32 %71, 0
  br i1 %72, label %73, label %75

; <label>:73:                                     ; preds = %68
  %74 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i64 0, i64 0), i32 %71) #16
  br label %75

; <label>:75:                                     ; preds = %73, %68
  %76 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i64 0, i64 0)) #16
  %77 = call fastcc i32 @pushglobalfuncname(%struct.lua_State* %0, %struct.lua_Debug* nonnull %6) #17
  %78 = icmp eq i32 %77, 0
  br i1 %78, label %82, label %79

; <label>:79:                                     ; preds = %75
  %80 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %81 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.284, i64 0, i64 0), i8* %80) #17
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  br label %99

; <label>:82:                                     ; preds = %75
  %83 = load i8*, i8** %53, align 8, !tbaa !120
  %84 = load i8, i8* %83, align 1, !tbaa !21
  %85 = icmp eq i8 %84, 0
  br i1 %85, label %89, label %86

; <label>:86:                                     ; preds = %82
  %87 = load i8*, i8** %56, align 8, !tbaa !197
  %88 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.285, i64 0, i64 0), i8* %83, i8* %87) #17
  br label %99

; <label>:89:                                     ; preds = %82
  %90 = load i8*, i8** %55, align 8, !tbaa !112
  %91 = load i8, i8* %90, align 1, !tbaa !21
  switch i8 %91, label %94 [
    i8 109, label %92
    i8 67, label %97
  ]

; <label>:92:                                     ; preds = %89
  %93 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.286, i64 0, i64 0)) #17
  br label %99

; <label>:94:                                     ; preds = %89
  %95 = load i32, i32* %57, align 4, !tbaa !106
  %96 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.287, i64 0, i64 0), i8* nonnull %51, i32 %95) #17
  br label %99

; <label>:97:                                     ; preds = %89
  %98 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0)) #17
  br label %99

; <label>:99:                                     ; preds = %79, %86, %92, %94, %97
  %100 = load i8, i8* %54, align 1, !tbaa !118
  %101 = icmp eq i8 %100, 0
  br i1 %101, label %104, label %102

; <label>:102:                                    ; preds = %99
  %103 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.14, i64 0, i64 0)) #16
  br label %104

; <label>:104:                                    ; preds = %99, %102
  %105 = load i64, i64* %9, align 8, !tbaa !20
  %106 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %107 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %106, i64 0, i32 0
  %108 = load %union.StackValue*, %union.StackValue** %107, align 8, !tbaa !61
  %109 = getelementptr inbounds %union.StackValue, %union.StackValue* %108, i64 1
  %110 = ptrtoint %union.StackValue* %109 to i64
  %111 = sub i64 %105, %110
  %112 = lshr exact i64 %111, 4
  %113 = trunc i64 %112 to i32
  %114 = sub nsw i32 %113, %27
  call void @lua_concat(%struct.lua_State* %0, i32 %114) #16
  br label %115

; <label>:115:                                    ; preds = %104, %66
  %116 = phi i32 [ %50, %66 ], [ %59, %104 ]
  %117 = add nsw i32 %116, 1
  br label %58

; <label>:118:                                    ; preds = %58
  %119 = load i64, i64* %9, align 8, !tbaa !20
  %120 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %121 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %120, i64 0, i32 0
  %122 = load %union.StackValue*, %union.StackValue** %121, align 8, !tbaa !61
  %123 = getelementptr inbounds %union.StackValue, %union.StackValue* %122, i64 1
  %124 = ptrtoint %union.StackValue* %123 to i64
  %125 = sub i64 %119, %124
  %126 = lshr exact i64 %125, 4
  %127 = trunc i64 %126 to i32
  %128 = sub nsw i32 %127, %27
  call void @lua_concat(%struct.lua_State* %0, i32 %128) #16
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_checkstack(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i8* %2, null
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %6
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i64 0, i64 0), i8* nonnull %2) #16
  unreachable

; <label>:10:                                     ; preds = %6
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_argerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.lua_Debug, align 8
  %5 = bitcast %struct.lua_Debug* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %5) #7
  %6 = call i32 @lua_getstack(%struct.lua_State* %0, i32 0, %struct.lua_Debug* nonnull %4) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15, i64 0, i64 0), i32 %1, i8* %2) #16
  unreachable

; <label>:10:                                     ; preds = %3
  %11 = call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0), %struct.lua_Debug* nonnull %4) #16
  %12 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 2
  %13 = load i8*, i8** %12, align 8, !tbaa !120
  %14 = tail call i32 @strcmp(i8* %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0)) #21
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %10
  %17 = add nsw i32 %1, -1
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %23

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %21 = load i8*, i8** %20, align 8, !tbaa !197
  %22 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.18, i64 0, i64 0), i8* %21, i8* %2) #16
  unreachable

; <label>:23:                                     ; preds = %16, %10
  %24 = phi i32 [ %17, %16 ], [ %1, %10 ]
  %25 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %26 = load i8*, i8** %25, align 8, !tbaa !197
  %27 = icmp eq i8* %26, null
  br i1 %27, label %28, label %35

; <label>:28:                                     ; preds = %23
  %29 = call fastcc i32 @pushglobalfuncname(%struct.lua_State* %0, %struct.lua_Debug* nonnull %4) #16
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %33, label %31

; <label>:31:                                     ; preds = %28
  %32 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  br label %33

; <label>:33:                                     ; preds = %28, %31
  %34 = phi i8* [ %32, %31 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %28 ]
  store i8* %34, i8** %25, align 8, !tbaa !197
  br label %35

; <label>:35:                                     ; preds = %33, %23
  %36 = phi i8* [ %34, %33 ], [ %26, %23 ]
  %37 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.19, i64 0, i64 0), i32 %24, i8* %36, i8* %2) #16
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define i32 @luaL_error(%struct.lua_State*, i8*, ...) local_unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  call void @luaL_where(%struct.lua_State* %0, i32 1) #16
  %6 = call i8* @lua_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  call void @lua_concat(%struct.lua_State* %0, i32 2) #16
  %7 = call i32 @lua_error(%struct.lua_State* %0) #16
  unreachable
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @pushglobalfuncname(%struct.lua_State*, %struct.lua_Debug* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = tail call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.288, i64 0, i64 0), %struct.lua_Debug* %1) #16
  %16 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  %17 = add nsw i32 %14, 1
  %18 = tail call fastcc i32 @findfield(%struct.lua_State* %0, i32 %17, i32 2) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %2
  %21 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  %22 = tail call i32 @strncmp(i8* %21, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.289, i64 0, i64 0), i64 3) #21
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %27

; <label>:24:                                     ; preds = %20
  %25 = getelementptr inbounds i8, i8* %21, i64 3
  %26 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* nonnull %25) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  br label %27

; <label>:27:                                     ; preds = %24, %20
  tail call void @lua_copy(%struct.lua_State* nonnull %0, i32 -1, i32 %17) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 -3) #16
  br label %29

; <label>:28:                                     ; preds = %2
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 %14) #16
  br label %29

; <label>:29:                                     ; preds = %28, %27
  %30 = phi i32 [ 1, %27 ], [ 0, %28 ]
  ret i32 %30
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_typeerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %5 = icmp eq i32 %4, 4
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  br label %16

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %10 = icmp eq i32 %9, 2
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %8
  %12 = add nsw i32 %9, 1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %13
  %15 = load i8*, i8** %14, align 8, !tbaa !39
  br label %16

; <label>:16:                                     ; preds = %8, %11, %6
  %17 = phi i8* [ %7, %6 ], [ %15, %11 ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i64 0, i64 0), %8 ]
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.22, i64 0, i64 0), i8* %2, i8* %17) #16
  %19 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %18) #16
  ret i32 %19
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_getmetafield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %12, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2) #16
  %8 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %6
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3) #16
  br label %12

; <label>:11:                                     ; preds = %6
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %12

; <label>:12:                                     ; preds = %10, %11, %3
  %13 = phi i32 [ 0, %3 ], [ %8, %11 ], [ 0, %10 ]
  ret i32 %13
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_where(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %4) #7
  %5 = call i32 @lua_getstack(%struct.lua_State* %0, i32 %1, %struct.lua_Debug* nonnull %3) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i64 0, i64 0), %struct.lua_Debug* nonnull %3) #16
  %9 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 6
  %10 = load i32, i32* %9, align 8, !tbaa !113
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %12, label %15

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 15, i64 0
  %14 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24, i64 0, i64 0), i8* nonnull %13, i32 %10) #16
  br label %17

; <label>:15:                                     ; preds = %2, %7
  %16 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %17

; <label>:17:                                     ; preds = %15, %12
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %4) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_fileresult(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #22
  %5 = load i32, i32* %4, align 4, !tbaa !74
  %6 = icmp eq i32 %1, 0
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  br i1 %6, label %12, label %10

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %9 to i32*
  store i32 1, i32* %11, align 8, !tbaa !21
  br label %26

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %7, align 8, !tbaa !20
  %16 = icmp eq i8* %2, null
  %17 = tail call i8* @strerror(i32 %5) #17
  br i1 %16, label %20, label %18

; <label>:18:                                     ; preds = %12
  %19 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25, i64 0, i64 0), i8* nonnull %2, i8* %17) #16
  br label %22

; <label>:20:                                     ; preds = %12
  %21 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %17) #16
  br label %22

; <label>:22:                                     ; preds = %20, %18
  %23 = sext i32 %5 to i64
  %24 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i64*
  store i64 %23, i64* %25, align 8, !tbaa !21
  br label %26

; <label>:26:                                     ; preds = %22, %10
  %27 = phi %struct.TValue* [ %24, %22 ], [ %9, %10 ]
  %28 = phi i8 [ 35, %22 ], [ 1, %10 ]
  %29 = phi i32 [ 3, %22 ], [ 1, %10 ]
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  store i8 %28, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 %29
}

; Function Attrs: minsize nounwind optsize readnone
declare i32* @__errno_location() local_unnamed_addr #8

; Function Attrs: minsize nounwind optsize
declare i8* @strerror(i32) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_execresult(%struct.lua_State*, i32) local_unnamed_addr #0 {
  switch i32 %1, label %10 [
    i32 -1, label %3
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %2
  %4 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %29

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32*
  store i32 1, i32* %9, align 8, !tbaa !21
  br label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  br label %14

; <label>:14:                                     ; preds = %10, %5
  %15 = phi %struct.TValue* [ %13, %10 ], [ %8, %5 ]
  %16 = phi i8 [ 0, %10 ], [ 1, %5 ]
  %17 = phi %union.StackValue** [ %11, %10 ], [ %6, %5 ]
  %18 = phi %struct.TValue** [ %12, %10 ], [ %7, %5 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %16, i8* %19, align 8, !tbaa !21
  %20 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %17, align 8, !tbaa !20
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i64 0, i64 0)) #16
  %23 = sext i32 %1 to i64
  %24 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i64*
  store i64 %23, i64* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 35, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %17, align 8, !tbaa !20
  br label %29

; <label>:29:                                     ; preds = %14, %3
  %30 = phi i32 [ %4, %3 ], [ 3, %14 ]
  ret i32 %30
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_newmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 2) #16
  %6 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  br label %7

; <label>:7:                                      ; preds = %2, %5
  %8 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_setmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  %4 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_testudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %6
  %10 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %2) #16
  %11 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, i8* null, i8* %4
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3) #16
  br label %14

; <label>:14:                                     ; preds = %3, %6, %9
  %15 = phi i8* [ %13, %9 ], [ null, %6 ], [ null, %3 ]
  ret i8* %15
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_checkudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 %1, i8* %2) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %2) #16
  br label %8

; <label>:8:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_checkoption(%struct.lua_State*, i32, i8*, i8** nocapture readonly) local_unnamed_addr #0 {
  %5 = icmp eq i8* %2, null
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 %1, i8* nonnull %2, i64* null) #16
  br label %10

; <label>:8:                                      ; preds = %4
  %9 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* null) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  br label %12

; <label>:12:                                     ; preds = %20, %10
  %13 = phi i64 [ %21, %20 ], [ 0, %10 ]
  %14 = getelementptr inbounds i8*, i8** %3, i64 %13
  %15 = load i8*, i8** %14, align 8, !tbaa !39
  %16 = icmp eq i8* %15, null
  br i1 %16, label %22, label %17

; <label>:17:                                     ; preds = %12
  %18 = tail call i32 @strcmp(i8* nonnull %15, i8* %11) #21
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %17
  %21 = add nuw i64 %13, 1
  br label %12

; <label>:22:                                     ; preds = %12
  %23 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.27, i64 0, i64 0), i8* %11) #16
  %24 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %23) #16
  br label %27

; <label>:25:                                     ; preds = %17
  %26 = trunc i64 %13 to i32
  br label %27

; <label>:27:                                     ; preds = %25, %22
  %28 = phi i32 [ %24, %22 ], [ %26, %25 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_optlstring(%struct.lua_State*, i32, i8* readonly, i64*) local_unnamed_addr #0 {
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %6 = icmp slt i32 %5, 1
  br i1 %6, label %7, label %15

; <label>:7:                                      ; preds = %4
  %8 = icmp eq i64* %3, null
  br i1 %8, label %17, label %9

; <label>:9:                                      ; preds = %7
  %10 = icmp eq i8* %2, null
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %9
  %12 = tail call i64 @strlen(i8* nonnull %2) #21
  br label %13

; <label>:13:                                     ; preds = %9, %11
  %14 = phi i64 [ %12, %11 ], [ 0, %9 ]
  store i64 %14, i64* %3, align 8, !tbaa !135
  br label %17

; <label>:15:                                     ; preds = %4
  %16 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* %3) #16
  br label %17

; <label>:17:                                     ; preds = %13, %7, %15
  %18 = phi i8* [ %16, %15 ], [ %2, %7 ], [ %2, %13 ]
  ret i8* %18
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_checklstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* %2) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %3
  tail call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 4) #16
  br label %7

; <label>:7:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_checktype(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, %2
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %3
  tail call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 %2) #16
  br label %7

; <label>:7:                                      ; preds = %3, %6
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @tag_error(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = add nsw i32 %2, 1
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %5
  %7 = load i8*, i8** %6, align 8, !tbaa !39
  %8 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %7) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_checkany(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %7

; <label>:7:                                      ; preds = %5, %2
  ret void
}

; Function Attrs: argmemonly minsize nounwind optsize readonly
declare i64 @strlen(i8* nocapture) local_unnamed_addr #10

; Function Attrs: minsize nounwind optsize uwtable
define double @luaL_checknumber(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* nonnull %3) #16
  %6 = load i32, i32* %3, align 4, !tbaa !74
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %2
  call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 3) #16
  br label %9

; <label>:9:                                      ; preds = %2, %8
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret double %5
}

; Function Attrs: minsize nounwind optsize uwtable
define double @luaL_optnumber(%struct.lua_State*, i32, double) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 %1) #16
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi double [ %7, %6 ], [ %2, %3 ]
  ret double %9
}

; Function Attrs: minsize nounwind optsize uwtable
define i64 @luaL_checkinteger(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* nonnull %3) #16
  %6 = load i32, i32* %3, align 4, !tbaa !74
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %14

; <label>:8:                                      ; preds = %2
  %9 = call i32 @lua_isnumber(%struct.lua_State* %0, i32 %1) #17
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.291, i64 0, i64 0)) #17
  br label %14

; <label>:13:                                     ; preds = %8
  call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 3) #17
  br label %14

; <label>:14:                                     ; preds = %13, %11, %2
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define i64 @luaL_optinteger(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1) #16
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi i64 [ %7, %6 ], [ %2, %3 ]
  ret i64 %9
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_prepbuffsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %1, i32 -1) #16
  ret i8* %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @prepbuffsize(%struct.luaL_Buffer*, i64, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 1
  %5 = load i64, i64* %4, align 8, !tbaa !198
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !200
  %8 = sub i64 %5, %7
  %9 = icmp ult i64 %8, %1
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %12 = load i8*, i8** %11, align 8, !tbaa !201
  %13 = getelementptr inbounds i8, i8* %12, i64 %7
  br label %54

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %16 = load %struct.lua_State*, %struct.lua_State** %15, align 8, !tbaa !202
  %17 = shl i64 %5, 1
  %18 = xor i64 %1, -1
  %19 = icmp ugt i64 %7, %18
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %14
  %21 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %16, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.292, i64 0, i64 0)) #17
  unreachable

; <label>:22:                                     ; preds = %14
  %23 = add i64 %7, %1
  %24 = icmp ult i64 %17, %23
  %25 = select i1 %24, i64 %23, i64 %17
  %26 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %27 = load i8*, i8** %26, align 8, !tbaa !201
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %29 = bitcast %union.anon.6* %28 to i8*
  %30 = icmp eq i8* %27, %29
  br i1 %30, label %33, label %31

; <label>:31:                                     ; preds = %22
  %32 = tail call fastcc i8* @resizebox(%struct.lua_State* %16, i32 %2, i64 %25) #16
  br label %50

; <label>:33:                                     ; preds = %22
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %16, i64 0, i32 6
  %35 = bitcast %union.StackValue** %34 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !20
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  store i8 0, i8* %37, align 8, !tbaa !21
  %38 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 1
  store %union.StackValue* %39, %union.StackValue** %34, align 8, !tbaa !20
  %40 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %16, i64 16, i32 0) #17
  tail call void @llvm.memset.p0i8.i64(i8* nonnull %40, i8 0, i64 16, i32 8, i1 false) #7
  %41 = tail call i32 @luaL_newmetatable(%struct.lua_State* %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.294, i64 0, i64 0)) #17
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %44, label %43

; <label>:43:                                     ; preds = %33
  tail call void @luaL_setfuncs(%struct.lua_State* nonnull %16, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @boxmt, i64 0, i64 0), i32 0) #17
  br label %44

; <label>:44:                                     ; preds = %33, %43
  %45 = tail call i32 @lua_setmetatable(%struct.lua_State* nonnull %16, i32 -2) #17
  %46 = add nsw i32 %2, -1
  tail call void @lua_rotate(%struct.lua_State* nonnull %16, i32 %46, i32 2) #16
  tail call void @lua_toclose(%struct.lua_State* nonnull %16, i32 %2) #16
  %47 = tail call fastcc i8* @resizebox(%struct.lua_State* nonnull %16, i32 %2, i64 %25) #16
  %48 = load i8*, i8** %26, align 8, !tbaa !201
  %49 = load i64, i64* %6, align 8, !tbaa !200
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 %49, i32 1, i1 false)
  br label %50

; <label>:50:                                     ; preds = %44, %31
  %51 = phi i8* [ %32, %31 ], [ %47, %44 ]
  store i8* %51, i8** %26, align 8, !tbaa !201
  store i64 %25, i64* %4, align 8, !tbaa !198
  %52 = load i64, i64* %6, align 8, !tbaa !200
  %53 = getelementptr inbounds i8, i8* %51, i64 %52
  br label %54

; <label>:54:                                     ; preds = %50, %10
  %55 = phi i8* [ %13, %10 ], [ %53, %50 ]
  ret i8* %55
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_addlstring(%struct.luaL_Buffer*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %2, i32 -1) #16
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %1, i64 %2, i32 1, i1 false)
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %8 = load i64, i64* %7, align 8, !tbaa !200
  %9 = add i64 %8, %2
  store i64 %9, i64* %7, align 8, !tbaa !200
  br label %10

; <label>:10:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_addstring(%struct.luaL_Buffer*, i8* nocapture readonly) local_unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %1) #21
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %0, i8* %1, i64 %3) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_pushresult(%struct.luaL_Buffer* readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !202
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %5 = load i8*, i8** %4, align 8, !tbaa !201
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !200
  %8 = tail call i8* @lua_pushlstring(%struct.lua_State* %3, i8* %5, i64 %7) #16
  %9 = load i8*, i8** %4, align 8, !tbaa !201
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %11 = bitcast %union.anon.6* %10 to i8*
  %12 = icmp eq i8* %9, %11
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %1
  tail call void @lua_copy(%struct.lua_State* %3, i32 -1, i32 -3) #16
  tail call void @lua_settop(%struct.lua_State* %3, i32 -3) #16
  br label %14

; <label>:14:                                     ; preds = %1, %13
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_pushresultsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %4 = load i64, i64* %3, align 8, !tbaa !200
  %5 = add i64 %4, %1
  store i64 %5, i64* %3, align 8, !tbaa !200
  tail call void @luaL_pushresult(%struct.luaL_Buffer* %0) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_addvalue(%struct.luaL_Buffer*) local_unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !202
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @lua_tolstring(%struct.lua_State* %4, i32 -1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !135
  %8 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %7, i32 -2) #16
  %9 = load i64, i64* %2, align 8, !tbaa !135
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %6, i64 %9, i32 1, i1 false)
  %10 = load i64, i64* %2, align 8, !tbaa !135
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %12 = load i64, i64* %11, align 8, !tbaa !200
  %13 = add i64 %12, %10
  store i64 %13, i64* %11, align 8, !tbaa !200
  call void @lua_settop(%struct.lua_State* %4, i32 -2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define void @luaL_buffinit(%struct.lua_State*, %struct.luaL_Buffer*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %3, align 8, !tbaa !202
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 4
  %5 = bitcast %struct.luaL_Buffer* %1 to %union.anon.6**
  store %union.anon.6* %4, %union.anon.6** %5, align 8, !tbaa !201
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  %7 = bitcast i64* %6 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %7, align 8, !tbaa !135
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_buffinitsize(%struct.lua_State*, %struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %4, align 8, !tbaa !202
  %5 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 4
  %6 = bitcast %struct.luaL_Buffer* %1 to %union.anon.6**
  store %union.anon.6* %5, %union.anon.6** %6, align 8, !tbaa !201
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  %8 = bitcast i64* %7 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %8, align 8, !tbaa !135
  %9 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %1, i64 %2, i32 -1) #16
  ret i8* %9
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_ref(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %2
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %23

; <label>:6:                                      ; preds = %2
  %7 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1) #16
  %8 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %7, i64 0) #16
  %9 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* null) #16
  %10 = trunc i64 %9 to i32
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %6
  %13 = shl i64 %9, 32
  %14 = ashr exact i64 %13, 32
  %15 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %7, i64 %14) #16
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %7, i64 0) #16
  br label %20

; <label>:16:                                     ; preds = %6
  %17 = tail call i64 @lua_rawlen(%struct.lua_State* %0, i32 %7) #16
  %18 = trunc i64 %17 to i32
  %19 = add nsw i32 %18, 1
  br label %20

; <label>:20:                                     ; preds = %16, %12
  %21 = phi i32 [ %10, %12 ], [ %19, %16 ]
  %22 = sext i32 %21 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %7, i64 %22) #16
  br label %23

; <label>:23:                                     ; preds = %20, %5
  %24 = phi i32 [ -1, %5 ], [ %21, %20 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_unref(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = icmp sgt i32 %2, -1
  br i1 %4, label %5, label %16

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1) #16
  %7 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %6, i64 0) #16
  %8 = sext i32 %2 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %6, i64 %8) #16
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = bitcast %struct.TValue* %11 to i64*
  store i64 %8, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 35, i8* %13, align 8, !tbaa !22
  %14 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %9, align 8, !tbaa !20
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %6, i64 0) #16
  br label %16

; <label>:16:                                     ; preds = %5, %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_loadfilex(%struct.lua_State*, i8*, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.LoadF, align 8
  %5 = alloca i32, align 4
  %6 = bitcast %struct.LoadF* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8208, i8* nonnull %6) #7
  %7 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, 1
  %21 = icmp eq i8* %1, null
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %3
  %23 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0)) #16
  %24 = load i64, i64* bitcast (%struct._IO_FILE** @stdin to i64*), align 8, !tbaa !39
  %25 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %26 = bitcast %struct._IO_FILE** %25 to i64*
  store i64 %24, i64* %26, align 8, !tbaa !203
  br label %33

; <label>:27:                                     ; preds = %3
  %28 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.32, i64 0, i64 0), i8* nonnull %1) #16
  %29 = tail call %struct._IO_FILE* @fopen64(i8* nonnull %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  %30 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  store %struct._IO_FILE* %29, %struct._IO_FILE** %30, align 8, !tbaa !203
  %31 = icmp eq %struct._IO_FILE* %29, null
  br i1 %31, label %32, label %33

; <label>:32:                                     ; preds = %27
  tail call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i64 0, i64 0), i32 %20) #16
  br label %78

; <label>:33:                                     ; preds = %27, %22
  %34 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5) #16
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %42, label %36

; <label>:36:                                     ; preds = %33
  %37 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %38 = load i32, i32* %37, align 8, !tbaa !205
  %39 = add nsw i32 %38, 1
  store i32 %39, i32* %37, align 8, !tbaa !205
  %40 = sext i32 %38 to i64
  %41 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %40
  store i8 10, i8* %41, align 1, !tbaa !21
  br label %42

; <label>:42:                                     ; preds = %33, %36
  %43 = load i32, i32* %5, align 4, !tbaa !74
  %44 = icmp eq i32 %43, 27
  %45 = icmp ne i8* %1, null
  %46 = and i1 %45, %44
  br i1 %46, label %47, label %56

; <label>:47:                                     ; preds = %42
  %48 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %49 = load %struct._IO_FILE*, %struct._IO_FILE** %48, align 8, !tbaa !203
  %50 = tail call %struct._IO_FILE* @freopen64(i8* nonnull %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.36, i64 0, i64 0), %struct._IO_FILE* %49) #17
  store %struct._IO_FILE* %50, %struct._IO_FILE** %48, align 8, !tbaa !203
  %51 = icmp eq %struct._IO_FILE* %50, null
  br i1 %51, label %52, label %53

; <label>:52:                                     ; preds = %47
  tail call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i64 0, i64 0), i32 %20) #16
  br label %78

; <label>:53:                                     ; preds = %47
  %54 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5) #16
  %55 = load i32, i32* %5, align 4, !tbaa !74
  br label %56

; <label>:56:                                     ; preds = %53, %42
  %57 = phi i32 [ %55, %53 ], [ %43, %42 ]
  %58 = icmp eq i32 %57, -1
  br i1 %58, label %66, label %59

; <label>:59:                                     ; preds = %56
  %60 = trunc i32 %57 to i8
  %61 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %62 = load i32, i32* %61, align 8, !tbaa !205
  %63 = add nsw i32 %62, 1
  store i32 %63, i32* %61, align 8, !tbaa !205
  %64 = sext i32 %62 to i64
  %65 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %64
  store i8 %60, i8* %65, align 1, !tbaa !21
  br label %66

; <label>:66:                                     ; preds = %56, %59
  %67 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  %68 = call i32 @lua_load(%struct.lua_State* nonnull %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getF, i8* nonnull %6, i8* %67, i8* %2) #16
  %69 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %70 = load %struct._IO_FILE*, %struct._IO_FILE** %69, align 8, !tbaa !203
  %71 = call i32 @ferror(%struct._IO_FILE* %70) #17
  br i1 %45, label %72, label %74

; <label>:72:                                     ; preds = %66
  %73 = call i32 @fclose(%struct._IO_FILE* %70) #16
  br label %74

; <label>:74:                                     ; preds = %72, %66
  %75 = icmp eq i32 %71, 0
  br i1 %75, label %77, label %76

; <label>:76:                                     ; preds = %74
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 %20) #16
  call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i64 0, i64 0), i32 %20) #16
  br label %78

; <label>:77:                                     ; preds = %74
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 %20, i32 -1) #16
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  br label %78

; <label>:78:                                     ; preds = %77, %76, %52, %32
  %79 = phi i32 [ 6, %52 ], [ 6, %76 ], [ %68, %77 ], [ 6, %32 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8208, i8* nonnull %6) #7
  ret i32 %79
}

; Function Attrs: minsize nounwind optsize
declare noalias %struct._IO_FILE* @fopen64(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @errfile(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #22
  %5 = load i32, i32* %4, align 4, !tbaa !74
  %6 = tail call i8* @strerror(i32 %5) #17
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %2, i64* null) #16
  %8 = getelementptr inbounds i8, i8* %7, i64 1
  %9 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.295, i64 0, i64 0), i8* %1, i8* nonnull %8, i8* %6) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @skipcomment(%struct.LoadF* nocapture, i32* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 0
  store i32 0, i32* %3, align 8, !tbaa !205
  %4 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  br label %5

; <label>:5:                                      ; preds = %15, %2
  %6 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.296, i64 0, i64 0), %2 ], [ %11, %15 ]
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !203
  %8 = tail call i32 @_IO_getc(%struct._IO_FILE* %7) #17
  %9 = icmp eq i32 %8, -1
  br i1 %9, label %36, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds i8, i8* %6, i64 1
  %12 = load i8, i8* %6, align 1, !tbaa !21
  %13 = zext i8 %12 to i32
  %14 = icmp eq i32 %8, %13
  br i1 %14, label %15, label %26

; <label>:15:                                     ; preds = %10
  %16 = trunc i32 %8 to i8
  %17 = load i32, i32* %3, align 8, !tbaa !205
  %18 = add nsw i32 %17, 1
  store i32 %18, i32* %3, align 8, !tbaa !205
  %19 = sext i32 %17 to i64
  %20 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 2, i64 %19
  store i8 %16, i8* %20, align 1, !tbaa !21
  %21 = load i8, i8* %11, align 1, !tbaa !21
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %5

; <label>:23:                                     ; preds = %15
  store i32 0, i32* %3, align 8, !tbaa !205
  %24 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !203
  %25 = tail call i32 @_IO_getc(%struct._IO_FILE* %24) #17
  br label %26

; <label>:26:                                     ; preds = %10, %23
  %27 = phi i32 [ %25, %23 ], [ %8, %10 ]
  store i32 %27, i32* %1, align 4, !tbaa !74
  %28 = icmp eq i32 %27, 35
  br i1 %28, label %29, label %39

; <label>:29:                                     ; preds = %26
  br label %30

; <label>:30:                                     ; preds = %29, %30
  %31 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !203
  %32 = tail call i32 @_IO_getc(%struct._IO_FILE* %31) #16
  switch i32 %32, label %30 [
    i32 -1, label %33
    i32 10, label %33
  ]

; <label>:33:                                     ; preds = %30, %30
  %34 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !203
  %35 = tail call i32 @_IO_getc(%struct._IO_FILE* %34) #16
  br label %36

; <label>:36:                                     ; preds = %5, %33
  %37 = phi i32 [ %35, %33 ], [ -1, %5 ]
  %38 = phi i32 [ 1, %33 ], [ 0, %5 ]
  store i32 %37, i32* %1, align 4, !tbaa !74
  br label %39

; <label>:39:                                     ; preds = %36, %26
  %40 = phi i32 [ 0, %26 ], [ %38, %36 ]
  ret i32 %40
}

; Function Attrs: minsize optsize
declare %struct._IO_FILE* @freopen64(i8*, i8*, %struct._IO_FILE*) local_unnamed_addr #11

; Function Attrs: minsize nounwind optsize uwtable
define internal i8* @getF(%struct.lua_State* nocapture readnone, i8*, i64* nocapture) #0 {
  %4 = bitcast i8* %1 to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !205
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %3
  %8 = sext i32 %5 to i64
  store i64 %8, i64* %2, align 8, !tbaa !135
  store i32 0, i32* %4, align 8, !tbaa !205
  %9 = getelementptr inbounds i8, i8* %1, i64 16
  br label %20

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds i8, i8* %1, i64 8
  %12 = bitcast i8* %11 to %struct._IO_FILE**
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** %12, align 8, !tbaa !203
  %14 = tail call i32 @feof(%struct._IO_FILE* %13) #17
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds i8, i8* %1, i64 16
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** %12, align 8, !tbaa !203
  %19 = tail call i64 @fread(i8* nonnull %17, i64 1, i64 8192, %struct._IO_FILE* %18) #16
  store i64 %19, i64* %2, align 8, !tbaa !135
  br label %20

; <label>:20:                                     ; preds = %7, %16, %10
  %21 = phi i8* [ null, %10 ], [ %17, %16 ], [ %9, %7 ]
  ret i8* %21
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @ferror(%struct._IO_FILE* nocapture) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize
declare i32 @fclose(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_loadbufferx(%struct.lua_State*, i8*, i64, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.LoadS, align 8
  %7 = bitcast %struct.LoadS* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 0
  store i8* %1, i8** %8, align 8, !tbaa !206
  %9 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 1
  store i64 %2, i64* %9, align 8, !tbaa !208
  %10 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %7, i8* %3, i8* %4) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %7) #7
  ret i32 %10
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal i8* @getS(%struct.lua_State* nocapture readnone, i8* nocapture, i64* nocapture) #2 {
  %4 = getelementptr inbounds i8, i8* %1, i64 8
  %5 = bitcast i8* %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !208
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %3
  store i64 %6, i64* %2, align 8, !tbaa !135
  store i64 0, i64* %5, align 8, !tbaa !208
  %9 = bitcast i8* %1 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !206
  br label %11

; <label>:11:                                     ; preds = %3, %8
  %12 = phi i8* [ %10, %8 ], [ null, %3 ]
  ret i8* %12
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_loadstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %1) #21
  %4 = tail call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %3, i8* %1, i8* null) #16
  ret i32 %4
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_callmeta(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %4, i8* %2) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %3
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %4) #16
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %10, i32 1) #17
  br label %11

; <label>:11:                                     ; preds = %3, %7
  %12 = phi i32 [ 1, %7 ], [ 0, %3 ]
  ret i32 %12
}

; Function Attrs: minsize nounwind optsize uwtable
define i64 @luaL_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  tail call void @lua_len(%struct.lua_State* %0, i32 %1) #16
  %5 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %3) #16
  %6 = load i32, i32* %3, align 4, !tbaa !74
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %2
  %9 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.39, i64 0, i64 0)) #16
  unreachable

; <label>:10:                                     ; preds = %2
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0)) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_isstring(%struct.lua_State* %0, i32 -1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %47

; <label>:9:                                      ; preds = %6
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.41, i64 0, i64 0)) #16
  unreachable

; <label>:11:                                     ; preds = %3
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  switch i32 %12, label %30 [
    i32 3, label %13
    i32 4, label %22
    i32 1, label %23
    i32 0, label %28
  ]

; <label>:13:                                     ; preds = %11
  %14 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 %1) #16
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %13
  %17 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* null) #16
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.42, i64 0, i64 0), i64 %17) #16
  br label %47

; <label>:19:                                     ; preds = %13
  %20 = tail call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* null) #16
  %21 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i64 0, i64 0), double %20) #16
  br label %47

; <label>:22:                                     ; preds = %11
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %1) #16
  br label %47

; <label>:23:                                     ; preds = %11
  %24 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 %1) #16
  %25 = icmp eq i32 %24, 0
  %26 = select i1 %25, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0)
  %27 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %26) #16
  br label %47

; <label>:28:                                     ; preds = %11
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i64 0, i64 0)) #16
  br label %47

; <label>:30:                                     ; preds = %11
  %31 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %32 = icmp eq i32 %31, 4
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %30
  %34 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  br label %41

; <label>:35:                                     ; preds = %30
  %36 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %37 = add nsw i32 %36, 1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %38
  %40 = load i8*, i8** %39, align 8, !tbaa !39
  br label %41

; <label>:41:                                     ; preds = %35, %33
  %42 = phi i8* [ %34, %33 ], [ %40, %35 ]
  %43 = tail call i8* @lua_topointer(%struct.lua_State* %0, i32 %1) #16
  %44 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i64 0, i64 0), i8* %42, i8* %43) #16
  %45 = icmp eq i32 %31, 0
  br i1 %45, label %47, label %46

; <label>:46:                                     ; preds = %41
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %47

; <label>:47:                                     ; preds = %46, %41, %6, %22, %23, %28, %19, %16
  %48 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* %2) #16
  ret i8* %48
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_setfuncs(%struct.lua_State*, %struct.luaL_Reg* nocapture readonly, i32) local_unnamed_addr #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.48, i64 0, i64 0)) #16
  %4 = sub nsw i32 0, %2
  %5 = sub i32 -2, %2
  br label %6

; <label>:6:                                      ; preds = %17, %3
  %7 = phi %struct.luaL_Reg* [ %1, %3 ], [ %21, %17 ]
  %8 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %7, i64 0, i32 0
  %9 = load i8*, i8** %8, align 8, !tbaa !209
  %10 = icmp eq i8* %9, null
  br i1 %10, label %22, label %11

; <label>:11:                                     ; preds = %6
  br label %12

; <label>:12:                                     ; preds = %11, %15
  %13 = phi i32 [ %16, %15 ], [ 0, %11 ]
  %14 = icmp slt i32 %13, %2
  br i1 %14, label %15, label %17

; <label>:15:                                     ; preds = %12
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %4) #16
  %16 = add nuw nsw i32 %13, 1
  br label %12

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %7, i64 0, i32 1
  %19 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %18, align 8, !tbaa !211
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %19, i32 %2) #16
  %20 = load i8*, i8** %8, align 8, !tbaa !209
  tail call void @lua_setfield(%struct.lua_State* %0, i32 %5, i8* %20) #16
  %21 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %7, i64 1
  br label %6

; <label>:22:                                     ; preds = %6
  %23 = xor i32 %2, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %23) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaL_getsubtable(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 %1, i8* %2) #16
  %5 = icmp eq i32 %4, 5
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %7 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 %7, i8* %2) #16
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi i32 [ 0, %6 ], [ 1, %3 ]
  ret i32 %9
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_requiref(%struct.lua_State*, i8*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %5 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  %6 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1) #16
  %7 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %20

; <label>:9:                                      ; preds = %4
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = bitcast %struct.TValue* %12 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %2, i32 (%struct.lua_State*)** %13, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 38, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %10, align 8, !tbaa !20
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1) #16
  %18 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %19, i32 1) #17
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -3, i8* %1) #16
  br label %20

; <label>:20:                                     ; preds = %4, %9
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %21 = icmp eq i32 %3, 0
  br i1 %21, label %23, label %22

; <label>:22:                                     ; preds = %20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* %1) #16
  br label %23

; <label>:23:                                     ; preds = %20, %22
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_addgsub(%struct.luaL_Buffer*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = tail call i64 @strlen(i8* %2) #21
  br label %6

; <label>:6:                                      ; preds = %10, %4
  %7 = phi i8* [ %1, %4 ], [ %14, %10 ]
  %8 = tail call i8* @strstr(i8* %7, i8* %2) #21
  %9 = icmp eq i8* %8, null
  br i1 %9, label %15, label %10

; <label>:10:                                     ; preds = %6
  %11 = ptrtoint i8* %8 to i64
  %12 = ptrtoint i8* %7 to i64
  %13 = sub i64 %11, %12
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %0, i8* %7, i64 %13) #16
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %3) #16
  %14 = getelementptr inbounds i8, i8* %8, i64 %5
  br label %6

; <label>:15:                                     ; preds = %6
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %7) #16
  ret void
}

; Function Attrs: minsize nounwind optsize readonly
declare i8* @strstr(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define i8* @luaL_gsub(%struct.lua_State*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %7, align 8, !tbaa !202
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %9 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %8, %union.anon.6** %9, align 8, !tbaa !201
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %11 = bitcast i64* %10 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %11, align 8, !tbaa !135
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %5, i8* %1, i8* %2, i8* %3) #16
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  %12 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %6) #7
  ret i8* %12
}

; Function Attrs: minsize nounwind optsize uwtable
define %struct.lua_State* @luaL_newstate() local_unnamed_addr #0 {
  %1 = tail call %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)* nonnull @l_alloc, i8* null) #16
  %2 = icmp eq %struct.lua_State* %1, null
  br i1 %2, label %13, label %3

; <label>:3:                                      ; preds = %0
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 37
  store i32 (%struct.lua_State*)* @panic, i32 (%struct.lua_State*)** %6, align 8, !tbaa !77
  %7 = tail call i8* @lua_newuserdatauv(%struct.lua_State* nonnull %1, i64 4, i32 0) #16
  %8 = bitcast i8* %7 to i32*
  %9 = tail call i32 @luaL_ref(%struct.lua_State* nonnull %1, i32 -1001000) #16
  store i32 0, i32* %8, align 4, !tbaa !74
  %10 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 44
  store i8* %7, i8** %11, align 8, !tbaa !186
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 43
  store void (i8*, i8*, i32)* @warnf, void (i8*, i8*, i32)** %12, align 8, !tbaa !187
  br label %13

; <label>:13:                                     ; preds = %0, %3
  ret %struct.lua_State* %1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal noalias i8* @l_alloc(i8* nocapture readnone, i8* nocapture, i64, i64) #0 {
  %5 = icmp eq i64 %3, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call void @free(i8* %1) #17
  br label %9

; <label>:7:                                      ; preds = %4
  %8 = tail call i8* @realloc(i8* %1, i64 %3) #17
  br label %9

; <label>:9:                                      ; preds = %7, %6
  %10 = phi i8* [ null, %6 ], [ %8, %7 ]
  ret i8* %10
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @panic(%struct.lua_State*) #0 {
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %3 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %4 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.297, i64 0, i64 0), i8* %3) #23
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @warnf(i8* nocapture, i8* nocapture readonly, i32) #0 {
  %4 = bitcast i8* %0 to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !74
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %12

; <label>:7:                                      ; preds = %3
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %9 = tail call i32 @fputs(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.299, i64 0, i64 0), %struct._IO_FILE* %8) #24
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %11 = tail call i32 @fflush(%struct._IO_FILE* %10) #16
  br label %12

; <label>:12:                                     ; preds = %3, %7
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %14 = tail call i32 @fputs(i8* %1, %struct._IO_FILE* %13) #24
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %16 = tail call i32 @fflush(%struct._IO_FILE* %15) #16
  %17 = icmp eq i32 %2, 0
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %12
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %20 = tail call i32 @fputs(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.300, i64 0, i64 0), %struct._IO_FILE* %19) #24
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %22 = tail call i32 @fflush(%struct._IO_FILE* %21) #16
  br label %23

; <label>:23:                                     ; preds = %12, %18
  store i32 %2, i32* %4, align 4, !tbaa !74
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_checkversion_(%struct.lua_State*, double, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 136
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.50, i64 0, i64 0)) #16
  unreachable

; <label>:7:                                      ; preds = %3
  %8 = fcmp une double %1, 5.040000e+02
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %7
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.51, i64 0, i64 0), double %1, double 5.040000e+02) #16
  unreachable

; <label>:11:                                     ; preds = %7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_base(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i64 2) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([26 x %struct.luaL_Reg], [26 x %struct.luaL_Reg]* @base_funcs, i64 0, i64 0), i32 0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0)) #16
  %3 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i64 0, i64 0)) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_coroutine(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 8) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([9 x %struct.luaL_Reg], [9 x %struct.luaL_Reg]* @co_funcs, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_debug(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 16) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([17 x %struct.luaL_Reg], [17 x %struct.luaL_Reg]* @dblib, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_io(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @iolib, i64 0, i64 0), i32 0) #16
  %2 = tail call i32 @luaL_newmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #17
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0)) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @flib, i64 0, i64 0), i32 0) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !39
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i64 0, i64 0)) #16
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %4, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.58, i64 0, i64 0)) #16
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %5, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @createstdfile(%struct.lua_State*, %struct._IO_FILE*, i8*, i8*) unnamed_addr #0 {
  %5 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0) #16
  %6 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 0
  store %struct._IO_FILE* %1, %struct._IO_FILE** %6, align 8, !tbaa !212
  %7 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 1
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %7, align 8, !tbaa !214
  %8 = icmp eq i8* %2, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %4
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* nonnull %2) #16
  br label %10

; <label>:10:                                     ; preds = %4, %9
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %3) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_math(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 27) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([28 x %struct.luaL_Reg], [28 x %struct.luaL_Reg]* @mathlib, i64 0, i64 0), i32 0) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to double*
  store double 0x400921FB54442D18, double* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i64 0, i64 0)) #16
  %9 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %10 = bitcast %struct.TValue* %9 to double*
  store double 0x7FF0000000000000, double* %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 19, i8* %11, align 8, !tbaa !22
  %12 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1
  store %union.StackValue* %13, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i64 0, i64 0)) #16
  %14 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %15 = bitcast %struct.TValue* %14 to i64*
  store i64 9223372036854775807, i64* %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 35, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i64 0, i64 0)) #16
  %19 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %19 to i64*
  store i64 -9223372036854775808, i64* %20, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 35, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i64 0, i64 0)) #16
  %24 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 32, i32 0) #17
  %25 = bitcast i8* %24 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* %0, %struct.RanState* nonnull %25) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @randfuncs, i64 0, i64 0), i32 1) #17
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_package(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0) #17
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 1) #17
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @gctm, i32 (%struct.lua_State*)** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 38, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0)) #17
  %9 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  tail call void @lua_rawsetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*)) #17
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @pk_funcs, i64 0, i64 0), i32 0) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 4, i32 0) #17
  br label %10

; <label>:10:                                     ; preds = %13, %1
  %11 = phi i64 [ %16, %13 ], [ 0, %1 ]
  %12 = icmp eq i64 %11, 4
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %10
  %14 = getelementptr inbounds [5 x i32 (%struct.lua_State*)*], [5 x i32 (%struct.lua_State*)*]* @createsearcherstable.searchers, i64 0, i64 %11
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2) #17
  %15 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %14, align 8, !tbaa !39
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %15, i32 1) #17
  %16 = add nuw nsw i64 %11, 1
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 -2, i64 %16) #17
  br label %10

; <label>:17:                                     ; preds = %10
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0)) #17
  tail call fastcc void @setpath(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.65, i64 0, i64 0), i8* getelementptr inbounds ([151 x i8], [151 x i8]* @.str.66, i64 0, i64 0)) #16
  tail call fastcc void @setpath(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.68, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.69, i64 0, i64 0)) #16
  %18 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.70, i64 0, i64 0)) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.71, i64 0, i64 0)) #16
  %19 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i64 0, i64 0)) #16
  %20 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0)) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i64 0, i64 0)) #16
  %21 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i64 2) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([2 x %struct.luaL_Reg], [2 x %struct.luaL_Reg]* @ll_funcs, i64 0, i64 0), i32 1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @setpath(%struct.lua_State*, i8*, i8*, i8*) unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.484, i64 0, i64 0), i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.485, i64 0, i64 0)) #16
  %7 = tail call i8* @getenv(i8* nonnull %6) #17
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %4
  %10 = tail call i8* @getenv(i8* %2) #17
  %11 = icmp eq i8* %10, null
  br i1 %11, label %17, label %12

; <label>:12:                                     ; preds = %4, %9
  %13 = phi i8* [ %10, %9 ], [ %7, %4 ]
  %14 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0)) #17
  %15 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %19, label %17

; <label>:17:                                     ; preds = %12, %9
  %18 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3) #16
  br label %72

; <label>:19:                                     ; preds = %12
  %20 = tail call i8* @strstr(i8* nonnull %13, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.486, i64 0, i64 0)) #21
  %21 = icmp eq i8* %20, null
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %19
  %23 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %13) #16
  br label %72

; <label>:24:                                     ; preds = %19
  %25 = tail call i64 @strlen(i8* nonnull %13) #21
  %26 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %26) #7
  %27 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %27, align 8, !tbaa !202
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %29 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %28, %union.anon.6** %29, align 8, !tbaa !201
  %30 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %31 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %32 = bitcast i64* %31 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %32, align 8, !tbaa !135
  %33 = icmp ult i8* %13, %20
  br i1 %33, label %34, label %50

; <label>:34:                                     ; preds = %24
  %35 = ptrtoint i8* %20 to i64
  %36 = ptrtoint i8* %13 to i64
  %37 = sub i64 %35, %36
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %13, i64 %37) #16
  %38 = load i64, i64* %30, align 8, !tbaa !200
  %39 = load i64, i64* %31, align 8, !tbaa !198
  %40 = icmp ult i64 %38, %39
  br i1 %40, label %44, label %41

; <label>:41:                                     ; preds = %34
  %42 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #16
  %43 = load i64, i64* %30, align 8, !tbaa !200
  br label %44

; <label>:44:                                     ; preds = %41, %34
  %45 = phi i64 [ %43, %41 ], [ %38, %34 ]
  %46 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %47 = load i8*, i8** %46, align 8, !tbaa !201
  %48 = add i64 %45, 1
  store i64 %48, i64* %30, align 8, !tbaa !200
  %49 = getelementptr inbounds i8, i8* %47, i64 %45
  store i8 59, i8* %49, align 1, !tbaa !21
  br label %50

; <label>:50:                                     ; preds = %44, %24
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %5, i8* %3) #16
  %51 = getelementptr inbounds i8, i8* %13, i64 %25
  %52 = getelementptr inbounds i8, i8* %51, i64 -2
  %53 = icmp ult i8* %20, %52
  br i1 %53, label %54, label %71

; <label>:54:                                     ; preds = %50
  %55 = load i64, i64* %30, align 8, !tbaa !200
  %56 = load i64, i64* %31, align 8, !tbaa !198
  %57 = icmp ult i64 %55, %56
  br i1 %57, label %61, label %58

; <label>:58:                                     ; preds = %54
  %59 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #16
  %60 = load i64, i64* %30, align 8, !tbaa !200
  br label %61

; <label>:61:                                     ; preds = %58, %54
  %62 = phi i64 [ %60, %58 ], [ %55, %54 ]
  %63 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %64 = load i8*, i8** %63, align 8, !tbaa !201
  %65 = add i64 %62, 1
  store i64 %65, i64* %30, align 8, !tbaa !200
  %66 = getelementptr inbounds i8, i8* %64, i64 %62
  store i8 59, i8* %66, align 1, !tbaa !21
  %67 = getelementptr inbounds i8, i8* %20, i64 2
  %68 = ptrtoint i8* %52 to i64
  %69 = ptrtoint i8* %20 to i64
  %70 = sub i64 %68, %69
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %67, i64 %70) #16
  br label %71

; <label>:71:                                     ; preds = %61, %50
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %26) #7
  br label %72

; <label>:72:                                     ; preds = %22, %71, %17
  call void @lua_setfield(%struct.lua_State* %0, i32 -3, i8* %1) #16
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_os(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @syslib, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_string(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 17) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([18 x %struct.luaL_Reg], [18 x %struct.luaL_Reg]* @strlib, i64 0, i64 0), i32 0) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 9) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([10 x %struct.luaL_Reg], [10 x %struct.luaL_Reg]* @stringmetamethods, i64 0, i64 0), i32 0) #17
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #17
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2) #17
  %3 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2) #17
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0)) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_table(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @tab_funcs, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @luaopen_utf8(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 6) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([7 x %struct.luaL_Reg], [7 x %struct.luaL_Reg]* @funcs, i64 0, i64 0), i32 0) #16
  %2 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.75, i64 0, i64 0), i64 14) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define void @luaL_openlibs(%struct.lua_State*) local_unnamed_addr #0 {
  br label %2

; <label>:2:                                      ; preds = %7, %1
  %3 = phi %struct.luaL_Reg* [ getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @loadedlibs, i64 0, i64 0), %1 ], [ %10, %7 ]
  %4 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %3, i64 0, i32 1
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !211
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %3, i64 0, i32 0
  %9 = load i8*, i8** %8, align 8, !tbaa !209
  tail call void @luaL_requiref(%struct.lua_State* %0, i8* %9, i32 (%struct.lua_State*)* nonnull %5, i32 1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %10 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %3, i64 1
  br label %2

; <label>:11:                                     ; preds = %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define i32 @main(i32, i8**) local_unnamed_addr #0 {
  %3 = tail call %struct.lua_State* @luaL_newstate() #16
  %4 = icmp eq %struct.lua_State* %3, null
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = load i8*, i8** %1, align 8, !tbaa !39
  tail call fastcc void @l_message(i8* %6, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.77, i64 0, i64 0)) #16
  br label %31

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %3, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = bitcast %struct.TValue* %10 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @pmain, i32 (%struct.lua_State*)** %11, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 38, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %8, align 8, !tbaa !20
  %15 = sext i32 %0 to i64
  %16 = bitcast %union.StackValue* %14 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1, i32 0, i32 1
  store i8 35, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %8, align 8, !tbaa !20
  %20 = bitcast %union.StackValue* %19 to i8***
  store i8** %1, i8*** %20, align 8, !tbaa !21
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1, i32 0, i32 1
  store i8 2, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %8, align 8, !tbaa !20
  %24 = tail call i32 @lua_pcallk(%struct.lua_State* nonnull %3, i32 2, i32 1, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  %25 = tail call i32 @lua_toboolean(%struct.lua_State* nonnull %3, i32 -1) #16
  %26 = tail call fastcc i32 @report(%struct.lua_State* nonnull %3, i32 %24) #16
  tail call void @lua_close(%struct.lua_State* nonnull %3) #16
  %27 = icmp eq i32 %25, 0
  %28 = icmp ne i32 %24, 0
  %29 = or i1 %28, %27
  %30 = zext i1 %29 to i32
  br label %31

; <label>:31:                                     ; preds = %7, %5
  %32 = phi i32 [ 1, %5 ], [ %30, %7 ]
  ret i32 %32
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @l_message(i8*, i8*) unnamed_addr #0 {
  %3 = icmp eq i8* %0, null
  br i1 %3, label %9, label %4

; <label>:4:                                      ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %6 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* nonnull %0) #23
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %8 = tail call i32 @fflush(%struct._IO_FILE* %7) #16
  br label %9

; <label>:9:                                      ; preds = %2, %4
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %11 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %1) #23
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %13 = tail call i32 @fflush(%struct._IO_FILE* %12) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @pmain(%struct.lua_State*) #0 {
  %2 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null) #16
  %3 = trunc i64 %2 to i32
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 2) #16
  %5 = bitcast i8* %4 to i8**
  br label %6

; <label>:6:                                      ; preds = %58, %1
  %7 = phi i32 [ 0, %1 ], [ %59, %58 ]
  %8 = phi i32 [ 1, %1 ], [ %61, %58 ]
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds i8*, i8** %5, i64 %9
  %11 = load i8*, i8** %10, align 8, !tbaa !39
  %12 = icmp eq i8* %11, null
  br i1 %12, label %63, label %13

; <label>:13:                                     ; preds = %6
  %14 = load i8, i8* %11, align 1, !tbaa !21
  %15 = icmp eq i8 %14, 45
  br i1 %15, label %16, label %63

; <label>:16:                                     ; preds = %13
  %17 = getelementptr inbounds i8, i8* %11, i64 1
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = sext i8 %18 to i32
  switch i32 %19, label %62 [
    i32 45, label %20
    i32 0, label %63
    i32 69, label %27
    i32 105, label %33
    i32 118, label %35
    i32 101, label %42
    i32 108, label %44
  ]

; <label>:20:                                     ; preds = %16
  %21 = getelementptr inbounds i8, i8* %11, i64 2
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = icmp eq i8 %22, 0
  %24 = zext i1 %23 to i32
  %25 = add nsw i32 %8, %24
  %26 = select i1 %23, i32 %7, i32 1
  br label %63

; <label>:27:                                     ; preds = %16
  %28 = getelementptr inbounds i8, i8* %11, i64 2
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %31, label %63

; <label>:31:                                     ; preds = %27
  %32 = or i32 %7, 16
  br label %58

; <label>:33:                                     ; preds = %16
  %34 = or i32 %7, 2
  br label %35

; <label>:35:                                     ; preds = %33, %16
  %36 = phi i32 [ %7, %16 ], [ %34, %33 ]
  %37 = getelementptr inbounds i8, i8* %11, i64 2
  %38 = load i8, i8* %37, align 1, !tbaa !21
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %40, label %63

; <label>:40:                                     ; preds = %35
  %41 = or i32 %36, 4
  br label %58

; <label>:42:                                     ; preds = %16
  %43 = or i32 %7, 8
  br label %44

; <label>:44:                                     ; preds = %42, %16
  %45 = phi i32 [ %7, %16 ], [ %43, %42 ]
  %46 = getelementptr inbounds i8, i8* %11, i64 2
  %47 = load i8, i8* %46, align 1, !tbaa !21
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %49, label %58

; <label>:49:                                     ; preds = %44
  %50 = add nsw i32 %8, 1
  %51 = sext i32 %50 to i64
  %52 = getelementptr inbounds i8*, i8** %5, i64 %51
  %53 = load i8*, i8** %52, align 8, !tbaa !39
  %54 = icmp eq i8* %53, null
  br i1 %54, label %63, label %55

; <label>:55:                                     ; preds = %49
  %56 = load i8, i8* %53, align 1, !tbaa !21
  %57 = icmp eq i8 %56, 45
  br i1 %57, label %63, label %58

; <label>:58:                                     ; preds = %55, %44, %40, %31
  %59 = phi i32 [ %45, %55 ], [ %45, %44 ], [ %41, %40 ], [ %32, %31 ]
  %60 = phi i32 [ %50, %55 ], [ %8, %44 ], [ %8, %40 ], [ %8, %31 ]
  %61 = add nsw i32 %60, 1
  br label %6

; <label>:62:                                     ; preds = %16
  br label %63

; <label>:63:                                     ; preds = %6, %13, %16, %27, %35, %49, %55, %62, %20
  %64 = phi i32 [ %25, %20 ], [ %8, %62 ], [ %8, %55 ], [ %8, %49 ], [ %8, %35 ], [ %8, %27 ], [ %8, %16 ], [ %8, %13 ], [ %8, %6 ]
  %65 = phi i32 [ %26, %20 ], [ 1, %62 ], [ %7, %6 ], [ %7, %13 ], [ %7, %16 ], [ 1, %27 ], [ 1, %35 ], [ 1, %49 ], [ 1, %55 ]
  %66 = load i8*, i8** %5, align 8, !tbaa !39
  %67 = icmp eq i8* %66, null
  br i1 %67, label %72, label %68

; <label>:68:                                     ; preds = %63
  %69 = load i8, i8* %66, align 1, !tbaa !21
  %70 = icmp eq i8 %69, 0
  br i1 %70, label %72, label %71

; <label>:71:                                     ; preds = %68
  store i8* %66, i8** @progname, align 8, !tbaa !39
  br label %72

; <label>:72:                                     ; preds = %68, %63, %71
  %73 = icmp eq i32 %65, 1
  br i1 %73, label %74, label %101

; <label>:74:                                     ; preds = %72
  %75 = sext i32 %64 to i64
  %76 = getelementptr inbounds i8*, i8** %5, i64 %75
  %77 = load i8*, i8** %76, align 8, !tbaa !39
  %78 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %79 = load i8*, i8** @progname, align 8, !tbaa !39
  %80 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %78, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* %79) #25
  %81 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %82 = tail call i32 @fflush(%struct._IO_FILE* %81) #17
  %83 = getelementptr inbounds i8, i8* %77, i64 1
  %84 = load i8, i8* %83, align 1, !tbaa !21
  switch i8 %84, label %90 [
    i8 101, label %85
    i8 108, label %85
  ]

; <label>:85:                                     ; preds = %74, %74
  %86 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %87 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %86, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.618, i64 0, i64 0), i8* nonnull %77) #25
  %88 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %89 = tail call i32 @fflush(%struct._IO_FILE* %88) #17
  br label %95

; <label>:90:                                     ; preds = %74
  %91 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %92 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %91, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.619, i64 0, i64 0), i8* nonnull %77) #25
  %93 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %94 = tail call i32 @fflush(%struct._IO_FILE* %93) #17
  br label %95

; <label>:95:                                     ; preds = %85, %90
  %96 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %97 = load i8*, i8** @progname, align 8, !tbaa !39
  %98 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %96, i8* getelementptr inbounds ([365 x i8], [365 x i8]* @.str.620, i64 0, i64 0), i8* %97) #25
  %99 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %100 = tail call i32 @fflush(%struct._IO_FILE* %99) #17
  br label %238

; <label>:101:                                    ; preds = %72
  %102 = and i32 %65, 4
  %103 = icmp eq i32 %102, 0
  br i1 %103, label %105, label %104

; <label>:104:                                    ; preds = %101
  tail call fastcc void @print_version() #16
  br label %105

; <label>:105:                                    ; preds = %101, %104
  %106 = and i32 %65, 16
  %107 = icmp eq i32 %106, 0
  br i1 %107, label %117, label %108

; <label>:108:                                    ; preds = %105
  %109 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %110 = bitcast %union.StackValue** %109 to %struct.TValue**
  %111 = load %struct.TValue*, %struct.TValue** %110, align 8, !tbaa !20
  %112 = bitcast %struct.TValue* %111 to i32*
  store i32 1, i32* %112, align 8, !tbaa !21
  %113 = getelementptr inbounds %struct.TValue, %struct.TValue* %111, i64 0, i32 1
  store i8 1, i8* %113, align 8, !tbaa !22
  %114 = load %union.StackValue*, %union.StackValue** %109, align 8, !tbaa !20
  %115 = getelementptr inbounds %union.StackValue, %union.StackValue* %114, i64 1
  store %union.StackValue* %115, %union.StackValue** %109, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0)) #16
  tail call void @luaL_openlibs(%struct.lua_State* %0) #16
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** nonnull %5, i32 %3, i32 %64) #16
  %116 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0) #16
  br label %138

; <label>:117:                                    ; preds = %105
  tail call void @luaL_openlibs(%struct.lua_State* %0) #16
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** nonnull %5, i32 %3, i32 %64) #16
  %118 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0) #16
  %119 = tail call i8* @getenv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 1)) #17
  %120 = icmp eq i8* %119, null
  br i1 %120, label %121, label %124

; <label>:121:                                    ; preds = %117
  %122 = tail call i8* @getenv(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 1)) #17
  %123 = icmp eq i8* %122, null
  br i1 %123, label %138, label %124

; <label>:124:                                    ; preds = %121, %117
  %125 = phi i8* [ %122, %121 ], [ %119, %117 ]
  %126 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 0), %121 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 0), %117 ]
  %127 = load i8, i8* %125, align 1, !tbaa !21
  %128 = icmp eq i8 %127, 64
  br i1 %128, label %129, label %133

; <label>:129:                                    ; preds = %124
  %130 = getelementptr inbounds i8, i8* %125, i64 1
  %131 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* nonnull %130, i8* null) #17
  %132 = tail call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %131) #17
  br label %135

; <label>:133:                                    ; preds = %124
  %134 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* nonnull %125, i8* %126) #17
  br label %135

; <label>:135:                                    ; preds = %129, %133
  %136 = phi i32 [ %132, %129 ], [ %134, %133 ]
  %137 = icmp eq i32 %136, 0
  br i1 %137, label %138, label %238

; <label>:138:                                    ; preds = %121, %108, %135
  br label %139

; <label>:139:                                    ; preds = %138, %174
  %140 = phi i32 [ %176, %174 ], [ 1, %138 ]
  %141 = icmp slt i32 %140, %64
  br i1 %141, label %142, label %177

; <label>:142:                                    ; preds = %139
  %143 = sext i32 %140 to i64
  %144 = getelementptr inbounds i8*, i8** %5, i64 %143
  %145 = load i8*, i8** %144, align 8, !tbaa !39
  %146 = getelementptr inbounds i8, i8* %145, i64 1
  %147 = load i8, i8* %146, align 1, !tbaa !21
  %148 = icmp eq i8 %147, 101
  switch i8 %147, label %174 [
    i8 108, label %149
    i8 101, label %149
  ]

; <label>:149:                                    ; preds = %142, %142
  %150 = getelementptr inbounds i8, i8* %145, i64 2
  %151 = load i8, i8* %150, align 1, !tbaa !21
  %152 = icmp eq i8 %151, 0
  br i1 %152, label %153, label %158

; <label>:153:                                    ; preds = %149
  %154 = add nsw i32 %140, 1
  %155 = sext i32 %154 to i64
  %156 = getelementptr inbounds i8*, i8** %5, i64 %155
  %157 = load i8*, i8** %156, align 8, !tbaa !39
  br label %158

; <label>:158:                                    ; preds = %153, %149
  %159 = phi i32 [ %154, %153 ], [ %140, %149 ]
  %160 = phi i8* [ %157, %153 ], [ %150, %149 ]
  br i1 %148, label %161, label %163

; <label>:161:                                    ; preds = %158
  %162 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* %160, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.627, i64 0, i64 0)) #17
  br label %171

; <label>:163:                                    ; preds = %158
  %164 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i64 0, i64 0)) #17
  %165 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %160) #17
  %166 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 1, i32 1) #17
  %167 = icmp eq i32 %166, 0
  br i1 %167, label %168, label %169

; <label>:168:                                    ; preds = %163
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* %160) #17
  br label %169

; <label>:169:                                    ; preds = %168, %163
  %170 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %166) #17
  br label %171

; <label>:171:                                    ; preds = %169, %161
  %172 = phi i32 [ %162, %161 ], [ %170, %169 ]
  %173 = icmp eq i32 %172, 0
  br i1 %173, label %174, label %238

; <label>:174:                                    ; preds = %171, %142
  %175 = phi i32 [ %159, %171 ], [ %140, %142 ]
  %176 = add nsw i32 %175, 1
  br label %139

; <label>:177:                                    ; preds = %139
  %178 = icmp slt i32 %64, %3
  br i1 %178, label %179, label %220

; <label>:179:                                    ; preds = %177
  %180 = sext i32 %64 to i64
  %181 = getelementptr inbounds i8*, i8** %5, i64 %180
  %182 = load i8*, i8** %181, align 8, !tbaa !39
  %183 = tail call i32 @strcmp(i8* %182, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.481, i64 0, i64 0)) #21
  %184 = icmp eq i32 %183, 0
  br i1 %184, label %185, label %191

; <label>:185:                                    ; preds = %179
  %186 = getelementptr inbounds i8*, i8** %181, i64 -1
  %187 = load i8*, i8** %186, align 8, !tbaa !39
  %188 = tail call i32 @strcmp(i8* %187, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.628, i64 0, i64 0)) #21
  %189 = icmp eq i32 %188, 0
  %190 = select i1 %189, i8* %182, i8* null
  br label %191

; <label>:191:                                    ; preds = %185, %179
  %192 = phi i8* [ %182, %179 ], [ %190, %185 ]
  %193 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %192, i8* null) #17
  %194 = icmp eq i32 %193, 0
  br i1 %194, label %195, label %216

; <label>:195:                                    ; preds = %191
  %196 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0)) #17
  %197 = icmp eq i32 %196, 5
  br i1 %197, label %200, label %198

; <label>:198:                                    ; preds = %195
  %199 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.629, i64 0, i64 0)) #17
  unreachable

; <label>:200:                                    ; preds = %195
  %201 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 -1) #17
  %202 = trunc i64 %201 to i32
  %203 = add nsw i32 %202, 3
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %203, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.630, i64 0, i64 0)) #17
  %204 = shl i64 %201, 32
  %205 = ashr exact i64 %204, 32
  br label %206

; <label>:206:                                    ; preds = %211, %200
  %207 = phi i64 [ %213, %211 ], [ 1, %200 ]
  %208 = icmp sgt i64 %207, %205
  %209 = trunc i64 %207 to i32
  %210 = sub i32 0, %209
  br i1 %208, label %214, label %211

; <label>:211:                                    ; preds = %206
  %212 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %210, i64 %207) #17
  %213 = add nuw nsw i64 %207, 1
  br label %206

; <label>:214:                                    ; preds = %206
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %210, i32 -1) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  %215 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 %202, i32 -1) #17
  br label %216

; <label>:216:                                    ; preds = %191, %214
  %217 = phi i32 [ %215, %214 ], [ %193, %191 ]
  %218 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %217) #17
  %219 = icmp eq i32 %218, 0
  br i1 %219, label %220, label %238

; <label>:220:                                    ; preds = %216, %177
  %221 = and i32 %65, 2
  %222 = icmp eq i32 %221, 0
  br i1 %222, label %224, label %223

; <label>:223:                                    ; preds = %220
  tail call fastcc void @doREPL(%struct.lua_State* %0) #16
  br label %230

; <label>:224:                                    ; preds = %220
  %225 = icmp eq i32 %64, %3
  %226 = and i32 %65, 12
  %227 = icmp eq i32 %226, 0
  %228 = and i1 %225, %227
  br i1 %228, label %229, label %230

; <label>:229:                                    ; preds = %224
  tail call fastcc void @print_version() #16
  tail call fastcc void @doREPL(%struct.lua_State* %0) #16
  br label %230

; <label>:230:                                    ; preds = %224, %229, %223
  %231 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %232 = bitcast %union.StackValue** %231 to %struct.TValue**
  %233 = load %struct.TValue*, %struct.TValue** %232, align 8, !tbaa !20
  %234 = bitcast %struct.TValue* %233 to i32*
  store i32 1, i32* %234, align 8, !tbaa !21
  %235 = getelementptr inbounds %struct.TValue, %struct.TValue* %233, i64 0, i32 1
  store i8 1, i8* %235, align 8, !tbaa !22
  %236 = load %union.StackValue*, %union.StackValue** %231, align 8, !tbaa !20
  %237 = getelementptr inbounds %union.StackValue, %union.StackValue* %236, i64 1
  store %union.StackValue* %237, %union.StackValue** %231, align 8, !tbaa !20
  br label %238

; <label>:238:                                    ; preds = %171, %216, %135, %230, %95
  %239 = phi i32 [ 0, %95 ], [ 1, %230 ], [ 0, %135 ], [ 0, %216 ], [ 0, %171 ]
  ret i32 %239
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @report(%struct.lua_State*, i32 returned) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %7, label %4

; <label>:4:                                      ; preds = %2
  %5 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %6 = load i8*, i8** @progname, align 8, !tbaa !39
  tail call fastcc void @l_message(i8* %6, i8* %5) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %7

; <label>:7:                                      ; preds = %2, %4
  ret i32 %1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @tryagain(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 8, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !87
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %4
  tail call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 1) #16
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %13 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %12, align 8, !tbaa !45
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !46
  %16 = tail call i8* %13(i8* %15, i8* %1, i64 %2, i64 %3) #17
  br label %17

; <label>:17:                                     ; preds = %4, %11
  %18 = phi i8* [ %16, %11 ], [ null, %4 ]
  ret i8* %18
}

; Function Attrs: minsize nounwind optsize
declare i64 @time(i64*) local_unnamed_addr #9

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @luaS_hash(i8* nocapture readonly, i64, i32) unnamed_addr #3 {
  %4 = trunc i64 %1 to i32
  %5 = xor i32 %4, %2
  %6 = lshr i64 %1, 5
  %7 = xor i64 %6, -1
  br label %8

; <label>:8:                                      ; preds = %12, %3
  %9 = phi i32 [ %5, %3 ], [ %21, %12 ]
  %10 = phi i64 [ %1, %3 ], [ %22, %12 ]
  %11 = icmp ugt i64 %10, %6
  br i1 %11, label %12, label %23

; <label>:12:                                     ; preds = %8
  %13 = shl i32 %9, 5
  %14 = lshr i32 %9, 2
  %15 = add i32 %13, %14
  %16 = add i64 %10, -1
  %17 = getelementptr inbounds i8, i8* %0, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  %20 = add i32 %15, %19
  %21 = xor i32 %20, %9
  %22 = add i64 %10, %7
  br label %8

; <label>:23:                                     ; preds = %8
  ret i32 %9
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @tablerehash(%struct.TString** nocapture, i32, i32) unnamed_addr #2 {
  %4 = sext i32 %1 to i64
  %5 = sext i32 %2 to i64
  br label %6

; <label>:6:                                      ; preds = %9, %3
  %7 = phi i64 [ %11, %9 ], [ %4, %3 ]
  %8 = icmp slt i64 %7, %5
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %6
  %10 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %7
  store %struct.TString* null, %struct.TString** %10, align 8, !tbaa !39
  %11 = add nsw i64 %7, 1
  br label %6

; <label>:12:                                     ; preds = %6
  %13 = add nsw i32 %2, -1
  br label %14

; <label>:14:                                     ; preds = %35, %12
  %15 = phi i64 [ %36, %35 ], [ 0, %12 ]
  %16 = icmp slt i64 %15, %4
  br i1 %16, label %17, label %37

; <label>:17:                                     ; preds = %14
  %18 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %15
  %19 = load %struct.TString*, %struct.TString** %18, align 8, !tbaa !39
  store %struct.TString* null, %struct.TString** %18, align 8, !tbaa !39
  br label %20

; <label>:20:                                     ; preds = %23, %17
  %21 = phi %struct.TString* [ %19, %17 ], [ %26, %23 ]
  %22 = icmp eq %struct.TString* %21, null
  br i1 %22, label %35, label %23

; <label>:23:                                     ; preds = %20
  %24 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 6
  %25 = bitcast %union.anon* %24 to %struct.TString**
  %26 = load %struct.TString*, %struct.TString** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 5
  %28 = load i32, i32* %27, align 4, !tbaa !215
  %29 = and i32 %28, %13
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %30
  %32 = bitcast %struct.TString** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !39
  %34 = getelementptr inbounds %union.anon, %union.anon* %24, i64 0, i32 0
  store i64 %33, i64* %34, align 8, !tbaa !21
  store %struct.TString* %21, %struct.TString** %31, align 8, !tbaa !39
  br label %20

; <label>:35:                                     ; preds = %20
  %36 = add nuw nsw i64 %15, 1
  br label %14

; <label>:37:                                     ; preds = %14
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @luaC_fix(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %6 = load i8, i8* %5, align 1, !tbaa !67
  %7 = and i8 %6, -32
  %8 = or i8 %7, 4
  store i8 %8, i8* %5, align 1, !tbaa !67
  %9 = bitcast %struct.GCObject* %1 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !152
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 20
  %12 = bitcast %struct.GCObject** %11 to i64*
  store i64 %10, i64* %12, align 8, !tbaa !18
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 29
  %14 = bitcast %struct.GCObject** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !88
  store i64 %15, i64* %9, align 8, !tbaa !152
  store %struct.GCObject* %1, %struct.GCObject** %13, align 8, !tbaa !88
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaM_free_(%struct.lua_State* nocapture readonly, i8*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  %7 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %6, align 8, !tbaa !45
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  %9 = load i8*, i8** %8, align 8, !tbaa !46
  %10 = tail call i8* %7(i8* %9, i8* %1, i64 %2, i64 0) #17
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 3
  %12 = load i64, i64* %11, align 8, !tbaa !11
  %13 = sub i64 %12, %2
  store i64 %13, i64* %11, align 8, !tbaa !11
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @freestack(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !48
  %4 = icmp eq %union.StackValue* %3, null
  br i1 %4, label %14, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %6, %struct.CallInfo** %7, align 8, !tbaa !49
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  %8 = bitcast %union.StackValue** %2 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !48
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %11 = load i32, i32* %10, align 4, !tbaa !51
  %12 = sext i32 %11 to i64
  %13 = shl nsw i64 %12, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* %9, i64 %13) #16
  br label %14

; <label>:14:                                     ; preds = %1, %5
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @separatetobefnz(%struct.global_State* nocapture, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  br label %4

; <label>:4:                                      ; preds = %4, %2
  %5 = phi %struct.GCObject** [ %3, %2 ], [ %8, %4 ]
  %6 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !39
  %7 = icmp eq %struct.GCObject* %6, null
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 0
  br i1 %7, label %9, label %4

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 34
  %12 = icmp ne i32 %1, 0
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %14 = bitcast %struct.GCObject** %13 to i64*
  br label %15

; <label>:15:                                     ; preds = %30, %9
  %16 = phi %struct.GCObject** [ %31, %30 ], [ %10, %9 ]
  %17 = phi %struct.GCObject** [ %20, %30 ], [ %5, %9 ]
  %18 = bitcast %struct.GCObject** %16 to i64*
  br label %19

; <label>:19:                                     ; preds = %15, %38
  %20 = phi %struct.GCObject** [ %39, %38 ], [ %17, %15 ]
  %21 = load %struct.GCObject*, %struct.GCObject** %16, align 8, !tbaa !39
  %22 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !41
  %23 = icmp eq %struct.GCObject* %21, %22
  br i1 %23, label %42, label %24

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %26 = load i8, i8* %25, align 1, !tbaa !67
  %27 = and i8 %26, 24
  %28 = icmp ne i8 %27, 0
  %29 = or i1 %12, %28
  br i1 %29, label %32, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 0
  br label %15

; <label>:32:                                     ; preds = %24
  %33 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !40
  %34 = icmp eq %struct.GCObject* %21, %33
  %35 = bitcast %struct.GCObject* %21 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !152
  br i1 %34, label %37, label %38

; <label>:37:                                     ; preds = %32
  store i64 %36, i64* %14, align 8, !tbaa !40
  br label %38

; <label>:38:                                     ; preds = %32, %37
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 0
  store i64 %36, i64* %18, align 8, !tbaa !39
  %40 = bitcast %struct.GCObject** %20 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !39
  store i64 %41, i64* %35, align 8, !tbaa !152
  store %struct.GCObject* %21, %struct.GCObject** %20, align 8, !tbaa !39
  br label %19

; <label>:42:                                     ; preds = %19
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @callallpendingfinalizers(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  br label %5

; <label>:5:                                      ; preds = %8, %1
  %6 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !216
  %7 = icmp eq %struct.GCObject* %6, null
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  tail call fastcc void @GCTM(%struct.lua_State* %0) #16
  br label %5

; <label>:9:                                      ; preds = %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @deletelist(%struct.lua_State* nocapture readonly, %struct.GCObject*, %struct.GCObject* readnone) unnamed_addr #0 {
  br label %4

; <label>:4:                                      ; preds = %7, %3
  %5 = phi %struct.GCObject* [ %1, %3 ], [ %9, %7 ]
  %6 = icmp eq %struct.GCObject* %5, %2
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 0, i32 0
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !152
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* %5) #16
  br label %4

; <label>:10:                                     ; preds = %4
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @GCTM(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca %struct.TValue, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = bitcast %struct.TValue* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 28
  %7 = load %struct.GCObject*, %struct.GCObject** %6, align 8, !tbaa !216
  %8 = bitcast %struct.GCObject* %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !152
  %10 = bitcast %struct.GCObject** %6 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !216
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 20
  %12 = bitcast %struct.GCObject** %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !18
  store i64 %13, i64* %8, align 8, !tbaa !152
  store %struct.GCObject* %7, %struct.GCObject** %11, align 8, !tbaa !18
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %15 = load i8, i8* %14, align 1, !tbaa !67
  %16 = and i8 %15, -65
  store i8 %16, i8* %14, align 1, !tbaa !67
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %18 = load i8, i8* %17, align 1, !tbaa !44
  %19 = add i8 %18, -3
  %20 = icmp ult i8 %19, 4
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %1
  %22 = and i8 %15, -128
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 10
  %24 = load i8, i8* %23, align 4, !tbaa !15
  %25 = and i8 %24, 24
  %26 = or i8 %25, %22
  store i8 %26, i8* %14, align 1, !tbaa !67
  br label %27

; <label>:27:                                     ; preds = %1, %21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  store %struct.GCObject* %7, %struct.GCObject** %28, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !217
  %31 = or i8 %30, 64
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %2, i32 2) #16
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !22
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %108, label %38

; <label>:38:                                     ; preds = %27
  %39 = ptrtoint %struct.GCObject* %7 to i64
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %41 = load i8, i8* %40, align 1, !tbaa !55
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 15
  %43 = load i8, i8* %42, align 1, !tbaa !28
  store i8 0, i8* %40, align 1, !tbaa !55
  store i8 0, i8* %42, align 1, !tbaa !28
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %45 = bitcast %union.StackValue** %44 to %struct.TValue**
  %46 = load %struct.TValue*, %struct.TValue** %45, align 8, !tbaa !20
  %47 = bitcast %struct.TValue* %33 to i64*
  %48 = bitcast %struct.TValue* %46 to i64*
  %49 = load i64, i64* %47, align 8
  store i64 %49, i64* %48, align 8
  %50 = load i8, i8* %34, align 8, !tbaa !22
  %51 = getelementptr inbounds %struct.TValue, %struct.TValue* %46, i64 0, i32 1
  store i8 %50, i8* %51, align 8, !tbaa !22
  %52 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1, i32 0
  %54 = bitcast %struct.TValue* %53 to i64*
  store i64 %39, i64* %54, align 8
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1, i32 0, i32 1
  store i8 %31, i8* %55, align 8, !tbaa !22
  %56 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 2
  store %union.StackValue* %57, %union.StackValue** %44, align 8, !tbaa !20
  %58 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %59 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !49
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 7
  %61 = load i16, i16* %60, align 2, !tbaa !60
  %62 = or i16 %61, 64
  store i16 %62, i16* %60, align 2, !tbaa !60
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %64 = bitcast %union.StackValue** %63 to i64*
  %65 = load i64, i64* %64, align 8, !tbaa !48
  %66 = ptrtoint %union.StackValue* %56 to i64
  %67 = sub i64 %66, %65
  %68 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @dothecall, i8* null, i64 %67, i64 0) #16
  %69 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !49
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %69, i64 0, i32 7
  %71 = load i16, i16* %70, align 2, !tbaa !60
  %72 = and i16 %71, -65
  store i16 %72, i16* %70, align 2, !tbaa !60
  store i8 %41, i8* %40, align 1, !tbaa !55
  store i8 %43, i8* %42, align 1, !tbaa !28
  %73 = icmp eq i32 %68, 0
  br i1 %73, label %108, label %74

; <label>:74:                                     ; preds = %38
  %75 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %76 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 -1, i32 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !21
  %78 = and i8 %77, 15
  %79 = icmp eq i8 %78, 4
  br i1 %79, label %80, label %85

; <label>:80:                                     ; preds = %74
  %81 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 -1, i32 0, i32 0, i32 0
  %82 = bitcast %struct.GCObject** %81 to i8**
  %83 = load i8*, i8** %82, align 8, !tbaa !21
  %84 = getelementptr inbounds i8, i8* %83, i64 24
  br label %85

; <label>:85:                                     ; preds = %74, %80
  %86 = phi i8* [ %84, %80 ], [ getelementptr inbounds ([29 x i8], [29 x i8]* @.str.139, i64 0, i64 0), %74 ]
  %87 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %88 = getelementptr inbounds %struct.global_State, %struct.global_State* %87, i64 0, i32 43
  %89 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %88, align 8, !tbaa !187
  %90 = icmp eq void (i8*, i8*, i32)* %89, null
  br i1 %90, label %108, label %91

; <label>:91:                                     ; preds = %85
  %92 = getelementptr inbounds %struct.global_State, %struct.global_State* %87, i64 0, i32 44
  %93 = load i8*, i8** %92, align 8, !tbaa !186
  tail call void %89(i8* %93, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.140, i64 0, i64 0), i32 1) #17
  %94 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %95 = getelementptr inbounds %struct.global_State, %struct.global_State* %94, i64 0, i32 43
  %96 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %95, align 8, !tbaa !187
  %97 = icmp eq void (i8*, i8*, i32)* %96, null
  br i1 %97, label %108, label %98

; <label>:98:                                     ; preds = %91
  %99 = getelementptr inbounds %struct.global_State, %struct.global_State* %94, i64 0, i32 44
  %100 = load i8*, i8** %99, align 8, !tbaa !186
  tail call void %96(i8* %100, i8* %86, i32 1) #17
  %101 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %102 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 43
  %103 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %102, align 8, !tbaa !187
  %104 = icmp eq void (i8*, i8*, i32)* %103, null
  br i1 %104, label %108, label %105

; <label>:105:                                    ; preds = %98
  %106 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 44
  %107 = load i8*, i8** %106, align 8, !tbaa !186
  tail call void %103(i8* %107, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.141, i64 0, i64 0), i32 0) #17
  br label %108

; <label>:108:                                    ; preds = %85, %91, %105, %98, %38, %27
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* nocapture readonly, %struct.TValue* nocapture readonly, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %1 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %1 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %3
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  br i1 %24, label %32, label %27

; <label>:27:                                     ; preds = %21
  %28 = zext i32 %2 to i64
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 40, i64 %28
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !39
  %31 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %23, %struct.TString* %30) #16
  br label %34

; <label>:32:                                     ; preds = %21
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %34

; <label>:34:                                     ; preds = %32, %27
  %35 = phi %struct.TValue* [ %31, %27 ], [ %33, %32 ]
  ret %struct.TValue* %35
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @dothecall(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nocapture readonly, %struct.TString* readonly) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !147
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !215
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %8 = load i8, i8* %7, align 1, !tbaa !148
  %9 = zext i8 %8 to i32
  %10 = shl i32 1, %9
  %11 = add nsw i32 %10, -1
  %12 = and i32 %11, %6
  br label %13

; <label>:13:                                     ; preds = %28, %2
  %14 = phi i32 [ %12, %2 ], [ %30, %28 ]
  %15 = phi %union.Node* [ %4, %2 ], [ %17, %28 ]
  %16 = sext i32 %14 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16
  %18 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 84
  br i1 %20, label %21, label %28

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 4, i32 0
  %23 = bitcast %struct.GCObject** %22 to %struct.TString**
  %24 = load %struct.TString*, %struct.TString** %23, align 8, !tbaa !21
  %25 = icmp eq %struct.TString* %24, %1
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %21
  %27 = bitcast %union.Node* %17 to %struct.TValue*
  br label %32

; <label>:28:                                     ; preds = %21, %13
  %29 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 3
  %30 = load i32, i32* %29, align 4, !tbaa !21
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %13

; <label>:32:                                     ; preds = %28, %26
  %33 = phi %struct.TValue* [ %27, %26 ], [ @absentkey, %28 ]
  ret %struct.TValue* %33
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @freeobj(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !217
  switch i8 %4, label %156 [
    i8 10, label %5
    i8 9, label %60
    i8 25, label %60
    i8 22, label %71
    i8 54, label %79
    i8 5, label %87
    i8 8, label %96
    i8 7, label %103
    i8 20, label %117
    i8 36, label %150
  ]

; <label>:5:                                      ; preds = %2
  %6 = bitcast %struct.GCObject* %1 to %struct.Proto*
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 4
  %8 = bitcast %struct.GCObject* %7 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !119
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1, i32 1
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !218
  %13 = sext i32 %12 to i64
  %14 = shl nsw i64 %13, 2
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %9, i64 %14) #17
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 4, i32 1
  %16 = bitcast i8* %15 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !219
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 2
  %19 = bitcast %struct.GCObject* %18 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !220
  %21 = sext i32 %20 to i64
  %22 = shl nsw i64 %21, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %17, i64 %22) #17
  %23 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 3, i32 1
  %24 = bitcast i8* %23 to i8**
  %25 = load i8*, i8** %24, align 8, !tbaa !221
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 7
  %27 = load i32, i32* %26, align 4, !tbaa !222
  %28 = sext i32 %27 to i64
  %29 = shl nsw i64 %28, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %25, i64 %29) #17
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 5, i32 1
  %31 = bitcast i8* %30 to i8**
  %32 = load i8*, i8** %31, align 8, !tbaa !124
  %33 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 9
  %34 = load i32, i32* %33, align 4, !tbaa !123
  %35 = sext i32 %34 to i64
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %32, i64 %35) #17
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 6
  %37 = bitcast %struct.GCObject* %36 to i8**
  %38 = load i8*, i8** %37, align 8, !tbaa !223
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 2, i32 1
  %40 = bitcast i8* %39 to i32*
  %41 = load i32, i32* %40, align 8, !tbaa !224
  %42 = sext i32 %41 to i64
  %43 = shl nsw i64 %42, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %38, i64 %43) #17
  %44 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 6, i32 1
  %45 = bitcast i8* %44 to i8**
  %46 = load i8*, i8** %45, align 8, !tbaa !97
  %47 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 11
  %48 = load i32, i32* %47, align 4, !tbaa !95
  %49 = sext i32 %48 to i64
  %50 = shl nsw i64 %49, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %46, i64 %50) #17
  %51 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 5
  %52 = bitcast %struct.GCObject* %51 to i8**
  %53 = load i8*, i8** %52, align 8, !tbaa !193
  %54 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %55 = bitcast %struct.GCObject* %54 to i32*
  %56 = load i32, i32* %55, align 8, !tbaa !185
  %57 = sext i32 %56 to i64
  %58 = shl nsw i64 %57, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %53, i64 %58) #17
  %59 = bitcast %struct.GCObject* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %59, i64 128) #17
  br label %156

; <label>:60:                                     ; preds = %2, %2
  %61 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %62 = bitcast %struct.GCObject* %61 to %struct.TValue**
  %63 = load %struct.TValue*, %struct.TValue** %62, align 8, !tbaa !64
  %64 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1, i32 1
  %65 = bitcast i8* %64 to %struct.TValue*
  %66 = icmp eq %struct.TValue* %63, %65
  br i1 %66, label %69, label %67

; <label>:67:                                     ; preds = %60
  %68 = bitcast %struct.GCObject* %1 to %struct.UpVal*
  tail call fastcc void @luaF_unlinkupval(%struct.UpVal* nonnull %68) #17
  br label %69

; <label>:69:                                     ; preds = %60, %67
  %70 = bitcast %struct.GCObject* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %70, i64 40) #17
  br label %156

; <label>:71:                                     ; preds = %2
  %72 = bitcast %struct.GCObject* %1 to i8*
  %73 = bitcast %struct.GCObject* %1 to %struct.LClosure*
  %74 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %73, i64 0, i32 3
  %75 = load i8, i8* %74, align 2, !tbaa !21
  %76 = zext i8 %75 to i64
  %77 = shl nuw nsw i64 %76, 3
  %78 = add nuw nsw i64 %77, 32
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %72, i64 %78) #16
  br label %156

; <label>:79:                                     ; preds = %2
  %80 = bitcast %struct.GCObject* %1 to i8*
  %81 = bitcast %struct.GCObject* %1 to %struct.CClosure*
  %82 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %81, i64 0, i32 3
  %83 = load i8, i8* %82, align 2, !tbaa !21
  %84 = zext i8 %83 to i64
  %85 = shl nuw nsw i64 %84, 4
  %86 = add nuw nsw i64 %85, 32
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %80, i64 %86) #16
  br label %156

; <label>:87:                                     ; preds = %2
  %88 = bitcast %struct.GCObject* %1 to %struct.Table*
  tail call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* %88) #17
  %89 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %90 = bitcast %struct.GCObject* %89 to i8**
  %91 = load i8*, i8** %90, align 8, !tbaa !137
  %92 = tail call fastcc i32 @luaH_realasize(%struct.Table* %88) #17
  %93 = zext i32 %92 to i64
  %94 = shl nuw nsw i64 %93, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %91, i64 %94) #17
  %95 = bitcast %struct.GCObject* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %95, i64 56) #17
  br label %156

; <label>:96:                                     ; preds = %2
  %97 = bitcast %struct.GCObject* %1 to %struct.lua_State*
  %98 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 -1, i32 1
  %99 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 3, i32 1
  %100 = bitcast i8* %99 to %union.StackValue**
  %101 = load %union.StackValue*, %union.StackValue** %100, align 8, !tbaa !48
  %102 = tail call fastcc i32 @luaF_close(%struct.lua_State* %97, %union.StackValue* %101, i32 -1) #17
  tail call fastcc void @freestack(%struct.lua_State* %97) #17
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* nonnull %98, i64 208) #17
  br label %156

; <label>:103:                                    ; preds = %2
  %104 = bitcast %struct.GCObject* %1 to %struct.Udata*
  %105 = bitcast %struct.GCObject* %1 to i8*
  %106 = getelementptr inbounds %struct.Udata, %struct.Udata* %104, i64 0, i32 3
  %107 = load i16, i16* %106, align 2, !tbaa !190
  %108 = icmp eq i16 %107, 0
  %109 = zext i16 %107 to i64
  %110 = shl nuw nsw i64 %109, 4
  %111 = add nuw nsw i64 %110, 40
  %112 = select i1 %108, i64 32, i64 %111
  %113 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %114 = bitcast %struct.GCObject* %113 to i64*
  %115 = load i64, i64* %114, align 8, !tbaa !188
  %116 = add i64 %112, %115
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %105, i64 %116) #16
  br label %156

; <label>:117:                                    ; preds = %2
  %118 = bitcast %struct.GCObject* %1 to %struct.TString*
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %120 = load %struct.global_State*, %struct.global_State** %119, align 8, !tbaa !2
  %121 = getelementptr inbounds %struct.global_State, %struct.global_State* %120, i64 0, i32 6, i32 0
  %122 = load %struct.TString**, %struct.TString*** %121, align 8, !tbaa !84
  %123 = getelementptr inbounds %struct.TString, %struct.TString* %118, i64 0, i32 5
  %124 = load i32, i32* %123, align 4, !tbaa !215
  %125 = getelementptr inbounds %struct.global_State, %struct.global_State* %120, i64 0, i32 6, i32 2
  %126 = load i32, i32* %125, align 4, !tbaa !85
  %127 = add nsw i32 %126, -1
  %128 = and i32 %127, %124
  %129 = sext i32 %128 to i64
  %130 = getelementptr inbounds %struct.TString*, %struct.TString** %122, i64 %129
  br label %131

; <label>:131:                                    ; preds = %136, %117
  %132 = phi %struct.TString** [ %130, %117 ], [ %137, %136 ]
  %133 = load %struct.TString*, %struct.TString** %132, align 8, !tbaa !39
  %134 = icmp eq %struct.TString* %133, %118
  %135 = getelementptr inbounds %struct.TString, %struct.TString* %133, i64 0, i32 6
  br i1 %134, label %138, label %136

; <label>:136:                                    ; preds = %131
  %137 = bitcast %union.anon* %135 to %struct.TString**
  br label %131

; <label>:138:                                    ; preds = %131
  %139 = getelementptr inbounds %union.anon, %union.anon* %135, i64 0, i32 0
  %140 = load i64, i64* %139, align 8, !tbaa !21
  %141 = bitcast %struct.TString** %132 to i64*
  store i64 %140, i64* %141, align 8, !tbaa !39
  %142 = getelementptr inbounds %struct.global_State, %struct.global_State* %120, i64 0, i32 6, i32 1
  %143 = load i32, i32* %142, align 8, !tbaa !141
  %144 = add nsw i32 %143, -1
  store i32 %144, i32* %142, align 8, !tbaa !141
  %145 = bitcast %struct.GCObject* %1 to i8*
  %146 = getelementptr inbounds %struct.TString, %struct.TString* %118, i64 0, i32 4
  %147 = load i8, i8* %146, align 1, !tbaa !21
  %148 = zext i8 %147 to i64
  %149 = add nuw nsw i64 %148, 25
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %145, i64 %149) #16
  br label %156

; <label>:150:                                    ; preds = %2
  %151 = bitcast %struct.GCObject* %1 to i8*
  %152 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %153 = bitcast %struct.GCObject* %152 to i64*
  %154 = load i64, i64* %153, align 8, !tbaa !21
  %155 = add i64 %154, 25
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %151, i64 %155) #16
  br label %156

; <label>:156:                                    ; preds = %2, %150, %138, %103, %96, %87, %79, %71, %69, %5
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @luaF_unlinkupval(%struct.UpVal* nocapture readonly) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %0, i64 0, i32 4, i32 0
  %3 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %2, i64 0, i32 0
  %4 = bitcast %struct.anon.5* %2 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %0, i64 0, i32 4, i32 0, i32 1
  %7 = bitcast %struct.UpVal*** %6 to i64**
  %8 = load i64*, i64** %7, align 8, !tbaa !21
  store i64 %5, i64* %8, align 8, !tbaa !39
  %9 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !21
  %10 = icmp eq %struct.UpVal* %9, null
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %1
  %12 = bitcast %struct.UpVal*** %6 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 4, i32 0, i32 1
  %15 = bitcast %struct.UpVal*** %14 to i64*
  store i64 %13, i64* %15, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %1, %11
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @freehash(%struct.lua_State* nocapture readonly, %struct.Table* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !139
  %5 = icmp eq %union.Node* %4, null
  br i1 %5, label %16, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %8 = bitcast %union.Node** %7 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !147
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !148
  %12 = zext i8 %11 to i32
  %13 = shl i32 1, %12
  %14 = sext i32 %13 to i64
  %15 = mul nsw i64 %14, 24
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %9, i64 %15) #16
  br label %16

; <label>:16:                                     ; preds = %6, %2
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @luaH_realasize(%struct.Table* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !138
  %4 = icmp slt i8 %3, 0
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !136
  br i1 %4, label %7, label %23

; <label>:7:                                      ; preds = %1
  %8 = add i32 %6, -1
  %9 = and i32 %8, %6
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %23, label %11

; <label>:11:                                     ; preds = %7
  %12 = lshr i32 %6, 1
  %13 = or i32 %12, %6
  %14 = lshr i32 %13, 2
  %15 = or i32 %14, %13
  %16 = lshr i32 %15, 4
  %17 = or i32 %16, %15
  %18 = lshr i32 %17, 8
  %19 = or i32 %18, %17
  %20 = lshr i32 %19, 16
  %21 = or i32 %20, %19
  %22 = add i32 %21, 1
  br label %23

; <label>:23:                                     ; preds = %1, %7, %11
  %24 = phi i32 [ %22, %11 ], [ %6, %7 ], [ %6, %1 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaE_freeCI(%struct.lua_State* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !49
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 3
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !103
  store %struct.CallInfo* null, %struct.CallInfo** %4, align 8, !tbaa !103
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %7 = load i16, i16* %6, align 4, !tbaa !50
  %8 = zext i16 %7 to i32
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %10 = load i32, i32* %9, align 8, !tbaa !54
  %11 = sub i32 %10, %8
  store i32 %11, i32* %9, align 8, !tbaa !54
  br label %12

; <label>:12:                                     ; preds = %16, %1
  %13 = phi i16 [ %7, %1 ], [ %21, %16 ]
  %14 = phi %struct.CallInfo* [ %5, %1 ], [ %19, %16 ]
  %15 = icmp eq %struct.CallInfo* %14, null
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %12
  %17 = bitcast %struct.CallInfo* %14 to i8*
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %14, i64 0, i32 3
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !103
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* %17, i64 64) #16
  %20 = load i16, i16* %6, align 4, !tbaa !50
  %21 = add i16 %20, -1
  store i16 %21, i16* %6, align 4, !tbaa !50
  br label %12

; <label>:22:                                     ; preds = %12
  %23 = zext i16 %13 to i32
  %24 = load i32, i32* %9, align 8, !tbaa !54
  %25 = add i32 %24, %23
  store i32 %25, i32* %9, align 8, !tbaa !54
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @fullgen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  tail call fastcc void @enterinc(%struct.global_State* %1) #16
  %3 = tail call fastcc i64 @entergen(%struct.lua_State* %0, %struct.global_State* %1) #16
  ret i64 %3
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @setminordebt(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %3 = load i64, i64* %2, align 8, !tbaa !31
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %5 = load i64, i64* %4, align 8, !tbaa !11
  %6 = add nsw i64 %5, %3
  %7 = udiv i64 %6, 100
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 13
  %9 = load i8, i8* %8, align 1, !tbaa !80
  %10 = zext i8 %9 to i64
  %11 = sub nsw i64 0, %10
  %12 = mul i64 %7, %11
  tail call fastcc void @luaE_setdebt(%struct.global_State* %0, i64 %12) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @setpause(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 17
  %3 = load i8, i8* %2, align 1, !tbaa !79
  %4 = zext i8 %3 to i64
  %5 = shl nuw nsw i64 %4, 2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 4
  %7 = load i64, i64* %6, align 8, !tbaa !32
  %8 = udiv i64 %7, 100
  %9 = udiv i64 9223372036854775807, %8
  %10 = icmp ult i64 %5, %9
  %11 = mul nsw i64 %8, %5
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %13 = load i64, i64* %12, align 8, !tbaa !31
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %15 = load i64, i64* %14, align 8, !tbaa !11
  %16 = add nsw i64 %15, %13
  %17 = sub nsw i64 0, %11
  %18 = select i1 %10, i64 %17, i64 -9223372036854775807
  %19 = add i64 %16, %18
  %20 = icmp slt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  tail call fastcc void @luaE_setdebt(%struct.global_State* %0, i64 %21) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @enterinc(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 20
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !18
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %3) #16
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 30
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %6 = bitcast %struct.GCObject** %4 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %6, i8 0, i64 24, i32 8, i1 false)
  %7 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !36
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %7) #16
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !216
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %9) #16
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %12 = bitcast %struct.GCObject** %10 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %12, i8 0, i64 24, i32 8, i1 false)
  store i8 8, i8* %11, align 1, !tbaa !44
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  store i8 0, i8* %13, align 2, !tbaa !29
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 5
  store i64 0, i64* %14, align 8, !tbaa !30
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaC_runtilstate(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  br label %6

; <label>:6:                                      ; preds = %12, %2
  %7 = load i8, i8* %5, align 1, !tbaa !44
  %8 = zext i8 %7 to i32
  %9 = shl i32 1, %8
  %10 = and i32 %9, %1
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %6
  %13 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #16
  br label %6

; <label>:14:                                     ; preds = %6
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @atomic(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 24
  %5 = bitcast %struct.GCObject** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !150
  store %struct.GCObject* null, %struct.GCObject** %4, align 8, !tbaa !150
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  store i8 2, i8* %7, align 1, !tbaa !44
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !16
  %10 = and i8 %9, 24
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %1
  %13 = bitcast %struct.lua_State* %0 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %3, %struct.GCObject* %13) #16
  br label %14

; <label>:14:                                     ; preds = %1, %12
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !76
  %17 = and i8 %16, 64
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %27, label %19

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 0, i32 0
  %21 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !67
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %21) #16
  br label %27

; <label>:27:                                     ; preds = %19, %14, %26
  tail call fastcc void @markmt(%struct.global_State* nonnull %3) #16
  %28 = tail call fastcc i64 @propagateall(%struct.global_State* nonnull %3) #16
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 36
  br label %30

; <label>:30:                                     ; preds = %49, %27
  %31 = phi %struct.lua_State** [ %50, %49 ], [ %29, %27 ]
  %32 = phi i32 [ %40, %49 ], [ 0, %27 ]
  %33 = bitcast %struct.lua_State** %31 to i64*
  br label %35

; <label>:34:                                     ; preds = %55
  br label %35

; <label>:35:                                     ; preds = %30, %34
  %36 = phi i32 [ %56, %34 ], [ %32, %30 ]
  %37 = load %struct.lua_State*, %struct.lua_State** %31, align 8, !tbaa !39
  %38 = icmp eq %struct.lua_State* %37, null
  br i1 %38, label %83, label %39

; <label>:39:                                     ; preds = %35
  %40 = add nsw i32 %36, 1
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %37, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !16
  %43 = and i8 %42, 56
  %44 = icmp eq i8 %43, 0
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %37, i64 0, i32 12
  br i1 %44, label %46, label %51

; <label>:46:                                     ; preds = %39
  %47 = load %struct.UpVal*, %struct.UpVal** %45, align 8, !tbaa !56
  %48 = icmp eq %struct.UpVal* %47, null
  br i1 %48, label %51, label %49

; <label>:49:                                     ; preds = %46
  %50 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %37, i64 0, i32 14
  br label %30

; <label>:51:                                     ; preds = %46, %39
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %37, i64 0, i32 14
  %53 = bitcast %struct.lua_State** %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !52
  store i64 %54, i64* %33, align 8, !tbaa !39
  store %struct.lua_State* %37, %struct.lua_State** %52, align 8, !tbaa !52
  br label %55

; <label>:55:                                     ; preds = %81, %51
  %56 = phi i32 [ %40, %51 ], [ %61, %81 ]
  %57 = phi %struct.UpVal** [ %45, %51 ], [ %82, %81 ]
  %58 = load %struct.UpVal*, %struct.UpVal** %57, align 8, !tbaa !21
  %59 = icmp eq %struct.UpVal* %58, null
  br i1 %59, label %34, label %60

; <label>:60:                                     ; preds = %55
  %61 = add nsw i32 %56, 1
  %62 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %58, i64 0, i32 2
  %63 = load i8, i8* %62, align 1, !tbaa !66
  %64 = and i8 %63, 24
  %65 = icmp eq i8 %64, 0
  br i1 %65, label %66, label %81

; <label>:66:                                     ; preds = %60
  %67 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %58, i64 0, i32 3
  %68 = load %struct.TValue*, %struct.TValue** %67, align 8, !tbaa !64
  %69 = getelementptr inbounds %struct.TValue, %struct.TValue* %68, i64 0, i32 1
  %70 = load i8, i8* %69, align 8, !tbaa !22
  %71 = and i8 %70, 64
  %72 = icmp eq i8 %71, 0
  br i1 %72, label %81, label %73

; <label>:73:                                     ; preds = %66
  %74 = getelementptr inbounds %struct.TValue, %struct.TValue* %68, i64 0, i32 0, i32 0
  %75 = load %struct.GCObject*, %struct.GCObject** %74, align 8, !tbaa !21
  %76 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %75, i64 0, i32 2
  %77 = load i8, i8* %76, align 1, !tbaa !67
  %78 = and i8 %77, 24
  %79 = icmp eq i8 %78, 0
  br i1 %79, label %81, label %80

; <label>:80:                                     ; preds = %73
  tail call fastcc void @reallymarkobject(%struct.global_State* %3, %struct.GCObject* %75) #17
  br label %81

; <label>:81:                                     ; preds = %80, %73, %66, %60
  %82 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %58, i64 0, i32 4, i32 0, i32 0
  br label %55

; <label>:83:                                     ; preds = %35
  %84 = sext i32 %36 to i64
  %85 = tail call fastcc i64 @propagateall(%struct.global_State* %3) #16
  %86 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %87 = bitcast %struct.GCObject** %86 to i64*
  store i64 %6, i64* %87, align 8, !tbaa !225
  %88 = tail call fastcc i64 @propagateall(%struct.global_State* %3) #16
  tail call fastcc void @convergeephemerons(%struct.global_State* %3) #16
  %89 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 25
  %90 = load %struct.GCObject*, %struct.GCObject** %89, align 8, !tbaa !226
  tail call fastcc void @clearbyvalues(%struct.global_State* %3, %struct.GCObject* %90, %struct.GCObject* null) #16
  %91 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 27
  %92 = load %struct.GCObject*, %struct.GCObject** %91, align 8, !tbaa !227
  tail call fastcc void @clearbyvalues(%struct.global_State* %3, %struct.GCObject* %92, %struct.GCObject* null) #16
  %93 = load %struct.GCObject*, %struct.GCObject** %89, align 8, !tbaa !226
  %94 = load %struct.GCObject*, %struct.GCObject** %91, align 8, !tbaa !227
  tail call fastcc void @separatetobefnz(%struct.global_State* %3, i32 0) #16
  %95 = tail call fastcc i64 @markbeingfnz(%struct.global_State* %3) #16
  %96 = tail call fastcc i64 @propagateall(%struct.global_State* %3) #16
  tail call fastcc void @convergeephemerons(%struct.global_State* %3) #16
  %97 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 26
  %98 = load %struct.GCObject*, %struct.GCObject** %97, align 8, !tbaa !228
  tail call fastcc void @clearbykeys(%struct.global_State* %3, %struct.GCObject* %98) #16
  %99 = load %struct.GCObject*, %struct.GCObject** %91, align 8, !tbaa !227
  tail call fastcc void @clearbykeys(%struct.global_State* %3, %struct.GCObject* %99) #16
  %100 = load %struct.GCObject*, %struct.GCObject** %89, align 8, !tbaa !226
  tail call fastcc void @clearbyvalues(%struct.global_State* %3, %struct.GCObject* %100, %struct.GCObject* %93) #16
  %101 = load %struct.GCObject*, %struct.GCObject** %91, align 8, !tbaa !227
  tail call fastcc void @clearbyvalues(%struct.global_State* %3, %struct.GCObject* %101, %struct.GCObject* %94) #16
  %102 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 39
  %103 = bitcast %struct.TString** %102 to i64*
  br label %104

; <label>:104:                                    ; preds = %123, %83
  %105 = phi i64 [ %124, %123 ], [ 0, %83 ]
  %106 = icmp eq i64 %105, 53
  br i1 %106, label %125, label %107

; <label>:107:                                    ; preds = %104
  br label %108

; <label>:108:                                    ; preds = %107, %121
  %109 = phi i64 [ %122, %121 ], [ 0, %107 ]
  %110 = icmp eq i64 %109, 2
  br i1 %110, label %123, label %111

; <label>:111:                                    ; preds = %108
  %112 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 42, i64 %105, i64 %109
  %113 = load %struct.TString*, %struct.TString** %112, align 8, !tbaa !39
  %114 = getelementptr inbounds %struct.TString, %struct.TString* %113, i64 0, i32 2
  %115 = load i8, i8* %114, align 1, !tbaa !140
  %116 = and i8 %115, 24
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %121, label %118

; <label>:118:                                    ; preds = %111
  %119 = load i64, i64* %103, align 8, !tbaa !71
  %120 = bitcast %struct.TString** %112 to i64*
  store i64 %119, i64* %120, align 8, !tbaa !39
  br label %121

; <label>:121:                                    ; preds = %118, %111
  %122 = add nuw nsw i64 %109, 1
  br label %108

; <label>:123:                                    ; preds = %108
  %124 = add nuw nsw i64 %105, 1
  br label %104

; <label>:125:                                    ; preds = %104
  %126 = add i64 %28, %84
  %127 = add i64 %126, %85
  %128 = add i64 %127, %88
  %129 = add i64 %128, %95
  %130 = add i64 %129, %96
  %131 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %132 = load i8, i8* %131, align 4, !tbaa !15
  %133 = xor i8 %132, 24
  store i8 %133, i8* %131, align 4, !tbaa !15
  ret i64 %130
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @atomic2gen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 20
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %3) #16
  %4 = bitcast %struct.GCObject** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !18
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 30
  %7 = bitcast %struct.GCObject** %6 to i64*
  store i64 %5, i64* %7, align 8, !tbaa !34
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 31
  %9 = bitcast %struct.GCObject** %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !38
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 32
  %11 = bitcast %struct.GCObject** %10 to i64*
  store i64 %5, i64* %11, align 8, !tbaa !35
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 22
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %12) #16
  %13 = bitcast %struct.GCObject** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !36
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 33
  %16 = bitcast %struct.GCObject** %15 to i64*
  store i64 %14, i64* %16, align 8, !tbaa !40
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 34
  %18 = bitcast %struct.GCObject** %17 to i64*
  store i64 %14, i64* %18, align 8, !tbaa !41
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 35
  %20 = bitcast %struct.GCObject** %19 to i64*
  store i64 %14, i64* %20, align 8, !tbaa !37
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 28
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %21) #16
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 12
  store i8 1, i8* %22, align 2, !tbaa !29
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 5
  store i64 0, i64* %23, align 8, !tbaa !30
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 2
  %25 = load i64, i64* %24, align 8, !tbaa !31
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %27 = load i64, i64* %26, align 8, !tbaa !11
  %28 = add nsw i64 %27, %25
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  store i64 %28, i64* %29, align 8, !tbaa !32
  tail call fastcc void @finishgencycle(%struct.lua_State* %0, %struct.global_State* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @entersweep(%struct.lua_State* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  store i8 3, i8* %4, align 1, !tbaa !44
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %6 = tail call fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* %0, %struct.GCObject** nonnull %5) #16
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 21
  store %struct.GCObject** %6, %struct.GCObject*** %7, align 8, !tbaa !151
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @whitelist(%struct.global_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 10
  %4 = load i8, i8* %3, align 4, !tbaa !15
  %5 = and i8 %4, 24
  br label %6

; <label>:6:                                      ; preds = %9, %2
  %7 = phi %struct.GCObject* [ %1, %2 ], [ %15, %9 ]
  %8 = icmp eq %struct.GCObject* %7, null
  br i1 %8, label %16, label %9

; <label>:9:                                      ; preds = %6
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !67
  %12 = and i8 %11, -64
  %13 = or i8 %12, %5
  store i8 %13, i8* %10, align 1, !tbaa !67
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %15 = load %struct.GCObject*, %struct.GCObject** %14, align 8, !tbaa !152
  br label %6

; <label>:16:                                     ; preds = %6
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @singlestep(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  %5 = load i8, i8* %4, align 1, !tbaa !44
  switch i8 %5, label %80 [
    i8 8, label %6
    i8 0, label %32
    i8 1, label %39
    i8 3, label %47
    i8 4, label %51
    i8 5, label %55
    i8 6, label %58
    i8 7, label %59
  ]

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %9 = bitcast %struct.GCObject** %7 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull %9, i8 0, i64 40, i32 8, i1 false) #7
  %10 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !27
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %10, i64 0, i32 2
  %12 = load i8, i8* %11, align 1, !tbaa !16
  %13 = and i8 %12, 24
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %6
  %16 = bitcast %struct.lua_State* %10 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %16) #17
  br label %17

; <label>:17:                                     ; preds = %15, %6
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !76
  %20 = and i8 %19, 64
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %30, label %22

; <label>:22:                                     ; preds = %17
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 0, i32 0
  %24 = load %struct.GCObject*, %struct.GCObject** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %24, i64 0, i32 2
  %26 = load i8, i8* %25, align 1, !tbaa !67
  %27 = and i8 %26, 24
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %30, label %29

; <label>:29:                                     ; preds = %22
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %24) #17
  br label %30

; <label>:30:                                     ; preds = %17, %22, %29
  tail call fastcc void @markmt(%struct.global_State* nonnull %3) #17
  %31 = tail call fastcc i64 @markbeingfnz(%struct.global_State* nonnull %3) #17
  store i8 0, i8* %4, align 1, !tbaa !44
  br label %80

; <label>:32:                                     ; preds = %1
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %34 = load %struct.GCObject*, %struct.GCObject** %33, align 8, !tbaa !225
  %35 = icmp eq %struct.GCObject* %34, null
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %32
  store i8 1, i8* %4, align 1, !tbaa !44
  br label %80

; <label>:37:                                     ; preds = %32
  %38 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #16
  br label %80

; <label>:39:                                     ; preds = %1
  %40 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0) #16
  tail call fastcc void @entersweep(%struct.lua_State* nonnull %0) #16
  %41 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %42 = load i64, i64* %41, align 8, !tbaa !31
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %44 = load i64, i64* %43, align 8, !tbaa !11
  %45 = add nsw i64 %44, %42
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  store i64 %45, i64* %46, align 8, !tbaa !32
  br label %80

; <label>:47:                                     ; preds = %1
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %49 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 4, %struct.GCObject** nonnull %48) #16
  %50 = sext i32 %49 to i64
  br label %80

; <label>:51:                                     ; preds = %1
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %53 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 5, %struct.GCObject** nonnull %52) #16
  %54 = sext i32 %53 to i64
  br label %80

; <label>:55:                                     ; preds = %1
  %56 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 6, %struct.GCObject** null) #16
  %57 = sext i32 %56 to i64
  br label %80

; <label>:58:                                     ; preds = %1
  tail call fastcc void @checkSizes(%struct.lua_State* nonnull %0, %struct.global_State* %3) #16
  store i8 7, i8* %4, align 1, !tbaa !44
  br label %80

; <label>:59:                                     ; preds = %1
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %61 = load %struct.GCObject*, %struct.GCObject** %60, align 8, !tbaa !216
  %62 = icmp eq %struct.GCObject* %61, null
  br i1 %62, label %79, label %63

; <label>:63:                                     ; preds = %59
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 16
  %65 = load i8, i8* %64, align 2, !tbaa !78
  %66 = icmp eq i8 %65, 0
  br i1 %66, label %67, label %79

; <label>:67:                                     ; preds = %63
  br label %68

; <label>:68:                                     ; preds = %67, %74
  %69 = phi i32 [ %75, %74 ], [ 0, %67 ]
  %70 = icmp ult i32 %69, 10
  br i1 %70, label %71, label %76

; <label>:71:                                     ; preds = %68
  %72 = load %struct.GCObject*, %struct.GCObject** %60, align 8, !tbaa !216
  %73 = icmp eq %struct.GCObject* %72, null
  br i1 %73, label %76, label %74

; <label>:74:                                     ; preds = %71
  tail call fastcc void @GCTM(%struct.lua_State* %0) #17
  %75 = add nuw nsw i32 %69, 1
  br label %68

; <label>:76:                                     ; preds = %68, %71
  %77 = mul nsw i32 %69, 50
  %78 = zext i32 %77 to i64
  br label %80

; <label>:79:                                     ; preds = %63, %59
  store i8 8, i8* %4, align 1, !tbaa !44
  br label %80

; <label>:80:                                     ; preds = %1, %79, %76, %58, %55, %51, %47, %39, %37, %36, %30
  %81 = phi i64 [ 0, %79 ], [ %78, %76 ], [ 0, %58 ], [ %57, %55 ], [ %54, %51 ], [ %50, %47 ], [ %40, %39 ], [ 0, %36 ], [ %38, %37 ], [ 1, %30 ], [ 0, %1 ]
  ret i64 %81
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @propagatemark(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !225
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 2
  %5 = load i8, i8* %4, align 1, !tbaa !67
  %6 = or i8 %5, 32
  store i8 %6, i8* %4, align 1, !tbaa !67
  %7 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* %3) #16
  %8 = bitcast %struct.GCObject** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !39
  %10 = bitcast %struct.GCObject** %2 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !225
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !217
  switch i8 %12, label %565 [
    i8 5, label %13
    i8 7, label %241
    i8 22, label %291
    i8 54, label %327
    i8 10, label %353
    i8 8, label %471
  ]

; <label>:13:                                     ; preds = %1
  %14 = bitcast %struct.GCObject* %3 to %struct.Table*
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2, i32 1
  %16 = bitcast i8* %15 to %struct.Table**
  %17 = load %struct.Table*, %struct.Table** %16, align 8, !tbaa !149
  %18 = icmp eq %struct.Table* %17, null
  br i1 %18, label %140, label %19

; <label>:19:                                     ; preds = %13
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 3
  %21 = load i8, i8* %20, align 2, !tbaa !131
  %22 = and i8 %21, 8
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 40, i64 3
  %26 = load %struct.TString*, %struct.TString** %25, align 8, !tbaa !39
  %27 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %17, i32 3, %struct.TString* %26) #17
  %28 = load %struct.Table*, %struct.Table** %16, align 8, !tbaa !149
  %29 = icmp eq %struct.Table* %28, null
  br i1 %29, label %39, label %30

; <label>:30:                                     ; preds = %24, %19
  %31 = phi %struct.TValue* [ %27, %24 ], [ null, %19 ]
  %32 = phi %struct.Table* [ %28, %24 ], [ %17, %19 ]
  %33 = getelementptr inbounds %struct.Table, %struct.Table* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !138
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %39, label %37

; <label>:37:                                     ; preds = %30
  %38 = bitcast %struct.Table* %32 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %38) #17
  br label %39

; <label>:39:                                     ; preds = %37, %30, %24
  %40 = phi %struct.TValue* [ %31, %30 ], [ %27, %24 ], [ %31, %37 ]
  %41 = icmp eq %struct.TValue* %40, null
  br i1 %41, label %140, label %42

; <label>:42:                                     ; preds = %39
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !22
  %45 = and i8 %44, 15
  %46 = icmp eq i8 %45, 4
  br i1 %46, label %47, label %140

; <label>:47:                                     ; preds = %42
  %48 = bitcast %struct.TValue* %40 to i8**
  %49 = load i8*, i8** %48, align 8, !tbaa !21
  %50 = getelementptr inbounds i8, i8* %49, i64 24
  %51 = tail call i8* @strchr(i8* nonnull %50, i32 107) #21
  %52 = tail call i8* @strchr(i8* nonnull %50, i32 118) #21
  %53 = icmp ne i8* %51, null
  %54 = icmp ne i8* %52, null
  %55 = or i1 %53, %54
  br i1 %55, label %56, label %140

; <label>:56:                                     ; preds = %47
  %57 = load i8, i8* %4, align 1, !tbaa !138
  %58 = and i8 %57, -33
  store i8 %58, i8* %4, align 1, !tbaa !138
  br i1 %53, label %131, label %59

; <label>:59:                                     ; preds = %56
  %60 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %61 = bitcast i8* %60 to %union.Node**
  %62 = load %union.Node*, %union.Node** %61, align 8, !tbaa !147
  %63 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %64 = load i8, i8* %63, align 1, !tbaa !148
  %65 = zext i8 %64 to i32
  %66 = shl i32 1, %65
  %67 = sext i32 %66 to i64
  %68 = getelementptr inbounds %union.Node, %union.Node* %62, i64 %67
  %69 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 5
  %70 = load i32, i32* %69, align 4, !tbaa !136
  %71 = icmp ne i32 %70, 0
  %72 = zext i1 %71 to i32
  br label %73

; <label>:73:                                     ; preds = %110, %59
  %74 = phi %union.Node* [ %62, %59 ], [ %112, %110 ]
  %75 = phi i32 [ %72, %59 ], [ %111, %110 ]
  %76 = icmp ult %union.Node* %74, %68
  br i1 %76, label %77, label %113

; <label>:77:                                     ; preds = %73
  %78 = getelementptr inbounds %union.Node, %union.Node* %74, i64 0, i32 0, i32 1
  %79 = load i8, i8* %78, align 8, !tbaa !21
  %80 = and i8 %79, 15
  %81 = icmp eq i8 %80, 0
  br i1 %81, label %82, label %83

; <label>:82:                                     ; preds = %77
  tail call fastcc void @clearkey(%union.Node* nonnull %74) #17
  br label %110

; <label>:83:                                     ; preds = %77
  %84 = getelementptr inbounds %union.Node, %union.Node* %74, i64 0, i32 0, i32 2
  %85 = load i8, i8* %84, align 1, !tbaa !21
  %86 = and i8 %85, 64
  %87 = icmp eq i8 %86, 0
  br i1 %87, label %96, label %88

; <label>:88:                                     ; preds = %83
  %89 = getelementptr inbounds %union.Node, %union.Node* %74, i64 0, i32 0, i32 4, i32 0
  %90 = load %struct.GCObject*, %struct.GCObject** %89, align 8, !tbaa !21
  %91 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %90, i64 0, i32 2
  %92 = load i8, i8* %91, align 1, !tbaa !67
  %93 = and i8 %92, 24
  %94 = icmp eq i8 %93, 0
  br i1 %94, label %96, label %95

; <label>:95:                                     ; preds = %88
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %90) #17
  br label %96

; <label>:96:                                     ; preds = %95, %88, %83
  %97 = icmp eq i32 %75, 0
  br i1 %97, label %98, label %110

; <label>:98:                                     ; preds = %96
  %99 = load i8, i8* %78, align 8, !tbaa !21
  %100 = and i8 %99, 64
  %101 = icmp eq i8 %100, 0
  br i1 %101, label %105, label %102

; <label>:102:                                    ; preds = %98
  %103 = getelementptr inbounds %union.Node, %union.Node* %74, i64 0, i32 0, i32 0, i32 0
  %104 = load %struct.GCObject*, %struct.GCObject** %103, align 8, !tbaa !21
  br label %105

; <label>:105:                                    ; preds = %102, %98
  %106 = phi %struct.GCObject* [ %104, %102 ], [ null, %98 ]
  %107 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %106) #17
  %108 = icmp ne i32 %107, 0
  %109 = zext i1 %108 to i32
  br label %110

; <label>:110:                                    ; preds = %105, %96, %82
  %111 = phi i32 [ %75, %82 ], [ %75, %96 ], [ %109, %105 ]
  %112 = getelementptr inbounds %union.Node, %union.Node* %74, i64 1
  br label %73

; <label>:113:                                    ; preds = %73
  %114 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %115 = load i8, i8* %114, align 1, !tbaa !44
  %116 = icmp eq i8 %115, 2
  %117 = icmp ne i32 %75, 0
  %118 = and i1 %117, %116
  br i1 %118, label %119, label %125

; <label>:119:                                    ; preds = %113
  %120 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 25
  %121 = bitcast %struct.GCObject** %120 to i64*
  %122 = load i64, i64* %121, align 8, !tbaa !226
  %123 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %124 = bitcast %struct.GCObject** %123 to i64*
  store i64 %122, i64* %124, align 8, !tbaa !229
  store %struct.GCObject* %3, %struct.GCObject** %120, align 8, !tbaa !226
  br label %224

; <label>:125:                                    ; preds = %113
  %126 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %127 = bitcast %struct.GCObject** %126 to i64*
  %128 = load i64, i64* %127, align 8, !tbaa !150
  %129 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %130 = bitcast %struct.GCObject** %129 to i64*
  store i64 %128, i64* %130, align 8, !tbaa !229
  store %struct.GCObject* %3, %struct.GCObject** %126, align 8, !tbaa !150
  br label %224

; <label>:131:                                    ; preds = %56
  br i1 %54, label %134, label %132

; <label>:132:                                    ; preds = %131
  %133 = tail call fastcc i32 @traverseephemeron(%struct.global_State* nonnull %0, %struct.Table* nonnull %14) #17
  br label %224

; <label>:134:                                    ; preds = %131
  %135 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %136 = bitcast %struct.GCObject** %135 to i64*
  %137 = load i64, i64* %136, align 8, !tbaa !227
  %138 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %139 = bitcast %struct.GCObject** %138 to i64*
  store i64 %137, i64* %139, align 8, !tbaa !229
  store %struct.GCObject* %3, %struct.GCObject** %135, align 8, !tbaa !227
  br label %224

; <label>:140:                                    ; preds = %47, %42, %39, %13
  %141 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %142 = bitcast i8* %141 to %union.Node**
  %143 = load %union.Node*, %union.Node** %142, align 8, !tbaa !147
  %144 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %145 = load i8, i8* %144, align 1, !tbaa !148
  %146 = zext i8 %145 to i32
  %147 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %14) #17
  %148 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %149 = bitcast %struct.GCObject* %148 to %struct.TValue**
  %150 = zext i32 %147 to i64
  br label %151

; <label>:151:                                    ; preds = %168, %140
  %152 = phi i64 [ %169, %168 ], [ 0, %140 ]
  %153 = icmp eq i64 %152, %150
  br i1 %153, label %170, label %154

; <label>:154:                                    ; preds = %151
  %155 = load %struct.TValue*, %struct.TValue** %149, align 8, !tbaa !137
  %156 = getelementptr inbounds %struct.TValue, %struct.TValue* %155, i64 %152, i32 1
  %157 = load i8, i8* %156, align 8, !tbaa !22
  %158 = and i8 %157, 64
  %159 = icmp eq i8 %158, 0
  br i1 %159, label %168, label %160

; <label>:160:                                    ; preds = %154
  %161 = getelementptr inbounds %struct.TValue, %struct.TValue* %155, i64 %152, i32 0, i32 0
  %162 = load %struct.GCObject*, %struct.GCObject** %161, align 8, !tbaa !21
  %163 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %162, i64 0, i32 2
  %164 = load i8, i8* %163, align 1, !tbaa !67
  %165 = and i8 %164, 24
  %166 = icmp eq i8 %165, 0
  br i1 %166, label %168, label %167

; <label>:167:                                    ; preds = %160
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %162) #17
  br label %168

; <label>:168:                                    ; preds = %167, %160, %154
  %169 = add nuw nsw i64 %152, 1
  br label %151

; <label>:170:                                    ; preds = %151
  %171 = shl i32 1, %146
  %172 = sext i32 %171 to i64
  %173 = getelementptr inbounds %union.Node, %union.Node* %143, i64 %172
  %174 = load %union.Node*, %union.Node** %142, align 8, !tbaa !147
  br label %175

; <label>:175:                                    ; preds = %210, %170
  %176 = phi %union.Node* [ %174, %170 ], [ %211, %210 ]
  %177 = icmp ult %union.Node* %176, %173
  br i1 %177, label %178, label %212

; <label>:178:                                    ; preds = %175
  %179 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 1
  %180 = load i8, i8* %179, align 8, !tbaa !21
  %181 = and i8 %180, 15
  %182 = icmp eq i8 %181, 0
  br i1 %182, label %183, label %184

; <label>:183:                                    ; preds = %178
  tail call fastcc void @clearkey(%union.Node* nonnull %176) #17
  br label %210

; <label>:184:                                    ; preds = %178
  %185 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 2
  %186 = load i8, i8* %185, align 1, !tbaa !21
  %187 = and i8 %186, 64
  %188 = icmp eq i8 %187, 0
  br i1 %188, label %198, label %189

; <label>:189:                                    ; preds = %184
  %190 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 4, i32 0
  %191 = load %struct.GCObject*, %struct.GCObject** %190, align 8, !tbaa !21
  %192 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %191, i64 0, i32 2
  %193 = load i8, i8* %192, align 1, !tbaa !67
  %194 = and i8 %193, 24
  %195 = icmp eq i8 %194, 0
  br i1 %195, label %198, label %196

; <label>:196:                                    ; preds = %189
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %191) #17
  %197 = load i8, i8* %179, align 8, !tbaa !21
  br label %198

; <label>:198:                                    ; preds = %196, %189, %184
  %199 = phi i8 [ %180, %189 ], [ %180, %184 ], [ %197, %196 ]
  %200 = and i8 %199, 64
  %201 = icmp eq i8 %200, 0
  br i1 %201, label %210, label %202

; <label>:202:                                    ; preds = %198
  %203 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 0, i32 0
  %204 = load %struct.GCObject*, %struct.GCObject** %203, align 8, !tbaa !21
  %205 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %204, i64 0, i32 2
  %206 = load i8, i8* %205, align 1, !tbaa !67
  %207 = and i8 %206, 24
  %208 = icmp eq i8 %207, 0
  br i1 %208, label %210, label %209

; <label>:209:                                    ; preds = %202
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %204) #17
  br label %210

; <label>:210:                                    ; preds = %209, %202, %198, %183
  %211 = getelementptr inbounds %union.Node, %union.Node* %176, i64 1
  br label %175

; <label>:212:                                    ; preds = %175
  %213 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %214 = load i8, i8* %213, align 2, !tbaa !29
  %215 = icmp eq i8 %214, 1
  br i1 %215, label %216, label %224

; <label>:216:                                    ; preds = %212
  %217 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %218 = bitcast %struct.GCObject** %217 to i64*
  %219 = load i64, i64* %218, align 8, !tbaa !150
  %220 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %221 = bitcast %struct.GCObject** %220 to i64*
  store i64 %219, i64* %221, align 8, !tbaa !229
  store %struct.GCObject* %3, %struct.GCObject** %217, align 8, !tbaa !150
  %222 = load i8, i8* %4, align 1, !tbaa !138
  %223 = and i8 %222, -33
  store i8 %223, i8* %4, align 1, !tbaa !138
  br label %224

; <label>:224:                                    ; preds = %216, %212, %134, %132, %125, %119
  %225 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 5
  %226 = load i32, i32* %225, align 4, !tbaa !136
  %227 = add i32 %226, 1
  %228 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2
  %229 = bitcast %struct.GCObject* %228 to %union.Node**
  %230 = load %union.Node*, %union.Node** %229, align 8, !tbaa !139
  %231 = icmp eq %union.Node* %230, null
  br i1 %231, label %237, label %232

; <label>:232:                                    ; preds = %224
  %233 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %234 = load i8, i8* %233, align 1, !tbaa !148
  %235 = zext i8 %234 to i32
  %236 = shl i32 2, %235
  br label %237

; <label>:237:                                    ; preds = %224, %232
  %238 = phi i32 [ %236, %232 ], [ 0, %224 ]
  %239 = add i32 %227, %238
  %240 = zext i32 %239 to i64
  br label %565

; <label>:241:                                    ; preds = %1
  %242 = bitcast %struct.GCObject* %3 to %struct.Udata*
  %243 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %244 = bitcast i8* %243 to %struct.Table**
  %245 = load %struct.Table*, %struct.Table** %244, align 8, !tbaa !191
  %246 = icmp eq %struct.Table* %245, null
  br i1 %246, label %254, label %247

; <label>:247:                                    ; preds = %241
  %248 = getelementptr inbounds %struct.Table, %struct.Table* %245, i64 0, i32 2
  %249 = load i8, i8* %248, align 1, !tbaa !138
  %250 = and i8 %249, 24
  %251 = icmp eq i8 %250, 0
  br i1 %251, label %254, label %252

; <label>:252:                                    ; preds = %247
  %253 = bitcast %struct.Table* %245 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %253) #17
  br label %254

; <label>:254:                                    ; preds = %252, %247, %241
  %255 = getelementptr inbounds %struct.Udata, %struct.Udata* %242, i64 0, i32 3
  br label %256

; <label>:256:                                    ; preds = %274, %254
  %257 = phi i64 [ %275, %274 ], [ 0, %254 ]
  %258 = load i16, i16* %255, align 2, !tbaa !190
  %259 = zext i16 %258 to i64
  %260 = icmp ult i64 %257, %259
  br i1 %260, label %261, label %276

; <label>:261:                                    ; preds = %256
  %262 = getelementptr inbounds %struct.Udata, %struct.Udata* %242, i64 0, i32 7, i64 %257, i32 0, i32 1
  %263 = load i8, i8* %262, align 8, !tbaa !21
  %264 = and i8 %263, 64
  %265 = icmp eq i8 %264, 0
  br i1 %265, label %274, label %266

; <label>:266:                                    ; preds = %261
  %267 = getelementptr inbounds %struct.Udata, %struct.Udata* %242, i64 0, i32 7, i64 %257, i32 0, i32 0, i32 0
  %268 = load %struct.GCObject*, %struct.GCObject** %267, align 8, !tbaa !21
  %269 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %268, i64 0, i32 2
  %270 = load i8, i8* %269, align 1, !tbaa !67
  %271 = and i8 %270, 24
  %272 = icmp eq i8 %271, 0
  br i1 %272, label %274, label %273

; <label>:273:                                    ; preds = %266
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %268) #17
  br label %274

; <label>:274:                                    ; preds = %273, %266, %261
  %275 = add nuw nsw i64 %257, 1
  br label %256

; <label>:276:                                    ; preds = %256
  %277 = zext i16 %258 to i64
  %278 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %279 = load i8, i8* %278, align 2, !tbaa !29
  %280 = icmp eq i8 %279, 1
  br i1 %280, label %281, label %289

; <label>:281:                                    ; preds = %276
  %282 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %283 = bitcast %struct.GCObject** %282 to i64*
  %284 = load i64, i64* %283, align 8, !tbaa !150
  %285 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2, i32 0
  %286 = bitcast %struct.GCObject** %285 to i64*
  store i64 %284, i64* %286, align 8, !tbaa !230
  store %struct.GCObject* %3, %struct.GCObject** %282, align 8, !tbaa !150
  %287 = load i8, i8* %4, align 1, !tbaa !231
  %288 = and i8 %287, -33
  store i8 %288, i8* %4, align 1, !tbaa !231
  br label %289

; <label>:289:                                    ; preds = %276, %281
  %290 = add nuw nsw i64 %277, 1
  br label %565

; <label>:291:                                    ; preds = %1
  %292 = bitcast %struct.GCObject* %3 to %struct.LClosure*
  %293 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %294 = bitcast i8* %293 to %struct.Proto**
  %295 = load %struct.Proto*, %struct.Proto** %294, align 8, !tbaa !192
  %296 = icmp eq %struct.Proto* %295, null
  br i1 %296, label %304, label %297

; <label>:297:                                    ; preds = %291
  %298 = getelementptr inbounds %struct.Proto, %struct.Proto* %295, i64 0, i32 2
  %299 = load i8, i8* %298, align 1, !tbaa !232
  %300 = and i8 %299, 24
  %301 = icmp eq i8 %300, 0
  br i1 %301, label %304, label %302

; <label>:302:                                    ; preds = %297
  %303 = bitcast %struct.Proto* %295 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %303) #17
  br label %304

; <label>:304:                                    ; preds = %302, %297, %291
  %305 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %292, i64 0, i32 3
  br label %306

; <label>:306:                                    ; preds = %322, %304
  %307 = phi i64 [ %323, %322 ], [ 0, %304 ]
  %308 = load i8, i8* %305, align 2, !tbaa !177
  %309 = zext i8 %308 to i64
  %310 = icmp ult i64 %307, %309
  br i1 %310, label %311, label %324

; <label>:311:                                    ; preds = %306
  %312 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %292, i64 0, i32 6, i64 %307
  %313 = load %struct.UpVal*, %struct.UpVal** %312, align 8, !tbaa !39
  %314 = icmp eq %struct.UpVal* %313, null
  br i1 %314, label %322, label %315

; <label>:315:                                    ; preds = %311
  %316 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %313, i64 0, i32 2
  %317 = load i8, i8* %316, align 1, !tbaa !66
  %318 = and i8 %317, 24
  %319 = icmp eq i8 %318, 0
  br i1 %319, label %322, label %320

; <label>:320:                                    ; preds = %315
  %321 = bitcast %struct.UpVal* %313 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %321) #17
  br label %322

; <label>:322:                                    ; preds = %320, %315, %311
  %323 = add nuw nsw i64 %307, 1
  br label %306

; <label>:324:                                    ; preds = %306
  %325 = zext i8 %308 to i64
  %326 = add nuw nsw i64 %325, 1
  br label %565

; <label>:327:                                    ; preds = %1
  %328 = bitcast %struct.GCObject* %3 to %struct.CClosure*
  %329 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %328, i64 0, i32 3
  br label %330

; <label>:330:                                    ; preds = %348, %327
  %331 = phi i64 [ %349, %348 ], [ 0, %327 ]
  %332 = load i8, i8* %329, align 2, !tbaa !125
  %333 = zext i8 %332 to i64
  %334 = icmp ult i64 %331, %333
  br i1 %334, label %335, label %350

; <label>:335:                                    ; preds = %330
  %336 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %328, i64 0, i32 6, i64 %331, i32 1
  %337 = load i8, i8* %336, align 8, !tbaa !22
  %338 = and i8 %337, 64
  %339 = icmp eq i8 %338, 0
  br i1 %339, label %348, label %340

; <label>:340:                                    ; preds = %335
  %341 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %328, i64 0, i32 6, i64 %331, i32 0, i32 0
  %342 = load %struct.GCObject*, %struct.GCObject** %341, align 8, !tbaa !21
  %343 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %342, i64 0, i32 2
  %344 = load i8, i8* %343, align 1, !tbaa !67
  %345 = and i8 %344, 24
  %346 = icmp eq i8 %345, 0
  br i1 %346, label %348, label %347

; <label>:347:                                    ; preds = %340
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %342) #17
  br label %348

; <label>:348:                                    ; preds = %347, %340, %335
  %349 = add nuw nsw i64 %331, 1
  br label %330

; <label>:350:                                    ; preds = %330
  %351 = zext i8 %332 to i64
  %352 = add nuw nsw i64 %351, 1
  br label %565

; <label>:353:                                    ; preds = %1
  %354 = bitcast %struct.GCObject* %3 to %struct.Proto*
  %355 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 7
  %356 = bitcast %struct.GCObject* %355 to %struct.TString**
  %357 = load %struct.TString*, %struct.TString** %356, align 8, !tbaa !108
  %358 = icmp eq %struct.TString* %357, null
  br i1 %358, label %366, label %359

; <label>:359:                                    ; preds = %353
  %360 = getelementptr inbounds %struct.TString, %struct.TString* %357, i64 0, i32 2
  %361 = load i8, i8* %360, align 1, !tbaa !140
  %362 = and i8 %361, 24
  %363 = icmp eq i8 %362, 0
  br i1 %363, label %366, label %364

; <label>:364:                                    ; preds = %359
  %365 = bitcast %struct.TString* %357 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %365) #17
  br label %366

; <label>:366:                                    ; preds = %364, %359, %353
  %367 = getelementptr inbounds %struct.Proto, %struct.Proto* %354, i64 0, i32 7
  %368 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 1
  %369 = bitcast i8* %368 to %struct.TValue**
  br label %370

; <label>:370:                                    ; preds = %389, %366
  %371 = phi i64 [ %390, %389 ], [ 0, %366 ]
  %372 = load i32, i32* %367, align 4, !tbaa !222
  %373 = sext i32 %372 to i64
  %374 = icmp slt i64 %371, %373
  br i1 %374, label %375, label %391

; <label>:375:                                    ; preds = %370
  %376 = load %struct.TValue*, %struct.TValue** %369, align 8, !tbaa !221
  %377 = getelementptr inbounds %struct.TValue, %struct.TValue* %376, i64 %371, i32 1
  %378 = load i8, i8* %377, align 8, !tbaa !22
  %379 = and i8 %378, 64
  %380 = icmp eq i8 %379, 0
  br i1 %380, label %389, label %381

; <label>:381:                                    ; preds = %375
  %382 = getelementptr inbounds %struct.TValue, %struct.TValue* %376, i64 %371, i32 0, i32 0
  %383 = load %struct.GCObject*, %struct.GCObject** %382, align 8, !tbaa !21
  %384 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %383, i64 0, i32 2
  %385 = load i8, i8* %384, align 1, !tbaa !67
  %386 = and i8 %385, 24
  %387 = icmp eq i8 %386, 0
  br i1 %387, label %389, label %388

; <label>:388:                                    ; preds = %381
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %383) #17
  br label %389

; <label>:389:                                    ; preds = %388, %381, %375
  %390 = add nuw nsw i64 %371, 1
  br label %370

; <label>:391:                                    ; preds = %370
  %392 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %393 = bitcast %struct.GCObject* %392 to i32*
  %394 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 5
  %395 = bitcast %struct.GCObject* %394 to %struct.Upvaldesc**
  br label %396

; <label>:396:                                    ; preds = %413, %391
  %397 = phi i64 [ %414, %413 ], [ 0, %391 ]
  %398 = load i32, i32* %393, align 8, !tbaa !185
  %399 = sext i32 %398 to i64
  %400 = icmp slt i64 %397, %399
  br i1 %400, label %401, label %415

; <label>:401:                                    ; preds = %396
  %402 = load %struct.Upvaldesc*, %struct.Upvaldesc** %395, align 8, !tbaa !193
  %403 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %402, i64 %397, i32 0
  %404 = load %struct.TString*, %struct.TString** %403, align 8, !tbaa !194
  %405 = icmp eq %struct.TString* %404, null
  br i1 %405, label %413, label %406

; <label>:406:                                    ; preds = %401
  %407 = getelementptr inbounds %struct.TString, %struct.TString* %404, i64 0, i32 2
  %408 = load i8, i8* %407, align 1, !tbaa !140
  %409 = and i8 %408, 24
  %410 = icmp eq i8 %409, 0
  br i1 %410, label %413, label %411

; <label>:411:                                    ; preds = %406
  %412 = bitcast %struct.TString* %404 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %412) #17
  br label %413

; <label>:413:                                    ; preds = %411, %406, %401
  %414 = add nuw nsw i64 %397, 1
  br label %396

; <label>:415:                                    ; preds = %396
  %416 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2
  %417 = bitcast %struct.GCObject* %416 to i32*
  %418 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4, i32 1
  %419 = bitcast i8* %418 to %struct.Proto***
  br label %420

; <label>:420:                                    ; preds = %437, %415
  %421 = phi i64 [ %438, %437 ], [ 0, %415 ]
  %422 = load i32, i32* %417, align 8, !tbaa !220
  %423 = sext i32 %422 to i64
  %424 = icmp slt i64 %421, %423
  br i1 %424, label %425, label %439

; <label>:425:                                    ; preds = %420
  %426 = load %struct.Proto**, %struct.Proto*** %419, align 8, !tbaa !219
  %427 = getelementptr inbounds %struct.Proto*, %struct.Proto** %426, i64 %421
  %428 = load %struct.Proto*, %struct.Proto** %427, align 8, !tbaa !39
  %429 = icmp eq %struct.Proto* %428, null
  br i1 %429, label %437, label %430

; <label>:430:                                    ; preds = %425
  %431 = getelementptr inbounds %struct.Proto, %struct.Proto* %428, i64 0, i32 2
  %432 = load i8, i8* %431, align 1, !tbaa !232
  %433 = and i8 %432, 24
  %434 = icmp eq i8 %433, 0
  br i1 %434, label %437, label %435

; <label>:435:                                    ; preds = %430
  %436 = bitcast %struct.Proto* %428 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %436) #17
  br label %437

; <label>:437:                                    ; preds = %435, %430, %425
  %438 = add nuw nsw i64 %421, 1
  br label %420

; <label>:439:                                    ; preds = %420
  %440 = getelementptr inbounds %struct.Proto, %struct.Proto* %354, i64 0, i32 11
  %441 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 6, i32 1
  %442 = bitcast i8* %441 to %struct.LocVar**
  br label %443

; <label>:443:                                    ; preds = %460, %439
  %444 = phi i64 [ %461, %460 ], [ 0, %439 ]
  %445 = load i32, i32* %440, align 4, !tbaa !95
  %446 = sext i32 %445 to i64
  %447 = icmp slt i64 %444, %446
  br i1 %447, label %448, label %462

; <label>:448:                                    ; preds = %443
  %449 = load %struct.LocVar*, %struct.LocVar** %442, align 8, !tbaa !97
  %450 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %449, i64 %444, i32 0
  %451 = load %struct.TString*, %struct.TString** %450, align 8, !tbaa !101
  %452 = icmp eq %struct.TString* %451, null
  br i1 %452, label %460, label %453

; <label>:453:                                    ; preds = %448
  %454 = getelementptr inbounds %struct.TString, %struct.TString* %451, i64 0, i32 2
  %455 = load i8, i8* %454, align 1, !tbaa !140
  %456 = and i8 %455, 24
  %457 = icmp eq i8 %456, 0
  br i1 %457, label %460, label %458

; <label>:458:                                    ; preds = %453
  %459 = bitcast %struct.TString* %451 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %459) #17
  br label %460

; <label>:460:                                    ; preds = %458, %453, %448
  %461 = add nuw nsw i64 %444, 1
  br label %443

; <label>:462:                                    ; preds = %443
  %463 = load i32, i32* %367, align 4, !tbaa !222
  %464 = load i32, i32* %393, align 8, !tbaa !185
  %465 = load i32, i32* %417, align 8, !tbaa !220
  %466 = add i32 %445, 1
  %467 = add i32 %466, %463
  %468 = add i32 %467, %464
  %469 = add i32 %468, %465
  %470 = sext i32 %469 to i64
  br label %565

; <label>:471:                                    ; preds = %1
  %472 = bitcast %struct.GCObject* %3 to %struct.lua_State*
  %473 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %474 = bitcast %struct.GCObject** %473 to i64*
  %475 = load i64, i64* %474, align 8, !tbaa !150
  %476 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4, i32 1
  %477 = bitcast i8* %476 to i64*
  store i64 %475, i64* %477, align 8, !tbaa !233
  store %struct.GCObject* %3, %struct.GCObject** %473, align 8, !tbaa !150
  %478 = and i8 %5, -33
  store i8 %478, i8* %4, align 1, !tbaa !67
  %479 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 1
  %480 = bitcast i8* %479 to %union.StackValue**
  %481 = load %union.StackValue*, %union.StackValue** %480, align 8, !tbaa !48
  %482 = icmp eq %union.StackValue* %481, null
  br i1 %482, label %565, label %483

; <label>:483:                                    ; preds = %471
  %484 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %485 = bitcast %struct.GCObject* %484 to %union.StackValue**
  br label %486

; <label>:486:                                    ; preds = %503, %483
  %487 = phi %union.StackValue* [ %481, %483 ], [ %504, %503 ]
  %488 = load %union.StackValue*, %union.StackValue** %485, align 8, !tbaa !20
  %489 = icmp ult %union.StackValue* %487, %488
  br i1 %489, label %490, label %505

; <label>:490:                                    ; preds = %486
  %491 = getelementptr inbounds %union.StackValue, %union.StackValue* %487, i64 0, i32 0, i32 1
  %492 = load i8, i8* %491, align 8, !tbaa !21
  %493 = and i8 %492, 64
  %494 = icmp eq i8 %493, 0
  br i1 %494, label %503, label %495

; <label>:495:                                    ; preds = %490
  %496 = getelementptr inbounds %union.StackValue, %union.StackValue* %487, i64 0, i32 0, i32 0, i32 0
  %497 = load %struct.GCObject*, %struct.GCObject** %496, align 8, !tbaa !21
  %498 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %497, i64 0, i32 2
  %499 = load i8, i8* %498, align 1, !tbaa !67
  %500 = and i8 %499, 24
  %501 = icmp eq i8 %500, 0
  br i1 %501, label %503, label %502

; <label>:502:                                    ; preds = %495
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %497) #17
  br label %503

; <label>:503:                                    ; preds = %502, %495, %490
  %504 = getelementptr inbounds %union.StackValue, %union.StackValue* %487, i64 1
  br label %486

; <label>:505:                                    ; preds = %486
  %506 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4
  %507 = bitcast %struct.GCObject* %506 to %struct.UpVal**
  br label %508

; <label>:508:                                    ; preds = %523, %505
  %509 = phi %struct.UpVal** [ %507, %505 ], [ %524, %523 ]
  %510 = load %struct.UpVal*, %struct.UpVal** %509, align 8, !tbaa !21
  %511 = icmp eq %struct.UpVal* %510, null
  br i1 %511, label %525, label %512

; <label>:512:                                    ; preds = %508
  %513 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %510, i64 0, i32 1
  %514 = load i8, i8* %513, align 8, !tbaa !69
  %515 = icmp eq i8 %514, 25
  br i1 %515, label %516, label %523

; <label>:516:                                    ; preds = %512
  %517 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %510, i64 0, i32 2
  %518 = load i8, i8* %517, align 1, !tbaa !66
  %519 = and i8 %518, 24
  %520 = icmp eq i8 %519, 0
  br i1 %520, label %523, label %521

; <label>:521:                                    ; preds = %516
  %522 = bitcast %struct.UpVal* %510 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %522) #17
  br label %523

; <label>:523:                                    ; preds = %521, %516, %512
  %524 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %510, i64 0, i32 4, i32 0, i32 0
  br label %508

; <label>:525:                                    ; preds = %508
  %526 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %527 = load i8, i8* %526, align 1, !tbaa !44
  %528 = icmp eq i8 %527, 2
  br i1 %528, label %529, label %555

; <label>:529:                                    ; preds = %525
  %530 = load %union.StackValue*, %union.StackValue** %480, align 8, !tbaa !48
  %531 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %472, i64 0, i32 20
  %532 = load i32, i32* %531, align 4, !tbaa !51
  %533 = sext i32 %532 to i64
  %534 = getelementptr inbounds %union.StackValue, %union.StackValue* %530, i64 %533
  br label %535

; <label>:535:                                    ; preds = %538, %529
  %536 = phi %union.StackValue* [ %487, %529 ], [ %540, %538 ]
  %537 = icmp ult %union.StackValue* %536, %534
  br i1 %537, label %538, label %541

; <label>:538:                                    ; preds = %535
  %539 = getelementptr inbounds %union.StackValue, %union.StackValue* %536, i64 0, i32 0, i32 1
  store i8 0, i8* %539, align 8, !tbaa !21
  %540 = getelementptr inbounds %union.StackValue, %union.StackValue* %536, i64 1
  br label %535

; <label>:541:                                    ; preds = %535
  %542 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 5
  %543 = bitcast %struct.GCObject* %542 to %struct.lua_State**
  %544 = load %struct.lua_State*, %struct.lua_State** %543, align 8, !tbaa !52
  %545 = icmp eq %struct.lua_State* %544, %472
  br i1 %545, label %546, label %560

; <label>:546:                                    ; preds = %541
  %547 = load %struct.UpVal*, %struct.UpVal** %507, align 8, !tbaa !56
  %548 = icmp eq %struct.UpVal* %547, null
  br i1 %548, label %560, label %549

; <label>:549:                                    ; preds = %546
  %550 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 36
  %551 = bitcast %struct.lua_State** %550 to i64*
  %552 = load i64, i64* %551, align 8, !tbaa !234
  %553 = bitcast %struct.GCObject* %542 to i64*
  store i64 %552, i64* %553, align 8, !tbaa !52
  %554 = bitcast %struct.lua_State** %550 to %struct.GCObject**
  store %struct.GCObject* %3, %struct.GCObject** %554, align 8, !tbaa !234
  br label %560

; <label>:555:                                    ; preds = %525
  %556 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 16
  %557 = load i8, i8* %556, align 2, !tbaa !78
  %558 = icmp eq i8 %557, 0
  br i1 %558, label %559, label %560

; <label>:559:                                    ; preds = %555
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* %472) #17
  br label %560

; <label>:560:                                    ; preds = %559, %555, %549, %546, %541
  %561 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %472, i64 0, i32 20
  %562 = load i32, i32* %561, align 4, !tbaa !51
  %563 = add nsw i32 %562, 1
  %564 = sext i32 %563 to i64
  br label %565

; <label>:565:                                    ; preds = %560, %471, %1, %462, %350, %324, %289, %237
  %566 = phi i64 [ %470, %462 ], [ %352, %350 ], [ %326, %324 ], [ %290, %289 ], [ %240, %237 ], [ 0, %1 ], [ %564, %560 ], [ 1, %471 ]
  ret i64 %566
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @sweepstep(%struct.lua_State*, %struct.global_State* nocapture, i32, %struct.GCObject**) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 21
  %7 = load %struct.GCObject**, %struct.GCObject*** %6, align 8, !tbaa !151
  %8 = icmp eq %struct.GCObject** %7, null
  br i1 %8, label %20, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %11 = load i64, i64* %10, align 8, !tbaa !11
  %12 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #7
  %13 = call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %7, i32 100, i32* nonnull %5) #16
  store %struct.GCObject** %13, %struct.GCObject*** %6, align 8, !tbaa !151
  %14 = load i64, i64* %10, align 8, !tbaa !11
  %15 = sub i64 %14, %11
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %17 = load i64, i64* %16, align 8, !tbaa !32
  %18 = add i64 %15, %17
  store i64 %18, i64* %16, align 8, !tbaa !32
  %19 = load i32, i32* %5, align 4, !tbaa !74
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #7
  br label %23

; <label>:20:                                     ; preds = %4
  %21 = trunc i32 %2 to i8
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 %21, i8* %22, align 1, !tbaa !44
  store %struct.GCObject** %3, %struct.GCObject*** %6, align 8, !tbaa !151
  br label %23

; <label>:23:                                     ; preds = %20, %9
  %24 = phi i32 [ %19, %9 ], [ 0, %20 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checkSizes(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %4 = load i8, i8* %3, align 2, !tbaa !78
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %6, label %24

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 1
  %10 = load i32, i32* %9, align 8, !tbaa !235
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !90
  %13 = sdiv i32 %12, 4
  %14 = icmp slt i32 %10, %13
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %6
  %16 = sdiv i32 %12, 2
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %16) #16
  %17 = load i64, i64* %7, align 8, !tbaa !11
  br label %18

; <label>:18:                                     ; preds = %15, %6
  %19 = phi i64 [ %17, %15 ], [ %8, %6 ]
  %20 = sub i64 %19, %8
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %22 = load i64, i64* %21, align 8, !tbaa !32
  %23 = add i64 %20, %22
  store i64 %23, i64* %21, align 8, !tbaa !32
  br label %24

; <label>:24:                                     ; preds = %2, %18
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @reallymarkobject(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %4 = load i8, i8* %3, align 1, !tbaa !67
  br label %5

; <label>:5:                                      ; preds = %28, %2
  %6 = phi i8 [ %4, %2 ], [ %32, %28 ]
  %7 = phi %struct.GCObject* [ %1, %2 ], [ %30, %28 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %9 = and i8 %6, -25
  store i8 %9, i8* %8, align 1, !tbaa !67
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !217
  switch i8 %11, label %62 [
    i8 20, label %12
    i8 36, label %12
    i8 9, label %14
    i8 25, label %14
    i8 7, label %35
    i8 22, label %56
    i8 54, label %56
    i8 5, label %56
    i8 8, label %56
    i8 10, label %56
  ]

; <label>:12:                                     ; preds = %5, %5
  %13 = or i8 %9, 32
  store i8 %13, i8* %8, align 1, !tbaa !67
  br label %62

; <label>:14:                                     ; preds = %5, %5
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1
  %16 = bitcast %struct.GCObject* %15 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !64
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %19 = bitcast i8* %18 to %struct.TValue*
  %20 = icmp eq %struct.TValue* %17, %19
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %14
  %22 = or i8 %9, 32
  store i8 %22, i8* %8, align 1, !tbaa !67
  br label %23

; <label>:23:                                     ; preds = %14, %21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = and i8 %25, 64
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %62, label %28

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 0, i32 0
  %30 = load %struct.GCObject*, %struct.GCObject** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %30, i64 0, i32 2
  %32 = load i8, i8* %31, align 1, !tbaa !67
  %33 = and i8 %32, 24
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %62, label %5

; <label>:35:                                     ; preds = %5
  %36 = bitcast %struct.GCObject* %7 to %struct.Udata*
  %37 = getelementptr inbounds %struct.Udata, %struct.Udata* %36, i64 0, i32 3
  %38 = load i16, i16* %37, align 2, !tbaa !190
  %39 = icmp eq i16 %38, 0
  br i1 %39, label %40, label %56

; <label>:40:                                     ; preds = %35
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %42 = bitcast i8* %41 to %struct.Table**
  %43 = load %struct.Table*, %struct.Table** %42, align 8, !tbaa !191
  %44 = icmp eq %struct.Table* %43, null
  br i1 %44, label %53, label %45

; <label>:45:                                     ; preds = %40
  %46 = getelementptr inbounds %struct.Table, %struct.Table* %43, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !138
  %48 = and i8 %47, 24
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %53, label %50

; <label>:50:                                     ; preds = %45
  %51 = bitcast %struct.Table* %43 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %51) #16
  %52 = load i8, i8* %8, align 1, !tbaa !67
  br label %53

; <label>:53:                                     ; preds = %45, %40, %50
  %54 = phi i8 [ %9, %45 ], [ %9, %40 ], [ %52, %50 ]
  %55 = or i8 %54, 32
  store i8 %55, i8* %8, align 1, !tbaa !67
  br label %62

; <label>:56:                                     ; preds = %5, %5, %5, %5, %5, %35
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %58 = bitcast %struct.GCObject** %57 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !225
  %60 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %7) #16
  %61 = bitcast %struct.GCObject** %60 to i64*
  store i64 %59, i64* %61, align 8, !tbaa !39
  store %struct.GCObject* %7, %struct.GCObject** %57, align 8, !tbaa !225
  br label %62

; <label>:62:                                     ; preds = %23, %28, %5, %53, %56, %12
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @markmt(%struct.global_State*) unnamed_addr #0 {
  br label %2

; <label>:2:                                      ; preds = %16, %1
  %3 = phi i64 [ %17, %16 ], [ 0, %1 ]
  %4 = icmp eq i64 %3, 9
  br i1 %4, label %18, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 41, i64 %3
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !39
  %8 = icmp eq %struct.Table* %7, null
  br i1 %8, label %16, label %9

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %7, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !138
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %9
  %15 = bitcast %struct.Table* %7 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %15) #16
  br label %16

; <label>:16:                                     ; preds = %9, %5, %14
  %17 = add nuw nsw i64 %3, 1
  br label %2

; <label>:18:                                     ; preds = %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @markbeingfnz(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  br label %3

; <label>:3:                                      ; preds = %15, %1
  %4 = phi %struct.GCObject** [ %2, %1 ], [ %16, %15 ]
  %5 = phi i64 [ 0, %1 ], [ %9, %15 ]
  %6 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !39
  %7 = icmp eq %struct.GCObject* %6, null
  br i1 %7, label %17, label %8

; <label>:8:                                      ; preds = %3
  %9 = add i64 %5, 1
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !67
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %8
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %6) #16
  br label %15

; <label>:15:                                     ; preds = %8, %14
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 0
  br label %3

; <label>:17:                                     ; preds = %3
  ret i64 %5
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.GCObject** @getgclist(%struct.GCObject* readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 0, i32 1
  %3 = load i8, i8* %2, align 8, !tbaa !217
  switch i8 %3, label %18 [
    i8 5, label %4
    i8 22, label %6
    i8 54, label %8
    i8 8, label %10
    i8 10, label %13
    i8 7, label %16
  ]

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 3, i32 0
  br label %18

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 4, i32 1
  %12 = bitcast i8* %11 to %struct.GCObject**
  br label %18

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 7, i32 1
  %15 = bitcast i8* %14 to %struct.GCObject**
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 2, i32 0
  br label %18

; <label>:18:                                     ; preds = %1, %16, %13, %10, %8, %6, %4
  %19 = phi %struct.GCObject** [ %17, %16 ], [ %15, %13 ], [ %12, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ null, %1 ]
  ret %struct.GCObject** %19
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaT_gettm(%struct.Table* nocapture, i32, %struct.TString* readonly) unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %9, label %15

; <label>:9:                                      ; preds = %3
  %10 = shl i32 1, %1
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 3
  %12 = load i8, i8* %11, align 2, !tbaa !131
  %13 = trunc i32 %10 to i8
  %14 = or i8 %12, %13
  store i8 %14, i8* %11, align 2, !tbaa !131
  br label %15

; <label>:15:                                     ; preds = %3, %9
  %16 = phi %struct.TValue* [ null, %9 ], [ %4, %3 ]
  ret %struct.TValue* %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @traverseephemeron(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !147
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !148
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = sext i32 %8 to i64
  %10 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1) #16
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %12 = zext i32 %10 to i64
  br label %13

; <label>:13:                                     ; preds = %31, %2
  %14 = phi i64 [ %33, %31 ], [ 0, %2 ]
  %15 = phi i32 [ %32, %31 ], [ 0, %2 ]
  %16 = icmp eq i64 %14, %12
  br i1 %16, label %34, label %17

; <label>:17:                                     ; preds = %13
  %18 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !137
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 %14, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 64
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %31, label %23

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 %14, i32 0, i32 0
  %25 = load %struct.GCObject*, %struct.GCObject** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %25, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !67
  %28 = and i8 %27, 24
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %31, label %30

; <label>:30:                                     ; preds = %23
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %25) #16
  br label %31

; <label>:31:                                     ; preds = %23, %17, %30
  %32 = phi i32 [ 1, %30 ], [ %15, %23 ], [ %15, %17 ]
  %33 = add nuw nsw i64 %14, 1
  br label %13

; <label>:34:                                     ; preds = %13
  %35 = getelementptr inbounds %union.Node, %union.Node* %4, i64 %9
  %36 = load %union.Node*, %union.Node** %3, align 8, !tbaa !147
  br label %37

; <label>:37:                                     ; preds = %82, %34
  %38 = phi i32 [ 0, %34 ], [ %83, %82 ]
  %39 = phi %union.Node* [ %36, %34 ], [ %86, %82 ]
  %40 = phi i32 [ 0, %34 ], [ %84, %82 ]
  %41 = phi i32 [ %15, %34 ], [ %85, %82 ]
  %42 = icmp ult %union.Node* %39, %35
  br i1 %42, label %43, label %87

; <label>:43:                                     ; preds = %37
  %44 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 1
  %45 = load i8, i8* %44, align 8, !tbaa !21
  %46 = and i8 %45, 15
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %48, label %49

; <label>:48:                                     ; preds = %43
  tail call fastcc void @clearkey(%union.Node* nonnull %39) #16
  br label %82

; <label>:49:                                     ; preds = %43
  %50 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 2
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = and i8 %51, 64
  %53 = icmp eq i8 %52, 0
  br i1 %53, label %57, label %54

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 4, i32 0
  %56 = load %struct.GCObject*, %struct.GCObject** %55, align 8, !tbaa !21
  br label %57

; <label>:57:                                     ; preds = %49, %54
  %58 = phi %struct.GCObject* [ %56, %54 ], [ null, %49 ]
  %59 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %58) #16
  %60 = icmp eq i32 %59, 0
  %61 = load i8, i8* %44, align 8, !tbaa !21
  %62 = and i8 %61, 64
  %63 = icmp eq i8 %62, 0
  br i1 %60, label %73, label %64

; <label>:64:                                     ; preds = %57
  br i1 %63, label %82, label %65

; <label>:65:                                     ; preds = %64
  %66 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 0, i32 0
  %67 = load %struct.GCObject*, %struct.GCObject** %66, align 8, !tbaa !21
  %68 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %67, i64 0, i32 2
  %69 = load i8, i8* %68, align 1, !tbaa !67
  %70 = and i8 %69, 24
  %71 = icmp eq i8 %70, 0
  %72 = select i1 %71, i32 %38, i32 1
  br label %82

; <label>:73:                                     ; preds = %57
  br i1 %63, label %82, label %74

; <label>:74:                                     ; preds = %73
  %75 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 0, i32 0
  %76 = load %struct.GCObject*, %struct.GCObject** %75, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %76, i64 0, i32 2
  %78 = load i8, i8* %77, align 1, !tbaa !67
  %79 = and i8 %78, 24
  %80 = icmp eq i8 %79, 0
  br i1 %80, label %82, label %81

; <label>:81:                                     ; preds = %74
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %76) #16
  br label %82

; <label>:82:                                     ; preds = %65, %64, %74, %73, %48, %81
  %83 = phi i32 [ %38, %48 ], [ %38, %64 ], [ %38, %81 ], [ %38, %74 ], [ %38, %73 ], [ %72, %65 ]
  %84 = phi i32 [ %40, %48 ], [ 1, %64 ], [ %40, %81 ], [ %40, %74 ], [ %40, %73 ], [ 1, %65 ]
  %85 = phi i32 [ %41, %48 ], [ %41, %64 ], [ 1, %81 ], [ %41, %74 ], [ %41, %73 ], [ %41, %65 ]
  %86 = getelementptr inbounds %union.Node, %union.Node* %39, i64 1
  br label %37

; <label>:87:                                     ; preds = %37
  %88 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %89 = load i8, i8* %88, align 1, !tbaa !44
  %90 = icmp eq i8 %89, 0
  br i1 %90, label %91, label %98

; <label>:91:                                     ; preds = %87
  %92 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %93 = bitcast %struct.GCObject** %92 to i64*
  %94 = load i64, i64* %93, align 8, !tbaa !150
  %95 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %96 = bitcast %struct.GCObject** %95 to i64*
  store i64 %94, i64* %96, align 8, !tbaa !229
  %97 = bitcast %struct.GCObject** %92 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %97, align 8, !tbaa !150
  br label %131

; <label>:98:                                     ; preds = %87
  %99 = icmp eq i32 %38, 0
  br i1 %99, label %107, label %100

; <label>:100:                                    ; preds = %98
  %101 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  %102 = bitcast %struct.GCObject** %101 to i64*
  %103 = load i64, i64* %102, align 8, !tbaa !228
  %104 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %105 = bitcast %struct.GCObject** %104 to i64*
  store i64 %103, i64* %105, align 8, !tbaa !229
  %106 = bitcast %struct.GCObject** %101 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %106, align 8, !tbaa !228
  br label %131

; <label>:107:                                    ; preds = %98
  %108 = icmp eq i32 %40, 0
  br i1 %108, label %116, label %109

; <label>:109:                                    ; preds = %107
  %110 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %111 = bitcast %struct.GCObject** %110 to i64*
  %112 = load i64, i64* %111, align 8, !tbaa !227
  %113 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %114 = bitcast %struct.GCObject** %113 to i64*
  store i64 %112, i64* %114, align 8, !tbaa !229
  %115 = bitcast %struct.GCObject** %110 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %115, align 8, !tbaa !227
  br label %131

; <label>:116:                                    ; preds = %107
  %117 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %118 = load i8, i8* %117, align 2, !tbaa !29
  %119 = icmp eq i8 %118, 1
  br i1 %119, label %120, label %127

; <label>:120:                                    ; preds = %116
  %121 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %122 = bitcast %struct.GCObject** %121 to i64*
  %123 = load i64, i64* %122, align 8, !tbaa !150
  %124 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %125 = bitcast %struct.GCObject** %124 to i64*
  store i64 %123, i64* %125, align 8, !tbaa !229
  %126 = bitcast %struct.GCObject** %121 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %126, align 8, !tbaa !150
  br label %131

; <label>:127:                                    ; preds = %116
  %128 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %129 = load i8, i8* %128, align 1, !tbaa !138
  %130 = or i8 %129, 32
  store i8 %130, i8* %128, align 1, !tbaa !138
  br label %131

; <label>:131:                                    ; preds = %100, %120, %127, %109, %91
  ret i32 %41
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @clearkey(%union.Node* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %union.Node, %union.Node* %0, i64 0, i32 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !21
  %4 = and i8 %3, 64
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %union.Node, %union.Node* %0, i64 0, i32 0, i32 4, i32 0
  %8 = load %struct.GCObject*, %struct.GCObject** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %8, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !67
  %11 = and i8 %10, 24
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %6
  store i8 5, i8* %2, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %7, align 8, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %6, %1, %13
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @iscleared(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  %3 = icmp eq %struct.GCObject* %1, null
  br i1 %3, label %17, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !217
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 4
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !67
  %11 = and i8 %10, 24
  br i1 %8, label %12, label %15

; <label>:12:                                     ; preds = %4
  %13 = icmp eq i8 %11, 0
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %12
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %1) #16
  br label %17

; <label>:15:                                     ; preds = %4
  %16 = zext i8 %11 to i32
  br label %17

; <label>:17:                                     ; preds = %14, %12, %2, %15
  %18 = phi i32 [ %16, %15 ], [ 0, %2 ], [ 0, %12 ], [ 0, %14 ]
  ret i32 %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_shrinkstack(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  br label %5

; <label>:5:                                      ; preds = %10, %1
  %6 = phi %struct.CallInfo** [ %4, %1 ], [ %15, %10 ]
  %7 = phi %union.StackValue* [ %3, %1 ], [ %14, %10 ]
  %8 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !39
  %9 = icmp eq %struct.CallInfo* %8, null
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 1
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !63
  %13 = icmp ult %union.StackValue* %7, %12
  %14 = select i1 %13, %union.StackValue* %12, %union.StackValue* %7
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 2
  br label %5

; <label>:16:                                     ; preds = %5
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !48
  %20 = ptrtoint %union.StackValue* %7 to i64
  %21 = sub i64 %20, %19
  %22 = lshr exact i64 %21, 4
  %23 = trunc i64 %22 to i32
  %24 = add nsw i32 %23, 1
  %25 = sdiv i32 %24, 8
  %26 = add i32 %23, 11
  %27 = add i32 %26, %25
  %28 = icmp slt i32 %27, 1000000
  %29 = select i1 %28, i32 %27, i32 1000000
  %30 = icmp slt i32 %23, 999995
  br i1 %30, label %31, label %37

; <label>:31:                                     ; preds = %16
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %33 = load i32, i32* %32, align 4, !tbaa !51
  %34 = icmp slt i32 %29, %33
  br i1 %34, label %35, label %37

; <label>:35:                                     ; preds = %31
  %36 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %29, i32 0) #16
  br label %37

; <label>:37:                                     ; preds = %16, %31, %35
  %38 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !49
  %39 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %40 = load i16, i16* %39, align 4, !tbaa !50
  %41 = zext i16 %40 to i32
  %42 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %43 = load i32, i32* %42, align 8, !tbaa !54
  %44 = sub i32 %43, %41
  store i32 %44, i32* %42, align 8, !tbaa !54
  br label %45

; <label>:45:                                     ; preds = %56, %37
  %46 = phi i16 [ %40, %37 ], [ %58, %56 ]
  %47 = phi %struct.CallInfo* [ %38, %37 ], [ %54, %56 ]
  %48 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %47, i64 0, i32 3
  %49 = load %struct.CallInfo*, %struct.CallInfo** %48, align 8, !tbaa !103
  %50 = icmp eq %struct.CallInfo* %49, null
  %51 = bitcast %struct.CallInfo* %49 to i8*
  br i1 %50, label %60, label %52

; <label>:52:                                     ; preds = %45
  %53 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %49, i64 0, i32 3
  %54 = load %struct.CallInfo*, %struct.CallInfo** %53, align 8, !tbaa !103
  %55 = icmp eq %struct.CallInfo* %54, null
  br i1 %55, label %60, label %56

; <label>:56:                                     ; preds = %52
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* nonnull %51, i64 64) #17
  %57 = load i16, i16* %39, align 4, !tbaa !50
  %58 = add i16 %57, -1
  store i16 %58, i16* %39, align 4, !tbaa !50
  store %struct.CallInfo* %54, %struct.CallInfo** %48, align 8, !tbaa !103
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 2
  store %struct.CallInfo* %47, %struct.CallInfo** %59, align 8, !tbaa !92
  br label %45

; <label>:60:                                     ; preds = %45, %52
  %61 = zext i16 %46 to i32
  %62 = load i32, i32* %42, align 8, !tbaa !54
  %63 = add i32 %62, %61
  store i32 %63, i32* %42, align 8, !tbaa !54
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaD_reallocstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !51
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !48
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 4
  %11 = sext i32 %1 to i64
  %12 = shl nsw i64 %11, 4
  %13 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %8, i64 %10, i64 %12) #16
  %14 = bitcast i8* %13 to %union.StackValue*
  %15 = icmp eq i8* %13, null
  br i1 %15, label %17, label %16, !prof !47

; <label>:16:                                     ; preds = %3
  br label %20

; <label>:17:                                     ; preds = %3
  %18 = icmp eq i32 %2, 0
  br i1 %18, label %82, label %19

; <label>:19:                                     ; preds = %17
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:20:                                     ; preds = %16, %23
  %21 = phi i64 [ %25, %23 ], [ %9, %16 ]
  %22 = icmp slt i64 %21, %11
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %21, i32 0, i32 1
  store i8 0, i8* %24, align 8, !tbaa !21
  %25 = add nsw i64 %21, 1
  br label %20

; <label>:26:                                     ; preds = %20
  %27 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !48
  %28 = icmp eq %union.StackValue* %27, %14
  br i1 %28, label %78, label %29

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = bitcast %union.StackValue** %30 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !20
  %33 = ptrtoint %union.StackValue* %27 to i64
  %34 = sub i64 %32, %33
  %35 = ashr exact i64 %34, 4
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %35
  store %union.StackValue* %36, %union.StackValue** %30, align 8, !tbaa !20
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  br label %38

; <label>:38:                                     ; preds = %42, %29
  %39 = phi %struct.UpVal** [ %37, %29 ], [ %49, %42 ]
  %40 = load %struct.UpVal*, %struct.UpVal** %39, align 8, !tbaa !21
  %41 = icmp eq %struct.UpVal* %40, null
  br i1 %41, label %50, label %42

; <label>:42:                                     ; preds = %38
  %43 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %40, i64 0, i32 3
  %44 = bitcast %struct.TValue** %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !64
  %46 = sub i64 %45, %33
  %47 = ashr exact i64 %46, 4
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %47, i32 0
  store %struct.TValue* %48, %struct.TValue** %43, align 8, !tbaa !64
  %49 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %40, i64 0, i32 4, i32 0, i32 0
  br label %38

; <label>:50:                                     ; preds = %38
  %51 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  br label %52

; <label>:52:                                     ; preds = %76, %50
  %53 = phi %struct.CallInfo** [ %51, %50 ], [ %77, %76 ]
  %54 = load %struct.CallInfo*, %struct.CallInfo** %53, align 8, !tbaa !39
  %55 = icmp eq %struct.CallInfo* %54, null
  br i1 %55, label %78, label %56

; <label>:56:                                     ; preds = %52
  %57 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 1
  %58 = bitcast %union.StackValue** %57 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !63
  %60 = sub i64 %59, %33
  %61 = ashr exact i64 %60, 4
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %61
  store %union.StackValue* %62, %union.StackValue** %57, align 8, !tbaa !63
  %63 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 0
  %64 = bitcast %struct.CallInfo* %54 to i64*
  %65 = load i64, i64* %64, align 8, !tbaa !61
  %66 = sub i64 %65, %33
  %67 = ashr exact i64 %66, 4
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %67
  store %union.StackValue* %68, %union.StackValue** %63, align 8, !tbaa !61
  %69 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 7
  %70 = load i16, i16* %69, align 2, !tbaa !60
  %71 = and i16 %70, 2
  %72 = icmp eq i16 %71, 0
  br i1 %72, label %73, label %76

; <label>:73:                                     ; preds = %56
  %74 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 4, i32 0, i32 1
  %75 = bitcast i64* %74 to i32*
  store i32 1, i32* %75, align 8, !tbaa !21
  br label %76

; <label>:76:                                     ; preds = %73, %56
  %77 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %54, i64 0, i32 2
  br label %52

; <label>:78:                                     ; preds = %52, %26
  store i8* %13, i8** %7, align 8, !tbaa !48
  store i32 %1, i32* %4, align 4, !tbaa !51
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %11
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %79, i64 -5
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %80, %union.StackValue** %81, align 8, !tbaa !59
  br label %82

; <label>:82:                                     ; preds = %17, %78
  %83 = phi i32 [ 1, %78 ], [ 0, %17 ]
  ret i32 %83
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaM_realloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %8 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !45
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !46
  %11 = tail call i8* %8(i8* %10, i8* %1, i64 %2, i64 %3) #17
  %12 = icmp eq i8* %11, null
  %13 = icmp ne i64 %3, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %20, !prof !47

; <label>:15:                                     ; preds = %4
  %16 = icmp ugt i64 %3, %2
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %15
  %18 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* %1, i64 %2, i64 %3) #16
  %19 = icmp eq i8* %18, null
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %17, %4
  %21 = phi i8* [ %18, %17 ], [ %11, %4 ]
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = sub i64 %3, %2
  %25 = add i64 %24, %23
  store i64 %25, i64* %22, align 8, !tbaa !11
  br label %26

; <label>:26:                                     ; preds = %15, %17, %20
  %27 = phi i8* [ %21, %20 ], [ null, %17 ], [ null, %15 ]
  ret i8* %27
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.GCObject** @sweeplist(%struct.lua_State* nocapture readonly, %struct.GCObject**, i32, i32*) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 10
  %8 = load i8, i8* %7, align 4, !tbaa !15
  %9 = xor i8 %8, 24
  %10 = and i8 %8, 24
  br label %11

; <label>:11:                                     ; preds = %31, %4
  %12 = phi i32 [ 0, %4 ], [ %33, %31 ]
  %13 = phi %struct.GCObject** [ %1, %4 ], [ %32, %31 ]
  %14 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !39
  %15 = icmp ne %struct.GCObject* %14, null
  %16 = icmp slt i32 %12, %2
  %17 = and i1 %16, %15
  br i1 %17, label %18, label %34

; <label>:18:                                     ; preds = %11
  %19 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !67
  %21 = and i8 %20, %9
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %27, label %23

; <label>:23:                                     ; preds = %18
  %24 = bitcast %struct.GCObject* %14 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !152
  %26 = bitcast %struct.GCObject** %13 to i64*
  store i64 %25, i64* %26, align 8, !tbaa !39
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %14) #16
  br label %31

; <label>:27:                                     ; preds = %18
  %28 = and i8 %20, -64
  %29 = or i8 %28, %10
  store i8 %29, i8* %19, align 1, !tbaa !67
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 0, i32 0
  br label %31

; <label>:31:                                     ; preds = %27, %23
  %32 = phi %struct.GCObject** [ %13, %23 ], [ %30, %27 ]
  %33 = add nuw nsw i32 %12, 1
  br label %11

; <label>:34:                                     ; preds = %11
  %35 = icmp eq i32* %3, null
  br i1 %35, label %37, label %36

; <label>:36:                                     ; preds = %34
  store i32 %12, i32* %3, align 4, !tbaa !74
  br label %37

; <label>:37:                                     ; preds = %34, %36
  %38 = icmp eq %struct.GCObject* %14, null
  %39 = select i1 %38, %struct.GCObject** null, %struct.GCObject** %13
  ret %struct.GCObject** %39
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaS_resize(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 2
  %7 = load i32, i32* %6, align 4, !tbaa !85
  %8 = icmp sgt i32 %7, %1
  %9 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %5, i64 0, i32 0
  br i1 %8, label %10, label %12

; <label>:10:                                     ; preds = %2
  %11 = load %struct.TString**, %struct.TString*** %9, align 8, !tbaa !84
  tail call fastcc void @tablerehash(%struct.TString** %11, i32 %7, i32 %1) #16
  br label %12

; <label>:12:                                     ; preds = %2, %10
  %13 = bitcast %struct.stringtable* %5 to i8**
  %14 = load i8*, i8** %13, align 8, !tbaa !84
  %15 = sext i32 %7 to i64
  %16 = shl nsw i64 %15, 3
  %17 = sext i32 %1 to i64
  %18 = shl nsw i64 %17, 3
  %19 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* nonnull %0, i8* %14, i64 %16, i64 %18) #16
  %20 = bitcast i8* %19 to %struct.TString**
  %21 = icmp eq i8* %19, null
  br i1 %21, label %22, label %25, !prof !47

; <label>:22:                                     ; preds = %12
  br i1 %8, label %23, label %28

; <label>:23:                                     ; preds = %22
  %24 = load %struct.TString**, %struct.TString*** %9, align 8, !tbaa !84
  tail call fastcc void @tablerehash(%struct.TString** %24, i32 %1, i32 %7) #16
  br label %28

; <label>:25:                                     ; preds = %12
  store i8* %19, i8** %13, align 8, !tbaa !84
  store i32 %1, i32* %6, align 4, !tbaa !85
  %26 = icmp slt i32 %7, %1
  br i1 %26, label %27, label %28

; <label>:27:                                     ; preds = %25
  tail call fastcc void @tablerehash(%struct.TString** %20, i32 %7, i32 %1) #16
  br label %28

; <label>:28:                                     ; preds = %25, %27, %22, %23
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @propagateall(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  br label %3

; <label>:3:                                      ; preds = %7, %1
  %4 = phi i64 [ 0, %1 ], [ %9, %7 ]
  %5 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !225
  %6 = icmp eq %struct.GCObject* %5, null
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %0) #16
  %9 = add i64 %8, %4
  br label %3

; <label>:10:                                     ; preds = %3
  ret i64 %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @convergeephemerons(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  br label %3

; <label>:3:                                      ; preds = %19, %1
  %4 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !228
  store %struct.GCObject* null, %struct.GCObject** %2, align 8, !tbaa !228
  br label %5

; <label>:5:                                      ; preds = %17, %3
  %6 = phi i32 [ 1, %17 ], [ 0, %3 ]
  %7 = phi %struct.GCObject* [ %14, %17 ], [ %4, %3 ]
  br label %8

; <label>:8:                                      ; preds = %5, %11
  %9 = phi %struct.GCObject* [ %14, %11 ], [ %7, %5 ]
  %10 = icmp eq %struct.GCObject* %9, null
  br i1 %10, label %19, label %11

; <label>:11:                                     ; preds = %8
  %12 = bitcast %struct.GCObject* %9 to %struct.Table*
  %13 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %9, i64 3, i32 0
  %14 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !21
  %15 = tail call fastcc i32 @traverseephemeron(%struct.global_State* %0, %struct.Table* %12) #16
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %8, label %17

; <label>:17:                                     ; preds = %11
  %18 = tail call fastcc i64 @propagateall(%struct.global_State* %0) #16
  br label %5

; <label>:19:                                     ; preds = %8
  %20 = icmp eq i32 %6, 0
  br i1 %20, label %21, label %3

; <label>:21:                                     ; preds = %19
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @clearbyvalues(%struct.global_State*, %struct.GCObject* readonly, %struct.GCObject* readnone) unnamed_addr #0 {
  br label %4

; <label>:4:                                      ; preds = %66, %3
  %5 = phi %struct.GCObject* [ %1, %3 ], [ %68, %66 ]
  %6 = icmp eq %struct.GCObject* %5, %2
  br i1 %6, label %69, label %7

; <label>:7:                                      ; preds = %4
  %8 = bitcast %struct.GCObject* %5 to %struct.Table*
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1, i32 1
  %10 = bitcast i8* %9 to %union.Node**
  %11 = load %union.Node*, %union.Node** %10, align 8, !tbaa !147
  %12 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 4
  %13 = load i8, i8* %12, align 1, !tbaa !148
  %14 = zext i8 %13 to i32
  %15 = shl i32 1, %14
  %16 = sext i32 %15 to i64
  %17 = tail call fastcc i32 @luaH_realasize(%struct.Table* %8) #16
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1
  %19 = bitcast %struct.GCObject* %18 to %struct.TValue**
  %20 = zext i32 %17 to i64
  br label %21

; <label>:21:                                     ; preds = %38, %7
  %22 = phi i64 [ %39, %38 ], [ 0, %7 ]
  %23 = icmp eq i64 %22, %20
  br i1 %23, label %40, label %24

; <label>:24:                                     ; preds = %21
  %25 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !137
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 %22, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = and i8 %27, 64
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %33, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 %22, i32 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  br label %33

; <label>:33:                                     ; preds = %24, %30
  %34 = phi %struct.GCObject* [ %32, %30 ], [ null, %24 ]
  %35 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %34) #16
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %33
  store i8 16, i8* %26, align 8, !tbaa !22
  br label %38

; <label>:38:                                     ; preds = %33, %37
  %39 = add nuw nsw i64 %22, 1
  br label %21

; <label>:40:                                     ; preds = %21
  %41 = getelementptr inbounds %union.Node, %union.Node* %11, i64 %16
  %42 = load %union.Node*, %union.Node** %10, align 8, !tbaa !147
  br label %43

; <label>:43:                                     ; preds = %64, %40
  %44 = phi %union.Node* [ %42, %40 ], [ %65, %64 ]
  %45 = icmp ult %union.Node* %44, %41
  br i1 %45, label %46, label %66

; <label>:46:                                     ; preds = %43
  %47 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !21
  %49 = and i8 %48, 64
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %54, label %51

; <label>:51:                                     ; preds = %46
  %52 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 0, i32 0
  %53 = load %struct.GCObject*, %struct.GCObject** %52, align 8, !tbaa !21
  br label %54

; <label>:54:                                     ; preds = %46, %51
  %55 = phi %struct.GCObject* [ %53, %51 ], [ null, %46 ]
  %56 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %55) #16
  %57 = icmp eq i32 %56, 0
  br i1 %57, label %59, label %58

; <label>:58:                                     ; preds = %54
  store i8 16, i8* %47, align 8, !tbaa !21
  br label %63

; <label>:59:                                     ; preds = %54
  %60 = load i8, i8* %47, align 8, !tbaa !21
  %61 = and i8 %60, 15
  %62 = icmp eq i8 %61, 0
  br i1 %62, label %63, label %64

; <label>:63:                                     ; preds = %58, %59
  tail call fastcc void @clearkey(%union.Node* nonnull %44) #16
  br label %64

; <label>:64:                                     ; preds = %59, %63
  %65 = getelementptr inbounds %union.Node, %union.Node* %44, i64 1
  br label %43

; <label>:66:                                     ; preds = %43
  %67 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 3, i32 0
  %68 = load %struct.GCObject*, %struct.GCObject** %67, align 8, !tbaa !21
  br label %4

; <label>:69:                                     ; preds = %4
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @clearbykeys(%struct.global_State*, %struct.GCObject* readonly) unnamed_addr #0 {
  br label %3

; <label>:3:                                      ; preds = %41, %2
  %4 = phi %struct.GCObject* [ %1, %2 ], [ %43, %41 ]
  %5 = icmp eq %struct.GCObject* %4, null
  br i1 %5, label %44, label %6

; <label>:6:                                      ; preds = %3
  %7 = bitcast %struct.GCObject* %4 to %struct.Table*
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 1, i32 1
  %9 = bitcast i8* %8 to %union.Node**
  %10 = load %union.Node*, %union.Node** %9, align 8, !tbaa !147
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %7, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !148
  %13 = zext i8 %12 to i32
  %14 = shl i32 1, %13
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds %union.Node, %union.Node* %10, i64 %15
  br label %17

; <label>:17:                                     ; preds = %39, %6
  %18 = phi %union.Node* [ %10, %6 ], [ %40, %39 ]
  %19 = icmp ult %union.Node* %18, %16
  br i1 %19, label %20, label %41

; <label>:20:                                     ; preds = %17
  %21 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 2
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = and i8 %22, 64
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %20
  %26 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4, i32 0
  %27 = load %struct.GCObject*, %struct.GCObject** %26, align 8, !tbaa !21
  br label %28

; <label>:28:                                     ; preds = %20, %25
  %29 = phi %struct.GCObject* [ %27, %25 ], [ null, %20 ]
  %30 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %29) #16
  %31 = icmp eq i32 %30, 0
  %32 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 1
  br i1 %31, label %34, label %33

; <label>:33:                                     ; preds = %28
  store i8 16, i8* %32, align 8, !tbaa !21
  br label %38

; <label>:34:                                     ; preds = %28
  %35 = load i8, i8* %32, align 8, !tbaa !21
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %39

; <label>:38:                                     ; preds = %33, %34
  tail call fastcc void @clearkey(%union.Node* nonnull %18) #16
  br label %39

; <label>:39:                                     ; preds = %34, %38
  %40 = getelementptr inbounds %union.Node, %union.Node* %18, i64 1
  br label %17

; <label>:41:                                     ; preds = %17
  %42 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 3, i32 0
  %43 = load %struct.GCObject*, %struct.GCObject** %42, align 8, !tbaa !21
  br label %3

; <label>:44:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @sweep2old(%struct.lua_State*, %struct.GCObject** nocapture) unnamed_addr #0 {
  br label %3

; <label>:3:                                      ; preds = %17, %2
  %4 = phi %struct.GCObject** [ %21, %17 ], [ %1, %2 ]
  %5 = bitcast %struct.GCObject** %4 to i64*
  br label %6

; <label>:6:                                      ; preds = %3, %14
  %7 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !39
  %8 = icmp eq %struct.GCObject* %7, null
  br i1 %8, label %22, label %9

; <label>:9:                                      ; preds = %6
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !67
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %9
  %15 = bitcast %struct.GCObject* %7 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !152
  store i64 %16, i64* %5, align 8, !tbaa !39
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %7) #16
  br label %6

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %19 = and i8 %11, -8
  %20 = or i8 %19, 4
  store i8 %20, i8* %18, align 1, !tbaa !67
  %21 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  br label %3

; <label>:22:                                     ; preds = %6
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @finishgencycle(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 24
  %4 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** nonnull %3) #17
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 25
  %6 = bitcast %struct.GCObject** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !226
  %8 = bitcast %struct.GCObject** %4 to i64*
  store i64 %7, i64* %8, align 8, !tbaa !39
  store %struct.GCObject* null, %struct.GCObject** %5, align 8, !tbaa !226
  %9 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %4) #17
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 27
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !227
  %13 = bitcast %struct.GCObject** %9 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !39
  store %struct.GCObject* null, %struct.GCObject** %10, align 8, !tbaa !227
  %14 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %9) #17
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 26
  %16 = bitcast %struct.GCObject** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !228
  %18 = bitcast %struct.GCObject** %14 to i64*
  store i64 %17, i64* %18, align 8, !tbaa !39
  store %struct.GCObject* null, %struct.GCObject** %15, align 8, !tbaa !228
  %19 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %14) #17
  tail call fastcc void @checkSizes(%struct.lua_State* %0, %struct.global_State* %1) #16
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 0, i8* %20, align 1, !tbaa !44
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %22 = load i8, i8* %21, align 2, !tbaa !78
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %25

; <label>:24:                                     ; preds = %2
  tail call fastcc void @callallpendingfinalizers(%struct.lua_State* %0) #16
  br label %25

; <label>:25:                                     ; preds = %2, %24
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc %struct.GCObject** @correctgraylist(%struct.GCObject**) unnamed_addr #2 {
  br label %2

; <label>:2:                                      ; preds = %22, %1
  %3 = phi %struct.GCObject** [ %0, %1 ], [ %23, %22 ]
  %4 = bitcast %struct.GCObject** %3 to i64*
  %5 = bitcast %struct.GCObject** %3 to i64*
  br label %6

; <label>:6:                                      ; preds = %46, %2
  %7 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !39
  %8 = icmp eq %struct.GCObject* %7, null
  br i1 %8, label %49, label %9

; <label>:9:                                      ; preds = %6
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !217
  switch i8 %11, label %46 [
    i8 5, label %12
    i8 7, label %12
    i8 8, label %37
  ]

; <label>:12:                                     ; preds = %9, %9
  %13 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %7) #16
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %15 = load i8, i8* %14, align 1, !tbaa !67
  %16 = zext i8 %15 to i32
  %17 = and i32 %16, 7
  %18 = icmp eq i32 %17, 5
  br i1 %18, label %19, label %24

; <label>:19:                                     ; preds = %12
  %20 = or i8 %15, 32
  %21 = xor i8 %20, 3
  store i8 %21, i8* %14, align 1, !tbaa !67
  br label %22

; <label>:22:                                     ; preds = %19, %47
  %23 = phi %struct.GCObject** [ %48, %47 ], [ %13, %19 ]
  br label %2

; <label>:24:                                     ; preds = %12
  %25 = and i32 %16, 24
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %27, label %34

; <label>:27:                                     ; preds = %24
  %28 = icmp eq i32 %17, 6
  br i1 %28, label %29, label %31

; <label>:29:                                     ; preds = %27
  %30 = xor i8 %15, 2
  store i8 %30, i8* %14, align 1, !tbaa !67
  br label %31

; <label>:31:                                     ; preds = %29, %27
  %32 = phi i8 [ %30, %29 ], [ %15, %27 ]
  %33 = or i8 %32, 32
  store i8 %33, i8* %14, align 1, !tbaa !67
  br label %34

; <label>:34:                                     ; preds = %24, %31
  %35 = bitcast %struct.GCObject** %13 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !39
  store i64 %36, i64* %5, align 8, !tbaa !39
  br label %46

; <label>:37:                                     ; preds = %9
  %38 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %39 = load i8, i8* %38, align 1, !tbaa !16
  %40 = and i8 %39, 24
  %41 = icmp eq i8 %40, 0
  %42 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 4, i32 1
  br i1 %41, label %47, label %43

; <label>:43:                                     ; preds = %37
  %44 = bitcast i8* %42 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !233
  store i64 %45, i64* %4, align 8, !tbaa !39
  br label %46

; <label>:46:                                     ; preds = %43, %34, %9
  br label %6

; <label>:47:                                     ; preds = %37
  %48 = bitcast i8* %42 to %struct.GCObject**
  br label %22

; <label>:49:                                     ; preds = %6
  ret %struct.GCObject** %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* nocapture readonly, %struct.GCObject**) unnamed_addr #0 {
  br label %3

; <label>:3:                                      ; preds = %3, %2
  %4 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** %1, i32 1, i32* null) #16
  %5 = icmp eq %struct.GCObject** %4, %1
  br i1 %5, label %3, label %6

; <label>:6:                                      ; preds = %3
  ret %struct.GCObject** %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @entergen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 256) #16
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 1) #16
  %3 = tail call fastcc i64 @atomic(%struct.lua_State* %0) #16
  tail call fastcc void @atomic2gen(%struct.lua_State* %0, %struct.global_State* %1) #16
  ret i64 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @markold(%struct.global_State*, %struct.GCObject*, %struct.GCObject* readnone) unnamed_addr #0 {
  br label %4

; <label>:4:                                      ; preds = %14, %3
  %5 = phi %struct.GCObject* [ %1, %3 ], [ %16, %14 ]
  %6 = icmp eq %struct.GCObject* %5, %2
  br i1 %6, label %17, label %7

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !67
  %10 = and i8 %9, 39
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %7
  %13 = and i8 %9, -33
  store i8 %13, i8* %8, align 1, !tbaa !67
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %5) #16
  br label %14

; <label>:14:                                     ; preds = %7, %12
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 0, i32 0
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !152
  br label %4

; <label>:17:                                     ; preds = %4
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.GCObject** @sweepgen(%struct.lua_State*, %struct.global_State* nocapture readonly, %struct.GCObject**, %struct.GCObject* readnone) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 10
  %6 = load i8, i8* %5, align 4, !tbaa !15
  %7 = and i8 %6, 24
  br label %8

; <label>:8:                                      ; preds = %31, %4
  %9 = phi %struct.GCObject** [ %39, %31 ], [ %2, %4 ]
  %10 = bitcast %struct.GCObject** %9 to i64*
  br label %11

; <label>:11:                                     ; preds = %8, %20
  %12 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !39
  %13 = icmp eq %struct.GCObject* %12, %3
  br i1 %13, label %40, label %14

; <label>:14:                                     ; preds = %11
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !67
  %17 = zext i8 %16 to i32
  %18 = and i32 %17, 24
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %23, label %20

; <label>:20:                                     ; preds = %14
  %21 = bitcast %struct.GCObject* %12 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !152
  store i64 %22, i64* %10, align 8, !tbaa !39
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %12) #16
  br label %11

; <label>:23:                                     ; preds = %14
  %24 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 2
  %25 = zext i8 %16 to i32
  %26 = and i32 %25, 7
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %31

; <label>:28:                                     ; preds = %23
  %29 = and i8 %16, -57
  %30 = or i8 %29, %7
  store i8 %30, i8* %24, align 1, !tbaa !67
  br label %31

; <label>:31:                                     ; preds = %28, %23
  %32 = phi i8 [ %30, %28 ], [ %16, %23 ]
  %33 = and i8 %32, -8
  %34 = and i8 %32, 7
  %35 = zext i8 %34 to i64
  %36 = getelementptr inbounds [7 x i8], [7 x i8]* @sweepgen.nextage, i64 0, i64 %35
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = or i8 %33, %37
  store i8 %38, i8* %24, align 1, !tbaa !67
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 0
  br label %8

; <label>:40:                                     ; preds = %11
  ret %struct.GCObject** %9
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @currentpc(%struct.CallInfo* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 4
  %3 = bitcast %union.anon.0* %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !21
  %5 = bitcast %struct.CallInfo* %0 to %struct.LClosure***
  %6 = load %struct.LClosure**, %struct.LClosure*** %5, align 8, !tbaa !61
  %7 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 5
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = bitcast i32** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !119
  %13 = sub i64 %4, %12
  %14 = lshr exact i64 %13, 2
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, -1
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @currentline(%struct.CallInfo* nocapture readonly) unnamed_addr #12 {
  %2 = bitcast %struct.CallInfo* %0 to %struct.LClosure***
  %3 = load %struct.LClosure**, %struct.LClosure*** %2, align 8, !tbaa !61
  %4 = load %struct.LClosure*, %struct.LClosure** %3, align 8, !tbaa !21
  %5 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4, i64 0, i32 5
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !21
  %7 = tail call fastcc i32 @currentpc(%struct.CallInfo* %0) #16
  %8 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %6, i32 %7) #16
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaO_chunkid(i8* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = load i8, i8* %1, align 1, !tbaa !21
  switch i8 %4, label %20 [
    i8 61, label %5
    i8 64, label %11
  ]

; <label>:5:                                      ; preds = %3
  %6 = icmp ult i64 %2, 61
  %7 = getelementptr inbounds i8, i8* %1, i64 1
  br i1 %6, label %8, label %9

; <label>:8:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 %2, i32 1, i1 false)
  br label %39

; <label>:9:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 59, i32 1, i1 false)
  %10 = getelementptr inbounds i8, i8* %0, i64 59
  store i8 0, i8* %10, align 1, !tbaa !21
  br label %39

; <label>:11:                                     ; preds = %3
  %12 = icmp ult i64 %2, 61
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds i8, i8* %1, i64 1
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %14, i64 %2, i32 1, i1 false)
  br label %39

; <label>:15:                                     ; preds = %11
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %16 = getelementptr inbounds i8, i8* %0, i64 3
  %17 = getelementptr inbounds i8, i8* %1, i64 1
  %18 = getelementptr inbounds i8, i8* %17, i64 %2
  %19 = getelementptr inbounds i8, i8* %18, i64 -57
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %16, i8* nonnull %19, i64 57, i32 1, i1 false)
  br label %39

; <label>:20:                                     ; preds = %3
  %21 = tail call i8* @strchr(i8* nonnull %1, i32 10) #21
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.150, i64 0, i64 0), i64 9, i32 1, i1 false)
  %22 = getelementptr inbounds i8, i8* %0, i64 9
  %23 = icmp ult i64 %2, 45
  %24 = icmp eq i8* %21, null
  %25 = and i1 %23, %24
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %20
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %2, i32 1, i1 false)
  %27 = getelementptr inbounds i8, i8* %22, i64 %2
  br label %37

; <label>:28:                                     ; preds = %20
  %29 = ptrtoint i8* %21 to i64
  %30 = ptrtoint i8* %1 to i64
  %31 = sub i64 %29, %30
  %32 = select i1 %24, i64 %2, i64 %31
  %33 = icmp ult i64 %32, 45
  %34 = select i1 %33, i64 %32, i64 45
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %34, i32 1, i1 false)
  %35 = getelementptr inbounds i8, i8* %22, i64 %34
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %35, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %36 = getelementptr inbounds i8, i8* %35, i64 3
  br label %37

; <label>:37:                                     ; preds = %28, %26
  %38 = phi i8* [ %27, %26 ], [ %36, %28 ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %38, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.151, i64 0, i64 0), i64 3, i32 1, i1 false)
  br label %39

; <label>:39:                                     ; preds = %37, %15, %13, %8, %9
  ret void
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @luaG_getfuncline(%struct.Proto* nocapture readonly, i32) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %4 = load i8*, i8** %3, align 8, !tbaa !124
  %5 = icmp eq i8* %4, null
  br i1 %5, label %61, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %8 = load i32, i32* %7, align 8, !tbaa !224
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %12 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %11, align 8, !tbaa !223
  %13 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 0, i32 0
  %14 = load i32, i32* %13, align 4, !tbaa !236
  %15 = icmp sgt i32 %14, %1
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %10, %6
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  br label %46

; <label>:18:                                     ; preds = %10
  %19 = add nsw i32 %8, -1
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %20, i32 0
  %22 = load i32, i32* %21, align 4, !tbaa !236
  %23 = icmp sgt i32 %22, %1
  br i1 %23, label %24, label %39

; <label>:24:                                     ; preds = %18
  br label %25

; <label>:25:                                     ; preds = %24, %30
  %26 = phi i32 [ %37, %30 ], [ 0, %24 ]
  %27 = phi i32 [ %38, %30 ], [ %19, %24 ]
  %28 = add i32 %27, -1
  %29 = icmp ult i32 %26, %28
  br i1 %29, label %30, label %39

; <label>:30:                                     ; preds = %25
  %31 = add i32 %27, %26
  %32 = lshr i32 %31, 1
  %33 = zext i32 %32 to i64
  %34 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %33, i32 0
  %35 = load i32, i32* %34, align 4, !tbaa !236
  %36 = icmp sgt i32 %35, %1
  %37 = select i1 %36, i32 %26, i32 %32
  %38 = select i1 %36, i32 %32, i32 %27
  br label %25

; <label>:39:                                     ; preds = %25, %18
  %40 = phi i32 [ %19, %18 ], [ %26, %25 ]
  %41 = zext i32 %40 to i64
  %42 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %41, i32 0
  %43 = load i32, i32* %42, align 4, !tbaa !236
  %44 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %41, i32 1
  %45 = sext i32 %43 to i64
  br label %46

; <label>:46:                                     ; preds = %16, %39
  %47 = phi i64 [ -1, %16 ], [ %45, %39 ]
  %48 = phi i32* [ %17, %16 ], [ %44, %39 ]
  %49 = load i32, i32* %48, align 4, !tbaa !74
  %50 = sext i32 %1 to i64
  br label %51

; <label>:51:                                     ; preds = %56, %46
  %52 = phi i64 [ %54, %56 ], [ %47, %46 ]
  %53 = phi i32 [ %60, %56 ], [ %49, %46 ]
  %54 = add nsw i64 %52, 1
  %55 = icmp slt i64 %52, %50
  br i1 %55, label %56, label %61

; <label>:56:                                     ; preds = %51
  %57 = getelementptr inbounds i8, i8* %4, i64 %54
  %58 = load i8, i8* %57, align 1, !tbaa !21
  %59 = sext i8 %58 to i32
  %60 = add nsw i32 %53, %59
  br label %51

; <label>:61:                                     ; preds = %51, %2
  %62 = phi i32 [ -1, %2 ], [ %53, %51 ]
  ret i32 %62
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @getobjname(%struct.Proto* nocapture readonly, i32, i32, i8** nocapture) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  br label %6

; <label>:6:                                      ; preds = %72, %4
  %7 = phi i32 [ %1, %4 ], [ %17, %72 ]
  %8 = phi i32 [ %2, %4 ], [ %74, %72 ]
  %9 = add nsw i32 %8, 1
  %10 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %0, i32 %9, i32 %7) #16
  store i8* %10, i8** %3, align 8, !tbaa !39
  %11 = icmp eq i8* %10, null
  br i1 %11, label %12, label %131

; <label>:12:                                     ; preds = %6
  %13 = sext i32 %7 to i64
  br label %14

; <label>:14:                                     ; preds = %60, %12
  %15 = phi i64 [ %63, %60 ], [ 0, %12 ]
  %16 = phi i32 [ %61, %60 ], [ 0, %12 ]
  %17 = phi i32 [ %62, %60 ], [ -1, %12 ]
  %18 = icmp slt i64 %15, %13
  br i1 %18, label %19, label %64

; <label>:19:                                     ; preds = %14
  %20 = load i32*, i32** %5, align 8, !tbaa !119
  %21 = getelementptr inbounds i32, i32* %20, i64 %15
  %22 = load i32, i32* %21, align 4, !tbaa !74
  %23 = lshr i32 %22, 7
  %24 = and i32 %23, 255
  %25 = trunc i32 %22 to i7
  switch i7 %25, label %41 [
    i7 6, label %26
    i7 -51, label %28
    i7 -59, label %31
    i7 -58, label %31
    i7 57, label %33
  ]

; <label>:26:                                     ; preds = %19
  %27 = icmp sgt i32 %24, %8
  br i1 %27, label %60, label %50

; <label>:28:                                     ; preds = %19
  %29 = add nuw nsw i32 %24, 2
  %30 = icmp sgt i32 %29, %8
  br i1 %30, label %60, label %55

; <label>:31:                                     ; preds = %19, %19
  %32 = icmp sgt i32 %24, %8
  br i1 %32, label %60, label %55

; <label>:33:                                     ; preds = %19
  %34 = trunc i64 %15 to i32
  %35 = add i32 %34, -16777214
  %36 = add i32 %35, %23
  %37 = icmp sle i32 %36, %7
  %38 = icmp sgt i32 %36, %16
  %39 = and i1 %37, %38
  %40 = select i1 %39, i32 %36, i32 %16
  br label %60

; <label>:41:                                     ; preds = %19
  %42 = and i32 %22, 127
  %43 = zext i32 %42 to i64
  %44 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %43
  %45 = load i8, i8* %44, align 1, !tbaa !21
  %46 = and i8 %45, 8
  %47 = icmp ne i8 %46, 0
  %48 = icmp eq i32 %24, %8
  %49 = and i1 %48, %47
  br i1 %49, label %55, label %60

; <label>:50:                                     ; preds = %26
  %51 = lshr i32 %22, 16
  %52 = and i32 %51, 255
  %53 = add nuw nsw i32 %24, %52
  %54 = icmp slt i32 %53, %8
  br i1 %54, label %60, label %55

; <label>:55:                                     ; preds = %50, %41, %31, %28
  %56 = sext i32 %16 to i64
  %57 = icmp slt i64 %15, %56
  %58 = trunc i64 %15 to i32
  %59 = select i1 %57, i32 -1, i32 %58
  br label %60

; <label>:60:                                     ; preds = %55, %50, %41, %33, %31, %28, %26
  %61 = phi i32 [ %16, %55 ], [ %16, %50 ], [ %16, %41 ], [ %16, %31 ], [ %16, %28 ], [ %40, %33 ], [ %16, %26 ]
  %62 = phi i32 [ %59, %55 ], [ %17, %50 ], [ %17, %41 ], [ %17, %31 ], [ %17, %28 ], [ %17, %33 ], [ %17, %26 ]
  %63 = add nuw nsw i64 %15, 1
  br label %14

; <label>:64:                                     ; preds = %14
  %65 = icmp eq i32 %17, -1
  br i1 %65, label %131, label %66

; <label>:66:                                     ; preds = %64
  %67 = load i32*, i32** %5, align 8, !tbaa !119
  %68 = sext i32 %17 to i64
  %69 = getelementptr inbounds i32, i32* %67, i64 %68
  %70 = load i32, i32* %69, align 4, !tbaa !74
  %71 = trunc i32 %70 to i7
  switch i7 %71, label %131 [
    i7 0, label %72
    i7 9, label %78
    i7 10, label %81
    i7 11, label %84
    i7 12, label %85
    i7 7, label %88
    i7 3, label %100
    i7 4, label %100
    i7 18, label %125
  ]

; <label>:72:                                     ; preds = %66
  %73 = lshr i32 %70, 16
  %74 = and i32 %73, 255
  %75 = lshr i32 %70, 7
  %76 = and i32 %75, 255
  %77 = icmp ult i32 %74, %76
  br i1 %77, label %6, label %131

; <label>:78:                                     ; preds = %66
  %79 = lshr i32 %70, 24
  tail call fastcc void @kname(%struct.Proto* nonnull %0, i32 %79, i8** %3) #16
  %80 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %70, i32 1) #16
  br label %131

; <label>:81:                                     ; preds = %66
  %82 = lshr i32 %70, 24
  tail call fastcc void @rname(%struct.Proto* nonnull %0, i32 %17, i32 %82, i8** %3) #16
  %83 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %70, i32 0) #16
  br label %131

; <label>:84:                                     ; preds = %66
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.157, i64 0, i64 0), i8** %3, align 8, !tbaa !39
  br label %131

; <label>:85:                                     ; preds = %66
  %86 = lshr i32 %70, 24
  tail call fastcc void @kname(%struct.Proto* nonnull %0, i32 %86, i8** %3) #16
  %87 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %70, i32 0) #16
  br label %131

; <label>:88:                                     ; preds = %66
  %89 = lshr i32 %70, 16
  %90 = and i32 %89, 255
  %91 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %92 = load %struct.Upvaldesc*, %struct.Upvaldesc** %91, align 8, !tbaa !193
  %93 = zext i32 %90 to i64
  %94 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %92, i64 %93, i32 0
  %95 = load %struct.TString*, %struct.TString** %94, align 8, !tbaa !194
  %96 = icmp eq %struct.TString* %95, null
  %97 = getelementptr inbounds %struct.TString, %struct.TString* %95, i64 1
  %98 = bitcast %struct.TString* %97 to i8*
  %99 = select i1 %96, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %98
  store i8* %99, i8** %3, align 8, !tbaa !39
  br label %131

; <label>:100:                                    ; preds = %66, %66
  %101 = and i32 %70, 127
  %102 = icmp eq i32 %101, 3
  br i1 %102, label %103, label %105

; <label>:103:                                    ; preds = %100
  %104 = lshr i32 %70, 15
  br label %111

; <label>:105:                                    ; preds = %100
  %106 = add nsw i32 %17, 1
  %107 = sext i32 %106 to i64
  %108 = getelementptr inbounds i32, i32* %67, i64 %107
  %109 = load i32, i32* %108, align 4, !tbaa !74
  %110 = lshr i32 %109, 7
  br label %111

; <label>:111:                                    ; preds = %105, %103
  %112 = phi i32 [ %104, %103 ], [ %110, %105 ]
  %113 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %114 = load %struct.TValue*, %struct.TValue** %113, align 8, !tbaa !221
  %115 = zext i32 %112 to i64
  %116 = getelementptr inbounds %struct.TValue, %struct.TValue* %114, i64 %115, i32 1
  %117 = load i8, i8* %116, align 8, !tbaa !22
  %118 = and i8 %117, 15
  %119 = icmp eq i8 %118, 4
  br i1 %119, label %120, label %131

; <label>:120:                                    ; preds = %111
  %121 = getelementptr inbounds %struct.TValue, %struct.TValue* %114, i64 %115, i32 0, i32 0
  %122 = bitcast %struct.GCObject** %121 to i8**
  %123 = load i8*, i8** %122, align 8, !tbaa !21
  %124 = getelementptr inbounds i8, i8* %123, i64 24
  store i8* %124, i8** %3, align 8, !tbaa !39
  br label %131

; <label>:125:                                    ; preds = %66
  %126 = lshr i32 %70, 24
  %127 = trunc i32 %70 to i16
  %128 = icmp slt i16 %127, 0
  br i1 %128, label %129, label %130

; <label>:129:                                    ; preds = %125
  tail call fastcc void @kname(%struct.Proto* nonnull %0, i32 %126, i8** %3) #17
  br label %131

; <label>:130:                                    ; preds = %125
  tail call fastcc void @rname(%struct.Proto* nonnull %0, i32 %17, i32 %126, i8** %3) #17
  br label %131

; <label>:131:                                    ; preds = %72, %64, %66, %6, %130, %129, %120, %78, %81, %84, %85, %88, %111
  %132 = phi i8* [ null, %111 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %130 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %129 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.160, i64 0, i64 0), %120 ], [ %80, %78 ], [ %83, %81 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %84 ], [ %87, %85 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %88 ], [ null, %72 ], [ null, %64 ], [ null, %66 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i64 0, i64 0), %6 ]
  ret i8* %132
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @kname(%struct.Proto* nocapture readonly, i32, i8** nocapture) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !221
  %6 = sext i32 %1 to i64
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 %6, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 4
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 %6, i32 0, i32 0
  %13 = bitcast %struct.GCObject** %12 to i8**
  %14 = load i8*, i8** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds i8, i8* %14, i64 24
  br label %16

; <label>:16:                                     ; preds = %3, %11
  %17 = phi i8* [ %15, %11 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %3 ]
  store i8* %17, i8** %2, align 8, !tbaa !39
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @gxf(%struct.Proto* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = lshr i32 %2, 16
  %7 = and i32 %6, 255
  %8 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %20, label %10

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %12 = load %struct.Upvaldesc*, %struct.Upvaldesc** %11, align 8, !tbaa !193
  %13 = zext i32 %7 to i64
  %14 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %12, i64 %13, i32 0
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !194
  %16 = icmp eq %struct.TString* %15, null
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = select i1 %16, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %18
  store i8* %19, i8** %5, align 8, !tbaa !39
  br label %24

; <label>:20:                                     ; preds = %4
  %21 = call fastcc i8* @getobjname(%struct.Proto* %0, i32 %1, i32 %7, i8** nonnull %5) #16
  %22 = load i8*, i8** %5, align 8, !tbaa !39
  %23 = icmp eq i8* %22, null
  br i1 %23, label %29, label %24

; <label>:24:                                     ; preds = %10, %20
  %25 = phi i8* [ %19, %10 ], [ %22, %20 ]
  %26 = tail call i32 @strcmp(i8* nonnull %25, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0)) #21
  %27 = icmp eq i32 %26, 0
  %28 = select i1 %27, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.161, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0)
  br label %29

; <label>:29:                                     ; preds = %20, %24
  %30 = phi i8* [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %20 ], [ %28, %24 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  ret i8* %30
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @rname(%struct.Proto* nocapture readonly, i32, i32, i8** nocapture) unnamed_addr #0 {
  %5 = tail call fastcc i8* @getobjname(%struct.Proto* %0, i32 %1, i32 %2, i8** %3) #16
  %6 = icmp eq i8* %5, null
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = load i8, i8* %5, align 1, !tbaa !21
  %9 = icmp eq i8 %8, 99
  br i1 %9, label %11, label %10

; <label>:10:                                     ; preds = %4, %7
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8** %3, align 8, !tbaa !39
  br label %11

; <label>:11:                                     ; preds = %10, %7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @prepclosingmethod(%struct.lua_State* nocapture, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 24) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %32, label %11

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %6 to i64*
  %13 = bitcast %union.StackValue* %5 to i64*
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %13, align 8
  %15 = load i8, i8* %7, align 8, !tbaa !22
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 0, i32 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0
  %18 = bitcast %struct.TValue* %1 to i64*
  %19 = bitcast %struct.TValue* %17 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0
  %25 = bitcast %struct.TValue* %2 to i64*
  %26 = bitcast %struct.TValue* %24 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !22
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 3
  store %union.StackValue* %31, %union.StackValue** %4, align 8, !tbaa !20
  br label %32

; <label>:32:                                     ; preds = %3, %11
  %33 = phi i32 [ 1, %11 ], [ 0, %3 ]
  ret i32 %33
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @callclose(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0) #16
  ret void
}

; Function Attrs: minsize nounwind optsize returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) local_unnamed_addr #13

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaV_execute(%struct.lua_State*, %struct.CallInfo*) #0 {
  %3 = alloca double, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = alloca %struct.TValue, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca i64, align 8
  %15 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca i64, align 8
  %21 = alloca i64, align 8
  %22 = alloca i64, align 8
  %23 = alloca double, align 8
  %24 = alloca double, align 8
  %25 = alloca double, align 8
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %28 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %30 = bitcast %union.anon.0* %29 to %struct.anon*
  %31 = bitcast %union.anon.0* %29 to i32**
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %33 = bitcast %union.StackValue** %32 to i64*
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %35 = bitcast %union.StackValue** %34 to i64*
  %36 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %37 = bitcast i64* %36 to i32*
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %39 = getelementptr inbounds %struct.anon, %struct.anon* %30, i64 0, i32 2
  %40 = bitcast %struct.CallInfo* %1 to i64*
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %42 = bitcast %union.StackValue** %41 to i64*
  %43 = bitcast %struct.TValue* %4 to i64*
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %45 = bitcast %struct.TValue* %5 to i64*
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %47 = bitcast %struct.CallInfo* %1 to %struct.TValue**
  %48 = bitcast double* %24 to i64*
  %49 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %50 = bitcast %union.StackValue** %49 to i64*
  %51 = bitcast double* %25 to i64*
  %52 = bitcast %union.StackValue** %49 to i8**
  %53 = bitcast double* %3 to i8*
  %54 = bitcast double* %23 to i64*
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %56 = bitcast double* %3 to i64*
  %57 = bitcast %union.anon.0* %29 to i64*
  %58 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  br label %59

; <label>:59:                                     ; preds = %3302, %2
  %60 = load i32, i32* %26, align 8, !tbaa !23
  %61 = load %struct.LClosure**, %struct.LClosure*** %28, align 8, !tbaa !61
  %62 = load %struct.LClosure*, %struct.LClosure** %61, align 8, !tbaa !21
  %63 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 5
  %64 = load %struct.Proto*, %struct.Proto** %63, align 8, !tbaa !192
  %65 = getelementptr inbounds %struct.Proto, %struct.Proto* %64, i64 0, i32 15
  %66 = load %struct.TValue*, %struct.TValue** %65, align 8, !tbaa !221
  %67 = load i32*, i32** %31, align 8, !tbaa !21
  %68 = icmp eq i32 %60, 0
  %69 = bitcast %struct.LClosure** %61 to %union.StackValue*
  br i1 %68, label %83, label %70

; <label>:70:                                     ; preds = %59
  %71 = getelementptr inbounds %struct.Proto, %struct.Proto* %64, i64 0, i32 4
  %72 = load i8, i8* %71, align 1, !tbaa !102
  %73 = icmp eq i8 %72, 0
  br i1 %73, label %74, label %79

; <label>:74:                                     ; preds = %70
  %75 = getelementptr inbounds %struct.Proto, %struct.Proto* %64, i64 0, i32 16
  %76 = load i32*, i32** %75, align 8, !tbaa !119
  %77 = icmp eq i32* %67, %76
  br i1 %77, label %78, label %80

; <label>:78:                                     ; preds = %74
  call fastcc void @luaD_hookcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1) #16
  br label %80

; <label>:79:                                     ; preds = %70
  store i32 1, i32* %37, align 8, !tbaa !21
  br label %83

; <label>:80:                                     ; preds = %78, %74
  store i32 1, i32* %37, align 8, !tbaa !21
  %81 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %67) #16
  %82 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  br label %83

; <label>:83:                                     ; preds = %59, %79, %80
  %84 = phi %union.StackValue* [ %82, %80 ], [ %69, %79 ], [ %69, %59 ]
  %85 = phi i32 [ %81, %80 ], [ 0, %79 ], [ 0, %59 ]
  %86 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 1
  %87 = getelementptr inbounds i32, i32* %67, i64 1
  %88 = load i32, i32* %67, align 4, !tbaa !74
  br label %4011

; <label>:89:                                     ; preds = %4011
  %90 = lshr i32 %4012, 16
  %91 = and i32 %90, 255
  %92 = zext i32 %91 to i64
  %93 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %92, i32 0
  %94 = bitcast %struct.TValue* %93 to i64*
  %95 = bitcast %union.StackValue* %4019 to i64*
  %96 = load i64, i64* %94, align 8
  store i64 %96, i64* %95, align 8
  %97 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %92, i32 0, i32 1
  %98 = load i8, i8* %97, align 8, !tbaa !22
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %98, i8* %99, align 8, !tbaa !22
  %100 = icmp eq i32 %4014, 0
  br i1 %100, label %105, label %101

; <label>:101:                                    ; preds = %89
  %102 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %103 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %104 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 1
  br label %105

; <label>:105:                                    ; preds = %89, %101
  %106 = phi i32 [ %102, %101 ], [ 0, %89 ]
  %107 = phi %union.StackValue* [ %104, %101 ], [ %4013, %89 ]
  %108 = getelementptr inbounds i32, i32* %4015, i64 1
  %109 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:110:                                    ; preds = %105, %130, %146, %162, %184, %202, %223, %247, %289, %335, %408, %462, %505, %577, %673, %750, %816, %865, %918, %959, %998, %1039, %1078, %1116, %1154, %1194, %1255, %1314, %1375, %1434, %1482, %1530, %1590, %1649, %1708, %1767, %1826, %1874, %1922, %1982, %2024, %2066, %2108, %2158, %2208, %2258, %2306, %2346, %2397, %2447, %2481, %2517, %2547, %2564, %2586, %2600, %2611, %2627, %2657, %2721, %2785, %2817, %2863, %2915, %2967, %3019, %3071, %3113, %3164, %3185, %3453, %3605, %3673, %3766, %3840, %3916, %3993, %4005
  %111 = phi i32 [ %109, %105 ], [ %134, %130 ], [ %150, %146 ], [ %166, %162 ], [ %188, %184 ], [ %206, %202 ], [ %227, %223 ], [ %251, %247 ], [ %293, %289 ], [ %339, %335 ], [ %412, %408 ], [ %466, %462 ], [ %509, %505 ], [ %581, %577 ], [ %677, %673 ], [ %754, %750 ], [ %820, %816 ], [ %869, %865 ], [ %922, %918 ], [ %963, %959 ], [ %1002, %998 ], [ %1043, %1039 ], [ %1082, %1078 ], [ %1120, %1116 ], [ %1158, %1154 ], [ %1198, %1194 ], [ %1259, %1255 ], [ %1318, %1314 ], [ %1379, %1375 ], [ %1438, %1434 ], [ %1486, %1482 ], [ %1534, %1530 ], [ %1594, %1590 ], [ %1653, %1649 ], [ %1712, %1708 ], [ %1771, %1767 ], [ %1830, %1826 ], [ %1878, %1874 ], [ %1926, %1922 ], [ %1986, %1982 ], [ %2028, %2024 ], [ %2070, %2066 ], [ %2112, %2108 ], [ %2162, %2158 ], [ %2212, %2208 ], [ %2262, %2258 ], [ %2310, %2306 ], [ %2350, %2346 ], [ %2401, %2397 ], [ %2451, %2447 ], [ %2485, %2481 ], [ %2521, %2517 ], [ %2551, %2547 ], [ %2568, %2564 ], [ %2590, %2586 ], [ %2604, %2600 ], [ %2615, %2611 ], [ %2631, %2627 ], [ %2661, %2657 ], [ %2725, %2721 ], [ %2789, %2785 ], [ %2821, %2817 ], [ %2867, %2863 ], [ %2919, %2915 ], [ %2971, %2967 ], [ %3023, %3019 ], [ %3075, %3071 ], [ %3117, %3113 ], [ %3168, %3164 ], [ %3189, %3185 ], [ %3457, %3453 ], [ %3609, %3605 ], [ %3677, %3673 ], [ %3770, %3766 ], [ %3844, %3840 ], [ %3920, %3916 ], [ %3998, %3993 ], [ %4009, %4005 ]
  %112 = phi %union.StackValue* [ %107, %105 ], [ %132, %130 ], [ %148, %146 ], [ %164, %162 ], [ %186, %184 ], [ %204, %202 ], [ %225, %223 ], [ %249, %247 ], [ %291, %289 ], [ %337, %335 ], [ %410, %408 ], [ %464, %462 ], [ %507, %505 ], [ %579, %577 ], [ %675, %673 ], [ %752, %750 ], [ %818, %816 ], [ %867, %865 ], [ %920, %918 ], [ %961, %959 ], [ %1000, %998 ], [ %1041, %1039 ], [ %1080, %1078 ], [ %1118, %1116 ], [ %1156, %1154 ], [ %1196, %1194 ], [ %1257, %1255 ], [ %1316, %1314 ], [ %1377, %1375 ], [ %1436, %1434 ], [ %1484, %1482 ], [ %1532, %1530 ], [ %1592, %1590 ], [ %1651, %1649 ], [ %1710, %1708 ], [ %1769, %1767 ], [ %1828, %1826 ], [ %1876, %1874 ], [ %1924, %1922 ], [ %1984, %1982 ], [ %2026, %2024 ], [ %2068, %2066 ], [ %2110, %2108 ], [ %2160, %2158 ], [ %2210, %2208 ], [ %2260, %2258 ], [ %2308, %2306 ], [ %2348, %2346 ], [ %2399, %2397 ], [ %2449, %2447 ], [ %2483, %2481 ], [ %2519, %2517 ], [ %2549, %2547 ], [ %2566, %2564 ], [ %2588, %2586 ], [ %2602, %2600 ], [ %2613, %2611 ], [ %2629, %2627 ], [ %2659, %2657 ], [ %2723, %2721 ], [ %2787, %2785 ], [ %2819, %2817 ], [ %2865, %2863 ], [ %2917, %2915 ], [ %2969, %2967 ], [ %3021, %3019 ], [ %3073, %3071 ], [ %3115, %3113 ], [ %3166, %3164 ], [ %3187, %3185 ], [ %3455, %3453 ], [ %3607, %3605 ], [ %3675, %3673 ], [ %3768, %3766 ], [ %3842, %3840 ], [ %3918, %3916 ], [ %3997, %3993 ], [ %4007, %4005 ]
  %113 = phi i32 [ %106, %105 ], [ %131, %130 ], [ %147, %146 ], [ %163, %162 ], [ %185, %184 ], [ %203, %202 ], [ %224, %223 ], [ %248, %247 ], [ %290, %289 ], [ %336, %335 ], [ %409, %408 ], [ %463, %462 ], [ %506, %505 ], [ %578, %577 ], [ %674, %673 ], [ %751, %750 ], [ %817, %816 ], [ %866, %865 ], [ %919, %918 ], [ %960, %959 ], [ %999, %998 ], [ %1040, %1039 ], [ %1079, %1078 ], [ %1117, %1116 ], [ %1155, %1154 ], [ %1195, %1194 ], [ %1256, %1255 ], [ %1315, %1314 ], [ %1376, %1375 ], [ %1435, %1434 ], [ %1483, %1482 ], [ %1531, %1530 ], [ %1591, %1590 ], [ %1650, %1649 ], [ %1709, %1708 ], [ %1768, %1767 ], [ %1827, %1826 ], [ %1875, %1874 ], [ %1923, %1922 ], [ %1983, %1982 ], [ %2025, %2024 ], [ %2067, %2066 ], [ %2109, %2108 ], [ %2159, %2158 ], [ %2209, %2208 ], [ %2259, %2258 ], [ %2307, %2306 ], [ %2347, %2346 ], [ %2398, %2397 ], [ %2448, %2447 ], [ %2482, %2481 ], [ %2518, %2517 ], [ %2548, %2547 ], [ %2565, %2564 ], [ %2587, %2586 ], [ %2601, %2600 ], [ %2612, %2611 ], [ %2628, %2627 ], [ %2658, %2657 ], [ %2722, %2721 ], [ %2786, %2785 ], [ %2818, %2817 ], [ %2864, %2863 ], [ %2916, %2915 ], [ %2968, %2967 ], [ %3020, %3019 ], [ %3072, %3071 ], [ %3114, %3113 ], [ %3165, %3164 ], [ %3186, %3185 ], [ %3454, %3453 ], [ %3606, %3605 ], [ %3674, %3673 ], [ %3767, %3766 ], [ %3841, %3840 ], [ %3917, %3916 ], [ %3996, %3993 ], [ %4006, %4005 ]
  %114 = phi i32* [ %108, %105 ], [ %133, %130 ], [ %149, %146 ], [ %165, %162 ], [ %187, %184 ], [ %205, %202 ], [ %226, %223 ], [ %250, %247 ], [ %292, %289 ], [ %338, %335 ], [ %411, %408 ], [ %465, %462 ], [ %508, %505 ], [ %580, %577 ], [ %676, %673 ], [ %753, %750 ], [ %819, %816 ], [ %868, %865 ], [ %921, %918 ], [ %962, %959 ], [ %1001, %998 ], [ %1042, %1039 ], [ %1081, %1078 ], [ %1119, %1116 ], [ %1157, %1154 ], [ %1197, %1194 ], [ %1258, %1255 ], [ %1317, %1314 ], [ %1378, %1375 ], [ %1437, %1434 ], [ %1485, %1482 ], [ %1533, %1530 ], [ %1593, %1590 ], [ %1652, %1649 ], [ %1711, %1708 ], [ %1770, %1767 ], [ %1829, %1826 ], [ %1877, %1874 ], [ %1925, %1922 ], [ %1985, %1982 ], [ %2027, %2024 ], [ %2069, %2066 ], [ %2111, %2108 ], [ %2161, %2158 ], [ %2211, %2208 ], [ %2261, %2258 ], [ %2309, %2306 ], [ %2349, %2346 ], [ %2400, %2397 ], [ %2450, %2447 ], [ %2484, %2481 ], [ %2520, %2517 ], [ %2550, %2547 ], [ %2567, %2564 ], [ %2589, %2586 ], [ %2603, %2600 ], [ %2614, %2611 ], [ %2630, %2627 ], [ %2660, %2657 ], [ %2724, %2721 ], [ %2788, %2785 ], [ %2820, %2817 ], [ %2866, %2863 ], [ %2918, %2915 ], [ %2970, %2967 ], [ %3022, %3019 ], [ %3074, %3071 ], [ %3116, %3113 ], [ %3167, %3164 ], [ %3188, %3185 ], [ %3456, %3453 ], [ %3608, %3605 ], [ %3676, %3673 ], [ %3769, %3766 ], [ %3843, %3840 ], [ %3919, %3916 ], [ %3994, %3993 ], [ %4008, %4005 ]
  br label %4011

; <label>:115:                                    ; preds = %4011
  %116 = lshr i32 %4012, 15
  %117 = zext i32 %116 to i64
  %118 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %117
  %119 = bitcast %struct.TValue* %118 to i64*
  %120 = bitcast %union.StackValue* %4019 to i64*
  %121 = load i64, i64* %119, align 8
  store i64 %121, i64* %120, align 8
  %122 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %117, i32 1
  %123 = load i8, i8* %122, align 8, !tbaa !22
  %124 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %123, i8* %124, align 8, !tbaa !22
  %125 = icmp eq i32 %4014, 0
  br i1 %125, label %130, label %126

; <label>:126:                                    ; preds = %115
  %127 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %128 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %129 = getelementptr inbounds %union.StackValue, %union.StackValue* %128, i64 1
  br label %130

; <label>:130:                                    ; preds = %115, %126
  %131 = phi i32 [ %127, %126 ], [ 0, %115 ]
  %132 = phi %union.StackValue* [ %129, %126 ], [ %4013, %115 ]
  %133 = getelementptr inbounds i32, i32* %4015, i64 1
  %134 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:135:                                    ; preds = %4011
  %136 = lshr i32 %4012, 15
  %137 = add nsw i32 %136, -65535
  %138 = sext i32 %137 to i64
  %139 = bitcast %union.StackValue* %4019 to i64*
  store i64 %138, i64* %139, align 8, !tbaa !21
  %140 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %140, align 8, !tbaa !22
  %141 = icmp eq i32 %4014, 0
  br i1 %141, label %146, label %142

; <label>:142:                                    ; preds = %135
  %143 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %144 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 1
  br label %146

; <label>:146:                                    ; preds = %135, %142
  %147 = phi i32 [ %143, %142 ], [ 0, %135 ]
  %148 = phi %union.StackValue* [ %145, %142 ], [ %4013, %135 ]
  %149 = getelementptr inbounds i32, i32* %4015, i64 1
  %150 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:151:                                    ; preds = %4011
  %152 = lshr i32 %4012, 15
  %153 = add nsw i32 %152, -65535
  %154 = sitofp i32 %153 to double
  %155 = bitcast %union.StackValue* %4019 to double*
  store double %154, double* %155, align 8, !tbaa !21
  %156 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %156, align 8, !tbaa !22
  %157 = icmp eq i32 %4014, 0
  br i1 %157, label %162, label %158

; <label>:158:                                    ; preds = %151
  %159 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %160 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %161 = getelementptr inbounds %union.StackValue, %union.StackValue* %160, i64 1
  br label %162

; <label>:162:                                    ; preds = %151, %158
  %163 = phi i32 [ %159, %158 ], [ 0, %151 ]
  %164 = phi %union.StackValue* [ %161, %158 ], [ %4013, %151 ]
  %165 = getelementptr inbounds i32, i32* %4015, i64 1
  %166 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:167:                                    ; preds = %4011
  %168 = load i32, i32* %4015, align 4, !tbaa !74
  %169 = lshr i32 %168, 7
  %170 = zext i32 %169 to i64
  %171 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %170
  %172 = getelementptr inbounds i32, i32* %4015, i64 1
  %173 = bitcast %struct.TValue* %171 to i64*
  %174 = bitcast %union.StackValue* %4019 to i64*
  %175 = load i64, i64* %173, align 8
  store i64 %175, i64* %174, align 8
  %176 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %170, i32 1
  %177 = load i8, i8* %176, align 8, !tbaa !22
  %178 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %177, i8* %178, align 8, !tbaa !22
  %179 = icmp eq i32 %4014, 0
  br i1 %179, label %184, label %180

; <label>:180:                                    ; preds = %167
  %181 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %172) #16
  %182 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %183 = getelementptr inbounds %union.StackValue, %union.StackValue* %182, i64 1
  br label %184

; <label>:184:                                    ; preds = %167, %180
  %185 = phi i32 [ %181, %180 ], [ 0, %167 ]
  %186 = phi %union.StackValue* [ %183, %180 ], [ %4013, %167 ]
  %187 = getelementptr inbounds i32, i32* %4015, i64 2
  %188 = load i32, i32* %172, align 4, !tbaa !74
  br label %110

; <label>:189:                                    ; preds = %4011
  %190 = lshr i32 %4012, 16
  %191 = and i32 %190, 255
  %192 = bitcast %union.StackValue* %4019 to i32*
  store i32 %191, i32* %192, align 8, !tbaa !21
  %193 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 1, i8* %193, align 8, !tbaa !22
  %194 = icmp ugt i32 %4012, 16777215
  %195 = getelementptr inbounds i32, i32* %4015, i64 1
  %196 = select i1 %194, i32* %195, i32* %4015
  %197 = icmp eq i32 %4014, 0
  br i1 %197, label %202, label %198

; <label>:198:                                    ; preds = %189
  %199 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %196) #16
  %200 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %201 = getelementptr inbounds %union.StackValue, %union.StackValue* %200, i64 1
  br label %202

; <label>:202:                                    ; preds = %189, %198
  %203 = phi i32 [ %199, %198 ], [ 0, %189 ]
  %204 = phi %union.StackValue* [ %201, %198 ], [ %4013, %189 ]
  %205 = getelementptr inbounds i32, i32* %196, i64 1
  %206 = load i32, i32* %196, align 4, !tbaa !74
  br label %110

; <label>:207:                                    ; preds = %4011
  %208 = lshr i32 %4012, 16
  %209 = and i32 %208, 255
  br label %210

; <label>:210:                                    ; preds = %210, %207
  %211 = phi i32 [ %209, %207 ], [ %215, %210 ]
  %212 = phi %union.StackValue* [ %4019, %207 ], [ %213, %210 ]
  %213 = getelementptr inbounds %union.StackValue, %union.StackValue* %212, i64 1
  %214 = getelementptr inbounds %union.StackValue, %union.StackValue* %212, i64 0, i32 0, i32 1
  store i8 0, i8* %214, align 8, !tbaa !21
  %215 = add nsw i32 %211, -1
  %216 = icmp eq i32 %211, 0
  br i1 %216, label %217, label %210

; <label>:217:                                    ; preds = %210
  %218 = icmp eq i32 %4014, 0
  br i1 %218, label %223, label %219

; <label>:219:                                    ; preds = %217
  %220 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %4015) #16
  %221 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %222 = getelementptr inbounds %union.StackValue, %union.StackValue* %221, i64 1
  br label %223

; <label>:223:                                    ; preds = %217, %219
  %224 = phi i32 [ %220, %219 ], [ 0, %217 ]
  %225 = phi %union.StackValue* [ %222, %219 ], [ %4013, %217 ]
  %226 = getelementptr inbounds i32, i32* %4015, i64 1
  %227 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:228:                                    ; preds = %4011
  %229 = lshr i32 %4012, 16
  %230 = and i32 %229, 255
  %231 = zext i32 %230 to i64
  %232 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 6, i64 %231
  %233 = load %struct.UpVal*, %struct.UpVal** %232, align 8, !tbaa !39
  %234 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %233, i64 0, i32 3
  %235 = load %struct.TValue*, %struct.TValue** %234, align 8, !tbaa !64
  %236 = bitcast %struct.TValue* %235 to i64*
  %237 = bitcast %union.StackValue* %4019 to i64*
  %238 = load i64, i64* %236, align 8
  store i64 %238, i64* %237, align 8
  %239 = getelementptr inbounds %struct.TValue, %struct.TValue* %235, i64 0, i32 1
  %240 = load i8, i8* %239, align 8, !tbaa !22
  %241 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %240, i8* %241, align 8, !tbaa !22
  %242 = icmp eq i32 %4014, 0
  br i1 %242, label %247, label %243

; <label>:243:                                    ; preds = %228
  %244 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %245 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %246 = getelementptr inbounds %union.StackValue, %union.StackValue* %245, i64 1
  br label %247

; <label>:247:                                    ; preds = %228, %243
  %248 = phi i32 [ %244, %243 ], [ 0, %228 ]
  %249 = phi %union.StackValue* [ %246, %243 ], [ %4013, %228 ]
  %250 = getelementptr inbounds i32, i32* %4015, i64 1
  %251 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:252:                                    ; preds = %4011
  %253 = lshr i32 %4012, 16
  %254 = and i32 %253, 255
  %255 = zext i32 %254 to i64
  %256 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 6, i64 %255
  %257 = load %struct.UpVal*, %struct.UpVal** %256, align 8, !tbaa !39
  %258 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %257, i64 0, i32 3
  %259 = load %struct.TValue*, %struct.TValue** %258, align 8, !tbaa !64
  %260 = bitcast %union.StackValue* %4019 to i64*
  %261 = bitcast %struct.TValue* %259 to i64*
  %262 = load i64, i64* %260, align 8
  store i64 %262, i64* %261, align 8
  %263 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %264 = load i8, i8* %263, align 8, !tbaa !22
  %265 = getelementptr inbounds %struct.TValue, %struct.TValue* %259, i64 0, i32 1
  store i8 %264, i8* %265, align 8, !tbaa !22
  %266 = load i8, i8* %263, align 8, !tbaa !21
  %267 = and i8 %266, 64
  %268 = icmp eq i8 %267, 0
  br i1 %268, label %283, label %269

; <label>:269:                                    ; preds = %252
  %270 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %257, i64 0, i32 2
  %271 = load i8, i8* %270, align 1, !tbaa !66
  %272 = and i8 %271, 32
  %273 = icmp eq i8 %272, 0
  br i1 %273, label %283, label %274

; <label>:274:                                    ; preds = %269
  %275 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0, i32 0, i32 0
  %276 = load %struct.GCObject*, %struct.GCObject** %275, align 8, !tbaa !21
  %277 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %276, i64 0, i32 2
  %278 = load i8, i8* %277, align 1, !tbaa !67
  %279 = and i8 %278, 24
  %280 = icmp eq i8 %279, 0
  br i1 %280, label %283, label %281

; <label>:281:                                    ; preds = %274
  %282 = bitcast %struct.UpVal* %257 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %282, %struct.GCObject* %276) #16
  br label %283

; <label>:283:                                    ; preds = %274, %269, %252, %281
  %284 = icmp eq i32 %4014, 0
  br i1 %284, label %289, label %285

; <label>:285:                                    ; preds = %283
  %286 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %287 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %288 = getelementptr inbounds %union.StackValue, %union.StackValue* %287, i64 1
  br label %289

; <label>:289:                                    ; preds = %283, %285
  %290 = phi i32 [ %286, %285 ], [ 0, %283 ]
  %291 = phi %union.StackValue* [ %288, %285 ], [ %4013, %283 ]
  %292 = getelementptr inbounds i32, i32* %4015, i64 1
  %293 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:294:                                    ; preds = %4011
  %295 = lshr i32 %4012, 16
  %296 = and i32 %295, 255
  %297 = zext i32 %296 to i64
  %298 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 6, i64 %297
  %299 = load %struct.UpVal*, %struct.UpVal** %298, align 8, !tbaa !39
  %300 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %299, i64 0, i32 3
  %301 = load %struct.TValue*, %struct.TValue** %300, align 8, !tbaa !64
  %302 = lshr i32 %4012, 24
  %303 = zext i32 %302 to i64
  %304 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %303
  %305 = getelementptr inbounds %struct.TValue, %struct.TValue* %301, i64 0, i32 1
  %306 = load i8, i8* %305, align 8, !tbaa !22
  %307 = icmp eq i8 %306, 69
  br i1 %307, label %308, label %324

; <label>:308:                                    ; preds = %294
  %309 = bitcast %struct.TValue* %304 to %struct.TString**
  %310 = load %struct.TString*, %struct.TString** %309, align 8, !tbaa !21
  %311 = bitcast %struct.TValue* %301 to %struct.Table**
  %312 = load %struct.Table*, %struct.Table** %311, align 8, !tbaa !21
  %313 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %312, %struct.TString* %310) #16
  %314 = getelementptr inbounds %struct.TValue, %struct.TValue* %313, i64 0, i32 1
  %315 = load i8, i8* %314, align 8, !tbaa !22
  %316 = and i8 %315, 15
  %317 = icmp eq i8 %316, 0
  br i1 %317, label %324, label %318

; <label>:318:                                    ; preds = %308
  %319 = bitcast %struct.TValue* %313 to i64*
  %320 = bitcast %union.StackValue* %4019 to i64*
  %321 = load i64, i64* %319, align 8
  store i64 %321, i64* %320, align 8
  %322 = load i8, i8* %314, align 8, !tbaa !22
  %323 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %322, i8* %323, align 8, !tbaa !22
  br label %328

; <label>:324:                                    ; preds = %294, %308
  %325 = phi %struct.TValue* [ %313, %308 ], [ null, %294 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %326 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %326, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %301, %struct.TValue* %304, %union.StackValue* %4019, %struct.TValue* %325) #16
  %327 = load i32, i32* %37, align 8, !tbaa !21
  br label %328

; <label>:328:                                    ; preds = %324, %318
  %329 = phi i32 [ %4014, %318 ], [ %327, %324 ]
  %330 = icmp eq i32 %329, 0
  br i1 %330, label %335, label %331

; <label>:331:                                    ; preds = %328
  %332 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %333 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %334 = getelementptr inbounds %union.StackValue, %union.StackValue* %333, i64 1
  br label %335

; <label>:335:                                    ; preds = %328, %331
  %336 = phi i32 [ %332, %331 ], [ 0, %328 ]
  %337 = phi %union.StackValue* [ %334, %331 ], [ %4013, %328 ]
  %338 = getelementptr inbounds i32, i32* %4015, i64 1
  %339 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:340:                                    ; preds = %4011
  %341 = lshr i32 %4012, 16
  %342 = and i32 %341, 255
  %343 = zext i32 %342 to i64
  %344 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %343, i32 0
  %345 = lshr i32 %4012, 24
  %346 = zext i32 %345 to i64
  %347 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %346, i32 0
  %348 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %346, i32 0, i32 1
  %349 = load i8, i8* %348, align 8, !tbaa !22
  %350 = icmp eq i8 %349, 35
  br i1 %350, label %351, label %377

; <label>:351:                                    ; preds = %340
  %352 = bitcast %struct.TValue* %347 to i64*
  %353 = load i64, i64* %352, align 8, !tbaa !21
  %354 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %343, i32 0, i32 1
  %355 = load i8, i8* %354, align 8, !tbaa !22
  %356 = icmp eq i8 %355, 69
  br i1 %356, label %357, label %397

; <label>:357:                                    ; preds = %351
  %358 = add i64 %353, -1
  %359 = bitcast %struct.TValue* %344 to %struct.Table**
  %360 = load %struct.Table*, %struct.Table** %359, align 8, !tbaa !21
  %361 = getelementptr inbounds %struct.Table, %struct.Table* %360, i64 0, i32 5
  %362 = load i32, i32* %361, align 4, !tbaa !21
  %363 = zext i32 %362 to i64
  %364 = icmp ult i64 %358, %363
  br i1 %364, label %365, label %369

; <label>:365:                                    ; preds = %357
  %366 = getelementptr inbounds %struct.Table, %struct.Table* %360, i64 0, i32 6
  %367 = load %struct.TValue*, %struct.TValue** %366, align 8, !tbaa !21
  %368 = getelementptr inbounds %struct.TValue, %struct.TValue* %367, i64 %358
  br label %371

; <label>:369:                                    ; preds = %357
  %370 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %360, i64 %353) #16
  br label %371

; <label>:371:                                    ; preds = %365, %369
  %372 = phi %struct.TValue* [ %368, %365 ], [ %370, %369 ]
  %373 = getelementptr inbounds %struct.TValue, %struct.TValue* %372, i64 0, i32 1
  %374 = load i8, i8* %373, align 8, !tbaa !22
  %375 = and i8 %374, 15
  %376 = icmp eq i8 %375, 0
  br i1 %376, label %397, label %389

; <label>:377:                                    ; preds = %340
  %378 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %343, i32 0, i32 1
  %379 = load i8, i8* %378, align 8, !tbaa !22
  %380 = icmp eq i8 %379, 69
  br i1 %380, label %381, label %397

; <label>:381:                                    ; preds = %377
  %382 = bitcast %struct.TValue* %344 to %struct.Table**
  %383 = load %struct.Table*, %struct.Table** %382, align 8, !tbaa !21
  %384 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %383, %struct.TValue* nonnull %347) #16
  %385 = getelementptr inbounds %struct.TValue, %struct.TValue* %384, i64 0, i32 1
  %386 = load i8, i8* %385, align 8, !tbaa !22
  %387 = and i8 %386, 15
  %388 = icmp eq i8 %387, 0
  br i1 %388, label %397, label %389

; <label>:389:                                    ; preds = %371, %381
  %390 = phi i8* [ %373, %371 ], [ %385, %381 ]
  %391 = phi %struct.TValue* [ %372, %371 ], [ %384, %381 ]
  %392 = bitcast %struct.TValue* %391 to i64*
  %393 = bitcast %union.StackValue* %4019 to i64*
  %394 = load i64, i64* %392, align 8
  store i64 %394, i64* %393, align 8
  %395 = load i8, i8* %390, align 8, !tbaa !22
  %396 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %395, i8* %396, align 8, !tbaa !22
  br label %401

; <label>:397:                                    ; preds = %351, %377, %371, %381
  %398 = phi %struct.TValue* [ %372, %371 ], [ %384, %381 ], [ null, %377 ], [ null, %351 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %399 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %399, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %344, %struct.TValue* nonnull %347, %union.StackValue* %4019, %struct.TValue* %398) #16
  %400 = load i32, i32* %37, align 8, !tbaa !21
  br label %401

; <label>:401:                                    ; preds = %397, %389
  %402 = phi i32 [ %4014, %389 ], [ %400, %397 ]
  %403 = icmp eq i32 %402, 0
  br i1 %403, label %408, label %404

; <label>:404:                                    ; preds = %401
  %405 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %406 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %407 = getelementptr inbounds %union.StackValue, %union.StackValue* %406, i64 1
  br label %408

; <label>:408:                                    ; preds = %401, %404
  %409 = phi i32 [ %405, %404 ], [ 0, %401 ]
  %410 = phi %union.StackValue* [ %407, %404 ], [ %4013, %401 ]
  %411 = getelementptr inbounds i32, i32* %4015, i64 1
  %412 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:413:                                    ; preds = %4011
  %414 = lshr i32 %4012, 16
  %415 = and i32 %414, 255
  %416 = zext i32 %415 to i64
  %417 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %416, i32 0
  %418 = lshr i32 %4012, 24
  %419 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %416, i32 0, i32 1
  %420 = load i8, i8* %419, align 8, !tbaa !22
  %421 = icmp eq i8 %420, 69
  %422 = zext i32 %418 to i64
  br i1 %421, label %423, label %451

; <label>:423:                                    ; preds = %413
  %424 = add nsw i64 %422, -1
  %425 = bitcast %struct.TValue* %417 to %struct.Table**
  %426 = load %struct.Table*, %struct.Table** %425, align 8, !tbaa !21
  %427 = getelementptr inbounds %struct.Table, %struct.Table* %426, i64 0, i32 5
  %428 = load i32, i32* %427, align 4, !tbaa !21
  %429 = zext i32 %428 to i64
  %430 = icmp ult i64 %424, %429
  br i1 %430, label %431, label %437

; <label>:431:                                    ; preds = %423
  %432 = getelementptr inbounds %struct.Table, %struct.Table* %426, i64 0, i32 6
  %433 = load %struct.TValue*, %struct.TValue** %432, align 8, !tbaa !21
  %434 = add nsw i32 %418, -1
  %435 = sext i32 %434 to i64
  %436 = getelementptr inbounds %struct.TValue, %struct.TValue* %433, i64 %435
  br label %439

; <label>:437:                                    ; preds = %423
  %438 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %426, i64 %422) #16
  br label %439

; <label>:439:                                    ; preds = %437, %431
  %440 = phi %struct.TValue* [ %436, %431 ], [ %438, %437 ]
  %441 = getelementptr inbounds %struct.TValue, %struct.TValue* %440, i64 0, i32 1
  %442 = load i8, i8* %441, align 8, !tbaa !22
  %443 = and i8 %442, 15
  %444 = icmp eq i8 %443, 0
  br i1 %444, label %451, label %445

; <label>:445:                                    ; preds = %439
  %446 = bitcast %struct.TValue* %440 to i64*
  %447 = bitcast %union.StackValue* %4019 to i64*
  %448 = load i64, i64* %446, align 8
  store i64 %448, i64* %447, align 8
  %449 = load i8, i8* %441, align 8, !tbaa !22
  %450 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %449, i8* %450, align 8, !tbaa !22
  br label %455

; <label>:451:                                    ; preds = %413, %439
  %452 = phi %struct.TValue* [ %440, %439 ], [ null, %413 ]
  store i64 %422, i64* %43, align 8, !tbaa !21
  store i8 35, i8* %44, align 8, !tbaa !22
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %453 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %453, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %417, %struct.TValue* nonnull %4, %union.StackValue* %4019, %struct.TValue* %452) #16
  %454 = load i32, i32* %37, align 8, !tbaa !21
  br label %455

; <label>:455:                                    ; preds = %451, %445
  %456 = phi i32 [ %4014, %445 ], [ %454, %451 ]
  %457 = icmp eq i32 %456, 0
  br i1 %457, label %462, label %458

; <label>:458:                                    ; preds = %455
  %459 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %460 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %461 = getelementptr inbounds %union.StackValue, %union.StackValue* %460, i64 1
  br label %462

; <label>:462:                                    ; preds = %455, %458
  %463 = phi i32 [ %459, %458 ], [ 0, %455 ]
  %464 = phi %union.StackValue* [ %461, %458 ], [ %4013, %455 ]
  %465 = getelementptr inbounds i32, i32* %4015, i64 1
  %466 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:467:                                    ; preds = %4011
  %468 = lshr i32 %4012, 16
  %469 = and i32 %468, 255
  %470 = zext i32 %469 to i64
  %471 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %470, i32 0
  %472 = lshr i32 %4012, 24
  %473 = zext i32 %472 to i64
  %474 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %473
  %475 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %470, i32 0, i32 1
  %476 = load i8, i8* %475, align 8, !tbaa !22
  %477 = icmp eq i8 %476, 69
  br i1 %477, label %478, label %494

; <label>:478:                                    ; preds = %467
  %479 = bitcast %struct.TValue* %474 to %struct.TString**
  %480 = load %struct.TString*, %struct.TString** %479, align 8, !tbaa !21
  %481 = bitcast %struct.TValue* %471 to %struct.Table**
  %482 = load %struct.Table*, %struct.Table** %481, align 8, !tbaa !21
  %483 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %482, %struct.TString* %480) #16
  %484 = getelementptr inbounds %struct.TValue, %struct.TValue* %483, i64 0, i32 1
  %485 = load i8, i8* %484, align 8, !tbaa !22
  %486 = and i8 %485, 15
  %487 = icmp eq i8 %486, 0
  br i1 %487, label %494, label %488

; <label>:488:                                    ; preds = %478
  %489 = bitcast %struct.TValue* %483 to i64*
  %490 = bitcast %union.StackValue* %4019 to i64*
  %491 = load i64, i64* %489, align 8
  store i64 %491, i64* %490, align 8
  %492 = load i8, i8* %484, align 8, !tbaa !22
  %493 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %492, i8* %493, align 8, !tbaa !22
  br label %498

; <label>:494:                                    ; preds = %467, %478
  %495 = phi %struct.TValue* [ %483, %478 ], [ null, %467 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %496 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %496, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %471, %struct.TValue* %474, %union.StackValue* %4019, %struct.TValue* %495) #16
  %497 = load i32, i32* %37, align 8, !tbaa !21
  br label %498

; <label>:498:                                    ; preds = %494, %488
  %499 = phi i32 [ %4014, %488 ], [ %497, %494 ]
  %500 = icmp eq i32 %499, 0
  br i1 %500, label %505, label %501

; <label>:501:                                    ; preds = %498
  %502 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %503 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %504 = getelementptr inbounds %union.StackValue, %union.StackValue* %503, i64 1
  br label %505

; <label>:505:                                    ; preds = %498, %501
  %506 = phi i32 [ %502, %501 ], [ 0, %498 ]
  %507 = phi %union.StackValue* [ %504, %501 ], [ %4013, %498 ]
  %508 = getelementptr inbounds i32, i32* %4015, i64 1
  %509 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:510:                                    ; preds = %4011
  %511 = lshr i32 %4012, 7
  %512 = and i32 %511, 255
  %513 = zext i32 %512 to i64
  %514 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 6, i64 %513
  %515 = load %struct.UpVal*, %struct.UpVal** %514, align 8, !tbaa !39
  %516 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %515, i64 0, i32 3
  %517 = load %struct.TValue*, %struct.TValue** %516, align 8, !tbaa !64
  %518 = lshr i32 %4012, 16
  %519 = and i32 %518, 255
  %520 = zext i32 %519 to i64
  %521 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %520
  %522 = trunc i32 %4012 to i16
  %523 = icmp slt i16 %522, 0
  %524 = lshr i32 %4012, 24
  %525 = zext i32 %524 to i64
  %526 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %525
  %527 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %525, i32 0
  %528 = select i1 %523, %struct.TValue* %526, %struct.TValue* %527
  %529 = getelementptr inbounds %struct.TValue, %struct.TValue* %517, i64 0, i32 1
  %530 = load i8, i8* %529, align 8, !tbaa !22
  %531 = icmp eq i8 %530, 69
  br i1 %531, label %532, label %566

; <label>:532:                                    ; preds = %510
  %533 = bitcast %struct.TValue* %521 to %struct.TString**
  %534 = load %struct.TString*, %struct.TString** %533, align 8, !tbaa !21
  %535 = getelementptr inbounds %struct.TValue, %struct.TValue* %517, i64 0, i32 0, i32 0
  %536 = bitcast %struct.TValue* %517 to %struct.Table**
  %537 = load %struct.Table*, %struct.Table** %536, align 8, !tbaa !21
  %538 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %537, %struct.TString* %534) #16
  %539 = getelementptr inbounds %struct.TValue, %struct.TValue* %538, i64 0, i32 1
  %540 = load i8, i8* %539, align 8, !tbaa !22
  %541 = and i8 %540, 15
  %542 = icmp eq i8 %541, 0
  br i1 %542, label %566, label %543

; <label>:543:                                    ; preds = %532
  %544 = bitcast %struct.TValue* %528 to i64*
  %545 = bitcast %struct.TValue* %538 to i64*
  %546 = load i64, i64* %544, align 8
  store i64 %546, i64* %545, align 8
  %547 = getelementptr inbounds %struct.TValue, %struct.TValue* %528, i64 0, i32 1
  %548 = load i8, i8* %547, align 8, !tbaa !22
  store i8 %548, i8* %539, align 8, !tbaa !22
  %549 = load i8, i8* %547, align 8, !tbaa !22
  %550 = and i8 %549, 64
  %551 = icmp eq i8 %550, 0
  br i1 %551, label %570, label %552

; <label>:552:                                    ; preds = %543
  %553 = load %struct.GCObject*, %struct.GCObject** %535, align 8, !tbaa !21
  %554 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %553, i64 0, i32 2
  %555 = load i8, i8* %554, align 1, !tbaa !67
  %556 = and i8 %555, 32
  %557 = icmp eq i8 %556, 0
  br i1 %557, label %570, label %558

; <label>:558:                                    ; preds = %552
  %559 = getelementptr inbounds %struct.TValue, %struct.TValue* %528, i64 0, i32 0, i32 0
  %560 = load %struct.GCObject*, %struct.GCObject** %559, align 8, !tbaa !21
  %561 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %560, i64 0, i32 2
  %562 = load i8, i8* %561, align 1, !tbaa !67
  %563 = and i8 %562, 24
  %564 = icmp eq i8 %563, 0
  br i1 %564, label %570, label %565

; <label>:565:                                    ; preds = %558
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %553) #16
  br label %570

; <label>:566:                                    ; preds = %510, %532
  %567 = phi %struct.TValue* [ %538, %532 ], [ null, %510 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %568 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %568, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %517, %struct.TValue* %521, %struct.TValue* %528, %struct.TValue* %567) #16
  %569 = load i32, i32* %37, align 8, !tbaa !21
  br label %570

; <label>:570:                                    ; preds = %558, %552, %543, %565, %566
  %571 = phi i32 [ %4014, %565 ], [ %4014, %558 ], [ %4014, %552 ], [ %4014, %543 ], [ %569, %566 ]
  %572 = icmp eq i32 %571, 0
  br i1 %572, label %577, label %573

; <label>:573:                                    ; preds = %570
  %574 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %575 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %576 = getelementptr inbounds %union.StackValue, %union.StackValue* %575, i64 1
  br label %577

; <label>:577:                                    ; preds = %570, %573
  %578 = phi i32 [ %574, %573 ], [ 0, %570 ]
  %579 = phi %union.StackValue* [ %576, %573 ], [ %4013, %570 ]
  %580 = getelementptr inbounds i32, i32* %4015, i64 1
  %581 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:582:                                    ; preds = %4011
  %583 = lshr i32 %4012, 16
  %584 = and i32 %583, 255
  %585 = zext i32 %584 to i64
  %586 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %585, i32 0
  %587 = trunc i32 %4012 to i16
  %588 = icmp slt i16 %587, 0
  %589 = lshr i32 %4012, 24
  %590 = zext i32 %589 to i64
  %591 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %590
  %592 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %590, i32 0
  %593 = select i1 %588, %struct.TValue* %591, %struct.TValue* %592
  %594 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %585, i32 0, i32 1
  %595 = load i8, i8* %594, align 8, !tbaa !22
  %596 = icmp eq i8 %595, 35
  br i1 %596, label %597, label %623

; <label>:597:                                    ; preds = %582
  %598 = bitcast %struct.TValue* %586 to i64*
  %599 = load i64, i64* %598, align 8, !tbaa !21
  %600 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %601 = load i8, i8* %600, align 8, !tbaa !21
  %602 = icmp eq i8 %601, 69
  br i1 %602, label %603, label %661

; <label>:603:                                    ; preds = %597
  %604 = add i64 %599, -1
  %605 = bitcast %union.StackValue* %4019 to %struct.Table**
  %606 = load %struct.Table*, %struct.Table** %605, align 8, !tbaa !21
  %607 = getelementptr inbounds %struct.Table, %struct.Table* %606, i64 0, i32 5
  %608 = load i32, i32* %607, align 4, !tbaa !21
  %609 = zext i32 %608 to i64
  %610 = icmp ult i64 %604, %609
  br i1 %610, label %611, label %615

; <label>:611:                                    ; preds = %603
  %612 = getelementptr inbounds %struct.Table, %struct.Table* %606, i64 0, i32 6
  %613 = load %struct.TValue*, %struct.TValue** %612, align 8, !tbaa !21
  %614 = getelementptr inbounds %struct.TValue, %struct.TValue* %613, i64 %604
  br label %617

; <label>:615:                                    ; preds = %603
  %616 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %606, i64 %599) #16
  br label %617

; <label>:617:                                    ; preds = %611, %615
  %618 = phi %struct.TValue* [ %614, %611 ], [ %616, %615 ]
  %619 = getelementptr inbounds %struct.TValue, %struct.TValue* %618, i64 0, i32 1
  %620 = load i8, i8* %619, align 8, !tbaa !22
  %621 = and i8 %620, 15
  %622 = icmp eq i8 %621, 0
  br i1 %622, label %661, label %635

; <label>:623:                                    ; preds = %582
  %624 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %625 = load i8, i8* %624, align 8, !tbaa !21
  %626 = icmp eq i8 %625, 69
  br i1 %626, label %627, label %661

; <label>:627:                                    ; preds = %623
  %628 = bitcast %union.StackValue* %4019 to %struct.Table**
  %629 = load %struct.Table*, %struct.Table** %628, align 8, !tbaa !21
  %630 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %629, %struct.TValue* %586) #16
  %631 = getelementptr inbounds %struct.TValue, %struct.TValue* %630, i64 0, i32 1
  %632 = load i8, i8* %631, align 8, !tbaa !22
  %633 = and i8 %632, 15
  %634 = icmp eq i8 %633, 0
  br i1 %634, label %661, label %635

; <label>:635:                                    ; preds = %617, %627
  %636 = phi i8* [ %619, %617 ], [ %631, %627 ]
  %637 = phi %struct.TValue* [ %618, %617 ], [ %630, %627 ]
  %638 = bitcast %struct.TValue* %593 to i64*
  %639 = bitcast %struct.TValue* %637 to i64*
  %640 = load i64, i64* %638, align 8
  store i64 %640, i64* %639, align 8
  %641 = getelementptr inbounds %struct.TValue, %struct.TValue* %593, i64 0, i32 1
  %642 = load i8, i8* %641, align 8, !tbaa !22
  store i8 %642, i8* %636, align 8, !tbaa !22
  %643 = load i8, i8* %641, align 8, !tbaa !22
  %644 = and i8 %643, 64
  %645 = icmp eq i8 %644, 0
  br i1 %645, label %666, label %646

; <label>:646:                                    ; preds = %635
  %647 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0, i32 0, i32 0
  %648 = load %struct.GCObject*, %struct.GCObject** %647, align 8, !tbaa !21
  %649 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %648, i64 0, i32 2
  %650 = load i8, i8* %649, align 1, !tbaa !67
  %651 = and i8 %650, 32
  %652 = icmp eq i8 %651, 0
  br i1 %652, label %666, label %653

; <label>:653:                                    ; preds = %646
  %654 = getelementptr inbounds %struct.TValue, %struct.TValue* %593, i64 0, i32 0, i32 0
  %655 = load %struct.GCObject*, %struct.GCObject** %654, align 8, !tbaa !21
  %656 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %655, i64 0, i32 2
  %657 = load i8, i8* %656, align 1, !tbaa !67
  %658 = and i8 %657, 24
  %659 = icmp eq i8 %658, 0
  br i1 %659, label %666, label %660

; <label>:660:                                    ; preds = %653
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %648) #16
  br label %666

; <label>:661:                                    ; preds = %597, %623, %617, %627
  %662 = phi %struct.TValue* [ %618, %617 ], [ %630, %627 ], [ null, %623 ], [ null, %597 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %663 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %663, i64* %35, align 8, !tbaa !20
  %664 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %664, %struct.TValue* %586, %struct.TValue* %593, %struct.TValue* %662) #16
  %665 = load i32, i32* %37, align 8, !tbaa !21
  br label %666

; <label>:666:                                    ; preds = %653, %646, %635, %660, %661
  %667 = phi i32 [ %4014, %660 ], [ %4014, %653 ], [ %4014, %646 ], [ %4014, %635 ], [ %665, %661 ]
  %668 = icmp eq i32 %667, 0
  br i1 %668, label %673, label %669

; <label>:669:                                    ; preds = %666
  %670 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %671 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %672 = getelementptr inbounds %union.StackValue, %union.StackValue* %671, i64 1
  br label %673

; <label>:673:                                    ; preds = %666, %669
  %674 = phi i32 [ %670, %669 ], [ 0, %666 ]
  %675 = phi %union.StackValue* [ %672, %669 ], [ %4013, %666 ]
  %676 = getelementptr inbounds i32, i32* %4015, i64 1
  %677 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:678:                                    ; preds = %4011
  %679 = lshr i32 %4012, 16
  %680 = and i32 %679, 255
  %681 = trunc i32 %4012 to i16
  %682 = icmp slt i16 %681, 0
  %683 = lshr i32 %4012, 24
  %684 = zext i32 %683 to i64
  %685 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %684
  %686 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %684, i32 0
  %687 = select i1 %682, %struct.TValue* %685, %struct.TValue* %686
  %688 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %689 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %690 = load i8, i8* %689, align 8, !tbaa !21
  %691 = icmp eq i8 %690, 69
  %692 = zext i32 %680 to i64
  br i1 %691, label %693, label %739

; <label>:693:                                    ; preds = %678
  %694 = add nsw i64 %692, -1
  %695 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0, i32 0, i32 0
  %696 = bitcast %union.StackValue* %4019 to %struct.Table**
  %697 = load %struct.Table*, %struct.Table** %696, align 8, !tbaa !21
  %698 = getelementptr inbounds %struct.Table, %struct.Table* %697, i64 0, i32 5
  %699 = load i32, i32* %698, align 4, !tbaa !21
  %700 = zext i32 %699 to i64
  %701 = icmp ult i64 %694, %700
  br i1 %701, label %702, label %708

; <label>:702:                                    ; preds = %693
  %703 = getelementptr inbounds %struct.Table, %struct.Table* %697, i64 0, i32 6
  %704 = load %struct.TValue*, %struct.TValue** %703, align 8, !tbaa !21
  %705 = add nsw i32 %680, -1
  %706 = sext i32 %705 to i64
  %707 = getelementptr inbounds %struct.TValue, %struct.TValue* %704, i64 %706
  br label %710

; <label>:708:                                    ; preds = %693
  %709 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %697, i64 %692) #16
  br label %710

; <label>:710:                                    ; preds = %708, %702
  %711 = phi %struct.TValue* [ %707, %702 ], [ %709, %708 ]
  %712 = getelementptr inbounds %struct.TValue, %struct.TValue* %711, i64 0, i32 1
  %713 = load i8, i8* %712, align 8, !tbaa !22
  %714 = and i8 %713, 15
  %715 = icmp eq i8 %714, 0
  br i1 %715, label %739, label %716

; <label>:716:                                    ; preds = %710
  %717 = bitcast %struct.TValue* %687 to i64*
  %718 = bitcast %struct.TValue* %711 to i64*
  %719 = load i64, i64* %717, align 8
  store i64 %719, i64* %718, align 8
  %720 = getelementptr inbounds %struct.TValue, %struct.TValue* %687, i64 0, i32 1
  %721 = load i8, i8* %720, align 8, !tbaa !22
  store i8 %721, i8* %712, align 8, !tbaa !22
  %722 = load i8, i8* %720, align 8, !tbaa !22
  %723 = and i8 %722, 64
  %724 = icmp eq i8 %723, 0
  br i1 %724, label %743, label %725

; <label>:725:                                    ; preds = %716
  %726 = load %struct.GCObject*, %struct.GCObject** %695, align 8, !tbaa !21
  %727 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %726, i64 0, i32 2
  %728 = load i8, i8* %727, align 1, !tbaa !67
  %729 = and i8 %728, 32
  %730 = icmp eq i8 %729, 0
  br i1 %730, label %743, label %731

; <label>:731:                                    ; preds = %725
  %732 = getelementptr inbounds %struct.TValue, %struct.TValue* %687, i64 0, i32 0, i32 0
  %733 = load %struct.GCObject*, %struct.GCObject** %732, align 8, !tbaa !21
  %734 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %733, i64 0, i32 2
  %735 = load i8, i8* %734, align 1, !tbaa !67
  %736 = and i8 %735, 24
  %737 = icmp eq i8 %736, 0
  br i1 %737, label %743, label %738

; <label>:738:                                    ; preds = %731
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %726) #16
  br label %743

; <label>:739:                                    ; preds = %678, %710
  %740 = phi %struct.TValue* [ %711, %710 ], [ null, %678 ]
  store i64 %692, i64* %45, align 8, !tbaa !21
  store i8 35, i8* %46, align 8, !tbaa !22
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %741 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %741, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %688, %struct.TValue* nonnull %5, %struct.TValue* %687, %struct.TValue* %740) #16
  %742 = load i32, i32* %37, align 8, !tbaa !21
  br label %743

; <label>:743:                                    ; preds = %731, %725, %716, %738, %739
  %744 = phi i32 [ %4014, %738 ], [ %4014, %731 ], [ %4014, %725 ], [ %4014, %716 ], [ %742, %739 ]
  %745 = icmp eq i32 %744, 0
  br i1 %745, label %750, label %746

; <label>:746:                                    ; preds = %743
  %747 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %748 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %749 = getelementptr inbounds %union.StackValue, %union.StackValue* %748, i64 1
  br label %750

; <label>:750:                                    ; preds = %743, %746
  %751 = phi i32 [ %747, %746 ], [ 0, %743 ]
  %752 = phi %union.StackValue* [ %749, %746 ], [ %4013, %743 ]
  %753 = getelementptr inbounds i32, i32* %4015, i64 1
  %754 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:755:                                    ; preds = %4011
  %756 = lshr i32 %4012, 16
  %757 = and i32 %756, 255
  %758 = zext i32 %757 to i64
  %759 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %758
  %760 = trunc i32 %4012 to i16
  %761 = icmp slt i16 %760, 0
  %762 = lshr i32 %4012, 24
  %763 = zext i32 %762 to i64
  %764 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %763
  %765 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %763, i32 0
  %766 = select i1 %761, %struct.TValue* %764, %struct.TValue* %765
  %767 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %768 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %769 = load i8, i8* %768, align 8, !tbaa !21
  %770 = icmp eq i8 %769, 69
  br i1 %770, label %771, label %805

; <label>:771:                                    ; preds = %755
  %772 = bitcast %struct.TValue* %759 to %struct.TString**
  %773 = load %struct.TString*, %struct.TString** %772, align 8, !tbaa !21
  %774 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0, i32 0, i32 0
  %775 = bitcast %union.StackValue* %4019 to %struct.Table**
  %776 = load %struct.Table*, %struct.Table** %775, align 8, !tbaa !21
  %777 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %776, %struct.TString* %773) #16
  %778 = getelementptr inbounds %struct.TValue, %struct.TValue* %777, i64 0, i32 1
  %779 = load i8, i8* %778, align 8, !tbaa !22
  %780 = and i8 %779, 15
  %781 = icmp eq i8 %780, 0
  br i1 %781, label %805, label %782

; <label>:782:                                    ; preds = %771
  %783 = bitcast %struct.TValue* %766 to i64*
  %784 = bitcast %struct.TValue* %777 to i64*
  %785 = load i64, i64* %783, align 8
  store i64 %785, i64* %784, align 8
  %786 = getelementptr inbounds %struct.TValue, %struct.TValue* %766, i64 0, i32 1
  %787 = load i8, i8* %786, align 8, !tbaa !22
  store i8 %787, i8* %778, align 8, !tbaa !22
  %788 = load i8, i8* %786, align 8, !tbaa !22
  %789 = and i8 %788, 64
  %790 = icmp eq i8 %789, 0
  br i1 %790, label %809, label %791

; <label>:791:                                    ; preds = %782
  %792 = load %struct.GCObject*, %struct.GCObject** %774, align 8, !tbaa !21
  %793 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %792, i64 0, i32 2
  %794 = load i8, i8* %793, align 1, !tbaa !67
  %795 = and i8 %794, 32
  %796 = icmp eq i8 %795, 0
  br i1 %796, label %809, label %797

; <label>:797:                                    ; preds = %791
  %798 = getelementptr inbounds %struct.TValue, %struct.TValue* %766, i64 0, i32 0, i32 0
  %799 = load %struct.GCObject*, %struct.GCObject** %798, align 8, !tbaa !21
  %800 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %799, i64 0, i32 2
  %801 = load i8, i8* %800, align 1, !tbaa !67
  %802 = and i8 %801, 24
  %803 = icmp eq i8 %802, 0
  br i1 %803, label %809, label %804

; <label>:804:                                    ; preds = %797
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %792) #16
  br label %809

; <label>:805:                                    ; preds = %755, %771
  %806 = phi %struct.TValue* [ %777, %771 ], [ null, %755 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %807 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %807, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %767, %struct.TValue* %759, %struct.TValue* %766, %struct.TValue* %806) #16
  %808 = load i32, i32* %37, align 8, !tbaa !21
  br label %809

; <label>:809:                                    ; preds = %797, %791, %782, %804, %805
  %810 = phi i32 [ %4014, %804 ], [ %4014, %797 ], [ %4014, %791 ], [ %4014, %782 ], [ %808, %805 ]
  %811 = icmp eq i32 %810, 0
  br i1 %811, label %816, label %812

; <label>:812:                                    ; preds = %809
  %813 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %814 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %815 = getelementptr inbounds %union.StackValue, %union.StackValue* %814, i64 1
  br label %816

; <label>:816:                                    ; preds = %809, %812
  %817 = phi i32 [ %813, %812 ], [ 0, %809 ]
  %818 = phi %union.StackValue* [ %815, %812 ], [ %4013, %809 ]
  %819 = getelementptr inbounds i32, i32* %4015, i64 1
  %820 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:821:                                    ; preds = %4011
  %822 = lshr i32 %4012, 16
  %823 = and i32 %822, 255
  %824 = lshr i32 %4012, 24
  %825 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %825, i64* %35, align 8, !tbaa !20
  %826 = call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #16
  %827 = bitcast %union.StackValue* %4019 to %struct.Table**
  store %struct.Table* %826, %struct.Table** %827, align 8, !tbaa !21
  %828 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 69, i8* %828, align 8, !tbaa !22
  %829 = or i32 %823, %824
  %830 = icmp eq i32 %829, 0
  br i1 %830, label %850, label %831

; <label>:831:                                    ; preds = %821
  %832 = icmp ult i32 %823, 8
  br i1 %832, label %839, label %833

; <label>:833:                                    ; preds = %831
  %834 = and i32 %822, 7
  %835 = or i32 %834, 8
  %836 = lshr i32 %823, 3
  %837 = add nsw i32 %836, -1
  %838 = shl i32 %835, %837
  br label %839

; <label>:839:                                    ; preds = %831, %833
  %840 = phi i32 [ %838, %833 ], [ %823, %831 ]
  %841 = icmp ult i32 %4012, 134217728
  br i1 %841, label %848, label %842

; <label>:842:                                    ; preds = %839
  %843 = and i32 %824, 7
  %844 = or i32 %843, 8
  %845 = lshr i32 %4012, 27
  %846 = add nsw i32 %845, -1
  %847 = shl i32 %844, %846
  br label %848

; <label>:848:                                    ; preds = %839, %842
  %849 = phi i32 [ %847, %842 ], [ %824, %839 ]
  call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %826, i32 %840, i32 %849) #16
  br label %850

; <label>:850:                                    ; preds = %821, %848
  %851 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %852 = getelementptr inbounds %struct.global_State, %struct.global_State* %851, i64 0, i32 3
  %853 = load i64, i64* %852, align 8, !tbaa !11
  %854 = icmp sgt i64 %853, 0
  br i1 %854, label %855, label %858

; <label>:855:                                    ; preds = %850
  %856 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1
  store %union.StackValue* %856, %union.StackValue** %34, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  %857 = load i32, i32* %37, align 8, !tbaa !21
  br label %858

; <label>:858:                                    ; preds = %855, %850
  %859 = phi i32 [ %857, %855 ], [ %4014, %850 ]
  %860 = icmp eq i32 %859, 0
  br i1 %860, label %865, label %861

; <label>:861:                                    ; preds = %858
  %862 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4015) #16
  %863 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %864 = getelementptr inbounds %union.StackValue, %union.StackValue* %863, i64 1
  br label %865

; <label>:865:                                    ; preds = %858, %861
  %866 = phi i32 [ %862, %861 ], [ 0, %858 ]
  %867 = phi %union.StackValue* [ %864, %861 ], [ %4013, %858 ]
  %868 = getelementptr inbounds i32, i32* %4015, i64 1
  %869 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:870:                                    ; preds = %4011
  %871 = lshr i32 %4012, 16
  %872 = and i32 %871, 255
  %873 = zext i32 %872 to i64
  %874 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %873, i32 0
  %875 = trunc i32 %4012 to i16
  %876 = icmp slt i16 %875, 0
  %877 = lshr i32 %4012, 24
  %878 = zext i32 %877 to i64
  %879 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %878
  %880 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %878, i32 0
  %881 = select i1 %876, %struct.TValue* %879, %struct.TValue* %880
  %882 = bitcast %struct.TValue* %881 to %struct.TString**
  %883 = load %struct.TString*, %struct.TString** %882, align 8, !tbaa !21
  %884 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0
  %885 = bitcast %struct.TValue* %874 to i64*
  %886 = bitcast %struct.TValue* %884 to i64*
  %887 = load i64, i64* %885, align 8
  store i64 %887, i64* %886, align 8
  %888 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %873, i32 0, i32 1
  %889 = load i8, i8* %888, align 8, !tbaa !22
  %890 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 1
  store i8 %889, i8* %890, align 8, !tbaa !22
  %891 = load i8, i8* %888, align 8, !tbaa !22
  %892 = icmp eq i8 %891, 69
  br i1 %892, label %893, label %907

; <label>:893:                                    ; preds = %870
  %894 = bitcast %struct.TValue* %874 to %struct.Table**
  %895 = load %struct.Table*, %struct.Table** %894, align 8, !tbaa !21
  %896 = call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %895, %struct.TString* %883) #16
  %897 = getelementptr inbounds %struct.TValue, %struct.TValue* %896, i64 0, i32 1
  %898 = load i8, i8* %897, align 8, !tbaa !22
  %899 = and i8 %898, 15
  %900 = icmp eq i8 %899, 0
  br i1 %900, label %907, label %901

; <label>:901:                                    ; preds = %893
  %902 = bitcast %struct.TValue* %896 to i64*
  %903 = bitcast %union.StackValue* %4019 to i64*
  %904 = load i64, i64* %902, align 8
  store i64 %904, i64* %903, align 8
  %905 = load i8, i8* %897, align 8, !tbaa !22
  %906 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %905, i8* %906, align 8, !tbaa !22
  br label %911

; <label>:907:                                    ; preds = %870, %893
  %908 = phi %struct.TValue* [ %896, %893 ], [ null, %870 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %909 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %909, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %874, %struct.TValue* %881, %union.StackValue* nonnull %4019, %struct.TValue* %908) #16
  %910 = load i32, i32* %37, align 8, !tbaa !21
  br label %911

; <label>:911:                                    ; preds = %907, %901
  %912 = phi i32 [ %4014, %901 ], [ %910, %907 ]
  %913 = icmp eq i32 %912, 0
  br i1 %913, label %918, label %914

; <label>:914:                                    ; preds = %911
  %915 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %916 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %917 = getelementptr inbounds %union.StackValue, %union.StackValue* %916, i64 1
  br label %918

; <label>:918:                                    ; preds = %911, %914
  %919 = phi i32 [ %915, %914 ], [ 0, %911 ]
  %920 = phi %union.StackValue* [ %917, %914 ], [ %4013, %911 ]
  %921 = getelementptr inbounds i32, i32* %4015, i64 1
  %922 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:923:                                    ; preds = %4011
  %924 = lshr i32 %4012, 16
  %925 = and i32 %924, 255
  %926 = zext i32 %925 to i64
  %927 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %926, i32 0
  %928 = lshr i32 %4012, 24
  %929 = add nsw i32 %928, -127
  %930 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %926, i32 0, i32 1
  %931 = load i8, i8* %930, align 8, !tbaa !22
  switch i8 %931, label %946 [
    i8 35, label %932
    i8 19, label %939
  ]

; <label>:932:                                    ; preds = %923
  %933 = bitcast %struct.TValue* %927 to i64*
  %934 = load i64, i64* %933, align 8, !tbaa !21
  %935 = sext i32 %929 to i64
  %936 = add i64 %934, %935
  %937 = bitcast %union.StackValue* %4019 to i64*
  store i64 %936, i64* %937, align 8, !tbaa !21
  %938 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %938, align 8, !tbaa !22
  br label %952

; <label>:939:                                    ; preds = %923
  %940 = bitcast %struct.TValue* %927 to double*
  %941 = load double, double* %940, align 8, !tbaa !21
  %942 = sitofp i32 %929 to double
  %943 = fadd double %941, %942
  %944 = bitcast %union.StackValue* %4019 to double*
  store double %943, double* %944, align 8, !tbaa !21
  %945 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %945, align 8, !tbaa !22
  br label %952

; <label>:946:                                    ; preds = %923
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %947 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %947, i64* %35, align 8, !tbaa !20
  %948 = sext i32 %929 to i64
  %949 = lshr i32 %4012, 15
  %950 = and i32 %949, 1
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %927, i64 %948, i32 %950, %union.StackValue* %4019, i32 6) #16
  %951 = load i32, i32* %37, align 8, !tbaa !21
  br label %952

; <label>:952:                                    ; preds = %939, %946, %932
  %953 = phi i32 [ %4014, %932 ], [ %4014, %939 ], [ %951, %946 ]
  %954 = icmp eq i32 %953, 0
  br i1 %954, label %959, label %955

; <label>:955:                                    ; preds = %952
  %956 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %957 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %958 = getelementptr inbounds %union.StackValue, %union.StackValue* %957, i64 1
  br label %959

; <label>:959:                                    ; preds = %952, %955
  %960 = phi i32 [ %956, %955 ], [ 0, %952 ]
  %961 = phi %union.StackValue* [ %958, %955 ], [ %4013, %952 ]
  %962 = getelementptr inbounds i32, i32* %4015, i64 1
  %963 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:964:                                    ; preds = %4011
  %965 = lshr i32 %4012, 16
  %966 = and i32 %965, 255
  %967 = zext i32 %966 to i64
  %968 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %967, i32 0
  %969 = lshr i32 %4012, 24
  %970 = add nsw i32 %969, -127
  %971 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %967, i32 0, i32 1
  %972 = load i8, i8* %971, align 8, !tbaa !22
  switch i8 %972, label %987 [
    i8 35, label %973
    i8 19, label %980
  ]

; <label>:973:                                    ; preds = %964
  %974 = bitcast %struct.TValue* %968 to i64*
  %975 = load i64, i64* %974, align 8, !tbaa !21
  %976 = sext i32 %970 to i64
  %977 = sub i64 %975, %976
  %978 = bitcast %union.StackValue* %4019 to i64*
  store i64 %977, i64* %978, align 8, !tbaa !21
  %979 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %979, align 8, !tbaa !22
  br label %991

; <label>:980:                                    ; preds = %964
  %981 = bitcast %struct.TValue* %968 to double*
  %982 = load double, double* %981, align 8, !tbaa !21
  %983 = sitofp i32 %970 to double
  %984 = fsub double %982, %983
  %985 = bitcast %union.StackValue* %4019 to double*
  store double %984, double* %985, align 8, !tbaa !21
  %986 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %986, align 8, !tbaa !22
  br label %991

; <label>:987:                                    ; preds = %964
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %988 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %988, i64* %35, align 8, !tbaa !20
  %989 = sext i32 %970 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %968, i64 %989, i32 0, %union.StackValue* %4019, i32 7) #16
  %990 = load i32, i32* %37, align 8, !tbaa !21
  br label %991

; <label>:991:                                    ; preds = %980, %987, %973
  %992 = phi i32 [ %4014, %973 ], [ %4014, %980 ], [ %990, %987 ]
  %993 = icmp eq i32 %992, 0
  br i1 %993, label %998, label %994

; <label>:994:                                    ; preds = %991
  %995 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %996 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %997 = getelementptr inbounds %union.StackValue, %union.StackValue* %996, i64 1
  br label %998

; <label>:998:                                    ; preds = %991, %994
  %999 = phi i32 [ %995, %994 ], [ 0, %991 ]
  %1000 = phi %union.StackValue* [ %997, %994 ], [ %4013, %991 ]
  %1001 = getelementptr inbounds i32, i32* %4015, i64 1
  %1002 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1003:                                   ; preds = %4011
  %1004 = lshr i32 %4012, 16
  %1005 = and i32 %1004, 255
  %1006 = zext i32 %1005 to i64
  %1007 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1006, i32 0
  %1008 = lshr i32 %4012, 24
  %1009 = add nsw i32 %1008, -127
  %1010 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1006, i32 0, i32 1
  %1011 = load i8, i8* %1010, align 8, !tbaa !22
  switch i8 %1011, label %1026 [
    i8 35, label %1012
    i8 19, label %1019
  ]

; <label>:1012:                                   ; preds = %1003
  %1013 = bitcast %struct.TValue* %1007 to i64*
  %1014 = load i64, i64* %1013, align 8, !tbaa !21
  %1015 = sext i32 %1009 to i64
  %1016 = mul i64 %1014, %1015
  %1017 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1016, i64* %1017, align 8, !tbaa !21
  %1018 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1018, align 8, !tbaa !22
  br label %1032

; <label>:1019:                                   ; preds = %1003
  %1020 = bitcast %struct.TValue* %1007 to double*
  %1021 = load double, double* %1020, align 8, !tbaa !21
  %1022 = sitofp i32 %1009 to double
  %1023 = fmul double %1021, %1022
  %1024 = bitcast %union.StackValue* %4019 to double*
  store double %1023, double* %1024, align 8, !tbaa !21
  %1025 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1025, align 8, !tbaa !22
  br label %1032

; <label>:1026:                                   ; preds = %1003
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1027 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1027, i64* %35, align 8, !tbaa !20
  %1028 = sext i32 %1009 to i64
  %1029 = lshr i32 %4012, 15
  %1030 = and i32 %1029, 1
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1007, i64 %1028, i32 %1030, %union.StackValue* %4019, i32 8) #16
  %1031 = load i32, i32* %37, align 8, !tbaa !21
  br label %1032

; <label>:1032:                                   ; preds = %1019, %1026, %1012
  %1033 = phi i32 [ %4014, %1012 ], [ %4014, %1019 ], [ %1031, %1026 ]
  %1034 = icmp eq i32 %1033, 0
  br i1 %1034, label %1039, label %1035

; <label>:1035:                                   ; preds = %1032
  %1036 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1037 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1038 = getelementptr inbounds %union.StackValue, %union.StackValue* %1037, i64 1
  br label %1039

; <label>:1039:                                   ; preds = %1032, %1035
  %1040 = phi i32 [ %1036, %1035 ], [ 0, %1032 ]
  %1041 = phi %union.StackValue* [ %1038, %1035 ], [ %4013, %1032 ]
  %1042 = getelementptr inbounds i32, i32* %4015, i64 1
  %1043 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1044:                                   ; preds = %4011
  %1045 = lshr i32 %4012, 16
  %1046 = and i32 %1045, 255
  %1047 = zext i32 %1046 to i64
  %1048 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1047, i32 0
  %1049 = lshr i32 %4012, 24
  %1050 = add nsw i32 %1049, -127
  %1051 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1047, i32 0, i32 1
  %1052 = load i8, i8* %1051, align 8, !tbaa !22
  switch i8 %1052, label %1067 [
    i8 35, label %1053
    i8 19, label %1060
  ]

; <label>:1053:                                   ; preds = %1044
  %1054 = bitcast %struct.TValue* %1048 to i64*
  %1055 = load i64, i64* %1054, align 8, !tbaa !21
  %1056 = sext i32 %1050 to i64
  %1057 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1055, i64 %1056) #16
  %1058 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1057, i64* %1058, align 8, !tbaa !21
  %1059 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1059, align 8, !tbaa !22
  br label %1071

; <label>:1060:                                   ; preds = %1044
  %1061 = bitcast %struct.TValue* %1048 to double*
  %1062 = load double, double* %1061, align 8, !tbaa !21
  %1063 = sitofp i32 %1050 to double
  %1064 = call fastcc double @luaV_modf(double %1062, double %1063) #16
  %1065 = bitcast %union.StackValue* %4019 to double*
  store double %1064, double* %1065, align 8, !tbaa !21
  %1066 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1066, align 8, !tbaa !22
  br label %1071

; <label>:1067:                                   ; preds = %1044
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1068 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1068, i64* %35, align 8, !tbaa !20
  %1069 = sext i32 %1050 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1048, i64 %1069, i32 0, %union.StackValue* %4019, i32 9) #16
  %1070 = load i32, i32* %37, align 8, !tbaa !21
  br label %1071

; <label>:1071:                                   ; preds = %1060, %1067, %1053
  %1072 = phi i32 [ %4014, %1053 ], [ %4014, %1060 ], [ %1070, %1067 ]
  %1073 = icmp eq i32 %1072, 0
  br i1 %1073, label %1078, label %1074

; <label>:1074:                                   ; preds = %1071
  %1075 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1076 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1077 = getelementptr inbounds %union.StackValue, %union.StackValue* %1076, i64 1
  br label %1078

; <label>:1078:                                   ; preds = %1071, %1074
  %1079 = phi i32 [ %1075, %1074 ], [ 0, %1071 ]
  %1080 = phi %union.StackValue* [ %1077, %1074 ], [ %4013, %1071 ]
  %1081 = getelementptr inbounds i32, i32* %4015, i64 1
  %1082 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1083:                                   ; preds = %4011
  %1084 = lshr i32 %4012, 16
  %1085 = and i32 %1084, 255
  %1086 = zext i32 %1085 to i64
  %1087 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1086, i32 0
  %1088 = lshr i32 %4012, 24
  %1089 = add nsw i32 %1088, -127
  %1090 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1086, i32 0, i32 1
  %1091 = load i8, i8* %1090, align 8, !tbaa !22
  switch i8 %1091, label %1105 [
    i8 19, label %1092
    i8 35, label %1095
  ]

; <label>:1092:                                   ; preds = %1083
  %1093 = bitcast %struct.TValue* %1087 to double*
  %1094 = load double, double* %1093, align 8, !tbaa !21
  br label %1099

; <label>:1095:                                   ; preds = %1083
  %1096 = bitcast %struct.TValue* %1087 to i64*
  %1097 = load i64, i64* %1096, align 8, !tbaa !21
  %1098 = sitofp i64 %1097 to double
  br label %1099

; <label>:1099:                                   ; preds = %1092, %1095
  %1100 = phi double [ %1094, %1092 ], [ %1098, %1095 ]
  %1101 = sitofp i32 %1089 to double
  %1102 = call double @pow(double %1100, double %1101) #17
  %1103 = bitcast %union.StackValue* %4019 to double*
  store double %1102, double* %1103, align 8, !tbaa !21
  %1104 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1104, align 8, !tbaa !22
  br label %1109

; <label>:1105:                                   ; preds = %1083
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1106 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1106, i64* %35, align 8, !tbaa !20
  %1107 = sext i32 %1089 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1087, i64 %1107, i32 0, %union.StackValue* %4019, i32 10) #16
  %1108 = load i32, i32* %37, align 8, !tbaa !21
  br label %1109

; <label>:1109:                                   ; preds = %1105, %1099
  %1110 = phi i32 [ %4014, %1099 ], [ %1108, %1105 ]
  %1111 = icmp eq i32 %1110, 0
  br i1 %1111, label %1116, label %1112

; <label>:1112:                                   ; preds = %1109
  %1113 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1114 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1115 = getelementptr inbounds %union.StackValue, %union.StackValue* %1114, i64 1
  br label %1116

; <label>:1116:                                   ; preds = %1109, %1112
  %1117 = phi i32 [ %1113, %1112 ], [ 0, %1109 ]
  %1118 = phi %union.StackValue* [ %1115, %1112 ], [ %4013, %1109 ]
  %1119 = getelementptr inbounds i32, i32* %4015, i64 1
  %1120 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1121:                                   ; preds = %4011
  %1122 = lshr i32 %4012, 16
  %1123 = and i32 %1122, 255
  %1124 = zext i32 %1123 to i64
  %1125 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1124, i32 0
  %1126 = lshr i32 %4012, 24
  %1127 = add nsw i32 %1126, -127
  %1128 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1124, i32 0, i32 1
  %1129 = load i8, i8* %1128, align 8, !tbaa !22
  switch i8 %1129, label %1143 [
    i8 19, label %1130
    i8 35, label %1133
  ]

; <label>:1130:                                   ; preds = %1121
  %1131 = bitcast %struct.TValue* %1125 to double*
  %1132 = load double, double* %1131, align 8, !tbaa !21
  br label %1137

; <label>:1133:                                   ; preds = %1121
  %1134 = bitcast %struct.TValue* %1125 to i64*
  %1135 = load i64, i64* %1134, align 8, !tbaa !21
  %1136 = sitofp i64 %1135 to double
  br label %1137

; <label>:1137:                                   ; preds = %1130, %1133
  %1138 = phi double [ %1132, %1130 ], [ %1136, %1133 ]
  %1139 = sitofp i32 %1127 to double
  %1140 = fdiv double %1138, %1139
  %1141 = bitcast %union.StackValue* %4019 to double*
  store double %1140, double* %1141, align 8, !tbaa !21
  %1142 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1142, align 8, !tbaa !22
  br label %1147

; <label>:1143:                                   ; preds = %1121
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1144 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1144, i64* %35, align 8, !tbaa !20
  %1145 = sext i32 %1127 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1125, i64 %1145, i32 0, %union.StackValue* %4019, i32 11) #16
  %1146 = load i32, i32* %37, align 8, !tbaa !21
  br label %1147

; <label>:1147:                                   ; preds = %1143, %1137
  %1148 = phi i32 [ %4014, %1137 ], [ %1146, %1143 ]
  %1149 = icmp eq i32 %1148, 0
  br i1 %1149, label %1154, label %1150

; <label>:1150:                                   ; preds = %1147
  %1151 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1152 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1153 = getelementptr inbounds %union.StackValue, %union.StackValue* %1152, i64 1
  br label %1154

; <label>:1154:                                   ; preds = %1147, %1150
  %1155 = phi i32 [ %1151, %1150 ], [ 0, %1147 ]
  %1156 = phi %union.StackValue* [ %1153, %1150 ], [ %4013, %1147 ]
  %1157 = getelementptr inbounds i32, i32* %4015, i64 1
  %1158 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1159:                                   ; preds = %4011
  %1160 = lshr i32 %4012, 16
  %1161 = and i32 %1160, 255
  %1162 = zext i32 %1161 to i64
  %1163 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1162, i32 0
  %1164 = lshr i32 %4012, 24
  %1165 = add nsw i32 %1164, -127
  %1166 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1162, i32 0, i32 1
  %1167 = load i8, i8* %1166, align 8, !tbaa !22
  switch i8 %1167, label %1183 [
    i8 35, label %1168
    i8 19, label %1175
  ]

; <label>:1168:                                   ; preds = %1159
  %1169 = bitcast %struct.TValue* %1163 to i64*
  %1170 = load i64, i64* %1169, align 8, !tbaa !21
  %1171 = sext i32 %1165 to i64
  %1172 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1170, i64 %1171) #16
  %1173 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1172, i64* %1173, align 8, !tbaa !21
  %1174 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1174, align 8, !tbaa !22
  br label %1187

; <label>:1175:                                   ; preds = %1159
  %1176 = bitcast %struct.TValue* %1163 to double*
  %1177 = load double, double* %1176, align 8, !tbaa !21
  %1178 = sitofp i32 %1165 to double
  %1179 = fdiv double %1177, %1178
  %1180 = call double @llvm.floor.f64(double %1179)
  %1181 = bitcast %union.StackValue* %4019 to double*
  store double %1180, double* %1181, align 8, !tbaa !21
  %1182 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1182, align 8, !tbaa !22
  br label %1187

; <label>:1183:                                   ; preds = %1159
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1184 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1184, i64* %35, align 8, !tbaa !20
  %1185 = sext i32 %1165 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1163, i64 %1185, i32 0, %union.StackValue* %4019, i32 12) #16
  %1186 = load i32, i32* %37, align 8, !tbaa !21
  br label %1187

; <label>:1187:                                   ; preds = %1175, %1183, %1168
  %1188 = phi i32 [ %4014, %1168 ], [ %4014, %1175 ], [ %1186, %1183 ]
  %1189 = icmp eq i32 %1188, 0
  br i1 %1189, label %1194, label %1190

; <label>:1190:                                   ; preds = %1187
  %1191 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1192 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1193 = getelementptr inbounds %union.StackValue, %union.StackValue* %1192, i64 1
  br label %1194

; <label>:1194:                                   ; preds = %1187, %1190
  %1195 = phi i32 [ %1191, %1190 ], [ 0, %1187 ]
  %1196 = phi %union.StackValue* [ %1193, %1190 ], [ %4013, %1187 ]
  %1197 = getelementptr inbounds i32, i32* %4015, i64 1
  %1198 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1199:                                   ; preds = %4011
  %1200 = lshr i32 %4012, 16
  %1201 = and i32 %1200, 255
  %1202 = zext i32 %1201 to i64
  %1203 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1202, i32 0
  %1204 = lshr i32 %4012, 24
  %1205 = zext i32 %1204 to i64
  %1206 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1205
  %1207 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1202, i32 0, i32 1
  %1208 = load i8, i8* %1207, align 8, !tbaa !22
  switch i8 %1208, label %1243 [
    i8 35, label %1209
    i8 19, label %1221
  ]

; <label>:1209:                                   ; preds = %1199
  %1210 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1205, i32 1
  %1211 = load i8, i8* %1210, align 8, !tbaa !22
  %1212 = icmp eq i8 %1211, 35
  %1213 = bitcast %struct.TValue* %1203 to i64*
  %1214 = load i64, i64* %1213, align 8, !tbaa !21
  br i1 %1212, label %1215, label %1226

; <label>:1215:                                   ; preds = %1209
  %1216 = bitcast %struct.TValue* %1206 to i64*
  %1217 = load i64, i64* %1216, align 8, !tbaa !21
  %1218 = add i64 %1217, %1214
  %1219 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1218, i64* %1219, align 8, !tbaa !21
  %1220 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1220, align 8, !tbaa !22
  br label %1248

; <label>:1221:                                   ; preds = %1199
  %1222 = bitcast %struct.TValue* %1203 to double*
  %1223 = load double, double* %1222, align 8, !tbaa !21
  %1224 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1205, i32 1
  %1225 = load i8, i8* %1224, align 8, !tbaa !22
  br label %1228

; <label>:1226:                                   ; preds = %1209
  %1227 = sitofp i64 %1214 to double
  br label %1228

; <label>:1228:                                   ; preds = %1221, %1226
  %1229 = phi i8 [ %1225, %1221 ], [ %1211, %1226 ]
  %1230 = phi double [ %1223, %1221 ], [ %1227, %1226 ]
  switch i8 %1229, label %1243 [
    i8 19, label %1231
    i8 35, label %1234
  ]

; <label>:1231:                                   ; preds = %1228
  %1232 = bitcast %struct.TValue* %1206 to double*
  %1233 = load double, double* %1232, align 8, !tbaa !21
  br label %1238

; <label>:1234:                                   ; preds = %1228
  %1235 = bitcast %struct.TValue* %1206 to i64*
  %1236 = load i64, i64* %1235, align 8, !tbaa !21
  %1237 = sitofp i64 %1236 to double
  br label %1238

; <label>:1238:                                   ; preds = %1231, %1234
  %1239 = phi double [ %1233, %1231 ], [ %1237, %1234 ]
  %1240 = fadd double %1230, %1239
  %1241 = bitcast %union.StackValue* %4019 to double*
  store double %1240, double* %1241, align 8, !tbaa !21
  %1242 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1242, align 8, !tbaa !22
  br label %1248

; <label>:1243:                                   ; preds = %1199, %1228
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1244 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1244, i64* %35, align 8, !tbaa !20
  %1245 = lshr i32 %4012, 15
  %1246 = and i32 %1245, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1203, %struct.TValue* %1206, %union.StackValue* %4019, i32 %1246, i32 6) #16
  %1247 = load i32, i32* %37, align 8, !tbaa !21
  br label %1248

; <label>:1248:                                   ; preds = %1238, %1243, %1215
  %1249 = phi i32 [ %4014, %1215 ], [ %4014, %1238 ], [ %1247, %1243 ]
  %1250 = icmp eq i32 %1249, 0
  br i1 %1250, label %1255, label %1251

; <label>:1251:                                   ; preds = %1248
  %1252 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1253 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1254 = getelementptr inbounds %union.StackValue, %union.StackValue* %1253, i64 1
  br label %1255

; <label>:1255:                                   ; preds = %1248, %1251
  %1256 = phi i32 [ %1252, %1251 ], [ 0, %1248 ]
  %1257 = phi %union.StackValue* [ %1254, %1251 ], [ %4013, %1248 ]
  %1258 = getelementptr inbounds i32, i32* %4015, i64 1
  %1259 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1260:                                   ; preds = %4011
  %1261 = lshr i32 %4012, 16
  %1262 = and i32 %1261, 255
  %1263 = zext i32 %1262 to i64
  %1264 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1263, i32 0
  %1265 = lshr i32 %4012, 24
  %1266 = zext i32 %1265 to i64
  %1267 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1266
  %1268 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1263, i32 0, i32 1
  %1269 = load i8, i8* %1268, align 8, !tbaa !22
  switch i8 %1269, label %1304 [
    i8 35, label %1270
    i8 19, label %1282
  ]

; <label>:1270:                                   ; preds = %1260
  %1271 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1266, i32 1
  %1272 = load i8, i8* %1271, align 8, !tbaa !22
  %1273 = icmp eq i8 %1272, 35
  %1274 = bitcast %struct.TValue* %1264 to i64*
  %1275 = load i64, i64* %1274, align 8, !tbaa !21
  br i1 %1273, label %1276, label %1287

; <label>:1276:                                   ; preds = %1270
  %1277 = bitcast %struct.TValue* %1267 to i64*
  %1278 = load i64, i64* %1277, align 8, !tbaa !21
  %1279 = sub i64 %1275, %1278
  %1280 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1279, i64* %1280, align 8, !tbaa !21
  %1281 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1281, align 8, !tbaa !22
  br label %1307

; <label>:1282:                                   ; preds = %1260
  %1283 = bitcast %struct.TValue* %1264 to double*
  %1284 = load double, double* %1283, align 8, !tbaa !21
  %1285 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1266, i32 1
  %1286 = load i8, i8* %1285, align 8, !tbaa !22
  br label %1289

; <label>:1287:                                   ; preds = %1270
  %1288 = sitofp i64 %1275 to double
  br label %1289

; <label>:1289:                                   ; preds = %1282, %1287
  %1290 = phi i8 [ %1286, %1282 ], [ %1272, %1287 ]
  %1291 = phi double [ %1284, %1282 ], [ %1288, %1287 ]
  switch i8 %1290, label %1304 [
    i8 19, label %1292
    i8 35, label %1295
  ]

; <label>:1292:                                   ; preds = %1289
  %1293 = bitcast %struct.TValue* %1267 to double*
  %1294 = load double, double* %1293, align 8, !tbaa !21
  br label %1299

; <label>:1295:                                   ; preds = %1289
  %1296 = bitcast %struct.TValue* %1267 to i64*
  %1297 = load i64, i64* %1296, align 8, !tbaa !21
  %1298 = sitofp i64 %1297 to double
  br label %1299

; <label>:1299:                                   ; preds = %1292, %1295
  %1300 = phi double [ %1294, %1292 ], [ %1298, %1295 ]
  %1301 = fsub double %1291, %1300
  %1302 = bitcast %union.StackValue* %4019 to double*
  store double %1301, double* %1302, align 8, !tbaa !21
  %1303 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1303, align 8, !tbaa !22
  br label %1307

; <label>:1304:                                   ; preds = %1260, %1289
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1305 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1305, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1264, %struct.TValue* %1267, %union.StackValue* %4019, i32 7) #17
  %1306 = load i32, i32* %37, align 8, !tbaa !21
  br label %1307

; <label>:1307:                                   ; preds = %1299, %1304, %1276
  %1308 = phi i32 [ %4014, %1276 ], [ %4014, %1299 ], [ %1306, %1304 ]
  %1309 = icmp eq i32 %1308, 0
  br i1 %1309, label %1314, label %1310

; <label>:1310:                                   ; preds = %1307
  %1311 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1312 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1313 = getelementptr inbounds %union.StackValue, %union.StackValue* %1312, i64 1
  br label %1314

; <label>:1314:                                   ; preds = %1307, %1310
  %1315 = phi i32 [ %1311, %1310 ], [ 0, %1307 ]
  %1316 = phi %union.StackValue* [ %1313, %1310 ], [ %4013, %1307 ]
  %1317 = getelementptr inbounds i32, i32* %4015, i64 1
  %1318 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1319:                                   ; preds = %4011
  %1320 = lshr i32 %4012, 16
  %1321 = and i32 %1320, 255
  %1322 = zext i32 %1321 to i64
  %1323 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1322, i32 0
  %1324 = lshr i32 %4012, 24
  %1325 = zext i32 %1324 to i64
  %1326 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1325
  %1327 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1322, i32 0, i32 1
  %1328 = load i8, i8* %1327, align 8, !tbaa !22
  switch i8 %1328, label %1363 [
    i8 35, label %1329
    i8 19, label %1341
  ]

; <label>:1329:                                   ; preds = %1319
  %1330 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1325, i32 1
  %1331 = load i8, i8* %1330, align 8, !tbaa !22
  %1332 = icmp eq i8 %1331, 35
  %1333 = bitcast %struct.TValue* %1323 to i64*
  %1334 = load i64, i64* %1333, align 8, !tbaa !21
  br i1 %1332, label %1335, label %1346

; <label>:1335:                                   ; preds = %1329
  %1336 = bitcast %struct.TValue* %1326 to i64*
  %1337 = load i64, i64* %1336, align 8, !tbaa !21
  %1338 = mul i64 %1337, %1334
  %1339 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1338, i64* %1339, align 8, !tbaa !21
  %1340 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1340, align 8, !tbaa !22
  br label %1368

; <label>:1341:                                   ; preds = %1319
  %1342 = bitcast %struct.TValue* %1323 to double*
  %1343 = load double, double* %1342, align 8, !tbaa !21
  %1344 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1325, i32 1
  %1345 = load i8, i8* %1344, align 8, !tbaa !22
  br label %1348

; <label>:1346:                                   ; preds = %1329
  %1347 = sitofp i64 %1334 to double
  br label %1348

; <label>:1348:                                   ; preds = %1341, %1346
  %1349 = phi i8 [ %1345, %1341 ], [ %1331, %1346 ]
  %1350 = phi double [ %1343, %1341 ], [ %1347, %1346 ]
  switch i8 %1349, label %1363 [
    i8 19, label %1351
    i8 35, label %1354
  ]

; <label>:1351:                                   ; preds = %1348
  %1352 = bitcast %struct.TValue* %1326 to double*
  %1353 = load double, double* %1352, align 8, !tbaa !21
  br label %1358

; <label>:1354:                                   ; preds = %1348
  %1355 = bitcast %struct.TValue* %1326 to i64*
  %1356 = load i64, i64* %1355, align 8, !tbaa !21
  %1357 = sitofp i64 %1356 to double
  br label %1358

; <label>:1358:                                   ; preds = %1351, %1354
  %1359 = phi double [ %1353, %1351 ], [ %1357, %1354 ]
  %1360 = fmul double %1350, %1359
  %1361 = bitcast %union.StackValue* %4019 to double*
  store double %1360, double* %1361, align 8, !tbaa !21
  %1362 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1362, align 8, !tbaa !22
  br label %1368

; <label>:1363:                                   ; preds = %1319, %1348
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1364 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1364, i64* %35, align 8, !tbaa !20
  %1365 = lshr i32 %4012, 15
  %1366 = and i32 %1365, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1323, %struct.TValue* %1326, %union.StackValue* %4019, i32 %1366, i32 8) #16
  %1367 = load i32, i32* %37, align 8, !tbaa !21
  br label %1368

; <label>:1368:                                   ; preds = %1358, %1363, %1335
  %1369 = phi i32 [ %4014, %1335 ], [ %4014, %1358 ], [ %1367, %1363 ]
  %1370 = icmp eq i32 %1369, 0
  br i1 %1370, label %1375, label %1371

; <label>:1371:                                   ; preds = %1368
  %1372 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1373 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1374 = getelementptr inbounds %union.StackValue, %union.StackValue* %1373, i64 1
  br label %1375

; <label>:1375:                                   ; preds = %1368, %1371
  %1376 = phi i32 [ %1372, %1371 ], [ 0, %1368 ]
  %1377 = phi %union.StackValue* [ %1374, %1371 ], [ %4013, %1368 ]
  %1378 = getelementptr inbounds i32, i32* %4015, i64 1
  %1379 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1380:                                   ; preds = %4011
  %1381 = lshr i32 %4012, 16
  %1382 = and i32 %1381, 255
  %1383 = zext i32 %1382 to i64
  %1384 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1383, i32 0
  %1385 = lshr i32 %4012, 24
  %1386 = zext i32 %1385 to i64
  %1387 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1386
  %1388 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1383, i32 0, i32 1
  %1389 = load i8, i8* %1388, align 8, !tbaa !22
  switch i8 %1389, label %1424 [
    i8 35, label %1390
    i8 19, label %1402
  ]

; <label>:1390:                                   ; preds = %1380
  %1391 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1386, i32 1
  %1392 = load i8, i8* %1391, align 8, !tbaa !22
  %1393 = icmp eq i8 %1392, 35
  %1394 = bitcast %struct.TValue* %1384 to i64*
  %1395 = load i64, i64* %1394, align 8, !tbaa !21
  br i1 %1393, label %1396, label %1407

; <label>:1396:                                   ; preds = %1390
  %1397 = bitcast %struct.TValue* %1387 to i64*
  %1398 = load i64, i64* %1397, align 8, !tbaa !21
  %1399 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1395, i64 %1398) #16
  %1400 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1399, i64* %1400, align 8, !tbaa !21
  %1401 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1401, align 8, !tbaa !22
  br label %1427

; <label>:1402:                                   ; preds = %1380
  %1403 = bitcast %struct.TValue* %1384 to double*
  %1404 = load double, double* %1403, align 8, !tbaa !21
  %1405 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1386, i32 1
  %1406 = load i8, i8* %1405, align 8, !tbaa !22
  br label %1409

; <label>:1407:                                   ; preds = %1390
  %1408 = sitofp i64 %1395 to double
  br label %1409

; <label>:1409:                                   ; preds = %1402, %1407
  %1410 = phi i8 [ %1406, %1402 ], [ %1392, %1407 ]
  %1411 = phi double [ %1404, %1402 ], [ %1408, %1407 ]
  switch i8 %1410, label %1424 [
    i8 19, label %1412
    i8 35, label %1415
  ]

; <label>:1412:                                   ; preds = %1409
  %1413 = bitcast %struct.TValue* %1387 to double*
  %1414 = load double, double* %1413, align 8, !tbaa !21
  br label %1419

; <label>:1415:                                   ; preds = %1409
  %1416 = bitcast %struct.TValue* %1387 to i64*
  %1417 = load i64, i64* %1416, align 8, !tbaa !21
  %1418 = sitofp i64 %1417 to double
  br label %1419

; <label>:1419:                                   ; preds = %1412, %1415
  %1420 = phi double [ %1414, %1412 ], [ %1418, %1415 ]
  %1421 = call fastcc double @luaV_modf(double %1411, double %1420) #16
  %1422 = bitcast %union.StackValue* %4019 to double*
  store double %1421, double* %1422, align 8, !tbaa !21
  %1423 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1423, align 8, !tbaa !22
  br label %1427

; <label>:1424:                                   ; preds = %1380, %1409
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1425 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1425, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1384, %struct.TValue* %1387, %union.StackValue* %4019, i32 9) #17
  %1426 = load i32, i32* %37, align 8, !tbaa !21
  br label %1427

; <label>:1427:                                   ; preds = %1419, %1424, %1396
  %1428 = phi i32 [ %4014, %1396 ], [ %4014, %1419 ], [ %1426, %1424 ]
  %1429 = icmp eq i32 %1428, 0
  br i1 %1429, label %1434, label %1430

; <label>:1430:                                   ; preds = %1427
  %1431 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1432 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1433 = getelementptr inbounds %union.StackValue, %union.StackValue* %1432, i64 1
  br label %1434

; <label>:1434:                                   ; preds = %1427, %1430
  %1435 = phi i32 [ %1431, %1430 ], [ 0, %1427 ]
  %1436 = phi %union.StackValue* [ %1433, %1430 ], [ %4013, %1427 ]
  %1437 = getelementptr inbounds i32, i32* %4015, i64 1
  %1438 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1439:                                   ; preds = %4011
  %1440 = lshr i32 %4012, 16
  %1441 = and i32 %1440, 255
  %1442 = zext i32 %1441 to i64
  %1443 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1442, i32 0
  %1444 = lshr i32 %4012, 24
  %1445 = zext i32 %1444 to i64
  %1446 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1445
  %1447 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1442, i32 0, i32 1
  %1448 = load i8, i8* %1447, align 8, !tbaa !22
  switch i8 %1448, label %1472 [
    i8 19, label %1449
    i8 35, label %1452
  ]

; <label>:1449:                                   ; preds = %1439
  %1450 = bitcast %struct.TValue* %1443 to double*
  %1451 = load double, double* %1450, align 8, !tbaa !21
  br label %1456

; <label>:1452:                                   ; preds = %1439
  %1453 = bitcast %struct.TValue* %1443 to i64*
  %1454 = load i64, i64* %1453, align 8, !tbaa !21
  %1455 = sitofp i64 %1454 to double
  br label %1456

; <label>:1456:                                   ; preds = %1449, %1452
  %1457 = phi double [ %1451, %1449 ], [ %1455, %1452 ]
  %1458 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1445, i32 1
  %1459 = load i8, i8* %1458, align 8, !tbaa !22
  switch i8 %1459, label %1472 [
    i8 19, label %1460
    i8 35, label %1463
  ]

; <label>:1460:                                   ; preds = %1456
  %1461 = bitcast %struct.TValue* %1446 to double*
  %1462 = load double, double* %1461, align 8, !tbaa !21
  br label %1467

; <label>:1463:                                   ; preds = %1456
  %1464 = bitcast %struct.TValue* %1446 to i64*
  %1465 = load i64, i64* %1464, align 8, !tbaa !21
  %1466 = sitofp i64 %1465 to double
  br label %1467

; <label>:1467:                                   ; preds = %1460, %1463
  %1468 = phi double [ %1462, %1460 ], [ %1466, %1463 ]
  %1469 = call double @pow(double %1457, double %1468) #17
  %1470 = bitcast %union.StackValue* %4019 to double*
  store double %1469, double* %1470, align 8, !tbaa !21
  %1471 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1471, align 8, !tbaa !22
  br label %1475

; <label>:1472:                                   ; preds = %1456, %1439
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1473 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1473, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1443, %struct.TValue* %1446, %union.StackValue* %4019, i32 10) #16
  %1474 = load i32, i32* %37, align 8, !tbaa !21
  br label %1475

; <label>:1475:                                   ; preds = %1472, %1467
  %1476 = phi i32 [ %4014, %1467 ], [ %1474, %1472 ]
  %1477 = icmp eq i32 %1476, 0
  br i1 %1477, label %1482, label %1478

; <label>:1478:                                   ; preds = %1475
  %1479 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1480 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1481 = getelementptr inbounds %union.StackValue, %union.StackValue* %1480, i64 1
  br label %1482

; <label>:1482:                                   ; preds = %1475, %1478
  %1483 = phi i32 [ %1479, %1478 ], [ 0, %1475 ]
  %1484 = phi %union.StackValue* [ %1481, %1478 ], [ %4013, %1475 ]
  %1485 = getelementptr inbounds i32, i32* %4015, i64 1
  %1486 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1487:                                   ; preds = %4011
  %1488 = lshr i32 %4012, 16
  %1489 = and i32 %1488, 255
  %1490 = zext i32 %1489 to i64
  %1491 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1490, i32 0
  %1492 = lshr i32 %4012, 24
  %1493 = zext i32 %1492 to i64
  %1494 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1493
  %1495 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1490, i32 0, i32 1
  %1496 = load i8, i8* %1495, align 8, !tbaa !22
  switch i8 %1496, label %1520 [
    i8 19, label %1497
    i8 35, label %1500
  ]

; <label>:1497:                                   ; preds = %1487
  %1498 = bitcast %struct.TValue* %1491 to double*
  %1499 = load double, double* %1498, align 8, !tbaa !21
  br label %1504

; <label>:1500:                                   ; preds = %1487
  %1501 = bitcast %struct.TValue* %1491 to i64*
  %1502 = load i64, i64* %1501, align 8, !tbaa !21
  %1503 = sitofp i64 %1502 to double
  br label %1504

; <label>:1504:                                   ; preds = %1497, %1500
  %1505 = phi double [ %1499, %1497 ], [ %1503, %1500 ]
  %1506 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1493, i32 1
  %1507 = load i8, i8* %1506, align 8, !tbaa !22
  switch i8 %1507, label %1520 [
    i8 19, label %1508
    i8 35, label %1511
  ]

; <label>:1508:                                   ; preds = %1504
  %1509 = bitcast %struct.TValue* %1494 to double*
  %1510 = load double, double* %1509, align 8, !tbaa !21
  br label %1515

; <label>:1511:                                   ; preds = %1504
  %1512 = bitcast %struct.TValue* %1494 to i64*
  %1513 = load i64, i64* %1512, align 8, !tbaa !21
  %1514 = sitofp i64 %1513 to double
  br label %1515

; <label>:1515:                                   ; preds = %1508, %1511
  %1516 = phi double [ %1510, %1508 ], [ %1514, %1511 ]
  %1517 = fdiv double %1505, %1516
  %1518 = bitcast %union.StackValue* %4019 to double*
  store double %1517, double* %1518, align 8, !tbaa !21
  %1519 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1519, align 8, !tbaa !22
  br label %1523

; <label>:1520:                                   ; preds = %1504, %1487
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1521 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1521, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1491, %struct.TValue* %1494, %union.StackValue* %4019, i32 11) #16
  %1522 = load i32, i32* %37, align 8, !tbaa !21
  br label %1523

; <label>:1523:                                   ; preds = %1520, %1515
  %1524 = phi i32 [ %4014, %1515 ], [ %1522, %1520 ]
  %1525 = icmp eq i32 %1524, 0
  br i1 %1525, label %1530, label %1526

; <label>:1526:                                   ; preds = %1523
  %1527 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1528 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1529 = getelementptr inbounds %union.StackValue, %union.StackValue* %1528, i64 1
  br label %1530

; <label>:1530:                                   ; preds = %1523, %1526
  %1531 = phi i32 [ %1527, %1526 ], [ 0, %1523 ]
  %1532 = phi %union.StackValue* [ %1529, %1526 ], [ %4013, %1523 ]
  %1533 = getelementptr inbounds i32, i32* %4015, i64 1
  %1534 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1535:                                   ; preds = %4011
  %1536 = lshr i32 %4012, 16
  %1537 = and i32 %1536, 255
  %1538 = zext i32 %1537 to i64
  %1539 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1538, i32 0
  %1540 = lshr i32 %4012, 24
  %1541 = zext i32 %1540 to i64
  %1542 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1541
  %1543 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1538, i32 0, i32 1
  %1544 = load i8, i8* %1543, align 8, !tbaa !22
  switch i8 %1544, label %1580 [
    i8 35, label %1545
    i8 19, label %1557
  ]

; <label>:1545:                                   ; preds = %1535
  %1546 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1541, i32 1
  %1547 = load i8, i8* %1546, align 8, !tbaa !22
  %1548 = icmp eq i8 %1547, 35
  %1549 = bitcast %struct.TValue* %1539 to i64*
  %1550 = load i64, i64* %1549, align 8, !tbaa !21
  br i1 %1548, label %1551, label %1562

; <label>:1551:                                   ; preds = %1545
  %1552 = bitcast %struct.TValue* %1542 to i64*
  %1553 = load i64, i64* %1552, align 8, !tbaa !21
  %1554 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1550, i64 %1553) #16
  %1555 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1554, i64* %1555, align 8, !tbaa !21
  %1556 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1556, align 8, !tbaa !22
  br label %1583

; <label>:1557:                                   ; preds = %1535
  %1558 = bitcast %struct.TValue* %1539 to double*
  %1559 = load double, double* %1558, align 8, !tbaa !21
  %1560 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1541, i32 1
  %1561 = load i8, i8* %1560, align 8, !tbaa !22
  br label %1564

; <label>:1562:                                   ; preds = %1545
  %1563 = sitofp i64 %1550 to double
  br label %1564

; <label>:1564:                                   ; preds = %1557, %1562
  %1565 = phi i8 [ %1561, %1557 ], [ %1547, %1562 ]
  %1566 = phi double [ %1559, %1557 ], [ %1563, %1562 ]
  switch i8 %1565, label %1580 [
    i8 19, label %1567
    i8 35, label %1570
  ]

; <label>:1567:                                   ; preds = %1564
  %1568 = bitcast %struct.TValue* %1542 to double*
  %1569 = load double, double* %1568, align 8, !tbaa !21
  br label %1574

; <label>:1570:                                   ; preds = %1564
  %1571 = bitcast %struct.TValue* %1542 to i64*
  %1572 = load i64, i64* %1571, align 8, !tbaa !21
  %1573 = sitofp i64 %1572 to double
  br label %1574

; <label>:1574:                                   ; preds = %1567, %1570
  %1575 = phi double [ %1569, %1567 ], [ %1573, %1570 ]
  %1576 = fdiv double %1566, %1575
  %1577 = call double @llvm.floor.f64(double %1576)
  %1578 = bitcast %union.StackValue* %4019 to double*
  store double %1577, double* %1578, align 8, !tbaa !21
  %1579 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1579, align 8, !tbaa !22
  br label %1583

; <label>:1580:                                   ; preds = %1535, %1564
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1581 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1581, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1539, %struct.TValue* %1542, %union.StackValue* %4019, i32 12) #17
  %1582 = load i32, i32* %37, align 8, !tbaa !21
  br label %1583

; <label>:1583:                                   ; preds = %1574, %1580, %1551
  %1584 = phi i32 [ %4014, %1551 ], [ %4014, %1574 ], [ %1582, %1580 ]
  %1585 = icmp eq i32 %1584, 0
  br i1 %1585, label %1590, label %1586

; <label>:1586:                                   ; preds = %1583
  %1587 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1588 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1589 = getelementptr inbounds %union.StackValue, %union.StackValue* %1588, i64 1
  br label %1590

; <label>:1590:                                   ; preds = %1583, %1586
  %1591 = phi i32 [ %1587, %1586 ], [ 0, %1583 ]
  %1592 = phi %union.StackValue* [ %1589, %1586 ], [ %4013, %1583 ]
  %1593 = getelementptr inbounds i32, i32* %4015, i64 1
  %1594 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1595:                                   ; preds = %4011
  %1596 = lshr i32 %4012, 16
  %1597 = and i32 %1596, 255
  %1598 = zext i32 %1597 to i64
  %1599 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1598, i32 0
  %1600 = lshr i32 %4012, 24
  %1601 = zext i32 %1600 to i64
  %1602 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1601, i32 0
  %1603 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1598, i32 0, i32 1
  %1604 = load i8, i8* %1603, align 8, !tbaa !22
  switch i8 %1604, label %1639 [
    i8 35, label %1605
    i8 19, label %1617
  ]

; <label>:1605:                                   ; preds = %1595
  %1606 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1601, i32 0, i32 1
  %1607 = load i8, i8* %1606, align 8, !tbaa !22
  %1608 = icmp eq i8 %1607, 35
  %1609 = bitcast %struct.TValue* %1599 to i64*
  %1610 = load i64, i64* %1609, align 8, !tbaa !21
  br i1 %1608, label %1611, label %1622

; <label>:1611:                                   ; preds = %1605
  %1612 = bitcast %struct.TValue* %1602 to i64*
  %1613 = load i64, i64* %1612, align 8, !tbaa !21
  %1614 = add i64 %1613, %1610
  %1615 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1614, i64* %1615, align 8, !tbaa !21
  %1616 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1616, align 8, !tbaa !22
  br label %1642

; <label>:1617:                                   ; preds = %1595
  %1618 = bitcast %struct.TValue* %1599 to double*
  %1619 = load double, double* %1618, align 8, !tbaa !21
  %1620 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1601, i32 0, i32 1
  %1621 = load i8, i8* %1620, align 8, !tbaa !22
  br label %1624

; <label>:1622:                                   ; preds = %1605
  %1623 = sitofp i64 %1610 to double
  br label %1624

; <label>:1624:                                   ; preds = %1617, %1622
  %1625 = phi i8 [ %1621, %1617 ], [ %1607, %1622 ]
  %1626 = phi double [ %1619, %1617 ], [ %1623, %1622 ]
  switch i8 %1625, label %1639 [
    i8 19, label %1627
    i8 35, label %1630
  ]

; <label>:1627:                                   ; preds = %1624
  %1628 = bitcast %struct.TValue* %1602 to double*
  %1629 = load double, double* %1628, align 8, !tbaa !21
  br label %1634

; <label>:1630:                                   ; preds = %1624
  %1631 = bitcast %struct.TValue* %1602 to i64*
  %1632 = load i64, i64* %1631, align 8, !tbaa !21
  %1633 = sitofp i64 %1632 to double
  br label %1634

; <label>:1634:                                   ; preds = %1627, %1630
  %1635 = phi double [ %1629, %1627 ], [ %1633, %1630 ]
  %1636 = fadd double %1626, %1635
  %1637 = bitcast %union.StackValue* %4019 to double*
  store double %1636, double* %1637, align 8, !tbaa !21
  %1638 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1638, align 8, !tbaa !22
  br label %1642

; <label>:1639:                                   ; preds = %1595, %1624
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1640 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1640, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1599, %struct.TValue* %1602, %union.StackValue* %4019, i32 6) #16
  %1641 = load i32, i32* %37, align 8, !tbaa !21
  br label %1642

; <label>:1642:                                   ; preds = %1634, %1639, %1611
  %1643 = phi i32 [ %4014, %1611 ], [ %4014, %1634 ], [ %1641, %1639 ]
  %1644 = icmp eq i32 %1643, 0
  br i1 %1644, label %1649, label %1645

; <label>:1645:                                   ; preds = %1642
  %1646 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1647 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1648 = getelementptr inbounds %union.StackValue, %union.StackValue* %1647, i64 1
  br label %1649

; <label>:1649:                                   ; preds = %1642, %1645
  %1650 = phi i32 [ %1646, %1645 ], [ 0, %1642 ]
  %1651 = phi %union.StackValue* [ %1648, %1645 ], [ %4013, %1642 ]
  %1652 = getelementptr inbounds i32, i32* %4015, i64 1
  %1653 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1654:                                   ; preds = %4011
  %1655 = lshr i32 %4012, 16
  %1656 = and i32 %1655, 255
  %1657 = zext i32 %1656 to i64
  %1658 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1657, i32 0
  %1659 = lshr i32 %4012, 24
  %1660 = zext i32 %1659 to i64
  %1661 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1660, i32 0
  %1662 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1657, i32 0, i32 1
  %1663 = load i8, i8* %1662, align 8, !tbaa !22
  switch i8 %1663, label %1698 [
    i8 35, label %1664
    i8 19, label %1676
  ]

; <label>:1664:                                   ; preds = %1654
  %1665 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1660, i32 0, i32 1
  %1666 = load i8, i8* %1665, align 8, !tbaa !22
  %1667 = icmp eq i8 %1666, 35
  %1668 = bitcast %struct.TValue* %1658 to i64*
  %1669 = load i64, i64* %1668, align 8, !tbaa !21
  br i1 %1667, label %1670, label %1681

; <label>:1670:                                   ; preds = %1664
  %1671 = bitcast %struct.TValue* %1661 to i64*
  %1672 = load i64, i64* %1671, align 8, !tbaa !21
  %1673 = sub i64 %1669, %1672
  %1674 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1673, i64* %1674, align 8, !tbaa !21
  %1675 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1675, align 8, !tbaa !22
  br label %1701

; <label>:1676:                                   ; preds = %1654
  %1677 = bitcast %struct.TValue* %1658 to double*
  %1678 = load double, double* %1677, align 8, !tbaa !21
  %1679 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1660, i32 0, i32 1
  %1680 = load i8, i8* %1679, align 8, !tbaa !22
  br label %1683

; <label>:1681:                                   ; preds = %1664
  %1682 = sitofp i64 %1669 to double
  br label %1683

; <label>:1683:                                   ; preds = %1676, %1681
  %1684 = phi i8 [ %1680, %1676 ], [ %1666, %1681 ]
  %1685 = phi double [ %1678, %1676 ], [ %1682, %1681 ]
  switch i8 %1684, label %1698 [
    i8 19, label %1686
    i8 35, label %1689
  ]

; <label>:1686:                                   ; preds = %1683
  %1687 = bitcast %struct.TValue* %1661 to double*
  %1688 = load double, double* %1687, align 8, !tbaa !21
  br label %1693

; <label>:1689:                                   ; preds = %1683
  %1690 = bitcast %struct.TValue* %1661 to i64*
  %1691 = load i64, i64* %1690, align 8, !tbaa !21
  %1692 = sitofp i64 %1691 to double
  br label %1693

; <label>:1693:                                   ; preds = %1686, %1689
  %1694 = phi double [ %1688, %1686 ], [ %1692, %1689 ]
  %1695 = fsub double %1685, %1694
  %1696 = bitcast %union.StackValue* %4019 to double*
  store double %1695, double* %1696, align 8, !tbaa !21
  %1697 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1697, align 8, !tbaa !22
  br label %1701

; <label>:1698:                                   ; preds = %1654, %1683
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1699 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1699, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1658, %struct.TValue* %1661, %union.StackValue* %4019, i32 7) #16
  %1700 = load i32, i32* %37, align 8, !tbaa !21
  br label %1701

; <label>:1701:                                   ; preds = %1693, %1698, %1670
  %1702 = phi i32 [ %4014, %1670 ], [ %4014, %1693 ], [ %1700, %1698 ]
  %1703 = icmp eq i32 %1702, 0
  br i1 %1703, label %1708, label %1704

; <label>:1704:                                   ; preds = %1701
  %1705 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1706 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1707 = getelementptr inbounds %union.StackValue, %union.StackValue* %1706, i64 1
  br label %1708

; <label>:1708:                                   ; preds = %1701, %1704
  %1709 = phi i32 [ %1705, %1704 ], [ 0, %1701 ]
  %1710 = phi %union.StackValue* [ %1707, %1704 ], [ %4013, %1701 ]
  %1711 = getelementptr inbounds i32, i32* %4015, i64 1
  %1712 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1713:                                   ; preds = %4011
  %1714 = lshr i32 %4012, 16
  %1715 = and i32 %1714, 255
  %1716 = zext i32 %1715 to i64
  %1717 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1716, i32 0
  %1718 = lshr i32 %4012, 24
  %1719 = zext i32 %1718 to i64
  %1720 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1719, i32 0
  %1721 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1716, i32 0, i32 1
  %1722 = load i8, i8* %1721, align 8, !tbaa !22
  switch i8 %1722, label %1757 [
    i8 35, label %1723
    i8 19, label %1735
  ]

; <label>:1723:                                   ; preds = %1713
  %1724 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1719, i32 0, i32 1
  %1725 = load i8, i8* %1724, align 8, !tbaa !22
  %1726 = icmp eq i8 %1725, 35
  %1727 = bitcast %struct.TValue* %1717 to i64*
  %1728 = load i64, i64* %1727, align 8, !tbaa !21
  br i1 %1726, label %1729, label %1740

; <label>:1729:                                   ; preds = %1723
  %1730 = bitcast %struct.TValue* %1720 to i64*
  %1731 = load i64, i64* %1730, align 8, !tbaa !21
  %1732 = mul i64 %1731, %1728
  %1733 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1732, i64* %1733, align 8, !tbaa !21
  %1734 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1734, align 8, !tbaa !22
  br label %1760

; <label>:1735:                                   ; preds = %1713
  %1736 = bitcast %struct.TValue* %1717 to double*
  %1737 = load double, double* %1736, align 8, !tbaa !21
  %1738 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1719, i32 0, i32 1
  %1739 = load i8, i8* %1738, align 8, !tbaa !22
  br label %1742

; <label>:1740:                                   ; preds = %1723
  %1741 = sitofp i64 %1728 to double
  br label %1742

; <label>:1742:                                   ; preds = %1735, %1740
  %1743 = phi i8 [ %1739, %1735 ], [ %1725, %1740 ]
  %1744 = phi double [ %1737, %1735 ], [ %1741, %1740 ]
  switch i8 %1743, label %1757 [
    i8 19, label %1745
    i8 35, label %1748
  ]

; <label>:1745:                                   ; preds = %1742
  %1746 = bitcast %struct.TValue* %1720 to double*
  %1747 = load double, double* %1746, align 8, !tbaa !21
  br label %1752

; <label>:1748:                                   ; preds = %1742
  %1749 = bitcast %struct.TValue* %1720 to i64*
  %1750 = load i64, i64* %1749, align 8, !tbaa !21
  %1751 = sitofp i64 %1750 to double
  br label %1752

; <label>:1752:                                   ; preds = %1745, %1748
  %1753 = phi double [ %1747, %1745 ], [ %1751, %1748 ]
  %1754 = fmul double %1744, %1753
  %1755 = bitcast %union.StackValue* %4019 to double*
  store double %1754, double* %1755, align 8, !tbaa !21
  %1756 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1756, align 8, !tbaa !22
  br label %1760

; <label>:1757:                                   ; preds = %1713, %1742
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1758 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1758, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1717, %struct.TValue* %1720, %union.StackValue* %4019, i32 8) #16
  %1759 = load i32, i32* %37, align 8, !tbaa !21
  br label %1760

; <label>:1760:                                   ; preds = %1752, %1757, %1729
  %1761 = phi i32 [ %4014, %1729 ], [ %4014, %1752 ], [ %1759, %1757 ]
  %1762 = icmp eq i32 %1761, 0
  br i1 %1762, label %1767, label %1763

; <label>:1763:                                   ; preds = %1760
  %1764 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1765 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1766 = getelementptr inbounds %union.StackValue, %union.StackValue* %1765, i64 1
  br label %1767

; <label>:1767:                                   ; preds = %1760, %1763
  %1768 = phi i32 [ %1764, %1763 ], [ 0, %1760 ]
  %1769 = phi %union.StackValue* [ %1766, %1763 ], [ %4013, %1760 ]
  %1770 = getelementptr inbounds i32, i32* %4015, i64 1
  %1771 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1772:                                   ; preds = %4011
  %1773 = lshr i32 %4012, 16
  %1774 = and i32 %1773, 255
  %1775 = zext i32 %1774 to i64
  %1776 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1775, i32 0
  %1777 = lshr i32 %4012, 24
  %1778 = zext i32 %1777 to i64
  %1779 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1778, i32 0
  %1780 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1775, i32 0, i32 1
  %1781 = load i8, i8* %1780, align 8, !tbaa !22
  switch i8 %1781, label %1816 [
    i8 35, label %1782
    i8 19, label %1794
  ]

; <label>:1782:                                   ; preds = %1772
  %1783 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1778, i32 0, i32 1
  %1784 = load i8, i8* %1783, align 8, !tbaa !22
  %1785 = icmp eq i8 %1784, 35
  %1786 = bitcast %struct.TValue* %1776 to i64*
  %1787 = load i64, i64* %1786, align 8, !tbaa !21
  br i1 %1785, label %1788, label %1799

; <label>:1788:                                   ; preds = %1782
  %1789 = bitcast %struct.TValue* %1779 to i64*
  %1790 = load i64, i64* %1789, align 8, !tbaa !21
  %1791 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1787, i64 %1790) #16
  %1792 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1791, i64* %1792, align 8, !tbaa !21
  %1793 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1793, align 8, !tbaa !22
  br label %1819

; <label>:1794:                                   ; preds = %1772
  %1795 = bitcast %struct.TValue* %1776 to double*
  %1796 = load double, double* %1795, align 8, !tbaa !21
  %1797 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1778, i32 0, i32 1
  %1798 = load i8, i8* %1797, align 8, !tbaa !22
  br label %1801

; <label>:1799:                                   ; preds = %1782
  %1800 = sitofp i64 %1787 to double
  br label %1801

; <label>:1801:                                   ; preds = %1794, %1799
  %1802 = phi i8 [ %1798, %1794 ], [ %1784, %1799 ]
  %1803 = phi double [ %1796, %1794 ], [ %1800, %1799 ]
  switch i8 %1802, label %1816 [
    i8 19, label %1804
    i8 35, label %1807
  ]

; <label>:1804:                                   ; preds = %1801
  %1805 = bitcast %struct.TValue* %1779 to double*
  %1806 = load double, double* %1805, align 8, !tbaa !21
  br label %1811

; <label>:1807:                                   ; preds = %1801
  %1808 = bitcast %struct.TValue* %1779 to i64*
  %1809 = load i64, i64* %1808, align 8, !tbaa !21
  %1810 = sitofp i64 %1809 to double
  br label %1811

; <label>:1811:                                   ; preds = %1804, %1807
  %1812 = phi double [ %1806, %1804 ], [ %1810, %1807 ]
  %1813 = call fastcc double @luaV_modf(double %1803, double %1812) #16
  %1814 = bitcast %union.StackValue* %4019 to double*
  store double %1813, double* %1814, align 8, !tbaa !21
  %1815 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1815, align 8, !tbaa !22
  br label %1819

; <label>:1816:                                   ; preds = %1772, %1801
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1817 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1817, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1776, %struct.TValue* %1779, %union.StackValue* %4019, i32 9) #16
  %1818 = load i32, i32* %37, align 8, !tbaa !21
  br label %1819

; <label>:1819:                                   ; preds = %1811, %1816, %1788
  %1820 = phi i32 [ %4014, %1788 ], [ %4014, %1811 ], [ %1818, %1816 ]
  %1821 = icmp eq i32 %1820, 0
  br i1 %1821, label %1826, label %1822

; <label>:1822:                                   ; preds = %1819
  %1823 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1824 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1825 = getelementptr inbounds %union.StackValue, %union.StackValue* %1824, i64 1
  br label %1826

; <label>:1826:                                   ; preds = %1819, %1822
  %1827 = phi i32 [ %1823, %1822 ], [ 0, %1819 ]
  %1828 = phi %union.StackValue* [ %1825, %1822 ], [ %4013, %1819 ]
  %1829 = getelementptr inbounds i32, i32* %4015, i64 1
  %1830 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1831:                                   ; preds = %4011
  %1832 = lshr i32 %4012, 16
  %1833 = and i32 %1832, 255
  %1834 = zext i32 %1833 to i64
  %1835 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1834, i32 0
  %1836 = lshr i32 %4012, 24
  %1837 = zext i32 %1836 to i64
  %1838 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1837, i32 0
  %1839 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1834, i32 0, i32 1
  %1840 = load i8, i8* %1839, align 8, !tbaa !22
  switch i8 %1840, label %1864 [
    i8 19, label %1841
    i8 35, label %1844
  ]

; <label>:1841:                                   ; preds = %1831
  %1842 = bitcast %struct.TValue* %1835 to double*
  %1843 = load double, double* %1842, align 8, !tbaa !21
  br label %1848

; <label>:1844:                                   ; preds = %1831
  %1845 = bitcast %struct.TValue* %1835 to i64*
  %1846 = load i64, i64* %1845, align 8, !tbaa !21
  %1847 = sitofp i64 %1846 to double
  br label %1848

; <label>:1848:                                   ; preds = %1841, %1844
  %1849 = phi double [ %1843, %1841 ], [ %1847, %1844 ]
  %1850 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1837, i32 0, i32 1
  %1851 = load i8, i8* %1850, align 8, !tbaa !22
  switch i8 %1851, label %1864 [
    i8 19, label %1852
    i8 35, label %1855
  ]

; <label>:1852:                                   ; preds = %1848
  %1853 = bitcast %struct.TValue* %1838 to double*
  %1854 = load double, double* %1853, align 8, !tbaa !21
  br label %1859

; <label>:1855:                                   ; preds = %1848
  %1856 = bitcast %struct.TValue* %1838 to i64*
  %1857 = load i64, i64* %1856, align 8, !tbaa !21
  %1858 = sitofp i64 %1857 to double
  br label %1859

; <label>:1859:                                   ; preds = %1852, %1855
  %1860 = phi double [ %1854, %1852 ], [ %1858, %1855 ]
  %1861 = call double @pow(double %1849, double %1860) #17
  %1862 = bitcast %union.StackValue* %4019 to double*
  store double %1861, double* %1862, align 8, !tbaa !21
  %1863 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1863, align 8, !tbaa !22
  br label %1867

; <label>:1864:                                   ; preds = %1848, %1831
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1865 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1865, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1835, %struct.TValue* %1838, %union.StackValue* %4019, i32 10) #16
  %1866 = load i32, i32* %37, align 8, !tbaa !21
  br label %1867

; <label>:1867:                                   ; preds = %1864, %1859
  %1868 = phi i32 [ %4014, %1859 ], [ %1866, %1864 ]
  %1869 = icmp eq i32 %1868, 0
  br i1 %1869, label %1874, label %1870

; <label>:1870:                                   ; preds = %1867
  %1871 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1872 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1873 = getelementptr inbounds %union.StackValue, %union.StackValue* %1872, i64 1
  br label %1874

; <label>:1874:                                   ; preds = %1867, %1870
  %1875 = phi i32 [ %1871, %1870 ], [ 0, %1867 ]
  %1876 = phi %union.StackValue* [ %1873, %1870 ], [ %4013, %1867 ]
  %1877 = getelementptr inbounds i32, i32* %4015, i64 1
  %1878 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1879:                                   ; preds = %4011
  %1880 = lshr i32 %4012, 16
  %1881 = and i32 %1880, 255
  %1882 = zext i32 %1881 to i64
  %1883 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1882, i32 0
  %1884 = lshr i32 %4012, 24
  %1885 = zext i32 %1884 to i64
  %1886 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1885, i32 0
  %1887 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1882, i32 0, i32 1
  %1888 = load i8, i8* %1887, align 8, !tbaa !22
  switch i8 %1888, label %1912 [
    i8 19, label %1889
    i8 35, label %1892
  ]

; <label>:1889:                                   ; preds = %1879
  %1890 = bitcast %struct.TValue* %1883 to double*
  %1891 = load double, double* %1890, align 8, !tbaa !21
  br label %1896

; <label>:1892:                                   ; preds = %1879
  %1893 = bitcast %struct.TValue* %1883 to i64*
  %1894 = load i64, i64* %1893, align 8, !tbaa !21
  %1895 = sitofp i64 %1894 to double
  br label %1896

; <label>:1896:                                   ; preds = %1889, %1892
  %1897 = phi double [ %1891, %1889 ], [ %1895, %1892 ]
  %1898 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1885, i32 0, i32 1
  %1899 = load i8, i8* %1898, align 8, !tbaa !22
  switch i8 %1899, label %1912 [
    i8 19, label %1900
    i8 35, label %1903
  ]

; <label>:1900:                                   ; preds = %1896
  %1901 = bitcast %struct.TValue* %1886 to double*
  %1902 = load double, double* %1901, align 8, !tbaa !21
  br label %1907

; <label>:1903:                                   ; preds = %1896
  %1904 = bitcast %struct.TValue* %1886 to i64*
  %1905 = load i64, i64* %1904, align 8, !tbaa !21
  %1906 = sitofp i64 %1905 to double
  br label %1907

; <label>:1907:                                   ; preds = %1900, %1903
  %1908 = phi double [ %1902, %1900 ], [ %1906, %1903 ]
  %1909 = fdiv double %1897, %1908
  %1910 = bitcast %union.StackValue* %4019 to double*
  store double %1909, double* %1910, align 8, !tbaa !21
  %1911 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1911, align 8, !tbaa !22
  br label %1915

; <label>:1912:                                   ; preds = %1896, %1879
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1913 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1913, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1883, %struct.TValue* %1886, %union.StackValue* %4019, i32 11) #16
  %1914 = load i32, i32* %37, align 8, !tbaa !21
  br label %1915

; <label>:1915:                                   ; preds = %1912, %1907
  %1916 = phi i32 [ %4014, %1907 ], [ %1914, %1912 ]
  %1917 = icmp eq i32 %1916, 0
  br i1 %1917, label %1922, label %1918

; <label>:1918:                                   ; preds = %1915
  %1919 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1920 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1921 = getelementptr inbounds %union.StackValue, %union.StackValue* %1920, i64 1
  br label %1922

; <label>:1922:                                   ; preds = %1915, %1918
  %1923 = phi i32 [ %1919, %1918 ], [ 0, %1915 ]
  %1924 = phi %union.StackValue* [ %1921, %1918 ], [ %4013, %1915 ]
  %1925 = getelementptr inbounds i32, i32* %4015, i64 1
  %1926 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1927:                                   ; preds = %4011
  %1928 = lshr i32 %4012, 16
  %1929 = and i32 %1928, 255
  %1930 = zext i32 %1929 to i64
  %1931 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1930, i32 0
  %1932 = lshr i32 %4012, 24
  %1933 = zext i32 %1932 to i64
  %1934 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1933, i32 0
  %1935 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1930, i32 0, i32 1
  %1936 = load i8, i8* %1935, align 8, !tbaa !22
  switch i8 %1936, label %1972 [
    i8 35, label %1937
    i8 19, label %1949
  ]

; <label>:1937:                                   ; preds = %1927
  %1938 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1933, i32 0, i32 1
  %1939 = load i8, i8* %1938, align 8, !tbaa !22
  %1940 = icmp eq i8 %1939, 35
  %1941 = bitcast %struct.TValue* %1931 to i64*
  %1942 = load i64, i64* %1941, align 8, !tbaa !21
  br i1 %1940, label %1943, label %1954

; <label>:1943:                                   ; preds = %1937
  %1944 = bitcast %struct.TValue* %1934 to i64*
  %1945 = load i64, i64* %1944, align 8, !tbaa !21
  %1946 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1942, i64 %1945) #16
  %1947 = bitcast %union.StackValue* %4019 to i64*
  store i64 %1946, i64* %1947, align 8, !tbaa !21
  %1948 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %1948, align 8, !tbaa !22
  br label %1975

; <label>:1949:                                   ; preds = %1927
  %1950 = bitcast %struct.TValue* %1931 to double*
  %1951 = load double, double* %1950, align 8, !tbaa !21
  %1952 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1933, i32 0, i32 1
  %1953 = load i8, i8* %1952, align 8, !tbaa !22
  br label %1956

; <label>:1954:                                   ; preds = %1937
  %1955 = sitofp i64 %1942 to double
  br label %1956

; <label>:1956:                                   ; preds = %1949, %1954
  %1957 = phi i8 [ %1953, %1949 ], [ %1939, %1954 ]
  %1958 = phi double [ %1951, %1949 ], [ %1955, %1954 ]
  switch i8 %1957, label %1972 [
    i8 19, label %1959
    i8 35, label %1962
  ]

; <label>:1959:                                   ; preds = %1956
  %1960 = bitcast %struct.TValue* %1934 to double*
  %1961 = load double, double* %1960, align 8, !tbaa !21
  br label %1966

; <label>:1962:                                   ; preds = %1956
  %1963 = bitcast %struct.TValue* %1934 to i64*
  %1964 = load i64, i64* %1963, align 8, !tbaa !21
  %1965 = sitofp i64 %1964 to double
  br label %1966

; <label>:1966:                                   ; preds = %1959, %1962
  %1967 = phi double [ %1961, %1959 ], [ %1965, %1962 ]
  %1968 = fdiv double %1958, %1967
  %1969 = call double @llvm.floor.f64(double %1968)
  %1970 = bitcast %union.StackValue* %4019 to double*
  store double %1969, double* %1970, align 8, !tbaa !21
  %1971 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %1971, align 8, !tbaa !22
  br label %1975

; <label>:1972:                                   ; preds = %1927, %1956
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %1973 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %1973, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1931, %struct.TValue* %1934, %union.StackValue* %4019, i32 12) #16
  %1974 = load i32, i32* %37, align 8, !tbaa !21
  br label %1975

; <label>:1975:                                   ; preds = %1966, %1972, %1943
  %1976 = phi i32 [ %4014, %1943 ], [ %4014, %1966 ], [ %1974, %1972 ]
  %1977 = icmp eq i32 %1976, 0
  br i1 %1977, label %1982, label %1978

; <label>:1978:                                   ; preds = %1975
  %1979 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %1980 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %1981 = getelementptr inbounds %union.StackValue, %union.StackValue* %1980, i64 1
  br label %1982

; <label>:1982:                                   ; preds = %1975, %1978
  %1983 = phi i32 [ %1979, %1978 ], [ 0, %1975 ]
  %1984 = phi %union.StackValue* [ %1981, %1978 ], [ %4013, %1975 ]
  %1985 = getelementptr inbounds i32, i32* %4015, i64 1
  %1986 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:1987:                                   ; preds = %4011
  %1988 = lshr i32 %4012, 16
  %1989 = and i32 %1988, 255
  %1990 = zext i32 %1989 to i64
  %1991 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1990, i32 0
  %1992 = lshr i32 %4012, 24
  %1993 = zext i32 %1992 to i64
  %1994 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %1993, i32 0
  %1995 = bitcast %union.Value* %1994 to i64*
  %1996 = load i64, i64* %1995, align 8, !tbaa !21
  %1997 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %1990, i32 0, i32 1
  %1998 = load i8, i8* %1997, align 8, !tbaa !22
  %1999 = icmp eq i8 %1998, 35
  br i1 %1999, label %2000, label %2003

; <label>:2000:                                   ; preds = %1987
  %2001 = bitcast %struct.TValue* %1991 to i64*
  %2002 = load i64, i64* %2001, align 8, !tbaa !21
  store i64 %2002, i64* %6, align 8, !tbaa !129
  br label %2008

; <label>:2003:                                   ; preds = %1987
  %2004 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %1991, i64* nonnull %6, i32 0) #16
  %2005 = icmp eq i32 %2004, 0
  br i1 %2005, label %2013, label %2006

; <label>:2006:                                   ; preds = %2003
  %2007 = load i64, i64* %6, align 8, !tbaa !129
  br label %2008

; <label>:2008:                                   ; preds = %2006, %2000
  %2009 = phi i64 [ %2007, %2006 ], [ %2002, %2000 ]
  %2010 = and i64 %2009, %1996
  %2011 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2010, i64* %2011, align 8, !tbaa !21
  %2012 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2012, align 8, !tbaa !22
  br label %2017

; <label>:2013:                                   ; preds = %2003
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2014 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2014, i64* %35, align 8, !tbaa !20
  %2015 = and i32 %4012, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1991, i64 %1996, i32 %2015, %union.StackValue* %4019, i32 13) #16
  %2016 = load i32, i32* %37, align 8, !tbaa !21
  br label %2017

; <label>:2017:                                   ; preds = %2013, %2008
  %2018 = phi i32 [ %4014, %2008 ], [ %2016, %2013 ]
  %2019 = icmp eq i32 %2018, 0
  br i1 %2019, label %2024, label %2020

; <label>:2020:                                   ; preds = %2017
  %2021 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2022 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2023 = getelementptr inbounds %union.StackValue, %union.StackValue* %2022, i64 1
  br label %2024

; <label>:2024:                                   ; preds = %2017, %2020
  %2025 = phi i32 [ %2021, %2020 ], [ 0, %2017 ]
  %2026 = phi %union.StackValue* [ %2023, %2020 ], [ %4013, %2017 ]
  %2027 = getelementptr inbounds i32, i32* %4015, i64 1
  %2028 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2029:                                   ; preds = %4011
  %2030 = lshr i32 %4012, 16
  %2031 = and i32 %2030, 255
  %2032 = zext i32 %2031 to i64
  %2033 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2032, i32 0
  %2034 = lshr i32 %4012, 24
  %2035 = zext i32 %2034 to i64
  %2036 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %2035, i32 0
  %2037 = bitcast %union.Value* %2036 to i64*
  %2038 = load i64, i64* %2037, align 8, !tbaa !21
  %2039 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2032, i32 0, i32 1
  %2040 = load i8, i8* %2039, align 8, !tbaa !22
  %2041 = icmp eq i8 %2040, 35
  br i1 %2041, label %2042, label %2045

; <label>:2042:                                   ; preds = %2029
  %2043 = bitcast %struct.TValue* %2033 to i64*
  %2044 = load i64, i64* %2043, align 8, !tbaa !21
  store i64 %2044, i64* %7, align 8, !tbaa !129
  br label %2050

; <label>:2045:                                   ; preds = %2029
  %2046 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2033, i64* nonnull %7, i32 0) #16
  %2047 = icmp eq i32 %2046, 0
  br i1 %2047, label %2055, label %2048

; <label>:2048:                                   ; preds = %2045
  %2049 = load i64, i64* %7, align 8, !tbaa !129
  br label %2050

; <label>:2050:                                   ; preds = %2048, %2042
  %2051 = phi i64 [ %2049, %2048 ], [ %2044, %2042 ]
  %2052 = or i64 %2051, %2038
  %2053 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2052, i64* %2053, align 8, !tbaa !21
  %2054 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2054, align 8, !tbaa !22
  br label %2059

; <label>:2055:                                   ; preds = %2045
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2056 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2056, i64* %35, align 8, !tbaa !20
  %2057 = and i32 %4012, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2033, i64 %2038, i32 %2057, %union.StackValue* %4019, i32 14) #16
  %2058 = load i32, i32* %37, align 8, !tbaa !21
  br label %2059

; <label>:2059:                                   ; preds = %2055, %2050
  %2060 = phi i32 [ %4014, %2050 ], [ %2058, %2055 ]
  %2061 = icmp eq i32 %2060, 0
  br i1 %2061, label %2066, label %2062

; <label>:2062:                                   ; preds = %2059
  %2063 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2064 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2065 = getelementptr inbounds %union.StackValue, %union.StackValue* %2064, i64 1
  br label %2066

; <label>:2066:                                   ; preds = %2059, %2062
  %2067 = phi i32 [ %2063, %2062 ], [ 0, %2059 ]
  %2068 = phi %union.StackValue* [ %2065, %2062 ], [ %4013, %2059 ]
  %2069 = getelementptr inbounds i32, i32* %4015, i64 1
  %2070 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2071:                                   ; preds = %4011
  %2072 = lshr i32 %4012, 16
  %2073 = and i32 %2072, 255
  %2074 = zext i32 %2073 to i64
  %2075 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2074, i32 0
  %2076 = lshr i32 %4012, 24
  %2077 = zext i32 %2076 to i64
  %2078 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %2077, i32 0
  %2079 = bitcast %union.Value* %2078 to i64*
  %2080 = load i64, i64* %2079, align 8, !tbaa !21
  %2081 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2074, i32 0, i32 1
  %2082 = load i8, i8* %2081, align 8, !tbaa !22
  %2083 = icmp eq i8 %2082, 35
  br i1 %2083, label %2084, label %2087

; <label>:2084:                                   ; preds = %2071
  %2085 = bitcast %struct.TValue* %2075 to i64*
  %2086 = load i64, i64* %2085, align 8, !tbaa !21
  store i64 %2086, i64* %8, align 8, !tbaa !129
  br label %2092

; <label>:2087:                                   ; preds = %2071
  %2088 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2075, i64* nonnull %8, i32 0) #16
  %2089 = icmp eq i32 %2088, 0
  br i1 %2089, label %2097, label %2090

; <label>:2090:                                   ; preds = %2087
  %2091 = load i64, i64* %8, align 8, !tbaa !129
  br label %2092

; <label>:2092:                                   ; preds = %2090, %2084
  %2093 = phi i64 [ %2091, %2090 ], [ %2086, %2084 ]
  %2094 = xor i64 %2093, %2080
  %2095 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2094, i64* %2095, align 8, !tbaa !21
  %2096 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2096, align 8, !tbaa !22
  br label %2101

; <label>:2097:                                   ; preds = %2087
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2098 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2098, i64* %35, align 8, !tbaa !20
  %2099 = and i32 %4012, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2075, i64 %2080, i32 %2099, %union.StackValue* %4019, i32 15) #16
  %2100 = load i32, i32* %37, align 8, !tbaa !21
  br label %2101

; <label>:2101:                                   ; preds = %2097, %2092
  %2102 = phi i32 [ %4014, %2092 ], [ %2100, %2097 ]
  %2103 = icmp eq i32 %2102, 0
  br i1 %2103, label %2108, label %2104

; <label>:2104:                                   ; preds = %2101
  %2105 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2106 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2107 = getelementptr inbounds %union.StackValue, %union.StackValue* %2106, i64 1
  br label %2108

; <label>:2108:                                   ; preds = %2101, %2104
  %2109 = phi i32 [ %2105, %2104 ], [ 0, %2101 ]
  %2110 = phi %union.StackValue* [ %2107, %2104 ], [ %4013, %2101 ]
  %2111 = getelementptr inbounds i32, i32* %4015, i64 1
  %2112 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2113:                                   ; preds = %4011
  %2114 = lshr i32 %4012, 16
  %2115 = and i32 %2114, 255
  %2116 = zext i32 %2115 to i64
  %2117 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2116, i32 0
  %2118 = lshr i32 %4012, 24
  %2119 = zext i32 %2118 to i64
  %2120 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2119, i32 0
  %2121 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2116, i32 0, i32 1
  %2122 = load i8, i8* %2121, align 8, !tbaa !22
  %2123 = icmp eq i8 %2122, 35
  br i1 %2123, label %2124, label %2127

; <label>:2124:                                   ; preds = %2113
  %2125 = bitcast %struct.TValue* %2117 to i64*
  %2126 = load i64, i64* %2125, align 8, !tbaa !21
  store i64 %2126, i64* %9, align 8, !tbaa !129
  br label %2130

; <label>:2127:                                   ; preds = %2113
  %2128 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2117, i64* nonnull %9, i32 0) #16
  %2129 = icmp eq i32 %2128, 0
  br i1 %2129, label %2148, label %2130

; <label>:2130:                                   ; preds = %2127, %2124
  %2131 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2119, i32 0, i32 1
  %2132 = load i8, i8* %2131, align 8, !tbaa !22
  %2133 = icmp eq i8 %2132, 35
  br i1 %2133, label %2134, label %2137

; <label>:2134:                                   ; preds = %2130
  %2135 = bitcast %struct.TValue* %2120 to i64*
  %2136 = load i64, i64* %2135, align 8, !tbaa !21
  store i64 %2136, i64* %10, align 8, !tbaa !129
  br label %2142

; <label>:2137:                                   ; preds = %2130
  %2138 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2120, i64* nonnull %10, i32 0) #16
  %2139 = icmp eq i32 %2138, 0
  br i1 %2139, label %2148, label %2140

; <label>:2140:                                   ; preds = %2137
  %2141 = load i64, i64* %10, align 8, !tbaa !129
  br label %2142

; <label>:2142:                                   ; preds = %2140, %2134
  %2143 = phi i64 [ %2141, %2140 ], [ %2136, %2134 ]
  %2144 = load i64, i64* %9, align 8, !tbaa !129
  %2145 = and i64 %2143, %2144
  %2146 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2145, i64* %2146, align 8, !tbaa !21
  %2147 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2147, align 8, !tbaa !22
  br label %2151

; <label>:2148:                                   ; preds = %2137, %2127
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2149 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2149, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2117, %struct.TValue* %2120, %union.StackValue* %4019, i32 13) #16
  %2150 = load i32, i32* %37, align 8, !tbaa !21
  br label %2151

; <label>:2151:                                   ; preds = %2148, %2142
  %2152 = phi i32 [ %4014, %2142 ], [ %2150, %2148 ]
  %2153 = icmp eq i32 %2152, 0
  br i1 %2153, label %2158, label %2154

; <label>:2154:                                   ; preds = %2151
  %2155 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2156 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2157 = getelementptr inbounds %union.StackValue, %union.StackValue* %2156, i64 1
  br label %2158

; <label>:2158:                                   ; preds = %2151, %2154
  %2159 = phi i32 [ %2155, %2154 ], [ 0, %2151 ]
  %2160 = phi %union.StackValue* [ %2157, %2154 ], [ %4013, %2151 ]
  %2161 = getelementptr inbounds i32, i32* %4015, i64 1
  %2162 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2163:                                   ; preds = %4011
  %2164 = lshr i32 %4012, 16
  %2165 = and i32 %2164, 255
  %2166 = zext i32 %2165 to i64
  %2167 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2166, i32 0
  %2168 = lshr i32 %4012, 24
  %2169 = zext i32 %2168 to i64
  %2170 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2169, i32 0
  %2171 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2166, i32 0, i32 1
  %2172 = load i8, i8* %2171, align 8, !tbaa !22
  %2173 = icmp eq i8 %2172, 35
  br i1 %2173, label %2174, label %2177

; <label>:2174:                                   ; preds = %2163
  %2175 = bitcast %struct.TValue* %2167 to i64*
  %2176 = load i64, i64* %2175, align 8, !tbaa !21
  store i64 %2176, i64* %11, align 8, !tbaa !129
  br label %2180

; <label>:2177:                                   ; preds = %2163
  %2178 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2167, i64* nonnull %11, i32 0) #16
  %2179 = icmp eq i32 %2178, 0
  br i1 %2179, label %2198, label %2180

; <label>:2180:                                   ; preds = %2177, %2174
  %2181 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2169, i32 0, i32 1
  %2182 = load i8, i8* %2181, align 8, !tbaa !22
  %2183 = icmp eq i8 %2182, 35
  br i1 %2183, label %2184, label %2187

; <label>:2184:                                   ; preds = %2180
  %2185 = bitcast %struct.TValue* %2170 to i64*
  %2186 = load i64, i64* %2185, align 8, !tbaa !21
  store i64 %2186, i64* %12, align 8, !tbaa !129
  br label %2192

; <label>:2187:                                   ; preds = %2180
  %2188 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2170, i64* nonnull %12, i32 0) #16
  %2189 = icmp eq i32 %2188, 0
  br i1 %2189, label %2198, label %2190

; <label>:2190:                                   ; preds = %2187
  %2191 = load i64, i64* %12, align 8, !tbaa !129
  br label %2192

; <label>:2192:                                   ; preds = %2190, %2184
  %2193 = phi i64 [ %2191, %2190 ], [ %2186, %2184 ]
  %2194 = load i64, i64* %11, align 8, !tbaa !129
  %2195 = or i64 %2193, %2194
  %2196 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2195, i64* %2196, align 8, !tbaa !21
  %2197 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2197, align 8, !tbaa !22
  br label %2201

; <label>:2198:                                   ; preds = %2187, %2177
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2199 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2199, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2167, %struct.TValue* %2170, %union.StackValue* %4019, i32 14) #16
  %2200 = load i32, i32* %37, align 8, !tbaa !21
  br label %2201

; <label>:2201:                                   ; preds = %2198, %2192
  %2202 = phi i32 [ %4014, %2192 ], [ %2200, %2198 ]
  %2203 = icmp eq i32 %2202, 0
  br i1 %2203, label %2208, label %2204

; <label>:2204:                                   ; preds = %2201
  %2205 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2206 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2207 = getelementptr inbounds %union.StackValue, %union.StackValue* %2206, i64 1
  br label %2208

; <label>:2208:                                   ; preds = %2201, %2204
  %2209 = phi i32 [ %2205, %2204 ], [ 0, %2201 ]
  %2210 = phi %union.StackValue* [ %2207, %2204 ], [ %4013, %2201 ]
  %2211 = getelementptr inbounds i32, i32* %4015, i64 1
  %2212 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2213:                                   ; preds = %4011
  %2214 = lshr i32 %4012, 16
  %2215 = and i32 %2214, 255
  %2216 = zext i32 %2215 to i64
  %2217 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2216, i32 0
  %2218 = lshr i32 %4012, 24
  %2219 = zext i32 %2218 to i64
  %2220 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2219, i32 0
  %2221 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2216, i32 0, i32 1
  %2222 = load i8, i8* %2221, align 8, !tbaa !22
  %2223 = icmp eq i8 %2222, 35
  br i1 %2223, label %2224, label %2227

; <label>:2224:                                   ; preds = %2213
  %2225 = bitcast %struct.TValue* %2217 to i64*
  %2226 = load i64, i64* %2225, align 8, !tbaa !21
  store i64 %2226, i64* %13, align 8, !tbaa !129
  br label %2230

; <label>:2227:                                   ; preds = %2213
  %2228 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2217, i64* nonnull %13, i32 0) #16
  %2229 = icmp eq i32 %2228, 0
  br i1 %2229, label %2248, label %2230

; <label>:2230:                                   ; preds = %2227, %2224
  %2231 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2219, i32 0, i32 1
  %2232 = load i8, i8* %2231, align 8, !tbaa !22
  %2233 = icmp eq i8 %2232, 35
  br i1 %2233, label %2234, label %2237

; <label>:2234:                                   ; preds = %2230
  %2235 = bitcast %struct.TValue* %2220 to i64*
  %2236 = load i64, i64* %2235, align 8, !tbaa !21
  store i64 %2236, i64* %14, align 8, !tbaa !129
  br label %2242

; <label>:2237:                                   ; preds = %2230
  %2238 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2220, i64* nonnull %14, i32 0) #16
  %2239 = icmp eq i32 %2238, 0
  br i1 %2239, label %2248, label %2240

; <label>:2240:                                   ; preds = %2237
  %2241 = load i64, i64* %14, align 8, !tbaa !129
  br label %2242

; <label>:2242:                                   ; preds = %2240, %2234
  %2243 = phi i64 [ %2241, %2240 ], [ %2236, %2234 ]
  %2244 = load i64, i64* %13, align 8, !tbaa !129
  %2245 = xor i64 %2243, %2244
  %2246 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2245, i64* %2246, align 8, !tbaa !21
  %2247 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2247, align 8, !tbaa !22
  br label %2251

; <label>:2248:                                   ; preds = %2237, %2227
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2249 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2249, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2217, %struct.TValue* %2220, %union.StackValue* %4019, i32 15) #16
  %2250 = load i32, i32* %37, align 8, !tbaa !21
  br label %2251

; <label>:2251:                                   ; preds = %2248, %2242
  %2252 = phi i32 [ %4014, %2242 ], [ %2250, %2248 ]
  %2253 = icmp eq i32 %2252, 0
  br i1 %2253, label %2258, label %2254

; <label>:2254:                                   ; preds = %2251
  %2255 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2256 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2257 = getelementptr inbounds %union.StackValue, %union.StackValue* %2256, i64 1
  br label %2258

; <label>:2258:                                   ; preds = %2251, %2254
  %2259 = phi i32 [ %2255, %2254 ], [ 0, %2251 ]
  %2260 = phi %union.StackValue* [ %2257, %2254 ], [ %4013, %2251 ]
  %2261 = getelementptr inbounds i32, i32* %4015, i64 1
  %2262 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2263:                                   ; preds = %4011
  %2264 = lshr i32 %4012, 16
  %2265 = and i32 %2264, 255
  %2266 = zext i32 %2265 to i64
  %2267 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2266, i32 0
  %2268 = lshr i32 %4012, 24
  %2269 = add nsw i32 %2268, -127
  %2270 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2266, i32 0, i32 1
  %2271 = load i8, i8* %2270, align 8, !tbaa !22
  %2272 = icmp eq i8 %2271, 35
  br i1 %2272, label %2273, label %2276

; <label>:2273:                                   ; preds = %2263
  %2274 = bitcast %struct.TValue* %2267 to i64*
  %2275 = load i64, i64* %2274, align 8, !tbaa !21
  store i64 %2275, i64* %15, align 8, !tbaa !129
  br label %2281

; <label>:2276:                                   ; preds = %2263
  %2277 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2267, i64* nonnull %15, i32 0) #16
  %2278 = icmp eq i32 %2277, 0
  br i1 %2278, label %2288, label %2279

; <label>:2279:                                   ; preds = %2276
  %2280 = load i64, i64* %15, align 8, !tbaa !129
  br label %2281

; <label>:2281:                                   ; preds = %2279, %2273
  %2282 = phi i64 [ %2280, %2279 ], [ %2275, %2273 ]
  %2283 = sub nsw i32 127, %2268
  %2284 = sext i32 %2283 to i64
  %2285 = call fastcc i64 @luaV_shiftl(i64 %2282, i64 %2284) #16
  %2286 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2285, i64* %2286, align 8, !tbaa !21
  %2287 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2287, align 8, !tbaa !22
  br label %2299

; <label>:2288:                                   ; preds = %2276
  %2289 = trunc i32 %4012 to i16
  %2290 = icmp slt i16 %2289, 0
  %2291 = sub nsw i32 127, %2268
  %2292 = lshr i32 %4012, 15
  %2293 = and i32 %2292, 1
  %2294 = sub nsw i32 17, %2293
  %2295 = select i1 %2290, i32 %2291, i32 %2269
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2296 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2296, i64* %35, align 8, !tbaa !20
  %2297 = sext i32 %2295 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2267, i64 %2297, i32 0, %union.StackValue* %4019, i32 %2294) #16
  %2298 = load i32, i32* %37, align 8, !tbaa !21
  br label %2299

; <label>:2299:                                   ; preds = %2288, %2281
  %2300 = phi i32 [ %4014, %2281 ], [ %2298, %2288 ]
  %2301 = icmp eq i32 %2300, 0
  br i1 %2301, label %2306, label %2302

; <label>:2302:                                   ; preds = %2299
  %2303 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2304 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2305 = getelementptr inbounds %union.StackValue, %union.StackValue* %2304, i64 1
  br label %2306

; <label>:2306:                                   ; preds = %2299, %2302
  %2307 = phi i32 [ %2303, %2302 ], [ 0, %2299 ]
  %2308 = phi %union.StackValue* [ %2305, %2302 ], [ %4013, %2299 ]
  %2309 = getelementptr inbounds i32, i32* %4015, i64 1
  %2310 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2311:                                   ; preds = %4011
  %2312 = lshr i32 %4012, 16
  %2313 = and i32 %2312, 255
  %2314 = zext i32 %2313 to i64
  %2315 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2314, i32 0
  %2316 = lshr i32 %4012, 24
  %2317 = add nsw i32 %2316, -127
  %2318 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2314, i32 0, i32 1
  %2319 = load i8, i8* %2318, align 8, !tbaa !22
  %2320 = icmp eq i8 %2319, 35
  br i1 %2320, label %2321, label %2324

; <label>:2321:                                   ; preds = %2311
  %2322 = bitcast %struct.TValue* %2315 to i64*
  %2323 = load i64, i64* %2322, align 8, !tbaa !21
  store i64 %2323, i64* %16, align 8, !tbaa !129
  br label %2329

; <label>:2324:                                   ; preds = %2311
  %2325 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2315, i64* nonnull %16, i32 0) #16
  %2326 = icmp eq i32 %2325, 0
  br i1 %2326, label %2335, label %2327

; <label>:2327:                                   ; preds = %2324
  %2328 = load i64, i64* %16, align 8, !tbaa !129
  br label %2329

; <label>:2329:                                   ; preds = %2327, %2321
  %2330 = phi i64 [ %2328, %2327 ], [ %2323, %2321 ]
  %2331 = sext i32 %2317 to i64
  %2332 = call fastcc i64 @luaV_shiftl(i64 %2331, i64 %2330) #16
  %2333 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2332, i64* %2333, align 8, !tbaa !21
  %2334 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2334, align 8, !tbaa !22
  br label %2339

; <label>:2335:                                   ; preds = %2324
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2336 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2336, i64* %35, align 8, !tbaa !20
  %2337 = sext i32 %2317 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2315, i64 %2337, i32 1, %union.StackValue* %4019, i32 16) #16
  %2338 = load i32, i32* %37, align 8, !tbaa !21
  br label %2339

; <label>:2339:                                   ; preds = %2335, %2329
  %2340 = phi i32 [ %4014, %2329 ], [ %2338, %2335 ]
  %2341 = icmp eq i32 %2340, 0
  br i1 %2341, label %2346, label %2342

; <label>:2342:                                   ; preds = %2339
  %2343 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2344 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2345 = getelementptr inbounds %union.StackValue, %union.StackValue* %2344, i64 1
  br label %2346

; <label>:2346:                                   ; preds = %2339, %2342
  %2347 = phi i32 [ %2343, %2342 ], [ 0, %2339 ]
  %2348 = phi %union.StackValue* [ %2345, %2342 ], [ %4013, %2339 ]
  %2349 = getelementptr inbounds i32, i32* %4015, i64 1
  %2350 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2351:                                   ; preds = %4011
  %2352 = lshr i32 %4012, 16
  %2353 = and i32 %2352, 255
  %2354 = zext i32 %2353 to i64
  %2355 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2354, i32 0
  %2356 = lshr i32 %4012, 24
  %2357 = zext i32 %2356 to i64
  %2358 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2357, i32 0
  %2359 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2354, i32 0, i32 1
  %2360 = load i8, i8* %2359, align 8, !tbaa !22
  %2361 = icmp eq i8 %2360, 35
  br i1 %2361, label %2362, label %2365

; <label>:2362:                                   ; preds = %2351
  %2363 = bitcast %struct.TValue* %2355 to i64*
  %2364 = load i64, i64* %2363, align 8, !tbaa !21
  store i64 %2364, i64* %17, align 8, !tbaa !129
  br label %2368

; <label>:2365:                                   ; preds = %2351
  %2366 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2355, i64* nonnull %17, i32 0) #16
  %2367 = icmp eq i32 %2366, 0
  br i1 %2367, label %2387, label %2368

; <label>:2368:                                   ; preds = %2365, %2362
  %2369 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2357, i32 0, i32 1
  %2370 = load i8, i8* %2369, align 8, !tbaa !22
  %2371 = icmp eq i8 %2370, 35
  br i1 %2371, label %2372, label %2375

; <label>:2372:                                   ; preds = %2368
  %2373 = bitcast %struct.TValue* %2358 to i64*
  %2374 = load i64, i64* %2373, align 8, !tbaa !21
  store i64 %2374, i64* %18, align 8, !tbaa !129
  br label %2380

; <label>:2375:                                   ; preds = %2368
  %2376 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2358, i64* nonnull %18, i32 0) #16
  %2377 = icmp eq i32 %2376, 0
  br i1 %2377, label %2387, label %2378

; <label>:2378:                                   ; preds = %2375
  %2379 = load i64, i64* %18, align 8, !tbaa !129
  br label %2380

; <label>:2380:                                   ; preds = %2378, %2372
  %2381 = phi i64 [ %2379, %2378 ], [ %2374, %2372 ]
  %2382 = load i64, i64* %17, align 8, !tbaa !129
  %2383 = sub nsw i64 0, %2381
  %2384 = call fastcc i64 @luaV_shiftl(i64 %2382, i64 %2383) #16
  %2385 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2384, i64* %2385, align 8, !tbaa !21
  %2386 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2386, align 8, !tbaa !22
  br label %2390

; <label>:2387:                                   ; preds = %2375, %2365
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2388 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2388, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2355, %struct.TValue* %2358, %union.StackValue* %4019, i32 17) #16
  %2389 = load i32, i32* %37, align 8, !tbaa !21
  br label %2390

; <label>:2390:                                   ; preds = %2387, %2380
  %2391 = phi i32 [ %4014, %2380 ], [ %2389, %2387 ]
  %2392 = icmp eq i32 %2391, 0
  br i1 %2392, label %2397, label %2393

; <label>:2393:                                   ; preds = %2390
  %2394 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2395 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2396 = getelementptr inbounds %union.StackValue, %union.StackValue* %2395, i64 1
  br label %2397

; <label>:2397:                                   ; preds = %2390, %2393
  %2398 = phi i32 [ %2394, %2393 ], [ 0, %2390 ]
  %2399 = phi %union.StackValue* [ %2396, %2393 ], [ %4013, %2390 ]
  %2400 = getelementptr inbounds i32, i32* %4015, i64 1
  %2401 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2402:                                   ; preds = %4011
  %2403 = lshr i32 %4012, 16
  %2404 = and i32 %2403, 255
  %2405 = zext i32 %2404 to i64
  %2406 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2405, i32 0
  %2407 = lshr i32 %4012, 24
  %2408 = zext i32 %2407 to i64
  %2409 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2408, i32 0
  %2410 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2405, i32 0, i32 1
  %2411 = load i8, i8* %2410, align 8, !tbaa !22
  %2412 = icmp eq i8 %2411, 35
  br i1 %2412, label %2413, label %2416

; <label>:2413:                                   ; preds = %2402
  %2414 = bitcast %struct.TValue* %2406 to i64*
  %2415 = load i64, i64* %2414, align 8, !tbaa !21
  store i64 %2415, i64* %19, align 8, !tbaa !129
  br label %2419

; <label>:2416:                                   ; preds = %2402
  %2417 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2406, i64* nonnull %19, i32 0) #16
  %2418 = icmp eq i32 %2417, 0
  br i1 %2418, label %2437, label %2419

; <label>:2419:                                   ; preds = %2416, %2413
  %2420 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2408, i32 0, i32 1
  %2421 = load i8, i8* %2420, align 8, !tbaa !22
  %2422 = icmp eq i8 %2421, 35
  br i1 %2422, label %2423, label %2426

; <label>:2423:                                   ; preds = %2419
  %2424 = bitcast %struct.TValue* %2409 to i64*
  %2425 = load i64, i64* %2424, align 8, !tbaa !21
  store i64 %2425, i64* %20, align 8, !tbaa !129
  br label %2431

; <label>:2426:                                   ; preds = %2419
  %2427 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2409, i64* nonnull %20, i32 0) #16
  %2428 = icmp eq i32 %2427, 0
  br i1 %2428, label %2437, label %2429

; <label>:2429:                                   ; preds = %2426
  %2430 = load i64, i64* %20, align 8, !tbaa !129
  br label %2431

; <label>:2431:                                   ; preds = %2429, %2423
  %2432 = phi i64 [ %2430, %2429 ], [ %2425, %2423 ]
  %2433 = load i64, i64* %19, align 8, !tbaa !129
  %2434 = call fastcc i64 @luaV_shiftl(i64 %2433, i64 %2432) #16
  %2435 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2434, i64* %2435, align 8, !tbaa !21
  %2436 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2436, align 8, !tbaa !22
  br label %2440

; <label>:2437:                                   ; preds = %2426, %2416
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2438 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2438, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2406, %struct.TValue* %2409, %union.StackValue* %4019, i32 16) #16
  %2439 = load i32, i32* %37, align 8, !tbaa !21
  br label %2440

; <label>:2440:                                   ; preds = %2437, %2431
  %2441 = phi i32 [ %4014, %2431 ], [ %2439, %2437 ]
  %2442 = icmp eq i32 %2441, 0
  br i1 %2442, label %2447, label %2443

; <label>:2443:                                   ; preds = %2440
  %2444 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2445 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2446 = getelementptr inbounds %union.StackValue, %union.StackValue* %2445, i64 1
  br label %2447

; <label>:2447:                                   ; preds = %2440, %2443
  %2448 = phi i32 [ %2444, %2443 ], [ 0, %2440 ]
  %2449 = phi %union.StackValue* [ %2446, %2443 ], [ %4013, %2440 ]
  %2450 = getelementptr inbounds i32, i32* %4015, i64 1
  %2451 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2452:                                   ; preds = %4011
  %2453 = lshr i32 %4012, 16
  %2454 = and i32 %2453, 255
  %2455 = zext i32 %2454 to i64
  %2456 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2455, i32 0
  %2457 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2455, i32 0, i32 1
  %2458 = load i8, i8* %2457, align 8, !tbaa !22
  switch i8 %2458, label %2471 [
    i8 35, label %2459
    i8 19, label %2465
  ]

; <label>:2459:                                   ; preds = %2452
  %2460 = bitcast %struct.TValue* %2456 to i64*
  %2461 = load i64, i64* %2460, align 8, !tbaa !21
  %2462 = sub i64 0, %2461
  %2463 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2462, i64* %2463, align 8, !tbaa !21
  %2464 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2464, align 8, !tbaa !22
  br label %2474

; <label>:2465:                                   ; preds = %2452
  %2466 = bitcast %struct.TValue* %2456 to double*
  %2467 = load double, double* %2466, align 8, !tbaa !21
  %2468 = fsub double -0.000000e+00, %2467
  %2469 = bitcast %union.StackValue* %4019 to double*
  store double %2468, double* %2469, align 8, !tbaa !21
  %2470 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 19, i8* %2470, align 8, !tbaa !22
  br label %2474

; <label>:2471:                                   ; preds = %2452
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2472 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2472, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2456, %struct.TValue* %2456, %union.StackValue* %4019, i32 18) #16
  %2473 = load i32, i32* %37, align 8, !tbaa !21
  br label %2474

; <label>:2474:                                   ; preds = %2465, %2471, %2459
  %2475 = phi i32 [ %4014, %2459 ], [ %4014, %2465 ], [ %2473, %2471 ]
  %2476 = icmp eq i32 %2475, 0
  br i1 %2476, label %2481, label %2477

; <label>:2477:                                   ; preds = %2474
  %2478 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2479 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2480 = getelementptr inbounds %union.StackValue, %union.StackValue* %2479, i64 1
  br label %2481

; <label>:2481:                                   ; preds = %2474, %2477
  %2482 = phi i32 [ %2478, %2477 ], [ 0, %2474 ]
  %2483 = phi %union.StackValue* [ %2480, %2477 ], [ %4013, %2474 ]
  %2484 = getelementptr inbounds i32, i32* %4015, i64 1
  %2485 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2486:                                   ; preds = %4011
  %2487 = lshr i32 %4012, 16
  %2488 = and i32 %2487, 255
  %2489 = zext i32 %2488 to i64
  %2490 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2489, i32 0
  %2491 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2489, i32 0, i32 1
  %2492 = load i8, i8* %2491, align 8, !tbaa !22
  %2493 = icmp eq i8 %2492, 35
  br i1 %2493, label %2494, label %2497

; <label>:2494:                                   ; preds = %2486
  %2495 = bitcast %struct.TValue* %2490 to i64*
  %2496 = load i64, i64* %2495, align 8, !tbaa !21
  store i64 %2496, i64* %21, align 8, !tbaa !129
  br label %2502

; <label>:2497:                                   ; preds = %2486
  %2498 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2490, i64* nonnull %21, i32 0) #16
  %2499 = icmp eq i32 %2498, 0
  br i1 %2499, label %2507, label %2500

; <label>:2500:                                   ; preds = %2497
  %2501 = load i64, i64* %21, align 8, !tbaa !129
  br label %2502

; <label>:2502:                                   ; preds = %2500, %2494
  %2503 = phi i64 [ %2501, %2500 ], [ %2496, %2494 ]
  %2504 = xor i64 %2503, -1
  %2505 = bitcast %union.StackValue* %4019 to i64*
  store i64 %2504, i64* %2505, align 8, !tbaa !21
  %2506 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 35, i8* %2506, align 8, !tbaa !22
  br label %2510

; <label>:2507:                                   ; preds = %2497
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2508 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2508, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2490, %struct.TValue* %2490, %union.StackValue* %4019, i32 19) #16
  %2509 = load i32, i32* %37, align 8, !tbaa !21
  br label %2510

; <label>:2510:                                   ; preds = %2507, %2502
  %2511 = phi i32 [ %4014, %2502 ], [ %2509, %2507 ]
  %2512 = icmp eq i32 %2511, 0
  br i1 %2512, label %2517, label %2513

; <label>:2513:                                   ; preds = %2510
  %2514 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2515 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2516 = getelementptr inbounds %union.StackValue, %union.StackValue* %2515, i64 1
  br label %2517

; <label>:2517:                                   ; preds = %2510, %2513
  %2518 = phi i32 [ %2514, %2513 ], [ 0, %2510 ]
  %2519 = phi %union.StackValue* [ %2516, %2513 ], [ %4013, %2510 ]
  %2520 = getelementptr inbounds i32, i32* %4015, i64 1
  %2521 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2522:                                   ; preds = %4011
  %2523 = lshr i32 %4012, 16
  %2524 = and i32 %2523, 255
  %2525 = zext i32 %2524 to i64
  %2526 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2525, i32 0, i32 1
  %2527 = load i8, i8* %2526, align 8, !tbaa !22
  %2528 = and i8 %2527, 15
  %2529 = icmp eq i8 %2528, 0
  br i1 %2529, label %2537, label %2530

; <label>:2530:                                   ; preds = %2522
  %2531 = icmp eq i8 %2527, 1
  br i1 %2531, label %2532, label %2537

; <label>:2532:                                   ; preds = %2530
  %2533 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2525, i32 0, i32 0
  %2534 = bitcast %union.Value* %2533 to i32*
  %2535 = load i32, i32* %2534, align 8, !tbaa !21
  %2536 = icmp eq i32 %2535, 0
  br label %2537

; <label>:2537:                                   ; preds = %2530, %2532, %2522
  %2538 = phi i1 [ true, %2522 ], [ false, %2530 ], [ %2536, %2532 ]
  %2539 = zext i1 %2538 to i32
  %2540 = bitcast %union.StackValue* %4019 to i32*
  store i32 %2539, i32* %2540, align 8, !tbaa !21
  %2541 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 1, i8* %2541, align 8, !tbaa !22
  %2542 = icmp eq i32 %4014, 0
  br i1 %2542, label %2547, label %2543

; <label>:2543:                                   ; preds = %2537
  %2544 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2545 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2546 = getelementptr inbounds %union.StackValue, %union.StackValue* %2545, i64 1
  br label %2547

; <label>:2547:                                   ; preds = %2537, %2543
  %2548 = phi i32 [ %2544, %2543 ], [ 0, %2537 ]
  %2549 = phi %union.StackValue* [ %2546, %2543 ], [ %4013, %2537 ]
  %2550 = getelementptr inbounds i32, i32* %4015, i64 1
  %2551 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2552:                                   ; preds = %4011
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2553 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2553, i64* %35, align 8, !tbaa !20
  %2554 = lshr i32 %4012, 16
  %2555 = and i32 %2554, 255
  %2556 = zext i32 %2555 to i64
  %2557 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2556, i32 0
  call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %4019, %struct.TValue* %2557) #16
  %2558 = load i32, i32* %37, align 8, !tbaa !21
  %2559 = icmp eq i32 %2558, 0
  br i1 %2559, label %2564, label %2560

; <label>:2560:                                   ; preds = %2552
  %2561 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4015) #16
  %2562 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2563 = getelementptr inbounds %union.StackValue, %union.StackValue* %2562, i64 1
  br label %2564

; <label>:2564:                                   ; preds = %2552, %2560
  %2565 = phi i32 [ %2561, %2560 ], [ 0, %2552 ]
  %2566 = phi %union.StackValue* [ %2563, %2560 ], [ %4013, %2552 ]
  %2567 = getelementptr inbounds i32, i32* %4015, i64 1
  %2568 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2569:                                   ; preds = %4011
  %2570 = lshr i32 %4012, 16
  %2571 = and i32 %2570, 255
  %2572 = zext i32 %2571 to i64
  %2573 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %2572
  store %union.StackValue* %2573, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %2571) #16
  %2574 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %2575 = getelementptr inbounds %struct.global_State, %struct.global_State* %2574, i64 0, i32 3
  %2576 = load i64, i64* %2575, align 8, !tbaa !11
  %2577 = icmp sgt i64 %2576, 0
  br i1 %2577, label %2578, label %2579

; <label>:2578:                                   ; preds = %2569
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %2579

; <label>:2579:                                   ; preds = %2578, %2569
  %2580 = load i32, i32* %37, align 8, !tbaa !21
  %2581 = icmp eq i32 %2580, 0
  br i1 %2581, label %2586, label %2582

; <label>:2582:                                   ; preds = %2579
  %2583 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4015) #16
  %2584 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2585 = getelementptr inbounds %union.StackValue, %union.StackValue* %2584, i64 1
  br label %2586

; <label>:2586:                                   ; preds = %2579, %2582
  %2587 = phi i32 [ %2583, %2582 ], [ 0, %2579 ]
  %2588 = phi %union.StackValue* [ %2585, %2582 ], [ %4013, %2579 ]
  %2589 = getelementptr inbounds i32, i32* %4015, i64 1
  %2590 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2591:                                   ; preds = %4011
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2592 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2592, i64* %35, align 8, !tbaa !20
  %2593 = call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4019, i32 0) #16
  %2594 = load i32, i32* %37, align 8, !tbaa !21
  %2595 = icmp eq i32 %2594, 0
  br i1 %2595, label %2600, label %2596

; <label>:2596:                                   ; preds = %2591
  %2597 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4015) #16
  %2598 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2599 = getelementptr inbounds %union.StackValue, %union.StackValue* %2598, i64 1
  br label %2600

; <label>:2600:                                   ; preds = %2591, %2596
  %2601 = phi i32 [ %2597, %2596 ], [ 0, %2591 ]
  %2602 = phi %union.StackValue* [ %2599, %2596 ], [ %4013, %2591 ]
  %2603 = getelementptr inbounds i32, i32* %4015, i64 1
  %2604 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2605:                                   ; preds = %4011
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* %4019) #16
  %2606 = icmp eq i32 %4014, 0
  br i1 %2606, label %2611, label %2607

; <label>:2607:                                   ; preds = %2605
  %2608 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %2609 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2610 = getelementptr inbounds %union.StackValue, %union.StackValue* %2609, i64 1
  br label %2611

; <label>:2611:                                   ; preds = %2605, %2607
  %2612 = phi i32 [ %2608, %2607 ], [ 0, %2605 ]
  %2613 = phi %union.StackValue* [ %2610, %2607 ], [ %4013, %2605 ]
  %2614 = getelementptr inbounds i32, i32* %4015, i64 1
  %2615 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:2616:                                   ; preds = %4011
  %2617 = lshr i32 %4012, 7
  %2618 = add nsw i32 %2617, -16777215
  %2619 = sext i32 %2618 to i64
  %2620 = getelementptr inbounds i32, i32* %4015, i64 %2619
  %2621 = load i32, i32* %37, align 8, !tbaa !21
  %2622 = icmp eq i32 %2621, 0
  br i1 %2622, label %2627, label %2623

; <label>:2623:                                   ; preds = %2616
  %2624 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2620) #16
  %2625 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2626 = getelementptr inbounds %union.StackValue, %union.StackValue* %2625, i64 1
  br label %2627

; <label>:2627:                                   ; preds = %2616, %2623
  %2628 = phi i32 [ %2624, %2623 ], [ 0, %2616 ]
  %2629 = phi %union.StackValue* [ %2626, %2623 ], [ %4013, %2616 ]
  %2630 = getelementptr inbounds i32, i32* %2620, i64 1
  %2631 = load i32, i32* %2620, align 4, !tbaa !74
  br label %110

; <label>:2632:                                   ; preds = %4011
  %2633 = lshr i32 %4012, 16
  %2634 = and i32 %2633, 255
  %2635 = zext i32 %2634 to i64
  %2636 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2635, i32 0
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2637 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2637, i64* %35, align 8, !tbaa !20
  %2638 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2639 = call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %2638, %struct.TValue* %2636) #16
  %2640 = load i32, i32* %37, align 8, !tbaa !21
  %2641 = lshr i32 %4012, 15
  %2642 = and i32 %2641, 1
  %2643 = icmp eq i32 %2639, %2642
  br i1 %2643, label %2644, label %2649

; <label>:2644:                                   ; preds = %2632
  %2645 = load i32, i32* %4015, align 4, !tbaa !74
  %2646 = lshr i32 %2645, 7
  %2647 = add nsw i32 %2646, -16777214
  %2648 = sext i32 %2647 to i64
  br label %2649

; <label>:2649:                                   ; preds = %2632, %2644
  %2650 = phi i64 [ %2648, %2644 ], [ 1, %2632 ]
  %2651 = getelementptr inbounds i32, i32* %4015, i64 %2650
  %2652 = icmp eq i32 %2640, 0
  br i1 %2652, label %2657, label %2653

; <label>:2653:                                   ; preds = %2649
  %2654 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %2651) #16
  %2655 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2656 = getelementptr inbounds %union.StackValue, %union.StackValue* %2655, i64 1
  br label %2657

; <label>:2657:                                   ; preds = %2649, %2653
  %2658 = phi i32 [ %2654, %2653 ], [ 0, %2649 ]
  %2659 = phi %union.StackValue* [ %2656, %2653 ], [ %4013, %2649 ]
  %2660 = getelementptr inbounds i32, i32* %2651, i64 1
  %2661 = load i32, i32* %2651, align 4, !tbaa !74
  br label %110

; <label>:2662:                                   ; preds = %4011
  %2663 = lshr i32 %4012, 16
  %2664 = and i32 %2663, 255
  %2665 = zext i32 %2664 to i64
  %2666 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2665, i32 0
  %2667 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2668 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2669 = load i8, i8* %2668, align 8, !tbaa !21
  %2670 = icmp eq i8 %2669, 35
  br i1 %2670, label %2671, label %2682

; <label>:2671:                                   ; preds = %2662
  %2672 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2665, i32 0, i32 1
  %2673 = load i8, i8* %2672, align 8, !tbaa !22
  %2674 = icmp eq i8 %2673, 35
  br i1 %2674, label %2675, label %2688

; <label>:2675:                                   ; preds = %2671
  %2676 = bitcast %union.StackValue* %4019 to i64*
  %2677 = load i64, i64* %2676, align 8, !tbaa !21
  %2678 = bitcast %struct.TValue* %2666 to i64*
  %2679 = load i64, i64* %2678, align 8, !tbaa !21
  %2680 = icmp slt i64 %2677, %2679
  %2681 = zext i1 %2680 to i32
  br label %2698

; <label>:2682:                                   ; preds = %2662
  %2683 = and i8 %2669, 15
  %2684 = icmp eq i8 %2683, 3
  br i1 %2684, label %2685, label %2694

; <label>:2685:                                   ; preds = %2682
  %2686 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2665, i32 0, i32 1
  %2687 = load i8, i8* %2686, align 8, !tbaa !22
  br label %2688

; <label>:2688:                                   ; preds = %2685, %2671
  %2689 = phi i8 [ %2687, %2685 ], [ %2673, %2671 ]
  %2690 = and i8 %2689, 15
  %2691 = icmp eq i8 %2690, 3
  br i1 %2691, label %2692, label %2694

; <label>:2692:                                   ; preds = %2688
  %2693 = call fastcc i32 @LTnum(%struct.TValue* %2667, %struct.TValue* nonnull %2666) #16
  br label %2698

; <label>:2694:                                   ; preds = %2688, %2682
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2695 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2695, i64* %35, align 8, !tbaa !20
  %2696 = call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* %2667, %struct.TValue* %2666) #16
  %2697 = load i32, i32* %37, align 8, !tbaa !21
  br label %2698

; <label>:2698:                                   ; preds = %2692, %2694, %2675
  %2699 = phi i32 [ %2681, %2675 ], [ %2693, %2692 ], [ %2696, %2694 ]
  %2700 = phi i32 [ %4014, %2675 ], [ %4014, %2692 ], [ %2697, %2694 ]
  %2701 = lshr i32 %4012, 15
  %2702 = and i32 %2701, 1
  %2703 = icmp eq i32 %2699, %2702
  br i1 %2703, label %2706, label %2704

; <label>:2704:                                   ; preds = %2698
  %2705 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2713

; <label>:2706:                                   ; preds = %2698
  %2707 = load i32, i32* %4015, align 4, !tbaa !74
  %2708 = lshr i32 %2707, 7
  %2709 = add nsw i32 %2708, -16777214
  %2710 = sext i32 %2709 to i64
  %2711 = getelementptr inbounds i32, i32* %4015, i64 %2710
  %2712 = load i32, i32* %37, align 8, !tbaa !21
  br label %2713

; <label>:2713:                                   ; preds = %2706, %2704
  %2714 = phi i32 [ %2700, %2704 ], [ %2712, %2706 ]
  %2715 = phi i32* [ %2705, %2704 ], [ %2711, %2706 ]
  %2716 = icmp eq i32 %2714, 0
  br i1 %2716, label %2721, label %2717

; <label>:2717:                                   ; preds = %2713
  %2718 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2715) #16
  %2719 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2720 = getelementptr inbounds %union.StackValue, %union.StackValue* %2719, i64 1
  br label %2721

; <label>:2721:                                   ; preds = %2713, %2717
  %2722 = phi i32 [ %2718, %2717 ], [ 0, %2713 ]
  %2723 = phi %union.StackValue* [ %2720, %2717 ], [ %4013, %2713 ]
  %2724 = getelementptr inbounds i32, i32* %2715, i64 1
  %2725 = load i32, i32* %2715, align 4, !tbaa !74
  br label %110

; <label>:2726:                                   ; preds = %4011
  %2727 = lshr i32 %4012, 16
  %2728 = and i32 %2727, 255
  %2729 = zext i32 %2728 to i64
  %2730 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2729, i32 0
  %2731 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2732 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2733 = load i8, i8* %2732, align 8, !tbaa !21
  %2734 = icmp eq i8 %2733, 35
  br i1 %2734, label %2735, label %2746

; <label>:2735:                                   ; preds = %2726
  %2736 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2729, i32 0, i32 1
  %2737 = load i8, i8* %2736, align 8, !tbaa !22
  %2738 = icmp eq i8 %2737, 35
  br i1 %2738, label %2739, label %2752

; <label>:2739:                                   ; preds = %2735
  %2740 = bitcast %union.StackValue* %4019 to i64*
  %2741 = load i64, i64* %2740, align 8, !tbaa !21
  %2742 = bitcast %struct.TValue* %2730 to i64*
  %2743 = load i64, i64* %2742, align 8, !tbaa !21
  %2744 = icmp sle i64 %2741, %2743
  %2745 = zext i1 %2744 to i32
  br label %2762

; <label>:2746:                                   ; preds = %2726
  %2747 = and i8 %2733, 15
  %2748 = icmp eq i8 %2747, 3
  br i1 %2748, label %2749, label %2758

; <label>:2749:                                   ; preds = %2746
  %2750 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %2729, i32 0, i32 1
  %2751 = load i8, i8* %2750, align 8, !tbaa !22
  br label %2752

; <label>:2752:                                   ; preds = %2749, %2735
  %2753 = phi i8 [ %2751, %2749 ], [ %2737, %2735 ]
  %2754 = and i8 %2753, 15
  %2755 = icmp eq i8 %2754, 3
  br i1 %2755, label %2756, label %2758

; <label>:2756:                                   ; preds = %2752
  %2757 = call fastcc i32 @LEnum(%struct.TValue* %2731, %struct.TValue* nonnull %2730) #16
  br label %2762

; <label>:2758:                                   ; preds = %2752, %2746
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2759 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2759, i64* %35, align 8, !tbaa !20
  %2760 = call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* %2731, %struct.TValue* %2730) #16
  %2761 = load i32, i32* %37, align 8, !tbaa !21
  br label %2762

; <label>:2762:                                   ; preds = %2756, %2758, %2739
  %2763 = phi i32 [ %2745, %2739 ], [ %2757, %2756 ], [ %2760, %2758 ]
  %2764 = phi i32 [ %4014, %2739 ], [ %4014, %2756 ], [ %2761, %2758 ]
  %2765 = lshr i32 %4012, 15
  %2766 = and i32 %2765, 1
  %2767 = icmp eq i32 %2763, %2766
  br i1 %2767, label %2770, label %2768

; <label>:2768:                                   ; preds = %2762
  %2769 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2777

; <label>:2770:                                   ; preds = %2762
  %2771 = load i32, i32* %4015, align 4, !tbaa !74
  %2772 = lshr i32 %2771, 7
  %2773 = add nsw i32 %2772, -16777214
  %2774 = sext i32 %2773 to i64
  %2775 = getelementptr inbounds i32, i32* %4015, i64 %2774
  %2776 = load i32, i32* %37, align 8, !tbaa !21
  br label %2777

; <label>:2777:                                   ; preds = %2770, %2768
  %2778 = phi i32 [ %2764, %2768 ], [ %2776, %2770 ]
  %2779 = phi i32* [ %2769, %2768 ], [ %2775, %2770 ]
  %2780 = icmp eq i32 %2778, 0
  br i1 %2780, label %2785, label %2781

; <label>:2781:                                   ; preds = %2777
  %2782 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2779) #16
  %2783 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2784 = getelementptr inbounds %union.StackValue, %union.StackValue* %2783, i64 1
  br label %2785

; <label>:2785:                                   ; preds = %2777, %2781
  %2786 = phi i32 [ %2782, %2781 ], [ 0, %2777 ]
  %2787 = phi %union.StackValue* [ %2784, %2781 ], [ %4013, %2777 ]
  %2788 = getelementptr inbounds i32, i32* %2779, i64 1
  %2789 = load i32, i32* %2779, align 4, !tbaa !74
  br label %110

; <label>:2790:                                   ; preds = %4011
  %2791 = lshr i32 %4012, 16
  %2792 = and i32 %2791, 255
  %2793 = zext i32 %2792 to i64
  %2794 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 %2793
  %2795 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2796 = call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %2795, %struct.TValue* %2794) #16
  %2797 = lshr i32 %4012, 15
  %2798 = and i32 %2797, 1
  %2799 = icmp eq i32 %2796, %2798
  br i1 %2799, label %2802, label %2800

; <label>:2800:                                   ; preds = %2790
  %2801 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2809

; <label>:2802:                                   ; preds = %2790
  %2803 = load i32, i32* %4015, align 4, !tbaa !74
  %2804 = lshr i32 %2803, 7
  %2805 = add nsw i32 %2804, -16777214
  %2806 = sext i32 %2805 to i64
  %2807 = getelementptr inbounds i32, i32* %4015, i64 %2806
  %2808 = load i32, i32* %37, align 8, !tbaa !21
  br label %2809

; <label>:2809:                                   ; preds = %2802, %2800
  %2810 = phi i32 [ %4014, %2800 ], [ %2808, %2802 ]
  %2811 = phi i32* [ %2801, %2800 ], [ %2807, %2802 ]
  %2812 = icmp eq i32 %2810, 0
  br i1 %2812, label %2817, label %2813

; <label>:2813:                                   ; preds = %2809
  %2814 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2811) #16
  %2815 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2816 = getelementptr inbounds %union.StackValue, %union.StackValue* %2815, i64 1
  br label %2817

; <label>:2817:                                   ; preds = %2809, %2813
  %2818 = phi i32 [ %2814, %2813 ], [ 0, %2809 ]
  %2819 = phi %union.StackValue* [ %2816, %2813 ], [ %4013, %2809 ]
  %2820 = getelementptr inbounds i32, i32* %2811, i64 1
  %2821 = load i32, i32* %2811, align 4, !tbaa !74
  br label %110

; <label>:2822:                                   ; preds = %4011
  %2823 = lshr i32 %4012, 16
  %2824 = and i32 %2823, 255
  %2825 = add nsw i32 %2824, -127
  %2826 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2827 = load i8, i8* %2826, align 8, !tbaa !21
  switch i8 %2827, label %2828 [
    i8 35, label %2831
    i8 19, label %2836
  ]

; <label>:2828:                                   ; preds = %2822
  %2829 = trunc i32 %4012 to i16
  %2830 = icmp slt i16 %2829, 0
  br i1 %2830, label %2846, label %2848

; <label>:2831:                                   ; preds = %2822
  %2832 = bitcast %union.StackValue* %4019 to i64*
  %2833 = load i64, i64* %2832, align 8, !tbaa !21
  %2834 = sext i32 %2825 to i64
  %2835 = icmp eq i64 %2833, %2834
  br label %2841

; <label>:2836:                                   ; preds = %2822
  %2837 = bitcast %union.StackValue* %4019 to double*
  %2838 = load double, double* %2837, align 8, !tbaa !21
  %2839 = sitofp i32 %2825 to double
  %2840 = fcmp oeq double %2838, %2839
  br label %2841

; <label>:2841:                                   ; preds = %2836, %2831
  %2842 = phi i1 [ %2835, %2831 ], [ %2840, %2836 ]
  %2843 = trunc i32 %4012 to i16
  %2844 = icmp slt i16 %2843, 0
  %2845 = xor i1 %2844, %2842
  br i1 %2845, label %2846, label %2848

; <label>:2846:                                   ; preds = %2828, %2841
  %2847 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2855

; <label>:2848:                                   ; preds = %2828, %2841
  %2849 = load i32, i32* %4015, align 4, !tbaa !74
  %2850 = lshr i32 %2849, 7
  %2851 = add nsw i32 %2850, -16777214
  %2852 = sext i32 %2851 to i64
  %2853 = getelementptr inbounds i32, i32* %4015, i64 %2852
  %2854 = load i32, i32* %37, align 8, !tbaa !21
  br label %2855

; <label>:2855:                                   ; preds = %2848, %2846
  %2856 = phi i32 [ %4014, %2846 ], [ %2854, %2848 ]
  %2857 = phi i32* [ %2847, %2846 ], [ %2853, %2848 ]
  %2858 = icmp eq i32 %2856, 0
  br i1 %2858, label %2863, label %2859

; <label>:2859:                                   ; preds = %2855
  %2860 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2857) #16
  %2861 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2862 = getelementptr inbounds %union.StackValue, %union.StackValue* %2861, i64 1
  br label %2863

; <label>:2863:                                   ; preds = %2855, %2859
  %2864 = phi i32 [ %2860, %2859 ], [ 0, %2855 ]
  %2865 = phi %union.StackValue* [ %2862, %2859 ], [ %4013, %2855 ]
  %2866 = getelementptr inbounds i32, i32* %2857, i64 1
  %2867 = load i32, i32* %2857, align 4, !tbaa !74
  br label %110

; <label>:2868:                                   ; preds = %4011
  %2869 = lshr i32 %4012, 16
  %2870 = and i32 %2869, 255
  %2871 = add nsw i32 %2870, -127
  %2872 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2873 = load i8, i8* %2872, align 8, !tbaa !21
  switch i8 %2873, label %2886 [
    i8 35, label %2874
    i8 19, label %2880
  ]

; <label>:2874:                                   ; preds = %2868
  %2875 = bitcast %union.StackValue* %4019 to i64*
  %2876 = load i64, i64* %2875, align 8, !tbaa !21
  %2877 = sext i32 %2871 to i64
  %2878 = icmp slt i64 %2876, %2877
  %2879 = zext i1 %2878 to i32
  br label %2892

; <label>:2880:                                   ; preds = %2868
  %2881 = bitcast %union.StackValue* %4019 to double*
  %2882 = load double, double* %2881, align 8, !tbaa !21
  %2883 = sitofp i32 %2871 to double
  %2884 = fcmp olt double %2882, %2883
  %2885 = zext i1 %2884 to i32
  br label %2892

; <label>:2886:                                   ; preds = %2868
  %2887 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2888 = lshr i32 %4012, 24
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2889 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2889, i64* %35, align 8, !tbaa !20
  %2890 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %2887, i32 %2871, i32 0, i32 %2888, i32 20) #16
  %2891 = load i32, i32* %37, align 8, !tbaa !21
  br label %2892

; <label>:2892:                                   ; preds = %2880, %2886, %2874
  %2893 = phi i32 [ %2879, %2874 ], [ %2885, %2880 ], [ %2890, %2886 ]
  %2894 = phi i32 [ %4014, %2874 ], [ %4014, %2880 ], [ %2891, %2886 ]
  %2895 = lshr i32 %4012, 15
  %2896 = and i32 %2895, 1
  %2897 = icmp eq i32 %2893, %2896
  br i1 %2897, label %2900, label %2898

; <label>:2898:                                   ; preds = %2892
  %2899 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2907

; <label>:2900:                                   ; preds = %2892
  %2901 = load i32, i32* %4015, align 4, !tbaa !74
  %2902 = lshr i32 %2901, 7
  %2903 = add nsw i32 %2902, -16777214
  %2904 = sext i32 %2903 to i64
  %2905 = getelementptr inbounds i32, i32* %4015, i64 %2904
  %2906 = load i32, i32* %37, align 8, !tbaa !21
  br label %2907

; <label>:2907:                                   ; preds = %2900, %2898
  %2908 = phi i32 [ %2894, %2898 ], [ %2906, %2900 ]
  %2909 = phi i32* [ %2899, %2898 ], [ %2905, %2900 ]
  %2910 = icmp eq i32 %2908, 0
  br i1 %2910, label %2915, label %2911

; <label>:2911:                                   ; preds = %2907
  %2912 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2909) #16
  %2913 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2914 = getelementptr inbounds %union.StackValue, %union.StackValue* %2913, i64 1
  br label %2915

; <label>:2915:                                   ; preds = %2907, %2911
  %2916 = phi i32 [ %2912, %2911 ], [ 0, %2907 ]
  %2917 = phi %union.StackValue* [ %2914, %2911 ], [ %4013, %2907 ]
  %2918 = getelementptr inbounds i32, i32* %2909, i64 1
  %2919 = load i32, i32* %2909, align 4, !tbaa !74
  br label %110

; <label>:2920:                                   ; preds = %4011
  %2921 = lshr i32 %4012, 16
  %2922 = and i32 %2921, 255
  %2923 = add nsw i32 %2922, -127
  %2924 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2925 = load i8, i8* %2924, align 8, !tbaa !21
  switch i8 %2925, label %2938 [
    i8 35, label %2926
    i8 19, label %2932
  ]

; <label>:2926:                                   ; preds = %2920
  %2927 = bitcast %union.StackValue* %4019 to i64*
  %2928 = load i64, i64* %2927, align 8, !tbaa !21
  %2929 = sext i32 %2923 to i64
  %2930 = icmp sle i64 %2928, %2929
  %2931 = zext i1 %2930 to i32
  br label %2944

; <label>:2932:                                   ; preds = %2920
  %2933 = bitcast %union.StackValue* %4019 to double*
  %2934 = load double, double* %2933, align 8, !tbaa !21
  %2935 = sitofp i32 %2923 to double
  %2936 = fcmp ole double %2934, %2935
  %2937 = zext i1 %2936 to i32
  br label %2944

; <label>:2938:                                   ; preds = %2920
  %2939 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2940 = lshr i32 %4012, 24
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2941 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2941, i64* %35, align 8, !tbaa !20
  %2942 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %2939, i32 %2923, i32 0, i32 %2940, i32 21) #16
  %2943 = load i32, i32* %37, align 8, !tbaa !21
  br label %2944

; <label>:2944:                                   ; preds = %2932, %2938, %2926
  %2945 = phi i32 [ %2931, %2926 ], [ %2937, %2932 ], [ %2942, %2938 ]
  %2946 = phi i32 [ %4014, %2926 ], [ %4014, %2932 ], [ %2943, %2938 ]
  %2947 = lshr i32 %4012, 15
  %2948 = and i32 %2947, 1
  %2949 = icmp eq i32 %2945, %2948
  br i1 %2949, label %2952, label %2950

; <label>:2950:                                   ; preds = %2944
  %2951 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %2959

; <label>:2952:                                   ; preds = %2944
  %2953 = load i32, i32* %4015, align 4, !tbaa !74
  %2954 = lshr i32 %2953, 7
  %2955 = add nsw i32 %2954, -16777214
  %2956 = sext i32 %2955 to i64
  %2957 = getelementptr inbounds i32, i32* %4015, i64 %2956
  %2958 = load i32, i32* %37, align 8, !tbaa !21
  br label %2959

; <label>:2959:                                   ; preds = %2952, %2950
  %2960 = phi i32 [ %2946, %2950 ], [ %2958, %2952 ]
  %2961 = phi i32* [ %2951, %2950 ], [ %2957, %2952 ]
  %2962 = icmp eq i32 %2960, 0
  br i1 %2962, label %2967, label %2963

; <label>:2963:                                   ; preds = %2959
  %2964 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2961) #16
  %2965 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %2966 = getelementptr inbounds %union.StackValue, %union.StackValue* %2965, i64 1
  br label %2967

; <label>:2967:                                   ; preds = %2959, %2963
  %2968 = phi i32 [ %2964, %2963 ], [ 0, %2959 ]
  %2969 = phi %union.StackValue* [ %2966, %2963 ], [ %4013, %2959 ]
  %2970 = getelementptr inbounds i32, i32* %2961, i64 1
  %2971 = load i32, i32* %2961, align 4, !tbaa !74
  br label %110

; <label>:2972:                                   ; preds = %4011
  %2973 = lshr i32 %4012, 16
  %2974 = and i32 %2973, 255
  %2975 = add nsw i32 %2974, -127
  %2976 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %2977 = load i8, i8* %2976, align 8, !tbaa !21
  switch i8 %2977, label %2990 [
    i8 35, label %2978
    i8 19, label %2984
  ]

; <label>:2978:                                   ; preds = %2972
  %2979 = bitcast %union.StackValue* %4019 to i64*
  %2980 = load i64, i64* %2979, align 8, !tbaa !21
  %2981 = sext i32 %2975 to i64
  %2982 = icmp sgt i64 %2980, %2981
  %2983 = zext i1 %2982 to i32
  br label %2996

; <label>:2984:                                   ; preds = %2972
  %2985 = bitcast %union.StackValue* %4019 to double*
  %2986 = load double, double* %2985, align 8, !tbaa !21
  %2987 = sitofp i32 %2975 to double
  %2988 = fcmp ogt double %2986, %2987
  %2989 = zext i1 %2988 to i32
  br label %2996

; <label>:2990:                                   ; preds = %2972
  %2991 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %2992 = lshr i32 %4012, 24
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %2993 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %2993, i64* %35, align 8, !tbaa !20
  %2994 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %2991, i32 %2975, i32 1, i32 %2992, i32 20) #16
  %2995 = load i32, i32* %37, align 8, !tbaa !21
  br label %2996

; <label>:2996:                                   ; preds = %2984, %2990, %2978
  %2997 = phi i32 [ %2983, %2978 ], [ %2989, %2984 ], [ %2994, %2990 ]
  %2998 = phi i32 [ %4014, %2978 ], [ %4014, %2984 ], [ %2995, %2990 ]
  %2999 = lshr i32 %4012, 15
  %3000 = and i32 %2999, 1
  %3001 = icmp eq i32 %2997, %3000
  br i1 %3001, label %3004, label %3002

; <label>:3002:                                   ; preds = %2996
  %3003 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3011

; <label>:3004:                                   ; preds = %2996
  %3005 = load i32, i32* %4015, align 4, !tbaa !74
  %3006 = lshr i32 %3005, 7
  %3007 = add nsw i32 %3006, -16777214
  %3008 = sext i32 %3007 to i64
  %3009 = getelementptr inbounds i32, i32* %4015, i64 %3008
  %3010 = load i32, i32* %37, align 8, !tbaa !21
  br label %3011

; <label>:3011:                                   ; preds = %3004, %3002
  %3012 = phi i32 [ %2998, %3002 ], [ %3010, %3004 ]
  %3013 = phi i32* [ %3003, %3002 ], [ %3009, %3004 ]
  %3014 = icmp eq i32 %3012, 0
  br i1 %3014, label %3019, label %3015

; <label>:3015:                                   ; preds = %3011
  %3016 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3013) #16
  %3017 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3018 = getelementptr inbounds %union.StackValue, %union.StackValue* %3017, i64 1
  br label %3019

; <label>:3019:                                   ; preds = %3011, %3015
  %3020 = phi i32 [ %3016, %3015 ], [ 0, %3011 ]
  %3021 = phi %union.StackValue* [ %3018, %3015 ], [ %4013, %3011 ]
  %3022 = getelementptr inbounds i32, i32* %3013, i64 1
  %3023 = load i32, i32* %3013, align 4, !tbaa !74
  br label %110

; <label>:3024:                                   ; preds = %4011
  %3025 = lshr i32 %4012, 16
  %3026 = and i32 %3025, 255
  %3027 = add nsw i32 %3026, -127
  %3028 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %3029 = load i8, i8* %3028, align 8, !tbaa !21
  switch i8 %3029, label %3042 [
    i8 35, label %3030
    i8 19, label %3036
  ]

; <label>:3030:                                   ; preds = %3024
  %3031 = bitcast %union.StackValue* %4019 to i64*
  %3032 = load i64, i64* %3031, align 8, !tbaa !21
  %3033 = sext i32 %3027 to i64
  %3034 = icmp sge i64 %3032, %3033
  %3035 = zext i1 %3034 to i32
  br label %3048

; <label>:3036:                                   ; preds = %3024
  %3037 = bitcast %union.StackValue* %4019 to double*
  %3038 = load double, double* %3037, align 8, !tbaa !21
  %3039 = sitofp i32 %3027 to double
  %3040 = fcmp oge double %3038, %3039
  %3041 = zext i1 %3040 to i32
  br label %3048

; <label>:3042:                                   ; preds = %3024
  %3043 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %3044 = lshr i32 %4012, 24
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3045 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %3045, i64* %35, align 8, !tbaa !20
  %3046 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %3043, i32 %3027, i32 1, i32 %3044, i32 21) #16
  %3047 = load i32, i32* %37, align 8, !tbaa !21
  br label %3048

; <label>:3048:                                   ; preds = %3036, %3042, %3030
  %3049 = phi i32 [ %3035, %3030 ], [ %3041, %3036 ], [ %3046, %3042 ]
  %3050 = phi i32 [ %4014, %3030 ], [ %4014, %3036 ], [ %3047, %3042 ]
  %3051 = lshr i32 %4012, 15
  %3052 = and i32 %3051, 1
  %3053 = icmp eq i32 %3049, %3052
  br i1 %3053, label %3056, label %3054

; <label>:3054:                                   ; preds = %3048
  %3055 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3063

; <label>:3056:                                   ; preds = %3048
  %3057 = load i32, i32* %4015, align 4, !tbaa !74
  %3058 = lshr i32 %3057, 7
  %3059 = add nsw i32 %3058, -16777214
  %3060 = sext i32 %3059 to i64
  %3061 = getelementptr inbounds i32, i32* %4015, i64 %3060
  %3062 = load i32, i32* %37, align 8, !tbaa !21
  br label %3063

; <label>:3063:                                   ; preds = %3056, %3054
  %3064 = phi i32 [ %3050, %3054 ], [ %3062, %3056 ]
  %3065 = phi i32* [ %3055, %3054 ], [ %3061, %3056 ]
  %3066 = icmp eq i32 %3064, 0
  br i1 %3066, label %3071, label %3067

; <label>:3067:                                   ; preds = %3063
  %3068 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3065) #16
  %3069 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3070 = getelementptr inbounds %union.StackValue, %union.StackValue* %3069, i64 1
  br label %3071

; <label>:3071:                                   ; preds = %3063, %3067
  %3072 = phi i32 [ %3068, %3067 ], [ 0, %3063 ]
  %3073 = phi %union.StackValue* [ %3070, %3067 ], [ %4013, %3063 ]
  %3074 = getelementptr inbounds i32, i32* %3065, i64 1
  %3075 = load i32, i32* %3065, align 4, !tbaa !74
  br label %110

; <label>:3076:                                   ; preds = %4011
  %3077 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %3078 = load i8, i8* %3077, align 8, !tbaa !21
  %3079 = and i8 %3078, 15
  %3080 = icmp eq i8 %3079, 0
  br i1 %3080, label %3081, label %3084

; <label>:3081:                                   ; preds = %3076
  %3082 = trunc i32 %4012 to i16
  %3083 = icmp slt i16 %3082, 0
  br i1 %3083, label %3096, label %3098

; <label>:3084:                                   ; preds = %3076
  %3085 = icmp eq i8 %3078, 1
  br i1 %3085, label %3089, label %3086

; <label>:3086:                                   ; preds = %3084
  %3087 = trunc i32 %4012 to i16
  %3088 = icmp sgt i16 %3087, -1
  br i1 %3088, label %3096, label %3098

; <label>:3089:                                   ; preds = %3084
  %3090 = bitcast %union.StackValue* %4019 to i32*
  %3091 = load i32, i32* %3090, align 8, !tbaa !21
  %3092 = icmp ne i32 %3091, 0
  %3093 = trunc i32 %4012 to i16
  %3094 = icmp slt i16 %3093, 0
  %3095 = xor i1 %3094, %3092
  br i1 %3095, label %3096, label %3098

; <label>:3096:                                   ; preds = %3086, %3081, %3089
  %3097 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3105

; <label>:3098:                                   ; preds = %3086, %3081, %3089
  %3099 = load i32, i32* %4015, align 4, !tbaa !74
  %3100 = lshr i32 %3099, 7
  %3101 = add nsw i32 %3100, -16777214
  %3102 = sext i32 %3101 to i64
  %3103 = getelementptr inbounds i32, i32* %4015, i64 %3102
  %3104 = load i32, i32* %37, align 8, !tbaa !21
  br label %3105

; <label>:3105:                                   ; preds = %3098, %3096
  %3106 = phi i32 [ %4014, %3096 ], [ %3104, %3098 ]
  %3107 = phi i32* [ %3097, %3096 ], [ %3103, %3098 ]
  %3108 = icmp eq i32 %3106, 0
  br i1 %3108, label %3113, label %3109

; <label>:3109:                                   ; preds = %3105
  %3110 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3107) #16
  %3111 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3112 = getelementptr inbounds %union.StackValue, %union.StackValue* %3111, i64 1
  br label %3113

; <label>:3113:                                   ; preds = %3105, %3109
  %3114 = phi i32 [ %3110, %3109 ], [ 0, %3105 ]
  %3115 = phi %union.StackValue* [ %3112, %3109 ], [ %4013, %3105 ]
  %3116 = getelementptr inbounds i32, i32* %3107, i64 1
  %3117 = load i32, i32* %3107, align 4, !tbaa !74
  br label %110

; <label>:3118:                                   ; preds = %4011
  %3119 = lshr i32 %4012, 16
  %3120 = and i32 %3119, 255
  %3121 = zext i32 %3120 to i64
  %3122 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %3121, i32 0
  %3123 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %3121, i32 0, i32 1
  %3124 = load i8, i8* %3123, align 8, !tbaa !22
  %3125 = and i8 %3124, 15
  %3126 = icmp eq i8 %3125, 0
  br i1 %3126, label %3127, label %3130

; <label>:3127:                                   ; preds = %3118
  %3128 = trunc i32 %4012 to i16
  %3129 = icmp sgt i16 %3128, -1
  br i1 %3129, label %3144, label %3142

; <label>:3130:                                   ; preds = %3118
  %3131 = icmp eq i8 %3124, 1
  br i1 %3131, label %3135, label %3132

; <label>:3132:                                   ; preds = %3130
  %3133 = trunc i32 %4012 to i16
  %3134 = icmp slt i16 %3133, 0
  br i1 %3134, label %3144, label %3142

; <label>:3135:                                   ; preds = %3130
  %3136 = bitcast %struct.TValue* %3122 to i32*
  %3137 = load i32, i32* %3136, align 8, !tbaa !21
  %3138 = icmp eq i32 %3137, 0
  %3139 = trunc i32 %4012 to i16
  %3140 = icmp slt i16 %3139, 0
  %3141 = xor i1 %3140, %3138
  br i1 %3141, label %3144, label %3142

; <label>:3142:                                   ; preds = %3127, %3132, %3135
  %3143 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3156

; <label>:3144:                                   ; preds = %3127, %3132, %3135
  %3145 = bitcast %struct.TValue* %3122 to i64*
  %3146 = bitcast %union.StackValue* %4019 to i64*
  %3147 = load i64, i64* %3145, align 8
  store i64 %3147, i64* %3146, align 8
  %3148 = load i8, i8* %3123, align 8, !tbaa !22
  %3149 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 %3148, i8* %3149, align 8, !tbaa !22
  %3150 = load i32, i32* %4015, align 4, !tbaa !74
  %3151 = lshr i32 %3150, 7
  %3152 = add nsw i32 %3151, -16777214
  %3153 = sext i32 %3152 to i64
  %3154 = getelementptr inbounds i32, i32* %4015, i64 %3153
  %3155 = load i32, i32* %37, align 8, !tbaa !21
  br label %3156

; <label>:3156:                                   ; preds = %3144, %3142
  %3157 = phi i32 [ %4014, %3142 ], [ %3155, %3144 ]
  %3158 = phi i32* [ %3143, %3142 ], [ %3154, %3144 ]
  %3159 = icmp eq i32 %3157, 0
  br i1 %3159, label %3164, label %3160

; <label>:3160:                                   ; preds = %3156
  %3161 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3158) #16
  %3162 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3163 = getelementptr inbounds %union.StackValue, %union.StackValue* %3162, i64 1
  br label %3164

; <label>:3164:                                   ; preds = %3156, %3160
  %3165 = phi i32 [ %3161, %3160 ], [ 0, %3156 ]
  %3166 = phi %union.StackValue* [ %3163, %3160 ], [ %4013, %3156 ]
  %3167 = getelementptr inbounds i32, i32* %3158, i64 1
  %3168 = load i32, i32* %3158, align 4, !tbaa !74
  br label %110

; <label>:3169:                                   ; preds = %4011
  %3170 = lshr i32 %4012, 16
  %3171 = and i32 %3170, 255
  %3172 = lshr i32 %4012, 24
  %3173 = add nsw i32 %3172, -1
  %3174 = icmp eq i32 %3171, 0
  br i1 %3174, label %3178, label %3175

; <label>:3175:                                   ; preds = %3169
  %3176 = zext i32 %3171 to i64
  %3177 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3176
  store %union.StackValue* %3177, %union.StackValue** %34, align 8, !tbaa !20
  br label %3178

; <label>:3178:                                   ; preds = %3169, %3175
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* %4019, i32 %3173) #16
  %3179 = load i32, i32* %37, align 8, !tbaa !21
  %3180 = icmp eq i32 %3179, 0
  br i1 %3180, label %3185, label %3181

; <label>:3181:                                   ; preds = %3178
  %3182 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %3183 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3184 = getelementptr inbounds %union.StackValue, %union.StackValue* %3183, i64 1
  br label %3185

; <label>:3185:                                   ; preds = %3178, %3181
  %3186 = phi i32 [ %3182, %3181 ], [ 0, %3178 ]
  %3187 = phi %union.StackValue* [ %3184, %3181 ], [ %4013, %3178 ]
  %3188 = getelementptr inbounds i32, i32* %4015, i64 1
  %3189 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:3190:                                   ; preds = %4011
  %3191 = zext i32 %4017 to i64
  %3192 = lshr i32 %4012, 16
  %3193 = and i32 %3192, 255
  %3194 = icmp eq i32 %3193, 0
  br i1 %3194, label %3198, label %3195

; <label>:3195:                                   ; preds = %3190
  %3196 = zext i32 %3193 to i64
  %3197 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3196
  store %union.StackValue* %3197, %union.StackValue** %34, align 8, !tbaa !20
  br label %3204

; <label>:3198:                                   ; preds = %3190
  %3199 = load i64, i64* %35, align 8, !tbaa !20
  %3200 = ptrtoint %union.StackValue* %4019 to i64
  %3201 = sub i64 %3199, %3200
  %3202 = lshr exact i64 %3201, 4
  %3203 = trunc i64 %3202 to i32
  br label %3204

; <label>:3204:                                   ; preds = %3198, %3195
  %3205 = phi i32 [ %3193, %3195 ], [ %3203, %3198 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3206 = trunc i32 %4012 to i16
  %3207 = icmp slt i16 %3206, 0
  br i1 %3207, label %3208, label %3217

; <label>:3208:                                   ; preds = %3204
  %3209 = lshr i32 %4012, 24
  %3210 = icmp eq i32 %3209, 0
  br i1 %3210, label %3214, label %3211

; <label>:3211:                                   ; preds = %3208
  %3212 = load i32, i32* %39, align 4, !tbaa !21
  %3213 = add nsw i32 %3212, %3209
  br label %3214

; <label>:3214:                                   ; preds = %3208, %3211
  %3215 = phi i32 [ %3213, %3211 ], [ 0, %3208 ]
  %3216 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4013, i32 -1) #16
  br label %3217

; <label>:3217:                                   ; preds = %3214, %3204
  %3218 = phi i32 [ %3215, %3214 ], [ 0, %3204 ]
  %3219 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %3191, i32 0, i32 1
  %3220 = load i8, i8* %3219, align 8, !tbaa !21
  %3221 = and i8 %3220, 15
  %3222 = icmp eq i8 %3221, 6
  br i1 %3222, label %3226, label %3223

; <label>:3223:                                   ; preds = %3217
  call fastcc void @luaD_tryfuncTM(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4019) #16
  %3224 = add nsw i32 %3205, 1
  %3225 = load i8, i8* %3219, align 8, !tbaa !21
  br label %3226

; <label>:3226:                                   ; preds = %3223, %3217
  %3227 = phi i8 [ %3225, %3223 ], [ %3220, %3217 ]
  %3228 = phi i32 [ %3224, %3223 ], [ %3205, %3217 ]
  %3229 = icmp eq i8 %3227, 86
  br i1 %3229, label %3250, label %3230

; <label>:3230:                                   ; preds = %3226
  call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4019, i32 -1) #16
  %3231 = load i32, i32* %37, align 8, !tbaa !21
  %3232 = icmp eq i32 %3231, 0
  %3233 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  br i1 %3232, label %3240, label %3234

; <label>:3234:                                   ; preds = %3230
  %3235 = getelementptr inbounds %union.StackValue, %union.StackValue* %3233, i64 1
  %3236 = lshr i32 %4012, 7
  %3237 = and i32 %3236, 255
  %3238 = zext i32 %3237 to i64
  %3239 = getelementptr inbounds %union.StackValue, %union.StackValue* %3235, i64 %3238
  br label %3240

; <label>:3240:                                   ; preds = %3230, %3234
  %3241 = phi %union.StackValue* [ %3239, %3234 ], [ %4019, %3230 ]
  %3242 = sext i32 %3218 to i64
  %3243 = sub nsw i64 0, %3242
  %3244 = getelementptr inbounds %union.StackValue, %union.StackValue* %3233, i64 %3243
  store %union.StackValue* %3244, %union.StackValue** %27, align 8, !tbaa !61
  %3245 = load i64, i64* %35, align 8, !tbaa !20
  %3246 = ptrtoint %union.StackValue* %3241 to i64
  %3247 = sub i64 %3245, %3246
  %3248 = lshr exact i64 %3247, 4
  %3249 = trunc i64 %3248 to i32
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3249) #16
  br label %4010

; <label>:3250:                                   ; preds = %3226
  %3251 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3252 = sext i32 %3218 to i64
  %3253 = sub nsw i64 0, %3252
  %3254 = getelementptr inbounds %union.StackValue, %union.StackValue* %3251, i64 %3253
  store %union.StackValue* %3254, %union.StackValue** %27, align 8, !tbaa !61
  %3255 = bitcast %union.StackValue* %4019 to %struct.LClosure**
  %3256 = load %struct.LClosure*, %struct.LClosure** %3255, align 8, !tbaa !21
  %3257 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3256, i64 0, i32 5
  %3258 = load %struct.Proto*, %struct.Proto** %3257, align 8, !tbaa !21
  %3259 = getelementptr inbounds %struct.Proto, %struct.Proto* %3258, i64 0, i32 5
  %3260 = load i8, i8* %3259, align 4, !tbaa !153
  %3261 = getelementptr inbounds %struct.Proto, %struct.Proto* %3258, i64 0, i32 3
  %3262 = load i8, i8* %3261, align 2, !tbaa !117
  %3263 = sext i32 %3228 to i64
  br label %3264

; <label>:3264:                                   ; preds = %3267, %3250
  %3265 = phi i64 [ %3277, %3267 ], [ 0, %3250 ]
  %3266 = icmp slt i64 %3265, %3263
  br i1 %3266, label %3267, label %3278

; <label>:3267:                                   ; preds = %3264
  %3268 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3269 = getelementptr inbounds %union.StackValue, %union.StackValue* %3268, i64 %3265, i32 0
  %3270 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3265, i32 0
  %3271 = bitcast %struct.TValue* %3270 to i64*
  %3272 = bitcast %struct.TValue* %3269 to i64*
  %3273 = load i64, i64* %3271, align 8
  store i64 %3273, i64* %3272, align 8
  %3274 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3265, i32 0, i32 1
  %3275 = load i8, i8* %3274, align 8, !tbaa !22
  %3276 = getelementptr inbounds %union.StackValue, %union.StackValue* %3268, i64 %3265, i32 0, i32 1
  store i8 %3275, i8* %3276, align 8, !tbaa !22
  %3277 = add nuw nsw i64 %3265, 1
  br label %3264

; <label>:3278:                                   ; preds = %3264
  %3279 = load i64, i64* %42, align 8, !tbaa !59
  %3280 = load i64, i64* %35, align 8, !tbaa !20
  %3281 = sub i64 %3279, %3280
  %3282 = ashr exact i64 %3281, 4
  %3283 = zext i8 %3260 to i64
  %3284 = icmp sgt i64 %3282, %3283
  br i1 %3284, label %3293, label %3285

; <label>:3285:                                   ; preds = %3278
  %3286 = zext i8 %3260 to i32
  %3287 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %3286, i32 1) #17
  %3288 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %3289 = getelementptr inbounds %struct.global_State, %struct.global_State* %3288, i64 0, i32 3
  %3290 = load i64, i64* %3289, align 8, !tbaa !11
  %3291 = icmp sgt i64 %3290, 0
  br i1 %3291, label %3292, label %3293

; <label>:3292:                                   ; preds = %3285
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %3293

; <label>:3293:                                   ; preds = %3292, %3285, %3278
  %3294 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3295 = zext i8 %3262 to i64
  br label %3296

; <label>:3296:                                   ; preds = %3299, %3293
  %3297 = phi i64 [ %3301, %3299 ], [ %3263, %3293 ]
  %3298 = icmp sgt i64 %3297, %3295
  br i1 %3298, label %3302, label %3299

; <label>:3299:                                   ; preds = %3296
  %3300 = getelementptr inbounds %union.StackValue, %union.StackValue* %3294, i64 %3297, i32 0, i32 1
  store i8 0, i8* %3300, align 8, !tbaa !21
  %3301 = add nsw i64 %3297, 1
  br label %3296

; <label>:3302:                                   ; preds = %3296
  %3303 = getelementptr inbounds %union.StackValue, %union.StackValue* %3294, i64 1
  %3304 = getelementptr inbounds %union.StackValue, %union.StackValue* %3303, i64 %3283
  store %union.StackValue* %3304, %union.StackValue** %32, align 8, !tbaa !63
  %3305 = getelementptr inbounds %struct.Proto, %struct.Proto* %3258, i64 0, i32 16
  %3306 = bitcast i32** %3305 to i64*
  %3307 = load i64, i64* %3306, align 8, !tbaa !119
  store i64 %3307, i64* %57, align 8, !tbaa !21
  %3308 = load i16, i16* %58, align 2, !tbaa !60
  %3309 = or i16 %3308, 16
  store i16 %3309, i16* %58, align 2, !tbaa !60
  %3310 = shl i64 %3297, 32
  %3311 = ashr exact i64 %3310, 32
  %3312 = getelementptr inbounds %union.StackValue, %union.StackValue* %3294, i64 %3311
  store %union.StackValue* %3312, %union.StackValue** %34, align 8, !tbaa !20
  br label %59

; <label>:3313:                                   ; preds = %4011
  %3314 = lshr i32 %4012, 16
  %3315 = and i32 %3314, 255
  %3316 = add nsw i32 %3315, -1
  %3317 = icmp eq i32 %3315, 0
  br i1 %3317, label %3318, label %3324

; <label>:3318:                                   ; preds = %3313
  %3319 = load i64, i64* %35, align 8, !tbaa !20
  %3320 = ptrtoint %union.StackValue* %4019 to i64
  %3321 = sub i64 %3319, %3320
  %3322 = lshr exact i64 %3321, 4
  %3323 = trunc i64 %3322 to i32
  br label %3327

; <label>:3324:                                   ; preds = %3313
  %3325 = sext i32 %3316 to i64
  %3326 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3325
  store %union.StackValue* %3326, %union.StackValue** %34, align 8, !tbaa !20
  br label %3327

; <label>:3327:                                   ; preds = %3324, %3318
  %3328 = phi i32 [ %3323, %3318 ], [ %3316, %3324 ]
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3329 = trunc i32 %4012 to i16
  %3330 = icmp slt i16 %3329, 0
  br i1 %3330, label %3331, label %3343

; <label>:3331:                                   ; preds = %3327
  %3332 = lshr i32 %4012, 24
  %3333 = icmp eq i32 %3332, 0
  br i1 %3333, label %3341, label %3334

; <label>:3334:                                   ; preds = %3331
  %3335 = load i32, i32* %39, align 4, !tbaa !21
  %3336 = add nsw i32 %3335, %3332
  %3337 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3338 = sext i32 %3336 to i64
  %3339 = sub nsw i64 0, %3338
  %3340 = getelementptr inbounds %union.StackValue, %union.StackValue* %3337, i64 %3339
  store %union.StackValue* %3340, %union.StackValue** %27, align 8, !tbaa !61
  br label %3341

; <label>:3341:                                   ; preds = %3331, %3334
  %3342 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4013, i32 0) #16
  br label %3343

; <label>:3343:                                   ; preds = %3341, %3327
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3328) #16
  br label %4010

; <label>:3344:                                   ; preds = %4011
  %3345 = load i32, i32* %26, align 8, !tbaa !23
  %3346 = icmp eq i32 %3345, 0
  br i1 %3346, label %3348, label %3347

; <label>:3347:                                   ; preds = %3344
  store %union.StackValue* %4019, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 0) #16
  br label %4010

; <label>:3348:                                   ; preds = %3344
  %3349 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3350 = load i16, i16* %3349, align 4, !tbaa !62
  %3351 = sext i16 %3350 to i32
  %3352 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3353 = bitcast %struct.CallInfo** %3352 to i64*
  %3354 = load i64, i64* %3353, align 8, !tbaa !92
  %3355 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3356 = bitcast %struct.CallInfo** %3355 to i64*
  store i64 %3354, i64* %3356, align 8, !tbaa !49
  %3357 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 -1
  store %union.StackValue* %3357, %union.StackValue** %34, align 8, !tbaa !20
  br label %3358

; <label>:3358:                                   ; preds = %3361, %3348
  %3359 = phi i32 [ %3351, %3348 ], [ %3362, %3361 ]
  %3360 = icmp sgt i32 %3359, 0
  br i1 %3360, label %3361, label %4010

; <label>:3361:                                   ; preds = %3358
  %3362 = add nsw i32 %3359, -1
  %3363 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3364 = getelementptr inbounds %union.StackValue, %union.StackValue* %3363, i64 1
  store %union.StackValue* %3364, %union.StackValue** %34, align 8, !tbaa !20
  %3365 = getelementptr inbounds %union.StackValue, %union.StackValue* %3363, i64 0, i32 0, i32 1
  store i8 0, i8* %3365, align 8, !tbaa !21
  br label %3358

; <label>:3366:                                   ; preds = %4011
  %3367 = zext i32 %4017 to i64
  %3368 = load i32, i32* %26, align 8, !tbaa !23
  %3369 = icmp eq i32 %3368, 0
  br i1 %3369, label %3372, label %3370

; <label>:3370:                                   ; preds = %3366
  %3371 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1
  store %union.StackValue* %3371, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 1) #16
  br label %4010

; <label>:3372:                                   ; preds = %3366
  %3373 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3374 = load i16, i16* %3373, align 4, !tbaa !62
  %3375 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3376 = bitcast %struct.CallInfo** %3375 to i64*
  %3377 = load i64, i64* %3376, align 8, !tbaa !92
  %3378 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3379 = bitcast %struct.CallInfo** %3378 to i64*
  store i64 %3377, i64* %3379, align 8, !tbaa !49
  %3380 = icmp eq i16 %3374, 0
  %3381 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 -1
  br i1 %3380, label %3382, label %3383

; <label>:3382:                                   ; preds = %3372
  store %union.StackValue* %3381, %union.StackValue** %34, align 8, !tbaa !20
  br label %4010

; <label>:3383:                                   ; preds = %3372
  %3384 = sext i16 %3374 to i32
  %3385 = bitcast %union.StackValue* %4019 to i64*
  %3386 = bitcast %union.StackValue* %3381 to i64*
  %3387 = load i64, i64* %3385, align 8
  store i64 %3387, i64* %3386, align 8
  %3388 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %3367, i32 0, i32 1
  %3389 = load i8, i8* %3388, align 8, !tbaa !22
  %3390 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 -1, i32 0, i32 1
  store i8 %3389, i8* %3390, align 8, !tbaa !22
  store %union.StackValue* %4013, %union.StackValue** %34, align 8, !tbaa !20
  br label %3391

; <label>:3391:                                   ; preds = %3394, %3383
  %3392 = phi i32 [ %3384, %3383 ], [ %3395, %3394 ]
  %3393 = icmp sgt i32 %3392, 1
  br i1 %3393, label %3394, label %4010

; <label>:3394:                                   ; preds = %3391
  %3395 = add nsw i32 %3392, -1
  %3396 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3397 = getelementptr inbounds %union.StackValue, %union.StackValue* %3396, i64 1
  store %union.StackValue* %3397, %union.StackValue** %34, align 8, !tbaa !20
  %3398 = getelementptr inbounds %union.StackValue, %union.StackValue* %3396, i64 0, i32 0, i32 1
  store i8 0, i8* %3398, align 8, !tbaa !21
  br label %3391

; <label>:3399:                                   ; preds = %4011
  %3400 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 2, i32 0
  %3401 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 2, i32 0, i32 1
  %3402 = load i8, i8* %3401, align 8, !tbaa !21
  %3403 = icmp eq i8 %3402, 35
  br i1 %3403, label %3404, label %3423

; <label>:3404:                                   ; preds = %3399
  %3405 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 0
  %3406 = bitcast %union.Value* %3405 to i64*
  %3407 = load i64, i64* %3406, align 8, !tbaa !21
  %3408 = icmp eq i64 %3407, 0
  br i1 %3408, label %3445, label %3409

; <label>:3409:                                   ; preds = %3404
  %3410 = bitcast %struct.TValue* %3400 to i64*
  %3411 = load i64, i64* %3410, align 8, !tbaa !21
  %3412 = bitcast %union.StackValue* %4019 to i64*
  %3413 = load i64, i64* %3412, align 8, !tbaa !21
  %3414 = add i64 %3407, -1
  store i64 %3414, i64* %3406, align 8, !tbaa !21
  %3415 = add i64 %3413, %3411
  store i64 %3415, i64* %3412, align 8, !tbaa !21
  %3416 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0
  %3417 = bitcast %struct.TValue* %3416 to i64*
  store i64 %3415, i64* %3417, align 8, !tbaa !21
  %3418 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0, i32 1
  store i8 35, i8* %3418, align 8, !tbaa !22
  %3419 = lshr i32 %4012, 15
  %3420 = zext i32 %3419 to i64
  %3421 = sub nsw i64 0, %3420
  %3422 = getelementptr inbounds i32, i32* %4015, i64 %3421
  br label %3445

; <label>:3423:                                   ; preds = %3399
  %3424 = bitcast %struct.TValue* %3400 to double*
  %3425 = load double, double* %3424, align 8, !tbaa !21
  %3426 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 0
  %3427 = bitcast %union.Value* %3426 to double*
  %3428 = load double, double* %3427, align 8, !tbaa !21
  %3429 = bitcast %union.StackValue* %4019 to double*
  %3430 = load double, double* %3429, align 8, !tbaa !21
  %3431 = fadd double %3425, %3430
  %3432 = fcmp ogt double %3425, 0.000000e+00
  br i1 %3432, label %3433, label %3435

; <label>:3433:                                   ; preds = %3423
  %3434 = fcmp ugt double %3431, %3428
  br i1 %3434, label %3445, label %3437

; <label>:3435:                                   ; preds = %3423
  %3436 = fcmp ugt double %3428, %3431
  br i1 %3436, label %3445, label %3437

; <label>:3437:                                   ; preds = %3433, %3435
  store double %3431, double* %3429, align 8, !tbaa !21
  %3438 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0
  %3439 = bitcast %struct.TValue* %3438 to double*
  store double %3431, double* %3439, align 8, !tbaa !21
  %3440 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0, i32 1
  store i8 19, i8* %3440, align 8, !tbaa !22
  %3441 = lshr i32 %4012, 15
  %3442 = zext i32 %3441 to i64
  %3443 = sub nsw i64 0, %3442
  %3444 = getelementptr inbounds i32, i32* %4015, i64 %3443
  br label %3445

; <label>:3445:                                   ; preds = %3404, %3433, %3435, %3437, %3409
  %3446 = phi i32* [ %3422, %3409 ], [ %4015, %3404 ], [ %3444, %3437 ], [ %4015, %3433 ], [ %4015, %3435 ]
  %3447 = load i32, i32* %37, align 8, !tbaa !21
  %3448 = icmp eq i32 %3447, 0
  br i1 %3448, label %3453, label %3449

; <label>:3449:                                   ; preds = %3445
  %3450 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3446) #16
  %3451 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3452 = getelementptr inbounds %union.StackValue, %union.StackValue* %3451, i64 1
  br label %3453

; <label>:3453:                                   ; preds = %3445, %3449
  %3454 = phi i32 [ %3450, %3449 ], [ 0, %3445 ]
  %3455 = phi %union.StackValue* [ %3452, %3449 ], [ %4013, %3445 ]
  %3456 = getelementptr inbounds i32, i32* %3446, i64 1
  %3457 = load i32, i32* %3446, align 4, !tbaa !74
  br label %110

; <label>:3458:                                   ; preds = %4011
  %3459 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0
  %3460 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0
  %3461 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 2, i32 0
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3462 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %3462, i64* %35, align 8, !tbaa !20
  %3463 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  %3464 = load i8, i8* %3463, align 8, !tbaa !22
  %3465 = icmp eq i8 %3464, 35
  br i1 %3465, label %3466, label %3537

; <label>:3466:                                   ; preds = %3458
  %3467 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 2, i32 0, i32 1
  %3468 = load i8, i8* %3467, align 8, !tbaa !22
  %3469 = icmp eq i8 %3468, 35
  br i1 %3469, label %3470, label %3537

; <label>:3470:                                   ; preds = %3466
  %3471 = bitcast %union.StackValue* %4019 to i64*
  %3472 = load i64, i64* %3471, align 8, !tbaa !21
  %3473 = bitcast %struct.TValue* %3461 to i64*
  %3474 = load i64, i64* %3473, align 8, !tbaa !21
  %3475 = icmp eq i64 %3474, 0
  br i1 %3475, label %3476, label %3477

; <label>:3476:                                   ; preds = %3470
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #18
  unreachable

; <label>:3477:                                   ; preds = %3470
  %3478 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0
  %3479 = bitcast %struct.TValue* %3478 to i64*
  store i64 %3472, i64* %3479, align 8, !tbaa !21
  %3480 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0, i32 1
  store i8 35, i8* %3480, align 8, !tbaa !22
  %3481 = icmp slt i64 %3474, 0
  %3482 = lshr i64 %3474, 63
  %3483 = trunc i64 %3482 to i32
  %3484 = add nuw nsw i32 %3483, 1
  %3485 = call fastcc i32 @luaV_tointeger(%struct.TValue* nonnull %3460, i64* nonnull %22, i32 %3484) #17
  %3486 = icmp eq i32 %3485, 0
  br i1 %3486, label %3489, label %3487

; <label>:3487:                                   ; preds = %3477
  %3488 = load i64, i64* %22, align 8, !tbaa !129
  br label %3512

; <label>:3489:                                   ; preds = %3477
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %53) #7
  %3490 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 1
  %3491 = load i8, i8* %3490, align 8, !tbaa !22
  %3492 = icmp eq i8 %3491, 19
  br i1 %3492, label %3493, label %3497

; <label>:3493:                                   ; preds = %3489
  %3494 = bitcast %struct.TValue* %3460 to i64*
  %3495 = load i64, i64* %3494, align 8, !tbaa !21
  store i64 %3495, i64* %56, align 8, !tbaa !127
  %3496 = bitcast i64 %3495 to double
  br label %3503

; <label>:3497:                                   ; preds = %3489
  %3498 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3460, double* nonnull %3) #17
  %3499 = icmp eq i32 %3498, 0
  br i1 %3499, label %3500, label %3501

; <label>:3500:                                   ; preds = %3497
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3460, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #19
  unreachable

; <label>:3501:                                   ; preds = %3497
  %3502 = load double, double* %3, align 8, !tbaa !127
  br label %3503

; <label>:3503:                                   ; preds = %3501, %3493
  %3504 = phi double [ %3502, %3501 ], [ %3496, %3493 ]
  %3505 = fcmp ogt double %3504, 0.000000e+00
  br i1 %3505, label %3506, label %3507

; <label>:3506:                                   ; preds = %3503
  br i1 %3481, label %3511, label %3509

; <label>:3507:                                   ; preds = %3503
  %3508 = icmp sgt i64 %3474, 0
  br i1 %3508, label %3511, label %3509

; <label>:3509:                                   ; preds = %3507, %3506
  %3510 = phi i64 [ 9223372036854775807, %3506 ], [ -9223372036854775808, %3507 ]
  store i64 %3510, i64* %22, align 8, !tbaa !129
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %53) #7
  br label %3512

; <label>:3511:                                   ; preds = %3506, %3507
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %53) #7
  br label %3518

; <label>:3512:                                   ; preds = %3487, %3509
  %3513 = phi i64 [ %3488, %3487 ], [ %3510, %3509 ]
  %3514 = icmp sgt i64 %3474, 0
  %3515 = icmp slt i64 %3513, %3472
  %3516 = icmp sgt i64 %3513, %3472
  %3517 = select i1 %3514, i1 %3515, i1 %3516
  br i1 %3517, label %3518, label %3523

; <label>:3518:                                   ; preds = %3512, %3511
  %3519 = lshr i32 %4012, 15
  %3520 = add nuw nsw i32 %3519, 1
  %3521 = zext i32 %3520 to i64
  %3522 = getelementptr inbounds i32, i32* %4015, i64 %3521
  br label %3598

; <label>:3523:                                   ; preds = %3512
  br i1 %3514, label %3524, label %3529

; <label>:3524:                                   ; preds = %3523
  %3525 = sub i64 %3513, %3472
  %3526 = icmp eq i64 %3474, 1
  br i1 %3526, label %3533, label %3527

; <label>:3527:                                   ; preds = %3524
  %3528 = udiv i64 %3525, %3474
  br label %3533

; <label>:3529:                                   ; preds = %3523
  %3530 = sub i64 %3472, %3513
  %3531 = sub i64 0, %3474
  %3532 = udiv i64 %3530, %3531
  br label %3533

; <label>:3533:                                   ; preds = %3524, %3527, %3529
  %3534 = phi i64 [ %3528, %3527 ], [ %3525, %3524 ], [ %3532, %3529 ]
  %3535 = bitcast %struct.TValue* %3460 to i64*
  store i64 %3534, i64* %3535, align 8, !tbaa !21
  %3536 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 1
  store i8 35, i8* %3536, align 8, !tbaa !22
  br label %3598

; <label>:3537:                                   ; preds = %3466, %3458
  %3538 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1, i32 0, i32 1
  %3539 = load i8, i8* %3538, align 8, !tbaa !22
  %3540 = icmp eq i8 %3539, 19
  br i1 %3540, label %3541, label %3544

; <label>:3541:                                   ; preds = %3537
  %3542 = bitcast %struct.TValue* %3460 to i64*
  %3543 = load i64, i64* %3542, align 8, !tbaa !21
  store i64 %3543, i64* %48, align 8, !tbaa !127
  br label %3548

; <label>:3544:                                   ; preds = %3537
  %3545 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3460, double* nonnull %24) #16
  %3546 = icmp eq i32 %3545, 0
  br i1 %3546, label %3547, label %3548, !prof !47

; <label>:3547:                                   ; preds = %3544
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3460, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #18
  unreachable

; <label>:3548:                                   ; preds = %3541, %3544
  %3549 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 2, i32 0, i32 1
  %3550 = load i8, i8* %3549, align 8, !tbaa !22
  %3551 = icmp eq i8 %3550, 19
  br i1 %3551, label %3552, label %3555

; <label>:3552:                                   ; preds = %3548
  %3553 = bitcast %struct.TValue* %3461 to i64*
  %3554 = load i64, i64* %3553, align 8, !tbaa !21
  store i64 %3554, i64* %51, align 8, !tbaa !127
  br label %3559

; <label>:3555:                                   ; preds = %3548
  %3556 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3461, double* nonnull %25) #16
  %3557 = icmp eq i32 %3556, 0
  br i1 %3557, label %3558, label %3559, !prof !47

; <label>:3558:                                   ; preds = %3555
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3461, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i64 0, i64 0)) #18
  unreachable

; <label>:3559:                                   ; preds = %3552, %3555
  %3560 = load i8, i8* %3463, align 8, !tbaa !22
  %3561 = icmp eq i8 %3560, 19
  br i1 %3561, label %3562, label %3565

; <label>:3562:                                   ; preds = %3559
  %3563 = bitcast %union.StackValue* %4019 to i64*
  %3564 = load i64, i64* %3563, align 8, !tbaa !21
  store i64 %3564, i64* %54, align 8, !tbaa !127
  br label %3569

; <label>:3565:                                   ; preds = %3559
  %3566 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3459, double* nonnull %23) #16
  %3567 = icmp eq i32 %3566, 0
  br i1 %3567, label %3568, label %3569, !prof !47

; <label>:3568:                                   ; preds = %3565
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3459, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.167, i64 0, i64 0)) #18
  unreachable

; <label>:3569:                                   ; preds = %3562, %3565
  %3570 = load double, double* %25, align 8, !tbaa !127
  %3571 = fcmp oeq double %3570, 0.000000e+00
  br i1 %3571, label %3572, label %3573

; <label>:3572:                                   ; preds = %3569
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #18
  unreachable

; <label>:3573:                                   ; preds = %3569
  %3574 = fcmp ogt double %3570, 0.000000e+00
  br i1 %3574, label %3575, label %3579

; <label>:3575:                                   ; preds = %3573
  %3576 = load double, double* %24, align 8, !tbaa !127
  %3577 = load double, double* %23, align 8, !tbaa !127
  %3578 = fcmp olt double %3576, %3577
  br i1 %3578, label %3583, label %3588

; <label>:3579:                                   ; preds = %3573
  %3580 = load double, double* %23, align 8, !tbaa !127
  %3581 = load double, double* %24, align 8, !tbaa !127
  %3582 = fcmp olt double %3580, %3581
  br i1 %3582, label %3583, label %3588

; <label>:3583:                                   ; preds = %3579, %3575
  %3584 = lshr i32 %4012, 15
  %3585 = add nuw nsw i32 %3584, 1
  %3586 = zext i32 %3585 to i64
  %3587 = getelementptr inbounds i32, i32* %4015, i64 %3586
  br label %3598

; <label>:3588:                                   ; preds = %3579, %3575
  %3589 = phi double [ %3580, %3579 ], [ %3577, %3575 ]
  %3590 = phi double [ %3581, %3579 ], [ %3576, %3575 ]
  %3591 = bitcast %struct.TValue* %3460 to double*
  store double %3590, double* %3591, align 8, !tbaa !21
  store i8 19, i8* %3538, align 8, !tbaa !22
  %3592 = bitcast %struct.TValue* %3461 to double*
  store double %3570, double* %3592, align 8, !tbaa !21
  store i8 19, i8* %3549, align 8, !tbaa !22
  %3593 = bitcast %union.StackValue* %4019 to double*
  store double %3589, double* %3593, align 8, !tbaa !21
  store i8 19, i8* %3463, align 8, !tbaa !22
  %3594 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0
  %3595 = load i64, i64* %54, align 8, !tbaa !127
  %3596 = bitcast %struct.TValue* %3594 to i64*
  store i64 %3595, i64* %3596, align 8, !tbaa !21
  %3597 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0, i32 1
  store i8 19, i8* %3597, align 8, !tbaa !22
  br label %3598

; <label>:3598:                                   ; preds = %3583, %3588, %3518, %3533
  %3599 = phi i32* [ %3522, %3518 ], [ %4015, %3533 ], [ %3587, %3583 ], [ %4015, %3588 ]
  %3600 = icmp eq i32 %4014, 0
  br i1 %3600, label %3605, label %3601

; <label>:3601:                                   ; preds = %3598
  %3602 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %3599) #16
  %3603 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3604 = getelementptr inbounds %union.StackValue, %union.StackValue* %3603, i64 1
  br label %3605

; <label>:3605:                                   ; preds = %3598, %3601
  %3606 = phi i32 [ %3602, %3601 ], [ 0, %3598 ]
  %3607 = phi %union.StackValue* [ %3604, %3601 ], [ %4013, %3598 ]
  %3608 = getelementptr inbounds i32, i32* %3599, i64 1
  %3609 = load i32, i32* %3599, align 4, !tbaa !74
  br label %110

; <label>:3610:                                   ; preds = %4011
  %3611 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3, i32 0, i32 1
  %3612 = load i8, i8* %3611, align 8, !tbaa !21
  %3613 = and i8 %3612, 15
  %3614 = icmp eq i8 %3613, 0
  br i1 %3614, label %3617, label %3615

; <label>:3615:                                   ; preds = %3610
  %3616 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 3
  store i32* %4015, i32** %31, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* nonnull %3616) #16
  br label %3617

; <label>:3617:                                   ; preds = %3615, %3610
  %3618 = lshr i32 %4012, 15
  %3619 = zext i32 %3618 to i64
  %3620 = getelementptr inbounds i32, i32* %4015, i64 %3619
  %3621 = getelementptr inbounds i32, i32* %3620, i64 1
  %3622 = load i32, i32* %3620, align 4, !tbaa !74
  br label %3623

; <label>:3623:                                   ; preds = %4011, %3617
  %3624 = phi i32 [ %4012, %4011 ], [ %3622, %3617 ]
  %3625 = phi i32* [ %4015, %4011 ], [ %3621, %3617 ]
  %3626 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 4
  %3627 = bitcast %union.StackValue* %3626 to i8*
  %3628 = bitcast %union.StackValue* %4019 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %3627, i8* %3628, i64 48, i32 8, i1 false)
  store i32* %3625, i32** %31, align 8, !tbaa !21
  %3629 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %3629, i64* %35, align 8, !tbaa !20
  %3630 = lshr i32 %3624, 24
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* nonnull %3626, i32 %3630) #16
  %3631 = load i32, i32* %37, align 8, !tbaa !21
  %3632 = icmp eq i32 %3631, 0
  br i1 %3632, label %3640, label %3633

; <label>:3633:                                   ; preds = %3623
  %3634 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3635 = getelementptr inbounds %union.StackValue, %union.StackValue* %3634, i64 1
  %3636 = lshr i32 %3624, 7
  %3637 = and i32 %3636, 255
  %3638 = zext i32 %3637 to i64
  %3639 = getelementptr inbounds %union.StackValue, %union.StackValue* %3635, i64 %3638
  br label %3640

; <label>:3640:                                   ; preds = %3623, %3633
  %3641 = phi %union.StackValue* [ %3639, %3633 ], [ %4019, %3623 ]
  %3642 = phi %union.StackValue* [ %3635, %3633 ], [ %4013, %3623 ]
  %3643 = getelementptr inbounds i32, i32* %3625, i64 1
  %3644 = load i32, i32* %3625, align 4, !tbaa !74
  %3645 = getelementptr inbounds %union.StackValue, %union.StackValue* %3641, i64 2
  br label %3646

; <label>:3646:                                   ; preds = %4011, %3640
  %3647 = phi %union.StackValue* [ %4019, %4011 ], [ %3645, %3640 ]
  %3648 = phi i32 [ %4012, %4011 ], [ %3644, %3640 ]
  %3649 = phi i32 [ %4014, %4011 ], [ %3631, %3640 ]
  %3650 = phi i32* [ %4015, %4011 ], [ %3643, %3640 ]
  %3651 = phi %union.StackValue* [ %4013, %4011 ], [ %3642, %3640 ]
  %3652 = getelementptr inbounds %union.StackValue, %union.StackValue* %3647, i64 2, i32 0, i32 1
  %3653 = load i8, i8* %3652, align 8, !tbaa !21
  %3654 = and i8 %3653, 15
  %3655 = icmp eq i8 %3654, 0
  br i1 %3655, label %3666, label %3656

; <label>:3656:                                   ; preds = %3646
  %3657 = getelementptr inbounds %union.StackValue, %union.StackValue* %3647, i64 2, i32 0, i32 0
  %3658 = bitcast %union.Value* %3657 to i64*
  %3659 = bitcast %union.StackValue* %3647 to i64*
  %3660 = load i64, i64* %3658, align 8
  store i64 %3660, i64* %3659, align 8
  %3661 = getelementptr inbounds %union.StackValue, %union.StackValue* %3647, i64 0, i32 0, i32 1
  store i8 %3653, i8* %3661, align 8, !tbaa !22
  %3662 = lshr i32 %3648, 15
  %3663 = zext i32 %3662 to i64
  %3664 = sub nsw i64 0, %3663
  %3665 = getelementptr inbounds i32, i32* %3650, i64 %3664
  br label %3666

; <label>:3666:                                   ; preds = %3656, %3646
  %3667 = phi i32* [ %3650, %3646 ], [ %3665, %3656 ]
  %3668 = icmp eq i32 %3649, 0
  br i1 %3668, label %3673, label %3669

; <label>:3669:                                   ; preds = %3666
  %3670 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3667) #16
  %3671 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3672 = getelementptr inbounds %union.StackValue, %union.StackValue* %3671, i64 1
  br label %3673

; <label>:3673:                                   ; preds = %3666, %3669
  %3674 = phi i32 [ %3670, %3669 ], [ 0, %3666 ]
  %3675 = phi %union.StackValue* [ %3672, %3669 ], [ %3651, %3666 ]
  %3676 = getelementptr inbounds i32, i32* %3667, i64 1
  %3677 = load i32, i32* %3667, align 4, !tbaa !74
  br label %110

; <label>:3678:                                   ; preds = %4011
  %3679 = lshr i32 %4012, 16
  %3680 = and i32 %3679, 255
  %3681 = lshr i32 %4012, 24
  %3682 = icmp eq i32 %3680, 0
  br i1 %3682, label %3683, label %3690

; <label>:3683:                                   ; preds = %3678
  %3684 = load i64, i64* %35, align 8, !tbaa !20
  %3685 = ptrtoint %union.StackValue* %4019 to i64
  %3686 = sub i64 %3684, %3685
  %3687 = lshr exact i64 %3686, 4
  %3688 = trunc i64 %3687 to i32
  %3689 = add nsw i32 %3688, -1
  br label %3692

; <label>:3690:                                   ; preds = %3678
  %3691 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %3691, i64* %35, align 8, !tbaa !20
  br label %3692

; <label>:3692:                                   ; preds = %3690, %3683
  %3693 = phi i32 [ %3689, %3683 ], [ %3680, %3690 ]
  %3694 = icmp eq i32 %3681, 0
  br i1 %3694, label %3695, label %3699

; <label>:3695:                                   ; preds = %3692
  %3696 = load i32, i32* %4015, align 4, !tbaa !74
  %3697 = lshr i32 %3696, 7
  %3698 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3699

; <label>:3699:                                   ; preds = %3695, %3692
  %3700 = phi i32 [ %3697, %3695 ], [ %3681, %3692 ]
  %3701 = phi i32* [ %3698, %3695 ], [ %4015, %3692 ]
  %3702 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 0, i32 0, i32 0, i32 0
  %3703 = load %struct.GCObject*, %struct.GCObject** %3702, align 8, !tbaa !21
  %3704 = bitcast %struct.GCObject* %3703 to %struct.Table*
  %3705 = mul nuw nsw i32 %3700, 50
  %3706 = add i32 %3693, -50
  %3707 = add i32 %3706, %3705
  %3708 = call fastcc i32 @luaH_realasize(%struct.Table* %3704) #16
  %3709 = icmp ugt i32 %3707, %3708
  br i1 %3709, label %3710, label %3722

; <label>:3710:                                   ; preds = %3699
  %3711 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3703, i64 2
  %3712 = bitcast %struct.GCObject* %3711 to %union.Node**
  %3713 = load %union.Node*, %union.Node** %3712, align 8, !tbaa !139
  %3714 = icmp eq %union.Node* %3713, null
  br i1 %3714, label %3720, label %3715

; <label>:3715:                                   ; preds = %3710
  %3716 = getelementptr inbounds %struct.Table, %struct.Table* %3704, i64 0, i32 4
  %3717 = load i8, i8* %3716, align 1, !tbaa !148
  %3718 = zext i8 %3717 to i32
  %3719 = shl i32 1, %3718
  br label %3720

; <label>:3720:                                   ; preds = %3710, %3715
  %3721 = phi i32 [ %3719, %3715 ], [ 0, %3710 ]
  call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* nonnull %3704, i32 %3707, i32 %3721) #17
  br label %3722

; <label>:3722:                                   ; preds = %3720, %3699
  %3723 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3703, i64 1
  %3724 = bitcast %struct.GCObject* %3723 to %struct.TValue**
  %3725 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3703, i64 0, i32 2
  %3726 = sext i32 %3693 to i64
  br label %3727

; <label>:3727:                                   ; preds = %3758, %3722
  %3728 = phi i64 [ %3759, %3758 ], [ %3726, %3722 ]
  %3729 = phi i32 [ %3734, %3758 ], [ %3707, %3722 ]
  %3730 = icmp sgt i64 %3728, 0
  br i1 %3730, label %3731, label %3760

; <label>:3731:                                   ; preds = %3727
  %3732 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3728, i32 0
  %3733 = load %struct.TValue*, %struct.TValue** %3724, align 8, !tbaa !137
  %3734 = add i32 %3729, -1
  %3735 = zext i32 %3734 to i64
  %3736 = getelementptr inbounds %struct.TValue, %struct.TValue* %3733, i64 %3735
  %3737 = bitcast %struct.TValue* %3732 to i64*
  %3738 = bitcast %struct.TValue* %3736 to i64*
  %3739 = load i64, i64* %3737, align 8
  store i64 %3739, i64* %3738, align 8
  %3740 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 %3728, i32 0, i32 1
  %3741 = load i8, i8* %3740, align 8, !tbaa !22
  %3742 = getelementptr inbounds %struct.TValue, %struct.TValue* %3733, i64 %3735, i32 1
  store i8 %3741, i8* %3742, align 8, !tbaa !22
  %3743 = load i8, i8* %3740, align 8, !tbaa !22
  %3744 = and i8 %3743, 64
  %3745 = icmp eq i8 %3744, 0
  br i1 %3745, label %3758, label %3746

; <label>:3746:                                   ; preds = %3731
  %3747 = load i8, i8* %3725, align 1, !tbaa !21
  %3748 = and i8 %3747, 32
  %3749 = icmp eq i8 %3748, 0
  br i1 %3749, label %3758, label %3750

; <label>:3750:                                   ; preds = %3746
  %3751 = getelementptr inbounds %struct.TValue, %struct.TValue* %3732, i64 0, i32 0, i32 0
  %3752 = load %struct.GCObject*, %struct.GCObject** %3751, align 8, !tbaa !21
  %3753 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3752, i64 0, i32 2
  %3754 = load i8, i8* %3753, align 1, !tbaa !67
  %3755 = and i8 %3754, 24
  %3756 = icmp eq i8 %3755, 0
  br i1 %3756, label %3758, label %3757

; <label>:3757:                                   ; preds = %3750
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %3703) #16
  br label %3758

; <label>:3758:                                   ; preds = %3750, %3746, %3731, %3757
  %3759 = add nsw i64 %3728, -1
  br label %3727

; <label>:3760:                                   ; preds = %3727
  %3761 = icmp eq i32 %4014, 0
  br i1 %3761, label %3766, label %3762

; <label>:3762:                                   ; preds = %3760
  %3763 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3701) #16
  %3764 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3765 = getelementptr inbounds %union.StackValue, %union.StackValue* %3764, i64 1
  br label %3766

; <label>:3766:                                   ; preds = %3760, %3762
  %3767 = phi i32 [ %3763, %3762 ], [ 0, %3760 ]
  %3768 = phi %union.StackValue* [ %3765, %3762 ], [ %4013, %3760 ]
  %3769 = getelementptr inbounds i32, i32* %3701, i64 1
  %3770 = load i32, i32* %3701, align 4, !tbaa !74
  br label %110

; <label>:3771:                                   ; preds = %4011
  %3772 = load %struct.Proto*, %struct.Proto** %63, align 8, !tbaa !192
  %3773 = getelementptr inbounds %struct.Proto, %struct.Proto* %3772, i64 0, i32 17
  %3774 = load %struct.Proto**, %struct.Proto*** %3773, align 8, !tbaa !219
  %3775 = lshr i32 %4012, 15
  %3776 = zext i32 %3775 to i64
  %3777 = getelementptr inbounds %struct.Proto*, %struct.Proto** %3774, i64 %3776
  %3778 = load %struct.Proto*, %struct.Proto** %3777, align 8, !tbaa !39
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3779 = getelementptr inbounds %struct.Proto, %struct.Proto* %3778, i64 0, i32 6
  %3780 = load i32, i32* %3779, align 8, !tbaa !185
  %3781 = getelementptr inbounds %struct.Proto, %struct.Proto* %3778, i64 0, i32 18
  %3782 = load %struct.Upvaldesc*, %struct.Upvaldesc** %3781, align 8, !tbaa !193
  %3783 = call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %3780) #17
  %3784 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3783, i64 0, i32 5
  store %struct.Proto* %3778, %struct.Proto** %3784, align 8, !tbaa !192
  %3785 = bitcast %struct.LClosure* %3783 to %struct.GCObject*
  %3786 = bitcast %union.StackValue* %4019 to %struct.LClosure**
  store %struct.LClosure* %3783, %struct.LClosure** %3786, align 8, !tbaa !21
  %3787 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018, i32 0, i32 1
  store i8 86, i8* %3787, align 8, !tbaa !22
  %3788 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3783, i64 0, i32 2
  %3789 = sext i32 %3780 to i64
  br label %3790

; <label>:3790:                                   ; preds = %3823, %3771
  %3791 = phi i64 [ %3824, %3823 ], [ 0, %3771 ]
  %3792 = icmp slt i64 %3791, %3789
  br i1 %3792, label %3793, label %3825

; <label>:3793:                                   ; preds = %3790
  %3794 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %3782, i64 %3791, i32 1
  %3795 = load i8, i8* %3794, align 8, !tbaa !238
  %3796 = icmp eq i8 %3795, 0
  %3797 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %3782, i64 %3791, i32 2
  %3798 = load i8, i8* %3797, align 1, !tbaa !239
  %3799 = zext i8 %3798 to i64
  br i1 %3796, label %3804, label %3800

; <label>:3800:                                   ; preds = %3793
  %3801 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %3799
  %3802 = call fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State* %0, %union.StackValue* %3801) #17
  %3803 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3783, i64 0, i32 6, i64 %3791
  store %struct.UpVal* %3802, %struct.UpVal** %3803, align 8, !tbaa !39
  br label %3811

; <label>:3804:                                   ; preds = %3793
  %3805 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %62, i64 0, i32 6, i64 %3799
  %3806 = bitcast %struct.UpVal** %3805 to i64*
  %3807 = load i64, i64* %3806, align 8, !tbaa !39
  %3808 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3783, i64 0, i32 6, i64 %3791
  %3809 = bitcast %struct.UpVal** %3808 to i64*
  store i64 %3807, i64* %3809, align 8, !tbaa !39
  %3810 = inttoptr i64 %3807 to %struct.UpVal*
  br label %3811

; <label>:3811:                                   ; preds = %3804, %3800
  %3812 = phi %struct.UpVal* [ %3810, %3804 ], [ %3802, %3800 ]
  %3813 = load i8, i8* %3788, align 1, !tbaa !196
  %3814 = and i8 %3813, 32
  %3815 = icmp eq i8 %3814, 0
  br i1 %3815, label %3823, label %3816

; <label>:3816:                                   ; preds = %3811
  %3817 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %3812, i64 0, i32 2
  %3818 = load i8, i8* %3817, align 1, !tbaa !66
  %3819 = and i8 %3818, 24
  %3820 = icmp eq i8 %3819, 0
  br i1 %3820, label %3823, label %3821

; <label>:3821:                                   ; preds = %3816
  %3822 = bitcast %struct.UpVal* %3812 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* nonnull %3785, %struct.GCObject* %3822) #17
  br label %3823

; <label>:3823:                                   ; preds = %3821, %3816, %3811
  %3824 = add nuw nsw i64 %3791, 1
  br label %3790

; <label>:3825:                                   ; preds = %3790
  %3826 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %3827 = getelementptr inbounds %struct.global_State, %struct.global_State* %3826, i64 0, i32 3
  %3828 = load i64, i64* %3827, align 8, !tbaa !11
  %3829 = icmp sgt i64 %3828, 0
  br i1 %3829, label %3830, label %3833

; <label>:3830:                                   ; preds = %3825
  %3831 = getelementptr inbounds %union.StackValue, %union.StackValue* %4019, i64 1
  store %union.StackValue* %3831, %union.StackValue** %34, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  %3832 = load i32, i32* %37, align 8, !tbaa !21
  br label %3833

; <label>:3833:                                   ; preds = %3830, %3825
  %3834 = phi i32 [ %3832, %3830 ], [ %4014, %3825 ]
  %3835 = icmp eq i32 %3834, 0
  br i1 %3835, label %3840, label %3836

; <label>:3836:                                   ; preds = %3833
  %3837 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %4015) #16
  %3838 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3839 = getelementptr inbounds %union.StackValue, %union.StackValue* %3838, i64 1
  br label %3840

; <label>:3840:                                   ; preds = %3833, %3836
  %3841 = phi i32 [ %3837, %3836 ], [ 0, %3833 ]
  %3842 = phi %union.StackValue* [ %3839, %3836 ], [ %4013, %3833 ]
  %3843 = getelementptr inbounds i32, i32* %4015, i64 1
  %3844 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:3845:                                   ; preds = %4011
  %3846 = lshr i32 %4012, 24
  %3847 = add nsw i32 %3846, -1
  store i32* %4015, i32** %31, align 8, !tbaa !21
  %3848 = load i64, i64* %33, align 8, !tbaa !63
  store i64 %3848, i64* %35, align 8, !tbaa !20
  %3849 = load i32, i32* %39, align 4, !tbaa !21
  %3850 = icmp eq i32 %3846, 0
  br i1 %3850, label %3854, label %3851

; <label>:3851:                                   ; preds = %3845
  %3852 = sext i32 %3849 to i64
  %3853 = sext i32 %3847 to i64
  br label %3877

; <label>:3854:                                   ; preds = %3845
  %3855 = load i64, i64* %42, align 8, !tbaa !59
  %3856 = sub i64 %3855, %3848
  %3857 = ashr exact i64 %3856, 4
  %3858 = sext i32 %3849 to i64
  %3859 = icmp sgt i64 %3857, %3858
  br i1 %3859, label %3874, label %3860

; <label>:3860:                                   ; preds = %3854
  %3861 = load i64, i64* %50, align 8, !tbaa !48
  %3862 = ptrtoint %union.StackValue* %4019 to i64
  %3863 = sub i64 %3862, %3861
  %3864 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %3865 = getelementptr inbounds %struct.global_State, %struct.global_State* %3864, i64 0, i32 3
  %3866 = load i64, i64* %3865, align 8, !tbaa !11
  %3867 = icmp sgt i64 %3866, 0
  br i1 %3867, label %3868, label %3869

; <label>:3868:                                   ; preds = %3860
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %3869

; <label>:3869:                                   ; preds = %3868, %3860
  %3870 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %3849, i32 1) #17
  %3871 = load i8*, i8** %52, align 8, !tbaa !48
  %3872 = getelementptr inbounds i8, i8* %3871, i64 %3863
  %3873 = bitcast i8* %3872 to %union.StackValue*
  br label %3874

; <label>:3874:                                   ; preds = %3869, %3854
  %3875 = phi %union.StackValue* [ %3873, %3869 ], [ %4019, %3854 ]
  %3876 = getelementptr inbounds %union.StackValue, %union.StackValue* %3875, i64 %3858
  store %union.StackValue* %3876, %union.StackValue** %34, align 8, !tbaa !20
  br label %3877

; <label>:3877:                                   ; preds = %3851, %3874
  %3878 = phi i64 [ %3853, %3851 ], [ %3858, %3874 ]
  %3879 = phi i64 [ %3852, %3851 ], [ %3858, %3874 ]
  %3880 = phi i32 [ %3847, %3851 ], [ %3849, %3874 ]
  %3881 = phi %union.StackValue* [ %4019, %3851 ], [ %3875, %3874 ]
  %3882 = sub nsw i64 0, %3879
  br label %3883

; <label>:3883:                                   ; preds = %3888, %3877
  %3884 = phi i64 [ %3899, %3888 ], [ 0, %3877 ]
  %3885 = icmp slt i64 %3884, %3878
  %3886 = icmp slt i64 %3884, %3879
  %3887 = and i1 %3885, %3886
  br i1 %3887, label %3888, label %3900

; <label>:3888:                                   ; preds = %3883
  %3889 = getelementptr inbounds %union.StackValue, %union.StackValue* %3881, i64 %3884, i32 0
  %3890 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3891 = getelementptr inbounds %union.StackValue, %union.StackValue* %3890, i64 %3882
  %3892 = getelementptr inbounds %union.StackValue, %union.StackValue* %3891, i64 %3884
  %3893 = bitcast %union.StackValue* %3892 to i64*
  %3894 = bitcast %struct.TValue* %3889 to i64*
  %3895 = load i64, i64* %3893, align 8
  store i64 %3895, i64* %3894, align 8
  %3896 = getelementptr inbounds %union.StackValue, %union.StackValue* %3892, i64 0, i32 0, i32 1
  %3897 = load i8, i8* %3896, align 8, !tbaa !22
  %3898 = getelementptr inbounds %union.StackValue, %union.StackValue* %3881, i64 %3884, i32 0, i32 1
  store i8 %3897, i8* %3898, align 8, !tbaa !22
  %3899 = add nuw nsw i64 %3884, 1
  br label %3883

; <label>:3900:                                   ; preds = %3883
  %3901 = and i64 %3884, 4294967295
  br label %3902

; <label>:3902:                                   ; preds = %3906, %3900
  %3903 = phi i64 [ %3908, %3906 ], [ %3901, %3900 ]
  %3904 = trunc i64 %3903 to i32
  %3905 = icmp sgt i32 %3880, %3904
  br i1 %3905, label %3906, label %3909

; <label>:3906:                                   ; preds = %3902
  %3907 = getelementptr inbounds %union.StackValue, %union.StackValue* %3881, i64 %3903, i32 0, i32 1
  store i8 0, i8* %3907, align 8, !tbaa !21
  %3908 = add nuw nsw i64 %3903, 1
  br label %3902

; <label>:3909:                                   ; preds = %3902
  %3910 = load i32, i32* %37, align 8, !tbaa !21
  %3911 = icmp eq i32 %3910, 0
  br i1 %3911, label %3916, label %3912

; <label>:3912:                                   ; preds = %3909
  %3913 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %4015) #16
  %3914 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3915 = getelementptr inbounds %union.StackValue, %union.StackValue* %3914, i64 1
  br label %3916

; <label>:3916:                                   ; preds = %3909, %3912
  %3917 = phi i32 [ %3913, %3912 ], [ 0, %3909 ]
  %3918 = phi %union.StackValue* [ %3915, %3912 ], [ %4013, %3909 ]
  %3919 = getelementptr inbounds i32, i32* %4015, i64 1
  %3920 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:3921:                                   ; preds = %4011
  %3922 = lshr i32 %4012, 7
  %3923 = and i32 %3922, 255
  %3924 = load %struct.Proto*, %struct.Proto** %63, align 8, !tbaa !192
  %3925 = load i64, i64* %35, align 8, !tbaa !20
  %3926 = load i64, i64* %40, align 8, !tbaa !61
  %3927 = sub i64 %3925, %3926
  %3928 = lshr exact i64 %3927, 4
  %3929 = trunc i64 %3928 to i32
  %3930 = xor i32 %3923, -1
  %3931 = add i32 %3930, %3929
  store i32 %3931, i32* %39, align 4, !tbaa !21
  %3932 = load i64, i64* %42, align 8, !tbaa !59
  %3933 = load i64, i64* %35, align 8, !tbaa !20
  %3934 = sub i64 %3932, %3933
  %3935 = ashr exact i64 %3934, 4
  %3936 = getelementptr inbounds %struct.Proto, %struct.Proto* %3924, i64 0, i32 5
  %3937 = load i8, i8* %3936, align 4, !tbaa !153
  %3938 = zext i8 %3937 to i32
  %3939 = add nuw nsw i32 %3938, 1
  %3940 = zext i32 %3939 to i64
  %3941 = icmp sgt i64 %3935, %3940
  br i1 %3941, label %3949, label %3942

; <label>:3942:                                   ; preds = %3921
  %3943 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %3939, i32 1) #17
  %3944 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %3945 = getelementptr inbounds %struct.global_State, %struct.global_State* %3944, i64 0, i32 3
  %3946 = load i64, i64* %3945, align 8, !tbaa !11
  %3947 = icmp sgt i64 %3946, 0
  br i1 %3947, label %3948, label %3949

; <label>:3948:                                   ; preds = %3942
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %3949

; <label>:3949:                                   ; preds = %3948, %3942, %3921
  %3950 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3951 = getelementptr inbounds %union.StackValue, %union.StackValue* %3950, i64 1
  store %union.StackValue* %3951, %union.StackValue** %34, align 8, !tbaa !20
  %3952 = load %struct.TValue*, %struct.TValue** %47, align 8, !tbaa !61
  %3953 = bitcast %struct.TValue* %3952 to i64*
  %3954 = bitcast %union.StackValue* %3950 to i64*
  %3955 = load i64, i64* %3953, align 8
  store i64 %3955, i64* %3954, align 8
  %3956 = getelementptr inbounds %struct.TValue, %struct.TValue* %3952, i64 0, i32 1
  %3957 = load i8, i8* %3956, align 8, !tbaa !22
  %3958 = getelementptr inbounds %union.StackValue, %union.StackValue* %3950, i64 0, i32 0, i32 1
  store i8 %3957, i8* %3958, align 8, !tbaa !22
  %3959 = add nuw nsw i32 %3923, 1
  %3960 = zext i32 %3959 to i64
  br label %3961

; <label>:3961:                                   ; preds = %3964, %3949
  %3962 = phi i64 [ %3977, %3964 ], [ 1, %3949 ]
  %3963 = icmp eq i64 %3962, %3960
  br i1 %3963, label %3978, label %3964

; <label>:3964:                                   ; preds = %3961
  %3965 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3966 = getelementptr inbounds %union.StackValue, %union.StackValue* %3965, i64 1
  store %union.StackValue* %3966, %union.StackValue** %34, align 8, !tbaa !20
  %3967 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3968 = getelementptr inbounds %union.StackValue, %union.StackValue* %3967, i64 %3962, i32 0
  %3969 = bitcast %struct.TValue* %3968 to i64*
  %3970 = bitcast %union.StackValue* %3965 to i64*
  %3971 = load i64, i64* %3969, align 8
  store i64 %3971, i64* %3970, align 8
  %3972 = getelementptr inbounds %union.StackValue, %union.StackValue* %3967, i64 %3962, i32 0, i32 1
  %3973 = load i8, i8* %3972, align 8, !tbaa !22
  %3974 = getelementptr inbounds %union.StackValue, %union.StackValue* %3965, i64 0, i32 0, i32 1
  store i8 %3973, i8* %3974, align 8, !tbaa !22
  %3975 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3976 = getelementptr inbounds %union.StackValue, %union.StackValue* %3975, i64 %3962, i32 0, i32 1
  store i8 0, i8* %3976, align 8, !tbaa !21
  %3977 = add nuw nsw i64 %3962, 1
  br label %3961

; <label>:3978:                                   ; preds = %3961
  %3979 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %3980 = shl i64 %3927, 28
  %3981 = ashr exact i64 %3980, 32
  %3982 = getelementptr inbounds %union.StackValue, %union.StackValue* %3979, i64 %3981
  store %union.StackValue* %3982, %union.StackValue** %27, align 8, !tbaa !61
  %3983 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !63
  %3984 = getelementptr inbounds %union.StackValue, %union.StackValue* %3983, i64 %3981
  store %union.StackValue* %3984, %union.StackValue** %32, align 8, !tbaa !63
  %3985 = load i32, i32* %37, align 8, !tbaa !21
  %3986 = icmp eq i32 %3985, 0
  br i1 %3986, label %3987, label %3989

; <label>:3987:                                   ; preds = %3978
  %3988 = getelementptr inbounds i32, i32* %4015, i64 1
  br label %3993

; <label>:3989:                                   ; preds = %3978
  call fastcc void @luaD_hookcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1) #16
  %3990 = getelementptr inbounds i32, i32* %4015, i64 1
  store i32* %3990, i32** %55, align 8, !tbaa !91
  %3991 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %4015) #16
  %3992 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  br label %3993

; <label>:3993:                                   ; preds = %3987, %3989
  %3994 = phi i32* [ %3988, %3987 ], [ %3990, %3989 ]
  %3995 = phi %union.StackValue* [ %3982, %3987 ], [ %3992, %3989 ]
  %3996 = phi i32 [ 0, %3987 ], [ %3991, %3989 ]
  %3997 = getelementptr inbounds %union.StackValue, %union.StackValue* %3995, i64 1
  %3998 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:3999:                                   ; preds = %4011
  %4000 = icmp eq i32 %4014, 0
  br i1 %4000, label %4005, label %4001

; <label>:4001:                                   ; preds = %3999
  %4002 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4015) #16
  %4003 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !61
  %4004 = getelementptr inbounds %union.StackValue, %union.StackValue* %4003, i64 1
  br label %4005

; <label>:4005:                                   ; preds = %3999, %4001
  %4006 = phi i32 [ %4002, %4001 ], [ 0, %3999 ]
  %4007 = phi %union.StackValue* [ %4004, %4001 ], [ %4013, %3999 ]
  %4008 = getelementptr inbounds i32, i32* %4015, i64 1
  %4009 = load i32, i32* %4015, align 4, !tbaa !74
  br label %110

; <label>:4010:                                   ; preds = %3391, %3358, %3370, %3382, %3347, %3343, %3240
  ret void

; <label>:4011:                                   ; preds = %110, %83
  %4012 = phi i32 [ %88, %83 ], [ %111, %110 ]
  %4013 = phi %union.StackValue* [ %86, %83 ], [ %112, %110 ]
  %4014 = phi i32 [ %85, %83 ], [ %113, %110 ]
  %4015 = phi i32* [ %87, %83 ], [ %114, %110 ]
  %4016 = lshr i32 %4012, 7
  %4017 = and i32 %4016, 255
  %4018 = zext i32 %4017 to i64
  %4019 = getelementptr inbounds %union.StackValue, %union.StackValue* %4013, i64 %4018
  %4020 = and i32 %4012, 127
  %4021 = zext i32 %4020 to i64
  %4022 = getelementptr inbounds [84 x i8*], [84 x i8*]* @luaV_execute.disptab, i64 0, i64 %4021
  %4023 = load i8*, i8** %4022, align 8, !tbaa !39
  indirectbr i8* %4023, [label %89, label %135, label %151, label %115, label %167, label %189, label %207, label %228, label %252, label %294, label %340, label %413, label %467, label %510, label %582, label %678, label %755, label %821, label %870, label %923, label %964, label %1003, label %1044, label %1083, label %1121, label %1159, label %1199, label %1260, label %1319, label %1380, label %1439, label %1487, label %1535, label %1987, label %2029, label %2071, label %2263, label %2311, label %1595, label %1654, label %1713, label %1772, label %1831, label %1879, label %1927, label %2113, label %2163, label %2213, label %2402, label %2351, label %2452, label %2486, label %2522, label %2552, label %2569, label %2591, label %2605, label %2616, label %2632, label %2662, label %2726, label %2790, label %2822, label %2868, label %2920, label %2972, label %3024, label %3076, label %3118, label %3169, label %3190, label %3313, label %3344, label %3366, label %3399, label %3458, label %3610, label %3623, label %3646, label %3678, label %3771, label %3845, label %3921, label %3999]
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_poscall(%struct.lua_State*, %struct.CallInfo* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %5 = load i32, i32* %4, align 8, !tbaa !23
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %9 = bitcast %struct.CallInfo** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !92
  br label %88

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = sext i32 %2 to i64
  %15 = sub nsw i64 0, %14
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 %15
  %17 = ptrtoint %union.StackValue* %13 to i64
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %19 = bitcast %union.StackValue** %18 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !48
  %21 = sub i64 %17, %20
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %23 = load i16, i16* %22, align 2, !tbaa !60
  %24 = and i16 %23, 6
  %25 = icmp eq i16 %24, 0
  br i1 %25, label %26, label %51

; <label>:26:                                     ; preds = %11
  %27 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %28 = load %struct.LClosure**, %struct.LClosure*** %27, align 8, !tbaa !61
  %29 = load %struct.LClosure*, %struct.LClosure** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %29, i64 0, i32 5
  %31 = load %struct.Proto*, %struct.Proto** %30, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 4
  %33 = load i8, i8* %32, align 1, !tbaa !102
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %45, label %35

; <label>:35:                                     ; preds = %26
  %36 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %37 = bitcast %union.anon.0* %36 to %struct.anon*
  %38 = getelementptr inbounds %struct.anon, %struct.anon* %37, i64 0, i32 2
  %39 = load i32, i32* %38, align 4, !tbaa !21
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 3
  %41 = load i8, i8* %40, align 2, !tbaa !117
  %42 = zext i8 %41 to i32
  %43 = add i32 %39, 1
  %44 = add i32 %43, %42
  br label %45

; <label>:45:                                     ; preds = %35, %26
  %46 = phi i32 [ %44, %35 ], [ 0, %26 ]
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %48 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !63
  %49 = icmp ult %union.StackValue* %13, %48
  br i1 %49, label %50, label %51

; <label>:50:                                     ; preds = %45
  store %union.StackValue* %48, %union.StackValue** %12, align 8, !tbaa !20
  br label %51

; <label>:51:                                     ; preds = %50, %45, %11
  %52 = phi i32 [ 0, %11 ], [ %46, %50 ], [ %46, %45 ]
  %53 = and i32 %5, 2
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %69, label %55

; <label>:55:                                     ; preds = %51
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %57 = load %union.StackValue*, %union.StackValue** %56, align 8, !tbaa !61
  %58 = sext i32 %52 to i64
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 %58
  store %union.StackValue* %59, %union.StackValue** %56, align 8, !tbaa !61
  %60 = ptrtoint %union.StackValue* %16 to i64
  %61 = ptrtoint %union.StackValue* %59 to i64
  %62 = sub i64 %60, %61
  %63 = lshr exact i64 %62, 4
  %64 = trunc i64 %63 to i32
  %65 = and i32 %64, 65535
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 1, i32 -1, i32 %65, i32 %2) #17
  %66 = load %union.StackValue*, %union.StackValue** %56, align 8, !tbaa !61
  %67 = sub nsw i64 0, %58
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 %67
  store %union.StackValue* %68, %union.StackValue** %56, align 8, !tbaa !61
  br label %69

; <label>:69:                                     ; preds = %55, %51
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %71 = load %struct.CallInfo*, %struct.CallInfo** %70, align 8, !tbaa !92
  %72 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %71, i64 0, i32 7
  %73 = load i16, i16* %72, align 2, !tbaa !60
  %74 = and i16 %73, 2
  %75 = icmp eq i16 %74, 0
  %76 = ptrtoint %struct.CallInfo* %71 to i64
  br i1 %75, label %77, label %83

; <label>:77:                                     ; preds = %69
  %78 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %71, i64 0, i32 4
  %79 = bitcast %union.anon.0* %78 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !21
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %82 = bitcast i32** %81 to i64*
  store i64 %80, i64* %82, align 8, !tbaa !91
  br label %83

; <label>:83:                                     ; preds = %69, %77
  %84 = bitcast %union.StackValue** %18 to i8**
  %85 = load i8*, i8** %84, align 8, !tbaa !48
  %86 = getelementptr inbounds i8, i8* %85, i64 %21
  %87 = bitcast %union.StackValue** %12 to i8**
  store i8* %86, i8** %87, align 8, !tbaa !20
  br label %88

; <label>:88:                                     ; preds = %7, %83
  %89 = phi i64 [ %10, %7 ], [ %76, %83 ]
  %90 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %91 = bitcast %struct.CallInfo** %90 to i64*
  store i64 %89, i64* %91, align 8, !tbaa !49
  %92 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %93 = load %union.StackValue*, %union.StackValue** %92, align 8, !tbaa !61
  %94 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %95 = load i16, i16* %94, align 4, !tbaa !62
  %96 = sext i16 %95 to i32
  switch i32 %96, label %116 [
    i32 0, label %97
    i32 1, label %99
    i32 -1, label %132
  ]

; <label>:97:                                     ; preds = %88
  %98 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %93, %union.StackValue** %98, align 8, !tbaa !20
  br label %167

; <label>:99:                                     ; preds = %88
  %100 = icmp eq i32 %2, 0
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %100, label %112, label %102

; <label>:102:                                    ; preds = %99
  %103 = load %union.StackValue*, %union.StackValue** %101, align 8, !tbaa !20
  %104 = sext i32 %2 to i64
  %105 = sub nsw i64 0, %104
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 %105, i32 0
  %107 = bitcast %struct.TValue* %106 to i64*
  %108 = bitcast %union.StackValue* %93 to i64*
  %109 = load i64, i64* %107, align 8
  store i64 %109, i64* %108, align 8
  %110 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 %105, i32 0, i32 1
  %111 = load i8, i8* %110, align 8, !tbaa !22
  br label %112

; <label>:112:                                    ; preds = %99, %102
  %113 = phi i8 [ %111, %102 ], [ 0, %99 ]
  %114 = getelementptr inbounds %union.StackValue, %union.StackValue* %93, i64 0, i32 0, i32 1
  store i8 %113, i8* %114, align 8
  %115 = getelementptr inbounds %union.StackValue, %union.StackValue* %93, i64 1
  store %union.StackValue* %115, %union.StackValue** %101, align 8, !tbaa !20
  br label %167

; <label>:116:                                    ; preds = %88
  %117 = icmp slt i16 %95, -1
  br i1 %117, label %118, label %132

; <label>:118:                                    ; preds = %116
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %120 = bitcast %union.StackValue** %119 to i64*
  %121 = load i64, i64* %120, align 8, !tbaa !48
  %122 = ptrtoint %union.StackValue* %93 to i64
  %123 = sub i64 %122, %121
  %124 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %93, i32 0) #17
  %125 = bitcast %union.StackValue** %119 to i8**
  %126 = load i8*, i8** %125, align 8, !tbaa !48
  %127 = getelementptr inbounds i8, i8* %126, i64 %123
  %128 = bitcast i8* %127 to %union.StackValue*
  %129 = sub nsw i32 -3, %96
  %130 = icmp eq i32 %129, -1
  %131 = select i1 %130, i32 %2, i32 %129
  br label %132

; <label>:132:                                    ; preds = %118, %116, %88
  %133 = phi i32 [ %131, %118 ], [ %96, %116 ], [ %2, %88 ]
  %134 = phi %union.StackValue* [ %128, %118 ], [ %93, %116 ], [ %93, %88 ]
  %135 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %136 = load %union.StackValue*, %union.StackValue** %135, align 8, !tbaa !20
  %137 = sext i32 %2 to i64
  %138 = sub nsw i64 0, %137
  %139 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 %138
  %140 = sext i32 %133 to i64
  br label %141

; <label>:141:                                    ; preds = %146, %132
  %142 = phi i64 [ %155, %146 ], [ 0, %132 ]
  %143 = icmp slt i64 %142, %137
  %144 = icmp slt i64 %142, %140
  %145 = and i1 %143, %144
  br i1 %145, label %146, label %156

; <label>:146:                                    ; preds = %141
  %147 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %142, i32 0
  %148 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 %142
  %149 = bitcast %union.StackValue* %148 to i64*
  %150 = bitcast %struct.TValue* %147 to i64*
  %151 = load i64, i64* %149, align 8
  store i64 %151, i64* %150, align 8
  %152 = getelementptr inbounds %union.StackValue, %union.StackValue* %148, i64 0, i32 0, i32 1
  %153 = load i8, i8* %152, align 8, !tbaa !22
  %154 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %142, i32 0, i32 1
  store i8 %153, i8* %154, align 8, !tbaa !22
  %155 = add nuw nsw i64 %142, 1
  br label %141

; <label>:156:                                    ; preds = %141
  %157 = and i64 %142, 4294967295
  br label %158

; <label>:158:                                    ; preds = %162, %156
  %159 = phi i64 [ %164, %162 ], [ %157, %156 ]
  %160 = trunc i64 %159 to i32
  %161 = icmp sgt i32 %133, %160
  br i1 %161, label %162, label %165

; <label>:162:                                    ; preds = %158
  %163 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %159, i32 0, i32 1
  store i8 0, i8* %163, align 8, !tbaa !21
  %164 = add nuw nsw i64 %159, 1
  br label %158

; <label>:165:                                    ; preds = %158
  %166 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %140
  store %union.StackValue* %166, %union.StackValue** %135, align 8, !tbaa !20
  br label %167

; <label>:167:                                    ; preds = %97, %112, %165
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_hookcall(%struct.lua_State*, %struct.CallInfo* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %4 = load i32, i32* %3, align 8, !tbaa !23
  %5 = and i32 %4, 1
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %32, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !60
  %10 = lshr i16 %9, 2
  %11 = and i16 %10, 4
  %12 = zext i16 %11 to i32
  %13 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %14 = load %struct.LClosure**, %struct.LClosure*** %13, align 8, !tbaa !61
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %19 = bitcast %union.StackValue** %18 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !63
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to i64*
  store i64 %20, i64* %22, align 8, !tbaa !20
  %23 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %24 = bitcast %union.anon.0* %23 to i32**
  %25 = load i32*, i32** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds i32, i32* %25, i64 1
  store i32* %26, i32** %24, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 3
  %28 = load i8, i8* %27, align 2, !tbaa !117
  %29 = zext i8 %28 to i32
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 %12, i32 -1, i32 1, i32 %29) #16
  %30 = load i32*, i32** %24, align 8, !tbaa !21
  %31 = getelementptr inbounds i32, i32* %30, i64 -1
  store i32* %31, i32** %24, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %2, %7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaG_traceexec(%struct.lua_State*, i32*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !49
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %6 = load i32, i32* %5, align 8, !tbaa !23
  %7 = and i32 %6, 12
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %11 = bitcast i64* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !21
  br label %115

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds i32, i32* %1, i64 1
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4
  %15 = bitcast %union.anon.0* %14 to i32**
  store i32* %13, i32** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  %17 = load i32, i32* %16, align 4, !tbaa !26
  %18 = add nsw i32 %17, -1
  store i32 %18, i32* %16, align 4, !tbaa !26
  %19 = icmp eq i32 %18, 0
  %20 = and i32 %6, 8
  %21 = icmp ne i32 %20, 0
  %22 = and i1 %21, %19
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %12
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %25 = load i32, i32* %24, align 8, !tbaa !24
  store i32 %25, i32* %16, align 4, !tbaa !26
  br label %29

; <label>:26:                                     ; preds = %12
  %27 = and i32 %6, 4
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %115, label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %31 = load i16, i16* %30, align 2, !tbaa !60
  %32 = and i16 %31, 32
  %33 = icmp eq i16 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %29
  %35 = and i16 %31, -33
  store i16 %35, i16* %30, align 2, !tbaa !60
  br label %115

; <label>:36:                                     ; preds = %29
  %37 = load i32*, i32** %15, align 8, !tbaa !21
  %38 = getelementptr inbounds i32, i32* %37, i64 -1
  %39 = load i32, i32* %38, align 4, !tbaa !74
  %40 = and i32 %39, 127
  %41 = zext i32 %40 to i64
  %42 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %41
  %43 = load i8, i8* %42, align 1, !tbaa !21
  %44 = and i8 %43, 32
  %45 = icmp ne i8 %44, 0
  %46 = and i32 %39, 16711680
  %47 = icmp eq i32 %46, 0
  %48 = and i1 %47, %45
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %36
  %50 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %51 = bitcast %union.StackValue** %50 to i64*
  %52 = load i64, i64* %51, align 8, !tbaa !63
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %54 = bitcast %union.StackValue** %53 to i64*
  store i64 %52, i64* %54, align 8, !tbaa !20
  br label %55

; <label>:55:                                     ; preds = %36, %49
  br i1 %22, label %56, label %57

; <label>:56:                                     ; preds = %55
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 3, i32 -1, i32 0, i32 0) #16
  br label %57

; <label>:57:                                     ; preds = %56, %55
  %58 = and i32 %6, 4
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %104, label %60

; <label>:60:                                     ; preds = %57
  %61 = bitcast %struct.CallInfo* %4 to %struct.LClosure***
  %62 = load %struct.LClosure**, %struct.LClosure*** %61, align 8, !tbaa !61
  %63 = load %struct.LClosure*, %struct.LClosure** %62, align 8, !tbaa !21
  %64 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %63, i64 0, i32 5
  %65 = load %struct.Proto*, %struct.Proto** %64, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.Proto, %struct.Proto* %65, i64 0, i32 16
  %67 = bitcast i32** %66 to i64*
  %68 = load i64, i64* %67, align 8, !tbaa !119
  %69 = ptrtoint i32* %13 to i64
  %70 = sub i64 %69, %68
  %71 = lshr exact i64 %70, 2
  %72 = trunc i64 %71 to i32
  %73 = add nsw i32 %72, -1
  %74 = icmp eq i32 %73, 0
  %75 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  br i1 %74, label %101, label %76

; <label>:76:                                     ; preds = %60
  %77 = load i32*, i32** %75, align 8, !tbaa !91
  %78 = icmp ugt i32* %13, %77
  br i1 %78, label %79, label %101

; <label>:79:                                     ; preds = %76
  %80 = ptrtoint i32* %77 to i64
  %81 = sub i64 %80, %68
  %82 = getelementptr inbounds %struct.Proto, %struct.Proto* %65, i64 0, i32 19
  %83 = shl i64 %81, 30
  %84 = add i64 %83, -4294967296
  %85 = ashr exact i64 %84, 32
  %86 = sext i32 %73 to i64
  br label %87

; <label>:87:                                     ; preds = %91, %79
  %88 = phi i64 [ %89, %91 ], [ %85, %79 ]
  %89 = add nsw i64 %88, 1
  %90 = icmp slt i64 %88, %86
  br i1 %90, label %91, label %103

; <label>:91:                                     ; preds = %87
  %92 = load i8*, i8** %82, align 8, !tbaa !124
  %93 = getelementptr inbounds i8, i8* %92, i64 %89
  %94 = load i8, i8* %93, align 1, !tbaa !21
  %95 = icmp eq i8 %94, 0
  br i1 %95, label %87, label %96

; <label>:96:                                     ; preds = %91
  %97 = trunc i64 %88 to i32
  %98 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %65, i32 %97) #17
  %99 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %65, i32 %73) #17
  %100 = icmp eq i32 %98, %99
  br i1 %100, label %103, label %101

; <label>:101:                                    ; preds = %60, %96, %76
  %102 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %65, i32 %73) #16
  tail call fastcc void @luaD_hook(%struct.lua_State* %0, i32 2, i32 %102, i32 0, i32 0) #16
  br label %103

; <label>:103:                                    ; preds = %87, %96, %101
  store i32* %13, i32** %75, align 8, !tbaa !91
  br label %104

; <label>:104:                                    ; preds = %57, %103
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %106 = load i8, i8* %105, align 2, !tbaa !57
  %107 = icmp eq i8 %106, 1
  br i1 %107, label %108, label %115

; <label>:108:                                    ; preds = %104
  br i1 %22, label %109, label %110

; <label>:109:                                    ; preds = %108
  store i32 1, i32* %16, align 4, !tbaa !26
  br label %110

; <label>:110:                                    ; preds = %109, %108
  %111 = load i32*, i32** %15, align 8, !tbaa !21
  %112 = getelementptr inbounds i32, i32* %111, i64 -1
  store i32* %112, i32** %15, align 8, !tbaa !21
  %113 = load i16, i16* %30, align 2, !tbaa !60
  %114 = or i16 %113, 32
  store i16 %114, i16* %30, align 2, !tbaa !60
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #18
  unreachable

; <label>:115:                                    ; preds = %104, %26, %34, %9
  %116 = phi i32 [ 1, %34 ], [ 0, %9 ], [ 1, %26 ], [ 1, %104 ]
  ret i32 %116
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_getstr(%struct.Table* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !72
  %6 = icmp eq i8 %5, 20
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %2
  %8 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* nonnull %1) #16
  br label %15

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %1, %struct.TString** %11, align 8, !tbaa !21
  %12 = or i8 %5, 64
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %12, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  br label %15

; <label>:15:                                     ; preds = %9, %7
  %16 = phi %struct.TValue* [ %8, %7 ], [ %14, %9 ]
  ret %struct.TValue* %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaT_trybiniTM(%struct.lua_State*, %struct.TValue*, i64, i32, %union.StackValue*, i32) unnamed_addr #0 {
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast %struct.TValue* %7 to i64*
  store i64 %2, i64* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 35, i8* %10, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* nonnull %7, %union.StackValue* %4, i32 %3, i32 %5) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @luaV_mod(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %9, !prof !47

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %17

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.168, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = srem i64 %1, %2
  %11 = icmp ne i64 %10, 0
  %12 = xor i64 %10, %2
  %13 = icmp slt i64 %12, 0
  %14 = and i1 %11, %13
  %15 = select i1 %14, i64 %2, i64 0
  %16 = add nsw i64 %15, %10
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i64 [ 0, %6 ], [ %16, %9 ]
  ret i64 %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc double @luaV_modf(double, double) unnamed_addr #0 {
  %3 = tail call double @fmod(double %0, double %1) #17
  %4 = fcmp ogt double %3, 0.000000e+00
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = fcmp olt double %1, 0.000000e+00
  br i1 %6, label %11, label %13

; <label>:7:                                      ; preds = %2
  %8 = fcmp olt double %3, 0.000000e+00
  %9 = fcmp ogt double %1, 0.000000e+00
  %10 = and i1 %9, %8
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %7, %5
  %12 = fadd double %3, %1
  br label %13

; <label>:13:                                     ; preds = %11, %7, %5
  %14 = phi double [ %12, %11 ], [ %3, %5 ], [ %3, %7 ]
  ret double %14
}

; Function Attrs: minsize nounwind optsize
declare double @pow(double, double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @luaV_idiv(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %11, !prof !47

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.169, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %6
  %10 = sub i64 0, %1
  br label %20

; <label>:11:                                     ; preds = %3
  %12 = sdiv i64 %1, %2
  %13 = srem i64 %1, %2
  %14 = xor i64 %2, %1
  %15 = icmp slt i64 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %11
  %17 = icmp ne i64 %13, 0
  %18 = sext i1 %17 to i64
  %19 = add nsw i64 %12, %18
  ret i64 %19

; <label>:20:                                     ; preds = %11, %9
  %21 = phi i64 [ %10, %9 ], [ %12, %11 ]
  ret i64 %21
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.floor.f64(double) #14

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaT_trybinassocTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32, i32) unnamed_addr #0 {
  %7 = icmp eq i32 %4, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2, %struct.TValue* %1, %union.StackValue* %3, i32 %5) #16
  br label %10

; <label>:9:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %5) #16
  br label %10

; <label>:10:                                     ; preds = %9, %8
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaT_trybinTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %4) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %23

; <label>:8:                                      ; preds = %5
  switch i32 %4, label %22 [
    i32 22, label %9
    i32 13, label %10
    i32 14, label %10
    i32 15, label %10
    i32 16, label %10
    i32 17, label %10
    i32 19, label %10
  ]

; <label>:9:                                      ; preds = %8
  tail call fastcc void @luaG_concaterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2) #18
  unreachable

; <label>:10:                                     ; preds = %8, %8, %8, %8, %8, %8
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = and i8 %12, 15
  %14 = icmp eq i8 %13, 3
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %10
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 3
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %15
  tail call fastcc void @luaG_tointerror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2) #18
  unreachable

; <label>:21:                                     ; preds = %15, %10
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.170, i64 0, i64 0)) #18
  unreachable

; <label>:22:                                     ; preds = %8
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.171, i64 0, i64 0)) #18
  unreachable

; <label>:23:                                     ; preds = %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaV_tointegerns(%struct.TValue* nocapture readonly, i64* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %13 [
    i8 19, label %6
    i8 35, label %10
  ]

; <label>:6:                                      ; preds = %3
  %7 = bitcast %struct.TValue* %0 to double*
  %8 = load double, double* %7, align 8, !tbaa !21
  %9 = tail call fastcc i32 @luaV_flttointeger(double %8, i64* %1, i32 %2) #16
  br label %13

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %0 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %1, align 8, !tbaa !129
  br label %13

; <label>:13:                                     ; preds = %3, %10, %6
  %14 = phi i32 [ %9, %6 ], [ 1, %10 ], [ 0, %3 ]
  ret i32 %14
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define internal fastcc i64 @luaV_shiftl(i64, i64) unnamed_addr #6 {
  %3 = icmp slt i64 %1, 0
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %2
  %5 = icmp slt i64 %1, -63
  %6 = sub nsw i64 0, %1
  %7 = lshr i64 %0, %6
  %8 = select i1 %5, i64 0, i64 %7
  ret i64 %8

; <label>:9:                                      ; preds = %2
  %10 = icmp sgt i64 %1, 63
  %11 = shl i64 %0, %1
  %12 = select i1 %10, i64 0, i64 %11
  ret i64 %12
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @LTnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %37

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp slt i64 %8, %14
  br label %65

; <label>:16:                                     ; preds = %6
  %17 = bitcast %struct.TValue* %1 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  %19 = add i64 %8, 9007199254740992
  %20 = icmp ult i64 %19, 18014398509481985
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %16
  %22 = sitofp i64 %8 to double
  %23 = fcmp ogt double %18, %22
  br label %65

; <label>:24:                                     ; preds = %16
  %25 = tail call double @llvm.floor.f64(double %18) #7
  %26 = fcmp une double %25, %18
  %27 = fadd double %25, 1.000000e+00
  %28 = select i1 %26, double %27, double %25
  %29 = fcmp oge double %28, 0xC3E0000000000000
  %30 = fcmp olt double %28, 0x43E0000000000000
  %31 = and i1 %29, %30
  br i1 %31, label %32, label %35

; <label>:32:                                     ; preds = %24
  %33 = fptosi double %28 to i64
  %34 = icmp slt i64 %8, %33
  br label %65

; <label>:35:                                     ; preds = %24
  %36 = fcmp ogt double %18, 0.000000e+00
  br label %65

; <label>:37:                                     ; preds = %2
  %38 = bitcast %struct.TValue* %0 to double*
  %39 = load double, double* %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = icmp eq i8 %41, 19
  br i1 %42, label %43, label %47

; <label>:43:                                     ; preds = %37
  %44 = bitcast %struct.TValue* %1 to double*
  %45 = load double, double* %44, align 8, !tbaa !21
  %46 = fcmp olt double %39, %45
  br label %65

; <label>:47:                                     ; preds = %37
  %48 = bitcast %struct.TValue* %1 to i64*
  %49 = load i64, i64* %48, align 8, !tbaa !21
  %50 = add i64 %49, 9007199254740992
  %51 = icmp ult i64 %50, 18014398509481985
  br i1 %51, label %52, label %55

; <label>:52:                                     ; preds = %47
  %53 = sitofp i64 %49 to double
  %54 = fcmp olt double %39, %53
  br label %65

; <label>:55:                                     ; preds = %47
  %56 = tail call double @llvm.floor.f64(double %39) #7
  %57 = fcmp oge double %56, 0xC3E0000000000000
  %58 = fcmp olt double %56, 0x43E0000000000000
  %59 = and i1 %57, %58
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %55
  %61 = fptosi double %56 to i64
  %62 = icmp sgt i64 %49, %61
  br label %65

; <label>:63:                                     ; preds = %55
  %64 = fcmp olt double %39, 0.000000e+00
  br label %65

; <label>:65:                                     ; preds = %63, %60, %52, %35, %32, %21, %43, %12
  %66 = phi i1 [ %15, %12 ], [ %46, %43 ], [ %23, %21 ], [ %36, %35 ], [ %34, %32 ], [ %54, %52 ], [ %64, %63 ], [ %62, %60 ]
  %67 = zext i1 %66 to i32
  ret i32 %67
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @lessthanothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %20

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17) #16
  %19 = lshr i32 %18, 31
  br label %22

; <label>:20:                                     ; preds = %8, %3
  %21 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 20) #16
  br label %22

; <label>:22:                                     ; preds = %20, %13
  %23 = phi i32 [ %19, %13 ], [ %21, %20 ]
  ret i32 %23
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @LEnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %34

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp sle i64 %8, %14
  br label %65

; <label>:16:                                     ; preds = %6
  %17 = bitcast %struct.TValue* %1 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  %19 = add i64 %8, 9007199254740992
  %20 = icmp ult i64 %19, 18014398509481985
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %16
  %22 = sitofp i64 %8 to double
  %23 = fcmp oge double %18, %22
  br label %65

; <label>:24:                                     ; preds = %16
  %25 = tail call double @llvm.floor.f64(double %18) #7
  %26 = fcmp oge double %25, 0xC3E0000000000000
  %27 = fcmp olt double %25, 0x43E0000000000000
  %28 = and i1 %26, %27
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %24
  %30 = fptosi double %25 to i64
  %31 = icmp sle i64 %8, %30
  br label %65

; <label>:32:                                     ; preds = %24
  %33 = fcmp ogt double %18, 0.000000e+00
  br label %65

; <label>:34:                                     ; preds = %2
  %35 = bitcast %struct.TValue* %0 to double*
  %36 = load double, double* %35, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 19
  br i1 %39, label %40, label %44

; <label>:40:                                     ; preds = %34
  %41 = bitcast %struct.TValue* %1 to double*
  %42 = load double, double* %41, align 8, !tbaa !21
  %43 = fcmp ole double %36, %42
  br label %65

; <label>:44:                                     ; preds = %34
  %45 = bitcast %struct.TValue* %1 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !21
  %47 = add i64 %46, 9007199254740992
  %48 = icmp ult i64 %47, 18014398509481985
  br i1 %48, label %49, label %52

; <label>:49:                                     ; preds = %44
  %50 = sitofp i64 %46 to double
  %51 = fcmp ole double %36, %50
  br label %65

; <label>:52:                                     ; preds = %44
  %53 = tail call double @llvm.floor.f64(double %36) #7
  %54 = fcmp une double %53, %36
  %55 = fadd double %53, 1.000000e+00
  %56 = select i1 %54, double %55, double %53
  %57 = fcmp oge double %56, 0xC3E0000000000000
  %58 = fcmp olt double %56, 0x43E0000000000000
  %59 = and i1 %57, %58
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %52
  %61 = fptosi double %56 to i64
  %62 = icmp sge i64 %46, %61
  br label %65

; <label>:63:                                     ; preds = %52
  %64 = fcmp olt double %36, 0.000000e+00
  br label %65

; <label>:65:                                     ; preds = %63, %60, %49, %32, %29, %21, %40, %12
  %66 = phi i1 [ %15, %12 ], [ %43, %40 ], [ %23, %21 ], [ %33, %32 ], [ %31, %29 ], [ %51, %49 ], [ %64, %63 ], [ %62, %60 ]
  %67 = zext i1 %66 to i32
  ret i32 %67
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @lessequalothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %21

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17) #16
  %19 = icmp slt i32 %18, 1
  %20 = zext i1 %19 to i32
  br label %23

; <label>:21:                                     ; preds = %8, %3
  %22 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 21) #16
  br label %23

; <label>:23:                                     ; preds = %21, %13
  %24 = phi i32 [ %20, %13 ], [ %22, %21 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaT_callorderiTM(%struct.lua_State*, %struct.TValue*, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = icmp eq i32 %4, 0
  br i1 %9, label %13, label %10

; <label>:10:                                     ; preds = %6
  %11 = sitofp i32 %2 to double
  %12 = bitcast %struct.TValue* %7 to double*
  store double %11, double* %12, align 8, !tbaa !21
  br label %16

; <label>:13:                                     ; preds = %6
  %14 = sext i32 %2 to i64
  %15 = bitcast %struct.TValue* %7 to i64*
  store i64 %14, i64* %15, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %13, %10
  %17 = phi i8 [ 35, %13 ], [ 19, %10 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 %17, i8* %18, align 8
  %19 = icmp eq i32 %3, 0
  %20 = select i1 %19, %struct.TValue* %7, %struct.TValue* %1
  %21 = select i1 %19, %struct.TValue* %1, %struct.TValue* %7
  %22 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* %21, %struct.TValue* %20, i32 %5) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %22
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_tryfuncTM(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %4 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %3, i32 23) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 6
  br i1 %8, label %10, label %9, !prof !70

; <label>:9:                                      ; preds = %2
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i64 0, i64 0)) #18
  unreachable

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  br label %13

; <label>:13:                                     ; preds = %16, %10
  %14 = phi %union.StackValue* [ %12, %10 ], [ %24, %16 ]
  %15 = icmp ugt %union.StackValue* %14, %1
  br i1 %15, label %16, label %25

; <label>:16:                                     ; preds = %13
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0
  %18 = bitcast %struct.TValue* %17 to i64*
  %19 = bitcast %union.StackValue* %14 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 0, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1
  br label %13

; <label>:25:                                     ; preds = %13
  %26 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 1
  store %union.StackValue* %27, %union.StackValue** %11, align 8, !tbaa !20
  %28 = bitcast %struct.TValue* %4 to i64*
  %29 = bitcast %union.StackValue* %1 to i64*
  %30 = load i64, i64* %28, align 8
  store i64 %30, i64* %29, align 8
  %31 = load i8, i8* %5, align 8, !tbaa !22
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  ret void
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_forerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.179, i64 0, i64 0), i8* %2, i8* %4) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_hook(%struct.lua_State*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.lua_Debug, align 8
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %8 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %7, align 8, !tbaa !25
  %9 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %8, null
  br i1 %9, label %74, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !55
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %74, label %14

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !49
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !48
  %23 = sub i64 %19, %22
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 1
  %25 = bitcast %union.StackValue** %24 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !63
  %27 = sub i64 %26, %22
  %28 = bitcast %struct.lua_Debug* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %28) #7
  %29 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 0
  store i32 %1, i32* %29, align 8, !tbaa !240
  %30 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 6
  store i32 %2, i32* %30, align 8, !tbaa !113
  %31 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 16
  store %struct.CallInfo* %16, %struct.CallInfo** %31, align 8, !tbaa !93
  %32 = icmp eq i32 %4, 0
  %33 = inttoptr i64 %26 to %union.StackValue*
  br i1 %32, label %42, label %34

; <label>:34:                                     ; preds = %14
  %35 = trunc i32 %3 to i16
  %36 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 5
  %37 = bitcast %union.anon.2* %36 to %struct.anon.3*
  %38 = bitcast %union.anon.2* %36 to i16*
  store i16 %35, i16* %38, align 8, !tbaa !21
  %39 = trunc i32 %4 to i16
  %40 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %37, i64 0, i32 1
  store i16 %39, i16* %40, align 2, !tbaa !21
  %41 = load i64, i64* %18, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %14, %34
  %43 = phi i64 [ %41, %34 ], [ %19, %14 ]
  %44 = phi i16 [ 132, %34 ], [ 4, %14 ]
  %45 = inttoptr i64 %43 to %union.StackValue*
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %47 = bitcast %union.StackValue** %46 to i64*
  %48 = load i64, i64* %47, align 8, !tbaa !59
  %49 = sub i64 %48, %43
  %50 = icmp slt i64 %49, 336
  br i1 %50, label %51, label %55

; <label>:51:                                     ; preds = %42
  %52 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1) #16
  %53 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %54 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !63
  br label %55

; <label>:55:                                     ; preds = %42, %51
  %56 = phi %union.StackValue* [ %33, %42 ], [ %54, %51 ]
  %57 = phi %union.StackValue* [ %45, %42 ], [ %53, %51 ]
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 20
  %59 = icmp ugt %union.StackValue* %58, %56
  br i1 %59, label %60, label %61

; <label>:60:                                     ; preds = %55
  store %union.StackValue* %58, %union.StackValue** %24, align 8, !tbaa !63
  br label %61

; <label>:61:                                     ; preds = %60, %55
  store i8 0, i8* %11, align 1, !tbaa !55
  %62 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 7
  %63 = load i16, i16* %62, align 2, !tbaa !60
  %64 = or i16 %63, %44
  store i16 %64, i16* %62, align 2, !tbaa !60
  call void %8(%struct.lua_State* nonnull %0, %struct.lua_Debug* nonnull %6) #17
  store i8 1, i8* %11, align 1, !tbaa !55
  %65 = bitcast %union.StackValue** %20 to i8**
  %66 = load i8*, i8** %65, align 8, !tbaa !48
  %67 = getelementptr inbounds i8, i8* %66, i64 %27
  %68 = bitcast %union.StackValue** %24 to i8**
  store i8* %67, i8** %68, align 8, !tbaa !63
  %69 = getelementptr inbounds i8, i8* %66, i64 %23
  %70 = bitcast %union.StackValue** %17 to i8**
  store i8* %69, i8** %70, align 8, !tbaa !20
  %71 = load i16, i16* %62, align 2, !tbaa !60
  %72 = xor i16 %44, -1
  %73 = and i16 %71, %72
  store i16 %73, i16* %62, align 2, !tbaa !60
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %28) #7
  br label %74

; <label>:74:                                     ; preds = %10, %5, %61
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TValue* @getgeneric(%struct.Table* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = tail call fastcc %union.Node* @mainpositionTV(%struct.Table* %0, %struct.TValue* %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %8 = bitcast %struct.TValue* %1 to i64*
  %9 = bitcast %struct.TValue* %1 to double*
  %10 = bitcast %struct.TValue* %1 to i32*
  %11 = bitcast %struct.TValue* %1 to i8**
  %12 = bitcast %struct.TValue* %1 to i32 (%struct.lua_State*)**
  %13 = bitcast %struct.TValue* %1 to %struct.TString**
  br label %14

; <label>:14:                                     ; preds = %76, %2
  %15 = phi %union.Node* [ %3, %2 ], [ %78, %76 ]
  %16 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 2
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = icmp eq i8 %5, %17
  br i1 %18, label %19, label %72

; <label>:19:                                     ; preds = %14
  switch i6 %6, label %61 [
    i6 0, label %70
    i6 -29, label %20
    i6 19, label %27
    i6 1, label %34
    i6 2, label %41
    i6 -26, label %48
    i6 -28, label %55
  ]

; <label>:20:                                     ; preds = %19
  %21 = load i64, i64* %8, align 8, !tbaa !21
  %22 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4
  %23 = bitcast %union.Value* %22 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !21
  %25 = icmp eq i64 %21, %24
  %26 = zext i1 %25 to i32
  br label %67

; <label>:27:                                     ; preds = %19
  %28 = load double, double* %9, align 8, !tbaa !21
  %29 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4
  %30 = bitcast %union.Value* %29 to double*
  %31 = load double, double* %30, align 8, !tbaa !21
  %32 = fcmp oeq double %28, %31
  %33 = zext i1 %32 to i32
  br label %67

; <label>:34:                                     ; preds = %19
  %35 = load i32, i32* %10, align 8, !tbaa !21
  %36 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4
  %37 = bitcast %union.Value* %36 to i32*
  %38 = load i32, i32* %37, align 8, !tbaa !21
  %39 = icmp eq i32 %35, %38
  %40 = zext i1 %39 to i32
  br label %67

; <label>:41:                                     ; preds = %19
  %42 = load i8*, i8** %11, align 8, !tbaa !21
  %43 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4
  %44 = bitcast %union.Value* %43 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !21
  %46 = icmp eq i8* %42, %45
  %47 = zext i1 %46 to i32
  br label %67

; <label>:48:                                     ; preds = %19
  %49 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %12, align 8, !tbaa !21
  %50 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4
  %51 = bitcast %union.Value* %50 to i32 (%struct.lua_State*)**
  %52 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %51, align 8, !tbaa !21
  %53 = icmp eq i32 (%struct.lua_State*)* %49, %52
  %54 = zext i1 %53 to i32
  br label %67

; <label>:55:                                     ; preds = %19
  %56 = load %struct.TString*, %struct.TString** %13, align 8, !tbaa !21
  %57 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4, i32 0
  %58 = bitcast %struct.GCObject** %57 to %struct.TString**
  %59 = load %struct.TString*, %struct.TString** %58, align 8, !tbaa !21
  %60 = tail call fastcc i32 @luaS_eqlngstr(%struct.TString* %56, %struct.TString* %59) #17
  br label %67

; <label>:61:                                     ; preds = %19
  %62 = load %struct.GCObject*, %struct.GCObject** %7, align 8, !tbaa !21
  %63 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 4, i32 0
  %64 = load %struct.GCObject*, %struct.GCObject** %63, align 8, !tbaa !21
  %65 = icmp eq %struct.GCObject* %62, %64
  %66 = zext i1 %65 to i32
  br label %67

; <label>:67:                                     ; preds = %20, %27, %34, %41, %48, %55, %61
  %68 = phi i32 [ %66, %61 ], [ %60, %55 ], [ %54, %48 ], [ %47, %41 ], [ %40, %34 ], [ %33, %27 ], [ %26, %20 ]
  %69 = icmp eq i32 %68, 0
  br i1 %69, label %72, label %70

; <label>:70:                                     ; preds = %19, %67
  %71 = bitcast %union.Node* %15 to %struct.TValue*
  br label %79

; <label>:72:                                     ; preds = %14, %67
  %73 = getelementptr inbounds %union.Node, %union.Node* %15, i64 0, i32 0, i32 3
  %74 = load i32, i32* %73, align 4, !tbaa !21
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %79, label %76

; <label>:76:                                     ; preds = %72
  %77 = sext i32 %74 to i64
  %78 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %77
  br label %14

; <label>:79:                                     ; preds = %72, %70
  %80 = phi %struct.TValue* [ %71, %70 ], [ @absentkey, %72 ]
  ret %struct.TValue* %80
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %union.Node* @mainpositionTV(%struct.Table* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = zext i8 %4 to i32
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0
  %7 = tail call fastcc %union.Node* @mainposition(%struct.Table* %0, i32 %5, %union.Value* %6) #16
  ret %union.Node* %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %union.Node* @mainposition(%struct.Table* nocapture readonly, i32, %union.Value* nocapture readonly) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = trunc i32 %1 to i6
  switch i6 %5, label %136 [
    i6 -29, label %6
    i6 19, label %20
    i6 20, label %49
    i6 -28, label %64
    i6 1, label %93
    i6 2, label %106
    i6 -26, label %121
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %8 = load %union.Node*, %union.Node** %7, align 8, !tbaa !147
  %9 = bitcast %union.Value* %2 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !148
  %13 = zext i8 %12 to i32
  %14 = shl i32 1, %13
  %15 = add nsw i32 %14, -1
  %16 = trunc i64 %10 to i32
  %17 = and i32 %15, %16
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %union.Node, %union.Node* %8, i64 %18
  br label %151

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %22 = load %union.Node*, %union.Node** %21, align 8, !tbaa !147
  %23 = bitcast %union.Value* %2 to double*
  %24 = load double, double* %23, align 8, !tbaa !21
  %25 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %25) #7
  %26 = call double @frexp(double %24, i32* nonnull %4) #17
  %27 = fmul double %26, 0x41E0000000000000
  %28 = fcmp oge double %27, 0xC3E0000000000000
  %29 = fcmp olt double %27, 0x43E0000000000000
  %30 = and i1 %28, %29
  br i1 %30, label %31, label %38

; <label>:31:                                     ; preds = %20
  %32 = fptosi double %27 to i64
  %33 = load i32, i32* %4, align 4, !tbaa !74
  %34 = trunc i64 %32 to i32
  %35 = add i32 %33, %34
  %36 = ashr i32 %35, 31
  %37 = xor i32 %36, %35
  br label %38

; <label>:38:                                     ; preds = %20, %31
  %39 = phi i32 [ %37, %31 ], [ 0, %20 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %25) #7
  %40 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %41 = load i8, i8* %40, align 1, !tbaa !148
  %42 = zext i8 %41 to i32
  %43 = shl i32 1, %42
  %44 = add nsw i32 %43, -1
  %45 = or i32 %44, 1
  %46 = srem i32 %39, %45
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds %union.Node, %union.Node* %22, i64 %47
  br label %151

; <label>:49:                                     ; preds = %3
  %50 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %51 = load %union.Node*, %union.Node** %50, align 8, !tbaa !147
  %52 = bitcast %union.Value* %2 to %struct.TString**
  %53 = load %struct.TString*, %struct.TString** %52, align 8, !tbaa !21
  %54 = getelementptr inbounds %struct.TString, %struct.TString* %53, i64 0, i32 5
  %55 = load i32, i32* %54, align 4, !tbaa !21
  %56 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %57 = load i8, i8* %56, align 1, !tbaa !148
  %58 = zext i8 %57 to i32
  %59 = shl i32 1, %58
  %60 = add nsw i32 %59, -1
  %61 = and i32 %60, %55
  %62 = sext i32 %61 to i64
  %63 = getelementptr inbounds %union.Node, %union.Node* %51, i64 %62
  br label %151

; <label>:64:                                     ; preds = %3
  %65 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %66 = load %union.Node*, %union.Node** %65, align 8, !tbaa !147
  %67 = bitcast %union.Value* %2 to %struct.TString**
  %68 = load %struct.TString*, %struct.TString** %67, align 8, !tbaa !21
  %69 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 3
  %70 = load i8, i8* %69, align 2, !tbaa !86
  %71 = icmp eq i8 %70, 0
  br i1 %71, label %75, label %72

; <label>:72:                                     ; preds = %64
  %73 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 5
  %74 = load i32, i32* %73, align 4, !tbaa !215
  br label %83

; <label>:75:                                     ; preds = %64
  %76 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 1
  %77 = bitcast %struct.TString* %76 to i8*
  %78 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 6, i32 0
  %79 = load i64, i64* %78, align 8, !tbaa !21
  %80 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 5
  %81 = load i32, i32* %80, align 4, !tbaa !215
  %82 = tail call fastcc i32 @luaS_hash(i8* nonnull %77, i64 %79, i32 %81) #17
  store i32 %82, i32* %80, align 4, !tbaa !215
  store i8 1, i8* %69, align 2, !tbaa !86
  br label %83

; <label>:83:                                     ; preds = %72, %75
  %84 = phi i32 [ %74, %72 ], [ %82, %75 ]
  %85 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %86 = load i8, i8* %85, align 1, !tbaa !148
  %87 = zext i8 %86 to i32
  %88 = shl i32 1, %87
  %89 = add nsw i32 %88, -1
  %90 = and i32 %89, %84
  %91 = sext i32 %90 to i64
  %92 = getelementptr inbounds %union.Node, %union.Node* %66, i64 %91
  br label %151

; <label>:93:                                     ; preds = %3
  %94 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %95 = load %union.Node*, %union.Node** %94, align 8, !tbaa !147
  %96 = bitcast %union.Value* %2 to i32*
  %97 = load i32, i32* %96, align 8, !tbaa !21
  %98 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %99 = load i8, i8* %98, align 1, !tbaa !148
  %100 = zext i8 %99 to i32
  %101 = shl i32 1, %100
  %102 = add nsw i32 %101, -1
  %103 = and i32 %102, %97
  %104 = sext i32 %103 to i64
  %105 = getelementptr inbounds %union.Node, %union.Node* %95, i64 %104
  br label %151

; <label>:106:                                    ; preds = %3
  %107 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %108 = load %union.Node*, %union.Node** %107, align 8, !tbaa !147
  %109 = bitcast %union.Value* %2 to i64*
  %110 = load i64, i64* %109, align 8, !tbaa !21
  %111 = trunc i64 %110 to i32
  %112 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %113 = load i8, i8* %112, align 1, !tbaa !148
  %114 = zext i8 %113 to i32
  %115 = shl i32 1, %114
  %116 = add nsw i32 %115, -1
  %117 = or i32 %116, 1
  %118 = urem i32 %111, %117
  %119 = zext i32 %118 to i64
  %120 = getelementptr inbounds %union.Node, %union.Node* %108, i64 %119
  br label %151

; <label>:121:                                    ; preds = %3
  %122 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %123 = load %union.Node*, %union.Node** %122, align 8, !tbaa !147
  %124 = bitcast %union.Value* %2 to i64*
  %125 = load i64, i64* %124, align 8, !tbaa !21
  %126 = trunc i64 %125 to i32
  %127 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %128 = load i8, i8* %127, align 1, !tbaa !148
  %129 = zext i8 %128 to i32
  %130 = shl i32 1, %129
  %131 = add nsw i32 %130, -1
  %132 = or i32 %131, 1
  %133 = urem i32 %126, %132
  %134 = zext i32 %133 to i64
  %135 = getelementptr inbounds %union.Node, %union.Node* %123, i64 %134
  br label %151

; <label>:136:                                    ; preds = %3
  %137 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %138 = load %union.Node*, %union.Node** %137, align 8, !tbaa !147
  %139 = bitcast %union.Value* %2 to i64*
  %140 = load i64, i64* %139, align 8, !tbaa !21
  %141 = trunc i64 %140 to i32
  %142 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %143 = load i8, i8* %142, align 1, !tbaa !148
  %144 = zext i8 %143 to i32
  %145 = shl i32 1, %144
  %146 = add nsw i32 %145, -1
  %147 = or i32 %146, 1
  %148 = urem i32 %141, %147
  %149 = zext i32 %148 to i64
  %150 = getelementptr inbounds %union.Node, %union.Node* %138, i64 %149
  br label %151

; <label>:151:                                    ; preds = %136, %121, %106, %93, %83, %49, %38, %6
  %152 = phi %union.Node* [ %150, %136 ], [ %135, %121 ], [ %120, %106 ], [ %105, %93 ], [ %92, %83 ], [ %63, %49 ], [ %48, %38 ], [ %19, %6 ]
  ret %union.Node* %152
}

; Function Attrs: minsize nounwind optsize
declare double @frexp(double, i32* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @luaS_eqlngstr(%struct.TString* readonly, %struct.TString* readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %4 = load i64, i64* %3, align 8, !tbaa !21
  %5 = icmp eq %struct.TString* %0, %1
  br i1 %5, label %18, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 6, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = icmp eq i64 %4, %8
  br i1 %9, label %10, label %18

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %12 = bitcast %struct.TString* %11 to i8*
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %14 = bitcast %struct.TString* %13 to i8*
  %15 = tail call i32 @memcmp(i8* nonnull %12, i8* nonnull %14, i64 %4) #21
  %16 = icmp eq i32 %15, 0
  %17 = zext i1 %16 to i32
  br label %18

; <label>:18:                                     ; preds = %6, %10, %2
  %19 = phi i32 [ 1, %2 ], [ 0, %6 ], [ %17, %10 ]
  ret i32 %19
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize
declare double @fmod(double, double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @callbinTM(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 %4) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %5
  %12 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %2, i32 %4) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %19, label %17

; <label>:17:                                     ; preds = %5, %11
  %18 = phi %struct.TValue* [ %12, %11 ], [ %6, %5 ]
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %18, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3) #16
  br label %19

; <label>:19:                                     ; preds = %11, %17
  %20 = phi i32 [ 1, %17 ], [ 0, %11 ]
  ret i32 %20
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_concaterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.172, i64 0, i64 0)) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_tointerror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 35
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %3
  %10 = bitcast %struct.TValue* %1 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  store i64 %11, i64* %4, align 8, !tbaa !129
  br label %16

; <label>:12:                                     ; preds = %3
  %13 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %1, i64* nonnull %4, i32 0) #16
  %14 = icmp eq i32 %13, 0
  %15 = select i1 %14, %struct.TValue* %1, %struct.TValue* %2
  br label %16

; <label>:16:                                     ; preds = %12, %9
  %17 = phi %struct.TValue* [ %2, %9 ], [ %15, %12 ]
  %18 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %17) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.175, i64 0, i64 0), i8* %18) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_opinterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i8*) unnamed_addr #5 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 3
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* %3) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaT_callTMres(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !48
  %9 = ptrtoint %union.StackValue* %4 to i64
  %10 = sub i64 %9, %8
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = bitcast %union.StackValue* %12 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0
  %20 = bitcast %struct.TValue* %2 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0
  %27 = bitcast %struct.TValue* %3 to i64*
  %28 = bitcast %struct.TValue* %26 to i64*
  %29 = load i64, i64* %27, align 8
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 3
  store %union.StackValue* %34, %union.StackValue** %11, align 8, !tbaa !20
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %36 = load %struct.CallInfo*, %struct.CallInfo** %35, align 8, !tbaa !49
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %36, i64 0, i32 7
  %38 = load i16, i16* %37, align 2, !tbaa !60
  %39 = and i16 %38, 6
  %40 = icmp eq i16 %39, 0
  br i1 %40, label %41, label %42

; <label>:41:                                     ; preds = %5
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1) #16
  br label %43

; <label>:42:                                     ; preds = %5
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1) #16
  br label %43

; <label>:43:                                     ; preds = %42, %41
  %44 = bitcast %union.StackValue** %6 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !48
  %46 = getelementptr inbounds i8, i8* %45, i64 %10
  %47 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  store %union.StackValue* %48, %union.StackValue** %11, align 8, !tbaa !20
  %49 = bitcast %union.StackValue* %48 to i64*
  %50 = bitcast i8* %46 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1, i32 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  %54 = getelementptr inbounds i8, i8* %46, i64 8
  store i8 %53, i8* %54, align 8, !tbaa !22
  ret void
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_typeerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  %5 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %1) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.173, i64 0, i64 0), i8* %2, i8* %4, i8* %5) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaT_objtypename(%struct.lua_State*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 69
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %1 to %struct.Table**
  %8 = load %struct.Table*, %struct.Table** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 9
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = icmp eq %struct.Table* %10, null
  br i1 %11, label %35, label %21

; <label>:12:                                     ; preds = %2
  %13 = and i8 %4, 15
  %14 = icmp eq i8 %13, 7
  br i1 %14, label %15, label %35

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %1 to %struct.Udata**
  %17 = load %struct.Udata*, %struct.Udata** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.Udata, %struct.Udata* %17, i64 0, i32 5
  %19 = load %struct.Table*, %struct.Table** %18, align 8, !tbaa !21
  %20 = icmp eq %struct.Table* %19, null
  br i1 %20, label %35, label %21

; <label>:21:                                     ; preds = %6, %15
  %22 = phi %struct.Table* [ %10, %6 ], [ %19, %15 ]
  %23 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %24 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %22, %struct.TString* %23) #16
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 4
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %21
  %30 = load i8, i8* %3, align 8, !tbaa !22
  br label %35

; <label>:31:                                     ; preds = %21
  %32 = bitcast %struct.TValue* %24 to i8**
  %33 = load i8*, i8** %32, align 8, !tbaa !21
  %34 = getelementptr inbounds i8, i8* %33, i64 24
  br label %42

; <label>:35:                                     ; preds = %29, %6, %15, %12
  %36 = phi i8 [ %30, %29 ], [ 69, %6 ], [ %4, %15 ], [ %4, %12 ]
  %37 = and i8 %36, 15
  %38 = add nuw nsw i8 %37, 1
  %39 = zext i8 %38 to i64
  %40 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %39
  %41 = load i8*, i8** %40, align 8, !tbaa !39
  br label %42

; <label>:42:                                     ; preds = %31, %35
  %43 = phi i8* [ %41, %35 ], [ %34, %31 ]
  ret i8* %43
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @varinfo(%struct.lua_State*, %struct.TValue*) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  store i8* null, i8** %3, align 8, !tbaa !39
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %8 = load i16, i16* %7, align 2, !tbaa !60
  %9 = and i16 %8, 2
  %10 = icmp eq i16 %9, 0
  br i1 %10, label %11, label %67

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.CallInfo* %6 to %struct.LClosure***
  %13 = load %struct.LClosure**, %struct.LClosure*** %12, align 8, !tbaa !61
  %14 = load %struct.LClosure*, %struct.LClosure** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 3
  %16 = load i8, i8* %15, align 2, !tbaa !177
  %17 = zext i8 %16 to i64
  br label %18

; <label>:18:                                     ; preds = %27, %11
  %19 = phi i64 [ %28, %27 ], [ 0, %11 ]
  %20 = icmp ult i64 %19, %17
  br i1 %20, label %21, label %41

; <label>:21:                                     ; preds = %18
  %22 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 6, i64 %19
  %23 = load %struct.UpVal*, %struct.UpVal** %22, align 8, !tbaa !39
  %24 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %23, i64 0, i32 3
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !64
  %26 = icmp eq %struct.TValue* %25, %1
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %21
  %28 = add nuw nsw i64 %19, 1
  br label %18

; <label>:29:                                     ; preds = %21
  %30 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 5
  %31 = load %struct.Proto*, %struct.Proto** %30, align 8, !tbaa !192
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 18
  %33 = load %struct.Upvaldesc*, %struct.Upvaldesc** %32, align 8, !tbaa !193
  %34 = and i64 %19, 4294967295
  %35 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %33, i64 %34, i32 0
  %36 = load %struct.TString*, %struct.TString** %35, align 8, !tbaa !194
  %37 = icmp eq %struct.TString* %36, null
  %38 = getelementptr inbounds %struct.TString, %struct.TString* %36, i64 1
  %39 = bitcast %struct.TString* %38 to i8*
  %40 = select i1 %37, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %39
  store i8* %40, i8** %3, align 8, !tbaa !39
  br label %63

; <label>:41:                                     ; preds = %18
  %42 = getelementptr inbounds %struct.LClosure*, %struct.LClosure** %13, i64 2
  %43 = ptrtoint %struct.TValue* %1 to i64
  %44 = ptrtoint %struct.LClosure** %42 to i64
  %45 = sub i64 %43, %44
  %46 = icmp sgt i64 %45, -16
  br i1 %46, label %47, label %67

; <label>:47:                                     ; preds = %41
  %48 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 1
  %49 = bitcast %union.StackValue** %48 to i64*
  %50 = load i64, i64* %49, align 8, !tbaa !63
  %51 = sub i64 %50, %44
  %52 = icmp slt i64 %45, %51
  br i1 %52, label %53, label %67

; <label>:53:                                     ; preds = %47
  %54 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 5
  %55 = load %struct.Proto*, %struct.Proto** %54, align 8, !tbaa !21
  %56 = tail call fastcc i32 @currentpc(%struct.CallInfo* nonnull %6) #16
  %57 = lshr exact i64 %45, 4
  %58 = trunc i64 %57 to i32
  %59 = call fastcc i8* @getobjname(%struct.Proto* %55, i32 %56, i32 %58, i8** nonnull %3) #16
  %60 = icmp eq i8* %59, null
  br i1 %60, label %67, label %61

; <label>:61:                                     ; preds = %53
  %62 = load i8*, i8** %3, align 8, !tbaa !39
  br label %63

; <label>:63:                                     ; preds = %61, %29
  %64 = phi i8* [ %40, %29 ], [ %62, %61 ]
  %65 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %29 ], [ %59, %61 ]
  %66 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.174, i64 0, i64 0), i8* nonnull %65, i8* %64) #16
  br label %67

; <label>:67:                                     ; preds = %47, %41, %2, %53, %63
  %68 = phi i8* [ %66, %63 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %53 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %2 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %47 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %41 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %68
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i8* @luaO_pushfstring(%struct.lua_State*, i8*, ...) unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaV_flttointeger(double, i64* nocapture, i32) unnamed_addr #0 {
  %4 = tail call double @llvm.floor.f64(double %0)
  %5 = fcmp une double %4, %0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i32 %2, 0
  br i1 %7, label %19, label %8

; <label>:8:                                      ; preds = %6
  %9 = icmp sgt i32 %2, 1
  %10 = fadd double %4, 1.000000e+00
  %11 = select i1 %9, double %10, double %4
  br label %12

; <label>:12:                                     ; preds = %8, %3
  %13 = phi double [ %4, %3 ], [ %11, %8 ]
  %14 = fcmp oge double %13, 0xC3E0000000000000
  %15 = fcmp olt double %13, 0x43E0000000000000
  %16 = and i1 %14, %15
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %12
  %18 = fptosi double %13 to i64
  store i64 %18, i64* %1, align 8, !tbaa !129
  br label %19

; <label>:19:                                     ; preds = %12, %17, %6
  %20 = phi i32 [ 0, %6 ], [ 0, %12 ], [ 1, %17 ]
  ret i32 %20
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @l_strcmp(%struct.TString* nocapture readonly, %struct.TString* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %4 = bitcast %struct.TString* %3 to i8*
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !72
  %7 = icmp eq i8 %6, 20
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !109
  %11 = zext i8 %10 to i64
  br label %15

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %14 = load i64, i64* %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %8
  %16 = phi i64 [ %11, %8 ], [ %14, %12 ]
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !72
  %21 = icmp eq i8 %20, 20
  br i1 %21, label %22, label %26

; <label>:22:                                     ; preds = %15
  %23 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 4
  %24 = load i8, i8* %23, align 1, !tbaa !109
  %25 = zext i8 %24 to i64
  br label %29

; <label>:26:                                     ; preds = %15
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 6, i32 0
  %28 = load i64, i64* %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %26, %22
  %30 = phi i64 [ %25, %22 ], [ %28, %26 ]
  br label %31

; <label>:31:                                     ; preds = %29, %46
  %32 = phi i8* [ %48, %46 ], [ %4, %29 ]
  %33 = phi i64 [ %49, %46 ], [ %16, %29 ]
  %34 = phi i8* [ %50, %46 ], [ %18, %29 ]
  %35 = phi i64 [ %51, %46 ], [ %30, %29 ]
  %36 = tail call i32 @strcoll(i8* %32, i8* %34) #21
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %38, label %52

; <label>:38:                                     ; preds = %31
  %39 = tail call i64 @strlen(i8* %32) #21
  %40 = icmp eq i64 %39, %35
  %41 = icmp eq i64 %39, %33
  br i1 %40, label %42, label %45

; <label>:42:                                     ; preds = %38
  %43 = xor i1 %41, true
  %44 = zext i1 %43 to i32
  br label %52

; <label>:45:                                     ; preds = %38
  br i1 %41, label %52, label %46

; <label>:46:                                     ; preds = %45
  %47 = add i64 %39, 1
  %48 = getelementptr inbounds i8, i8* %32, i64 %47
  %49 = sub i64 %33, %47
  %50 = getelementptr inbounds i8, i8* %34, i64 %47
  %51 = sub i64 %35, %47
  br label %31

; <label>:52:                                     ; preds = %45, %31, %42
  %53 = phi i32 [ %44, %42 ], [ -1, %45 ], [ %36, %31 ]
  ret i32 %53
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaT_callorderTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %6, i32 %3) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %25, label %9

; <label>:9:                                      ; preds = %4
  %10 = bitcast %union.StackValue** %5 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %23, label %16

; <label>:16:                                     ; preds = %9
  %17 = icmp eq i8 %13, 1
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %16
  %19 = bitcast %struct.TValue* %11 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = icmp ne i32 %20, 0
  %22 = zext i1 %21 to i32
  br label %23

; <label>:23:                                     ; preds = %16, %18, %9
  %24 = phi i32 [ 0, %9 ], [ 1, %16 ], [ %22, %18 ]
  ret i32 %24

; <label>:25:                                     ; preds = %4
  tail call fastcc void @luaG_ordererror(%struct.lua_State* nonnull %0, %struct.TValue* %1, %struct.TValue* %2) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @strcoll(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaG_ordererror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  %5 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %2) #16
  %6 = tail call i32 @strcmp(i8* %4, i8* %5) #21
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.176, i64 0, i64 0), i8* %4) #18
  unreachable

; <label>:9:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.177, i64 0, i64 0), i8* %4, i8* %5) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 3
  %4 = add nsw i32 %3, 32
  %5 = sext i32 %4 to i64
  %6 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 22, i64 %5) #16
  %7 = bitcast %struct.GCObject* %6 to %struct.LClosure*
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %9 = bitcast i8* %8 to %struct.Proto**
  store %struct.Proto* null, %struct.Proto** %9, align 8, !tbaa !192
  %10 = trunc i32 %1 to i8
  %11 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 3
  store i8 %10, i8* %11, align 2, !tbaa !177
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 2
  %13 = bitcast %struct.GCObject* %12 to [1 x %struct.UpVal*]*
  %14 = sext i32 %1 to i64
  br label %15

; <label>:15:                                     ; preds = %20, %2
  %16 = phi i64 [ %17, %20 ], [ %14, %2 ]
  %17 = add nsw i64 %16, -1
  %18 = trunc i64 %16 to i32
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %22, label %20

; <label>:20:                                     ; preds = %15
  %21 = getelementptr inbounds [1 x %struct.UpVal*], [1 x %struct.UpVal*]* %13, i64 0, i64 %17
  store %struct.UpVal* null, %struct.UpVal** %21, align 8, !tbaa !39
  br label %15

; <label>:22:                                     ; preds = %15
  ret %struct.LClosure* %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %5

; <label>:5:                                      ; preds = %25, %2
  %6 = phi %struct.UpVal** [ %3, %2 ], [ %26, %25 ]
  %7 = load %struct.UpVal*, %struct.UpVal** %6, align 8, !tbaa !39
  %8 = icmp eq %struct.UpVal* %7, null
  br i1 %8, label %27, label %9

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %7, i64 0, i32 3
  %11 = bitcast %struct.TValue** %10 to %union.StackValue**
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !64
  %13 = icmp ult %union.StackValue* %12, %1
  br i1 %13, label %27, label %14

; <label>:14:                                     ; preds = %9
  %15 = icmp eq %union.StackValue* %12, %1
  br i1 %15, label %16, label %25

; <label>:16:                                     ; preds = %14
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %7, i64 0, i32 2
  %18 = load i8, i8* %17, align 1, !tbaa !66
  %19 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %19, i64 0, i32 10
  %21 = load i8, i8* %20, align 4, !tbaa !15
  %22 = xor i8 %21, 24
  %23 = and i8 %22, %18
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %29, label %25

; <label>:25:                                     ; preds = %16, %14
  %26 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %7, i64 0, i32 4, i32 0, i32 0
  br label %5

; <label>:27:                                     ; preds = %9, %5
  %28 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 9, %union.StackValue* %1, %struct.UpVal** nonnull %6) #16
  br label %29

; <label>:29:                                     ; preds = %16, %27
  %30 = phi %struct.UpVal* [ %28, %27 ], [ %7, %16 ]
  ret %struct.UpVal* %30
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State*, i32, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = and i32 %1, 15
  %7 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %2, i32 %6) #16
  %8 = bitcast i8* %7 to %struct.GCObject*
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %10 = load i8, i8* %9, align 4, !tbaa !15
  %11 = and i8 %10, 24
  %12 = getelementptr inbounds i8, i8* %7, i64 9
  store i8 %11, i8* %12, align 1, !tbaa !67
  %13 = trunc i32 %1 to i8
  %14 = getelementptr inbounds i8, i8* %7, i64 8
  store i8 %13, i8* %14, align 8, !tbaa !217
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  %16 = bitcast %struct.GCObject** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !18
  %18 = bitcast i8* %7 to i64*
  store i64 %17, i64* %18, align 8, !tbaa !152
  %19 = bitcast %struct.GCObject** %15 to i8**
  store i8* %7, i8** %19, align 8, !tbaa !18
  ret %struct.GCObject* %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.UpVal* @newupval(%struct.lua_State*, i32, %union.StackValue*, %struct.UpVal**) unnamed_addr #0 {
  %5 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 %1, i64 40) #16
  %6 = bitcast %struct.GCObject* %5 to %struct.UpVal*
  %7 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !39
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1
  %10 = bitcast %struct.GCObject* %9 to %struct.TValue**
  store %struct.TValue* %8, %struct.TValue** %10, align 8, !tbaa !64
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1, i32 1
  %12 = bitcast i8* %11 to %struct.UpVal**
  store %struct.UpVal* %7, %struct.UpVal** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds i8, i8* %11, i64 8
  %14 = bitcast i8* %13 to %struct.UpVal***
  store %struct.UpVal** %3, %struct.UpVal*** %14, align 8, !tbaa !21
  %15 = icmp eq %struct.UpVal* %7, null
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %7, i64 0, i32 4, i32 0, i32 1
  %18 = bitcast %struct.UpVal*** %17 to i8**
  store i8* %11, i8** %18, align 8, !tbaa !21
  br label %19

; <label>:19:                                     ; preds = %4, %16
  %20 = bitcast %struct.UpVal** %3 to %struct.GCObject**
  store %struct.GCObject* %5, %struct.GCObject** %20, align 8, !tbaa !39
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 14
  %22 = load %struct.lua_State*, %struct.lua_State** %21, align 8, !tbaa !52
  %23 = icmp eq %struct.lua_State* %22, %0
  br i1 %23, label %24, label %31

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 36
  %28 = bitcast %struct.lua_State** %27 to i64*
  %29 = load i64, i64* %28, align 8, !tbaa !234
  %30 = bitcast %struct.lua_State** %21 to i64*
  store i64 %29, i64* %30, align 8, !tbaa !52
  store %struct.lua_State* %0, %struct.lua_State** %27, align 8, !tbaa !234
  br label %31

; <label>:31:                                     ; preds = %19, %24
  ret %struct.UpVal* %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @finishCcall(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !49
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %6 = load i16, i16* %5, align 2, !tbaa !60
  %7 = and i16 %6, 8
  %8 = icmp eq i16 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %2
  %10 = and i16 %6, -9
  store i16 %10, i16* %5, align 2, !tbaa !60
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 %12, i64* %13, align 8, !tbaa !58
  br label %14

; <label>:14:                                     ; preds = %2, %9
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 6
  %16 = load i16, i16* %15, align 4, !tbaa !62
  %17 = icmp slt i16 %16, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %14
  %19 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !63
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %23 = icmp ult %union.StackValue* %20, %22
  br i1 %23, label %24, label %25

; <label>:24:                                     ; preds = %18
  store %union.StackValue* %22, %union.StackValue** %19, align 8, !tbaa !63
  br label %25

; <label>:25:                                     ; preds = %24, %18, %14
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 0
  %27 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %27(%struct.lua_State* nonnull %0, i32 %1, i64 %29) #17
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %4, i32 %30) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaG_addinfo(%struct.lua_State*, i8*, %struct.TString*, i32) unnamed_addr #0 {
  %5 = alloca [60 x i8], align 16
  %6 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 60, i8* nonnull %6) #7
  %7 = icmp eq %struct.TString* %2, null
  br i1 %7, label %23, label %8

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 1
  %10 = bitcast %struct.TString* %9 to i8*
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !72
  %13 = icmp eq i8 %12, 20
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %8
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 4
  %16 = load i8, i8* %15, align 1, !tbaa !109
  %17 = zext i8 %16 to i64
  br label %21

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 6, i32 0
  %20 = load i64, i64* %19, align 8, !tbaa !21
  br label %21

; <label>:21:                                     ; preds = %18, %14
  %22 = phi i64 [ %17, %14 ], [ %20, %18 ]
  call fastcc void @luaO_chunkid(i8* nonnull %6, i8* nonnull %10, i64 %22) #16
  br label %25

; <label>:23:                                     ; preds = %4
  store i8 63, i8* %6, align 16, !tbaa !21
  %24 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 1
  store i8 0, i8* %24, align 1, !tbaa !21
  br label %25

; <label>:25:                                     ; preds = %23, %21
  %26 = call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.180, i64 0, i64 0), i8* nonnull %6, i32 %3, i8* %1) #16
  call void @llvm.lifetime.end.p0i8(i64 60, i8* nonnull %6) #7
  ret i8* %26
}

; Function Attrs: minsize noreturn nounwind optsize
declare void @longjmp(%struct.__jmp_buf_tag*, i32) local_unnamed_addr #15

; Function Attrs: minsize noreturn nounwind optsize
declare void @abort() local_unnamed_addr #15

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaO_rawarith(%struct.lua_State*, i32, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture) unnamed_addr #0 {
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  switch i32 %1, label %66 [
    i32 7, label %8
    i32 8, label %8
    i32 9, label %8
    i32 10, label %8
    i32 11, label %8
    i32 13, label %8
    i32 5, label %40
    i32 4, label %40
  ]

; <label>:8:                                      ; preds = %5, %5, %5, %5, %5, %5
  %9 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = bitcast i64* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = icmp eq i8 %12, 35
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %8
  %15 = bitcast %struct.TValue* %2 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !21
  store i64 %16, i64* %6, align 8, !tbaa !129
  br label %20

; <label>:17:                                     ; preds = %8
  %18 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2, i64* nonnull %6, i32 0) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %38, label %20

; <label>:20:                                     ; preds = %17, %14
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = icmp eq i8 %22, 35
  br i1 %23, label %24, label %27

; <label>:24:                                     ; preds = %20
  %25 = bitcast %struct.TValue* %3 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !21
  store i64 %26, i64* %7, align 8, !tbaa !129
  br label %32

; <label>:27:                                     ; preds = %20
  %28 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %3, i64* nonnull %7, i32 0) #16
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %38, label %30

; <label>:30:                                     ; preds = %27
  %31 = load i64, i64* %7, align 8, !tbaa !129
  br label %32

; <label>:32:                                     ; preds = %30, %24
  %33 = phi i64 [ %31, %30 ], [ %26, %24 ]
  %34 = load i64, i64* %6, align 8, !tbaa !129
  %35 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %34, i64 %33) #16
  %36 = bitcast %struct.TValue* %4 to i64*
  store i64 %35, i64* %36, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %37, align 8, !tbaa !22
  br label %38

; <label>:38:                                     ; preds = %17, %27, %32
  %39 = phi i32 [ 1, %32 ], [ 0, %27 ], [ 0, %17 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  br label %103

; <label>:40:                                     ; preds = %5, %5
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %42 = load i8, i8* %41, align 8, !tbaa !22
  switch i8 %42, label %103 [
    i8 19, label %43
    i8 35, label %46
  ]

; <label>:43:                                     ; preds = %40
  %44 = bitcast %struct.TValue* %2 to double*
  %45 = load double, double* %44, align 8, !tbaa !21
  br label %50

; <label>:46:                                     ; preds = %40
  %47 = bitcast %struct.TValue* %2 to i64*
  %48 = load i64, i64* %47, align 8, !tbaa !21
  %49 = sitofp i64 %48 to double
  br label %50

; <label>:50:                                     ; preds = %43, %46
  %51 = phi double [ %45, %43 ], [ %49, %46 ]
  %52 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  switch i8 %53, label %103 [
    i8 19, label %54
    i8 35, label %57
  ]

; <label>:54:                                     ; preds = %50
  %55 = bitcast %struct.TValue* %3 to double*
  %56 = load double, double* %55, align 8, !tbaa !21
  br label %61

; <label>:57:                                     ; preds = %50
  %58 = bitcast %struct.TValue* %3 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !21
  %60 = sitofp i64 %59 to double
  br label %61

; <label>:61:                                     ; preds = %54, %57
  %62 = phi double [ %56, %54 ], [ %60, %57 ]
  %63 = tail call fastcc double @numarith(i32 %1, double %51, double %62) #16
  %64 = bitcast %struct.TValue* %4 to double*
  store double %63, double* %64, align 8, !tbaa !21
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %65, align 8, !tbaa !22
  br label %103

; <label>:66:                                     ; preds = %5
  %67 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %68 = load i8, i8* %67, align 8, !tbaa !22
  switch i8 %68, label %103 [
    i8 35, label %69
    i8 19, label %81
  ]

; <label>:69:                                     ; preds = %66
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  %72 = icmp eq i8 %71, 35
  %73 = bitcast %struct.TValue* %2 to i64*
  %74 = load i64, i64* %73, align 8, !tbaa !21
  br i1 %72, label %75, label %86

; <label>:75:                                     ; preds = %69
  %76 = bitcast %struct.TValue* %3 to i64*
  %77 = load i64, i64* %76, align 8, !tbaa !21
  %78 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %74, i64 %77) #16
  %79 = bitcast %struct.TValue* %4 to i64*
  store i64 %78, i64* %79, align 8, !tbaa !21
  %80 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %80, align 8, !tbaa !22
  br label %103

; <label>:81:                                     ; preds = %66
  %82 = bitcast %struct.TValue* %2 to double*
  %83 = load double, double* %82, align 8, !tbaa !21
  %84 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %85 = load i8, i8* %84, align 8, !tbaa !22
  br label %88

; <label>:86:                                     ; preds = %69
  %87 = sitofp i64 %74 to double
  br label %88

; <label>:88:                                     ; preds = %81, %86
  %89 = phi i8 [ %85, %81 ], [ %71, %86 ]
  %90 = phi double [ %83, %81 ], [ %87, %86 ]
  switch i8 %89, label %103 [
    i8 19, label %91
    i8 35, label %94
  ]

; <label>:91:                                     ; preds = %88
  %92 = bitcast %struct.TValue* %3 to double*
  %93 = load double, double* %92, align 8, !tbaa !21
  br label %98

; <label>:94:                                     ; preds = %88
  %95 = bitcast %struct.TValue* %3 to i64*
  %96 = load i64, i64* %95, align 8, !tbaa !21
  %97 = sitofp i64 %96 to double
  br label %98

; <label>:98:                                     ; preds = %91, %94
  %99 = phi double [ %93, %91 ], [ %97, %94 ]
  %100 = tail call fastcc double @numarith(i32 %1, double %90, double %99) #16
  %101 = bitcast %struct.TValue* %4 to double*
  store double %100, double* %101, align 8, !tbaa !21
  %102 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %102, align 8, !tbaa !22
  br label %103

; <label>:103:                                    ; preds = %66, %75, %98, %88, %61, %50, %40, %38
  %104 = phi i32 [ %39, %38 ], [ 1, %61 ], [ 0, %50 ], [ 0, %40 ], [ 1, %75 ], [ 1, %98 ], [ 0, %88 ], [ 0, %66 ]
  ret i32 %104
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @intarith(%struct.lua_State*, i32, i64, i64) unnamed_addr #0 {
  switch i32 %1, label %30 [
    i32 0, label %5
    i32 1, label %7
    i32 2, label %9
    i32 3, label %11
    i32 6, label %13
    i32 7, label %15
    i32 8, label %17
    i32 9, label %19
    i32 10, label %21
    i32 11, label %23
    i32 12, label %26
    i32 13, label %28
  ]

; <label>:5:                                      ; preds = %4
  %6 = add i64 %3, %2
  br label %30

; <label>:7:                                      ; preds = %4
  %8 = sub i64 %2, %3
  br label %30

; <label>:9:                                      ; preds = %4
  %10 = mul i64 %3, %2
  br label %30

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %2, i64 %3) #16
  br label %30

; <label>:13:                                     ; preds = %4
  %14 = tail call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %2, i64 %3) #16
  br label %30

; <label>:15:                                     ; preds = %4
  %16 = and i64 %3, %2
  br label %30

; <label>:17:                                     ; preds = %4
  %18 = or i64 %3, %2
  br label %30

; <label>:19:                                     ; preds = %4
  %20 = xor i64 %3, %2
  br label %30

; <label>:21:                                     ; preds = %4
  %22 = tail call fastcc i64 @luaV_shiftl(i64 %2, i64 %3) #16
  br label %30

; <label>:23:                                     ; preds = %4
  %24 = sub nsw i64 0, %3
  %25 = tail call fastcc i64 @luaV_shiftl(i64 %2, i64 %24) #16
  br label %30

; <label>:26:                                     ; preds = %4
  %27 = sub i64 0, %2
  br label %30

; <label>:28:                                     ; preds = %4
  %29 = xor i64 %2, -1
  br label %30

; <label>:30:                                     ; preds = %4, %28, %26, %23, %21, %19, %17, %15, %13, %11, %9, %7, %5
  %31 = phi i64 [ %29, %28 ], [ %27, %26 ], [ %25, %23 ], [ %22, %21 ], [ %20, %19 ], [ %18, %17 ], [ %16, %15 ], [ %14, %13 ], [ %12, %11 ], [ %10, %9 ], [ %8, %7 ], [ %6, %5 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc double @numarith(i32, double, double) unnamed_addr #0 {
  switch i32 %0, label %21 [
    i32 0, label %4
    i32 1, label %6
    i32 2, label %8
    i32 5, label %10
    i32 4, label %12
    i32 6, label %14
    i32 12, label %17
    i32 3, label %19
  ]

; <label>:4:                                      ; preds = %3
  %5 = fadd double %1, %2
  br label %21

; <label>:6:                                      ; preds = %3
  %7 = fsub double %1, %2
  br label %21

; <label>:8:                                      ; preds = %3
  %9 = fmul double %1, %2
  br label %21

; <label>:10:                                     ; preds = %3
  %11 = fdiv double %1, %2
  br label %21

; <label>:12:                                     ; preds = %3
  %13 = tail call double @pow(double %1, double %2) #17
  br label %21

; <label>:14:                                     ; preds = %3
  %15 = fdiv double %1, %2
  %16 = tail call double @llvm.floor.f64(double %15)
  br label %21

; <label>:17:                                     ; preds = %3
  %18 = fsub double -0.000000e+00, %1
  br label %21

; <label>:19:                                     ; preds = %3
  %20 = tail call fastcc double @luaV_modf(double %1, double %2) #16
  br label %21

; <label>:21:                                     ; preds = %3, %19, %17, %14, %12, %10, %8, %6, %4
  %22 = phi double [ %20, %19 ], [ %18, %17 ], [ %16, %14 ], [ %13, %12 ], [ %11, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ 0.000000e+00, %3 ]
  ret double %22
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define internal fastcc i32 @luaO_hexavalue(i32) unnamed_addr #6 {
  %2 = add nsw i32 %0, 1
  %3 = sext i32 %2 to i64
  %4 = add nsw i64 %3, -49
  %5 = icmp ult i64 %4, 10
  %6 = add nsw i32 %0, -48
  %7 = or i32 %0, 32
  %8 = add nsw i32 %7, -87
  %9 = select i1 %5, i32 %6, i32 %8
  ret i32 %9
}

; Function Attrs: minsize nounwind optsize readonly
declare i8* @strpbrk(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @l_str2dloc(i8*, double* nocapture) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call double @strtod(i8* %0, i8** nonnull %3) #17
  store double %5, double* %1, align 8, !tbaa !127
  %6 = load i8*, i8** %3, align 8, !tbaa !39
  %7 = icmp eq i8* %6, %0
  br i1 %7, label %22, label %8

; <label>:8:                                      ; preds = %2
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i8* [ %18, %9 ], [ %6, %8 ]
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = zext i8 %11 to i64
  %13 = add nuw nsw i64 %12, 1
  %14 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %13
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = and i8 %15, 8
  %17 = icmp eq i8 %16, 0
  %18 = getelementptr inbounds i8, i8* %10, i64 1
  br i1 %17, label %19, label %9

; <label>:19:                                     ; preds = %9
  store i8* %10, i8** %3, align 8, !tbaa !39
  %20 = icmp eq i8 %11, 0
  %21 = select i1 %20, i8* %10, i8* null
  br label %22

; <label>:22:                                     ; preds = %2, %19
  %23 = phi i8* [ %21, %19 ], [ null, %2 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %23
}

; Function Attrs: minsize nounwind optsize
declare i8* @strcpy(i8*, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare %struct.lconv* @localeconv() local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @strtod(i8* readonly, i8** nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @tostringbuff(%struct.TValue* nocapture readonly, i8* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %11

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %8) #17
  %10 = sext i32 %9 to i64
  br label %29

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %0 to double*
  %13 = load double, double* %12, align 8, !tbaa !21
  %14 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %13) #17
  %15 = sext i32 %14 to i64
  %16 = tail call i64 @strspn(i8* %1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.191, i64 0, i64 0)) #21
  %17 = getelementptr inbounds i8, i8* %1, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %29

; <label>:20:                                     ; preds = %11
  %21 = tail call %struct.lconv* @localeconv() #17
  %22 = getelementptr inbounds %struct.lconv, %struct.lconv* %21, i64 0, i32 0
  %23 = load i8*, i8** %22, align 8, !tbaa !133
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = add nsw i64 %15, 1
  %26 = getelementptr inbounds i8, i8* %1, i64 %15
  store i8 %24, i8* %26, align 1, !tbaa !21
  %27 = add nsw i64 %15, 2
  %28 = getelementptr inbounds i8, i8* %1, i64 %25
  store i8 48, i8* %28, align 1, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %11, %20, %6
  %30 = phi i64 [ %10, %6 ], [ %27, %20 ], [ %15, %11 ]
  ret i64 %30
}

; Function Attrs: minsize nounwind optsize
declare i32 @snprintf(i8* nocapture, i64, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize readonly
declare i64 @strspn(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @binsearch(%struct.TValue* nocapture readonly, i32, i32) unnamed_addr #3 {
  br label %4

; <label>:4:                                      ; preds = %9, %3
  %5 = phi i32 [ %2, %3 ], [ %18, %9 ]
  %6 = phi i32 [ %1, %3 ], [ %19, %9 ]
  %7 = sub i32 %5, %6
  %8 = icmp ugt i32 %7, 1
  br i1 %8, label %9, label %20

; <label>:9:                                      ; preds = %4
  %10 = add i32 %6, %5
  %11 = lshr i32 %10, 1
  %12 = add nsw i32 %11, -1
  %13 = zext i32 %12 to i64
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 %13, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  %18 = select i1 %17, i32 %11, i32 %5
  %19 = select i1 %17, i32 %6, i32 %11
  br label %4

; <label>:20:                                     ; preds = %4
  ret i32 %6
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaM_toobig(%struct.lua_State*) unnamed_addr #5 {
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.192, i64 0, i64 0)) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State*, i64) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 9
  %6 = load i32, i32* %5, align 8, !tbaa !75
  %7 = tail call fastcc %struct.TString* @createstrobj(%struct.lua_State* %0, i64 %1, i32 36, i32 %6) #16
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 6, i32 0
  store i64 %1, i64* %8, align 8, !tbaa !21
  ret %struct.TString* %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @createstrobj(%struct.lua_State*, i64, i32, i32) unnamed_addr #0 {
  %5 = add i64 %1, 25
  %6 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 %2, i64 %5) #16
  %7 = bitcast %struct.GCObject* %6 to %struct.TString*
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 5
  store i32 %3, i32* %8, align 4, !tbaa !215
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 3
  store i8 0, i8* %9, align 2, !tbaa !86
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %11 = getelementptr inbounds i8, i8* %10, i64 %1
  store i8 0, i8* %11, align 1, !tbaa !21
  ret %struct.TString* %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @addstr2buff(%struct.BuffFS*, i8*, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 401
  br i1 %4, label %5, label %11

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i8* @getbuff(%struct.BuffFS* %0, i64 %2) #16
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %6, i8* %1, i64 %2, i32 1, i1 false)
  %7 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %8 = load i32, i32* %7, align 4, !tbaa !142
  %9 = trunc i64 %2 to i32
  %10 = add i32 %8, %9
  store i32 %10, i32* %7, align 4, !tbaa !142
  br label %12

; <label>:11:                                     ; preds = %3
  tail call fastcc void @clearbuff(%struct.BuffFS* %0) #16
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* %1, i64 %2) #16
  br label %12

; <label>:12:                                     ; preds = %11, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @addnum2buff(%struct.BuffFS*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = tail call fastcc i8* @getbuff(%struct.BuffFS* %0, i64 50) #16
  %4 = tail call fastcc i64 @tostringbuff(%struct.TValue* %1, i8* nonnull %3) #16
  %5 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %6 = load i32, i32* %5, align 4, !tbaa !142
  %7 = trunc i64 %4 to i32
  %8 = add i32 %6, %7
  store i32 %8, i32* %5, align 4, !tbaa !142
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc nonnull i8* @getbuff(%struct.BuffFS*, i64) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !142
  %5 = sext i32 %4 to i64
  %6 = sub nsw i64 400, %5
  %7 = icmp ult i64 %6, %1
  br i1 %7, label %8, label %11

; <label>:8:                                      ; preds = %2
  tail call fastcc void @clearbuff(%struct.BuffFS* nonnull %0) #16
  %9 = load i32, i32* %3, align 4, !tbaa !142
  %10 = sext i32 %9 to i64
  br label %11

; <label>:11:                                     ; preds = %8, %2
  %12 = phi i64 [ %10, %8 ], [ %5, %2 ]
  %13 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 %12
  ret i8* %13
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @luaO_utf8esc(i8* nocapture, i64) unnamed_addr #2 {
  %3 = icmp ult i64 %1, 128
  br i1 %3, label %28, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i64 [ %12, %5 ], [ 1, %4 ]
  %7 = phi i64 [ %15, %5 ], [ %1, %4 ]
  %8 = phi i32 [ %16, %5 ], [ 63, %4 ]
  %9 = trunc i64 %7 to i8
  %10 = and i8 %9, 63
  %11 = or i8 %10, -128
  %12 = add nuw i64 %6, 1
  %13 = sub nsw i64 8, %6
  %14 = getelementptr inbounds i8, i8* %0, i64 %13
  store i8 %11, i8* %14, align 1, !tbaa !21
  %15 = lshr i64 %7, 6
  %16 = lshr i32 %8, 1
  %17 = zext i32 %16 to i64
  %18 = icmp ugt i64 %15, %17
  br i1 %18, label %5, label %19

; <label>:19:                                     ; preds = %5
  %20 = trunc i64 %12 to i32
  %21 = and i32 %8, 254
  %22 = xor i32 %21, 254
  %23 = zext i32 %22 to i64
  %24 = or i64 %15, %23
  %25 = shl i64 %6, 32
  %26 = sub i64 30064771072, %25
  %27 = ashr exact i64 %26, 32
  br label %28

; <label>:28:                                     ; preds = %2, %19
  %29 = phi i64 [ %27, %19 ], [ 7, %2 ]
  %30 = phi i64 [ %24, %19 ], [ %1, %2 ]
  %31 = phi i32 [ %20, %19 ], [ 1, %2 ]
  %32 = trunc i64 %30 to i8
  %33 = getelementptr inbounds i8, i8* %0, i64 %29
  store i8 %32, i8* %33, align 1, !tbaa !21
  ret i32 %31
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @clearbuff(%struct.BuffFS*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 0
  %3 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !142
  %5 = sext i32 %4 to i64
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* nonnull %2, i64 %5) #16
  store i32 0, i32* %3, align 4, !tbaa !142
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @pushstr(%struct.BuffFS* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !145
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2) #16
  %10 = bitcast %struct.TValue* %8 to %struct.TString**
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !72
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %6, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 1
  %18 = load i32, i32* %17, align 8, !tbaa !144
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* %17, align 8, !tbaa !144
  %20 = icmp sgt i32 %18, 0
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %3
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 3
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 10
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !59
  %25 = icmp ugt %union.StackValue* %22, %24
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %21
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %5, i32 %19) #16
  store i32 1, i32* %17, align 8, !tbaa !144
  br label %27

; <label>:27:                                     ; preds = %26, %21, %3
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @setlimittosize(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = tail call fastcc i32 @luaH_realasize(%struct.Table* %0) #16
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  store i32 %2, i32* %3, align 4, !tbaa !136
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %5 = load i8, i8* %4, align 1, !tbaa !138
  %6 = and i8 %5, 127
  store i8 %6, i8* %4, align 1, !tbaa !138
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_newkey(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = alloca [32 x i32], align 16
  %5 = alloca %struct.TValue, align 8
  %6 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %12, !prof !47

; <label>:11:                                     ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.201, i64 0, i64 0)) #18
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = icmp eq i8 %8, 19
  br i1 %13, label %14, label %30

; <label>:14:                                     ; preds = %12
  %15 = bitcast %struct.TValue* %2 to double*
  %16 = load double, double* %15, align 8, !tbaa !21
  %17 = tail call double @llvm.floor.f64(double %16) #7
  %18 = fcmp une double %17, %16
  br i1 %18, label %27, label %19

; <label>:19:                                     ; preds = %14
  %20 = fcmp oge double %17, 0xC3E0000000000000
  %21 = fcmp olt double %17, 0x43E0000000000000
  %22 = and i1 %20, %21
  br i1 %22, label %23, label %27

; <label>:23:                                     ; preds = %19
  %24 = fptosi double %17 to i64
  %25 = bitcast %struct.TValue* %5 to i64*
  store i64 %24, i64* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %26, align 8, !tbaa !22
  br label %30

; <label>:27:                                     ; preds = %19, %14
  %28 = fcmp uno double %16, 0.000000e+00
  br i1 %28, label %29, label %30, !prof !47

; <label>:29:                                     ; preds = %27
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.202, i64 0, i64 0)) #18
  unreachable

; <label>:30:                                     ; preds = %23, %27, %12
  %31 = phi %struct.TValue* [ %2, %12 ], [ %5, %23 ], [ %2, %27 ]
  %32 = call fastcc %union.Node* @mainpositionTV(%struct.Table* %1, %struct.TValue* nonnull %31) #16
  %33 = getelementptr inbounds %union.Node, %union.Node* %32, i64 0, i32 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !21
  %35 = and i8 %34, 15
  %36 = icmp eq i8 %35, 0
  %37 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %38 = load %union.Node*, %union.Node** %37, align 8, !tbaa !139
  %39 = icmp eq %union.Node* %38, null
  br i1 %36, label %40, label %41

; <label>:40:                                     ; preds = %30
  br i1 %39, label %53, label %229

; <label>:41:                                     ; preds = %30
  br i1 %39, label %53, label %42

; <label>:42:                                     ; preds = %41
  %43 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %44 = load %union.Node*, %union.Node** %43, align 8, !tbaa !147
  br label %45

; <label>:45:                                     ; preds = %48, %42
  %46 = phi %union.Node* [ %49, %48 ], [ %38, %42 ]
  %47 = icmp ugt %union.Node* %46, %44
  br i1 %47, label %48, label %53

; <label>:48:                                     ; preds = %45
  %49 = getelementptr inbounds %union.Node, %union.Node* %46, i64 -1
  store %union.Node* %49, %union.Node** %37, align 8, !tbaa !139
  %50 = getelementptr inbounds %union.Node, %union.Node* %46, i64 -1, i32 0, i32 2
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = icmp eq i8 %51, 0
  br i1 %52, label %167, label %45

; <label>:53:                                     ; preds = %45, %40, %41
  %54 = bitcast [32 x i32]* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* nonnull %54) #7
  br label %55

; <label>:55:                                     ; preds = %58, %53
  %56 = phi i64 [ %60, %58 ], [ 0, %53 ]
  %57 = icmp eq i64 %56, 32
  br i1 %57, label %61, label %58

; <label>:58:                                     ; preds = %55
  %59 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 %56
  store i32 0, i32* %59, align 4, !tbaa !74
  %60 = add nuw nsw i64 %56, 1
  br label %55

; <label>:61:                                     ; preds = %55
  %62 = tail call fastcc i32 @setlimittosize(%struct.Table* %1) #17
  %63 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 0
  %64 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  %65 = load i32, i32* %64, align 4, !tbaa !136
  %66 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  br label %67

; <label>:67:                                     ; preds = %94, %61
  %68 = phi i64 [ %99, %94 ], [ 0, %61 ]
  %69 = phi i32 [ %100, %94 ], [ 1, %61 ]
  %70 = phi i32 [ %98, %94 ], [ 0, %61 ]
  %71 = phi i32 [ %80, %94 ], [ 1, %61 ]
  %72 = icmp ult i64 %68, 32
  br i1 %72, label %73, label %101

; <label>:73:                                     ; preds = %67
  %74 = icmp ugt i32 %69, %65
  br i1 %74, label %75, label %77

; <label>:75:                                     ; preds = %73
  %76 = icmp ugt i32 %71, %65
  br i1 %76, label %101, label %77

; <label>:77:                                     ; preds = %75, %73
  %78 = phi i32 [ %65, %75 ], [ %69, %73 ]
  br label %79

; <label>:79:                                     ; preds = %83, %77
  %80 = phi i32 [ %71, %77 ], [ %93, %83 ]
  %81 = phi i32 [ 0, %77 ], [ %92, %83 ]
  %82 = icmp ugt i32 %80, %78
  br i1 %82, label %94, label %83

; <label>:83:                                     ; preds = %79
  %84 = load %struct.TValue*, %struct.TValue** %66, align 8, !tbaa !137
  %85 = add i32 %80, -1
  %86 = zext i32 %85 to i64
  %87 = getelementptr inbounds %struct.TValue, %struct.TValue* %84, i64 %86, i32 1
  %88 = load i8, i8* %87, align 8, !tbaa !22
  %89 = and i8 %88, 15
  %90 = icmp ne i8 %89, 0
  %91 = zext i1 %90 to i32
  %92 = add i32 %81, %91
  %93 = add i32 %80, 1
  br label %79

; <label>:94:                                     ; preds = %79
  %95 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 %68
  %96 = load i32, i32* %95, align 4, !tbaa !74
  %97 = add i32 %96, %81
  store i32 %97, i32* %95, align 4, !tbaa !74
  %98 = add i32 %81, %70
  %99 = add nuw nsw i64 %68, 1
  %100 = shl i32 %69, 1
  br label %67

; <label>:101:                                    ; preds = %75, %67
  %102 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %103 = load i8, i8* %102, align 1, !tbaa !148
  %104 = zext i8 %103 to i32
  %105 = shl i32 1, %104
  %106 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %107 = sext i32 %105 to i64
  br label %108

; <label>:108:                                    ; preds = %133, %101
  %109 = phi i64 [ %114, %133 ], [ %107, %101 ]
  %110 = phi i32 [ %134, %133 ], [ 0, %101 ]
  %111 = phi i32 [ %135, %133 ], [ 0, %101 ]
  br label %112

; <label>:112:                                    ; preds = %108, %117
  %113 = phi i64 [ %114, %117 ], [ %109, %108 ]
  %114 = add nsw i64 %113, -1
  %115 = trunc i64 %113 to i32
  %116 = icmp eq i32 %115, 0
  br i1 %116, label %136, label %117

; <label>:117:                                    ; preds = %112
  %118 = load %union.Node*, %union.Node** %106, align 8, !tbaa !147
  %119 = getelementptr inbounds %union.Node, %union.Node* %118, i64 %114, i32 0, i32 1
  %120 = load i8, i8* %119, align 8, !tbaa !21
  %121 = and i8 %120, 15
  %122 = icmp eq i8 %121, 0
  br i1 %122, label %112, label %123

; <label>:123:                                    ; preds = %117
  %124 = getelementptr inbounds %union.Node, %union.Node* %118, i64 %114, i32 0, i32 2
  %125 = load i8, i8* %124, align 1, !tbaa !21
  %126 = icmp eq i8 %125, 35
  br i1 %126, label %127, label %133

; <label>:127:                                    ; preds = %123
  %128 = getelementptr inbounds %union.Node, %union.Node* %118, i64 %114, i32 0, i32 4
  %129 = bitcast %union.Value* %128 to i64*
  %130 = load i64, i64* %129, align 8, !tbaa !21
  %131 = call fastcc i32 @countint(i64 %130, i32* nonnull %63) #17
  %132 = add nsw i32 %131, %110
  br label %133

; <label>:133:                                    ; preds = %127, %123
  %134 = phi i32 [ %132, %127 ], [ %110, %123 ]
  %135 = add nuw nsw i32 %111, 1
  br label %108

; <label>:136:                                    ; preds = %112
  %137 = add i32 %110, %70
  %138 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %139 = load i8, i8* %138, align 8, !tbaa !22
  %140 = icmp eq i8 %139, 35
  br i1 %140, label %141, label %146

; <label>:141:                                    ; preds = %136
  %142 = bitcast %struct.TValue* %31 to i64*
  %143 = load i64, i64* %142, align 8, !tbaa !21
  %144 = call fastcc i32 @countint(i64 %143, i32* nonnull %63) #17
  %145 = add i32 %144, %137
  br label %146

; <label>:146:                                    ; preds = %141, %136
  %147 = phi i32 [ %145, %141 ], [ %137, %136 ]
  br label %148

; <label>:148:                                    ; preds = %158, %146
  %149 = phi i64 [ %165, %158 ], [ 0, %146 ]
  %150 = phi i32 [ %166, %158 ], [ 1, %146 ]
  %151 = phi i32 [ %161, %158 ], [ 0, %146 ]
  %152 = phi i32 [ %163, %158 ], [ 0, %146 ]
  %153 = phi i32 [ %164, %158 ], [ 0, %146 ]
  %154 = icmp eq i32 %150, 0
  br i1 %154, label %224, label %155

; <label>:155:                                    ; preds = %148
  %156 = lshr i32 %150, 1
  %157 = icmp ugt i32 %147, %156
  br i1 %157, label %158, label %224

; <label>:158:                                    ; preds = %155
  %159 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 %149
  %160 = load i32, i32* %159, align 4, !tbaa !74
  %161 = add i32 %160, %151
  %162 = icmp ugt i32 %161, %156
  %163 = select i1 %162, i32 %161, i32 %152
  %164 = select i1 %162, i32 %150, i32 %153
  %165 = add nuw nsw i64 %149, 1
  %166 = shl i32 %150, 1
  br label %148

; <label>:167:                                    ; preds = %48
  %168 = getelementptr inbounds %union.Node, %union.Node* %32, i64 0, i32 0, i32 2
  %169 = load i8, i8* %168, align 1, !tbaa !21
  %170 = zext i8 %169 to i32
  %171 = getelementptr inbounds %union.Node, %union.Node* %32, i64 0, i32 0, i32 4
  %172 = tail call fastcc %union.Node* @mainposition(%struct.Table* nonnull %1, i32 %170, %union.Value* nonnull %171) #16
  %173 = icmp eq %union.Node* %172, %32
  br i1 %173, label %203, label %174

; <label>:174:                                    ; preds = %167
  br label %175

; <label>:175:                                    ; preds = %174, %175
  %176 = phi %union.Node* [ %180, %175 ], [ %172, %174 ]
  %177 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 3
  %178 = load i32, i32* %177, align 4, !tbaa !21
  %179 = sext i32 %178 to i64
  %180 = getelementptr inbounds %union.Node, %union.Node* %176, i64 %179
  %181 = icmp eq %union.Node* %180, %32
  br i1 %181, label %182, label %175

; <label>:182:                                    ; preds = %175
  %183 = getelementptr inbounds %union.Node, %union.Node* %176, i64 0, i32 0, i32 3
  %184 = ptrtoint %union.Node* %49 to i64
  %185 = ptrtoint %union.Node* %176 to i64
  %186 = sub i64 %184, %185
  %187 = sdiv exact i64 %186, 24
  %188 = trunc i64 %187 to i32
  store i32 %188, i32* %183, align 4, !tbaa !21
  %189 = bitcast %union.Node* %49 to i8*
  %190 = bitcast %union.Node* %32 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %189, i8* %190, i64 24, i32 8, i1 false), !tbaa.struct !241
  %191 = getelementptr inbounds %union.Node, %union.Node* %32, i64 0, i32 0, i32 3
  %192 = load i32, i32* %191, align 4, !tbaa !21
  %193 = icmp eq i32 %192, 0
  br i1 %193, label %202, label %194

; <label>:194:                                    ; preds = %182
  %195 = ptrtoint %union.Node* %32 to i64
  %196 = sub i64 %195, %184
  %197 = sdiv exact i64 %196, 24
  %198 = trunc i64 %197 to i32
  %199 = getelementptr inbounds %union.Node, %union.Node* %46, i64 -1, i32 0, i32 3
  %200 = load i32, i32* %199, align 4, !tbaa !21
  %201 = add nsw i32 %200, %198
  store i32 %201, i32* %199, align 4, !tbaa !21
  store i32 0, i32* %191, align 4, !tbaa !21
  br label %202

; <label>:202:                                    ; preds = %182, %194
  store i8 16, i8* %33, align 8, !tbaa !21
  br label %229

; <label>:203:                                    ; preds = %167
  %204 = getelementptr inbounds %union.Node, %union.Node* %32, i64 0, i32 0, i32 3
  %205 = load i32, i32* %204, align 4, !tbaa !21
  %206 = icmp eq i32 %205, 0
  br i1 %206, label %207, label %209

; <label>:207:                                    ; preds = %203
  %208 = ptrtoint %union.Node* %49 to i64
  br label %218

; <label>:209:                                    ; preds = %203
  %210 = sext i32 %205 to i64
  %211 = getelementptr inbounds %union.Node, %union.Node* %32, i64 %210
  %212 = ptrtoint %union.Node* %211 to i64
  %213 = ptrtoint %union.Node* %49 to i64
  %214 = sub i64 %212, %213
  %215 = sdiv exact i64 %214, 24
  %216 = trunc i64 %215 to i32
  %217 = getelementptr inbounds %union.Node, %union.Node* %46, i64 -1, i32 0, i32 3
  store i32 %216, i32* %217, align 4, !tbaa !21
  br label %218

; <label>:218:                                    ; preds = %207, %209
  %219 = phi i64 [ %208, %207 ], [ %213, %209 ]
  %220 = ptrtoint %union.Node* %32 to i64
  %221 = sub i64 %219, %220
  %222 = sdiv exact i64 %221, 24
  %223 = trunc i64 %222 to i32
  store i32 %223, i32* %204, align 4, !tbaa !21
  br label %229

; <label>:224:                                    ; preds = %155, %148
  %225 = add nuw i32 %111, 1
  %226 = add i32 %225, %70
  %227 = sub i32 %226, %152
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %1, i32 %153, i32 %227) #17
  call void @llvm.lifetime.end.p0i8(i64 128, i8* nonnull %54) #7
  %228 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %31) #16
  br label %257

; <label>:229:                                    ; preds = %202, %218, %40
  %230 = phi %union.Node* [ %32, %40 ], [ %49, %218 ], [ %32, %202 ]
  %231 = getelementptr inbounds %union.Node, %union.Node* %230, i64 0, i32 0, i32 4
  %232 = bitcast %struct.TValue* %31 to i64*
  %233 = bitcast %union.Value* %231 to i64*
  %234 = load i64, i64* %232, align 8
  store i64 %234, i64* %233, align 8
  %235 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %236 = load i8, i8* %235, align 8, !tbaa !22
  %237 = getelementptr inbounds %union.Node, %union.Node* %230, i64 0, i32 0, i32 2
  store i8 %236, i8* %237, align 1, !tbaa !21
  %238 = load i8, i8* %235, align 8, !tbaa !22
  %239 = and i8 %238, 64
  %240 = icmp eq i8 %239, 0
  br i1 %240, label %255, label %241

; <label>:241:                                    ; preds = %229
  %242 = bitcast %struct.Table* %1 to %struct.GCObject*
  %243 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %244 = load i8, i8* %243, align 1, !tbaa !21
  %245 = and i8 %244, 32
  %246 = icmp eq i8 %245, 0
  br i1 %246, label %255, label %247

; <label>:247:                                    ; preds = %241
  %248 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 0, i32 0
  %249 = load %struct.GCObject*, %struct.GCObject** %248, align 8, !tbaa !21
  %250 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %249, i64 0, i32 2
  %251 = load i8, i8* %250, align 1, !tbaa !67
  %252 = and i8 %251, 24
  %253 = icmp eq i8 %252, 0
  br i1 %253, label %255, label %254

; <label>:254:                                    ; preds = %247
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %242) #16
  br label %255

; <label>:255:                                    ; preds = %247, %241, %229, %254
  %256 = bitcast %union.Node* %230 to %struct.TValue*
  br label %257

; <label>:257:                                    ; preds = %224, %255
  %258 = phi %struct.TValue* [ %256, %255 ], [ %228, %224 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  ret %struct.TValue* %258
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @countint(i64, i32* nocapture) unnamed_addr #2 {
  %3 = add i64 %0, -1
  %4 = icmp ugt i64 %3, 2147483647
  %5 = trunc i64 %0 to i32
  %6 = icmp eq i32 %5, 0
  %7 = or i1 %6, %4
  br i1 %7, label %27, label %8

; <label>:8:                                      ; preds = %2
  %9 = add i32 %5, -1
  br label %10

; <label>:10:                                     ; preds = %14, %8
  %11 = phi i32 [ %9, %8 ], [ %16, %14 ]
  %12 = phi i32 [ 0, %8 ], [ %15, %14 ]
  %13 = icmp ugt i32 %11, 255
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %10
  %15 = add nuw nsw i32 %12, 8
  %16 = lshr i32 %11, 8
  br label %10

; <label>:17:                                     ; preds = %10
  %18 = zext i32 %11 to i64
  %19 = getelementptr inbounds [256 x i8], [256 x i8]* @luaO_ceillog2.log_2, i64 0, i64 %18
  %20 = load i8, i8* %19, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  %22 = add nuw nsw i32 %12, %21
  %23 = zext i32 %22 to i64
  %24 = getelementptr inbounds i32, i32* %1, i64 %23
  %25 = load i32, i32* %24, align 4, !tbaa !74
  %26 = add i32 %25, 1
  store i32 %26, i32* %24, align 4, !tbaa !74
  br label %27

; <label>:27:                                     ; preds = %2, %17
  %28 = phi i32 [ 1, %17 ], [ 0, %2 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State*) unnamed_addr #0 {
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %0) #16
  %2 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 64, i32 0) #16
  %3 = bitcast i8* %2 to %struct.CallInfo*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !49
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 3
  %7 = bitcast %struct.CallInfo** %6 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !103
  %8 = ptrtoint %struct.CallInfo* %5 to i64
  %9 = getelementptr inbounds i8, i8* %2, i64 16
  %10 = bitcast i8* %9 to i64*
  store i64 %8, i64* %10, align 8, !tbaa !92
  %11 = getelementptr inbounds i8, i8* %2, i64 24
  %12 = bitcast i8* %11 to %struct.CallInfo**
  store %struct.CallInfo* null, %struct.CallInfo** %12, align 8, !tbaa !103
  %13 = getelementptr inbounds i8, i8* %2, i64 40
  %14 = bitcast i8* %13 to i32*
  store i32 0, i32* %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %16 = load i16, i16* %15, align 4, !tbaa !50
  %17 = add i16 %16, 1
  store i16 %17, i16* %15, align 4, !tbaa !50
  ret %struct.CallInfo* %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaE_enterCcall(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !54
  %4 = and i32 %3, 65528
  %5 = add i32 %3, 1
  store i32 %5, i32* %2, align 8, !tbaa !54
  %6 = icmp ugt i32 %4, 2199
  br i1 %6, label %7, label %18

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  %8 = load i32, i32* %2, align 8, !tbaa !54
  %9 = and i32 %8, 65535
  %10 = icmp ugt i32 %9, 2199
  br i1 %10, label %11, label %18

; <label>:11:                                     ; preds = %7
  %12 = icmp ult i32 %9, 2213
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = add i32 %8, 14
  store i32 %14, i32* %2, align 8, !tbaa !54
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0)) #18
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = icmp ugt i32 %9, 2474
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #18
  unreachable

; <label>:18:                                     ; preds = %7, %15, %1
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @f_parser(%struct.lua_State*, i8*) #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LexState, align 8
  %6 = alloca %struct.FuncState, align 8
  %7 = alloca %struct.LoadState, align 8
  %8 = bitcast i8* %1 to %struct.Zio**
  %9 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !161
  %10 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !242
  %12 = add i64 %11, -1
  store i64 %12, i64* %10, align 8, !tbaa !242
  %13 = icmp eq i64 %11, 0
  br i1 %13, label %20, label %14

; <label>:14:                                     ; preds = %2
  %15 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !243
  %17 = getelementptr inbounds i8, i8* %16, i64 1
  store i8* %17, i8** %15, align 8, !tbaa !243
  %18 = load i8, i8* %16, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  br label %22

; <label>:20:                                     ; preds = %2
  %21 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %9) #16
  br label %22

; <label>:22:                                     ; preds = %20, %14
  %23 = phi i32 [ %19, %14 ], [ %21, %20 ]
  %24 = icmp eq i32 %23, 27
  %25 = getelementptr inbounds i8, i8* %1, i64 80
  %26 = bitcast i8* %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !168
  br i1 %24, label %28, label %71

; <label>:28:                                     ; preds = %22
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %27, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.203, i64 0, i64 0)) #16
  %29 = bitcast i8* %1 to i64*
  %30 = load i64, i64* %29, align 8, !tbaa !161
  %31 = getelementptr inbounds i8, i8* %1, i64 88
  %32 = bitcast i8* %31 to i8**
  %33 = load i8*, i8** %32, align 8, !tbaa !167
  %34 = bitcast %struct.LoadState* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %34) #7
  %35 = load i8, i8* %33, align 1, !tbaa !21
  switch i8 %35, label %38 [
    i8 64, label %36
    i8 61, label %36
    i8 27, label %39
  ]

; <label>:36:                                     ; preds = %28, %28
  %37 = getelementptr inbounds i8, i8* %33, i64 1
  br label %39

; <label>:38:                                     ; preds = %28
  br label %39

; <label>:39:                                     ; preds = %28, %38, %36
  %40 = phi i8* [ %33, %38 ], [ %37, %36 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.206, i64 0, i64 0), %28 ]
  %41 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %7, i64 0, i32 2
  store i8* %40, i8** %41, align 8, !tbaa !244
  %42 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %7, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %42, align 8, !tbaa !246
  %43 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %7, i64 0, i32 1
  %44 = bitcast %struct.Zio** %43 to i64*
  store i64 %30, i64* %44, align 8, !tbaa !247
  call fastcc void @checkliteral(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 1), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.207, i64 0, i64 0)) #17
  %45 = call fastcc i32 @LoadInt(%struct.LoadState* nonnull %7) #17
  %46 = icmp eq i32 %45, 504
  br i1 %46, label %48, label %47

; <label>:47:                                     ; preds = %39
  call fastcc void @error(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.208, i64 0, i64 0)) #19
  unreachable

; <label>:48:                                     ; preds = %39
  %49 = call fastcc zeroext i8 @LoadByte(%struct.LoadState* nonnull %7) #17
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %52, label %51

; <label>:51:                                     ; preds = %48
  call fastcc void @error(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.209, i64 0, i64 0)) #19
  unreachable

; <label>:52:                                     ; preds = %48
  call fastcc void @checkliteral(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.211, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %7, i64 4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.212, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %7, i64 8, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.213, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %7, i64 8, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.214, i64 0, i64 0)) #17
  %53 = call fastcc i64 @LoadInteger(%struct.LoadState* nonnull %7) #17
  %54 = icmp eq i64 %53, 22136
  br i1 %54, label %56, label %55

; <label>:55:                                     ; preds = %52
  call fastcc void @error(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.215, i64 0, i64 0)) #19
  unreachable

; <label>:56:                                     ; preds = %52
  %57 = call fastcc double @LoadNumber(%struct.LoadState* nonnull %7) #17
  %58 = fcmp une double %57, 3.705000e+02
  br i1 %58, label %59, label %60

; <label>:59:                                     ; preds = %56
  call fastcc void @error(%struct.LoadState* nonnull %7, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.216, i64 0, i64 0)) #19
  unreachable

; <label>:60:                                     ; preds = %56
  %61 = call fastcc zeroext i8 @LoadByte(%struct.LoadState* nonnull %7) #17
  %62 = zext i8 %61 to i32
  %63 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %62) #17
  %64 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %65 = bitcast %union.StackValue** %64 to %struct.TValue**
  %66 = load %struct.TValue*, %struct.TValue** %65, align 8, !tbaa !20
  %67 = bitcast %struct.TValue* %66 to %struct.LClosure**
  store %struct.LClosure* %63, %struct.LClosure** %67, align 8, !tbaa !21
  %68 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 0, i32 1
  store i8 86, i8* %68, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0) #17
  %69 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %0) #17
  %70 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %63, i64 0, i32 5
  store %struct.Proto* %69, %struct.Proto** %70, align 8, !tbaa !192
  call fastcc void @LoadFunction(%struct.LoadState* nonnull %7, %struct.Proto* %69, %struct.TString* null) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %34) #7
  br label %154

; <label>:71:                                     ; preds = %22
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %27, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.204, i64 0, i64 0)) #16
  %72 = bitcast i8* %1 to i64*
  %73 = load i64, i64* %72, align 8, !tbaa !161
  %74 = getelementptr inbounds i8, i8* %1, i64 8
  %75 = getelementptr inbounds i8, i8* %1, i64 32
  %76 = getelementptr inbounds i8, i8* %1, i64 88
  %77 = bitcast i8* %76 to i8**
  %78 = load i8*, i8** %77, align 8, !tbaa !167
  %79 = bitcast %struct.LexState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %79) #7
  %80 = bitcast %struct.FuncState* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %80) #7
  %81 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 1) #17
  %82 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %83 = bitcast %union.StackValue** %82 to %struct.TValue**
  %84 = load %struct.TValue*, %struct.TValue** %83, align 8, !tbaa !20
  %85 = bitcast %struct.TValue* %84 to %struct.LClosure**
  store %struct.LClosure* %81, %struct.LClosure** %85, align 8, !tbaa !21
  %86 = getelementptr inbounds %struct.TValue, %struct.TValue* %84, i64 0, i32 1
  store i8 86, i8* %86, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0) #17
  %87 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0) #17
  %88 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 9
  store %struct.Table* %87, %struct.Table** %88, align 8, !tbaa !248
  %89 = load %struct.TValue*, %struct.TValue** %83, align 8, !tbaa !20
  %90 = bitcast %struct.TValue* %89 to %struct.Table**
  store %struct.Table* %87, %struct.Table** %90, align 8, !tbaa !21
  %91 = getelementptr inbounds %struct.TValue, %struct.TValue* %89, i64 0, i32 1
  store i8 69, i8* %91, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0) #17
  %92 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %0) #17
  %93 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %81, i64 0, i32 5
  store %struct.Proto* %92, %struct.Proto** %93, align 8, !tbaa !192
  %94 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 0
  store %struct.Proto* %92, %struct.Proto** %94, align 8, !tbaa !251
  %95 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %78) #17
  %96 = getelementptr inbounds %struct.Proto, %struct.Proto* %92, i64 0, i32 22
  store %struct.TString* %95, %struct.TString** %96, align 8, !tbaa !108
  %97 = getelementptr inbounds %struct.Proto, %struct.Proto* %92, i64 0, i32 2
  %98 = load i8, i8* %97, align 1, !tbaa !232
  %99 = and i8 %98, 32
  %100 = icmp eq i8 %99, 0
  %101 = ptrtoint %struct.TString* %95 to i64
  br i1 %100, label %112, label %102

; <label>:102:                                    ; preds = %71
  %103 = getelementptr inbounds %struct.TString, %struct.TString* %95, i64 0, i32 2
  %104 = load i8, i8* %103, align 1, !tbaa !140
  %105 = and i8 %104, 24
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %112, label %107

; <label>:107:                                    ; preds = %102
  %108 = bitcast %struct.Proto* %92 to %struct.GCObject*
  %109 = bitcast %struct.TString* %95 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %108, %struct.GCObject* %109) #17
  %110 = bitcast %struct.TString** %96 to i64*
  %111 = load i64, i64* %110, align 8, !tbaa !108
  br label %112

; <label>:112:                                    ; preds = %71, %102, %107
  %113 = phi i64 [ %101, %102 ], [ %101, %71 ], [ %111, %107 ]
  %114 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 8
  %115 = bitcast %struct.Mbuffer** %114 to i8**
  store i8* %74, i8** %115, align 8, !tbaa !253
  %116 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 10
  %117 = bitcast %struct.Dyndata** %116 to i8**
  store i8* %75, i8** %117, align 8, !tbaa !254
  %118 = getelementptr inbounds i8, i8* %1, i64 72
  %119 = bitcast i8* %118 to i32*
  store i32 0, i32* %119, align 8, !tbaa !255
  %120 = getelementptr inbounds i8, i8* %1, i64 56
  %121 = bitcast i8* %120 to i32*
  store i32 0, i32* %121, align 8, !tbaa !256
  %122 = getelementptr inbounds i8, i8* %1, i64 40
  %123 = bitcast i8* %122 to i32*
  store i32 0, i32* %123, align 8, !tbaa !257
  %124 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 3, i32 0
  store i32 0, i32* %124, align 8, !tbaa !258
  %125 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  store %struct.lua_State* %0, %struct.lua_State** %125, align 8, !tbaa !259
  %126 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 0
  store i32 %23, i32* %126, align 8, !tbaa !260
  %127 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 4, i32 0
  store i32 289, i32* %127, align 8, !tbaa !261
  %128 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 7
  %129 = bitcast %struct.Zio** %128 to i64*
  store i64 %73, i64* %129, align 8, !tbaa !262
  %130 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 5
  store %struct.FuncState* null, %struct.FuncState** %130, align 8, !tbaa !263
  %131 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 1
  store i32 1, i32* %131, align 4, !tbaa !264
  %132 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 2
  store i32 1, i32* %132, align 8, !tbaa !265
  %133 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 11
  %134 = bitcast %struct.TString** %133 to i64*
  store i64 %113, i64* %134, align 8, !tbaa !266
  %135 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4) #17
  %136 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 12
  store %struct.TString* %135, %struct.TString** %136, align 8, !tbaa !267
  %137 = bitcast i8* %74 to i8**
  %138 = load i8*, i8** %137, align 8, !tbaa !268
  %139 = getelementptr inbounds i8, i8* %1, i64 24
  %140 = bitcast i8* %139 to i64*
  %141 = load i64, i64* %140, align 8, !tbaa !269
  %142 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* nonnull %0, i8* %138, i64 %141, i64 32) #17
  store i8* %142, i8** %137, align 8, !tbaa !268
  store i64 32, i64* %140, align 8, !tbaa !269
  %143 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %143) #7
  %144 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %144) #7
  call fastcc void @open_func(%struct.LexState* nonnull %5, %struct.FuncState* nonnull %6, %struct.BlockCnt* nonnull %3) #17
  call fastcc void @setvararg(%struct.FuncState* nonnull %6, i32 0) #17
  %145 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %145, align 8, !tbaa !270
  %146 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %146, align 4, !tbaa !272
  %147 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 8, i32* %147, align 8, !tbaa !273
  %148 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %149 = bitcast %union.anon.8* %148 to i32*
  store i32 0, i32* %149, align 8, !tbaa !21
  %150 = load %struct.TString*, %struct.TString** %136, align 8, !tbaa !267
  %151 = call fastcc i32 @newupvalue(%struct.FuncState* nonnull %6, %struct.TString* %150, %struct.expdesc* nonnull %4) #17
  call fastcc void @luaX_next(%struct.LexState* nonnull %5) #17
  call fastcc void @statlist(%struct.LexState* nonnull %5) #17
  call fastcc void @check(%struct.LexState* nonnull %5, i32 289) #17
  call fastcc void @close_func(%struct.LexState* nonnull %5) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %144) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %143) #7
  %152 = load %union.StackValue*, %union.StackValue** %82, align 8, !tbaa !20
  %153 = getelementptr inbounds %union.StackValue, %union.StackValue* %152, i64 -1
  store %union.StackValue* %153, %union.StackValue** %82, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %80) #7
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %79) #7
  br label %154

; <label>:154:                                    ; preds = %112, %60
  %155 = phi %struct.LClosure* [ %63, %60 ], [ %81, %112 ]
  %156 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %155, i64 0, i32 3
  %157 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %155, i64 0, i32 2
  %158 = bitcast %struct.LClosure* %155 to %struct.GCObject*
  br label %159

; <label>:159:                                    ; preds = %181, %154
  %160 = phi i64 [ %182, %181 ], [ 0, %154 ]
  %161 = load i8, i8* %156, align 2, !tbaa !177
  %162 = zext i8 %161 to i64
  %163 = icmp ult i64 %160, %162
  br i1 %163, label %164, label %183

; <label>:164:                                    ; preds = %159
  %165 = call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 9, i64 40) #17
  %166 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %165, i64 1, i32 1
  %167 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %165, i64 1
  %168 = bitcast %struct.GCObject* %167 to i8**
  store i8* %166, i8** %168, align 8, !tbaa !64
  %169 = getelementptr inbounds i8, i8* %166, i64 8
  store i8 0, i8* %169, align 8, !tbaa !22
  %170 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %155, i64 0, i32 6, i64 %160
  %171 = bitcast %struct.UpVal** %170 to %struct.GCObject**
  store %struct.GCObject* %165, %struct.GCObject** %171, align 8, !tbaa !39
  %172 = load i8, i8* %157, align 1, !tbaa !196
  %173 = and i8 %172, 32
  %174 = icmp eq i8 %173, 0
  br i1 %174, label %181, label %175

; <label>:175:                                    ; preds = %164
  %176 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %165, i64 0, i32 2
  %177 = load i8, i8* %176, align 1, !tbaa !67
  %178 = and i8 %177, 24
  %179 = icmp eq i8 %178, 0
  br i1 %179, label %181, label %180

; <label>:180:                                    ; preds = %175
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* nonnull %158, %struct.GCObject* nonnull %165) #17
  br label %181

; <label>:181:                                    ; preds = %180, %175, %164
  %182 = add nuw nsw i64 %160, 1
  br label %159

; <label>:183:                                    ; preds = %159
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaM_saferealloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %2, i64 %3) #16
  %6 = icmp eq i8* %5, null
  %7 = icmp ne i64 %3, 0
  %8 = and i1 %7, %6
  br i1 %8, label %9, label %10, !prof !47

; <label>:9:                                      ; preds = %4
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:10:                                     ; preds = %4
  ret i8* %5
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaZ_fill(%struct.Zio* nocapture) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 4
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !157
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 2
  %7 = load i8* (%struct.lua_State*, i8*, i64*)*, i8* (%struct.lua_State*, i8*, i64*)** %6, align 8, !tbaa !159
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 3
  %9 = load i8*, i8** %8, align 8, !tbaa !160
  %10 = call i8* %7(%struct.lua_State* %5, i8* %9, i64* nonnull %2) #17
  %11 = icmp eq i8* %10, null
  %12 = load i64, i64* %2, align 8
  %13 = icmp eq i64 %12, 0
  %14 = or i1 %11, %13
  br i1 %14, label %22, label %15

; <label>:15:                                     ; preds = %1
  %16 = add i64 %12, -1
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 0
  store i64 %16, i64* %17, align 8, !tbaa !242
  %18 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 1
  %19 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %19, i8** %18, align 8, !tbaa !243
  %20 = load i8, i8* %10, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %22

; <label>:22:                                     ; preds = %1, %15
  %23 = phi i32 [ %21, %15 ], [ -1, %1 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %23
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checkmode(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = icmp eq i8* %1, null
  br i1 %4, label %12, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i8, i8* %2, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  %8 = tail call i8* @strchr(i8* nonnull %1, i32 %7) #21
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %5
  %11 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.205, i64 0, i64 0), i8* nonnull %2, i8* nonnull %1) #16
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 3) #18
  unreachable

; <label>:12:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc zeroext i8 @LoadByte(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %3 = load %struct.Zio*, %struct.Zio** %2, align 8, !tbaa !247
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 0
  %5 = load i64, i64* %4, align 8, !tbaa !242
  %6 = add i64 %5, -1
  store i64 %6, i64* %4, align 8, !tbaa !242
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !243
  %11 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %11, i8** %9, align 8, !tbaa !243
  %12 = load i8, i8* %10, align 1, !tbaa !21
  %13 = zext i8 %12 to i32
  br label %18

; <label>:14:                                     ; preds = %1
  %15 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %3) #16
  %16 = icmp eq i32 %15, -1
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  tail call fastcc void @error(%struct.LoadState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %8, %14
  %19 = phi i32 [ %13, %8 ], [ %15, %14 ]
  %20 = trunc i32 %19 to i8
  ret i8 %20
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaD_inctop(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !59
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = sub i64 %4, %7
  %9 = icmp slt i64 %8, 32
  %10 = inttoptr i64 %7 to %union.StackValue*
  br i1 %9, label %11, label %14

; <label>:11:                                     ; preds = %1
  %12 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 1, i32 1) #16
  %13 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  br label %14

; <label>:14:                                     ; preds = %1, %11
  %15 = phi %union.StackValue* [ %10, %1 ], [ %13, %11 ]
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.Proto* @luaF_newproto(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 10, i64 128) #16
  %3 = bitcast %struct.GCObject* %2 to %struct.Proto*
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 3, i32 1
  %5 = bitcast i8* %4 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %5, align 8, !tbaa !221
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 7
  store i32 0, i32* %6, align 4, !tbaa !222
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2
  %8 = bitcast %struct.GCObject* %7 to i32*
  store i32 0, i32* %8, align 8, !tbaa !220
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 4
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1, i32 1
  %11 = bitcast i8* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !218
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 5, i32 1
  %13 = bitcast i8* %12 to i8**
  store i8* null, i8** %13, align 8, !tbaa !124
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 9
  %15 = bitcast %struct.GCObject* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %15, i8 0, i64 16, i32 8, i1 false)
  store i32 0, i32* %14, align 4, !tbaa !123
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 6
  %17 = bitcast %struct.GCObject* %16 to %struct.AbsLineInfo**
  store %struct.AbsLineInfo* null, %struct.AbsLineInfo** %17, align 8, !tbaa !223
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2, i32 1
  %19 = bitcast i8* %18 to i32*
  store i32 0, i32* %19, align 8, !tbaa !224
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 5
  %21 = bitcast %struct.GCObject* %20 to %struct.Upvaldesc**
  store %struct.Upvaldesc* null, %struct.Upvaldesc** %21, align 8, !tbaa !193
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1
  %23 = bitcast %struct.GCObject* %22 to i32*
  store i32 0, i32* %23, align 8, !tbaa !185
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 3
  store i8 0, i8* %24, align 2, !tbaa !117
  %25 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 4
  store i8 0, i8* %25, align 1, !tbaa !102
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 5
  store i8 0, i8* %26, align 4, !tbaa !153
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 6, i32 1
  %28 = bitcast i8* %27 to %struct.LocVar**
  store %struct.LocVar* null, %struct.LocVar** %28, align 8, !tbaa !97
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 11
  store i32 0, i32* %29, align 4, !tbaa !95
  %30 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 13
  store i32 0, i32* %30, align 4, !tbaa !110
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 3
  %32 = bitcast %struct.GCObject* %31 to i32*
  store i32 0, i32* %32, align 8, !tbaa !111
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 7
  %34 = bitcast %struct.GCObject* %33 to %struct.TString**
  store %struct.TString* null, %struct.TString** %34, align 8, !tbaa !108
  ret %struct.Proto* %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @LoadFunction(%struct.LoadState* readonly, %struct.Proto*, %struct.TString*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #16
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 22
  %6 = icmp eq %struct.TString* %4, null
  %7 = select i1 %6, %struct.TString* %2, %struct.TString* %4
  store %struct.TString* %7, %struct.TString** %5, align 8, !tbaa !108
  %8 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #16
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 13
  store i32 %8, i32* %9, align 4, !tbaa !110
  %10 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #16
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 14
  store i32 %10, i32* %11, align 8, !tbaa !111
  %12 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 3
  store i8 %12, i8* %13, align 2, !tbaa !117
  %14 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %15 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 4
  store i8 %14, i8* %15, align 1, !tbaa !102
  %16 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 5
  store i8 %16, i8* %17, align 4, !tbaa !153
  %18 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %19 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %20 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %21 = sext i32 %18 to i64
  %22 = shl nsw i64 %21, 2
  %23 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %20, i64 %22, i32 0) #17
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 16
  %25 = bitcast i32** %24 to i8**
  store i8* %23, i8** %25, align 8, !tbaa !119
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 8
  store i32 %18, i32* %26, align 8, !tbaa !218
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %23, i64 %22) #17
  %27 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %28 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %29 = sext i32 %27 to i64
  %30 = shl nsw i64 %29, 4
  %31 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %28, i64 %30, i32 0) #17
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 15
  %33 = bitcast %struct.TValue** %32 to i8**
  store i8* %31, i8** %33, align 8, !tbaa !221
  %34 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 7
  store i32 %27, i32* %34, align 4, !tbaa !222
  %35 = bitcast i8* %31 to %struct.TValue*
  br label %36

; <label>:36:                                     ; preds = %40, %3
  %37 = phi i64 [ %42, %40 ], [ 0, %3 ]
  %38 = icmp slt i64 %37, %29
  br i1 %38, label %40, label %39

; <label>:39:                                     ; preds = %36
  br label %43

; <label>:40:                                     ; preds = %36
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %35, i64 %37, i32 1
  store i8 0, i8* %41, align 8, !tbaa !22
  %42 = add nuw nsw i64 %37, 1
  br label %36

; <label>:43:                                     ; preds = %39, %72
  %44 = phi i64 [ %73, %72 ], [ 0, %39 ]
  %45 = icmp slt i64 %44, %29
  br i1 %45, label %46, label %74

; <label>:46:                                     ; preds = %43
  %47 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !221
  %48 = getelementptr inbounds %struct.TValue, %struct.TValue* %47, i64 %44
  %49 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  switch i8 %49, label %72 [
    i8 0, label %69
    i8 1, label %50
    i8 19, label %54
    i8 35, label %57
    i8 20, label %60
    i8 36, label %60
  ]

; <label>:50:                                     ; preds = %46
  %51 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %52 = zext i8 %51 to i32
  %53 = bitcast %struct.TValue* %48 to i32*
  store i32 %52, i32* %53, align 8, !tbaa !21
  br label %69

; <label>:54:                                     ; preds = %46
  %55 = tail call fastcc double @LoadNumber(%struct.LoadState* %0) #17
  %56 = bitcast %struct.TValue* %48 to double*
  store double %55, double* %56, align 8, !tbaa !21
  br label %69

; <label>:57:                                     ; preds = %46
  %58 = tail call fastcc i64 @LoadInteger(%struct.LoadState* %0) #17
  %59 = bitcast %struct.TValue* %48 to i64*
  store i64 %58, i64* %59, align 8, !tbaa !21
  br label %69

; <label>:60:                                     ; preds = %46, %46
  %61 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %62 = icmp eq %struct.TString* %61, null
  br i1 %62, label %63, label %64

; <label>:63:                                     ; preds = %60
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.221, i64 0, i64 0)) #19
  unreachable

; <label>:64:                                     ; preds = %60
  %65 = bitcast %struct.TValue* %48 to %struct.TString**
  store %struct.TString* %61, %struct.TString** %65, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.TString, %struct.TString* %61, i64 0, i32 1
  %67 = load i8, i8* %66, align 8, !tbaa !72
  %68 = or i8 %67, 64
  br label %69

; <label>:69:                                     ; preds = %46, %50, %54, %57, %64
  %70 = phi i8 [ %68, %64 ], [ 35, %57 ], [ 19, %54 ], [ 1, %50 ], [ %49, %46 ]
  %71 = getelementptr inbounds %struct.TValue, %struct.TValue* %47, i64 %44, i32 1
  store i8 %70, i8* %71, align 8, !tbaa !22
  br label %72

; <label>:72:                                     ; preds = %69, %46
  %73 = add nuw nsw i64 %44, 1
  br label %43

; <label>:74:                                     ; preds = %43
  %75 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %76 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %77 = sext i32 %75 to i64
  %78 = shl nsw i64 %77, 4
  %79 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %76, i64 %78, i32 0) #17
  %80 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %81 = bitcast %struct.Upvaldesc** %80 to i8**
  store i8* %79, i8** %81, align 8, !tbaa !193
  %82 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  store i32 %75, i32* %82, align 8, !tbaa !185
  %83 = bitcast i8* %79 to %struct.Upvaldesc*
  br label %84

; <label>:84:                                     ; preds = %88, %74
  %85 = phi i64 [ %90, %88 ], [ 0, %74 ]
  %86 = icmp slt i64 %85, %77
  br i1 %86, label %88, label %87

; <label>:87:                                     ; preds = %84
  br label %91

; <label>:88:                                     ; preds = %84
  %89 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %83, i64 %85, i32 0
  store %struct.TString* null, %struct.TString** %89, align 8, !tbaa !194
  %90 = add nuw nsw i64 %85, 1
  br label %84

; <label>:91:                                     ; preds = %87, %94
  %92 = phi i64 [ %101, %94 ], [ 0, %87 ]
  %93 = icmp slt i64 %92, %77
  br i1 %93, label %94, label %102

; <label>:94:                                     ; preds = %91
  %95 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %96 = load %struct.Upvaldesc*, %struct.Upvaldesc** %80, align 8, !tbaa !193
  %97 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %96, i64 %92, i32 1
  store i8 %95, i8* %97, align 8, !tbaa !238
  %98 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %99 = load %struct.Upvaldesc*, %struct.Upvaldesc** %80, align 8, !tbaa !193
  %100 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %99, i64 %92, i32 2
  store i8 %98, i8* %100, align 1, !tbaa !239
  %101 = add nuw nsw i64 %92, 1
  br label %91

; <label>:102:                                    ; preds = %91
  %103 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %104 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %105 = sext i32 %103 to i64
  %106 = shl nsw i64 %105, 3
  %107 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %104, i64 %106, i32 0) #17
  %108 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 17
  %109 = bitcast %struct.Proto*** %108 to i8**
  store i8* %107, i8** %109, align 8, !tbaa !219
  %110 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 10
  store i32 %103, i32* %110, align 8, !tbaa !220
  br label %111

; <label>:111:                                    ; preds = %115, %102
  %112 = phi i64 [ %118, %115 ], [ 0, %102 ]
  %113 = icmp slt i64 %112, %105
  br i1 %113, label %115, label %114

; <label>:114:                                    ; preds = %111
  br label %119

; <label>:115:                                    ; preds = %111
  %116 = load %struct.Proto**, %struct.Proto*** %108, align 8, !tbaa !219
  %117 = getelementptr inbounds %struct.Proto*, %struct.Proto** %116, i64 %112
  store %struct.Proto* null, %struct.Proto** %117, align 8, !tbaa !39
  %118 = add nuw nsw i64 %112, 1
  br label %111

; <label>:119:                                    ; preds = %114, %122
  %120 = phi i64 [ %131, %122 ], [ 0, %114 ]
  %121 = icmp slt i64 %120, %105
  br i1 %121, label %122, label %132

; <label>:122:                                    ; preds = %119
  %123 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %124 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %123) #17
  %125 = load %struct.Proto**, %struct.Proto*** %108, align 8, !tbaa !219
  %126 = getelementptr inbounds %struct.Proto*, %struct.Proto** %125, i64 %120
  store %struct.Proto* %124, %struct.Proto** %126, align 8, !tbaa !39
  %127 = load %struct.Proto**, %struct.Proto*** %108, align 8, !tbaa !219
  %128 = getelementptr inbounds %struct.Proto*, %struct.Proto** %127, i64 %120
  %129 = load %struct.Proto*, %struct.Proto** %128, align 8, !tbaa !39
  %130 = load %struct.TString*, %struct.TString** %5, align 8, !tbaa !108
  tail call fastcc void @LoadFunction(%struct.LoadState* %0, %struct.Proto* %129, %struct.TString* %130) #17
  %131 = add nuw nsw i64 %120, 1
  br label %119

; <label>:132:                                    ; preds = %119
  %133 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %134 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %135 = sext i32 %133 to i64
  %136 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %134, i64 %135, i32 0) #17
  %137 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  store i8* %136, i8** %137, align 8, !tbaa !124
  %138 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  store i32 %133, i32* %138, align 4, !tbaa !123
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %136, i64 %135) #17
  %139 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %140 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %141 = sext i32 %139 to i64
  %142 = shl nsw i64 %141, 3
  %143 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %140, i64 %142, i32 0) #17
  %144 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %145 = bitcast %struct.AbsLineInfo** %144 to i8**
  store i8* %143, i8** %145, align 8, !tbaa !223
  %146 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  store i32 %139, i32* %146, align 8, !tbaa !224
  br label %147

; <label>:147:                                    ; preds = %151, %132
  %148 = phi i64 [ %157, %151 ], [ 0, %132 ]
  %149 = icmp slt i64 %148, %141
  %150 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  br i1 %149, label %151, label %158

; <label>:151:                                    ; preds = %147
  %152 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %144, align 8, !tbaa !223
  %153 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %152, i64 %148, i32 0
  store i32 %150, i32* %153, align 4, !tbaa !236
  %154 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %155 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %144, align 8, !tbaa !223
  %156 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %155, i64 %148, i32 1
  store i32 %154, i32* %156, align 4, !tbaa !274
  %157 = add nuw nsw i64 %148, 1
  br label %147

; <label>:158:                                    ; preds = %147
  %159 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !246
  %160 = sext i32 %150 to i64
  %161 = shl nsw i64 %160, 4
  %162 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %159, i64 %161, i32 0) #17
  %163 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 21
  %164 = bitcast %struct.LocVar** %163 to i8**
  store i8* %162, i8** %164, align 8, !tbaa !97
  %165 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 11
  store i32 %150, i32* %165, align 4, !tbaa !95
  %166 = bitcast i8* %162 to %struct.LocVar*
  br label %167

; <label>:167:                                    ; preds = %171, %158
  %168 = phi i64 [ %173, %171 ], [ 0, %158 ]
  %169 = icmp slt i64 %168, %160
  br i1 %169, label %171, label %170

; <label>:170:                                    ; preds = %167
  br label %174

; <label>:171:                                    ; preds = %167
  %172 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %166, i64 %168, i32 0
  store %struct.TString* null, %struct.TString** %172, align 8, !tbaa !101
  %173 = add nuw nsw i64 %168, 1
  br label %167

; <label>:174:                                    ; preds = %170, %177
  %175 = phi i64 [ %187, %177 ], [ 0, %170 ]
  %176 = icmp slt i64 %175, %160
  br i1 %176, label %177, label %188

; <label>:177:                                    ; preds = %174
  %178 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %179 = load %struct.LocVar*, %struct.LocVar** %163, align 8, !tbaa !97
  %180 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %179, i64 %175, i32 0
  store %struct.TString* %178, %struct.TString** %180, align 8, !tbaa !101
  %181 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %182 = load %struct.LocVar*, %struct.LocVar** %163, align 8, !tbaa !97
  %183 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %182, i64 %175, i32 1
  store i32 %181, i32* %183, align 8, !tbaa !98
  %184 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %185 = load %struct.LocVar*, %struct.LocVar** %163, align 8, !tbaa !97
  %186 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %185, i64 %175, i32 2
  store i32 %184, i32* %186, align 4, !tbaa !100
  %187 = add nuw nsw i64 %175, 1
  br label %174

; <label>:188:                                    ; preds = %174
  %189 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0) #17
  %190 = sext i32 %189 to i64
  br label %191

; <label>:191:                                    ; preds = %194, %188
  %192 = phi i64 [ %198, %194 ], [ 0, %188 ]
  %193 = icmp slt i64 %192, %190
  br i1 %193, label %194, label %199

; <label>:194:                                    ; preds = %191
  %195 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %196 = load %struct.Upvaldesc*, %struct.Upvaldesc** %80, align 8, !tbaa !193
  %197 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %196, i64 %192, i32 0
  store %struct.TString* %195, %struct.TString** %197, align 8, !tbaa !194
  %198 = add nuw nsw i64 %192, 1
  br label %191

; <label>:199:                                    ; preds = %191
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checkliteral(%struct.LoadState* nocapture readonly, i8* nocapture readonly, i8*) unnamed_addr #0 {
  %4 = alloca [12 x i8], align 1
  %5 = getelementptr inbounds [12 x i8], [12 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 12, i8* nonnull %5) #7
  %6 = tail call i64 @strlen(i8* %1) #21
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %5, i64 %6) #16
  %7 = call i32 @memcmp(i8* %1, i8* nonnull %5, i64 %6) #21
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %3
  tail call fastcc void @error(%struct.LoadState* %0, i8* %2) #18
  unreachable

; <label>:10:                                     ; preds = %3
  call void @llvm.lifetime.end.p0i8(i64 12, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @LoadInt(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #16
  %3 = trunc i64 %2 to i32
  ret i32 %3
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @error(%struct.LoadState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !246
  %5 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 2
  %6 = load i8*, i8** %5, align 8, !tbaa !244
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.219, i64 0, i64 0), i8* %6, i8* %1) #16
  %8 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !246
  tail call fastcc void @luaD_throw(%struct.lua_State* %8, i32 3) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @fchecksize(%struct.LoadState* nocapture readonly, i64, i8*) unnamed_addr #0 {
  %4 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %5 = zext i8 %4 to i64
  %6 = icmp eq i64 %5, %1
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !246
  %10 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.220, i64 0, i64 0), i8* %2) #16
  tail call fastcc void @error(%struct.LoadState* %0, i8* %10) #18
  unreachable

; <label>:11:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @LoadInteger(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %3, i64 8) #16
  %4 = load i64, i64* %2, align 8, !tbaa !129
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i64 %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc double @LoadNumber(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca double, align 8
  %3 = bitcast double* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %3, i64 8) #16
  %4 = load double, double* %2, align 8, !tbaa !127
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret double %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @LoadBlock(%struct.LoadState* nocapture readonly, i8* nocapture, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !247
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  br label %8

; <label>:8:                                      ; preds = %25, %3
  %9 = phi i8* [ %1, %3 ], [ %34, %25 ]
  %10 = phi i64 [ %2, %3 ], [ %35, %25 ]
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %37, label %12

; <label>:12:                                     ; preds = %8
  %13 = load i64, i64* %6, align 8, !tbaa !242
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %12
  %16 = load i8*, i8** %7, align 8, !tbaa !243
  br label %25

; <label>:17:                                     ; preds = %12
  %18 = tail call fastcc i32 @luaZ_fill(%struct.Zio* nonnull %5) #17
  %19 = icmp eq i32 %18, -1
  br i1 %19, label %36, label %20

; <label>:20:                                     ; preds = %17
  %21 = load i64, i64* %6, align 8, !tbaa !242
  %22 = add i64 %21, 1
  store i64 %22, i64* %6, align 8, !tbaa !242
  %23 = load i8*, i8** %7, align 8, !tbaa !243
  %24 = getelementptr inbounds i8, i8* %23, i64 -1
  store i8* %24, i8** %7, align 8, !tbaa !243
  br label %25

; <label>:25:                                     ; preds = %20, %15
  %26 = phi i8* [ %16, %15 ], [ %24, %20 ]
  %27 = phi i64 [ %13, %15 ], [ %22, %20 ]
  %28 = icmp ugt i64 %10, %27
  %29 = select i1 %28, i64 %27, i64 %10
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %26, i64 %29, i32 1, i1 false) #7
  %30 = load i64, i64* %6, align 8, !tbaa !242
  %31 = sub i64 %30, %29
  store i64 %31, i64* %6, align 8, !tbaa !242
  %32 = load i8*, i8** %7, align 8, !tbaa !243
  %33 = getelementptr inbounds i8, i8* %32, i64 %29
  store i8* %33, i8** %7, align 8, !tbaa !243
  %34 = getelementptr inbounds i8, i8* %9, i64 %29
  %35 = sub i64 %10, %29
  br label %8

; <label>:36:                                     ; preds = %17
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #18
  unreachable

; <label>:37:                                     ; preds = %8
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @LoadUnsigned(%struct.LoadState* nocapture readonly, i64) unnamed_addr #0 {
  %3 = lshr i64 %1, 7
  br label %4

; <label>:4:                                      ; preds = %9, %2
  %5 = phi i64 [ 0, %2 ], [ %13, %9 ]
  %6 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %7 = icmp ult i64 %5, %3
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %4
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %4
  %10 = shl i64 %5, 7
  %11 = and i8 %6, 127
  %12 = zext i8 %11 to i64
  %13 = or i64 %10, %12
  %14 = icmp sgt i8 %6, -1
  br i1 %14, label %4, label %15

; <label>:15:                                     ; preds = %9
  ret i64 %13
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @LoadStringN(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca [40 x i8], align 16
  %3 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 -1) #17
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %19, label %5

; <label>:5:                                      ; preds = %1
  %6 = add i64 %3, -1
  %7 = icmp ult i64 %6, 41
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %5
  %9 = getelementptr inbounds [40 x i8], [40 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %9) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %9, i64 %6) #16
  %10 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !246
  %12 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* nonnull %9, i64 %6) #16
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %9) #7
  br label %19

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !246
  %16 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %15, i64 %6) #16
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %18, i64 %6) #16
  br label %19

; <label>:19:                                     ; preds = %1, %13, %8
  %20 = phi %struct.TString* [ %12, %8 ], [ %16, %13 ], [ null, %1 ]
  ret %struct.TString* %20
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @open_func(%struct.LexState*, %struct.FuncState*, %struct.BlockCnt*) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = bitcast %struct.FuncState** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !263
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 1
  %10 = bitcast %struct.FuncState** %9 to i64*
  store i64 %8, i64* %10, align 8, !tbaa !275
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 2
  store %struct.LexState* %0, %struct.LexState** %11, align 8, !tbaa !276
  store %struct.FuncState* %1, %struct.FuncState** %6, align 8, !tbaa !263
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 4
  store i32 0, i32* %12, align 8, !tbaa !277
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 13
  %14 = load i32, i32* %13, align 4, !tbaa !110
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 6
  store i32 %14, i32* %15, align 8, !tbaa !278
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 5
  store i32 0, i32* %16, align 4, !tbaa !279
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 7
  store i32 0, i32* %17, align 4, !tbaa !280
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 9
  store i32 0, i32* %18, align 4, !tbaa !281
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 8
  store i32 0, i32* %19, align 8, !tbaa !282
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 12
  %21 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %22 = bitcast i16* %20 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %22, i8 0, i64 7, i32 8, i1 false)
  %23 = load %struct.Dyndata*, %struct.Dyndata** %21, align 8, !tbaa !254
  %24 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 0, i32 1
  %25 = load i32, i32* %24, align 8, !tbaa !257
  %26 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 10
  store i32 %25, i32* %26, align 8, !tbaa !283
  %27 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 2, i32 1
  %28 = load i32, i32* %27, align 8, !tbaa !255
  %29 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 11
  store i32 %28, i32* %29, align 4, !tbaa !284
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 3
  store %struct.BlockCnt* null, %struct.BlockCnt** %30, align 8, !tbaa !285
  %31 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %32 = bitcast %struct.TString** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !266
  %34 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 22
  %35 = bitcast %struct.TString** %34 to i64*
  store i64 %33, i64* %35, align 8, !tbaa !108
  %36 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 5
  store i8 2, i8* %36, align 4, !tbaa !153
  tail call fastcc void @enterblock(%struct.FuncState* %1, %struct.BlockCnt* %2, i8 zeroext 0) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @setvararg(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 4
  store i8 1, i8* %5, align 1, !tbaa !102
  %6 = shl i32 %1, 7
  %7 = or i32 %6, 82
  %8 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %7) #17
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @newupvalue(%struct.FuncState* nocapture, %struct.TString*, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 6
  %7 = load i32, i32* %6, align 8, !tbaa !185
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %9 = load i8, i8* %8, align 1, !tbaa !286
  %10 = zext i8 %9 to i32
  %11 = add nuw nsw i32 %10, 1
  tail call fastcc void @checklimit(%struct.FuncState* %0, i32 %11, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0)) #16
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %13 = load %struct.LexState*, %struct.LexState** %12, align 8, !tbaa !276
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %13, i64 0, i32 6
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !259
  %16 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 18
  %17 = bitcast %struct.Upvaldesc** %16 to i8**
  %18 = load i8*, i8** %17, align 8, !tbaa !193
  %19 = load i8, i8* %8, align 1, !tbaa !286
  %20 = zext i8 %19 to i32
  %21 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %15, i8* %18, i32 %20, i32* nonnull %6, i32 16, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0)) #16
  store i8* %21, i8** %17, align 8, !tbaa !193
  %22 = load i32, i32* %6, align 8, !tbaa !185
  %23 = sext i32 %7 to i64
  %24 = sext i32 %22 to i64
  %25 = bitcast i8* %21 to %struct.Upvaldesc*
  br label %26

; <label>:26:                                     ; preds = %29, %3
  %27 = phi i64 [ %30, %29 ], [ %23, %3 ]
  %28 = icmp slt i64 %27, %24
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %26
  %30 = add nsw i64 %27, 1
  %31 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %25, i64 %27, i32 0
  store %struct.TString* null, %struct.TString** %31, align 8, !tbaa !194
  br label %26

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %34 = load i32, i32* %33, align 8, !tbaa !273
  %35 = icmp eq i32 %34, 8
  %36 = zext i1 %35 to i8
  %37 = load i8, i8* %8, align 1, !tbaa !286
  %38 = zext i8 %37 to i64
  %39 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %25, i64 %38, i32 1
  store i8 %36, i8* %39, align 8, !tbaa !238
  %40 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %41 = bitcast %union.anon.8* %40 to i32*
  %42 = load i32, i32* %41, align 8, !tbaa !21
  %43 = trunc i32 %42 to i8
  %44 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %25, i64 %38, i32 2
  store i8 %43, i8* %44, align 1, !tbaa !239
  %45 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %25, i64 %38, i32 0
  store %struct.TString* %1, %struct.TString** %45, align 8, !tbaa !194
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !232
  %48 = and i8 %47, 32
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %62, label %50

; <label>:50:                                     ; preds = %32
  %51 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %52 = load i8, i8* %51, align 1, !tbaa !140
  %53 = and i8 %52, 24
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %62, label %55

; <label>:55:                                     ; preds = %50
  %56 = load %struct.LexState*, %struct.LexState** %12, align 8, !tbaa !276
  %57 = getelementptr inbounds %struct.LexState, %struct.LexState* %56, i64 0, i32 6
  %58 = load %struct.lua_State*, %struct.lua_State** %57, align 8, !tbaa !259
  %59 = bitcast %struct.Proto* %5 to %struct.GCObject*
  %60 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %58, %struct.GCObject* %59, %struct.GCObject* %60) #16
  %61 = load i8, i8* %8, align 1, !tbaa !286
  br label %62

; <label>:62:                                     ; preds = %50, %32, %55
  %63 = phi i8 [ %37, %50 ], [ %37, %32 ], [ %61, %55 ]
  %64 = add i8 %63, 1
  store i8 %64, i8* %8, align 1, !tbaa !286
  %65 = zext i8 %63 to i32
  ret i32 %65
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaX_next(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %3 = load i32, i32* %2, align 4, !tbaa !264
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %3, i32* %4, align 8, !tbaa !265
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %6 = getelementptr inbounds %struct.Token, %struct.Token* %5, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !261
  %8 = icmp eq i32 %7, 289
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %11 = bitcast %struct.Token* %10 to i8*
  %12 = bitcast %struct.Token* %5 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %11, i8* nonnull %12, i64 16, i32 8, i1 false), !tbaa.struct !287
  store i32 289, i32* %6, align 8, !tbaa !261
  br label %17

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %15 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %14) #16
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 %15, i32* %16, align 8, !tbaa !258
  br label %17

; <label>:17:                                     ; preds = %13, %9
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @statlist(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %3

; <label>:3:                                      ; preds = %5, %1
  %4 = load i32, i32* %2, align 8, !tbaa !258
  switch i32 %4, label %5 [
    i32 260, label %7
    i32 261, label %7
    i32 262, label %7
    i32 289, label %7
    i32 277, label %7
  ]

; <label>:5:                                      ; preds = %3
  %6 = icmp eq i32 %4, 274
  tail call fastcc void @statement(%struct.LexState* nonnull %0) #16
  br i1 %6, label %7, label %3

; <label>:7:                                      ; preds = %3, %3, %3, %3, %3, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @check(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !258
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #18
  unreachable

; <label>:7:                                      ; preds = %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @close_func(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !259
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 13
  %9 = load i8, i8* %8, align 2, !tbaa !288
  %10 = zext i8 %9 to i32
  tail call fastcc void @luaK_ret(%struct.FuncState* %5, i32 %10, i32 0) #16
  tail call fastcc void @leaveblock(%struct.FuncState* %5) #16
  %11 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 4
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %11, i64 0, i32 16
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 17
  %15 = getelementptr inbounds %struct.Proto, %struct.Proto* %11, i64 0, i32 4
  %16 = getelementptr inbounds %struct.Proto, %struct.Proto* %11, i64 0, i32 3
  br label %17

; <label>:17:                                     ; preds = %77, %1
  %18 = phi i64 [ %78, %77 ], [ 0, %1 ]
  %19 = load i32, i32* %12, align 8, !tbaa !277
  %20 = sext i32 %19 to i64
  %21 = icmp slt i64 %18, %20
  br i1 %21, label %22, label %79

; <label>:22:                                     ; preds = %17
  %23 = load i32*, i32** %13, align 8, !tbaa !119
  %24 = getelementptr inbounds i32, i32* %23, i64 %18
  %25 = load i32, i32* %24, align 4, !tbaa !74
  %26 = trunc i32 %25 to i7
  switch i7 %26, label %77 [
    i7 -56, label %27
    i7 -55, label %27
    i7 -57, label %36
    i7 -58, label %36
    i7 57, label %59
  ]

; <label>:27:                                     ; preds = %22, %22
  %28 = load i8, i8* %14, align 2, !tbaa !289
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %30, label %33

; <label>:30:                                     ; preds = %27
  %31 = load i8, i8* %15, align 1, !tbaa !102
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %77, label %33

; <label>:33:                                     ; preds = %30, %27
  %34 = and i32 %25, -128
  %35 = or i32 %34, 71
  store i32 %35, i32* %24, align 4, !tbaa !74
  br label %36

; <label>:36:                                     ; preds = %33, %22, %22
  %37 = phi i32 [ %25, %22 ], [ %25, %22 ], [ %35, %33 ]
  %38 = load i8, i8* %14, align 2, !tbaa !289
  %39 = icmp eq i8 %38, 0
  %40 = load i8, i8* %15, align 1, !tbaa !102
  br i1 %39, label %41, label %45

; <label>:41:                                     ; preds = %36
  %42 = icmp eq i8 %40, 0
  br i1 %42, label %77, label %43

; <label>:43:                                     ; preds = %41
  %44 = and i32 %37, 16744447
  br label %48

; <label>:45:                                     ; preds = %36
  %46 = and i32 %37, 16744447
  %47 = icmp eq i8 %40, 0
  br i1 %47, label %53, label %48

; <label>:48:                                     ; preds = %45, %43
  %49 = phi i32 [ %44, %43 ], [ %46, %45 ]
  %50 = load i8, i8* %16, align 2, !tbaa !117
  %51 = zext i8 %50 to i32
  %52 = add nuw nsw i32 %51, 1
  br label %53

; <label>:53:                                     ; preds = %48, %45
  %54 = phi i32 [ %49, %48 ], [ %46, %45 ]
  %55 = phi i32 [ %52, %48 ], [ 0, %45 ]
  %56 = shl i32 %55, 24
  %57 = or i32 %54, %56
  %58 = or i32 %57, 32768
  store i32 %58, i32* %24, align 4, !tbaa !74
  br label %77

; <label>:59:                                     ; preds = %22
  %60 = trunc i64 %18 to i32
  br label %61

; <label>:61:                                     ; preds = %71, %59
  %62 = phi i32 [ 0, %59 ], [ %75, %71 ]
  %63 = phi i32 [ %60, %59 ], [ %74, %71 ]
  %64 = icmp ult i32 %62, 100
  br i1 %64, label %65, label %76

; <label>:65:                                     ; preds = %61
  %66 = sext i32 %63 to i64
  %67 = getelementptr inbounds i32, i32* %23, i64 %66
  %68 = load i32, i32* %67, align 4, !tbaa !74
  %69 = and i32 %68, 127
  %70 = icmp eq i32 %69, 57
  br i1 %70, label %71, label %76

; <label>:71:                                     ; preds = %65
  %72 = lshr i32 %68, 7
  %73 = add i32 %63, -16777214
  %74 = add i32 %73, %72
  %75 = add nuw nsw i32 %62, 1
  br label %61

; <label>:76:                                     ; preds = %65, %61
  tail call fastcc void @fixjump(%struct.FuncState* %5, i32 %60, i32 %63) #17
  br label %77

; <label>:77:                                     ; preds = %76, %53, %41, %30, %22
  %78 = add nuw nsw i64 %18, 1
  br label %17

; <label>:79:                                     ; preds = %17
  %80 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %81 = bitcast i32** %80 to i8**
  %82 = load i8*, i8** %81, align 8, !tbaa !119
  %83 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 8
  %84 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %82, i32* nonnull %83, i32 %19, i32 4) #16
  store i8* %84, i8** %81, align 8, !tbaa !119
  %85 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 19
  %86 = load i8*, i8** %85, align 8, !tbaa !124
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 9
  %88 = load i32, i32* %12, align 8, !tbaa !277
  %89 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %86, i32* nonnull %87, i32 %88, i32 1) #16
  store i8* %89, i8** %85, align 8, !tbaa !124
  %90 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 20
  %91 = bitcast %struct.AbsLineInfo** %90 to i8**
  %92 = load i8*, i8** %91, align 8, !tbaa !223
  %93 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 12
  %94 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 9
  %95 = load i32, i32* %94, align 4, !tbaa !281
  %96 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %92, i32* nonnull %93, i32 %95, i32 8) #16
  store i8* %96, i8** %91, align 8, !tbaa !223
  %97 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 15
  %98 = bitcast %struct.TValue** %97 to i8**
  %99 = load i8*, i8** %98, align 8, !tbaa !221
  %100 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 7
  %101 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 7
  %102 = load i32, i32* %101, align 4, !tbaa !280
  %103 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %99, i32* nonnull %100, i32 %102, i32 16) #16
  store i8* %103, i8** %98, align 8, !tbaa !221
  %104 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 17
  %105 = bitcast %struct.Proto*** %104 to i8**
  %106 = load i8*, i8** %105, align 8, !tbaa !219
  %107 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 10
  %108 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 8
  %109 = load i32, i32* %108, align 8, !tbaa !282
  %110 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %106, i32* nonnull %107, i32 %109, i32 8) #16
  store i8* %110, i8** %105, align 8, !tbaa !219
  %111 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 21
  %112 = bitcast %struct.LocVar** %111 to i8**
  %113 = load i8*, i8** %112, align 8, !tbaa !97
  %114 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 11
  %115 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 12
  %116 = load i16, i16* %115, align 8, !tbaa !290
  %117 = sext i16 %116 to i32
  %118 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %113, i32* nonnull %114, i32 %117, i32 16) #16
  store i8* %118, i8** %112, align 8, !tbaa !97
  %119 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 18
  %120 = bitcast %struct.Upvaldesc** %119 to i8**
  %121 = load i8*, i8** %120, align 8, !tbaa !193
  %122 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 6
  %123 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 14
  %124 = load i8, i8* %123, align 1, !tbaa !286
  %125 = zext i8 %124 to i32
  %126 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %121, i32* nonnull %122, i32 %125, i32 16) #16
  store i8* %126, i8** %120, align 8, !tbaa !193
  %127 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 1
  %128 = bitcast %struct.FuncState** %127 to i64*
  %129 = load i64, i64* %128, align 8, !tbaa !275
  %130 = bitcast %struct.FuncState** %4 to i64*
  store i64 %129, i64* %130, align 8, !tbaa !263
  %131 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %3, i64 0, i32 7
  %132 = load %struct.global_State*, %struct.global_State** %131, align 8, !tbaa !2
  %133 = getelementptr inbounds %struct.global_State, %struct.global_State* %132, i64 0, i32 3
  %134 = load i64, i64* %133, align 8, !tbaa !11
  %135 = icmp sgt i64 %134, 0
  br i1 %135, label %136, label %137

; <label>:136:                                    ; preds = %79
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %3) #16
  br label %137

; <label>:137:                                    ; preds = %136, %79
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @enterblock(%struct.FuncState* nocapture, %struct.BlockCnt*, i8 zeroext) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 5
  store i8 %2, i8* %4, align 2, !tbaa !291
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !288
  %7 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 3
  store i8 %6, i8* %7, align 8, !tbaa !293
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %9 = load %struct.LexState*, %struct.LexState** %8, align 8, !tbaa !276
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %9, i64 0, i32 10
  %11 = load %struct.Dyndata*, %struct.Dyndata** %10, align 8, !tbaa !254
  %12 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %11, i64 0, i32 2, i32 1
  %13 = load i32, i32* %12, align 8, !tbaa !255
  %14 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 1
  store i32 %13, i32* %14, align 8, !tbaa !294
  %15 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %11, i64 0, i32 1, i32 1
  %16 = load i32, i32* %15, align 8, !tbaa !256
  %17 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 2
  store i32 %16, i32* %17, align 4, !tbaa !295
  %18 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 4
  store i8 0, i8* %18, align 1, !tbaa !296
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  %20 = load %struct.BlockCnt*, %struct.BlockCnt** %19, align 8, !tbaa !285
  %21 = icmp eq %struct.BlockCnt* %20, null
  %22 = ptrtoint %struct.BlockCnt* %20 to i64
  br i1 %21, label %28, label %23

; <label>:23:                                     ; preds = %3
  %24 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %20, i64 0, i32 6
  %25 = load i8, i8* %24, align 1, !tbaa !297
  %26 = icmp ne i8 %25, 0
  %27 = zext i1 %26 to i8
  br label %28

; <label>:28:                                     ; preds = %3, %23
  %29 = phi i8 [ 0, %3 ], [ %27, %23 ]
  %30 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 6
  store i8 %29, i8* %30, align 1, !tbaa !297
  %31 = bitcast %struct.BlockCnt* %1 to i64*
  store i64 %22, i64* %31, align 8, !tbaa !298
  store %struct.BlockCnt* %1, %struct.BlockCnt** %19, align 8, !tbaa !285
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_codeABCk(%struct.FuncState* nocapture, i32, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = shl i32 %2, 7
  %8 = or i32 %7, %1
  %9 = shl i32 %3, 16
  %10 = or i32 %8, %9
  %11 = shl i32 %4, 24
  %12 = or i32 %10, %11
  %13 = shl i32 %5, 15
  %14 = or i32 %12, %13
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14) #16
  ret i32 %15
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_code(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %6 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !276
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %6, i64 0, i32 6
  %8 = load %struct.lua_State*, %struct.lua_State** %7, align 8, !tbaa !259
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %10 = bitcast i32** %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !119
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %13 = load i32, i32* %12, align 8, !tbaa !277
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 8
  %15 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %8, i8* %11, i32 %13, i32* nonnull %14, i32 4, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0)) #16
  %16 = bitcast i8* %15 to i32*
  store i8* %15, i8** %10, align 8, !tbaa !119
  %17 = load i32, i32* %12, align 8, !tbaa !277
  %18 = add nsw i32 %17, 1
  store i32 %18, i32* %12, align 8, !tbaa !277
  %19 = sext i32 %17 to i64
  %20 = getelementptr inbounds i32, i32* %16, i64 %19
  store i32 %1, i32* %20, align 4, !tbaa !74
  %21 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !276
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 2
  %23 = load i32, i32* %22, align 8, !tbaa !265
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %4, i32 %23) #16
  %24 = load i32, i32* %12, align 8, !tbaa !277
  %25 = add nsw i32 %24, -1
  ret i32 %25
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaM_growaux_(%struct.lua_State*, i8*, i32, i32* nocapture, i32, i32, i8*) unnamed_addr #0 {
  %8 = load i32, i32* %3, align 4, !tbaa !74
  %9 = icmp sgt i32 %8, %2
  br i1 %9, label %31, label %10

; <label>:10:                                     ; preds = %7
  %11 = sdiv i32 %5, 2
  %12 = icmp slt i32 %8, %11
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %10
  %14 = icmp slt i32 %8, %5
  br i1 %14, label %20, label %15, !prof !70

; <label>:15:                                     ; preds = %13
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.223, i64 0, i64 0), i8* %6, i32 %5) #18
  unreachable

; <label>:16:                                     ; preds = %10
  %17 = shl nsw i32 %8, 1
  %18 = icmp sgt i32 %17, 4
  %19 = select i1 %18, i32 %17, i32 4
  br label %20

; <label>:20:                                     ; preds = %13, %16
  %21 = phi i32 [ %19, %16 ], [ %5, %13 ]
  %22 = sext i32 %8 to i64
  %23 = sext i32 %4 to i64
  %24 = mul nsw i64 %22, %23
  %25 = sext i32 %21 to i64
  %26 = mul nsw i64 %25, %23
  %27 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %24, i64 %26) #16
  %28 = icmp eq i8* %27, null
  br i1 %28, label %29, label %30, !prof !47

; <label>:29:                                     ; preds = %20
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:30:                                     ; preds = %20
  store i32 %21, i32* %3, align 4, !tbaa !74
  br label %31

; <label>:31:                                     ; preds = %7, %30
  %32 = phi i8* [ %27, %30 ], [ %1, %7 ]
  ret i8* %32
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @savelineinfo(%struct.FuncState* nocapture, %struct.Proto* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %5 = load i32, i32* %4, align 8, !tbaa !278
  %6 = sub nsw i32 %2, %5
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %8 = load i32, i32* %7, align 8, !tbaa !277
  %9 = add nsw i32 %8, -1
  %10 = icmp sgt i32 %6, -1
  %11 = sub i32 0, %6
  %12 = select i1 %10, i32 %6, i32 %11
  %13 = icmp sgt i32 %12, 127
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  br i1 %13, label %22, label %15

; <label>:15:                                     ; preds = %3
  %16 = load i8, i8* %14, align 1, !tbaa !299
  %17 = add i8 %16, 1
  store i8 %17, i8* %14, align 1, !tbaa !299
  %18 = icmp ugt i8 %16, 120
  br i1 %18, label %22, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %21 = trunc i32 %6 to i8
  br label %40

; <label>:22:                                     ; preds = %3, %15
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %24 = load %struct.LexState*, %struct.LexState** %23, align 8, !tbaa !276
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %24, i64 0, i32 6
  %26 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !259
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %28 = bitcast %struct.AbsLineInfo** %27 to i8**
  %29 = load i8*, i8** %28, align 8, !tbaa !223
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %31 = load i32, i32* %30, align 4, !tbaa !281
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  %33 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %26, i8* %29, i32 %31, i32* nonnull %32, i32 8, i32 2147483647, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i64 0, i64 0)) #16
  %34 = bitcast i8* %33 to %struct.AbsLineInfo*
  store i8* %33, i8** %28, align 8, !tbaa !223
  %35 = load i32, i32* %30, align 4, !tbaa !281
  %36 = sext i32 %35 to i64
  %37 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %34, i64 %36, i32 0
  store i32 %9, i32* %37, align 4, !tbaa !236
  %38 = add nsw i32 %35, 1
  store i32 %38, i32* %30, align 4, !tbaa !281
  %39 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %34, i64 %36, i32 1
  store i32 %2, i32* %39, align 4, !tbaa !274
  store i8 0, i8* %14, align 1, !tbaa !299
  br label %40

; <label>:40:                                     ; preds = %19, %22
  %41 = phi %struct.LexState** [ %20, %19 ], [ %23, %22 ]
  %42 = phi i8 [ %21, %19 ], [ -128, %22 ]
  %43 = load %struct.LexState*, %struct.LexState** %41, align 8, !tbaa !276
  %44 = getelementptr inbounds %struct.LexState, %struct.LexState* %43, i64 0, i32 6
  %45 = load %struct.lua_State*, %struct.lua_State** %44, align 8, !tbaa !259
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  %47 = load i8*, i8** %46, align 8, !tbaa !124
  %48 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  %49 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %45, i8* %47, i32 %9, i32* nonnull %48, i32 1, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0)) #16
  store i8* %49, i8** %46, align 8, !tbaa !124
  %50 = sext i32 %9 to i64
  %51 = getelementptr inbounds i8, i8* %49, i64 %50
  store i8 %42, i8* %51, align 1, !tbaa !21
  store i32 %2, i32* %4, align 8, !tbaa !278
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checklimit(%struct.FuncState* nocapture readonly, i32, i32, i8*) unnamed_addr #0 {
  %5 = icmp sgt i32 %1, %2
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call fastcc void @errorlimit(%struct.FuncState* %0, i32 %2, i8* %3) #18
  unreachable

; <label>:7:                                      ; preds = %4
  ret void
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @errorlimit(%struct.FuncState* nocapture readonly, i32, i8*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !276
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !259
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 13
  %11 = load i32, i32* %10, align 4, !tbaa !110
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %3
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.227, i64 0, i64 0), i32 %11) #16
  br label %15

; <label>:15:                                     ; preds = %3, %13
  %16 = phi i8* [ %14, %13 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.226, i64 0, i64 0), %3 ]
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.228, i64 0, i64 0), i8* %2, i32 %1, i8* %16) #16
  %18 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !276
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %18, i8* %17) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaX_syntaxerror(%struct.LexState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !258
  tail call fastcc void @lexerror(%struct.LexState* %0, i8* %1, i32 %4) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @lexerror(%struct.LexState* nocapture readonly, i8*, i32) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !259
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %7 = load %struct.TString*, %struct.TString** %6, align 8, !tbaa !266
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !264
  %10 = tail call fastcc i8* @luaG_addinfo(%struct.lua_State* %5, i8* %1, %struct.TString* %7, i32 %9) #16
  %11 = icmp eq i32 %2, 0
  br i1 %11, label %28, label %12

; <label>:12:                                     ; preds = %3
  %13 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !259
  %14 = add i32 %2, -290
  %15 = icmp ult i32 %14, 4
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %12
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 0) #17
  %17 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !259
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %19 = load %struct.Mbuffer*, %struct.Mbuffer** %18, align 8, !tbaa !253
  %20 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %19, i64 0, i32 0
  %21 = load i8*, i8** %20, align 8, !tbaa !268
  %22 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %17, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %21) #17
  br label %25

; <label>:23:                                     ; preds = %12
  %24 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %2) #17
  br label %25

; <label>:25:                                     ; preds = %16, %23
  %26 = phi i8* [ %22, %16 ], [ %24, %23 ]
  %27 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.229, i64 0, i64 0), i8* %10, i8* %26) #16
  br label %28

; <label>:28:                                     ; preds = %3, %25
  %29 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !259
  tail call fastcc void @luaD_throw(%struct.lua_State* %29, i32 3) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @save(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %4 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %5 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 1
  %6 = load i64, i64* %5, align 8, !tbaa !300
  %7 = add i64 %6, 1
  %8 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 2
  %9 = load i64, i64* %8, align 8, !tbaa !269
  %10 = icmp ugt i64 %7, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %13 = load i8*, i8** %12, align 8, !tbaa !268
  br label %26

; <label>:14:                                     ; preds = %2
  %15 = icmp ugt i64 %9, 4611686018427387902
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %14
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.231, i64 0, i64 0), i32 0) #18
  unreachable

; <label>:17:                                     ; preds = %14
  %18 = shl i64 %9, 1
  %19 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %20 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !259
  %21 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %22 = load i8*, i8** %21, align 8, !tbaa !268
  %23 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %20, i8* %22, i64 %9, i64 %18) #16
  store i8* %23, i8** %21, align 8, !tbaa !268
  store i64 %18, i64* %8, align 8, !tbaa !269
  %24 = load i64, i64* %5, align 8, !tbaa !300
  %25 = add i64 %24, 1
  br label %26

; <label>:26:                                     ; preds = %11, %17
  %27 = phi i64 [ %7, %11 ], [ %25, %17 ]
  %28 = phi i64 [ %6, %11 ], [ %24, %17 ]
  %29 = phi i8* [ %13, %11 ], [ %23, %17 ]
  %30 = trunc i32 %1 to i8
  store i64 %27, i64* %5, align 8, !tbaa !300
  %31 = getelementptr inbounds i8, i8* %29, i64 %28
  store i8 %30, i8* %31, align 1, !tbaa !21
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaX_token2str(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = icmp slt i32 %1, 257
  br i1 %3, label %4, label %15

; <label>:4:                                      ; preds = %2
  %5 = add nsw i32 %1, 1
  %6 = sext i32 %5 to i64
  %7 = add nsw i64 %6, -33
  %8 = icmp ult i64 %7, 95
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !259
  br i1 %8, label %11, label %13

; <label>:11:                                     ; preds = %4
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.232, i64 0, i64 0), i32 %1) #16
  br label %25

; <label>:13:                                     ; preds = %4
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.233, i64 0, i64 0), i32 %1) #16
  br label %25

; <label>:15:                                     ; preds = %2
  %16 = add nsw i32 %1, -257
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %17
  %19 = load i8*, i8** %18, align 8, !tbaa !39
  %20 = icmp slt i32 %1, 289
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !259
  %24 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %23, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %19) #16
  br label %25

; <label>:25:                                     ; preds = %21, %15, %13, %11
  %26 = phi i8* [ %12, %11 ], [ %14, %13 ], [ %24, %21 ], [ %19, %15 ]
  ret i8* %26
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @llex(%struct.LexState*, %union.SemInfo*) unnamed_addr #0 {
  %3 = alloca [8 x i8], align 1
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %5 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %6 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %5, i64 0, i32 1
  store i64 0, i64* %6, align 8, !tbaa !300
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  br label %9

; <label>:9:                                      ; preds = %74, %2
  %10 = load i32, i32* %7, align 8, !tbaa !260
  switch i32 %10, label %558 [
    i32 10, label %11
    i32 13, label %11
    i32 32, label %12
    i32 12, label %12
    i32 9, label %12
    i32 11, label %12
    i32 45, label %28
    i32 91, label %93
    i32 61, label %100
    i32 60, label %119
    i32 62, label %141
    i32 47, label %163
    i32 126, label %182
    i32 58, label %201
    i32 34, label %220
    i32 39, label %220
    i32 46, label %526
    i32 48, label %556
    i32 49, label %556
    i32 50, label %556
    i32 51, label %556
    i32 52, label %556
    i32 53, label %556
    i32 54, label %556
    i32 55, label %556
    i32 56, label %556
    i32 57, label %556
    i32 -1, label %623
  ]

; <label>:11:                                     ; preds = %9, %9
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br label %74

; <label>:12:                                     ; preds = %9, %9, %9, %9
  %13 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !242
  %16 = add i64 %15, -1
  store i64 %16, i64* %14, align 8, !tbaa !242
  %17 = icmp eq i64 %15, 0
  br i1 %17, label %24, label %18

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 1
  %20 = load i8*, i8** %19, align 8, !tbaa !243
  %21 = getelementptr inbounds i8, i8* %20, i64 1
  store i8* %21, i8** %19, align 8, !tbaa !243
  %22 = load i8, i8* %20, align 1, !tbaa !21
  %23 = zext i8 %22 to i32
  br label %26

; <label>:24:                                     ; preds = %12
  %25 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %13) #16
  br label %26

; <label>:26:                                     ; preds = %24, %18
  %27 = phi i32 [ %23, %18 ], [ %25, %24 ]
  store i32 %27, i32* %7, align 8, !tbaa !260
  br label %74

; <label>:28:                                     ; preds = %9
  %29 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %30 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !242
  %32 = add i64 %31, -1
  store i64 %32, i64* %30, align 8, !tbaa !242
  %33 = icmp eq i64 %31, 0
  br i1 %33, label %40, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 1
  %36 = load i8*, i8** %35, align 8, !tbaa !243
  %37 = getelementptr inbounds i8, i8* %36, i64 1
  store i8* %37, i8** %35, align 8, !tbaa !243
  %38 = load i8, i8* %36, align 1, !tbaa !21
  %39 = zext i8 %38 to i32
  br label %42

; <label>:40:                                     ; preds = %28
  %41 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %29) #16
  br label %42

; <label>:42:                                     ; preds = %40, %34
  %43 = phi i32 [ %39, %34 ], [ %41, %40 ]
  store i32 %43, i32* %7, align 8, !tbaa !260
  %44 = icmp eq i32 %43, 45
  br i1 %44, label %45, label %623

; <label>:45:                                     ; preds = %42
  %46 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %47 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 0
  %48 = load i64, i64* %47, align 8, !tbaa !242
  %49 = add i64 %48, -1
  store i64 %49, i64* %47, align 8, !tbaa !242
  %50 = icmp eq i64 %48, 0
  br i1 %50, label %57, label %51

; <label>:51:                                     ; preds = %45
  %52 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 1
  %53 = load i8*, i8** %52, align 8, !tbaa !243
  %54 = getelementptr inbounds i8, i8* %53, i64 1
  store i8* %54, i8** %52, align 8, !tbaa !243
  %55 = load i8, i8* %53, align 1, !tbaa !21
  %56 = zext i8 %55 to i32
  br label %59

; <label>:57:                                     ; preds = %45
  %58 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %46) #16
  br label %59

; <label>:59:                                     ; preds = %57, %51
  %60 = phi i32 [ %56, %51 ], [ %58, %57 ]
  store i32 %60, i32* %7, align 8, !tbaa !260
  %61 = icmp eq i32 %60, 91
  br i1 %61, label %64, label %62

; <label>:62:                                     ; preds = %69, %59
  %63 = phi i32 [ %60, %59 ], [ %70, %69 ]
  br label %75

; <label>:64:                                     ; preds = %59
  %65 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %66 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %67 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %66, i64 0, i32 1
  store i64 0, i64* %67, align 8, !tbaa !300
  %68 = icmp ugt i64 %65, 1
  br i1 %68, label %71, label %69

; <label>:69:                                     ; preds = %64
  %70 = load i32, i32* %7, align 8, !tbaa !260
  br label %62

; <label>:71:                                     ; preds = %64
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* null, i64 %65) #16
  %72 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %73 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %72, i64 0, i32 1
  store i64 0, i64* %73, align 8, !tbaa !300
  br label %74

; <label>:74:                                     ; preds = %75, %75, %75, %71, %26, %11
  br label %9

; <label>:75:                                     ; preds = %62, %91
  %76 = phi i32 [ %92, %91 ], [ %63, %62 ]
  switch i32 %76, label %77 [
    i32 10, label %74
    i32 13, label %74
    i32 -1, label %74
  ]

; <label>:77:                                     ; preds = %75
  %78 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %79 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 0
  %80 = load i64, i64* %79, align 8, !tbaa !242
  %81 = add i64 %80, -1
  store i64 %81, i64* %79, align 8, !tbaa !242
  %82 = icmp eq i64 %80, 0
  br i1 %82, label %89, label %83

; <label>:83:                                     ; preds = %77
  %84 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 1
  %85 = load i8*, i8** %84, align 8, !tbaa !243
  %86 = getelementptr inbounds i8, i8* %85, i64 1
  store i8* %86, i8** %84, align 8, !tbaa !243
  %87 = load i8, i8* %85, align 1, !tbaa !21
  %88 = zext i8 %87 to i32
  br label %91

; <label>:89:                                     ; preds = %77
  %90 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %78) #16
  br label %91

; <label>:91:                                     ; preds = %89, %83
  %92 = phi i32 [ %88, %83 ], [ %90, %89 ]
  store i32 %92, i32* %7, align 8, !tbaa !260
  br label %75

; <label>:93:                                     ; preds = %9
  %94 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %95 = icmp ugt i64 %94, 1
  br i1 %95, label %96, label %97

; <label>:96:                                     ; preds = %93
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* %1, i64 %94) #16
  br label %623

; <label>:97:                                     ; preds = %93
  %98 = icmp eq i64 %94, 0
  br i1 %98, label %99, label %623

; <label>:99:                                     ; preds = %97
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.234, i64 0, i64 0), i32 293) #18
  unreachable

; <label>:100:                                    ; preds = %9
  %101 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %102 = getelementptr inbounds %struct.Zio, %struct.Zio* %101, i64 0, i32 0
  %103 = load i64, i64* %102, align 8, !tbaa !242
  %104 = add i64 %103, -1
  store i64 %104, i64* %102, align 8, !tbaa !242
  %105 = icmp eq i64 %103, 0
  br i1 %105, label %112, label %106

; <label>:106:                                    ; preds = %100
  %107 = getelementptr inbounds %struct.Zio, %struct.Zio* %101, i64 0, i32 1
  %108 = load i8*, i8** %107, align 8, !tbaa !243
  %109 = getelementptr inbounds i8, i8* %108, i64 1
  store i8* %109, i8** %107, align 8, !tbaa !243
  %110 = load i8, i8* %108, align 1, !tbaa !21
  %111 = zext i8 %110 to i32
  br label %114

; <label>:112:                                    ; preds = %100
  %113 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %101) #16
  br label %114

; <label>:114:                                    ; preds = %112, %106
  %115 = phi i32 [ %111, %106 ], [ %113, %112 ]
  store i32 %115, i32* %7, align 8, !tbaa !260
  %116 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %117 = icmp eq i32 %116, 0
  %118 = select i1 %117, i32 61, i32 282
  br label %623

; <label>:119:                                    ; preds = %9
  %120 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %121 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 0
  %122 = load i64, i64* %121, align 8, !tbaa !242
  %123 = add i64 %122, -1
  store i64 %123, i64* %121, align 8, !tbaa !242
  %124 = icmp eq i64 %122, 0
  br i1 %124, label %131, label %125

; <label>:125:                                    ; preds = %119
  %126 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 1
  %127 = load i8*, i8** %126, align 8, !tbaa !243
  %128 = getelementptr inbounds i8, i8* %127, i64 1
  store i8* %128, i8** %126, align 8, !tbaa !243
  %129 = load i8, i8* %127, align 1, !tbaa !21
  %130 = zext i8 %129 to i32
  br label %133

; <label>:131:                                    ; preds = %119
  %132 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %120) #16
  br label %133

; <label>:133:                                    ; preds = %131, %125
  %134 = phi i32 [ %130, %125 ], [ %132, %131 ]
  store i32 %134, i32* %7, align 8, !tbaa !260
  %135 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %136 = icmp eq i32 %135, 0
  br i1 %136, label %137, label %623

; <label>:137:                                    ; preds = %133
  %138 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 60) #16
  %139 = icmp eq i32 %138, 0
  %140 = select i1 %139, i32 60, i32 286
  br label %623

; <label>:141:                                    ; preds = %9
  %142 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %143 = getelementptr inbounds %struct.Zio, %struct.Zio* %142, i64 0, i32 0
  %144 = load i64, i64* %143, align 8, !tbaa !242
  %145 = add i64 %144, -1
  store i64 %145, i64* %143, align 8, !tbaa !242
  %146 = icmp eq i64 %144, 0
  br i1 %146, label %153, label %147

; <label>:147:                                    ; preds = %141
  %148 = getelementptr inbounds %struct.Zio, %struct.Zio* %142, i64 0, i32 1
  %149 = load i8*, i8** %148, align 8, !tbaa !243
  %150 = getelementptr inbounds i8, i8* %149, i64 1
  store i8* %150, i8** %148, align 8, !tbaa !243
  %151 = load i8, i8* %149, align 1, !tbaa !21
  %152 = zext i8 %151 to i32
  br label %155

; <label>:153:                                    ; preds = %141
  %154 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %142) #16
  br label %155

; <label>:155:                                    ; preds = %153, %147
  %156 = phi i32 [ %152, %147 ], [ %154, %153 ]
  store i32 %156, i32* %7, align 8, !tbaa !260
  %157 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %158 = icmp eq i32 %157, 0
  br i1 %158, label %159, label %623

; <label>:159:                                    ; preds = %155
  %160 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 62) #16
  %161 = icmp eq i32 %160, 0
  %162 = select i1 %161, i32 62, i32 287
  br label %623

; <label>:163:                                    ; preds = %9
  %164 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %165 = getelementptr inbounds %struct.Zio, %struct.Zio* %164, i64 0, i32 0
  %166 = load i64, i64* %165, align 8, !tbaa !242
  %167 = add i64 %166, -1
  store i64 %167, i64* %165, align 8, !tbaa !242
  %168 = icmp eq i64 %166, 0
  br i1 %168, label %175, label %169

; <label>:169:                                    ; preds = %163
  %170 = getelementptr inbounds %struct.Zio, %struct.Zio* %164, i64 0, i32 1
  %171 = load i8*, i8** %170, align 8, !tbaa !243
  %172 = getelementptr inbounds i8, i8* %171, i64 1
  store i8* %172, i8** %170, align 8, !tbaa !243
  %173 = load i8, i8* %171, align 1, !tbaa !21
  %174 = zext i8 %173 to i32
  br label %177

; <label>:175:                                    ; preds = %163
  %176 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %164) #16
  br label %177

; <label>:177:                                    ; preds = %175, %169
  %178 = phi i32 [ %174, %169 ], [ %176, %175 ]
  store i32 %178, i32* %7, align 8, !tbaa !260
  %179 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 47) #16
  %180 = icmp eq i32 %179, 0
  %181 = select i1 %180, i32 47, i32 279
  br label %623

; <label>:182:                                    ; preds = %9
  %183 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %184 = getelementptr inbounds %struct.Zio, %struct.Zio* %183, i64 0, i32 0
  %185 = load i64, i64* %184, align 8, !tbaa !242
  %186 = add i64 %185, -1
  store i64 %186, i64* %184, align 8, !tbaa !242
  %187 = icmp eq i64 %185, 0
  br i1 %187, label %194, label %188

; <label>:188:                                    ; preds = %182
  %189 = getelementptr inbounds %struct.Zio, %struct.Zio* %183, i64 0, i32 1
  %190 = load i8*, i8** %189, align 8, !tbaa !243
  %191 = getelementptr inbounds i8, i8* %190, i64 1
  store i8* %191, i8** %189, align 8, !tbaa !243
  %192 = load i8, i8* %190, align 1, !tbaa !21
  %193 = zext i8 %192 to i32
  br label %196

; <label>:194:                                    ; preds = %182
  %195 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %183) #16
  br label %196

; <label>:196:                                    ; preds = %194, %188
  %197 = phi i32 [ %193, %188 ], [ %195, %194 ]
  store i32 %197, i32* %7, align 8, !tbaa !260
  %198 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %199 = icmp eq i32 %198, 0
  %200 = select i1 %199, i32 126, i32 285
  br label %623

; <label>:201:                                    ; preds = %9
  %202 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %203 = getelementptr inbounds %struct.Zio, %struct.Zio* %202, i64 0, i32 0
  %204 = load i64, i64* %203, align 8, !tbaa !242
  %205 = add i64 %204, -1
  store i64 %205, i64* %203, align 8, !tbaa !242
  %206 = icmp eq i64 %204, 0
  br i1 %206, label %213, label %207

; <label>:207:                                    ; preds = %201
  %208 = getelementptr inbounds %struct.Zio, %struct.Zio* %202, i64 0, i32 1
  %209 = load i8*, i8** %208, align 8, !tbaa !243
  %210 = getelementptr inbounds i8, i8* %209, i64 1
  store i8* %210, i8** %208, align 8, !tbaa !243
  %211 = load i8, i8* %209, align 1, !tbaa !21
  %212 = zext i8 %211 to i32
  br label %215

; <label>:213:                                    ; preds = %201
  %214 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %202) #16
  br label %215

; <label>:215:                                    ; preds = %213, %207
  %216 = phi i32 [ %212, %207 ], [ %214, %213 ]
  store i32 %216, i32* %7, align 8, !tbaa !260
  %217 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 58) #16
  %218 = icmp eq i32 %217, 0
  %219 = select i1 %218, i32 58, i32 288
  br label %623

; <label>:220:                                    ; preds = %9, %9
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %10) #17
  %221 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %222 = getelementptr inbounds %struct.Zio, %struct.Zio* %221, i64 0, i32 0
  %223 = load i64, i64* %222, align 8, !tbaa !242
  %224 = add i64 %223, -1
  store i64 %224, i64* %222, align 8, !tbaa !242
  %225 = icmp eq i64 %223, 0
  br i1 %225, label %232, label %226

; <label>:226:                                    ; preds = %220
  %227 = getelementptr inbounds %struct.Zio, %struct.Zio* %221, i64 0, i32 1
  %228 = load i8*, i8** %227, align 8, !tbaa !243
  %229 = getelementptr inbounds i8, i8* %228, i64 1
  store i8* %229, i8** %227, align 8, !tbaa !243
  %230 = load i8, i8* %228, align 1, !tbaa !21
  %231 = zext i8 %230 to i32
  br label %234

; <label>:232:                                    ; preds = %220
  %233 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %221) #17
  br label %234

; <label>:234:                                    ; preds = %232, %226
  %235 = phi i32 [ %231, %226 ], [ %233, %232 ]
  store i32 %235, i32* %7, align 8, !tbaa !260
  %236 = getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 0
  br label %237

; <label>:237:                                    ; preds = %499, %234
  %238 = phi i32 [ %500, %499 ], [ %235, %234 ]
  %239 = icmp eq i32 %238, %10
  br i1 %239, label %501, label %240

; <label>:240:                                    ; preds = %237
  switch i32 %238, label %483 [
    i32 -1, label %241
    i32 10, label %242
    i32 13, label %242
    i32 92, label %243
  ]

; <label>:241:                                    ; preds = %240
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 289) #19
  unreachable

; <label>:242:                                    ; preds = %240, %240
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 293) #19
  unreachable

; <label>:243:                                    ; preds = %240
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 92) #17
  %244 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %245 = getelementptr inbounds %struct.Zio, %struct.Zio* %244, i64 0, i32 0
  %246 = load i64, i64* %245, align 8, !tbaa !242
  %247 = add i64 %246, -1
  store i64 %247, i64* %245, align 8, !tbaa !242
  %248 = icmp eq i64 %246, 0
  br i1 %248, label %255, label %249

; <label>:249:                                    ; preds = %243
  %250 = getelementptr inbounds %struct.Zio, %struct.Zio* %244, i64 0, i32 1
  %251 = load i8*, i8** %250, align 8, !tbaa !243
  %252 = getelementptr inbounds i8, i8* %251, i64 1
  store i8* %252, i8** %250, align 8, !tbaa !243
  %253 = load i8, i8* %251, align 1, !tbaa !21
  %254 = zext i8 %253 to i32
  br label %257

; <label>:255:                                    ; preds = %243
  %256 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %244) #17
  br label %257

; <label>:257:                                    ; preds = %255, %249
  %258 = phi i32 [ %254, %249 ], [ %256, %255 ]
  store i32 %258, i32* %7, align 8, !tbaa !260
  switch i32 %258, label %415 [
    i32 97, label %460
    i32 98, label %259
    i32 102, label %260
    i32 110, label %261
    i32 114, label %262
    i32 116, label %263
    i32 118, label %264
    i32 120, label %265
    i32 117, label %274
    i32 10, label %364
    i32 13, label %364
    i32 92, label %365
    i32 34, label %365
    i32 39, label %365
    i32 -1, label %499
    i32 122, label %366
  ]

; <label>:259:                                    ; preds = %257
  br label %460

; <label>:260:                                    ; preds = %257
  br label %460

; <label>:261:                                    ; preds = %257
  br label %460

; <label>:262:                                    ; preds = %257
  br label %460

; <label>:263:                                    ; preds = %257
  br label %460

; <label>:264:                                    ; preds = %257
  br label %460

; <label>:265:                                    ; preds = %257
  %266 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %267 = shl i32 %266, 4
  %268 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %269 = add nsw i32 %267, %268
  %270 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %271 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %270, i64 0, i32 1
  %272 = load i64, i64* %271, align 8, !tbaa !300
  %273 = add i64 %272, -2
  store i64 %273, i64* %271, align 8, !tbaa !300
  br label %460

; <label>:274:                                    ; preds = %257
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %236) #7
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 117) #17
  %275 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %276 = getelementptr inbounds %struct.Zio, %struct.Zio* %275, i64 0, i32 0
  %277 = load i64, i64* %276, align 8, !tbaa !242
  %278 = add i64 %277, -1
  store i64 %278, i64* %276, align 8, !tbaa !242
  %279 = icmp eq i64 %277, 0
  br i1 %279, label %286, label %280

; <label>:280:                                    ; preds = %274
  %281 = getelementptr inbounds %struct.Zio, %struct.Zio* %275, i64 0, i32 1
  %282 = load i8*, i8** %281, align 8, !tbaa !243
  %283 = getelementptr inbounds i8, i8* %282, i64 1
  store i8* %283, i8** %281, align 8, !tbaa !243
  %284 = load i8, i8* %282, align 1, !tbaa !21
  %285 = zext i8 %284 to i32
  br label %288

; <label>:286:                                    ; preds = %274
  %287 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %275) #17
  br label %288

; <label>:288:                                    ; preds = %286, %280
  %289 = phi i32 [ %285, %280 ], [ %287, %286 ]
  store i32 %289, i32* %7, align 8, !tbaa !260
  %290 = icmp eq i32 %289, 123
  %291 = zext i1 %290 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %291, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.241, i64 0, i64 0)) #17
  %292 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %293 = sext i32 %292 to i64
  %294 = load i32, i32* %7, align 8, !tbaa !260
  br label %295

; <label>:295:                                    ; preds = %320, %288
  %296 = phi i32 [ %294, %288 ], [ %325, %320 ]
  %297 = phi i64 [ %293, %288 ], [ %328, %320 ]
  %298 = phi i32 [ 4, %288 ], [ %321, %320 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %296) #17
  %299 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %300 = getelementptr inbounds %struct.Zio, %struct.Zio* %299, i64 0, i32 0
  %301 = load i64, i64* %300, align 8, !tbaa !242
  %302 = add i64 %301, -1
  store i64 %302, i64* %300, align 8, !tbaa !242
  %303 = icmp eq i64 %301, 0
  br i1 %303, label %310, label %304

; <label>:304:                                    ; preds = %295
  %305 = getelementptr inbounds %struct.Zio, %struct.Zio* %299, i64 0, i32 1
  %306 = load i8*, i8** %305, align 8, !tbaa !243
  %307 = getelementptr inbounds i8, i8* %306, i64 1
  store i8* %307, i8** %305, align 8, !tbaa !243
  %308 = load i8, i8* %306, align 1, !tbaa !21
  %309 = zext i8 %308 to i32
  br label %312

; <label>:310:                                    ; preds = %295
  %311 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %299) #17
  br label %312

; <label>:312:                                    ; preds = %310, %304
  %313 = phi i32 [ %309, %304 ], [ %311, %310 ]
  store i32 %313, i32* %7, align 8, !tbaa !260
  %314 = add nsw i32 %313, 1
  %315 = sext i32 %314 to i64
  %316 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %315
  %317 = load i8, i8* %316, align 1, !tbaa !21
  %318 = and i8 %317, 16
  %319 = icmp eq i8 %318, 0
  br i1 %319, label %329, label %320

; <label>:320:                                    ; preds = %312
  %321 = add nuw nsw i32 %298, 1
  %322 = icmp ult i64 %297, 134217728
  %323 = zext i1 %322 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %323, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.242, i64 0, i64 0)) #17
  %324 = shl i64 %297, 4
  %325 = load i32, i32* %7, align 8, !tbaa !260
  %326 = tail call fastcc i32 @luaO_hexavalue(i32 %325) #17
  %327 = sext i32 %326 to i64
  %328 = add i64 %324, %327
  br label %295

; <label>:329:                                    ; preds = %312
  %330 = icmp eq i32 %313, 125
  %331 = zext i1 %330 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %331, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.243, i64 0, i64 0)) #17
  %332 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %333 = getelementptr inbounds %struct.Zio, %struct.Zio* %332, i64 0, i32 0
  %334 = load i64, i64* %333, align 8, !tbaa !242
  %335 = add i64 %334, -1
  store i64 %335, i64* %333, align 8, !tbaa !242
  %336 = icmp eq i64 %334, 0
  br i1 %336, label %343, label %337

; <label>:337:                                    ; preds = %329
  %338 = getelementptr inbounds %struct.Zio, %struct.Zio* %332, i64 0, i32 1
  %339 = load i8*, i8** %338, align 8, !tbaa !243
  %340 = getelementptr inbounds i8, i8* %339, i64 1
  store i8* %340, i8** %338, align 8, !tbaa !243
  %341 = load i8, i8* %339, align 1, !tbaa !21
  %342 = zext i8 %341 to i32
  br label %345

; <label>:343:                                    ; preds = %329
  %344 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %332) #17
  br label %345

; <label>:345:                                    ; preds = %343, %337
  %346 = phi i32 [ %342, %337 ], [ %344, %343 ]
  store i32 %346, i32* %7, align 8, !tbaa !260
  %347 = zext i32 %298 to i64
  %348 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %349 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %348, i64 0, i32 1
  %350 = load i64, i64* %349, align 8, !tbaa !300
  %351 = sub i64 %350, %347
  store i64 %351, i64* %349, align 8, !tbaa !300
  %352 = call fastcc i32 @luaO_utf8esc(i8* nonnull %236, i64 %297) #17
  %353 = sext i32 %352 to i64
  br label %354

; <label>:354:                                    ; preds = %357, %345
  %355 = phi i64 [ %362, %357 ], [ %353, %345 ]
  %356 = icmp sgt i64 %355, 0
  br i1 %356, label %357, label %363

; <label>:357:                                    ; preds = %354
  %358 = sub nsw i64 8, %355
  %359 = getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 %358
  %360 = load i8, i8* %359, align 1, !tbaa !21
  %361 = sext i8 %360 to i32
  tail call fastcc void @save(%struct.LexState* %0, i32 %361) #17
  %362 = add nsw i64 %355, -1
  br label %354

; <label>:363:                                    ; preds = %354
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %236) #7
  br label %499

; <label>:364:                                    ; preds = %257, %257
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #17
  br label %477

; <label>:365:                                    ; preds = %257, %257, %257
  br label %460

; <label>:366:                                    ; preds = %257
  %367 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %368 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %367, i64 0, i32 1
  %369 = load i64, i64* %368, align 8, !tbaa !300
  %370 = add i64 %369, -1
  store i64 %370, i64* %368, align 8, !tbaa !300
  %371 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %372 = getelementptr inbounds %struct.Zio, %struct.Zio* %371, i64 0, i32 0
  %373 = load i64, i64* %372, align 8, !tbaa !242
  %374 = add i64 %373, -1
  store i64 %374, i64* %372, align 8, !tbaa !242
  %375 = icmp eq i64 %373, 0
  br i1 %375, label %382, label %376

; <label>:376:                                    ; preds = %366
  %377 = getelementptr inbounds %struct.Zio, %struct.Zio* %371, i64 0, i32 1
  %378 = load i8*, i8** %377, align 8, !tbaa !243
  %379 = getelementptr inbounds i8, i8* %378, i64 1
  store i8* %379, i8** %377, align 8, !tbaa !243
  %380 = load i8, i8* %378, align 1, !tbaa !21
  %381 = zext i8 %380 to i32
  br label %384

; <label>:382:                                    ; preds = %366
  %383 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %371) #17
  br label %384

; <label>:384:                                    ; preds = %382, %376
  %385 = phi i32 [ %381, %376 ], [ %383, %382 ]
  store i32 %385, i32* %7, align 8, !tbaa !260
  br label %386

; <label>:386:                                    ; preds = %413, %384
  %387 = phi i32 [ %385, %384 ], [ %414, %413 ]
  %388 = add nsw i32 %387, 1
  %389 = sext i32 %388 to i64
  %390 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %389
  %391 = load i8, i8* %390, align 1, !tbaa !21
  %392 = and i8 %391, 8
  %393 = icmp eq i8 %392, 0
  br i1 %393, label %499, label %394

; <label>:394:                                    ; preds = %386
  switch i32 %387, label %397 [
    i32 10, label %395
    i32 13, label %395
  ]

; <label>:395:                                    ; preds = %394, %394
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #17
  %396 = load i32, i32* %7, align 8, !tbaa !260
  br label %413

; <label>:397:                                    ; preds = %394
  %398 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %399 = getelementptr inbounds %struct.Zio, %struct.Zio* %398, i64 0, i32 0
  %400 = load i64, i64* %399, align 8, !tbaa !242
  %401 = add i64 %400, -1
  store i64 %401, i64* %399, align 8, !tbaa !242
  %402 = icmp eq i64 %400, 0
  br i1 %402, label %409, label %403

; <label>:403:                                    ; preds = %397
  %404 = getelementptr inbounds %struct.Zio, %struct.Zio* %398, i64 0, i32 1
  %405 = load i8*, i8** %404, align 8, !tbaa !243
  %406 = getelementptr inbounds i8, i8* %405, i64 1
  store i8* %406, i8** %404, align 8, !tbaa !243
  %407 = load i8, i8* %405, align 1, !tbaa !21
  %408 = zext i8 %407 to i32
  br label %411

; <label>:409:                                    ; preds = %397
  %410 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %398) #17
  br label %411

; <label>:411:                                    ; preds = %409, %403
  %412 = phi i32 [ %408, %403 ], [ %410, %409 ]
  store i32 %412, i32* %7, align 8, !tbaa !260
  br label %413

; <label>:413:                                    ; preds = %411, %395
  %414 = phi i32 [ %412, %411 ], [ %396, %395 ]
  br label %386

; <label>:415:                                    ; preds = %257
  %416 = add nsw i32 %258, 1
  %417 = sext i32 %416 to i64
  %418 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %417
  %419 = load i8, i8* %418, align 1, !tbaa !21
  %420 = and i8 %419, 2
  %421 = zext i8 %420 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %421, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.239, i64 0, i64 0)) #17
  br label %422

; <label>:422:                                    ; preds = %449, %415
  %423 = phi i32 [ 0, %415 ], [ %451, %449 ]
  %424 = phi i32 [ 0, %415 ], [ %435, %449 ]
  %425 = icmp ult i32 %423, 3
  br i1 %425, label %426, label %452

; <label>:426:                                    ; preds = %422
  %427 = load i32, i32* %7, align 8, !tbaa !260
  %428 = add nsw i32 %427, 1
  %429 = sext i32 %428 to i64
  %430 = add nsw i64 %429, -49
  %431 = icmp ult i64 %430, 10
  br i1 %431, label %432, label %452

; <label>:432:                                    ; preds = %426
  %433 = mul nsw i32 %424, 10
  %434 = add i32 %433, -48
  %435 = add i32 %434, %427
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %427) #17
  %436 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %437 = getelementptr inbounds %struct.Zio, %struct.Zio* %436, i64 0, i32 0
  %438 = load i64, i64* %437, align 8, !tbaa !242
  %439 = add i64 %438, -1
  store i64 %439, i64* %437, align 8, !tbaa !242
  %440 = icmp eq i64 %438, 0
  br i1 %440, label %447, label %441

; <label>:441:                                    ; preds = %432
  %442 = getelementptr inbounds %struct.Zio, %struct.Zio* %436, i64 0, i32 1
  %443 = load i8*, i8** %442, align 8, !tbaa !243
  %444 = getelementptr inbounds i8, i8* %443, i64 1
  store i8* %444, i8** %442, align 8, !tbaa !243
  %445 = load i8, i8* %443, align 1, !tbaa !21
  %446 = zext i8 %445 to i32
  br label %449

; <label>:447:                                    ; preds = %432
  %448 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %436) #17
  br label %449

; <label>:449:                                    ; preds = %447, %441
  %450 = phi i32 [ %446, %441 ], [ %448, %447 ]
  store i32 %450, i32* %7, align 8, !tbaa !260
  %451 = add nuw nsw i32 %423, 1
  br label %422

; <label>:452:                                    ; preds = %426, %422
  %453 = icmp slt i32 %424, 256
  %454 = zext i1 %453 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %454, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.244, i64 0, i64 0)) #17
  %455 = zext i32 %423 to i64
  %456 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %457 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %456, i64 0, i32 1
  %458 = load i64, i64* %457, align 8, !tbaa !300
  %459 = sub i64 %458, %455
  store i64 %459, i64* %457, align 8, !tbaa !300
  br label %477

; <label>:460:                                    ; preds = %365, %265, %264, %263, %262, %261, %260, %259, %257
  %461 = phi i32 [ %258, %365 ], [ %269, %265 ], [ 11, %264 ], [ 9, %263 ], [ 13, %262 ], [ 10, %261 ], [ 12, %260 ], [ 8, %259 ], [ 7, %257 ]
  %462 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %463 = getelementptr inbounds %struct.Zio, %struct.Zio* %462, i64 0, i32 0
  %464 = load i64, i64* %463, align 8, !tbaa !242
  %465 = add i64 %464, -1
  store i64 %465, i64* %463, align 8, !tbaa !242
  %466 = icmp eq i64 %464, 0
  br i1 %466, label %473, label %467

; <label>:467:                                    ; preds = %460
  %468 = getelementptr inbounds %struct.Zio, %struct.Zio* %462, i64 0, i32 1
  %469 = load i8*, i8** %468, align 8, !tbaa !243
  %470 = getelementptr inbounds i8, i8* %469, i64 1
  store i8* %470, i8** %468, align 8, !tbaa !243
  %471 = load i8, i8* %469, align 1, !tbaa !21
  %472 = zext i8 %471 to i32
  br label %475

; <label>:473:                                    ; preds = %460
  %474 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %462) #17
  br label %475

; <label>:475:                                    ; preds = %473, %467
  %476 = phi i32 [ %472, %467 ], [ %474, %473 ]
  store i32 %476, i32* %7, align 8, !tbaa !260
  br label %477

; <label>:477:                                    ; preds = %475, %452, %364
  %478 = phi i32 [ %424, %452 ], [ %461, %475 ], [ 10, %364 ]
  %479 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %480 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %479, i64 0, i32 1
  %481 = load i64, i64* %480, align 8, !tbaa !300
  %482 = add i64 %481, -1
  store i64 %482, i64* %480, align 8, !tbaa !300
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %478) #17
  br label %499

; <label>:483:                                    ; preds = %240
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %238) #17
  %484 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %485 = getelementptr inbounds %struct.Zio, %struct.Zio* %484, i64 0, i32 0
  %486 = load i64, i64* %485, align 8, !tbaa !242
  %487 = add i64 %486, -1
  store i64 %487, i64* %485, align 8, !tbaa !242
  %488 = icmp eq i64 %486, 0
  br i1 %488, label %495, label %489

; <label>:489:                                    ; preds = %483
  %490 = getelementptr inbounds %struct.Zio, %struct.Zio* %484, i64 0, i32 1
  %491 = load i8*, i8** %490, align 8, !tbaa !243
  %492 = getelementptr inbounds i8, i8* %491, i64 1
  store i8* %492, i8** %490, align 8, !tbaa !243
  %493 = load i8, i8* %491, align 1, !tbaa !21
  %494 = zext i8 %493 to i32
  br label %497

; <label>:495:                                    ; preds = %483
  %496 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %484) #17
  br label %497

; <label>:497:                                    ; preds = %495, %489
  %498 = phi i32 [ %494, %489 ], [ %496, %495 ]
  store i32 %498, i32* %7, align 8, !tbaa !260
  br label %499

; <label>:499:                                    ; preds = %386, %497, %477, %363, %257
  %500 = load i32, i32* %7, align 8, !tbaa !260
  br label %237

; <label>:501:                                    ; preds = %237
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %10) #17
  %502 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %503 = getelementptr inbounds %struct.Zio, %struct.Zio* %502, i64 0, i32 0
  %504 = load i64, i64* %503, align 8, !tbaa !242
  %505 = add i64 %504, -1
  store i64 %505, i64* %503, align 8, !tbaa !242
  %506 = icmp eq i64 %504, 0
  br i1 %506, label %513, label %507

; <label>:507:                                    ; preds = %501
  %508 = getelementptr inbounds %struct.Zio, %struct.Zio* %502, i64 0, i32 1
  %509 = load i8*, i8** %508, align 8, !tbaa !243
  %510 = getelementptr inbounds i8, i8* %509, i64 1
  store i8* %510, i8** %508, align 8, !tbaa !243
  %511 = load i8, i8* %509, align 1, !tbaa !21
  %512 = zext i8 %511 to i32
  br label %515

; <label>:513:                                    ; preds = %501
  %514 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %502) #17
  br label %515

; <label>:515:                                    ; preds = %507, %513
  %516 = phi i32 [ %512, %507 ], [ %514, %513 ]
  store i32 %516, i32* %7, align 8, !tbaa !260
  %517 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %518 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %517, i64 0, i32 0
  %519 = load i8*, i8** %518, align 8, !tbaa !268
  %520 = getelementptr inbounds i8, i8* %519, i64 1
  %521 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %517, i64 0, i32 1
  %522 = load i64, i64* %521, align 8, !tbaa !300
  %523 = add i64 %522, -2
  %524 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* nonnull %520, i64 %523) #17
  %525 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %524, %struct.TString** %525, align 8, !tbaa !21
  br label %623

; <label>:526:                                    ; preds = %9
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 46) #16
  %527 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %528 = getelementptr inbounds %struct.Zio, %struct.Zio* %527, i64 0, i32 0
  %529 = load i64, i64* %528, align 8, !tbaa !242
  %530 = add i64 %529, -1
  store i64 %530, i64* %528, align 8, !tbaa !242
  %531 = icmp eq i64 %529, 0
  br i1 %531, label %538, label %532

; <label>:532:                                    ; preds = %526
  %533 = getelementptr inbounds %struct.Zio, %struct.Zio* %527, i64 0, i32 1
  %534 = load i8*, i8** %533, align 8, !tbaa !243
  %535 = getelementptr inbounds i8, i8* %534, i64 1
  store i8* %535, i8** %533, align 8, !tbaa !243
  %536 = load i8, i8* %534, align 1, !tbaa !21
  %537 = zext i8 %536 to i32
  br label %540

; <label>:538:                                    ; preds = %526
  %539 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %527) #16
  br label %540

; <label>:540:                                    ; preds = %538, %532
  %541 = phi i32 [ %537, %532 ], [ %539, %538 ]
  store i32 %541, i32* %7, align 8, !tbaa !260
  %542 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46) #16
  %543 = icmp eq i32 %542, 0
  br i1 %543, label %548, label %544

; <label>:544:                                    ; preds = %540
  %545 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46) #16
  %546 = icmp eq i32 %545, 0
  %547 = select i1 %546, i32 280, i32 281
  br label %623

; <label>:548:                                    ; preds = %540
  %549 = load i32, i32* %7, align 8, !tbaa !260
  %550 = add nsw i32 %549, 1
  %551 = sext i32 %550 to i64
  %552 = add nsw i64 %551, -49
  %553 = icmp ult i64 %552, 10
  br i1 %553, label %554, label %623

; <label>:554:                                    ; preds = %548
  %555 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1) #16
  br label %623

; <label>:556:                                    ; preds = %9, %9, %9, %9, %9, %9, %9, %9, %9, %9
  %557 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1) #16
  br label %623

; <label>:558:                                    ; preds = %9
  %559 = add nsw i32 %10, 1
  %560 = sext i32 %559 to i64
  %561 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %560
  %562 = load i8, i8* %561, align 1, !tbaa !21
  %563 = and i8 %562, 1
  %564 = icmp eq i8 %563, 0
  br i1 %564, label %607, label %565

; <label>:565:                                    ; preds = %558
  br label %566

; <label>:566:                                    ; preds = %565, %581
  %567 = phi i32 [ %582, %581 ], [ %10, %565 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %567) #16
  %568 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %569 = getelementptr inbounds %struct.Zio, %struct.Zio* %568, i64 0, i32 0
  %570 = load i64, i64* %569, align 8, !tbaa !242
  %571 = add i64 %570, -1
  store i64 %571, i64* %569, align 8, !tbaa !242
  %572 = icmp eq i64 %570, 0
  br i1 %572, label %579, label %573

; <label>:573:                                    ; preds = %566
  %574 = getelementptr inbounds %struct.Zio, %struct.Zio* %568, i64 0, i32 1
  %575 = load i8*, i8** %574, align 8, !tbaa !243
  %576 = getelementptr inbounds i8, i8* %575, i64 1
  store i8* %576, i8** %574, align 8, !tbaa !243
  %577 = load i8, i8* %575, align 1, !tbaa !21
  %578 = zext i8 %577 to i32
  br label %581

; <label>:579:                                    ; preds = %566
  %580 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %568) #16
  br label %581

; <label>:581:                                    ; preds = %579, %573
  %582 = phi i32 [ %578, %573 ], [ %580, %579 ]
  store i32 %582, i32* %7, align 8, !tbaa !260
  %583 = add nsw i32 %582, 1
  %584 = sext i32 %583 to i64
  %585 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %584
  %586 = load i8, i8* %585, align 1, !tbaa !21
  %587 = and i8 %586, 3
  %588 = icmp eq i8 %587, 0
  br i1 %588, label %589, label %566

; <label>:589:                                    ; preds = %581
  %590 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !253
  %591 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %590, i64 0, i32 0
  %592 = load i8*, i8** %591, align 8, !tbaa !268
  %593 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %590, i64 0, i32 1
  %594 = load i64, i64* %593, align 8, !tbaa !300
  %595 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %592, i64 %594) #16
  %596 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %595, %struct.TString** %596, align 8, !tbaa !21
  %597 = getelementptr inbounds %struct.TString, %struct.TString* %595, i64 0, i32 1
  %598 = load i8, i8* %597, align 8, !tbaa !72
  %599 = icmp eq i8 %598, 20
  br i1 %599, label %600, label %623

; <label>:600:                                    ; preds = %589
  %601 = getelementptr inbounds %struct.TString, %struct.TString* %595, i64 0, i32 3
  %602 = load i8, i8* %601, align 2, !tbaa !86
  %603 = icmp eq i8 %602, 0
  br i1 %603, label %623, label %604

; <label>:604:                                    ; preds = %600
  %605 = zext i8 %602 to i32
  %606 = or i32 %605, 256
  br label %623

; <label>:607:                                    ; preds = %558
  %608 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %609 = getelementptr inbounds %struct.Zio, %struct.Zio* %608, i64 0, i32 0
  %610 = load i64, i64* %609, align 8, !tbaa !242
  %611 = add i64 %610, -1
  store i64 %611, i64* %609, align 8, !tbaa !242
  %612 = icmp eq i64 %610, 0
  br i1 %612, label %619, label %613

; <label>:613:                                    ; preds = %607
  %614 = getelementptr inbounds %struct.Zio, %struct.Zio* %608, i64 0, i32 1
  %615 = load i8*, i8** %614, align 8, !tbaa !243
  %616 = getelementptr inbounds i8, i8* %615, i64 1
  store i8* %616, i8** %614, align 8, !tbaa !243
  %617 = load i8, i8* %615, align 1, !tbaa !21
  %618 = zext i8 %617 to i32
  br label %621

; <label>:619:                                    ; preds = %607
  %620 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %608) #16
  br label %621

; <label>:621:                                    ; preds = %619, %613
  %622 = phi i32 [ %618, %613 ], [ %620, %619 ]
  store i32 %622, i32* %7, align 8, !tbaa !260
  br label %623

; <label>:623:                                    ; preds = %9, %42, %604, %600, %589, %548, %544, %215, %196, %177, %159, %155, %137, %133, %114, %96, %97, %621, %556, %554, %515
  %624 = phi i32 [ %10, %621 ], [ %557, %556 ], [ %555, %554 ], [ 293, %515 ], [ 293, %96 ], [ 91, %97 ], [ %118, %114 ], [ 284, %133 ], [ %140, %137 ], [ 283, %155 ], [ %162, %159 ], [ %181, %177 ], [ %200, %196 ], [ %219, %215 ], [ %547, %544 ], [ 46, %548 ], [ %606, %604 ], [ 292, %600 ], [ 292, %589 ], [ 289, %9 ], [ 45, %42 ]
  ret i32 %624
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @inclinenumber(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !260
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !262
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !260
  switch i32 %19, label %38 [
    i32 10, label %20
    i32 13, label %20
  ]

; <label>:20:                                     ; preds = %18, %18
  %21 = icmp eq i32 %19, %3
  br i1 %21, label %38, label %22

; <label>:22:                                     ; preds = %20
  %23 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !262
  %24 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 0
  %25 = load i64, i64* %24, align 8, !tbaa !242
  %26 = add i64 %25, -1
  store i64 %26, i64* %24, align 8, !tbaa !242
  %27 = icmp eq i64 %25, 0
  br i1 %27, label %34, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 1
  %30 = load i8*, i8** %29, align 8, !tbaa !243
  %31 = getelementptr inbounds i8, i8* %30, i64 1
  store i8* %31, i8** %29, align 8, !tbaa !243
  %32 = load i8, i8* %30, align 1, !tbaa !21
  %33 = zext i8 %32 to i32
  br label %36

; <label>:34:                                     ; preds = %22
  %35 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %23) #16
  br label %36

; <label>:36:                                     ; preds = %34, %28
  %37 = phi i32 [ %33, %28 ], [ %35, %34 ]
  store i32 %37, i32* %2, align 8, !tbaa !260
  br label %38

; <label>:38:                                     ; preds = %18, %20, %36
  %39 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %40 = load i32, i32* %39, align 4, !tbaa !264
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* %39, align 4, !tbaa !264
  %42 = icmp eq i32 %41, 2147483647
  br i1 %42, label %43, label %44

; <label>:43:                                     ; preds = %38
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.235, i64 0, i64 0), i32 0) #18
  unreachable

; <label>:44:                                     ; preds = %38
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @skip_sep(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !260
  tail call fastcc void @save(%struct.LexState* %0, i32 %3) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !262
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !260
  br label %20

; <label>:20:                                     ; preds = %38, %18
  %21 = phi i32 [ %39, %38 ], [ %19, %18 ]
  %22 = phi i64 [ %40, %38 ], [ 0, %18 ]
  %23 = icmp eq i32 %21, 61
  br i1 %23, label %24, label %41

; <label>:24:                                     ; preds = %20
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 61) #16
  %25 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !262
  %26 = getelementptr inbounds %struct.Zio, %struct.Zio* %25, i64 0, i32 0
  %27 = load i64, i64* %26, align 8, !tbaa !242
  %28 = add i64 %27, -1
  store i64 %28, i64* %26, align 8, !tbaa !242
  %29 = icmp eq i64 %27, 0
  br i1 %29, label %36, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.Zio, %struct.Zio* %25, i64 0, i32 1
  %32 = load i8*, i8** %31, align 8, !tbaa !243
  %33 = getelementptr inbounds i8, i8* %32, i64 1
  store i8* %33, i8** %31, align 8, !tbaa !243
  %34 = load i8, i8* %32, align 1, !tbaa !21
  %35 = zext i8 %34 to i32
  br label %38

; <label>:36:                                     ; preds = %24
  %37 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %25) #16
  br label %38

; <label>:38:                                     ; preds = %36, %30
  %39 = phi i32 [ %35, %30 ], [ %37, %36 ]
  store i32 %39, i32* %2, align 8, !tbaa !260
  %40 = add i64 %22, 1
  br label %20

; <label>:41:                                     ; preds = %20
  %42 = icmp eq i32 %21, %3
  %43 = add i64 %22, 2
  %44 = icmp eq i64 %22, 0
  %45 = zext i1 %44 to i64
  %46 = select i1 %42, i64 %43, i64 %45
  ret i64 %46
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @read_long_string(%struct.LexState* nocapture, %union.SemInfo*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %5 = load i32, i32* %4, align 4, !tbaa !264
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !260
  tail call fastcc void @save(%struct.LexState* %0, i32 %7) #16
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %9 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %10 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !242
  %12 = add i64 %11, -1
  store i64 %12, i64* %10, align 8, !tbaa !242
  %13 = icmp eq i64 %11, 0
  br i1 %13, label %20, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !243
  %17 = getelementptr inbounds i8, i8* %16, i64 1
  store i8* %17, i8** %15, align 8, !tbaa !243
  %18 = load i8, i8* %16, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  br label %22

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %9) #16
  br label %22

; <label>:22:                                     ; preds = %20, %14
  %23 = phi i32 [ %19, %14 ], [ %21, %20 ]
  store i32 %23, i32* %6, align 8, !tbaa !260
  switch i32 %23, label %25 [
    i32 10, label %24
    i32 13, label %24
  ]

; <label>:24:                                     ; preds = %22, %22
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br label %25

; <label>:25:                                     ; preds = %22, %24
  %26 = icmp eq %union.SemInfo* %1, null
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  br label %28

; <label>:28:                                     ; preds = %56, %25
  %29 = load i32, i32* %6, align 8, !tbaa !260
  switch i32 %29, label %60 [
    i32 -1, label %30
    i32 93, label %35
    i32 10, label %55
    i32 13, label %55
  ]

; <label>:30:                                     ; preds = %28
  %31 = select i1 %26, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.236, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i64 0, i64 0)
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %33 = load %struct.lua_State*, %struct.lua_State** %32, align 8, !tbaa !259
  %34 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %33, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.237, i64 0, i64 0), i8* %31, i32 %5) #16
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %34, i32 289) #18
  unreachable

; <label>:35:                                     ; preds = %28
  %36 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %37 = icmp eq i64 %36, %2
  br i1 %37, label %38, label %56

; <label>:38:                                     ; preds = %35
  %39 = load i32, i32* %6, align 8, !tbaa !260
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %39) #16
  %40 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %41 = getelementptr inbounds %struct.Zio, %struct.Zio* %40, i64 0, i32 0
  %42 = load i64, i64* %41, align 8, !tbaa !242
  %43 = add i64 %42, -1
  store i64 %43, i64* %41, align 8, !tbaa !242
  %44 = icmp eq i64 %42, 0
  br i1 %44, label %51, label %45

; <label>:45:                                     ; preds = %38
  %46 = getelementptr inbounds %struct.Zio, %struct.Zio* %40, i64 0, i32 1
  %47 = load i8*, i8** %46, align 8, !tbaa !243
  %48 = getelementptr inbounds i8, i8* %47, i64 1
  store i8* %48, i8** %46, align 8, !tbaa !243
  %49 = load i8, i8* %47, align 1, !tbaa !21
  %50 = zext i8 %49 to i32
  br label %53

; <label>:51:                                     ; preds = %38
  %52 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %40) #16
  br label %53

; <label>:53:                                     ; preds = %51, %45
  %54 = phi i32 [ %50, %45 ], [ %52, %51 ]
  store i32 %54, i32* %6, align 8, !tbaa !260
  br i1 %26, label %104, label %93

; <label>:55:                                     ; preds = %28, %28
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 10) #16
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br i1 %26, label %57, label %56

; <label>:56:                                     ; preds = %55, %75, %91, %57, %35
  br label %28

; <label>:57:                                     ; preds = %55
  %58 = load %struct.Mbuffer*, %struct.Mbuffer** %27, align 8, !tbaa !253
  %59 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %58, i64 0, i32 1
  store i64 0, i64* %59, align 8, !tbaa !300
  br label %56

; <label>:60:                                     ; preds = %28
  br i1 %26, label %77, label %61

; <label>:61:                                     ; preds = %60
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %29) #16
  %62 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %63 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !242
  %65 = add i64 %64, -1
  store i64 %65, i64* %63, align 8, !tbaa !242
  %66 = icmp eq i64 %64, 0
  br i1 %66, label %73, label %67

; <label>:67:                                     ; preds = %61
  %68 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 1
  %69 = load i8*, i8** %68, align 8, !tbaa !243
  %70 = getelementptr inbounds i8, i8* %69, i64 1
  store i8* %70, i8** %68, align 8, !tbaa !243
  %71 = load i8, i8* %69, align 1, !tbaa !21
  %72 = zext i8 %71 to i32
  br label %75

; <label>:73:                                     ; preds = %61
  %74 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %62) #16
  br label %75

; <label>:75:                                     ; preds = %73, %67
  %76 = phi i32 [ %72, %67 ], [ %74, %73 ]
  store i32 %76, i32* %6, align 8, !tbaa !260
  br label %56

; <label>:77:                                     ; preds = %60
  %78 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !262
  %79 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 0
  %80 = load i64, i64* %79, align 8, !tbaa !242
  %81 = add i64 %80, -1
  store i64 %81, i64* %79, align 8, !tbaa !242
  %82 = icmp eq i64 %80, 0
  br i1 %82, label %89, label %83

; <label>:83:                                     ; preds = %77
  %84 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 1
  %85 = load i8*, i8** %84, align 8, !tbaa !243
  %86 = getelementptr inbounds i8, i8* %85, i64 1
  store i8* %86, i8** %84, align 8, !tbaa !243
  %87 = load i8, i8* %85, align 1, !tbaa !21
  %88 = zext i8 %87 to i32
  br label %91

; <label>:89:                                     ; preds = %77
  %90 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %78) #16
  br label %91

; <label>:91:                                     ; preds = %89, %83
  %92 = phi i32 [ %88, %83 ], [ %90, %89 ]
  store i32 %92, i32* %6, align 8, !tbaa !260
  br label %56

; <label>:93:                                     ; preds = %53
  %94 = load %struct.Mbuffer*, %struct.Mbuffer** %27, align 8, !tbaa !253
  %95 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %94, i64 0, i32 0
  %96 = load i8*, i8** %95, align 8, !tbaa !268
  %97 = getelementptr inbounds i8, i8* %96, i64 %2
  %98 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %94, i64 0, i32 1
  %99 = load i64, i64* %98, align 8, !tbaa !300
  %100 = shl i64 %2, 1
  %101 = sub i64 %99, %100
  %102 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %97, i64 %101) #16
  %103 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %102, %struct.TString** %103, align 8, !tbaa !21
  br label %104

; <label>:104:                                    ; preds = %53, %93
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @check_next1(%struct.LexState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !260
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %6, label %23

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !262
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !242
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !242
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %6
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !243
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !243
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %6
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8) #16
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %3, align 8, !tbaa !260
  br label %23

; <label>:23:                                     ; preds = %2, %21
  %24 = phi i32 [ 1, %21 ], [ 0, %2 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @read_numeral(%struct.LexState* nocapture, %union.SemInfo* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !260
  tail call fastcc void @save(%struct.LexState* %0, i32 %6) #16
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !262
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !242
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !242
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !243
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !243
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %2
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8) #16
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %5, align 8, !tbaa !260
  %23 = icmp eq i32 %6, 48
  br i1 %23, label %24, label %28

; <label>:24:                                     ; preds = %21
  %25 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.246, i64 0, i64 0)) #16
  %26 = icmp eq i32 %25, 0
  %27 = select i1 %26, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.247, i64 0, i64 0)
  br label %28

; <label>:28:                                     ; preds = %24, %21
  %29 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), %21 ], [ %27, %24 ]
  br label %30

; <label>:30:                                     ; preds = %73, %28
  %31 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* %29) #16
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %35, label %33

; <label>:33:                                     ; preds = %30
  %34 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0)) #16
  br label %35

; <label>:35:                                     ; preds = %30, %33
  %36 = load i32, i32* %5, align 8, !tbaa !260
  %37 = add nsw i32 %36, 1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %38
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = and i8 %40, 16
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %57, label %43

; <label>:43:                                     ; preds = %35
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36) #16
  %44 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !262
  %45 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 0
  %46 = load i64, i64* %45, align 8, !tbaa !242
  %47 = add i64 %46, -1
  store i64 %47, i64* %45, align 8, !tbaa !242
  %48 = icmp eq i64 %46, 0
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %43
  %50 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 1
  %51 = load i8*, i8** %50, align 8, !tbaa !243
  %52 = getelementptr inbounds i8, i8* %51, i64 1
  store i8* %52, i8** %50, align 8, !tbaa !243
  %53 = load i8, i8* %51, align 1, !tbaa !21
  %54 = zext i8 %53 to i32
  br label %73

; <label>:55:                                     ; preds = %43
  %56 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %44) #16
  br label %73

; <label>:57:                                     ; preds = %35
  %58 = icmp eq i32 %36, 46
  br i1 %58, label %59, label %75

; <label>:59:                                     ; preds = %57
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 46) #16
  %60 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !262
  %61 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 0
  %62 = load i64, i64* %61, align 8, !tbaa !242
  %63 = add i64 %62, -1
  store i64 %63, i64* %61, align 8, !tbaa !242
  %64 = icmp eq i64 %62, 0
  br i1 %64, label %71, label %65

; <label>:65:                                     ; preds = %59
  %66 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 1
  %67 = load i8*, i8** %66, align 8, !tbaa !243
  %68 = getelementptr inbounds i8, i8* %67, i64 1
  store i8* %68, i8** %66, align 8, !tbaa !243
  %69 = load i8, i8* %67, align 1, !tbaa !21
  %70 = zext i8 %69 to i32
  br label %73

; <label>:71:                                     ; preds = %59
  %72 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %60) #16
  br label %73

; <label>:73:                                     ; preds = %65, %71, %49, %55
  %74 = phi i32 [ %54, %49 ], [ %56, %55 ], [ %70, %65 ], [ %72, %71 ]
  store i32 %74, i32* %5, align 8, !tbaa !260
  br label %30

; <label>:75:                                     ; preds = %57
  %76 = and i8 %40, 3
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %94, label %78

; <label>:78:                                     ; preds = %75
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36) #16
  %79 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !262
  %80 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 0
  %81 = load i64, i64* %80, align 8, !tbaa !242
  %82 = add i64 %81, -1
  store i64 %82, i64* %80, align 8, !tbaa !242
  %83 = icmp eq i64 %81, 0
  br i1 %83, label %90, label %84

; <label>:84:                                     ; preds = %78
  %85 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 1
  %86 = load i8*, i8** %85, align 8, !tbaa !243
  %87 = getelementptr inbounds i8, i8* %86, i64 1
  store i8* %87, i8** %85, align 8, !tbaa !243
  %88 = load i8, i8* %86, align 1, !tbaa !21
  %89 = zext i8 %88 to i32
  br label %92

; <label>:90:                                     ; preds = %78
  %91 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %79) #16
  br label %92

; <label>:92:                                     ; preds = %90, %84
  %93 = phi i32 [ %89, %84 ], [ %91, %90 ]
  store i32 %93, i32* %5, align 8, !tbaa !260
  br label %94

; <label>:94:                                     ; preds = %75, %92
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 0) #16
  %95 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %96 = load %struct.Mbuffer*, %struct.Mbuffer** %95, align 8, !tbaa !253
  %97 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %96, i64 0, i32 0
  %98 = load i8*, i8** %97, align 8, !tbaa !268
  %99 = call fastcc i64 @luaO_str2num(i8* %98, %struct.TValue* nonnull %3) #16
  %100 = icmp eq i64 %99, 0
  br i1 %100, label %101, label %102

; <label>:101:                                    ; preds = %94
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.249, i64 0, i64 0), i32 290) #18
  unreachable

; <label>:102:                                    ; preds = %94
  %103 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !22
  %105 = icmp eq i8 %104, 35
  %106 = bitcast %struct.TValue* %3 to i64*
  %107 = load i64, i64* %106, align 8, !tbaa !21
  %108 = bitcast %union.SemInfo* %1 to i64*
  store i64 %107, i64* %108, align 8, !tbaa !21
  %109 = select i1 %105, i32 291, i32 290
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %109
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @luaX_newstring(%struct.LexState* nocapture readonly, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !259
  %6 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2) #16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %7, align 8, !tbaa !20
  %10 = bitcast %union.StackValue* %8 to %struct.TString**
  store %struct.TString* %6, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %6, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !72
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 9
  %16 = load %struct.Table*, %struct.Table** %15, align 8, !tbaa !248
  %17 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0
  %19 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %5, %struct.Table* %16, %struct.TValue* nonnull %18) #16
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %32

; <label>:24:                                     ; preds = %3
  %25 = bitcast %struct.TValue* %19 to i32*
  store i32 1, i32* %25, align 8, !tbaa !21
  store i8 1, i8* %20, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %36

; <label>:31:                                     ; preds = %24
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %5) #16
  br label %36

; <label>:32:                                     ; preds = %3
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 1, i32 0, i32 0
  %34 = bitcast %struct.GCObject** %33 to %struct.TString**
  %35 = load %struct.TString*, %struct.TString** %34, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %24, %31, %32
  %37 = phi %struct.TString* [ %6, %31 ], [ %6, %24 ], [ %35, %32 ]
  %38 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -1
  store %union.StackValue* %39, %union.StackValue** %7, align 8, !tbaa !20
  ret %struct.TString* %37
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @esccheck(%struct.LexState* nocapture, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %27

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !260
  %8 = icmp eq i32 %7, -1
  br i1 %8, label %26, label %9

; <label>:9:                                      ; preds = %5
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %7) #16
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %11 = load %struct.Zio*, %struct.Zio** %10, align 8, !tbaa !262
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !242
  %14 = add i64 %13, -1
  store i64 %14, i64* %12, align 8, !tbaa !242
  %15 = icmp eq i64 %13, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %9
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 1
  %18 = load i8*, i8** %17, align 8, !tbaa !243
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  store i8* %19, i8** %17, align 8, !tbaa !243
  %20 = load i8, i8* %18, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %11) #16
  br label %24

; <label>:24:                                     ; preds = %22, %16
  %25 = phi i32 [ %21, %16 ], [ %23, %22 ]
  store i32 %25, i32* %6, align 8, !tbaa !260
  br label %26

; <label>:26:                                     ; preds = %5, %24
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %2, i32 293) #18
  unreachable

; <label>:27:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @gethexa(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !260
  tail call fastcc void @save(%struct.LexState* %0, i32 %3) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !262
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !260
  %20 = add nsw i32 %19, 1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %21
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = and i8 %23, 16
  %25 = zext i8 %24 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %25, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.240, i64 0, i64 0)) #16
  %26 = load i32, i32* %2, align 8, !tbaa !260
  %27 = tail call fastcc i32 @luaO_hexavalue(i32 %26) #16
  ret i32 %27
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @check_next2(%struct.LexState* nocapture, i8* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !260
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %13, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds i8, i8* %1, i64 1
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %4, %11
  br i1 %12, label %13, label %30

; <label>:13:                                     ; preds = %8, %2
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %4) #16
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %15 = load %struct.Zio*, %struct.Zio** %14, align 8, !tbaa !262
  %16 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !242
  %18 = add i64 %17, -1
  store i64 %18, i64* %16, align 8, !tbaa !242
  %19 = icmp eq i64 %17, 0
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %13
  %21 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 1
  %22 = load i8*, i8** %21, align 8, !tbaa !243
  %23 = getelementptr inbounds i8, i8* %22, i64 1
  store i8* %23, i8** %21, align 8, !tbaa !243
  %24 = load i8, i8* %22, align 1, !tbaa !21
  %25 = zext i8 %24 to i32
  br label %28

; <label>:26:                                     ; preds = %13
  %27 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %15) #16
  br label %28

; <label>:28:                                     ; preds = %26, %20
  %29 = phi i32 [ %25, %20 ], [ %27, %26 ]
  store i32 %29, i32* %3, align 8, !tbaa !260
  br label %30

; <label>:30:                                     ; preds = %8, %28
  %31 = phi i32 [ 1, %28 ], [ 0, %8 ]
  ret i32 %31
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @statement(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.LHS_assign, align 8
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = alloca %struct.expdesc, align 8
  %7 = alloca %struct.expdesc, align 8
  %8 = alloca %struct.BlockCnt, align 8
  %9 = alloca %struct.BlockCnt, align 8
  %10 = alloca %struct.expdesc, align 8
  %11 = alloca %struct.BlockCnt, align 8
  %12 = alloca %struct.BlockCnt, align 8
  %13 = alloca i32, align 4
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %15 = load i32, i32* %14, align 4, !tbaa !264
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %17 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !259
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %17) #16
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %19 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %19, label %305 [
    i32 59, label %20
    i32 267, label %21
    i32 278, label %35
    i32 259, label %44
    i32 264, label %45
    i32 273, label %102
    i32 265, label %125
    i32 269, label %137
    i32 288, label %207
    i32 274, label %227
    i32 258, label %274
    i32 266, label %281
  ]

; <label>:20:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  br label %332

; <label>:21:                                     ; preds = %1
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %23 = load %struct.FuncState*, %struct.FuncState** %22, align 8, !tbaa !263
  %24 = bitcast i32* %13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %24) #7
  store i32 -1, i32* %13, align 4, !tbaa !74
  call fastcc void @test_then_block(%struct.LexState* nonnull %0, i32* nonnull %13) #17
  br label %25

; <label>:25:                                     ; preds = %28, %21
  %26 = load i32, i32* %18, align 8, !tbaa !258
  %27 = icmp eq i32 %26, 261
  br i1 %27, label %28, label %29

; <label>:28:                                     ; preds = %25
  call fastcc void @test_then_block(%struct.LexState* nonnull %0, i32* nonnull %13) #17
  br label %25

; <label>:29:                                     ; preds = %25
  %30 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 260) #17
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %33, label %32

; <label>:32:                                     ; preds = %29
  tail call fastcc void @block(%struct.LexState* nonnull %0) #17
  br label %33

; <label>:33:                                     ; preds = %29, %32
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 267, i32 %15) #17
  %34 = load i32, i32* %13, align 4, !tbaa !74
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %23, i32 %34) #17
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %24) #7
  br label %332

; <label>:35:                                     ; preds = %1
  %36 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %37 = load %struct.FuncState*, %struct.FuncState** %36, align 8, !tbaa !263
  %38 = bitcast %struct.BlockCnt* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %38) #7
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  %39 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %37, i64 0, i32 4
  %40 = load i32, i32* %39, align 8, !tbaa !277
  %41 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %37, i64 0, i32 5
  store i32 %40, i32* %41, align 4, !tbaa !279
  %42 = tail call fastcc i32 @cond(%struct.LexState* nonnull %0) #17
  call fastcc void @enterblock(%struct.FuncState* %37, %struct.BlockCnt* nonnull %12, i8 zeroext 1) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 259) #17
  call fastcc void @block(%struct.LexState* nonnull %0) #17
  %43 = call fastcc i32 @luaK_jump(%struct.FuncState* %37) #17
  call fastcc void @luaK_patchlist(%struct.FuncState* %37, i32 %43, i32 %40) #17
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 278, i32 %15) #17
  call fastcc void @leaveblock(%struct.FuncState* %37) #17
  call fastcc void @luaK_patchtohere(%struct.FuncState* %37, i32 %42) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %38) #7
  br label %332

; <label>:44:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  tail call fastcc void @block(%struct.LexState* nonnull %0) #16
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 259, i32 %15) #16
  br label %332

; <label>:45:                                     ; preds = %1
  %46 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %47 = load %struct.FuncState*, %struct.FuncState** %46, align 8, !tbaa !263
  %48 = bitcast %struct.BlockCnt* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %48) #7
  call fastcc void @enterblock(%struct.FuncState* %47, %struct.BlockCnt* nonnull %11, i8 zeroext 1) #17
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  %49 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %50 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %50, label %100 [
    i32 61, label %51
    i32 44, label %66
    i32 268, label %66
  ]

; <label>:51:                                     ; preds = %45
  %52 = load %struct.FuncState*, %struct.FuncState** %46, align 8, !tbaa !263
  %53 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %52, i64 0, i32 15
  %54 = load i8, i8* %53, align 4, !tbaa !301
  %55 = zext i8 %54 to i32
  %56 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.269, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %56) #17
  %57 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.270, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %57) #17
  %58 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.271, i64 0, i64 0), i64 10) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %58) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %49) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #17
  call fastcc void @exp1(%struct.LexState* nonnull %0) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 44) #17
  call fastcc void @exp1(%struct.LexState* nonnull %0) #17
  %59 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 44) #17
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %62, label %61

; <label>:61:                                     ; preds = %51
  call fastcc void @exp1(%struct.LexState* nonnull %0) #17
  br label %65

; <label>:62:                                     ; preds = %51
  %63 = load i8, i8* %53, align 4, !tbaa !301
  %64 = zext i8 %63 to i32
  call fastcc void @luaK_int(%struct.FuncState* %52, i32 %64, i64 1) #17
  call fastcc void @luaK_reserveregs(%struct.FuncState* %52, i32 1) #17
  br label %65

; <label>:65:                                     ; preds = %62, %61
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 3) #17
  call fastcc void @forbody(%struct.LexState* nonnull %0, i32 %55, i32 %15, i32 1, i32 0) #17
  br label %101

; <label>:66:                                     ; preds = %45, %45
  %67 = load %struct.FuncState*, %struct.FuncState** %46, align 8, !tbaa !263
  %68 = bitcast %struct.expdesc* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %68) #7
  %69 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 15
  %70 = load i8, i8* %69, align 4, !tbaa !301
  %71 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.272, i64 0, i64 0), i64 15) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %71) #17
  %72 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.273, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %72) #17
  %73 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 13
  %74 = load i8, i8* %73, align 2, !tbaa !288
  %75 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 3
  br label %76

; <label>:76:                                     ; preds = %76, %66
  %77 = phi %struct.BlockCnt** [ %75, %66 ], [ %82, %76 ]
  %78 = load %struct.BlockCnt*, %struct.BlockCnt** %77, align 8, !tbaa !39
  %79 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %78, i64 0, i32 3
  %80 = load i8, i8* %79, align 8, !tbaa !293
  %81 = icmp ugt i8 %80, %74
  %82 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %78, i64 0, i32 0
  br i1 %81, label %76, label %83

; <label>:83:                                     ; preds = %76
  %84 = zext i8 %70 to i32
  %85 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %78, i64 0, i32 4
  store i8 1, i8* %85, align 1, !tbaa !296
  %86 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 17
  store i8 1, i8* %86, align 2, !tbaa !289
  %87 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.274, i64 0, i64 0), i64 13) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %87) #17
  %88 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.275, i64 0, i64 0), i64 13) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %88) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %49) #17
  br label %89

; <label>:89:                                     ; preds = %93, %83
  %90 = phi i32 [ 5, %83 ], [ %95, %93 ]
  %91 = call fastcc i32 @testnext(%struct.LexState* %0, i32 44) #17
  %92 = icmp eq i32 %91, 0
  br i1 %92, label %96, label %93

; <label>:93:                                     ; preds = %89
  %94 = call fastcc %struct.TString* @str_checkname(%struct.LexState* %0) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %94) #17
  %95 = add nuw nsw i32 %90, 1
  br label %89

; <label>:96:                                     ; preds = %89
  call fastcc void @checknext(%struct.LexState* %0, i32 268) #17
  %97 = load i32, i32* %14, align 4, !tbaa !264
  %98 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %10) #17
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 4, i32 %98, %struct.expdesc* nonnull %10) #17
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 4) #17
  call fastcc void @luaK_checkstack(%struct.FuncState* %67, i32 3) #17
  %99 = add nsw i32 %90, -4
  call fastcc void @forbody(%struct.LexState* %0, i32 %84, i32 %97, i32 %99, i32 1) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %68) #7
  br label %101

; <label>:100:                                    ; preds = %45
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.268, i64 0, i64 0)) #19
  unreachable

; <label>:101:                                    ; preds = %65, %96
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 264, i32 %15) #17
  call fastcc void @leaveblock(%struct.FuncState* %47) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %48) #7
  br label %332

; <label>:102:                                    ; preds = %1
  %103 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %104 = load %struct.FuncState*, %struct.FuncState** %103, align 8, !tbaa !263
  %105 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %104, i64 0, i32 4
  %106 = load i32, i32* %105, align 8, !tbaa !277
  %107 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %104, i64 0, i32 5
  store i32 %106, i32* %107, align 4, !tbaa !279
  %108 = bitcast %struct.BlockCnt* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %108) #7
  %109 = bitcast %struct.BlockCnt* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %109) #7
  call fastcc void @enterblock(%struct.FuncState* %104, %struct.BlockCnt* nonnull %8, i8 zeroext 1) #17
  call fastcc void @enterblock(%struct.FuncState* %104, %struct.BlockCnt* nonnull %9, i8 zeroext 0) #17
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  call fastcc void @statlist(%struct.LexState* nonnull %0) #17
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 277, i32 273, i32 %15) #17
  %110 = call fastcc i32 @cond(%struct.LexState* nonnull %0) #17
  call fastcc void @leaveblock(%struct.FuncState* %104) #17
  %111 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %9, i64 0, i32 4
  %112 = load i8, i8* %111, align 1, !tbaa !296
  %113 = icmp eq i8 %112, 0
  br i1 %113, label %123, label %114

; <label>:114:                                    ; preds = %102
  %115 = call fastcc i32 @luaK_jump(%struct.FuncState* %104) #17
  call fastcc void @luaK_patchtohere(%struct.FuncState* %104, i32 %110) #17
  %116 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %9, i64 0, i32 3
  %117 = load i8, i8* %116, align 8, !tbaa !293
  %118 = zext i8 %117 to i32
  %119 = shl nuw nsw i32 %118, 7
  %120 = or i32 %119, 55
  %121 = call fastcc i32 @luaK_code(%struct.FuncState* %104, i32 %120) #17
  %122 = call fastcc i32 @luaK_jump(%struct.FuncState* %104) #17
  call fastcc void @luaK_patchtohere(%struct.FuncState* %104, i32 %115) #17
  br label %123

; <label>:123:                                    ; preds = %102, %114
  %124 = phi i32 [ %122, %114 ], [ %110, %102 ]
  call fastcc void @luaK_patchlist(%struct.FuncState* %104, i32 %124, i32 %106) #17
  call fastcc void @leaveblock(%struct.FuncState* %104) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %109) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %108) #7
  br label %332

; <label>:125:                                    ; preds = %1
  %126 = bitcast %struct.expdesc* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %126) #7
  %127 = bitcast %struct.expdesc* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %127) #7
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  call fastcc void @singlevar(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %6) #17
  br label %128

; <label>:128:                                    ; preds = %130, %125
  %129 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %129, label %132 [
    i32 46, label %130
    i32 58, label %131
  ]

; <label>:130:                                    ; preds = %128
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %6) #17
  br label %128

; <label>:131:                                    ; preds = %128
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %6) #17
  br label %132

; <label>:132:                                    ; preds = %128, %131
  %133 = phi i32 [ 1, %131 ], [ 0, %128 ]
  call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %7, i32 %133, i32 %15) #17
  %134 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %135 = load %struct.FuncState*, %struct.FuncState** %134, align 8, !tbaa !263
  call fastcc void @luaK_storevar(%struct.FuncState* %135, %struct.expdesc* nonnull %6, %struct.expdesc* nonnull %7) #17
  %136 = load %struct.FuncState*, %struct.FuncState** %134, align 8, !tbaa !263
  tail call fastcc void @luaK_fixline(%struct.FuncState* %136, i32 %15) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %127) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %126) #7
  br label %332

; <label>:137:                                    ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %138 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 265) #16
  %139 = icmp eq i32 %138, 0
  br i1 %139, label %153, label %140

; <label>:140:                                    ; preds = %137
  %141 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %141) #7
  %142 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %143 = load %struct.FuncState*, %struct.FuncState** %142, align 8, !tbaa !263
  %144 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %144) #17
  tail call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 1) #17
  %145 = load i32, i32* %14, align 4, !tbaa !264
  call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5, i32 0, i32 %145) #17
  %146 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %143, i64 0, i32 4
  %147 = load i32, i32* %146, align 8, !tbaa !277
  %148 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 1
  %149 = bitcast %union.anon.8* %148 to i32*
  %150 = load i32, i32* %149, align 8, !tbaa !21
  %151 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %143, i32 %150) #17
  %152 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %151, i64 0, i32 1
  store i32 %147, i32* %152, align 8, !tbaa !98
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %141) #7
  br label %332

; <label>:153:                                    ; preds = %137
  %154 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 42) #17
  %155 = icmp eq i32 %154, 0
  br i1 %155, label %190, label %156

; <label>:156:                                    ; preds = %153
  %157 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %158 = load %struct.FuncState*, %struct.FuncState** %157, align 8, !tbaa !263
  %159 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %160 = getelementptr inbounds %struct.TString, %struct.TString* %159, i64 1
  %161 = bitcast %struct.TString* %160 to i8*
  %162 = tail call i32 @strcmp(i8* nonnull %161, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.276, i64 0, i64 0)) #21
  %163 = icmp eq i32 %162, 0
  br i1 %163, label %167, label %164

; <label>:164:                                    ; preds = %156
  %165 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !259
  %166 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %165, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.277, i64 0, i64 0), %struct.TString* nonnull %160) #17
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %166) #19
  unreachable

; <label>:167:                                    ; preds = %156
  %168 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %168) #17
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #17
  tail call fastcc void @exp1(%struct.LexState* nonnull %0) #17
  %169 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %158, i64 0, i32 13
  %170 = load i8, i8* %169, align 2, !tbaa !288
  %171 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %158, i64 0, i32 3
  br label %172

; <label>:172:                                    ; preds = %172, %167
  %173 = phi %struct.BlockCnt** [ %171, %167 ], [ %178, %172 ]
  %174 = load %struct.BlockCnt*, %struct.BlockCnt** %173, align 8, !tbaa !39
  %175 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %174, i64 0, i32 3
  %176 = load i8, i8* %175, align 8, !tbaa !293
  %177 = icmp ugt i8 %176, %170
  %178 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %174, i64 0, i32 0
  br i1 %177, label %172, label %179

; <label>:179:                                    ; preds = %172
  %180 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %174, i64 0, i32 4
  store i8 1, i8* %180, align 1, !tbaa !296
  %181 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %158, i64 0, i32 17
  store i8 1, i8* %181, align 2, !tbaa !289
  %182 = load %struct.BlockCnt*, %struct.BlockCnt** %171, align 8, !tbaa !285
  %183 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %182, i64 0, i32 6
  store i8 1, i8* %183, align 1, !tbaa !297
  tail call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 1) #17
  %184 = load i8, i8* %169, align 2, !tbaa !288
  %185 = zext i8 %184 to i32
  %186 = shl nuw nsw i32 %185, 7
  %187 = add nsw i32 %186, -128
  %188 = or i32 %187, 56
  %189 = tail call fastcc i32 @luaK_code(%struct.FuncState* %158, i32 %188) #17
  br label %332

; <label>:190:                                    ; preds = %153
  %191 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %191) #7
  br label %192

; <label>:192:                                    ; preds = %192, %190
  %193 = phi i32 [ 0, %190 ], [ %195, %192 ]
  %194 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %194) #17
  %195 = add nuw nsw i32 %193, 1
  %196 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44) #17
  %197 = icmp eq i32 %196, 0
  br i1 %197, label %198, label %192

; <label>:198:                                    ; preds = %192
  %199 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 61) #17
  %200 = icmp eq i32 %199, 0
  br i1 %200, label %203, label %201

; <label>:201:                                    ; preds = %198
  %202 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %4) #17
  br label %205

; <label>:203:                                    ; preds = %198
  %204 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 0, i32* %204, align 8, !tbaa !273
  br label %205

; <label>:205:                                    ; preds = %203, %201
  %206 = phi i32 [ %202, %201 ], [ 0, %203 ]
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 %195, i32 %206, %struct.expdesc* nonnull %4) #17
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 %195) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %191) #7
  br label %332

; <label>:207:                                    ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %208 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #16
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 288) #17
  br label %209

; <label>:209:                                    ; preds = %211, %207
  %210 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %210, label %212 [
    i32 288, label %211
    i32 59, label %211
  ]

; <label>:211:                                    ; preds = %209, %209
  tail call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br label %209

; <label>:212:                                    ; preds = %209
  %213 = tail call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nonnull %0, %struct.TString* %208) #17
  %214 = icmp eq %struct.Labeldesc* %213, null
  br i1 %214, label %221, label %215, !prof !70

; <label>:215:                                    ; preds = %212
  %216 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !259
  %217 = getelementptr inbounds %struct.TString, %struct.TString* %208, i64 1
  %218 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %213, i64 0, i32 2
  %219 = load i32, i32* %218, align 4, !tbaa !302
  %220 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %216, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.278, i64 0, i64 0), %struct.TString* nonnull %217, i32 %219) #17
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %220) #19
  unreachable

; <label>:221:                                    ; preds = %212
  switch i32 %210, label %223 [
    i32 260, label %224
    i32 261, label %224
    i32 262, label %224
    i32 289, label %224
    i32 277, label %222
  ]

; <label>:222:                                    ; preds = %221
  br label %224

; <label>:223:                                    ; preds = %221
  br label %224

; <label>:224:                                    ; preds = %221, %221, %221, %221, %222, %223
  %225 = phi i32 [ 0, %223 ], [ 0, %222 ], [ 1, %221 ], [ 1, %221 ], [ 1, %221 ], [ 1, %221 ]
  %226 = tail call fastcc i32 @createlabel(%struct.LexState* nonnull %0, %struct.TString* %208, i32 %15, i32 %225) #17
  br label %332

; <label>:227:                                    ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %228 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %229 = load %struct.FuncState*, %struct.FuncState** %228, align 8, !tbaa !263
  %230 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %230) #7
  %231 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %229, i64 0, i32 13
  %232 = load i8, i8* %231, align 2, !tbaa !288
  %233 = zext i8 %232 to i32
  %234 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %234, label %235 [
    i32 260, label %270
    i32 261, label %270
    i32 262, label %270
    i32 289, label %270
    i32 277, label %270
    i32 59, label %270
  ]

; <label>:235:                                    ; preds = %227
  %236 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3) #17
  %237 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %238 = load i32, i32* %237, align 8, !tbaa !273
  %239 = and i32 %238, -2
  %240 = icmp eq i32 %239, 16
  br i1 %240, label %241, label %265

; <label>:241:                                    ; preds = %235
  call fastcc void @luaK_setreturns(%struct.FuncState* %229, %struct.expdesc* nonnull %3, i32 -1) #17
  %242 = load i32, i32* %237, align 8, !tbaa !273
  %243 = icmp eq i32 %242, 16
  %244 = icmp eq i32 %236, 1
  %245 = and i1 %244, %243
  br i1 %245, label %246, label %270

; <label>:246:                                    ; preds = %241
  %247 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %229, i64 0, i32 3
  %248 = load %struct.BlockCnt*, %struct.BlockCnt** %247, align 8, !tbaa !285
  %249 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %248, i64 0, i32 6
  %250 = load i8, i8* %249, align 1, !tbaa !297
  %251 = icmp eq i8 %250, 0
  br i1 %251, label %252, label %270

; <label>:252:                                    ; preds = %246
  %253 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %229, i64 0, i32 0
  %254 = load %struct.Proto*, %struct.Proto** %253, align 8, !tbaa !251
  %255 = getelementptr inbounds %struct.Proto, %struct.Proto* %254, i64 0, i32 16
  %256 = load i32*, i32** %255, align 8, !tbaa !119
  %257 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %258 = bitcast %union.anon.8* %257 to i32*
  %259 = load i32, i32* %258, align 8, !tbaa !21
  %260 = sext i32 %259 to i64
  %261 = getelementptr inbounds i32, i32* %256, i64 %260
  %262 = load i32, i32* %261, align 4, !tbaa !74
  %263 = and i32 %262, -128
  %264 = or i32 %263, 70
  store i32 %264, i32* %261, align 4, !tbaa !74
  br label %270

; <label>:265:                                    ; preds = %235
  %266 = icmp eq i32 %236, 1
  br i1 %266, label %267, label %269

; <label>:267:                                    ; preds = %265
  %268 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %229, %struct.expdesc* nonnull %3) #17
  br label %270

; <label>:269:                                    ; preds = %265
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %229, %struct.expdesc* nonnull %3) #17
  br label %270

; <label>:270:                                    ; preds = %227, %227, %227, %227, %227, %227, %241, %246, %252, %267, %269
  %271 = phi i32 [ 1, %267 ], [ %236, %269 ], [ -1, %246 ], [ -1, %252 ], [ -1, %241 ], [ 0, %227 ], [ 0, %227 ], [ 0, %227 ], [ 0, %227 ], [ 0, %227 ], [ 0, %227 ]
  %272 = phi i32 [ %268, %267 ], [ %233, %269 ], [ %233, %246 ], [ %233, %252 ], [ %233, %241 ], [ %233, %227 ], [ %233, %227 ], [ %233, %227 ], [ %233, %227 ], [ %233, %227 ], [ %233, %227 ]
  call fastcc void @luaK_ret(%struct.FuncState* %229, i32 %272, i32 %271) #17
  %273 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 59) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %230) #7
  br label %332

; <label>:274:                                    ; preds = %1
  %275 = load i32, i32* %14, align 4, !tbaa !264
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  %276 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !259
  %277 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %276, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #17
  %278 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %279 = load %struct.FuncState*, %struct.FuncState** %278, align 8, !tbaa !263
  %280 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %279) #17
  tail call fastcc void @newgotoentry(%struct.LexState* nonnull %0, %struct.TString* %277, i32 %275, i32 %280) #17
  br label %332

; <label>:281:                                    ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %282 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %283 = load %struct.FuncState*, %struct.FuncState** %282, align 8, !tbaa !263
  %284 = load i32, i32* %14, align 4, !tbaa !264
  %285 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %286 = tail call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nonnull %0, %struct.TString* %285) #17
  %287 = icmp eq %struct.Labeldesc* %286, null
  br i1 %287, label %288, label %290

; <label>:288:                                    ; preds = %281
  %289 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %283) #17
  tail call fastcc void @newgotoentry(%struct.LexState* nonnull %0, %struct.TString* %285, i32 %284, i32 %289) #17
  br label %332

; <label>:290:                                    ; preds = %281
  %291 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %283, i64 0, i32 13
  %292 = load i8, i8* %291, align 2, !tbaa !288
  %293 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %286, i64 0, i32 3
  %294 = load i8, i8* %293, align 8, !tbaa !304
  %295 = icmp ugt i8 %292, %294
  br i1 %295, label %296, label %301

; <label>:296:                                    ; preds = %290
  %297 = zext i8 %294 to i32
  %298 = shl nuw nsw i32 %297, 7
  %299 = or i32 %298, 55
  %300 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %283, i32 %299) #17
  br label %301

; <label>:301:                                    ; preds = %296, %290
  %302 = tail call fastcc i32 @luaK_jump(%struct.FuncState* nonnull %283) #17
  %303 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %286, i64 0, i32 1
  %304 = load i32, i32* %303, align 8, !tbaa !305
  tail call fastcc void @luaK_patchlist(%struct.FuncState* nonnull %283, i32 %302, i32 %304) #17
  br label %332

; <label>:305:                                    ; preds = %1
  %306 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %307 = load %struct.FuncState*, %struct.FuncState** %306, align 8, !tbaa !263
  %308 = bitcast %struct.LHS_assign* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %308) #7
  %309 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %309) #17
  %310 = load i32, i32* %18, align 8, !tbaa !258
  switch i32 %310, label %313 [
    i32 61, label %311
    i32 44, label %311
  ]

; <label>:311:                                    ; preds = %305, %305
  %312 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 0
  store %struct.LHS_assign* null, %struct.LHS_assign** %312, align 8, !tbaa !306
  call fastcc void @restassign(%struct.LexState* nonnull %0, %struct.LHS_assign* nonnull %2, i32 1) #17
  br label %331

; <label>:313:                                    ; preds = %305
  %314 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %307, i64 0, i32 0
  %315 = load %struct.Proto*, %struct.Proto** %314, align 8, !tbaa !251
  %316 = getelementptr inbounds %struct.Proto, %struct.Proto* %315, i64 0, i32 16
  %317 = load i32*, i32** %316, align 8, !tbaa !119
  %318 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 1, i32 1
  %319 = bitcast %union.anon.8* %318 to i32*
  %320 = load i32, i32* %319, align 8, !tbaa !21
  %321 = sext i32 %320 to i64
  %322 = getelementptr inbounds i32, i32* %317, i64 %321
  %323 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %309, i64 0, i32 0
  %324 = load i32, i32* %323, align 8, !tbaa !308
  %325 = icmp eq i32 %324, 16
  br i1 %325, label %327, label %326

; <label>:326:                                    ; preds = %313
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #19
  unreachable

; <label>:327:                                    ; preds = %313
  %328 = load i32, i32* %322, align 4, !tbaa !74
  %329 = and i32 %328, 16777215
  %330 = or i32 %329, 16777216
  store i32 %330, i32* %322, align 4, !tbaa !74
  br label %331

; <label>:331:                                    ; preds = %311, %327
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %308) #7
  br label %332

; <label>:332:                                    ; preds = %301, %288, %205, %179, %140, %331, %274, %270, %224, %132, %123, %101, %44, %35, %33, %20
  %333 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %334 = load %struct.FuncState*, %struct.FuncState** %333, align 8, !tbaa !263
  %335 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %334, i64 0, i32 13
  %336 = load i8, i8* %335, align 2, !tbaa !288
  %337 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %334, i64 0, i32 15
  store i8 %336, i8* %337, align 4, !tbaa !301
  %338 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !259
  %339 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %338, i64 0, i32 19
  %340 = load i32, i32* %339, align 8, !tbaa !54
  %341 = add i32 %340, -1
  store i32 %341, i32* %339, align 8, !tbaa !54
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @block(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.BlockCnt, align 8
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  %5 = bitcast %struct.BlockCnt* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  call fastcc void @enterblock(%struct.FuncState* %4, %struct.BlockCnt* nonnull %2, i8 zeroext 0) #16
  call fastcc void @statlist(%struct.LexState* %0) #16
  call fastcc void @leaveblock(%struct.FuncState* %4) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @check_match(%struct.LexState*, i32, i32, i32) unnamed_addr #0 {
  %5 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 %1) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %18, !prof !47

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !264
  %10 = icmp eq i32 %9, %3
  br i1 %10, label %11, label %12

; <label>:11:                                     ; preds = %7
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #18
  unreachable

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !259
  %15 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %1) #16
  %16 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %2) #16
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %14, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.266, i64 0, i64 0), i8* %15, i8* %16, i32 %3) #16
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* %17) #18
  unreachable

; <label>:18:                                     ; preds = %4
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @testnext(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !258
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  br label %7

; <label>:7:                                      ; preds = %2, %6
  %8 = phi i32 [ 1, %6 ], [ 0, %2 ]
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.TString* @str_checkname(%struct.LexState*) unnamed_addr #0 {
  tail call fastcc void @check(%struct.LexState* %0, i32 292) #16
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %3 = bitcast %union.SemInfo* %2 to %struct.TString**
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !21
  tail call fastcc void @luaX_next(%struct.LexState* %0) #16
  ret %struct.TString* %4
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @test_then_block(%struct.LexState*, i32* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !263
  %8 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  tail call fastcc void @luaX_next(%struct.LexState* %0) #16
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %4) #16
  call fastcc void @checknext(%struct.LexState* %0, i32 275) #16
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %10 = load i32, i32* %9, align 4, !tbaa !264
  %11 = call fastcc i32 @testnext(%struct.LexState* %0, i32 258) #17
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !259
  %16 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #17
  br label %43

; <label>:17:                                     ; preds = %2
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %19 = load i32, i32* %18, align 8, !tbaa !258
  %20 = icmp eq i32 %19, 266
  br i1 %20, label %21, label %62

; <label>:21:                                     ; preds = %17
  %22 = call fastcc i32 @luaX_lookahead(%struct.LexState* nonnull %0) #17
  %23 = icmp eq i32 %22, 292
  br i1 %23, label %24, label %62

; <label>:24:                                     ; preds = %21
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %26 = bitcast %union.SemInfo* %25 to %struct.TString**
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !21
  %28 = call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nonnull %0, %struct.TString* %27) #17
  %29 = icmp eq %struct.Labeldesc* %28, null
  br i1 %29, label %40, label %30

; <label>:30:                                     ; preds = %24
  %31 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !263
  %32 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %31, i64 0, i32 13
  %33 = load i8, i8* %32, align 2, !tbaa !288
  %34 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %28, i64 0, i32 3
  %35 = load i8, i8* %34, align 8, !tbaa !304
  %36 = icmp ugt i8 %33, %35
  br i1 %36, label %62, label %37

; <label>:37:                                     ; preds = %30
  %38 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %28, i64 0, i32 1
  %39 = load i32, i32* %38, align 8, !tbaa !305
  br label %40

; <label>:40:                                     ; preds = %24, %37
  %41 = phi %struct.TString* [ null, %37 ], [ %27, %24 ]
  %42 = phi i32 [ %39, %37 ], [ -1, %24 ]
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  br label %43

; <label>:43:                                     ; preds = %40, %13
  %44 = phi %struct.TString* [ %41, %40 ], [ %16, %13 ]
  %45 = phi i32 [ %42, %40 ], [ -1, %13 ]
  %46 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !263
  call fastcc void @luaK_goiffalse(%struct.FuncState* %46, %struct.expdesc* nonnull %4) #16
  call fastcc void @enterblock(%struct.FuncState* %7, %struct.BlockCnt* nonnull %3, i8 zeroext 0) #16
  %47 = icmp eq %struct.TString* %44, null
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  %49 = load i32, i32* %48, align 8, !tbaa !270
  br i1 %47, label %51, label %50

; <label>:50:                                     ; preds = %43
  call fastcc void @newgotoentry(%struct.LexState* nonnull %0, %struct.TString* nonnull %44, i32 %10, i32 %49) #16
  br label %52

; <label>:51:                                     ; preds = %43
  call fastcc void @luaK_patchlist(%struct.FuncState* %7, i32 %49, i32 %45) #16
  br label %52

; <label>:52:                                     ; preds = %51, %50
  br label %53

; <label>:53:                                     ; preds = %52, %53
  %54 = call fastcc i32 @testnext(%struct.LexState* %0, i32 59) #16
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %53

; <label>:56:                                     ; preds = %53
  %57 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %58 = load i32, i32* %57, align 8, !tbaa !258
  switch i32 %58, label %60 [
    i32 260, label %59
    i32 261, label %59
    i32 262, label %59
    i32 289, label %59
  ]

; <label>:59:                                     ; preds = %56, %56, %56, %56
  call fastcc void @leaveblock(%struct.FuncState* %7) #16
  br label %75

; <label>:60:                                     ; preds = %56
  %61 = call fastcc i32 @luaK_jump(%struct.FuncState* %7) #16
  br label %66

; <label>:62:                                     ; preds = %21, %17, %30
  %63 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !263
  call fastcc void @luaK_goiftrue(%struct.FuncState* %63, %struct.expdesc* nonnull %4) #16
  call fastcc void @enterblock(%struct.FuncState* %7, %struct.BlockCnt* nonnull %3, i8 zeroext 0) #16
  %64 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  %65 = load i32, i32* %64, align 4, !tbaa !272
  br label %66

; <label>:66:                                     ; preds = %62, %60
  %67 = phi i32* [ %18, %62 ], [ %57, %60 ]
  %68 = phi i32 [ %65, %62 ], [ %61, %60 ]
  call fastcc void @statlist(%struct.LexState* nonnull %0) #16
  call fastcc void @leaveblock(%struct.FuncState* %7) #16
  %69 = load i32, i32* %67, align 8, !tbaa !258
  %70 = and i32 %69, -2
  %71 = icmp eq i32 %70, 260
  br i1 %71, label %72, label %74

; <label>:72:                                     ; preds = %66
  %73 = call fastcc i32 @luaK_jump(%struct.FuncState* %7) #16
  call fastcc void @luaK_concat(%struct.FuncState* %7, i32* %1, i32 %73) #16
  br label %74

; <label>:74:                                     ; preds = %66, %72
  call fastcc void @luaK_patchtohere(%struct.FuncState* %7, i32 %68) #16
  br label %75

; <label>:75:                                     ; preds = %74, %59
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_patchtohere(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %4 = load i32, i32* %3, align 8, !tbaa !277
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %4, i32* %5, align 4, !tbaa !279
  tail call fastcc void @luaK_patchlist(%struct.FuncState* %0, i32 %1, i32 %4) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @expr(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = tail call fastcc i32 @subexpr(%struct.LexState* %0, %struct.expdesc* %1, i32 0) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checknext(%struct.LexState*, i32) unnamed_addr #0 {
  tail call fastcc void @check(%struct.LexState* %0, i32 %1) #16
  tail call fastcc void @luaX_next(%struct.LexState* %0) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_goiffalse(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  switch i32 %4, label %9 [
    i32 14, label %5
    i32 1, label %11
    i32 3, label %11
  ]

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  br label %11

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 1) #16
  br label %11

; <label>:11:                                     ; preds = %2, %2, %9, %5
  %12 = phi i32 [ %10, %9 ], [ %8, %5 ], [ -1, %2 ], [ -1, %2 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %12) #16
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !272
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %15) #16
  store i32 -1, i32* %14, align 4, !tbaa !272
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @newgotoentry(%struct.LexState* nocapture readonly, %struct.TString*, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 1
  %8 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %7, %struct.TString* %1, i32 %2, i32 %3) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_patchlist(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #0 {
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %1, i32 %2, i32 255, i32 %2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @leaveblock(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  %3 = load %struct.BlockCnt*, %struct.BlockCnt** %2, align 8, !tbaa !285
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !276
  %6 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  %7 = load i8, i8* %6, align 2, !tbaa !291
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !259
  %12 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #16
  %13 = tail call fastcc i32 @createlabel(%struct.LexState* %5, %struct.TString* %12, i32 0, i32 0) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %30

; <label>:15:                                     ; preds = %9, %1
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 0
  %17 = load %struct.BlockCnt*, %struct.BlockCnt** %16, align 8, !tbaa !298
  %18 = icmp eq %struct.BlockCnt* %17, null
  br i1 %18, label %30, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  %21 = load i8, i8* %20, align 1, !tbaa !296
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %30, label %23

; <label>:23:                                     ; preds = %19
  %24 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %25 = load i8, i8* %24, align 8, !tbaa !293
  %26 = zext i8 %25 to i32
  %27 = shl nuw nsw i32 %26, 7
  %28 = or i32 %27, 55
  %29 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %28) #17
  br label %30

; <label>:30:                                     ; preds = %9, %19, %15, %23
  %31 = bitcast %struct.BlockCnt* %3 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !298
  %33 = bitcast %struct.BlockCnt** %2 to i64*
  store i64 %32, i64* %33, align 8, !tbaa !285
  %34 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %35 = load i8, i8* %34, align 8, !tbaa !293
  %36 = zext i8 %35 to i32
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %38 = load i8, i8* %37, align 2, !tbaa !288
  %39 = zext i8 %38 to i32
  %40 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !276
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %40, i64 0, i32 10
  %42 = load %struct.Dyndata*, %struct.Dyndata** %41, align 8, !tbaa !254
  %43 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 0, i32 1
  %44 = load i32, i32* %43, align 8, !tbaa !257
  %45 = sub nsw i32 %36, %39
  %46 = add i32 %45, %44
  store i32 %46, i32* %43, align 8, !tbaa !257
  %47 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  br label %48

; <label>:48:                                     ; preds = %52, %30
  %49 = phi i8 [ %55, %52 ], [ %38, %30 ]
  %50 = phi i32 [ %59, %52 ], [ %39, %30 ]
  %51 = icmp ugt i32 %50, %36
  br i1 %51, label %52, label %60

; <label>:52:                                     ; preds = %48
  %53 = load i32, i32* %47, align 8, !tbaa !277
  %54 = trunc i32 %50 to i8
  %55 = add i8 %54, -1
  store i8 %55, i8* %37, align 2, !tbaa !288
  %56 = zext i8 %55 to i32
  %57 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nonnull %0, i32 %56) #17
  %58 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %57, i64 0, i32 2
  store i32 %53, i32* %58, align 4, !tbaa !100
  %59 = add nsw i32 %50, -1
  br label %48

; <label>:60:                                     ; preds = %48
  %61 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %49, i8* %61, align 4, !tbaa !301
  %62 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  %63 = load i32, i32* %62, align 8, !tbaa !294
  %64 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 10
  %65 = load %struct.Dyndata*, %struct.Dyndata** %64, align 8, !tbaa !254
  %66 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %65, i64 0, i32 2, i32 1
  store i32 %63, i32* %66, align 8, !tbaa !255
  %67 = icmp eq i64 %32, 0
  %68 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  %69 = load i32, i32* %68, align 4, !tbaa !295
  br i1 %67, label %92, label %70

; <label>:70:                                     ; preds = %60
  %71 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 1
  %72 = load i32, i32* %71, align 8, !tbaa !309
  %73 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 0
  %74 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  %75 = sext i32 %69 to i64
  %76 = sext i32 %72 to i64
  br label %77

; <label>:77:                                     ; preds = %90, %70
  %78 = phi i64 [ %91, %90 ], [ %75, %70 ]
  %79 = icmp slt i64 %78, %76
  br i1 %79, label %80, label %101

; <label>:80:                                     ; preds = %77
  %81 = load %struct.Labeldesc*, %struct.Labeldesc** %73, align 8, !tbaa !310
  %82 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %81, i64 %78, i32 3
  %83 = load i8, i8* %82, align 8, !tbaa !304
  %84 = icmp ugt i8 %83, %35
  br i1 %84, label %85, label %90

; <label>:85:                                     ; preds = %80
  store i8 %35, i8* %82, align 8, !tbaa !304
  %86 = load i8, i8* %74, align 1, !tbaa !296
  %87 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %81, i64 %78, i32 4
  %88 = load i8, i8* %87, align 1, !tbaa !311
  %89 = or i8 %88, %86
  store i8 %89, i8* %87, align 1, !tbaa !311
  br label %90

; <label>:90:                                     ; preds = %85, %80
  %91 = add nsw i64 %78, 1
  br label %77

; <label>:92:                                     ; preds = %60
  %93 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %65, i64 0, i32 1, i32 1
  %94 = load i32, i32* %93, align 8, !tbaa !256
  %95 = icmp slt i32 %69, %94
  br i1 %95, label %96, label %101

; <label>:96:                                     ; preds = %92
  %97 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %65, i64 0, i32 1, i32 0
  %98 = load %struct.Labeldesc*, %struct.Labeldesc** %97, align 8, !tbaa !312
  %99 = sext i32 %69 to i64
  %100 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %98, i64 %99
  tail call fastcc void @undefgoto(%struct.LexState* nonnull %5, %struct.Labeldesc* %100) #18
  unreachable

; <label>:101:                                    ; preds = %77, %92
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_jump(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 2147483449) #17
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_goiftrue(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  switch i32 %4, label %9 [
    i32 14, label %5
    i32 4, label %11
    i32 5, label %11
    i32 6, label %11
    i32 2, label %11
  ]

; <label>:5:                                      ; preds = %2
  tail call fastcc void @negatecondition(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  br label %11

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 0) #16
  br label %11

; <label>:11:                                     ; preds = %2, %2, %2, %2, %9, %5
  %12 = phi i32 [ %10, %9 ], [ %8, %5 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %12) #16
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %15 = load i32, i32* %14, align 8, !tbaa !270
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %15) #16
  store i32 -1, i32* %14, align 8, !tbaa !270
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_concat(%struct.FuncState* nocapture readonly, i32* nocapture, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, -1
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i32, i32* %1, align 4, !tbaa !74
  %7 = icmp eq i32 %6, -1
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  br label %10

; <label>:9:                                      ; preds = %5
  store i32 %2, i32* %1, align 4, !tbaa !74
  br label %15

; <label>:10:                                     ; preds = %8, %10
  %11 = phi i32 [ %12, %10 ], [ %6, %8 ]
  %12 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %11) #16
  %13 = icmp eq i32 %12, -1
  br i1 %13, label %14, label %10

; <label>:14:                                     ; preds = %10
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %11, i32 %2) #16
  br label %15

; <label>:15:                                     ; preds = %9, %14, %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @subexpr(%struct.LexState*, %struct.expdesc*, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = alloca i32, align 4
  %6 = alloca %struct.expdesc, align 8
  %7 = alloca %struct.expdesc, align 8
  %8 = alloca i64, align 8
  %9 = alloca i32, align 4
  %10 = alloca %struct.expdesc, align 8
  %11 = alloca %struct.expdesc, align 8
  %12 = alloca %struct.expdesc, align 8
  %13 = alloca %struct.expdesc, align 8
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !259
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %15) #16
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %17 = load i32, i32* %16, align 8, !tbaa !258
  switch i32 %17, label %131 [
    i32 271, label %47
    i32 45, label %25
    i32 126, label %18
    i32 35, label %19
    i32 290, label %69
    i32 291, label %79
    i32 293, label %89
    i32 270, label %93
    i32 276, label %99
    i32 263, label %105
    i32 281, label %111
    i32 123, label %127
    i32 265, label %128
  ]

; <label>:18:                                     ; preds = %3
  br label %25

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %21 = load i32, i32* %20, align 4, !tbaa !264
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %22 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 12) #16
  %23 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %24 = load %struct.FuncState*, %struct.FuncState** %23, align 8, !tbaa !263
  br label %35

; <label>:25:                                     ; preds = %3, %18
  %26 = phi i32 [ 1, %18 ], [ 0, %3 ]
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %28 = load i32, i32* %27, align 4, !tbaa !264
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %29 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 12) #16
  %30 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %31 = load %struct.FuncState*, %struct.FuncState** %30, align 8, !tbaa !263
  %32 = or i32 %26, 12
  %33 = tail call fastcc i32 @constfolding(%struct.FuncState* %31, i32 %32, %struct.expdesc* %1, %struct.expdesc* nonnull @luaK_prefix.ef) #17
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %35, label %133

; <label>:35:                                     ; preds = %19, %25
  %36 = phi %struct.FuncState* [ %31, %25 ], [ %24, %19 ]
  %37 = phi i32 [ %28, %25 ], [ %21, %19 ]
  %38 = phi i32 [ %26, %25 ], [ 3, %19 ]
  %39 = add nsw i32 %38, 50
  %40 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %36, %struct.expdesc* %1) #17
  tail call fastcc void @freeexp(%struct.FuncState* %36, %struct.expdesc* %1) #17
  %41 = shl i32 %40, 16
  %42 = or i32 %41, %39
  %43 = tail call fastcc i32 @luaK_code(%struct.FuncState* %36, i32 %42) #17
  %44 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %45 = bitcast %union.anon.8* %44 to i32*
  store i32 %43, i32* %45, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %46, align 8, !tbaa !273
  tail call fastcc void @luaK_fixline(%struct.FuncState* %36, i32 %37) #17
  br label %133

; <label>:47:                                     ; preds = %3
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %48 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 12) #16
  %49 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %50 = load %struct.FuncState*, %struct.FuncState** %49, align 8, !tbaa !263
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %50, %struct.expdesc* %1) #17
  %51 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %52 = load i32, i32* %51, align 8, !tbaa !273
  switch i32 %52, label %63 [
    i32 1, label %53
    i32 3, label %53
    i32 4, label %54
    i32 5, label %54
    i32 6, label %54
    i32 2, label %54
    i32 14, label %55
    i32 15, label %56
    i32 7, label %56
  ]

; <label>:53:                                     ; preds = %47, %47
  store i32 2, i32* %51, align 8, !tbaa !273
  br label %63

; <label>:54:                                     ; preds = %47, %47, %47, %47
  store i32 3, i32* %51, align 8, !tbaa !273
  br label %63

; <label>:55:                                     ; preds = %47
  tail call fastcc void @negatecondition(%struct.FuncState* %50, %struct.expdesc* nonnull %1) #17
  br label %63

; <label>:56:                                     ; preds = %47, %47
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %50, %struct.expdesc* nonnull %1) #17
  tail call fastcc void @freeexp(%struct.FuncState* %50, %struct.expdesc* nonnull %1) #17
  %57 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %58 = bitcast %union.anon.8* %57 to i32*
  %59 = load i32, i32* %58, align 8, !tbaa !21
  %60 = shl i32 %59, 16
  %61 = or i32 %60, 52
  %62 = tail call fastcc i32 @luaK_code(%struct.FuncState* %50, i32 %61) #17
  store i32 %62, i32* %58, align 8, !tbaa !21
  store i32 15, i32* %51, align 8, !tbaa !273
  br label %63

; <label>:63:                                     ; preds = %56, %55, %54, %53, %47
  %64 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %65 = load i32, i32* %64, align 4, !tbaa !272
  %66 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %67 = load i32, i32* %66, align 8, !tbaa !270
  store i32 %67, i32* %64, align 4, !tbaa !272
  store i32 %65, i32* %66, align 8, !tbaa !270
  tail call fastcc void @removevalues(%struct.FuncState* %50, i32 %67) #17
  %68 = load i32, i32* %66, align 8, !tbaa !270
  tail call fastcc void @removevalues(%struct.FuncState* %50, i32 %68) #17
  br label %133

; <label>:69:                                     ; preds = %3
  %70 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %70, align 8, !tbaa !270
  %71 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %71, align 4, !tbaa !272
  %72 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 5, i32* %72, align 8, !tbaa !273
  %73 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %74 = bitcast %union.anon.8* %73 to i32*
  store i32 0, i32* %74, align 8, !tbaa !21
  %75 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1, i32 0
  %76 = bitcast double* %75 to i64*
  %77 = load i64, i64* %76, align 8, !tbaa !21
  %78 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %77, i64* %78, align 8, !tbaa !21
  br label %132

; <label>:79:                                     ; preds = %3
  %80 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %80, align 8, !tbaa !270
  %81 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %81, align 4, !tbaa !272
  %82 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 6, i32* %82, align 8, !tbaa !273
  %83 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %84 = bitcast %union.anon.8* %83 to i32*
  store i32 0, i32* %84, align 8, !tbaa !21
  %85 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %86 = bitcast %union.SemInfo* %85 to i64*
  %87 = load i64, i64* %86, align 8, !tbaa !21
  %88 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %87, i64* %88, align 8, !tbaa !21
  br label %132

; <label>:89:                                     ; preds = %3
  %90 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %91 = bitcast %union.SemInfo* %90 to %struct.TString**
  %92 = load %struct.TString*, %struct.TString** %91, align 8, !tbaa !21
  tail call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* %1, %struct.TString* %92) #17
  br label %132

; <label>:93:                                     ; preds = %3
  %94 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %94, align 8, !tbaa !270
  %95 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %95, align 4, !tbaa !272
  %96 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 1, i32* %96, align 8, !tbaa !273
  %97 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %98 = bitcast %union.anon.8* %97 to i32*
  store i32 0, i32* %98, align 8, !tbaa !21
  br label %132

; <label>:99:                                     ; preds = %3
  %100 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %100, align 8, !tbaa !270
  %101 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %101, align 4, !tbaa !272
  %102 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 2, i32* %102, align 8, !tbaa !273
  %103 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %104 = bitcast %union.anon.8* %103 to i32*
  store i32 0, i32* %104, align 8, !tbaa !21
  br label %132

; <label>:105:                                    ; preds = %3
  %106 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %106, align 8, !tbaa !270
  %107 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %107, align 4, !tbaa !272
  %108 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 3, i32* %108, align 8, !tbaa !273
  %109 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %110 = bitcast %union.anon.8* %109 to i32*
  store i32 0, i32* %110, align 8, !tbaa !21
  br label %132

; <label>:111:                                    ; preds = %3
  %112 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %113 = load %struct.FuncState*, %struct.FuncState** %112, align 8, !tbaa !263
  %114 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %113, i64 0, i32 0
  %115 = load %struct.Proto*, %struct.Proto** %114, align 8, !tbaa !251
  %116 = getelementptr inbounds %struct.Proto, %struct.Proto* %115, i64 0, i32 4
  %117 = load i8, i8* %116, align 1, !tbaa !102
  %118 = icmp eq i8 %117, 0
  br i1 %118, label %119, label %120

; <label>:119:                                    ; preds = %111
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.253, i64 0, i64 0)) #19
  unreachable

; <label>:120:                                    ; preds = %111
  %121 = tail call fastcc i32 @luaK_code(%struct.FuncState* %113, i32 16777297) #17
  %122 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %122, align 8, !tbaa !270
  %123 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %123, align 4, !tbaa !272
  %124 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 17, i32* %124, align 8, !tbaa !273
  %125 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %126 = bitcast %union.anon.8* %125 to i32*
  store i32 %121, i32* %126, align 8, !tbaa !21
  br label %132

; <label>:127:                                    ; preds = %3
  tail call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  br label %133

; <label>:128:                                    ; preds = %3
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  %129 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %130 = load i32, i32* %129, align 4, !tbaa !264
  tail call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0, i32 %130) #17
  br label %133

; <label>:131:                                    ; preds = %3
  tail call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  br label %133

; <label>:132:                                    ; preds = %120, %105, %99, %93, %89, %79, %69
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  br label %133

; <label>:133:                                    ; preds = %132, %131, %128, %127, %63, %35, %25
  %134 = load i32, i32* %16, align 8, !tbaa !258
  switch i32 %134, label %155 [
    i32 43, label %156
    i32 45, label %135
    i32 42, label %136
    i32 37, label %137
    i32 94, label %138
    i32 47, label %139
    i32 279, label %140
    i32 38, label %141
    i32 124, label %142
    i32 126, label %143
    i32 286, label %144
    i32 287, label %145
    i32 280, label %146
    i32 285, label %147
    i32 282, label %148
    i32 60, label %149
    i32 284, label %150
    i32 62, label %151
    i32 283, label %152
    i32 257, label %153
    i32 272, label %154
  ]

; <label>:135:                                    ; preds = %133
  br label %156

; <label>:136:                                    ; preds = %133
  br label %156

; <label>:137:                                    ; preds = %133
  br label %156

; <label>:138:                                    ; preds = %133
  br label %156

; <label>:139:                                    ; preds = %133
  br label %156

; <label>:140:                                    ; preds = %133
  br label %156

; <label>:141:                                    ; preds = %133
  br label %156

; <label>:142:                                    ; preds = %133
  br label %156

; <label>:143:                                    ; preds = %133
  br label %156

; <label>:144:                                    ; preds = %133
  br label %156

; <label>:145:                                    ; preds = %133
  br label %156

; <label>:146:                                    ; preds = %133
  br label %156

; <label>:147:                                    ; preds = %133
  br label %156

; <label>:148:                                    ; preds = %133
  br label %156

; <label>:149:                                    ; preds = %133
  br label %156

; <label>:150:                                    ; preds = %133
  br label %156

; <label>:151:                                    ; preds = %133
  br label %156

; <label>:152:                                    ; preds = %133
  br label %156

; <label>:153:                                    ; preds = %133
  br label %156

; <label>:154:                                    ; preds = %133
  br label %156

; <label>:155:                                    ; preds = %133
  br label %156

; <label>:156:                                    ; preds = %133, %135, %136, %137, %138, %139, %140, %141, %142, %143, %144, %145, %146, %147, %148, %149, %150, %151, %152, %153, %154, %155
  %157 = phi i32 [ 21, %155 ], [ 20, %154 ], [ 19, %153 ], [ 18, %152 ], [ 17, %151 ], [ 15, %150 ], [ 14, %149 ], [ 13, %148 ], [ 16, %147 ], [ 12, %146 ], [ 11, %145 ], [ 10, %144 ], [ 9, %143 ], [ 8, %142 ], [ 7, %141 ], [ 6, %140 ], [ 5, %139 ], [ 4, %138 ], [ 3, %137 ], [ 2, %136 ], [ 1, %135 ], [ 0, %133 ]
  %158 = bitcast %struct.expdesc* %13 to i8*
  %159 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %160 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %161 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %13, i64 0, i32 3
  %162 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %163 = bitcast %struct.expdesc* %1 to i8*
  %164 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %13, i64 0, i32 2
  %165 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %166 = bitcast i64* %4 to i8*
  %167 = bitcast i32* %5 to i8*
  %168 = bitcast %struct.expdesc* %6 to i8*
  %169 = bitcast i64* %8 to i8*
  %170 = bitcast i32* %9 to i8*
  %171 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %172 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %13, i64 0, i32 0
  %173 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %174 = bitcast %union.anon.8* %173 to i32*
  %175 = bitcast %struct.expdesc* %7 to i8*
  %176 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %13, i64 0, i32 1
  %177 = bitcast %union.anon.8* %176 to i32*
  %178 = bitcast %struct.expdesc* %12 to i8*
  %179 = bitcast %struct.expdesc* %10 to i8*
  %180 = bitcast %struct.expdesc* %11 to i8*
  br label %181

; <label>:181:                                    ; preds = %361, %156
  %182 = phi i32 [ %157, %156 ], [ %362, %361 ]
  %183 = icmp eq i32 %182, 21
  br i1 %183, label %363, label %184

; <label>:184:                                    ; preds = %181
  %185 = zext i32 %182 to i64
  %186 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %185, i32 0
  %187 = load i8, i8* %186, align 2, !tbaa !313
  %188 = zext i8 %187 to i32
  %189 = icmp sgt i32 %188, %2
  br i1 %189, label %190, label %363

; <label>:190:                                    ; preds = %184
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %158) #7
  %191 = load i32, i32* %159, align 4, !tbaa !264
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %192 = load %struct.FuncState*, %struct.FuncState** %160, align 8, !tbaa !263
  switch i32 %182, label %229 [
    i32 19, label %193
    i32 20, label %200
    i32 12, label %207
    i32 0, label %213
    i32 1, label %213
    i32 2, label %213
    i32 5, label %213
    i32 6, label %213
    i32 3, label %213
    i32 4, label %213
    i32 7, label %213
    i32 8, label %213
    i32 9, label %213
    i32 10, label %213
    i32 11, label %213
    i32 13, label %218
    i32 16, label %218
    i32 14, label %223
    i32 15, label %223
    i32 17, label %223
    i32 18, label %223
  ]

; <label>:193:                                    ; preds = %190
  call fastcc void @luaK_goiftrue(%struct.FuncState* %192, %struct.expdesc* %1) #17
  %194 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %185, i32 1
  %195 = load i8, i8* %194, align 1, !tbaa !315
  %196 = zext i8 %195 to i32
  %197 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %13, i32 %196) #16
  %198 = load %struct.FuncState*, %struct.FuncState** %160, align 8, !tbaa !263
  call fastcc void @luaK_dischargevars(%struct.FuncState* %198, %struct.expdesc* nonnull %13) #17
  %199 = load i32, i32* %162, align 4, !tbaa !272
  call fastcc void @luaK_concat(%struct.FuncState* %198, i32* nonnull %161, i32 %199) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  br label %361

; <label>:200:                                    ; preds = %190
  call fastcc void @luaK_goiffalse(%struct.FuncState* %192, %struct.expdesc* %1) #17
  %201 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %185, i32 1
  %202 = load i8, i8* %201, align 1, !tbaa !315
  %203 = zext i8 %202 to i32
  %204 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %13, i32 %203) #16
  %205 = load %struct.FuncState*, %struct.FuncState** %160, align 8, !tbaa !263
  call fastcc void @luaK_dischargevars(%struct.FuncState* %205, %struct.expdesc* nonnull %13) #17
  %206 = load i32, i32* %165, align 8, !tbaa !270
  call fastcc void @luaK_concat(%struct.FuncState* %205, i32* nonnull %164, i32 %206) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  br label %361

; <label>:207:                                    ; preds = %190
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %192, %struct.expdesc* %1) #17
  %208 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %185, i32 1
  %209 = load i8, i8* %208, align 1, !tbaa !315
  %210 = zext i8 %209 to i32
  %211 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %13, i32 %210) #16
  %212 = load %struct.FuncState*, %struct.FuncState** %160, align 8, !tbaa !263
  br label %235

; <label>:213:                                    ; preds = %190, %190, %190, %190, %190, %190, %190, %190, %190, %190, %190, %190
  %214 = call fastcc i32 @tonumeral(%struct.expdesc* %1, %struct.TValue* null) #17
  %215 = icmp eq i32 %214, 0
  br i1 %215, label %216, label %229

; <label>:216:                                    ; preds = %213
  %217 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %192, %struct.expdesc* %1) #17
  br label %229

; <label>:218:                                    ; preds = %190, %190
  %219 = call fastcc i32 @tonumeral(%struct.expdesc* %1, %struct.TValue* null) #17
  %220 = icmp eq i32 %219, 0
  br i1 %220, label %221, label %229

; <label>:221:                                    ; preds = %218
  %222 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %192, %struct.expdesc* %1) #17
  br label %229

; <label>:223:                                    ; preds = %190, %190, %190, %190
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %166) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %167) #7
  %224 = call fastcc i32 @isSCnumber(%struct.expdesc* %1, i64* nonnull %4, i32* nonnull %5) #17
  %225 = icmp eq i32 %224, 0
  br i1 %225, label %226, label %228

; <label>:226:                                    ; preds = %223
  %227 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %192, %struct.expdesc* %1) #17
  br label %228

; <label>:228:                                    ; preds = %226, %223
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %167) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %166) #7
  br label %229

; <label>:229:                                    ; preds = %190, %213, %216, %218, %221, %228
  %230 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %185, i32 1
  %231 = load i8, i8* %230, align 1, !tbaa !315
  %232 = zext i8 %231 to i32
  %233 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %13, i32 %232) #16
  %234 = load %struct.FuncState*, %struct.FuncState** %160, align 8, !tbaa !263
  switch i32 %182, label %361 [
    i32 18, label %359
    i32 17, label %359
    i32 12, label %235
    i32 0, label %283
    i32 2, label %283
    i32 1, label %293
    i32 5, label %293
    i32 6, label %293
    i32 3, label %293
    i32 4, label %293
    i32 7, label %298
    i32 8, label %298
    i32 9, label %298
    i32 10, label %320
    i32 11, label %328
    i32 13, label %332
    i32 16, label %332
    i32 14, label %357
    i32 15, label %357
  ]

; <label>:235:                                    ; preds = %207, %229
  %236 = phi %struct.FuncState* [ %212, %207 ], [ %234, %229 ]
  %237 = phi i32 [ %211, %207 ], [ %233, %229 ]
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %236, %struct.expdesc* nonnull %13) #17
  %238 = call fastcc i32* @previousinstruction(%struct.FuncState* %236) #17
  %239 = load i32, i32* %238, align 4, !tbaa !74
  %240 = and i32 %239, 127
  %241 = icmp eq i32 %240, 54
  br i1 %241, label %242, label %265

; <label>:242:                                    ; preds = %235
  %243 = load i32, i32* %172, align 8, !tbaa !273
  %244 = icmp eq i32 %243, 7
  br i1 %244, label %245, label %255

; <label>:245:                                    ; preds = %242
  %246 = load i32, i32* %177, align 8, !tbaa !21
  %247 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %236, i64 0, i32 13
  %248 = load i8, i8* %247, align 2, !tbaa !288
  %249 = zext i8 %248 to i32
  %250 = icmp slt i32 %246, %249
  br i1 %250, label %255, label %251

; <label>:251:                                    ; preds = %245
  %252 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %236, i64 0, i32 15
  %253 = load i8, i8* %252, align 4, !tbaa !301
  %254 = add i8 %253, -1
  store i8 %254, i8* %252, align 4, !tbaa !301
  br label %255

; <label>:255:                                    ; preds = %242, %245, %251
  %256 = and i32 %239, -16744321
  %257 = load i32, i32* %174, align 8, !tbaa !21
  %258 = shl i32 %257, 7
  %259 = and i32 %258, 32640
  %260 = and i32 %239, 16711680
  %261 = add nuw nsw i32 %260, 65536
  %262 = and i32 %261, 16711680
  %263 = or i32 %262, %256
  %264 = or i32 %263, %259
  store i32 %264, i32* %238, align 4, !tbaa !74
  br label %361

; <label>:265:                                    ; preds = %235
  %266 = load i32, i32* %174, align 8, !tbaa !21
  %267 = shl i32 %266, 7
  %268 = or i32 %267, 131126
  %269 = call fastcc i32 @luaK_code(%struct.FuncState* %236, i32 %268) #17
  %270 = load i32, i32* %172, align 8, !tbaa !273
  %271 = icmp eq i32 %270, 7
  br i1 %271, label %272, label %282

; <label>:272:                                    ; preds = %265
  %273 = load i32, i32* %177, align 8, !tbaa !21
  %274 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %236, i64 0, i32 13
  %275 = load i8, i8* %274, align 2, !tbaa !288
  %276 = zext i8 %275 to i32
  %277 = icmp slt i32 %273, %276
  br i1 %277, label %282, label %278

; <label>:278:                                    ; preds = %272
  %279 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %236, i64 0, i32 15
  %280 = load i8, i8* %279, align 4, !tbaa !301
  %281 = add i8 %280, -1
  store i8 %281, i8* %279, align 4, !tbaa !301
  br label %282

; <label>:282:                                    ; preds = %265, %272, %278
  call fastcc void @luaK_fixline(%struct.FuncState* %236, i32 %191) #17
  br label %361

; <label>:283:                                    ; preds = %229, %229
  %284 = call fastcc i32 @constfolding(%struct.FuncState* %234, i32 %182, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  %285 = icmp eq i32 %284, 0
  br i1 %285, label %286, label %361

; <label>:286:                                    ; preds = %283
  %287 = add i32 %182, 38
  %288 = call fastcc i32 @tonumeral(%struct.expdesc* %1, %struct.TValue* null) #17
  %289 = icmp eq i32 %288, 0
  br i1 %289, label %291, label %290

; <label>:290:                                    ; preds = %286
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %178)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %178, i8* %163, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %158, i8* nonnull %178, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %178)
  br label %291

; <label>:291:                                    ; preds = %290, %286
  %292 = phi i32 [ 1, %290 ], [ 0, %286 ]
  call fastcc void @codearith(%struct.FuncState* %234, i32 %287, %struct.expdesc* %1, %struct.expdesc* nonnull %13, i32 %292, i32 %191) #17
  br label %361

; <label>:293:                                    ; preds = %229, %229, %229, %229, %229
  %294 = call fastcc i32 @constfolding(%struct.FuncState* %234, i32 %182, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  %295 = icmp eq i32 %294, 0
  br i1 %295, label %296, label %361

; <label>:296:                                    ; preds = %293
  %297 = add i32 %182, 38
  call fastcc void @codearith(%struct.FuncState* %234, i32 %297, %struct.expdesc* %1, %struct.expdesc* nonnull %13, i32 0, i32 %191) #17
  br label %361

; <label>:298:                                    ; preds = %229, %229, %229
  %299 = call fastcc i32 @constfolding(%struct.FuncState* %234, i32 %182, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  %300 = icmp eq i32 %299, 0
  br i1 %300, label %301, label %361

; <label>:301:                                    ; preds = %298
  %302 = load i32, i32* %171, align 8, !tbaa !273
  %303 = icmp eq i32 %302, 6
  br i1 %303, label %304, label %308

; <label>:304:                                    ; preds = %301
  %305 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %234, %struct.expdesc* nonnull %1) #17
  %306 = icmp eq i32 %305, 0
  br i1 %306, label %308, label %307

; <label>:307:                                    ; preds = %304
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %180)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %180, i8* nonnull %163, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %158, i8* nonnull %180, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %180)
  br label %316

; <label>:308:                                    ; preds = %304, %301
  %309 = load i32, i32* %172, align 8, !tbaa !273
  %310 = icmp eq i32 %309, 6
  br i1 %310, label %311, label %314

; <label>:311:                                    ; preds = %308
  %312 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %234, %struct.expdesc* nonnull %13) #17
  %313 = icmp eq i32 %312, 0
  br i1 %313, label %314, label %316

; <label>:314:                                    ; preds = %311, %308
  %315 = add i32 %182, 38
  call fastcc void @codebinexpval(%struct.FuncState* %234, i32 %315, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %13, i32 %191) #17
  br label %361

; <label>:316:                                    ; preds = %311, %307
  %317 = phi i32 [ 1, %307 ], [ 0, %311 ]
  %318 = load i32, i32* %177, align 8, !tbaa !21
  %319 = add i32 %182, 26
  call fastcc void @finishbinexpval(%struct.FuncState* %234, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %13, i32 %319, i32 %318, i32 %317, i32 %191) #17
  br label %361

; <label>:320:                                    ; preds = %229
  %321 = call fastcc i32 @constfolding(%struct.FuncState* %234, i32 10, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  %322 = icmp eq i32 %321, 0
  br i1 %322, label %323, label %361

; <label>:323:                                    ; preds = %320
  %324 = call fastcc i32 @isSCint(%struct.expdesc* %1) #17
  %325 = icmp eq i32 %324, 0
  br i1 %325, label %327, label %326

; <label>:326:                                    ; preds = %323
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %179)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %179, i8* %163, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %158, i8* nonnull %179, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %179)
  call fastcc void @codebini(%struct.FuncState* %234, i32 37, %struct.expdesc* %1, %struct.expdesc* nonnull %13, i32 1, i32 %191) #17
  br label %361

; <label>:327:                                    ; preds = %323
  call fastcc void @codeshift(%struct.FuncState* %234, i32 48, %struct.expdesc* %1, %struct.expdesc* nonnull %13, i32 %191) #17
  br label %361

; <label>:328:                                    ; preds = %229
  %329 = call fastcc i32 @constfolding(%struct.FuncState* %234, i32 11, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  %330 = icmp eq i32 %329, 0
  br i1 %330, label %331, label %361

; <label>:331:                                    ; preds = %328
  call fastcc void @codeshift(%struct.FuncState* %234, i32 49, %struct.expdesc* %1, %struct.expdesc* nonnull %13, i32 %191) #17
  br label %361

; <label>:332:                                    ; preds = %229, %229
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %169) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %170) #7
  store i32 0, i32* %9, align 4, !tbaa !74
  %333 = load i32, i32* %171, align 8, !tbaa !273
  %334 = icmp eq i32 %333, 7
  br i1 %334, label %336, label %335

; <label>:335:                                    ; preds = %332
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %175)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %175, i8* nonnull %163, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %158, i8* nonnull %175, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %175)
  br label %336

; <label>:336:                                    ; preds = %335, %332
  %337 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %234, %struct.expdesc* nonnull %1) #17
  %338 = call fastcc i32 @isSCnumber(%struct.expdesc* nonnull %13, i64* nonnull %8, i32* nonnull %9) #17
  %339 = icmp eq i32 %338, 0
  br i1 %339, label %343, label %340

; <label>:340:                                    ; preds = %336
  %341 = load i64, i64* %8, align 8, !tbaa !129
  %342 = trunc i64 %341 to i32
  br label %350

; <label>:343:                                    ; preds = %336
  %344 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %234, %struct.expdesc* nonnull %13) #17
  %345 = icmp eq i32 %344, 0
  br i1 %345, label %348, label %346

; <label>:346:                                    ; preds = %343
  %347 = load i32, i32* %177, align 8, !tbaa !21
  br label %350

; <label>:348:                                    ; preds = %343
  %349 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %234, %struct.expdesc* nonnull %13) #17
  br label %350

; <label>:350:                                    ; preds = %348, %346, %340
  %351 = phi i32 [ %342, %340 ], [ %347, %346 ], [ %349, %348 ]
  %352 = phi i32 [ 62, %340 ], [ 61, %346 ], [ 58, %348 ]
  call fastcc void @freeexps(%struct.FuncState* %234, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %13) #17
  %353 = load i32, i32* %9, align 4, !tbaa !74
  %354 = icmp eq i32 %182, 13
  %355 = zext i1 %354 to i32
  %356 = call fastcc i32 @condjump(%struct.FuncState* %234, i32 %352, i32 %337, i32 %351, i32 %353, i32 %355) #17
  store i32 %356, i32* %174, align 8, !tbaa !21
  store i32 14, i32* %171, align 8, !tbaa !273
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %170) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %169) #7
  br label %361

; <label>:357:                                    ; preds = %229, %229
  %358 = add i32 %182, 45
  call fastcc void @codeorder(%struct.FuncState* %234, i32 %358, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  br label %361

; <label>:359:                                    ; preds = %229, %229
  %360 = add i32 %182, 42
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %168)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %168, i8* %163, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %163, i8* nonnull %158, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %158, i8* nonnull %168, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %168)
  call fastcc void @codeorder(%struct.FuncState* %234, i32 %360, %struct.expdesc* %1, %struct.expdesc* nonnull %13) #17
  br label %361

; <label>:361:                                    ; preds = %229, %193, %200, %255, %282, %283, %291, %293, %296, %298, %314, %316, %320, %326, %327, %328, %331, %350, %357, %359
  %362 = phi i32 [ %233, %229 ], [ %197, %193 ], [ %204, %200 ], [ %237, %255 ], [ %237, %282 ], [ %233, %283 ], [ %233, %291 ], [ %233, %293 ], [ %233, %296 ], [ %233, %298 ], [ %233, %314 ], [ %233, %316 ], [ %233, %320 ], [ %233, %326 ], [ %233, %327 ], [ %233, %328 ], [ %233, %331 ], [ %233, %350 ], [ %233, %357 ], [ %233, %359 ]
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %158) #7
  br label %181

; <label>:363:                                    ; preds = %181, %184
  %364 = phi i32 [ 21, %181 ], [ %182, %184 ]
  %365 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !259
  %366 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %365, i64 0, i32 19
  %367 = load i32, i32* %366, align 8, !tbaa !54
  %368 = add i32 %367, -1
  store i32 %368, i32* %366, align 8, !tbaa !54
  ret i32 %364
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @constfolding(%struct.FuncState* nocapture readonly, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = bitcast %struct.TValue* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %9) #7
  %10 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = bitcast %struct.TValue* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #7
  %12 = call fastcc i32 @tonumeral(%struct.expdesc* %2, %struct.TValue* nonnull %6) #16
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %70, label %14

; <label>:14:                                     ; preds = %4
  %15 = call fastcc i32 @tonumeral(%struct.expdesc* %3, %struct.TValue* nonnull %7) #16
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %70, label %17

; <label>:17:                                     ; preds = %14
  switch i32 %1, label %48 [
    i32 7, label %18
    i32 8, label %18
    i32 9, label %18
    i32 10, label %18
    i32 11, label %18
    i32 13, label %18
    i32 5, label %35
    i32 6, label %35
    i32 3, label %35
  ]

; <label>:18:                                     ; preds = %17, %17, %17, %17, %17, %17
  %19 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %19) #7
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = icmp eq i8 %21, 35
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %18
  %24 = bitcast %struct.TValue* %6 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !21
  store i64 %25, i64* %5, align 8, !tbaa !129
  br label %30

; <label>:26:                                     ; preds = %18
  %27 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %6, i64* nonnull %5, i32 0) #17
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %29, label %30

; <label>:29:                                     ; preds = %26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %19) #7
  br label %70

; <label>:30:                                     ; preds = %26, %23
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = icmp eq i8 %32, 35
  br i1 %33, label %34, label %45

; <label>:34:                                     ; preds = %30
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %19) #7
  br label %48

; <label>:35:                                     ; preds = %17, %17, %17
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %37 = load i8, i8* %36, align 8, !tbaa !22
  %38 = icmp eq i8 %37, 35
  %39 = bitcast %struct.TValue* %7 to i64*
  %40 = load i64, i64* %39, align 8
  %41 = sitofp i64 %40 to double
  %42 = bitcast i64 %40 to double
  %43 = select i1 %38, double %41, double %42
  %44 = fcmp une double %43, 0.000000e+00
  br i1 %44, label %48, label %70

; <label>:45:                                     ; preds = %30
  %46 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %7, i64* nonnull %5, i32 0) #17
  %47 = icmp eq i32 %46, 0
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %19) #7
  br i1 %47, label %70, label %48

; <label>:48:                                     ; preds = %45, %34, %35, %17
  %49 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %50 = load %struct.LexState*, %struct.LexState** %49, align 8, !tbaa !276
  %51 = getelementptr inbounds %struct.LexState, %struct.LexState* %50, i64 0, i32 6
  %52 = load %struct.lua_State*, %struct.lua_State** %51, align 8, !tbaa !259
  %53 = call fastcc i32 @luaO_rawarith(%struct.lua_State* %52, i32 %1, %struct.TValue* nonnull %6, %struct.TValue* nonnull %7, %struct.TValue* nonnull %8) #16
  %54 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %55 = load i8, i8* %54, align 8, !tbaa !22
  %56 = icmp eq i8 %55, 35
  br i1 %56, label %57, label %62

; <label>:57:                                     ; preds = %48
  %58 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 6, i32* %58, align 8, !tbaa !273
  %59 = bitcast %struct.TValue* %8 to i64*
  %60 = load i64, i64* %59, align 8, !tbaa !21
  %61 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  store i64 %60, i64* %61, align 8, !tbaa !21
  br label %70

; <label>:62:                                     ; preds = %48
  %63 = bitcast %struct.TValue* %8 to double*
  %64 = load double, double* %63, align 8, !tbaa !21
  %65 = fcmp ueq double %64, 0.000000e+00
  br i1 %65, label %70, label %66

; <label>:66:                                     ; preds = %62
  %67 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 5, i32* %67, align 8, !tbaa !273
  %68 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %69 = bitcast %union.anon.8* %68 to double*
  store double %64, double* %69, align 8, !tbaa !21
  br label %70

; <label>:70:                                     ; preds = %45, %29, %35, %57, %66, %62, %4, %14
  %71 = phi i32 [ 0, %45 ], [ 0, %14 ], [ 0, %4 ], [ 0, %62 ], [ 1, %66 ], [ 1, %57 ], [ 0, %35 ], [ 0, %29 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %9) #7
  ret i32 %71
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @tonumeral(%struct.expdesc* nocapture readonly, %struct.TValue*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 8, !tbaa !270
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !272
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %8, label %25

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !273
  switch i32 %10, label %25 [
    i32 6, label %11
    i32 5, label %18
  ]

; <label>:11:                                     ; preds = %8
  %12 = icmp eq %struct.TValue* %1, null
  br i1 %12, label %25, label %13

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %1 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 35, i8* %17, align 8, !tbaa !22
  br label %25

; <label>:18:                                     ; preds = %8
  %19 = icmp eq %struct.TValue* %1, null
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %18
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %22 = load i64, i64* %21, align 8, !tbaa !21
  %23 = bitcast %struct.TValue* %1 to i64*
  store i64 %22, i64* %23, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 19, i8* %24, align 8, !tbaa !22
  br label %25

; <label>:25:                                     ; preds = %8, %20, %18, %13, %11, %2
  %26 = phi i32 [ 0, %2 ], [ 1, %11 ], [ 1, %13 ], [ 1, %18 ], [ 1, %20 ], [ 0, %8 ]
  ret i32 %26
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  br label %24

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %11 = load i32, i32* %10, align 8, !tbaa !270
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !272
  %14 = icmp eq i32 %11, %13
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %16 = bitcast %union.anon.8* %15 to i32*
  %17 = load i32, i32* %16, align 8, !tbaa !21
  br i1 %14, label %29, label %18

; <label>:18:                                     ; preds = %9
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %20 = load i8, i8* %19, align 2, !tbaa !288
  %21 = zext i8 %20 to i32
  %22 = icmp slt i32 %17, %21
  br i1 %22, label %24, label %23

; <label>:23:                                     ; preds = %18
  tail call fastcc void @exp2reg(%struct.FuncState* nonnull %0, %struct.expdesc* nonnull %1, i32 %17) #16
  br label %26

; <label>:24:                                     ; preds = %6, %18
  %25 = phi i32* [ %8, %6 ], [ %16, %18 ]
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  br label %26

; <label>:26:                                     ; preds = %23, %24
  %27 = phi i32* [ %25, %24 ], [ %16, %23 ]
  %28 = load i32, i32* %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %26, %9
  %30 = phi i32 [ %17, %9 ], [ %28, %26 ]
  ret i32 %30
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @freeexp(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %6, label %18

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %11 = load i8, i8* %10, align 2, !tbaa !288
  %12 = zext i8 %11 to i32
  %13 = icmp slt i32 %9, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %16 = load i8, i8* %15, align 4, !tbaa !301
  %17 = add i8 %16, -1
  store i8 %17, i8* %15, align 4, !tbaa !301
  br label %18

; <label>:18:                                     ; preds = %14, %6, %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_fixline(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %0) #16
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %4, i32 %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_dischargevars(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  switch i32 %4, label %98 [
    i32 8, label %5
    i32 9, label %6
    i32 11, label %13
    i32 12, label %28
    i32 13, label %53
    i32 10, label %78
    i32 17, label %97
    i32 16, label %97
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = shl i32 %9, 16
  %11 = or i32 %10, 7
  %12 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %11) #17
  store i32 %12, i32* %8, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %15 = bitcast %union.anon.8* %14 to %struct.anon.9*
  %16 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %15, i64 0, i32 1
  %17 = load i8, i8* %16, align 2, !tbaa !21
  %18 = zext i8 %17 to i32
  %19 = bitcast %union.anon.8* %14 to i16*
  %20 = load i16, i16* %19, align 8, !tbaa !21
  %21 = zext i16 %20 to i32
  %22 = shl nuw nsw i32 %18, 16
  %23 = shl i32 %21, 24
  %24 = or i32 %22, %23
  %25 = or i32 %24, 9
  %26 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %25) #17
  %27 = bitcast %union.anon.8* %14 to i32*
  store i32 %26, i32* %27, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:28:                                     ; preds = %2
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %30 = bitcast %union.anon.8* %29 to %struct.anon.9*
  %31 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 2, !tbaa !21
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %34 = load i8, i8* %33, align 2, !tbaa !288
  %35 = icmp ugt i8 %34, %32
  br i1 %35, label %41, label %36

; <label>:36:                                     ; preds = %28
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %38 = load i8, i8* %37, align 4, !tbaa !301
  %39 = add i8 %38, -1
  store i8 %39, i8* %37, align 4, !tbaa !301
  %40 = load i8, i8* %31, align 2, !tbaa !21
  br label %41

; <label>:41:                                     ; preds = %28, %36
  %42 = phi i8 [ %32, %28 ], [ %40, %36 ]
  %43 = zext i8 %42 to i32
  %44 = bitcast %union.anon.8* %29 to i16*
  %45 = load i16, i16* %44, align 8, !tbaa !21
  %46 = zext i16 %45 to i32
  %47 = shl nuw nsw i32 %43, 16
  %48 = shl i32 %46, 24
  %49 = or i32 %47, %48
  %50 = or i32 %49, 11
  %51 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %50) #17
  %52 = bitcast %union.anon.8* %29 to i32*
  store i32 %51, i32* %52, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:53:                                     ; preds = %2
  %54 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %55 = bitcast %union.anon.8* %54 to %struct.anon.9*
  %56 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %55, i64 0, i32 1
  %57 = load i8, i8* %56, align 2, !tbaa !21
  %58 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %59 = load i8, i8* %58, align 2, !tbaa !288
  %60 = icmp ugt i8 %59, %57
  br i1 %60, label %66, label %61

; <label>:61:                                     ; preds = %53
  %62 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %63 = load i8, i8* %62, align 4, !tbaa !301
  %64 = add i8 %63, -1
  store i8 %64, i8* %62, align 4, !tbaa !301
  %65 = load i8, i8* %56, align 2, !tbaa !21
  br label %66

; <label>:66:                                     ; preds = %53, %61
  %67 = phi i8 [ %57, %53 ], [ %65, %61 ]
  %68 = zext i8 %67 to i32
  %69 = bitcast %union.anon.8* %54 to i16*
  %70 = load i16, i16* %69, align 8, !tbaa !21
  %71 = zext i16 %70 to i32
  %72 = shl nuw nsw i32 %68, 16
  %73 = shl i32 %71, 24
  %74 = or i32 %72, %73
  %75 = or i32 %74, 12
  %76 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %75) #17
  %77 = bitcast %union.anon.8* %54 to i32*
  store i32 %76, i32* %77, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:78:                                     ; preds = %2
  %79 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %80 = bitcast %union.anon.8* %79 to %struct.anon.9*
  %81 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %80, i64 0, i32 1
  %82 = load i8, i8* %81, align 2, !tbaa !21
  %83 = zext i8 %82 to i32
  %84 = bitcast %union.anon.8* %79 to i16*
  %85 = load i16, i16* %84, align 8, !tbaa !21
  %86 = sext i16 %85 to i32
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %83, i32 %86) #16
  %87 = load i8, i8* %81, align 2, !tbaa !21
  %88 = zext i8 %87 to i32
  %89 = load i16, i16* %84, align 8, !tbaa !21
  %90 = zext i16 %89 to i32
  %91 = shl nuw nsw i32 %88, 16
  %92 = shl i32 %90, 24
  %93 = or i32 %91, %92
  %94 = or i32 %93, 10
  %95 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %94) #17
  %96 = bitcast %union.anon.8* %79 to i32*
  store i32 %95, i32* %96, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %98

; <label>:97:                                     ; preds = %2, %2
  tail call fastcc void @luaK_setoneret(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  br label %98

; <label>:98:                                     ; preds = %2, %97, %78, %66, %41, %13, %6, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @exp2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %2) #16
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp eq i32 %5, 14
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  br i1 %6, label %8, label %12

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %10 = bitcast %union.anon.8* %9 to i32*
  %11 = load i32, i32* %10, align 8, !tbaa !21
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %7, i32 %11) #16
  br label %12

; <label>:12:                                     ; preds = %3, %8
  %13 = load i32, i32* %7, align 8, !tbaa !270
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !272
  %16 = icmp eq i32 %13, %15
  br i1 %16, label %41, label %17

; <label>:17:                                     ; preds = %12
  %18 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %13) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %17
  %21 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %15) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %33, label %23

; <label>:23:                                     ; preds = %20, %17
  %24 = load i32, i32* %4, align 8, !tbaa !273
  %25 = icmp eq i32 %24, 14
  br i1 %25, label %28, label %26

; <label>:26:                                     ; preds = %23
  %27 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %0) #16
  br label %28

; <label>:28:                                     ; preds = %23, %26
  %29 = phi i32 [ %27, %26 ], [ -1, %23 ]
  %30 = tail call fastcc i32 @code_loadbool(%struct.FuncState* %0, i32 %2, i32 0, i32 1) #16
  %31 = tail call fastcc i32 @code_loadbool(%struct.FuncState* %0, i32 %2, i32 1, i32 0) #16
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %29) #16
  %32 = load i32, i32* %14, align 4, !tbaa !272
  br label %33

; <label>:33:                                     ; preds = %20, %28
  %34 = phi i32 [ %32, %28 ], [ %15, %20 ]
  %35 = phi i32 [ %31, %28 ], [ -1, %20 ]
  %36 = phi i32 [ %30, %28 ], [ -1, %20 ]
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %38 = load i32, i32* %37, align 8, !tbaa !277
  %39 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %38, i32* %39, align 4, !tbaa !279
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %34, i32 %38, i32 %2, i32 %36) #16
  %40 = load i32, i32* %7, align 8, !tbaa !270
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %40, i32 %38, i32 %2, i32 %35) #16
  br label %41

; <label>:41:                                     ; preds = %12, %33
  store i32 -1, i32* %7, align 8, !tbaa !270
  store i32 -1, i32* %14, align 4, !tbaa !272
  %42 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %43 = bitcast %union.anon.8* %42 to i32*
  store i32 %2, i32* %43, align 8, !tbaa !21
  store i32 7, i32* %4, align 8, !tbaa !273
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_exp2nextreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %1) #16
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %0, i32 1) #16
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !301
  %5 = zext i8 %4 to i32
  %6 = add nsw i32 %5, -1
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %6) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @freeregs(%struct.FuncState* nocapture, i32, i32) unnamed_addr #2 {
  %4 = icmp sgt i32 %1, %2
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !288
  %7 = zext i8 %6 to i32
  br i1 %4, label %8, label %20

; <label>:8:                                      ; preds = %3
  %9 = icmp sgt i32 %7, %1
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %8
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %12 = load i8, i8* %11, align 4, !tbaa !301
  %13 = add i8 %12, -1
  store i8 %13, i8* %11, align 4, !tbaa !301
  br label %14

; <label>:14:                                     ; preds = %8, %10
  %15 = icmp sgt i32 %7, %2
  br i1 %15, label %32, label %16

; <label>:16:                                     ; preds = %14
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %18 = load i8, i8* %17, align 4, !tbaa !301
  %19 = add i8 %18, -1
  store i8 %19, i8* %17, align 4, !tbaa !301
  br label %32

; <label>:20:                                     ; preds = %3
  %21 = icmp sgt i32 %7, %2
  br i1 %21, label %26, label %22

; <label>:22:                                     ; preds = %20
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %24 = load i8, i8* %23, align 4, !tbaa !301
  %25 = add i8 %24, -1
  store i8 %25, i8* %23, align 4, !tbaa !301
  br label %26

; <label>:26:                                     ; preds = %20, %22
  %27 = icmp sgt i32 %7, %1
  br i1 %27, label %32, label %28

; <label>:28:                                     ; preds = %26
  %29 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %30 = load i8, i8* %29, align 4, !tbaa !301
  %31 = add i8 %30, -1
  store i8 %31, i8* %29, align 4, !tbaa !301
  br label %32

; <label>:32:                                     ; preds = %28, %26, %16, %14
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @luaK_setoneret(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  switch i32 %4, label %31 [
    i32 16, label %5
    i32 17, label %18
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !273
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %9 = load i32*, i32** %8, align 8, !tbaa !119
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, i32* %9, i64 %13
  %15 = load i32, i32* %14, align 4, !tbaa !74
  %16 = lshr i32 %15, 7
  %17 = and i32 %16, 255
  store i32 %17, i32* %11, align 8, !tbaa !21
  br label %31

; <label>:18:                                     ; preds = %2
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %20 = load %struct.Proto*, %struct.Proto** %19, align 8, !tbaa !251
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %20, i64 0, i32 16
  %22 = load i32*, i32** %21, align 8, !tbaa !119
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = load i32, i32* %24, align 8, !tbaa !21
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds i32, i32* %22, i64 %26
  %28 = load i32, i32* %27, align 4, !tbaa !74
  %29 = and i32 %28, 16777215
  %30 = or i32 %29, 33554432
  store i32 %30, i32* %27, align 4, !tbaa !74
  store i32 15, i32* %3, align 8, !tbaa !273
  br label %31

; <label>:31:                                     ; preds = %2, %18, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @discharge2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !273
  switch i32 %6, label %64 [
    i32 1, label %7
    i32 3, label %8
    i32 2, label %8
    i32 4, label %16
    i32 5, label %20
    i32 6, label %33
    i32 15, label %36
    i32 7, label %51
  ]

; <label>:7:                                      ; preds = %3
  tail call fastcc void @luaK_nil(%struct.FuncState* %0, i32 %2, i32 1) #16
  br label %61

; <label>:8:                                      ; preds = %3, %3
  %9 = icmp eq i32 %6, 2
  %10 = zext i1 %9 to i32
  %11 = shl i32 %2, 7
  %12 = shl nuw nsw i32 %10, 16
  %13 = or i32 %11, %12
  %14 = or i32 %13, 5
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14) #17
  br label %61

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  %19 = load i32, i32* %18, align 8, !tbaa !21
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %2, i32 %19) #16
  br label %61

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %22 = bitcast %union.anon.8* %21 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %24) #7
  %25 = call fastcc i32 @floatI(double %23, i64* nonnull %4) #17
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %30, label %27

; <label>:27:                                     ; preds = %20
  %28 = load i64, i64* %4, align 8, !tbaa !129
  %29 = trunc i64 %28 to i32
  tail call fastcc void @luaK_codeAsBx(%struct.FuncState* %0, i32 2, i32 %2, i32 %29) #17
  br label %32

; <label>:30:                                     ; preds = %20
  %31 = tail call fastcc i32 @luaK_numberK(%struct.FuncState* %0, double %23) #17
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %2, i32 %31) #17
  br label %32

; <label>:32:                                     ; preds = %27, %30
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %24) #7
  br label %61

; <label>:33:                                     ; preds = %3
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %35 = load i64, i64* %34, align 8, !tbaa !21
  tail call fastcc void @luaK_int(%struct.FuncState* %0, i32 %2, i64 %35) #16
  br label %61

; <label>:36:                                     ; preds = %3
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %38 = load %struct.Proto*, %struct.Proto** %37, align 8, !tbaa !251
  %39 = getelementptr inbounds %struct.Proto, %struct.Proto* %38, i64 0, i32 16
  %40 = load i32*, i32** %39, align 8, !tbaa !119
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %42 = bitcast %union.anon.8* %41 to i32*
  %43 = load i32, i32* %42, align 8, !tbaa !21
  %44 = sext i32 %43 to i64
  %45 = getelementptr inbounds i32, i32* %40, i64 %44
  %46 = load i32, i32* %45, align 4, !tbaa !74
  %47 = and i32 %46, -32641
  %48 = shl i32 %2, 7
  %49 = and i32 %48, 32640
  %50 = or i32 %47, %49
  store i32 %50, i32* %45, align 4, !tbaa !74
  br label %61

; <label>:51:                                     ; preds = %3
  %52 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %53 = bitcast %union.anon.8* %52 to i32*
  %54 = load i32, i32* %53, align 8, !tbaa !21
  %55 = icmp eq i32 %54, %2
  br i1 %55, label %61, label %56

; <label>:56:                                     ; preds = %51
  %57 = shl i32 %2, 7
  %58 = shl i32 %54, 16
  %59 = or i32 %58, %57
  %60 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %59) #17
  br label %61

; <label>:61:                                     ; preds = %51, %56, %36, %33, %32, %16, %8, %7
  %62 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %63 = bitcast %union.anon.8* %62 to i32*
  store i32 %2, i32* %63, align 8, !tbaa !21
  store i32 7, i32* %5, align 8, !tbaa !273
  br label %64

; <label>:64:                                     ; preds = %3, %61
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @need_value(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  br label %3

; <label>:3:                                      ; preds = %11, %2
  %4 = phi i32 [ %1, %2 ], [ %12, %11 ]
  %5 = icmp eq i32 %4, -1
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %4) #16
  %8 = load i32, i32* %7, align 4, !tbaa !74
  %9 = and i32 %8, 127
  %10 = icmp eq i32 %9, 68
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %6
  %12 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %4) #16
  br label %3

; <label>:13:                                     ; preds = %3, %6
  %14 = phi i32 [ 1, %6 ], [ 0, %3 ]
  ret i32 %14
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @code_loadbool(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %6 = load i32, i32* %5, align 8, !tbaa !277
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %6, i32* %7, align 4, !tbaa !279
  %8 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 5, i32 %1, i32 %2, i32 %3, i32 0) #16
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @patchlistaux(%struct.FuncState* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  br label %6

; <label>:6:                                      ; preds = %15, %5
  %7 = phi i32 [ %1, %5 ], [ %10, %15 ]
  %8 = icmp eq i32 %7, -1
  br i1 %8, label %16, label %9

; <label>:9:                                      ; preds = %6
  %10 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %7) #16
  %11 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %7, i32 %3) #16
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %9
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %7, i32 %2) #16
  br label %15

; <label>:14:                                     ; preds = %9
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %7, i32 %4) #16
  br label %15

; <label>:15:                                     ; preds = %14, %13
  br label %6

; <label>:16:                                     ; preds = %6
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_nil(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = add nsw i32 %2, %1
  %5 = add i32 %4, 255
  %6 = tail call fastcc i32* @previousinstruction(%struct.FuncState* %0) #16
  %7 = load i32, i32* %6, align 4, !tbaa !74
  %8 = and i32 %7, 127
  %9 = icmp eq i32 %8, 6
  br i1 %9, label %10, label %37

; <label>:10:                                     ; preds = %3
  %11 = lshr i32 %7, 7
  %12 = and i32 %11, 255
  %13 = lshr i32 %7, 16
  %14 = and i32 %13, 255
  %15 = add nuw nsw i32 %12, %14
  %16 = icmp sgt i32 %12, %1
  %17 = add nuw nsw i32 %15, 1
  %18 = icmp slt i32 %17, %1
  %19 = or i1 %16, %18
  br i1 %19, label %20, label %24

; <label>:20:                                     ; preds = %10
  %21 = icmp slt i32 %12, %1
  %22 = icmp sgt i32 %12, %4
  %23 = or i1 %21, %22
  br i1 %23, label %37, label %24

; <label>:24:                                     ; preds = %10, %20
  %25 = icmp slt i32 %12, %1
  %26 = select i1 %25, i32 %12, i32 %1
  %27 = icmp slt i32 %15, %4
  %28 = select i1 %27, i32 %5, i32 %15
  %29 = and i32 %7, -16744321
  %30 = shl i32 %26, 7
  %31 = and i32 %30, 32640
  %32 = or i32 %31, %29
  %33 = sub i32 %28, %26
  %34 = shl i32 %33, 16
  %35 = and i32 %34, 16711680
  %36 = or i32 %32, %35
  store i32 %36, i32* %6, align 4, !tbaa !74
  br label %44

; <label>:37:                                     ; preds = %20, %3
  %38 = shl i32 %1, 7
  %39 = shl i32 %2, 16
  %40 = add i32 %39, -65536
  %41 = or i32 %38, %40
  %42 = or i32 %41, 6
  %43 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %42) #17
  br label %44

; <label>:44:                                     ; preds = %24, %37
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_codek(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = icmp slt i32 %2, 131072
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i32 @luaK_codeABx(%struct.FuncState* %0, i32 3, i32 %1, i32 %2) #16
  br label %11

; <label>:7:                                      ; preds = %3
  %8 = shl i32 %1, 7
  %9 = or i32 %8, 4
  %10 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %9) #17
  tail call fastcc void @codeextraarg(%struct.FuncState* %0, i32 %2) #16
  br label %11

; <label>:11:                                     ; preds = %7, %5
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_int(%struct.FuncState* nocapture, i32, i64) unnamed_addr #0 {
  %4 = add i64 %2, 65535
  %5 = icmp ugt i64 %4, 131071
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = trunc i64 %2 to i32
  tail call fastcc void @luaK_codeAsBx(%struct.FuncState* %0, i32 1, i32 %1, i32 %7) #16
  br label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc i32 @luaK_intK(%struct.FuncState* %0, i64 %2) #16
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %1, i32 %9) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32* @previousinstruction(%struct.FuncState* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %3 = load i32, i32* %2, align 8, !tbaa !277
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  %5 = load i32, i32* %4, align 4, !tbaa !279
  %6 = icmp sgt i32 %3, %5
  br i1 %6, label %7, label %15

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !119
  %12 = add nsw i32 %3, -1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, i32* %11, i64 %13
  br label %15

; <label>:15:                                     ; preds = %1, %7
  %16 = phi i32* [ %14, %7 ], [ @previousinstruction.invalidinstruction, %1 ]
  ret i32* %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_codeABx(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = shl i32 %2, 7
  %6 = or i32 %5, %1
  %7 = shl i32 %3, 15
  %8 = or i32 %6, %7
  %9 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %8) #16
  ret i32 %9
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codeextraarg(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 7
  %4 = or i32 %3, 83
  %5 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %4) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @floatI(double, i64* nocapture) unnamed_addr #0 {
  %3 = tail call double @llvm.floor.f64(double %0) #7
  %4 = fcmp une double %3, %0
  br i1 %4, label %14, label %5

; <label>:5:                                      ; preds = %2
  %6 = fcmp oge double %3, 0xC3E0000000000000
  %7 = fcmp olt double %3, 0x43E0000000000000
  %8 = and i1 %6, %7
  br i1 %8, label %9, label %14

; <label>:9:                                      ; preds = %5
  %10 = fptosi double %3 to i64
  store i64 %10, i64* %1, align 8, !tbaa !129
  %11 = add i64 %10, 65535
  %12 = icmp ult i64 %11, 131072
  %13 = zext i1 %12 to i32
  br label %14

; <label>:14:                                     ; preds = %2, %5, %9
  %15 = phi i32 [ %13, %9 ], [ 0, %5 ], [ 0, %2 ]
  ret i32 %15
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_codeAsBx(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = shl i32 %2, 7
  %6 = or i32 %5, %1
  %7 = shl i32 %3, 15
  %8 = add i32 %7, 2147450880
  %9 = or i32 %6, %8
  %10 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %9) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_numberK(%struct.FuncState* nocapture, double) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to double*
  store double %1, double* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 19, i8* %6, align 8, !tbaa !22
  %7 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @addk(%struct.FuncState* nocapture, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !276
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !259
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !248
  %12 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %7, %struct.Table* %11, %struct.TValue* %1) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = icmp eq i8 %14, 35
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %18 = bitcast %struct.TValue* %12 to i64*
  br label %42

; <label>:19:                                     ; preds = %3
  %20 = bitcast %struct.TValue* %12 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !21
  %22 = trunc i64 %21 to i32
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %24 = load i32, i32* %23, align 4, !tbaa !280
  %25 = icmp sgt i32 %24, %22
  br i1 %25, label %26, label %42

; <label>:26:                                     ; preds = %19
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !221
  %29 = shl i64 %21, 32
  %30 = ashr exact i64 %29, 32
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %30, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = xor i8 %34, %32
  %36 = and i8 %35, 63
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %42

; <label>:38:                                     ; preds = %26
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %30
  %40 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %39, %struct.TValue* nonnull %2) #16
  %41 = icmp eq i32 %40, 0
  br i1 %41, label %42, label %90

; <label>:42:                                     ; preds = %16, %38, %19, %26
  %43 = phi i64* [ %18, %16 ], [ %20, %38 ], [ %20, %19 ], [ %20, %26 ]
  %44 = phi i32* [ %17, %16 ], [ %23, %38 ], [ %23, %19 ], [ %23, %26 ]
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 7
  %46 = load i32, i32* %45, align 4, !tbaa !222
  %47 = load i32, i32* %44, align 4, !tbaa !280
  %48 = sext i32 %47 to i64
  store i64 %48, i64* %43, align 8, !tbaa !21
  store i8 35, i8* %13, align 8, !tbaa !22
  %49 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %50 = bitcast %struct.TValue** %49 to i8**
  %51 = load i8*, i8** %50, align 8, !tbaa !221
  %52 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %7, i8* %51, i32 %47, i32* nonnull %45, i32 16, i32 33554431, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.250, i64 0, i64 0)) #16
  store i8* %52, i8** %50, align 8, !tbaa !221
  %53 = load i32, i32* %45, align 4, !tbaa !222
  %54 = bitcast i8* %52 to %struct.TValue*
  %55 = sext i32 %46 to i64
  %56 = sext i32 %53 to i64
  br label %57

; <label>:57:                                     ; preds = %60, %42
  %58 = phi i64 [ %61, %60 ], [ %55, %42 ]
  %59 = icmp slt i64 %58, %56
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %57
  %61 = add nsw i64 %58, 1
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 %58, i32 1
  store i8 0, i8* %62, align 8, !tbaa !22
  br label %57

; <label>:63:                                     ; preds = %57
  %64 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 %48
  %65 = bitcast %struct.TValue* %2 to i64*
  %66 = bitcast %struct.TValue* %64 to i64*
  %67 = load i64, i64* %65, align 8
  store i64 %67, i64* %66, align 8
  %68 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %69 = load i8, i8* %68, align 8, !tbaa !22
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 %48, i32 1
  store i8 %69, i8* %70, align 8, !tbaa !22
  %71 = load i32, i32* %44, align 4, !tbaa !280
  %72 = add nsw i32 %71, 1
  store i32 %72, i32* %44, align 4, !tbaa !280
  %73 = load i8, i8* %68, align 8, !tbaa !22
  %74 = and i8 %73, 64
  %75 = icmp eq i8 %74, 0
  br i1 %75, label %90, label %76

; <label>:76:                                     ; preds = %63
  %77 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 2
  %78 = load i8, i8* %77, align 1, !tbaa !232
  %79 = and i8 %78, 32
  %80 = icmp eq i8 %79, 0
  br i1 %80, label %90, label %81

; <label>:81:                                     ; preds = %76
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %83 = load %struct.GCObject*, %struct.GCObject** %82, align 8, !tbaa !21
  %84 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %83, i64 0, i32 2
  %85 = load i8, i8* %84, align 1, !tbaa !67
  %86 = and i8 %85, 24
  %87 = icmp eq i8 %86, 0
  br i1 %87, label %90, label %88

; <label>:88:                                     ; preds = %81
  %89 = bitcast %struct.Proto* %9 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %7, %struct.GCObject* %89, %struct.GCObject* %83) #16
  br label %90

; <label>:90:                                     ; preds = %88, %63, %76, %81, %38
  %91 = phi i32 [ %22, %38 ], [ %47, %81 ], [ %47, %76 ], [ %47, %63 ], [ %47, %88 ]
  ret i32 %91
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_intK(%struct.FuncState* nocapture, i64) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = inttoptr i64 %1 to i8*
  %8 = bitcast %struct.TValue* %3 to i8**
  store i8* %7, i8** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 2, i8* %9, align 8, !tbaa !22
  %10 = bitcast %struct.TValue* %4 to i64*
  store i64 %1, i64* %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %11, align 8, !tbaa !22
  %12 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %4) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %12
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32* @getjumpcontrol(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %6 = load i32*, i32** %5, align 8, !tbaa !119
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i32, i32* %6, i64 %7
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds i32, i32* %8, i64 -1
  %12 = load i32, i32* %11, align 4, !tbaa !74
  %13 = and i32 %12, 127
  %14 = zext i32 %13 to i64
  %15 = add nsw i64 %14, -58
  %16 = icmp ult i64 %15, 11
  br i1 %16, label %18, label %17

; <label>:17:                                     ; preds = %10, %2
  br label %18

; <label>:18:                                     ; preds = %10, %17
  %19 = phi i32* [ %8, %17 ], [ %11, %10 ]
  ret i32* %19
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @getjump(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %6 = load i32*, i32** %5, align 8, !tbaa !119
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i32, i32* %6, i64 %7
  %9 = load i32, i32* %8, align 4, !tbaa !74
  %10 = lshr i32 %9, 7
  %11 = add nsw i32 %10, -16777215
  %12 = icmp eq i32 %11, -1
  %13 = add nsw i32 %1, 1
  %14 = add nsw i32 %13, %11
  %15 = select i1 %12, i32 -1, i32 %14
  ret i32 %15
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @patchtestreg(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #2 {
  %4 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %1) #16
  %5 = load i32, i32* %4, align 4, !tbaa !74
  %6 = and i32 %5, 127
  %7 = icmp eq i32 %6, 68
  br i1 %7, label %8, label %27

; <label>:8:                                      ; preds = %3
  %9 = icmp eq i32 %2, 255
  br i1 %9, label %19, label %10

; <label>:10:                                     ; preds = %8
  %11 = lshr i32 %5, 16
  %12 = and i32 %11, 255
  %13 = icmp eq i32 %12, %2
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %10
  %15 = and i32 %5, -32641
  %16 = shl i32 %2, 7
  %17 = and i32 %16, 32640
  %18 = or i32 %15, %17
  br label %25

; <label>:19:                                     ; preds = %10, %8
  %20 = lshr i32 %5, 9
  %21 = and i32 %20, 32640
  %22 = and i32 %5, 32768
  %23 = or i32 %22, %21
  %24 = or i32 %23, 67
  br label %25

; <label>:25:                                     ; preds = %19, %14
  %26 = phi i32 [ %24, %19 ], [ %18, %14 ]
  store i32 %26, i32* %4, align 4, !tbaa !74
  br label %27

; <label>:27:                                     ; preds = %3, %25
  %28 = phi i32 [ 1, %25 ], [ 0, %3 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @fixjump(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !119
  %8 = sext i32 %1 to i64
  %9 = getelementptr inbounds i32, i32* %7, i64 %8
  %10 = xor i32 %1, -1
  %11 = add i32 %10, %2
  %12 = add i32 %11, 16777215
  %13 = icmp ult i32 %12, 33554432
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %16 = load %struct.LexState*, %struct.LexState** %15, align 8, !tbaa !276
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %16, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #18
  unreachable

; <label>:17:                                     ; preds = %3
  %18 = load i32, i32* %9, align 4, !tbaa !74
  %19 = and i32 %18, 127
  %20 = shl i32 %11, 7
  %21 = add i32 %20, 2147483520
  %22 = or i32 %19, %21
  store i32 %22, i32* %9, align 4, !tbaa !74
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_reserveregs(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @luaK_checkstack(%struct.FuncState* %0, i32 %1) #16
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !301
  %5 = trunc i32 %1 to i8
  %6 = add i8 %4, %5
  store i8 %6, i8* %3, align 4, !tbaa !301
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_checkstack(%struct.FuncState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !301
  %5 = zext i8 %4 to i32
  %6 = add nsw i32 %5, %1
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !251
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 5
  %10 = load i8, i8* %9, align 4, !tbaa !153
  %11 = zext i8 %10 to i32
  %12 = icmp sgt i32 %6, %11
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %2
  %14 = icmp sgt i32 %6, 254
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %13
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %17 = load %struct.LexState*, %struct.LexState** %16, align 8, !tbaa !276
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %17, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.252, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %13
  %19 = trunc i32 %6 to i8
  store i8 %19, i8* %9, align 4, !tbaa !153
  br label %20

; <label>:20:                                     ; preds = %18, %2
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @removelastlineinfo(%struct.FuncState* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %3 = load %struct.Proto*, %struct.Proto** %2, align 8, !tbaa !251
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !277
  %6 = add nsw i32 %5, -1
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 19
  %8 = load i8*, i8** %7, align 8, !tbaa !124
  %9 = sext i32 %6 to i64
  %10 = getelementptr inbounds i8, i8* %8, i64 %9
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = icmp eq i8 %11, -128
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %1
  %14 = sext i8 %11 to i32
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %16 = load i32, i32* %15, align 8, !tbaa !278
  %17 = sub nsw i32 %16, %14
  store i32 %17, i32* %15, align 8, !tbaa !278
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  %19 = load i8, i8* %18, align 1, !tbaa !299
  %20 = add i8 %19, -1
  store i8 %20, i8* %18, align 1, !tbaa !299
  br label %26

; <label>:21:                                     ; preds = %1
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %23 = load i32, i32* %22, align 4, !tbaa !281
  %24 = add nsw i32 %23, -1
  store i32 %24, i32* %22, align 4, !tbaa !281
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  store i8 121, i8* %25, align 1, !tbaa !299
  br label %26

; <label>:26:                                     ; preds = %21, %13
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @negatecondition(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %4 = bitcast %union.anon.8* %3 to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !21
  %6 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %5) #16
  %7 = load i32, i32* %6, align 4, !tbaa !74
  %8 = xor i32 %7, 32768
  store i32 %8, i32* %6, align 4, !tbaa !74
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @discharge2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %0, i32 1) #16
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %8 = load i8, i8* %7, align 4, !tbaa !301
  %9 = zext i8 %8 to i32
  %10 = add nsw i32 %9, -1
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 %10) #16
  br label %11

; <label>:11:                                     ; preds = %2, %6
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @removevalues(%struct.FuncState* nocapture readonly, i32) unnamed_addr #2 {
  br label %3

; <label>:3:                                      ; preds = %6, %2
  %4 = phi i32 [ %1, %2 ], [ %8, %6 ]
  %5 = icmp eq i32 %4, -1
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %4, i32 255) #16
  %8 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %4) #16
  br label %3

; <label>:9:                                      ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codestring(%struct.LexState* nocapture readonly, %struct.expdesc* nocapture, %struct.TString*) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %7) #7
  %8 = bitcast %struct.TValue* %4 to %struct.TString**
  store %struct.TString* %2, %struct.TString** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !72
  %11 = or i8 %10, 64
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = call fastcc i32 @addk(%struct.FuncState* %6, %struct.TValue* nonnull %4, %struct.TValue* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %7) #7
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %14, align 8, !tbaa !270
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %15, align 4, !tbaa !272
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 4, i32* %16, align 8, !tbaa !273
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  store i32 %13, i32* %18, align 8, !tbaa !21
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @constructor(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.ConsControl, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !264
  %8 = tail call fastcc i32 @luaK_code(%struct.FuncState* %5, i32 17) #17
  %9 = bitcast %struct.ConsControl* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* nonnull %9) #7
  %10 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 4
  store i32 0, i32* %10, align 8, !tbaa !318
  %11 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 2
  store i32 0, i32* %11, align 8, !tbaa !320
  %12 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 3
  store i32 0, i32* %12, align 4, !tbaa !321
  %13 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 1
  store %struct.expdesc* %1, %struct.expdesc** %13, align 8, !tbaa !322
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %14, align 8, !tbaa !270
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %15, align 4, !tbaa !272
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %16, align 8, !tbaa !273
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  store i32 %8, i32* %18, align 8, !tbaa !21
  %19 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0
  %20 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 2
  store i32 -1, i32* %20, align 8, !tbaa !270
  %21 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 3
  store i32 -1, i32* %21, align 4, !tbaa !272
  %22 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 0
  store i32 0, i32* %22, align 8, !tbaa !273
  %23 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  store i32 0, i32* %24, align 8, !tbaa !21
  %25 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %25, %struct.expdesc* %1) #16
  tail call fastcc void @checknext(%struct.LexState* %0, i32 123) #16
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %27

; <label>:27:                                     ; preds = %56, %2
  %28 = load i32, i32* %26, align 8, !tbaa !258
  %29 = icmp eq i32 %28, 125
  br i1 %29, label %60, label %30

; <label>:30:                                     ; preds = %27
  %31 = load i32, i32* %22, align 8, !tbaa !323
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %44, label %33

; <label>:33:                                     ; preds = %30
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %19) #17
  store i32 0, i32* %22, align 8, !tbaa !323
  %34 = load i32, i32* %10, align 8, !tbaa !318
  %35 = icmp eq i32 %34, 50
  br i1 %35, label %36, label %42

; <label>:36:                                     ; preds = %33
  %37 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !322
  %38 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %37, i64 0, i32 1
  %39 = bitcast %union.anon.8* %38 to i32*
  %40 = load i32, i32* %39, align 8, !tbaa !21
  %41 = load i32, i32* %12, align 4, !tbaa !321
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %40, i32 %41, i32 50) #17
  store i32 0, i32* %10, align 8, !tbaa !318
  br label %42

; <label>:42:                                     ; preds = %36, %33
  %43 = load i32, i32* %26, align 8, !tbaa !258
  br label %44

; <label>:44:                                     ; preds = %42, %30
  %45 = phi i32 [ %43, %42 ], [ %28, %30 ]
  switch i32 %45, label %52 [
    i32 292, label %46
    i32 91, label %51
  ]

; <label>:46:                                     ; preds = %44
  %47 = call fastcc i32 @luaX_lookahead(%struct.LexState* nonnull %0) #17
  %48 = icmp eq i32 %47, 61
  br i1 %48, label %50, label %49

; <label>:49:                                     ; preds = %46
  call fastcc void @listfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %53

; <label>:50:                                     ; preds = %46
  call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %53

; <label>:51:                                     ; preds = %44
  call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %53

; <label>:52:                                     ; preds = %44
  call fastcc void @listfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %53

; <label>:53:                                     ; preds = %49, %50, %51, %52
  %54 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 44) #16
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %57, label %56

; <label>:56:                                     ; preds = %53, %57
  br label %27

; <label>:57:                                     ; preds = %53
  %58 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 59) #16
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %60, label %56

; <label>:60:                                     ; preds = %57, %27
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 125, i32 123, i32 %7) #16
  %61 = load i32, i32* %10, align 8, !tbaa !318
  %62 = icmp eq i32 %61, 0
  br i1 %62, label %82, label %63

; <label>:63:                                     ; preds = %60
  %64 = load i32, i32* %22, align 8, !tbaa !323
  switch i32 %64, label %73 [
    i32 16, label %65
    i32 17, label %65
    i32 0, label %75
  ]

; <label>:65:                                     ; preds = %63, %63
  call fastcc void @luaK_setreturns(%struct.FuncState* %5, %struct.expdesc* nonnull %19, i32 -1) #17
  %66 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !322
  %67 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %66, i64 0, i32 1
  %68 = bitcast %union.anon.8* %67 to i32*
  %69 = load i32, i32* %68, align 8, !tbaa !21
  %70 = load i32, i32* %12, align 4, !tbaa !321
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %69, i32 %70, i32 -1) #17
  %71 = load i32, i32* %12, align 4, !tbaa !321
  %72 = add nsw i32 %71, -1
  store i32 %72, i32* %12, align 4, !tbaa !321
  br label %82

; <label>:73:                                     ; preds = %63
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %19) #17
  %74 = load i32, i32* %10, align 8, !tbaa !318
  br label %75

; <label>:75:                                     ; preds = %73, %63
  %76 = phi i32 [ %61, %63 ], [ %74, %73 ]
  %77 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !322
  %78 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %77, i64 0, i32 1
  %79 = bitcast %union.anon.8* %78 to i32*
  %80 = load i32, i32* %79, align 8, !tbaa !21
  %81 = load i32, i32* %12, align 4, !tbaa !321
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %80, i32 %81, i32 %76) #17
  br label %82

; <label>:82:                                     ; preds = %60, %65, %75
  %83 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %84 = load %struct.Proto*, %struct.Proto** %83, align 8, !tbaa !251
  %85 = getelementptr inbounds %struct.Proto, %struct.Proto* %84, i64 0, i32 16
  %86 = load i32*, i32** %85, align 8, !tbaa !119
  %87 = sext i32 %8 to i64
  %88 = getelementptr inbounds i32, i32* %86, i64 %87
  %89 = load i32, i32* %88, align 4, !tbaa !74
  %90 = and i32 %89, -16711681
  %91 = load i32, i32* %12, align 4, !tbaa !321
  %92 = call fastcc i32 @luaO_int2fb(i32 %91) #16
  %93 = shl i32 %92, 16
  %94 = and i32 %93, 16711680
  %95 = or i32 %94, %90
  store i32 %95, i32* %88, align 4, !tbaa !74
  %96 = and i32 %95, 16777215
  %97 = load i32, i32* %11, align 8, !tbaa !320
  %98 = call fastcc i32 @luaO_int2fb(i32 %97) #16
  %99 = shl i32 %98, 24
  %100 = or i32 %96, %99
  store i32 %100, i32* %88, align 4, !tbaa !74
  call void @llvm.lifetime.end.p0i8(i64 48, i8* nonnull %9) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @body(%struct.LexState*, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.FuncState, align 8
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.FuncState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %7) #7
  %8 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !259
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %12 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !263
  %13 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %12, i64 0, i32 0
  %14 = load %struct.Proto*, %struct.Proto** %13, align 8, !tbaa !251
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %12, i64 0, i32 8
  %16 = load i32, i32* %15, align 8, !tbaa !282
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 10
  %18 = load i32, i32* %17, align 8, !tbaa !220
  %19 = icmp slt i32 %16, %18
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 17
  br i1 %19, label %35, label %21

; <label>:21:                                     ; preds = %4
  %22 = bitcast %struct.Proto*** %20 to i8**
  %23 = load i8*, i8** %22, align 8, !tbaa !219
  %24 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %10, i8* %23, i32 %16, i32* nonnull %17, i32 8, i32 131071, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.257, i64 0, i64 0)) #17
  store i8* %24, i8** %22, align 8, !tbaa !219
  %25 = load i32, i32* %17, align 8, !tbaa !220
  %26 = sext i32 %18 to i64
  %27 = sext i32 %25 to i64
  br label %28

; <label>:28:                                     ; preds = %31, %21
  %29 = phi i64 [ %33, %31 ], [ %26, %21 ]
  %30 = icmp slt i64 %29, %27
  br i1 %30, label %31, label %35

; <label>:31:                                     ; preds = %28
  %32 = load %struct.Proto**, %struct.Proto*** %20, align 8, !tbaa !219
  %33 = add nsw i64 %29, 1
  %34 = getelementptr inbounds %struct.Proto*, %struct.Proto** %32, i64 %29
  store %struct.Proto* null, %struct.Proto** %34, align 8, !tbaa !39
  br label %28

; <label>:35:                                     ; preds = %28, %4
  %36 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %10) #17
  %37 = load %struct.Proto**, %struct.Proto*** %20, align 8, !tbaa !219
  %38 = load i32, i32* %15, align 8, !tbaa !282
  %39 = add nsw i32 %38, 1
  store i32 %39, i32* %15, align 8, !tbaa !282
  %40 = sext i32 %38 to i64
  %41 = getelementptr inbounds %struct.Proto*, %struct.Proto** %37, i64 %40
  store %struct.Proto* %36, %struct.Proto** %41, align 8, !tbaa !39
  %42 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 2
  %43 = load i8, i8* %42, align 1, !tbaa !232
  %44 = and i8 %43, 32
  %45 = icmp eq i8 %44, 0
  br i1 %45, label %54, label %46

; <label>:46:                                     ; preds = %35
  %47 = getelementptr inbounds %struct.Proto, %struct.Proto* %36, i64 0, i32 2
  %48 = load i8, i8* %47, align 1, !tbaa !232
  %49 = and i8 %48, 24
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %54, label %51

; <label>:51:                                     ; preds = %46
  %52 = bitcast %struct.Proto* %14 to %struct.GCObject*
  %53 = bitcast %struct.Proto* %36 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %10, %struct.GCObject* %52, %struct.GCObject* %53) #17
  br label %54

; <label>:54:                                     ; preds = %35, %46, %51
  %55 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  store %struct.Proto* %36, %struct.Proto** %55, align 8, !tbaa !251
  %56 = getelementptr inbounds %struct.Proto, %struct.Proto* %36, i64 0, i32 13
  store i32 %3, i32* %56, align 4, !tbaa !110
  call fastcc void @open_func(%struct.LexState* %0, %struct.FuncState* nonnull %5, %struct.BlockCnt* nonnull %6) #16
  call fastcc void @checknext(%struct.LexState* %0, i32 40) #16
  %57 = icmp eq i32 %2, 0
  br i1 %57, label %60, label %58

; <label>:58:                                     ; preds = %54
  %59 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.256, i64 0, i64 0), i64 4) #16
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %59) #16
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 1) #16
  br label %60

; <label>:60:                                     ; preds = %54, %58
  %61 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !263
  %62 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %61, i64 0, i32 0
  %63 = load %struct.Proto*, %struct.Proto** %62, align 8, !tbaa !251
  %64 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %65 = load i32, i32* %64, align 8, !tbaa !258
  %66 = icmp eq i32 %65, 41
  br i1 %66, label %80, label %67

; <label>:67:                                     ; preds = %60
  br label %70

; <label>:68:                                     ; preds = %75
  %69 = load i32, i32* %64, align 8, !tbaa !258
  br label %70

; <label>:70:                                     ; preds = %67, %68
  %71 = phi i32 [ %69, %68 ], [ %65, %67 ]
  %72 = phi i32 [ %77, %68 ], [ 0, %67 ]
  switch i32 %71, label %73 [
    i32 292, label %75
    i32 281, label %74
  ]

; <label>:73:                                     ; preds = %70
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.259, i64 0, i64 0)) #19
  unreachable

; <label>:74:                                     ; preds = %70
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  br label %80

; <label>:75:                                     ; preds = %70
  %76 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %76) #17
  %77 = add nuw nsw i32 %72, 1
  %78 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 44) #17
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %68

; <label>:80:                                     ; preds = %75, %74, %60
  %81 = phi i32 [ %72, %74 ], [ 0, %60 ], [ %77, %75 ]
  %82 = phi i1 [ false, %74 ], [ true, %60 ], [ true, %75 ]
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 %81) #17
  %83 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %61, i64 0, i32 13
  %84 = load i8, i8* %83, align 2, !tbaa !288
  %85 = getelementptr inbounds %struct.Proto, %struct.Proto* %63, i64 0, i32 3
  store i8 %84, i8* %85, align 2, !tbaa !117
  br i1 %82, label %89, label %86

; <label>:86:                                     ; preds = %80
  %87 = zext i8 %84 to i32
  call fastcc void @setvararg(%struct.FuncState* nonnull %61, i32 %87) #17
  %88 = load i8, i8* %83, align 2, !tbaa !288
  br label %89

; <label>:89:                                     ; preds = %80, %86
  %90 = phi i8 [ %84, %80 ], [ %88, %86 ]
  %91 = zext i8 %90 to i32
  call fastcc void @luaK_reserveregs(%struct.FuncState* nonnull %61, i32 %91) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 41) #16
  call fastcc void @statlist(%struct.LexState* nonnull %0) #16
  %92 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %93 = load i32, i32* %92, align 4, !tbaa !264
  %94 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !251
  %95 = getelementptr inbounds %struct.Proto, %struct.Proto* %94, i64 0, i32 14
  store i32 %93, i32* %95, align 8, !tbaa !111
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 265, i32 %3) #16
  %96 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !263
  %97 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %96, i64 0, i32 1
  %98 = load %struct.FuncState*, %struct.FuncState** %97, align 8, !tbaa !275
  %99 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %98, i64 0, i32 8
  %100 = load i32, i32* %99, align 8, !tbaa !282
  %101 = shl i32 %100, 15
  %102 = add i32 %101, -32768
  %103 = or i32 %102, 80
  %104 = call fastcc i32 @luaK_code(%struct.FuncState* %98, i32 %103) #17
  %105 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %105, align 8, !tbaa !270
  %106 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %106, align 4, !tbaa !272
  %107 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %107, align 8, !tbaa !273
  %108 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %109 = bitcast %union.anon.8* %108 to i32*
  store i32 %104, i32* %109, align 8, !tbaa !21
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %98, %struct.expdesc* %1) #17
  call fastcc void @close_func(%struct.LexState* nonnull %0) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @suffixedexp(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !264
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !258
  switch i32 %10, label %14 [
    i32 40, label %11
    i32 292, label %13
  ]

; <label>:11:                                     ; preds = %2
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #17
  tail call fastcc void @expr(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %8) #17
  %12 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %12, %struct.expdesc* %1) #17
  br label %15

; <label>:13:                                     ; preds = %2
  tail call fastcc void @singlevar(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  br label %15

; <label>:14:                                     ; preds = %2
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.260, i64 0, i64 0)) #19
  unreachable

; <label>:15:                                     ; preds = %11, %13
  %16 = bitcast %struct.expdesc* %3 to i8*
  %17 = bitcast %struct.expdesc* %4 to i8*
  %18 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %19 = bitcast %union.anon.8* %18 to i32*
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %22 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 13
  br label %26

; <label>:26:                                     ; preds = %48, %15
  %27 = load i32, i32* %9, align 8, !tbaa !258
  switch i32 %27, label %49 [
    i32 46, label %28
    i32 91, label %29
    i32 58, label %30
    i32 40, label %47
    i32 293, label %47
    i32 123, label %47
  ]

; <label>:28:                                     ; preds = %26
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* %1) #16
  br label %48

; <label>:29:                                     ; preds = %26
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %16) #7
  call fastcc void @luaK_exp2anyregup(%struct.FuncState* %6, %struct.expdesc* %1) #16
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3) #16
  call fastcc void @luaK_indexed(%struct.FuncState* %6, %struct.expdesc* %1, %struct.expdesc* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %16) #7
  br label %48

; <label>:30:                                     ; preds = %26
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %17) #7
  call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  call fastcc void @codename(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  %31 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %6, %struct.expdesc* %1) #17
  %32 = load i32, i32* %19, align 8, !tbaa !21
  call fastcc void @freeexp(%struct.FuncState* %6, %struct.expdesc* %1) #17
  %33 = load i8, i8* %20, align 4, !tbaa !301
  %34 = zext i8 %33 to i32
  store i32 %34, i32* %19, align 8, !tbaa !21
  store i32 7, i32* %21, align 8, !tbaa !273
  call fastcc void @luaK_reserveregs(%struct.FuncState* %6, i32 2) #17
  %35 = load i32, i32* %19, align 8, !tbaa !21
  call fastcc void @codeABRK(%struct.FuncState* %6, i32 18, i32 %35, i32 %32, %struct.expdesc* nonnull %4) #17
  %36 = load i32, i32* %22, align 8, !tbaa !273
  %37 = icmp eq i32 %36, 7
  br i1 %37, label %38, label %46

; <label>:38:                                     ; preds = %30
  %39 = load i32, i32* %24, align 8, !tbaa !21
  %40 = load i8, i8* %25, align 2, !tbaa !288
  %41 = zext i8 %40 to i32
  %42 = icmp slt i32 %39, %41
  br i1 %42, label %46, label %43

; <label>:43:                                     ; preds = %38
  %44 = load i8, i8* %20, align 4, !tbaa !301
  %45 = add i8 %44, -1
  store i8 %45, i8* %20, align 4, !tbaa !301
  br label %46

; <label>:46:                                     ; preds = %30, %38, %43
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %1, i32 %8) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %17) #7
  br label %48

; <label>:47:                                     ; preds = %26, %26, %26
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* %1) #16
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 %8) #16
  br label %48

; <label>:48:                                     ; preds = %47, %46, %29, %28
  br label %26

; <label>:49:                                     ; preds = %26
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define internal fastcc i32 @luaO_int2fb(i32) unnamed_addr #6 {
  %2 = icmp ult i32 %0, 8
  br i1 %2, label %26, label %3

; <label>:3:                                      ; preds = %1
  br label %4

; <label>:4:                                      ; preds = %3, %9
  %5 = phi i32 [ %11, %9 ], [ %0, %3 ]
  %6 = phi i32 [ %12, %9 ], [ 0, %3 ]
  %7 = icmp ugt i32 %5, 127
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %4
  br label %13

; <label>:9:                                      ; preds = %4
  %10 = add i32 %5, 15
  %11 = lshr i32 %10, 4
  %12 = add nuw nsw i32 %6, 4
  br label %4

; <label>:13:                                     ; preds = %8, %17
  %14 = phi i32 [ %19, %17 ], [ %5, %8 ]
  %15 = phi i32 [ %20, %17 ], [ %6, %8 ]
  %16 = icmp ugt i32 %14, 15
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %13
  %18 = add i32 %14, 1
  %19 = lshr i32 %18, 1
  %20 = add nuw nsw i32 %15, 1
  br label %13

; <label>:21:                                     ; preds = %13
  %22 = shl i32 %15, 3
  %23 = add i32 %22, 8
  %24 = add nsw i32 %14, -8
  %25 = or i32 %23, %24
  br label %26

; <label>:26:                                     ; preds = %1, %21
  %27 = phi i32 [ %25, %21 ], [ %0, %1 ]
  ret i32 %27
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_setlist(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = add nsw i32 %2, -1
  %6 = sdiv i32 %5, 50
  %7 = add nsw i32 %6, 1
  %8 = icmp eq i32 %3, -1
  %9 = select i1 %8, i32 0, i32 %3
  %10 = icmp slt i32 %2, 12751
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 79, i32 %1, i32 %9, i32 %7, i32 0) #16
  br label %24

; <label>:13:                                     ; preds = %4
  %14 = icmp slt i32 %2, 1677721551
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %13
  %16 = shl i32 %1, 7
  %17 = shl i32 %9, 16
  %18 = or i32 %16, %17
  %19 = or i32 %18, 79
  %20 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %19) #17
  tail call fastcc void @codeextraarg(%struct.FuncState* %0, i32 %7) #16
  br label %24

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %23 = load %struct.LexState*, %struct.LexState** %22, align 8, !tbaa !276
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %23, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.254, i64 0, i64 0)) #18
  unreachable

; <label>:24:                                     ; preds = %15, %11
  %25 = trunc i32 %1 to i8
  %26 = add i8 %25, 1
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %26, i8* %27, align 4, !tbaa !301
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaX_lookahead(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %3 = tail call fastcc i32 @llex(%struct.LexState* %0, %union.SemInfo* nonnull %2) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 0
  store i32 %3, i32* %4, align 8, !tbaa !261
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @listfield(%struct.LexState*, %struct.ConsControl*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %3) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 3
  %7 = load i32, i32* %6, align 4, !tbaa !321
  tail call fastcc void @checklimit(%struct.FuncState* %5, i32 %7, i32 2147483647, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.255, i64 0, i64 0)) #16
  %8 = load i32, i32* %6, align 4, !tbaa !321
  %9 = add nsw i32 %8, 1
  store i32 %9, i32* %6, align 4, !tbaa !321
  %10 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 4
  %11 = load i32, i32* %10, align 8, !tbaa !318
  %12 = add nsw i32 %11, 1
  store i32 %12, i32* %10, align 8, !tbaa !318
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @recfield(%struct.LexState*, %struct.ConsControl* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !263
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 15
  %9 = load i8, i8* %8, align 4, !tbaa !301
  %10 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %10) #7
  %11 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  %12 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %12) #7
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !258
  %15 = icmp eq i32 %14, 292
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 2
  %18 = load i32, i32* %17, align 8, !tbaa !320
  tail call fastcc void @checklimit(%struct.FuncState* %7, i32 %18, i32 2147483647, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.255, i64 0, i64 0)) #16
  call fastcc void @codename(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  br label %21

; <label>:19:                                     ; preds = %2
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  %20 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 2
  br label %21

; <label>:21:                                     ; preds = %19, %16
  %22 = phi i32* [ %20, %19 ], [ %17, %16 ]
  %23 = load i32, i32* %22, align 8, !tbaa !320
  %24 = add nsw i32 %23, 1
  store i32 %24, i32* %22, align 8, !tbaa !320
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #16
  %25 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %26 = bitcast %struct.expdesc** %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !322
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %10, i8* %27, i64 24, i32 8, i1 false), !tbaa.struct !316
  call fastcc void @luaK_indexed(%struct.FuncState* %7, %struct.expdesc* nonnull %3, %struct.expdesc* nonnull %4) #16
  call fastcc void @expr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5) #16
  call fastcc void @luaK_storevar(%struct.FuncState* %7, %struct.expdesc* nonnull %3, %struct.expdesc* nonnull %5) #16
  store i8 %9, i8* %8, align 4, !tbaa !301
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %10) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codename(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0) #16
  tail call fastcc void @codestring(%struct.LexState* %0, %struct.expdesc* %1, %struct.TString* %3) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @yindex(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  tail call fastcc void @luaX_next(%struct.LexState* %0) #16
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %6 = load i32, i32* %5, align 8, !tbaa !270
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !272
  %9 = icmp eq i32 %6, %8
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %2
  %11 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %4, %struct.expdesc* nonnull %1) #17
  br label %13

; <label>:12:                                     ; preds = %2
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %4, %struct.expdesc* nonnull %1) #17
  br label %13

; <label>:13:                                     ; preds = %10, %12
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 93) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_indexed(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp eq i32 %5, 9
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = trunc i32 %10 to i8
  %12 = bitcast %union.anon.8* %8 to %struct.anon.9*
  %13 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %12, i64 0, i32 1
  store i8 %11, i8* %13, align 2, !tbaa !21
  br label %40

; <label>:14:                                     ; preds = %3
  %15 = tail call fastcc i32 @isKstr(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %24, label %17

; <label>:17:                                     ; preds = %14
  %18 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %19 = bitcast %union.anon.8* %18 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = trunc i32 %20 to i8
  %22 = bitcast %union.anon.8* %18 to %struct.anon.9*
  %23 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %22, i64 0, i32 1
  store i8 %21, i8* %23, align 2, !tbaa !21
  br label %34

; <label>:24:                                     ; preds = %14
  %25 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  %26 = load i32, i32* %4, align 8, !tbaa !273
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %28 = bitcast %union.anon.8* %27 to i32*
  %29 = load i32, i32* %28, align 8, !tbaa !21
  %30 = trunc i32 %29 to i8
  %31 = bitcast %union.anon.8* %27 to %struct.anon.9*
  %32 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %31, i64 0, i32 1
  store i8 %30, i8* %32, align 2, !tbaa !21
  %33 = icmp eq i32 %26, 9
  br i1 %33, label %34, label %40

; <label>:34:                                     ; preds = %17, %24
  %35 = phi %union.anon.8* [ %18, %17 ], [ %27, %24 ]
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to i32*
  %38 = load i32, i32* %37, align 8, !tbaa !21
  %39 = trunc i32 %38 to i16
  br label %68

; <label>:40:                                     ; preds = %7, %24
  %41 = phi %union.anon.8* [ %8, %7 ], [ %27, %24 ]
  %42 = tail call fastcc i32 @isKstr(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %49, label %44

; <label>:44:                                     ; preds = %40
  %45 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %46 = bitcast %union.anon.8* %45 to i32*
  %47 = load i32, i32* %46, align 8, !tbaa !21
  %48 = trunc i32 %47 to i16
  br label %68

; <label>:49:                                     ; preds = %40
  %50 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %51 = load i32, i32* %50, align 8, !tbaa !273
  %52 = icmp eq i32 %51, 6
  br i1 %52, label %53, label %65

; <label>:53:                                     ; preds = %49
  %54 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %55 = load i32, i32* %54, align 8, !tbaa !270
  %56 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %57 = load i32, i32* %56, align 4, !tbaa !272
  %58 = icmp eq i32 %55, %57
  br i1 %58, label %59, label %65

; <label>:59:                                     ; preds = %53
  %60 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  %61 = load i64, i64* %60, align 8, !tbaa !21
  %62 = icmp ugt i64 %61, 255
  br i1 %62, label %65, label %63

; <label>:63:                                     ; preds = %59
  %64 = trunc i64 %61 to i16
  br label %68

; <label>:65:                                     ; preds = %49, %53, %59
  %66 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %2) #16
  %67 = trunc i32 %66 to i16
  br label %68

; <label>:68:                                     ; preds = %44, %65, %63, %34
  %69 = phi %union.anon.8* [ %41, %44 ], [ %41, %65 ], [ %41, %63 ], [ %35, %34 ]
  %70 = phi i16 [ %48, %44 ], [ %67, %65 ], [ %64, %63 ], [ %39, %34 ]
  %71 = phi i32 [ 13, %44 ], [ 10, %65 ], [ 12, %63 ], [ 11, %34 ]
  %72 = bitcast %union.anon.8* %69 to i16*
  store i16 %70, i16* %72, align 8, !tbaa !21
  store i32 %71, i32* %4, align 8, !tbaa !273
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_storevar(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  switch i32 %5, label %56 [
    i32 8, label %6
    i32 9, label %10
    i32 11, label %20
    i32 12, label %29
    i32 13, label %38
    i32 10, label %47
  ]

; <label>:6:                                      ; preds = %3
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* %2, i32 %9) #16
  br label %57

; <label>:10:                                     ; preds = %3
  %11 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  %15 = shl i32 %11, 7
  %16 = shl i32 %14, 16
  %17 = or i32 %15, %16
  %18 = or i32 %17, 8
  %19 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %18) #17
  br label %56

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %22 = bitcast %union.anon.8* %21 to %struct.anon.9*
  %23 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %22, i64 0, i32 1
  %24 = load i8, i8* %23, align 2, !tbaa !21
  %25 = zext i8 %24 to i32
  %26 = bitcast %union.anon.8* %21 to i16*
  %27 = load i16, i16* %26, align 8, !tbaa !21
  %28 = sext i16 %27 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 13, i32 %25, i32 %28, %struct.expdesc* %2) #16
  br label %56

; <label>:29:                                     ; preds = %3
  %30 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %31 = bitcast %union.anon.8* %30 to %struct.anon.9*
  %32 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 2, !tbaa !21
  %34 = zext i8 %33 to i32
  %35 = bitcast %union.anon.8* %30 to i16*
  %36 = load i16, i16* %35, align 8, !tbaa !21
  %37 = sext i16 %36 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 15, i32 %34, i32 %37, %struct.expdesc* %2) #16
  br label %56

; <label>:38:                                     ; preds = %3
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %40 = bitcast %union.anon.8* %39 to %struct.anon.9*
  %41 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %40, i64 0, i32 1
  %42 = load i8, i8* %41, align 2, !tbaa !21
  %43 = zext i8 %42 to i32
  %44 = bitcast %union.anon.8* %39 to i16*
  %45 = load i16, i16* %44, align 8, !tbaa !21
  %46 = sext i16 %45 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 16, i32 %43, i32 %46, %struct.expdesc* %2) #16
  br label %56

; <label>:47:                                     ; preds = %3
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %49 = bitcast %union.anon.8* %48 to %struct.anon.9*
  %50 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %49, i64 0, i32 1
  %51 = load i8, i8* %50, align 2, !tbaa !21
  %52 = zext i8 %51 to i32
  %53 = bitcast %union.anon.8* %48 to i16*
  %54 = load i16, i16* %53, align 8, !tbaa !21
  %55 = sext i16 %54 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 14, i32 %52, i32 %55, %struct.expdesc* %2) #16
  br label %56

; <label>:56:                                     ; preds = %3, %47, %38, %29, %20, %10
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2) #16
  br label %57

; <label>:57:                                     ; preds = %56, %6
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @isKstr(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  %5 = icmp eq i32 %4, 4
  br i1 %5, label %6, label %27

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !270
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !272
  %11 = icmp eq i32 %8, %10
  br i1 %11, label %12, label %27

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %14 = bitcast %union.anon.8* %13 to i32*
  %15 = load i32, i32* %14, align 8, !tbaa !21
  %16 = icmp slt i32 %15, 256
  br i1 %16, label %17, label %27

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %19 = load %struct.Proto*, %struct.Proto** %18, align 8, !tbaa !251
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %19, i64 0, i32 15
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !221
  %22 = sext i32 %15 to i64
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 %22, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = icmp eq i8 %24, 84
  %26 = zext i1 %25 to i32
  br label %27

; <label>:27:                                     ; preds = %6, %17, %12, %2
  %28 = phi i32 [ 0, %12 ], [ 0, %6 ], [ 0, %2 ], [ %26, %17 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codeABRK(%struct.FuncState* nocapture, i32, i32, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %6 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %4) #16
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %1, i32 %2, i32 %3, i32 %9, i32 %6) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2RK(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1) #16
  br label %7

; <label>:7:                                      ; preds = %2, %5
  %8 = phi i32 [ 0, %5 ], [ 1, %2 ]
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2K(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %6 = load i32, i32* %5, align 8, !tbaa !270
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %8 = load i32, i32* %7, align 4, !tbaa !272
  %9 = icmp eq i32 %6, %8
  br i1 %9, label %10, label %48

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %12 = load i32, i32* %11, align 8, !tbaa !273
  switch i32 %12, label %48 [
    i32 2, label %13
    i32 3, label %15
    i32 1, label %17
    i32 6, label %29
    i32 5, label %33
    i32 4, label %38
  ]

; <label>:13:                                     ; preds = %10
  %14 = tail call fastcc i32 @boolK(%struct.FuncState* %0, i32 1) #16
  br label %42

; <label>:15:                                     ; preds = %10
  %16 = tail call fastcc i32 @boolK(%struct.FuncState* %0, i32 0) #16
  br label %42

; <label>:17:                                     ; preds = %10
  %18 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %18) #7
  %19 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %19) #7
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 0, i8* %20, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %22 = load %struct.LexState*, %struct.LexState** %21, align 8, !tbaa !276
  %23 = getelementptr inbounds %struct.LexState, %struct.LexState* %22, i64 0, i32 9
  %24 = bitcast %struct.Table** %23 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !248
  %26 = bitcast %struct.TValue* %3 to i64*
  store i64 %25, i64* %26, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 69, i8* %27, align 8, !tbaa !22
  %28 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %19) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %18) #7
  br label %42

; <label>:29:                                     ; preds = %10
  %30 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !21
  %32 = tail call fastcc i32 @luaK_intK(%struct.FuncState* %0, i64 %31) #16
  br label %42

; <label>:33:                                     ; preds = %10
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %35 = bitcast %union.anon.8* %34 to double*
  %36 = load double, double* %35, align 8, !tbaa !21
  %37 = tail call fastcc i32 @luaK_numberK(%struct.FuncState* %0, double %36) #16
  br label %42

; <label>:38:                                     ; preds = %10
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %40 = bitcast %union.anon.8* %39 to i32*
  %41 = load i32, i32* %40, align 8, !tbaa !21
  br label %42

; <label>:42:                                     ; preds = %38, %33, %29, %17, %15, %13
  %43 = phi i32 [ %41, %38 ], [ %37, %33 ], [ %32, %29 ], [ %28, %17 ], [ %16, %15 ], [ %14, %13 ]
  %44 = icmp slt i32 %43, 256
  br i1 %44, label %45, label %48

; <label>:45:                                     ; preds = %42
  store i32 4, i32* %11, align 8, !tbaa !273
  %46 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %47 = bitcast %union.anon.8* %46 to i32*
  store i32 %43, i32* %47, align 8, !tbaa !21
  br label %48

; <label>:48:                                     ; preds = %10, %45, %2, %42
  %49 = phi i32 [ 0, %42 ], [ 0, %2 ], [ 0, %10 ], [ 1, %45 ]
  ret i32 %49
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @boolK(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to i32*
  store i32 %1, i32* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 1, i8* %6, align 8, !tbaa !22
  %7 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_setreturns(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !119
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i32, i32* %7, i64 %11
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !273
  switch i32 %14, label %32 [
    i32 16, label %15
    i32 17, label %21
  ]

; <label>:15:                                     ; preds = %3
  %16 = load i32, i32* %12, align 4, !tbaa !74
  %17 = and i32 %16, 16777215
  %18 = shl i32 %2, 24
  %19 = add i32 %18, 16777216
  %20 = or i32 %17, %19
  store i32 %20, i32* %12, align 4, !tbaa !74
  br label %32

; <label>:21:                                     ; preds = %3
  %22 = load i32, i32* %12, align 4, !tbaa !74
  %23 = and i32 %22, 16744575
  %24 = shl i32 %2, 24
  %25 = add i32 %24, 16777216
  %26 = or i32 %23, %25
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %28 = load i8, i8* %27, align 4, !tbaa !301
  %29 = zext i8 %28 to i32
  %30 = shl nuw nsw i32 %29, 7
  %31 = or i32 %30, %26
  store i32 %31, i32* %12, align 4, !tbaa !74
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* nonnull %0, i32 1) #16
  br label %32

; <label>:32:                                     ; preds = %3, %21, %15
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @new_localvar(%struct.LexState* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !251
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 11
  %10 = load i32, i32* %9, align 4, !tbaa !95
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !259
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 21
  %14 = bitcast %struct.LocVar** %13 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !97
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 12
  %17 = load i16, i16* %16, align 8, !tbaa !290
  %18 = sext i16 %17 to i32
  %19 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %12, i8* %15, i32 %18, i32* nonnull %9, i32 16, i32 32767, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #17
  store i8* %19, i8** %14, align 8, !tbaa !97
  %20 = load i32, i32* %9, align 4, !tbaa !95
  %21 = bitcast i8* %19 to %struct.LocVar*
  %22 = sext i32 %10 to i64
  %23 = sext i32 %20 to i64
  br label %24

; <label>:24:                                     ; preds = %27, %2
  %25 = phi i64 [ %28, %27 ], [ %22, %2 ]
  %26 = icmp slt i64 %25, %23
  br i1 %26, label %27, label %30

; <label>:27:                                     ; preds = %24
  %28 = add nsw i64 %25, 1
  %29 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %21, i64 %25, i32 0
  store %struct.TString* null, %struct.TString** %29, align 8, !tbaa !101
  br label %24

; <label>:30:                                     ; preds = %24
  %31 = load i16, i16* %16, align 8, !tbaa !290
  %32 = sext i16 %31 to i64
  %33 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %21, i64 %32, i32 0
  store %struct.TString* %1, %struct.TString** %33, align 8, !tbaa !101
  %34 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !232
  %36 = and i8 %35, 32
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %48, label %38

; <label>:38:                                     ; preds = %30
  %39 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %40 = load i8, i8* %39, align 1, !tbaa !140
  %41 = and i8 %40, 24
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %48, label %43

; <label>:43:                                     ; preds = %38
  %44 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !259
  %45 = bitcast %struct.Proto* %8 to %struct.GCObject*
  %46 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %44, %struct.GCObject* %45, %struct.GCObject* %46) #17
  %47 = load i16, i16* %16, align 8, !tbaa !290
  br label %48

; <label>:48:                                     ; preds = %30, %38, %43
  %49 = phi i16 [ %31, %38 ], [ %31, %30 ], [ %47, %43 ]
  %50 = add i16 %49, 1
  store i16 %50, i16* %16, align 8, !tbaa !290
  %51 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 1
  %52 = load i32, i32* %51, align 8, !tbaa !257
  %53 = add nsw i32 %52, 1
  %54 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 10
  %55 = load i32, i32* %54, align 8, !tbaa !283
  %56 = sub i32 %53, %55
  tail call fastcc void @checklimit(%struct.FuncState* nonnull %4, i32 %56, i32 200, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #16
  %57 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !259
  %58 = bitcast %struct.Dyndata* %6 to i8**
  %59 = load i8*, i8** %58, align 8, !tbaa !324
  %60 = load i32, i32* %51, align 8, !tbaa !257
  %61 = add nsw i32 %60, 1
  %62 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 2
  %63 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %57, i8* %59, i32 %61, i32* nonnull %62, i32 2, i32 2147483647, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #16
  %64 = bitcast i8* %63 to %struct.Vardesc*
  store i8* %63, i8** %58, align 8, !tbaa !324
  %65 = load i32, i32* %51, align 8, !tbaa !257
  %66 = add nsw i32 %65, 1
  store i32 %66, i32* %51, align 8, !tbaa !257
  %67 = sext i32 %65 to i64
  %68 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %64, i64 %67, i32 0
  store i16 %49, i16* %68, align 2, !tbaa !325
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @adjustlocalvars(%struct.LexState* nocapture readonly, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !288
  %7 = trunc i32 %1 to i8
  %8 = add i8 %6, %7
  store i8 %8, i8* %5, align 2, !tbaa !288
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 4
  %10 = zext i8 %8 to i32
  br label %11

; <label>:11:                                     ; preds = %14, %2
  %12 = phi i32 [ %1, %2 ], [ %19, %14 ]
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %20, label %14

; <label>:14:                                     ; preds = %11
  %15 = load i32, i32* %9, align 8, !tbaa !277
  %16 = sub nsw i32 %10, %12
  %17 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %4, i32 %16) #16
  %18 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %17, i64 0, i32 1
  store i32 %15, i32* %18, align 8, !tbaa !98
  %19 = add nsw i32 %12, -1
  br label %11

; <label>:20:                                     ; preds = %11
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %4 = load %struct.LexState*, %struct.LexState** %3, align 8, !tbaa !276
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %4, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 0
  %8 = load %struct.Vardesc*, %struct.Vardesc** %7, align 8, !tbaa !324
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 10
  %10 = load i32, i32* %9, align 8, !tbaa !283
  %11 = add nsw i32 %10, %1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %8, i64 %12, i32 0
  %14 = load i16, i16* %13, align 2, !tbaa !325
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %16 = load %struct.Proto*, %struct.Proto** %15, align 8, !tbaa !251
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 21
  %18 = load %struct.LocVar*, %struct.LocVar** %17, align 8, !tbaa !97
  %19 = sext i16 %14 to i64
  %20 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %18, i64 %19
  ret %struct.LocVar* %20
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @fieldsel(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  %6 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  tail call fastcc void @luaK_exp2anyregup(%struct.FuncState* %5, %struct.expdesc* %1) #16
  tail call fastcc void @luaX_next(%struct.LexState* %0) #16
  call fastcc void @codename(%struct.LexState* %0, %struct.expdesc* nonnull %3) #16
  call fastcc void @luaK_indexed(%struct.FuncState* %5, %struct.expdesc* %1, %struct.expdesc* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_exp2anyregup(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !273
  %5 = icmp eq i32 %4, 9
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !270
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !272
  %11 = icmp eq i32 %8, %10
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %6, %2
  %13 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  br label %14

; <label>:14:                                     ; preds = %6, %12
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @funcargs(%struct.LexState*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !258
  switch i32 %9, label %23 [
    i32 40, label %10
    i32 123, label %18
    i32 293, label %19
  ]

; <label>:10:                                     ; preds = %3
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  %11 = load i32, i32* %8, align 8, !tbaa !258
  %12 = icmp eq i32 %11, 41
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %10
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 0, i32* %14, align 8, !tbaa !273
  br label %17

; <label>:15:                                     ; preds = %10
  %16 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  call fastcc void @luaK_setreturns(%struct.FuncState* %6, %struct.expdesc* nonnull %4, i32 -1) #16
  br label %17

; <label>:17:                                     ; preds = %15, %13
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %2) #16
  br label %24

; <label>:18:                                     ; preds = %3
  call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  br label %24

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %21 = bitcast %union.SemInfo* %20 to %struct.TString**
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !21
  call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4, %struct.TString* %22) #16
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0) #16
  br label %24

; <label>:23:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.261, i64 0, i64 0)) #18
  unreachable

; <label>:24:                                     ; preds = %19, %18, %17
  %25 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %26 = bitcast %union.anon.8* %25 to i32*
  %27 = load i32, i32* %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  %29 = load i32, i32* %28, align 8, !tbaa !273
  switch i32 %29, label %30 [
    i32 16, label %36
    i32 17, label %36
    i32 0, label %31
  ]

; <label>:30:                                     ; preds = %24
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* nonnull %4) #16
  br label %31

; <label>:31:                                     ; preds = %24, %30
  %32 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %33 = load i8, i8* %32, align 4, !tbaa !301
  %34 = zext i8 %33 to i32
  %35 = sub i32 %34, %27
  br label %36

; <label>:36:                                     ; preds = %24, %24, %31
  %37 = phi i32 [ %35, %31 ], [ 0, %24 ], [ 0, %24 ]
  %38 = call fastcc i32 @luaK_codeABCk(%struct.FuncState* %6, i32 69, i32 %27, i32 %37, i32 2, i32 0) #16
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %39, align 8, !tbaa !270
  %40 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %40, align 4, !tbaa !272
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 16, i32* %41, align 8, !tbaa !273
  store i32 %38, i32* %26, align 8, !tbaa !21
  call fastcc void @luaK_fixline(%struct.FuncState* %6, i32 %2) #16
  %42 = trunc i32 %27 to i8
  %43 = add i8 %42, 1
  %44 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  store i8 %43, i8* %44, align 4, !tbaa !301
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @singlevar(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0) #16
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  tail call fastcc void @singlevaraux(%struct.FuncState* %6, %struct.TString* %4, %struct.expdesc* %1, i32 1) #16
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !273
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 12
  %13 = load %struct.TString*, %struct.TString** %12, align 8, !tbaa !267
  tail call fastcc void @singlevaraux(%struct.FuncState* %6, %struct.TString* %13, %struct.expdesc* nonnull %1, i32 1) #16
  call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3, %struct.TString* %4) #16
  call fastcc void @luaK_indexed(%struct.FuncState* %6, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  br label %14

; <label>:14:                                     ; preds = %10, %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @singlevaraux(%struct.FuncState*, %struct.TString*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %5 = icmp eq %struct.FuncState* %0, null
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %4
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %7, align 8, !tbaa !270
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %8, align 4, !tbaa !272
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 0, i32* %9, align 8, !tbaa !273
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !21
  ret void

; <label>:12:                                     ; preds = %4
  %13 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %14 = load i8, i8* %13, align 2, !tbaa !288
  %15 = zext i8 %14 to i32
  br label %16

; <label>:16:                                     ; preds = %20, %12
  %17 = phi i32 [ %15, %12 ], [ %18, %20 ]
  %18 = add nsw i32 %17, -1
  %19 = icmp sgt i32 %17, 0
  br i1 %19, label %20, label %45

; <label>:20:                                     ; preds = %16
  %21 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nonnull %0, i32 %18) #17
  %22 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %21, i64 0, i32 0
  %23 = load %struct.TString*, %struct.TString** %22, align 8, !tbaa !101
  %24 = icmp eq %struct.TString* %23, %1
  br i1 %24, label %25, label %16

; <label>:25:                                     ; preds = %20
  %26 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %26, align 8, !tbaa !270
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %27, align 4, !tbaa !272
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 8, i32* %28, align 8, !tbaa !273
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %30 = bitcast %union.anon.8* %29 to i32*
  store i32 %18, i32* %30, align 8, !tbaa !21
  %31 = icmp eq i32 %3, 0
  br i1 %31, label %32, label %82

; <label>:32:                                     ; preds = %25
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  br label %34

; <label>:34:                                     ; preds = %34, %32
  %35 = phi %struct.BlockCnt** [ %33, %32 ], [ %41, %34 ]
  %36 = load %struct.BlockCnt*, %struct.BlockCnt** %35, align 8, !tbaa !39
  %37 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %36, i64 0, i32 3
  %38 = load i8, i8* %37, align 8, !tbaa !293
  %39 = zext i8 %38 to i32
  %40 = icmp sgt i32 %17, %39
  %41 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %36, i64 0, i32 0
  br i1 %40, label %42, label %34

; <label>:42:                                     ; preds = %34
  %43 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %36, i64 0, i32 4
  store i8 1, i8* %43, align 1, !tbaa !296
  %44 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 17
  store i8 1, i8* %44, align 2, !tbaa !289
  br label %82

; <label>:45:                                     ; preds = %16
  %46 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %47 = load %struct.Proto*, %struct.Proto** %46, align 8, !tbaa !251
  %48 = getelementptr inbounds %struct.Proto, %struct.Proto* %47, i64 0, i32 18
  %49 = load %struct.Upvaldesc*, %struct.Upvaldesc** %48, align 8, !tbaa !193
  %50 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %51 = load i8, i8* %50, align 1, !tbaa !286
  %52 = zext i8 %51 to i64
  br label %53

; <label>:53:                                     ; preds = %60, %45
  %54 = phi i64 [ %61, %60 ], [ 0, %45 ]
  %55 = icmp ult i64 %54, %52
  br i1 %55, label %56, label %67

; <label>:56:                                     ; preds = %53
  %57 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %49, i64 %54, i32 0
  %58 = load %struct.TString*, %struct.TString** %57, align 8, !tbaa !194
  %59 = icmp eq %struct.TString* %58, %1
  br i1 %59, label %62, label %60

; <label>:60:                                     ; preds = %56
  %61 = add nuw nsw i64 %54, 1
  br label %53

; <label>:62:                                     ; preds = %56
  %63 = trunc i64 %54 to i32
  %64 = icmp slt i32 %63, 0
  br i1 %64, label %67, label %65

; <label>:65:                                     ; preds = %62
  %66 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  br label %75

; <label>:67:                                     ; preds = %53, %62
  %68 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 1
  %69 = load %struct.FuncState*, %struct.FuncState** %68, align 8, !tbaa !275
  tail call fastcc void @singlevaraux(%struct.FuncState* %69, %struct.TString* %1, %struct.expdesc* %2, i32 0) #16
  %70 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %71 = load i32, i32* %70, align 8, !tbaa !273
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %82, label %73

; <label>:73:                                     ; preds = %67
  %74 = tail call fastcc i32 @newupvalue(%struct.FuncState* nonnull %0, %struct.TString* %1, %struct.expdesc* nonnull %2) #16
  br label %75

; <label>:75:                                     ; preds = %65, %73
  %76 = phi i32* [ %66, %65 ], [ %70, %73 ]
  %77 = phi i32 [ %63, %65 ], [ %74, %73 ]
  %78 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %78, align 8, !tbaa !270
  %79 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %79, align 4, !tbaa !272
  store i32 9, i32* %76, align 8, !tbaa !273
  %80 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %81 = bitcast %union.anon.8* %80 to i32*
  store i32 %77, i32* %81, align 8, !tbaa !21
  br label %82

; <label>:82:                                     ; preds = %42, %25, %75, %67
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @explist(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  br label %4

; <label>:4:                                      ; preds = %8, %2
  %5 = phi i32 [ 1, %2 ], [ %10, %8 ]
  %6 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %4
  %9 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %9, %struct.expdesc* %1) #16
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1) #16
  %10 = add nuw nsw i32 %5, 1
  br label %4

; <label>:11:                                     ; preds = %4
  ret i32 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @isSCnumber(%struct.expdesc* nocapture readonly, i64* nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  switch i32 %5, label %27 [
    i32 6, label %6
    i32 5, label %9
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  store i64 %8, i64* %1, align 8, !tbaa !129
  br label %16

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to double*
  %12 = load double, double* %11, align 8, !tbaa !21
  %13 = tail call fastcc i32 @floatI(double %12, i64* %1) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %27, label %15

; <label>:15:                                     ; preds = %9
  store i32 1, i32* %2, align 4, !tbaa !74
  br label %16

; <label>:16:                                     ; preds = %15, %6
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %18 = load i32, i32* %17, align 8, !tbaa !270
  %19 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %20 = load i32, i32* %19, align 4, !tbaa !272
  %21 = icmp eq i32 %18, %20
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %16
  %23 = load i64, i64* %1, align 8, !tbaa !129
  %24 = add i64 %23, 127
  %25 = icmp ugt i64 %24, 255
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %22
  store i64 %24, i64* %1, align 8, !tbaa !129
  br label %27

; <label>:27:                                     ; preds = %16, %22, %9, %3, %26
  %28 = phi i32 [ 1, %26 ], [ 0, %3 ], [ 0, %9 ], [ 0, %22 ], [ 0, %16 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codearith(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %7 = alloca %struct.expdesc, align 8
  %8 = tail call fastcc i32 @isSCint(%struct.expdesc* %3) #16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %6
  %11 = add i32 %1, -19
  tail call fastcc void @codebini(%struct.FuncState* %0, i32 %11, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4, i32 %5) #16
  br label %30

; <label>:12:                                     ; preds = %6
  %13 = tail call fastcc i32 @tonumeral(%struct.expdesc* %3, %struct.TValue* null) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %23, label %15

; <label>:15:                                     ; preds = %12
  %16 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* %3) #16
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %23, label %18

; <label>:18:                                     ; preds = %15
  %19 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %20 = bitcast %union.anon.8* %19 to i32*
  %21 = load i32, i32* %20, align 8, !tbaa !21
  %22 = add i32 %1, -12
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %22, i32 %21, i32 %4, i32 %5) #16
  br label %30

; <label>:23:                                     ; preds = %15, %12
  %24 = icmp eq i32 %4, 0
  br i1 %24, label %29, label %25

; <label>:25:                                     ; preds = %23
  %26 = bitcast %struct.expdesc* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %26)
  %27 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %26, i8* %27, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  %28 = bitcast %struct.expdesc* %3 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %27, i8* %28, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %28, i8* nonnull %26, i64 24, i32 8, i1 false) #7, !tbaa.struct !316
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %26)
  br label %29

; <label>:29:                                     ; preds = %23, %25
  tail call fastcc void @codebinexpval(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %5) #16
  br label %30

; <label>:30:                                     ; preds = %18, %29, %10
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @isSCint(%struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !273
  %4 = icmp eq i32 %3, 6
  br i1 %4, label %5, label %17

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %7 = load i32, i32* %6, align 8, !tbaa !270
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !272
  %10 = icmp eq i32 %7, %9
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %5
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = add i64 %13, 127
  %15 = icmp ult i64 %14, 256
  %16 = zext i1 %15 to i32
  br label %17

; <label>:17:                                     ; preds = %5, %1, %11
  %18 = phi i32 [ 0, %5 ], [ %16, %11 ], [ 0, %1 ]
  ret i32 %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codebini(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly, i32, i32) unnamed_addr #0 {
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = trunc i64 %8 to i32
  %10 = add nsw i32 %9, 127
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %1, i32 %10, i32 %4, i32 %5) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codeshift(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @isSCint(%struct.expdesc* %3) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %16, label %8

; <label>:8:                                      ; preds = %5
  %9 = icmp eq i32 %1, 48
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %8
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = sub nsw i64 0, %12
  store i64 %13, i64* %11, align 8, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %10, %8
  %15 = phi i32 [ 1, %10 ], [ 0, %8 ]
  tail call fastcc void @codebini(%struct.FuncState* %0, i32 36, %struct.expdesc* %2, %struct.expdesc* %3, i32 %15, i32 %4) #16
  br label %17

; <label>:16:                                     ; preds = %5
  tail call fastcc void @codebinexpval(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4) #16
  br label %17

; <label>:17:                                     ; preds = %16, %14
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codeorder(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  store i32 0, i32* %6, align 4, !tbaa !74
  %9 = call fastcc i32 @isSCnumber(%struct.expdesc* %3, i64* nonnull %5, i32* nonnull %6) #16
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %13 = load i64, i64* %5, align 8, !tbaa !129
  %14 = trunc i64 %13 to i32
  %15 = add i32 %1, 4
  br label %28

; <label>:16:                                     ; preds = %4
  %17 = call fastcc i32 @isSCnumber(%struct.expdesc* %2, i64* nonnull %5, i32* nonnull %6) #16
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %16
  %20 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3) #16
  %21 = load i64, i64* %5, align 8, !tbaa !129
  %22 = trunc i64 %21 to i32
  %23 = icmp eq i32 %1, 59
  %24 = select i1 %23, i32 65, i32 66
  br label %28

; <label>:25:                                     ; preds = %16
  %26 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %27 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3) #16
  br label %28

; <label>:28:                                     ; preds = %19, %25, %11
  %29 = phi i32 [ %15, %11 ], [ %24, %19 ], [ %1, %25 ]
  %30 = phi i32 [ %12, %11 ], [ %20, %19 ], [ %26, %25 ]
  %31 = phi i32 [ %14, %11 ], [ %22, %19 ], [ %27, %25 ]
  tail call fastcc void @freeexps(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3) #16
  %32 = load i32, i32* %6, align 4, !tbaa !74
  %33 = tail call fastcc i32 @condjump(%struct.FuncState* %0, i32 %29, i32 %30, i32 %31, i32 %32, i32 1) #16
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %35 = bitcast %union.anon.8* %34 to i32*
  store i32 %33, i32* %35, align 8, !tbaa !21
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 14, i32* %36, align 8, !tbaa !273
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @finishbinexpval(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  %8 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %9 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %3, i32 0, i32 %8, i32 %4, i32 %5) #16
  tail call fastcc void @freeexps(%struct.FuncState* %0, %struct.expdesc* %1, %struct.expdesc* %2) #16
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  store i32 %9, i32* %11, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %12, align 8, !tbaa !273
  tail call fastcc void @luaK_fixline(%struct.FuncState* %0, i32 %6) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @codebinexpval(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3) #16
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %1, i32 %6, i32 0, i32 %4) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @freeexps(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp eq i32 %5, 7
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  br label %11

; <label>:11:                                     ; preds = %3, %7
  %12 = phi i32 [ %10, %7 ], [ -1, %3 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !273
  %15 = icmp eq i32 %14, 7
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %11
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  %19 = load i32, i32* %18, align 8, !tbaa !21
  br label %20

; <label>:20:                                     ; preds = %11, %16
  %21 = phi i32 [ %19, %16 ], [ -1, %11 ]
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %12, i32 %21) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @condjump(%struct.FuncState* nocapture, i32, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5) #16
  %8 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %0) #16
  ret i32 %8
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nocapture readonly, %struct.TString* readnone) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %4 = load %struct.Dyndata*, %struct.Dyndata** %3, align 8, !tbaa !254
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 11
  %8 = load i32, i32* %7, align 4, !tbaa !284
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 2, i32 0
  %10 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 2, i32 1
  %11 = load i32, i32* %10, align 8, !tbaa !255
  %12 = sext i32 %8 to i64
  %13 = sext i32 %11 to i64
  br label %14

; <label>:14:                                     ; preds = %17, %2
  %15 = phi i64 [ %23, %17 ], [ %12, %2 ]
  %16 = icmp slt i64 %15, %13
  br i1 %16, label %17, label %24

; <label>:17:                                     ; preds = %14
  %18 = load %struct.Labeldesc*, %struct.Labeldesc** %9, align 8, !tbaa !327
  %19 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %18, i64 %15
  %20 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %19, i64 0, i32 0
  %21 = load %struct.TString*, %struct.TString** %20, align 8, !tbaa !328
  %22 = icmp eq %struct.TString* %21, %1
  %23 = add nsw i64 %15, 1
  br i1 %22, label %24, label %14

; <label>:24:                                     ; preds = %17, %14
  %25 = phi %struct.Labeldesc* [ %19, %17 ], [ null, %14 ]
  ret %struct.Labeldesc* %25
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @jumponcond(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp eq i32 %5, 15
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  br label %32

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %12 = load %struct.Proto*, %struct.Proto** %11, align 8, !tbaa !251
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %12, i64 0, i32 16
  %14 = load i32*, i32** %13, align 8, !tbaa !119
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %16 = bitcast %union.anon.8* %15 to i32*
  %17 = load i32, i32* %16, align 8, !tbaa !21
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds i32, i32* %14, i64 %18
  %20 = load i32, i32* %19, align 4, !tbaa !74
  %21 = and i32 %20, 127
  %22 = icmp eq i32 %21, 52
  br i1 %22, label %23, label %32

; <label>:23:                                     ; preds = %10
  tail call fastcc void @removelastlineinfo(%struct.FuncState* nonnull %0) #17
  %24 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %25 = load i32, i32* %24, align 8, !tbaa !277
  %26 = add nsw i32 %25, -1
  store i32 %26, i32* %24, align 8, !tbaa !277
  %27 = lshr i32 %20, 16
  %28 = and i32 %27, 255
  %29 = icmp eq i32 %2, 0
  %30 = zext i1 %29 to i32
  %31 = tail call fastcc i32 @condjump(%struct.FuncState* nonnull %0, i32 67, i32 %28, i32 0, i32 0, i32 %30) #16
  br label %36

; <label>:32:                                     ; preds = %7, %10
  %33 = phi i32* [ %9, %7 ], [ %16, %10 ]
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  %34 = load i32, i32* %33, align 8, !tbaa !21
  %35 = tail call fastcc i32 @condjump(%struct.FuncState* %0, i32 68, i32 255, i32 %34, i32 0, i32 %2) #16
  br label %36

; <label>:36:                                     ; preds = %23, %32
  %37 = phi i32 [ %35, %32 ], [ %31, %23 ]
  ret i32 %37
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @newlabelentry(%struct.LexState* nocapture readonly, %struct.Labellist* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 1
  %7 = load i32, i32* %6, align 8, !tbaa !309
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !259
  %10 = bitcast %struct.Labellist* %1 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !310
  %12 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 2
  %13 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %9, i8* %11, i32 %7, i32* nonnull %12, i32 24, i32 32767, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.262, i64 0, i64 0)) #16
  %14 = bitcast i8* %13 to %struct.Labeldesc*
  store i8* %13, i8** %10, align 8, !tbaa !310
  %15 = sext i32 %7 to i64
  %16 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 0
  store %struct.TString* %2, %struct.TString** %16, align 8, !tbaa !328
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 2
  store i32 %3, i32* %17, align 4, !tbaa !302
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %19 = load %struct.FuncState*, %struct.FuncState** %18, align 8, !tbaa !263
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %19, i64 0, i32 13
  %21 = load i8, i8* %20, align 2, !tbaa !288
  %22 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 3
  store i8 %21, i8* %22, align 8, !tbaa !304
  %23 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 4
  store i8 0, i8* %23, align 1, !tbaa !311
  %24 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 1
  store i32 %4, i32* %24, align 8, !tbaa !305
  %25 = add nsw i32 %7, 1
  store i32 %25, i32* %6, align 8, !tbaa !309
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @createlabel(%struct.LexState* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %8 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !254
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %8, i64 0, i32 2
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 4
  %11 = load i32, i32* %10, align 8, !tbaa !277
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 5
  store i32 %11, i32* %12, align 4, !tbaa !279
  %13 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %9, %struct.TString* %1, i32 %2, i32 %11) #16
  %14 = icmp eq i32 %3, 0
  br i1 %14, label %15, label %20

; <label>:15:                                     ; preds = %4
  %16 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %17 = load %struct.Labeldesc*, %struct.Labeldesc** %16, align 8, !tbaa !310
  %18 = sext i32 %13 to i64
  %19 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %17, i64 %18, i32 3
  br label %29

; <label>:20:                                     ; preds = %4
  %21 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 3
  %22 = load %struct.BlockCnt*, %struct.BlockCnt** %21, align 8, !tbaa !285
  %23 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %22, i64 0, i32 3
  %24 = load i8, i8* %23, align 8, !tbaa !293
  %25 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %26 = load %struct.Labeldesc*, %struct.Labeldesc** %25, align 8, !tbaa !310
  %27 = sext i32 %13 to i64
  %28 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %26, i64 %27, i32 3
  store i8 %24, i8* %28, align 8, !tbaa !304
  br label %29

; <label>:29:                                     ; preds = %15, %20
  %30 = phi i8* [ %19, %15 ], [ %28, %20 ]
  %31 = phi i64 [ %18, %15 ], [ %27, %20 ]
  %32 = phi %struct.Labeldesc* [ %17, %15 ], [ %26, %20 ]
  %33 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !254
  %34 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %35 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %34, i64 0, i32 3
  %36 = load %struct.BlockCnt*, %struct.BlockCnt** %35, align 8, !tbaa !285
  %37 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %36, i64 0, i32 2
  %38 = load i32, i32* %37, align 4, !tbaa !295
  %39 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %33, i64 0, i32 1, i32 1
  %40 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %33, i64 0, i32 1, i32 0
  %41 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %32, i64 %31, i32 0
  %42 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %32, i64 %31, i32 1
  br label %43

; <label>:43:                                     ; preds = %91, %29
  %44 = phi i32 [ %92, %91 ], [ %38, %29 ]
  %45 = phi i32 [ %48, %91 ], [ 0, %29 ]
  %46 = sext i32 %44 to i64
  br label %47

; <label>:47:                                     ; preds = %43, %90
  %48 = phi i32 [ %61, %90 ], [ %45, %43 ]
  %49 = load i32, i32* %39, align 8, !tbaa !309
  %50 = icmp slt i32 %44, %49
  br i1 %50, label %51, label %93

; <label>:51:                                     ; preds = %47
  %52 = load %struct.Labeldesc*, %struct.Labeldesc** %40, align 8, !tbaa !310
  %53 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %52, i64 %46, i32 0
  %54 = load %struct.TString*, %struct.TString** %53, align 8, !tbaa !328
  %55 = load %struct.TString*, %struct.TString** %41, align 8, !tbaa !328
  %56 = icmp eq %struct.TString* %54, %55
  br i1 %56, label %57, label %91

; <label>:57:                                     ; preds = %51
  %58 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %52, i64 %46, i32 4
  %59 = load i8, i8* %58, align 1, !tbaa !311
  %60 = zext i8 %59 to i32
  %61 = or i32 %48, %60
  %62 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !254
  %63 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %62, i64 0, i32 1, i32 0
  %64 = load %struct.Labeldesc*, %struct.Labeldesc** %63, align 8, !tbaa !310
  %65 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %64, i64 %46, i32 3
  %66 = load i8, i8* %65, align 8, !tbaa !304
  %67 = load i8, i8* %30, align 8, !tbaa !304
  %68 = icmp ult i8 %66, %67
  br i1 %68, label %69, label %71, !prof !47

; <label>:69:                                     ; preds = %57
  %70 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %64, i64 %46
  tail call fastcc void @jumpscopeerror(%struct.LexState* nonnull %0, %struct.Labeldesc* %70) #19
  unreachable

; <label>:71:                                     ; preds = %57
  %72 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %73 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %64, i64 %46, i32 1
  %74 = load i32, i32* %73, align 8, !tbaa !305
  %75 = load i32, i32* %42, align 8, !tbaa !305
  tail call fastcc void @luaK_patchlist(%struct.FuncState* %72, i32 %74, i32 %75) #17
  %76 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %62, i64 0, i32 1, i32 1
  br label %77

; <label>:77:                                     ; preds = %83, %71
  %78 = phi i64 [ %86, %83 ], [ %46, %71 ]
  %79 = load i32, i32* %76, align 8, !tbaa !309
  %80 = add nsw i32 %79, -1
  %81 = sext i32 %80 to i64
  %82 = icmp slt i64 %78, %81
  br i1 %82, label %83, label %90

; <label>:83:                                     ; preds = %77
  %84 = load %struct.Labeldesc*, %struct.Labeldesc** %63, align 8, !tbaa !310
  %85 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %84, i64 %78
  %86 = add nsw i64 %78, 1
  %87 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %84, i64 %86
  %88 = bitcast %struct.Labeldesc* %85 to i8*
  %89 = bitcast %struct.Labeldesc* %87 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %88, i8* %89, i64 24, i32 8, i1 false) #7, !tbaa.struct !329
  br label %77

; <label>:90:                                     ; preds = %77
  store i32 %80, i32* %76, align 8, !tbaa !309
  br label %47

; <label>:91:                                     ; preds = %51
  %92 = add nsw i32 %44, 1
  br label %43

; <label>:93:                                     ; preds = %47
  %94 = icmp eq i32 %48, 0
  br i1 %94, label %102, label %95

; <label>:95:                                     ; preds = %93
  %96 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 13
  %97 = load i8, i8* %96, align 2, !tbaa !288
  %98 = zext i8 %97 to i32
  %99 = shl nuw nsw i32 %98, 7
  %100 = or i32 %99, 55
  %101 = tail call fastcc i32 @luaK_code(%struct.FuncState* %6, i32 %100) #17
  br label %102

; <label>:102:                                    ; preds = %93, %95
  %103 = phi i32 [ 1, %95 ], [ 0, %93 ]
  ret i32 %103
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @undefgoto(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 0
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !328
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %6 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !259
  %7 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #16
  %8 = icmp eq %struct.TString* %4, %7
  %9 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !259
  br i1 %8, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !302
  %13 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.264, i64 0, i64 0), i32 %12) #16
  br label %21

; <label>:14:                                     ; preds = %2
  %15 = bitcast %struct.Labeldesc* %1 to i8**
  %16 = load i8*, i8** %15, align 8, !tbaa !328
  %17 = getelementptr inbounds i8, i8* %16, i64 24
  %18 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %19 = load i32, i32* %18, align 4, !tbaa !302
  %20 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.265, i64 0, i64 0), i8* nonnull %17, i32 %19) #16
  br label %21

; <label>:21:                                     ; preds = %14, %10
  %22 = phi i8* [ %13, %10 ], [ %20, %14 ]
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %22) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @jumpscopeerror(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !263
  %5 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 3
  %6 = load i8, i8* %5, align 8, !tbaa !304
  %7 = zext i8 %6 to i32
  %8 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %4, i32 %7) #16
  %9 = bitcast %struct.LocVar* %8 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !101
  %11 = getelementptr inbounds i8, i8* %10, i64 24
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %13 = load %struct.lua_State*, %struct.lua_State** %12, align 8, !tbaa !259
  %14 = bitcast %struct.Labeldesc* %1 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !328
  %16 = getelementptr inbounds i8, i8* %15, i64 24
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %18 = load i32, i32* %17, align 4, !tbaa !302
  %19 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.263, i64 0, i64 0), i8* nonnull %16, i32 %18, i8* nonnull %11) #16
  tail call fastcc void @luaK_semerror(%struct.LexState* %0, i8* %19) #18
  unreachable
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @luaK_semerror(%struct.LexState* nocapture, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 0, i32* %3, align 8, !tbaa !258
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %1) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @cond(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %2) #16
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  store i32 3, i32* %4, align 8, !tbaa !273
  br label %8

; <label>:8:                                      ; preds = %7, %1
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %10 = load %struct.FuncState*, %struct.FuncState** %9, align 8, !tbaa !263
  call fastcc void @luaK_goiftrue(%struct.FuncState* %10, %struct.expdesc* nonnull %2) #16
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %12 = load i32, i32* %11, align 4, !tbaa !272
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret i32 %12
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal fastcc void @error_expected(%struct.LexState* nocapture readonly, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !259
  %5 = tail call fastcc i8* @luaX_token2str(%struct.LexState* %0, i32 %1) #16
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.267, i64 0, i64 0), i8* %5) #16
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %6) #18
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @exp1(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %2) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !263
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @forbody(%struct.LexState*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !263
  tail call fastcc void @checknext(%struct.LexState* %0, i32 259) #16
  %10 = sext i32 %4 to i64
  %11 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forprep, i64 0, i64 %10
  %12 = load i32, i32* %11, align 4, !tbaa !21
  %13 = shl i32 %1, 7
  %14 = or i32 %12, %13
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %9, i32 %14) #17
  call fastcc void @enterblock(%struct.FuncState* %9, %struct.BlockCnt* nonnull %6, i8 zeroext 0) #16
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 %3) #16
  call fastcc void @luaK_reserveregs(%struct.FuncState* %9, i32 %3) #16
  call fastcc void @block(%struct.LexState* %0) #16
  call fastcc void @leaveblock(%struct.FuncState* %9) #16
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 4
  %17 = load i32, i32* %16, align 8, !tbaa !277
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 5
  store i32 %17, i32* %18, align 4, !tbaa !279
  call fastcc void @fixforjump(%struct.FuncState* %9, i32 %15, i32 %17, i32 0) #16
  %19 = icmp eq i32 %4, 0
  br i1 %19, label %27, label %20

; <label>:20:                                     ; preds = %5
  %21 = shl i32 %3, 24
  %22 = or i32 %13, %21
  %23 = or i32 %22, 77
  %24 = call fastcc i32 @luaK_code(%struct.FuncState* %9, i32 %23) #17
  call fastcc void @luaK_fixline(%struct.FuncState* %9, i32 %2) #16
  %25 = shl i32 %1, 7
  %26 = add i32 %25, 256
  br label %27

; <label>:27:                                     ; preds = %5, %20
  %28 = phi i32 [ %13, %5 ], [ %26, %20 ]
  %29 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forloop, i64 0, i64 %10
  %30 = load i32, i32* %29, align 4, !tbaa !21
  %31 = or i32 %28, %30
  %32 = call fastcc i32 @luaK_code(%struct.FuncState* %9, i32 %31) #17
  %33 = add nsw i32 %15, 1
  call fastcc void @fixforjump(%struct.FuncState* %9, i32 %32, i32 %33, i32 1) #16
  call fastcc void @luaK_fixline(%struct.FuncState* %9, i32 %2) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @fixforjump(%struct.FuncState* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !251
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 16
  %8 = load i32*, i32** %7, align 8, !tbaa !119
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds i32, i32* %8, i64 %9
  %11 = xor i32 %1, -1
  %12 = add i32 %11, %2
  %13 = icmp eq i32 %3, 0
  %14 = sub nsw i32 0, %12
  %15 = select i1 %13, i32 %12, i32 %14
  %16 = icmp sgt i32 %15, 131071
  br i1 %16, label %17, label %20, !prof !47

; <label>:17:                                     ; preds = %4
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %19 = load %struct.LexState*, %struct.LexState** %18, align 8, !tbaa !276
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %19, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #18
  unreachable

; <label>:20:                                     ; preds = %4
  %21 = load i32, i32* %10, align 4, !tbaa !74
  %22 = and i32 %21, 32767
  %23 = shl i32 %15, 15
  %24 = or i32 %22, %23
  store i32 %24, i32* %10, align 4, !tbaa !74
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @adjust_assign(%struct.LexState* nocapture readonly, i32, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !263
  %7 = sub nsw i32 %1, %2
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !273
  switch i32 %9, label %10 [
    i32 16, label %17
    i32 17, label %17
    i32 0, label %11
  ]

; <label>:10:                                     ; preds = %4
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* nonnull %3) #16
  br label %11

; <label>:11:                                     ; preds = %4, %10
  %12 = icmp sgt i32 %7, 0
  br i1 %12, label %13, label %23

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %15 = load i8, i8* %14, align 4, !tbaa !301
  %16 = zext i8 %15 to i32
  tail call fastcc void @luaK_nil(%struct.FuncState* %6, i32 %16, i32 %7) #16
  br label %22

; <label>:17:                                     ; preds = %4, %4
  %18 = add nsw i32 %7, 1
  %19 = icmp sgt i32 %18, 0
  %20 = select i1 %19, i32 %18, i32 0
  tail call fastcc void @luaK_setreturns(%struct.FuncState* %6, %struct.expdesc* nonnull %3, i32 %20) #16
  %21 = icmp sgt i32 %7, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %13, %17
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %6, i32 %7) #16
  br label %28

; <label>:23:                                     ; preds = %11, %17
  %24 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %25 = load i8, i8* %24, align 4, !tbaa !301
  %26 = trunc i32 %7 to i8
  %27 = add i8 %25, %26
  store i8 %27, i8* %24, align 4, !tbaa !301
  br label %28

; <label>:28:                                     ; preds = %23, %22
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @luaK_ret(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 1
  %5 = select i1 %4, i32 73, i32 71
  %6 = icmp eq i32 %2, 0
  %7 = select i1 %6, i32 72, i32 %5
  %8 = shl i32 %1, 7
  %9 = shl i32 %2, 16
  %10 = add i32 %9, 65536
  %11 = or i32 %10, %8
  %12 = or i32 %11, %7
  %13 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %12) #17
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @restassign(%struct.LexState*, %struct.LHS_assign*, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LHS_assign, align 8
  %6 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %1, i64 0, i32 1
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %7, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !308
  %10 = add i32 %9, -8
  %11 = icmp ult i32 %10, 6
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #18
  unreachable

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44) #16
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %104, label %16

; <label>:16:                                     ; preds = %13
  %17 = bitcast %struct.LHS_assign* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %17) #7
  %18 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 0
  store %struct.LHS_assign* %1, %struct.LHS_assign** %18, align 8, !tbaa !306
  %19 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* %0, %struct.expdesc* nonnull %19) #16
  %20 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %19, i64 0, i32 0
  %21 = load i32, i32* %20, align 8, !tbaa !308
  %22 = add i32 %21, -10
  %23 = icmp ult i32 %22, 4
  br i1 %23, label %96, label %24

; <label>:24:                                     ; preds = %16
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %26 = load %struct.FuncState*, %struct.FuncState** %25, align 8, !tbaa !263
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %26, i64 0, i32 15
  %28 = load i8, i8* %27, align 4, !tbaa !301
  %29 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 1, i32 1
  %30 = bitcast %union.anon.8* %29 to i32*
  %31 = zext i8 %28 to i16
  br label %32

; <label>:32:                                     ; preds = %79, %24
  %33 = phi i32 [ 0, %24 ], [ %80, %79 ]
  %34 = phi %struct.LHS_assign* [ %1, %24 ], [ %82, %79 ]
  %35 = icmp eq %struct.LHS_assign* %34, null
  br i1 %35, label %83, label %36

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %34, i64 0, i32 1, i32 0
  %38 = load i32, i32* %37, align 8, !tbaa !308
  %39 = add i32 %38, -10
  %40 = icmp ult i32 %39, 4
  br i1 %40, label %41, label %79

; <label>:41:                                     ; preds = %36
  %42 = icmp eq i32 %38, 11
  %43 = load i32, i32* %20, align 8, !tbaa !273
  br i1 %42, label %44, label %55

; <label>:44:                                     ; preds = %41
  %45 = icmp eq i32 %43, 9
  br i1 %45, label %46, label %79

; <label>:46:                                     ; preds = %44
  %47 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %34, i64 0, i32 1, i32 1
  %48 = bitcast %union.anon.8* %47 to %struct.anon.9*
  %49 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %48, i64 0, i32 1
  %50 = load i8, i8* %49, align 2, !tbaa !21
  %51 = zext i8 %50 to i32
  %52 = load i32, i32* %30, align 8, !tbaa !21
  %53 = icmp eq i32 %52, %51
  br i1 %53, label %54, label %79

; <label>:54:                                     ; preds = %46
  store i32 13, i32* %37, align 8, !tbaa !308
  store i8 %28, i8* %49, align 2, !tbaa !21
  br label %79

; <label>:55:                                     ; preds = %41
  %56 = icmp eq i32 %43, 8
  br i1 %56, label %57, label %79

; <label>:57:                                     ; preds = %55
  %58 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %34, i64 0, i32 1, i32 1
  %59 = bitcast %union.anon.8* %58 to %struct.anon.9*
  %60 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %59, i64 0, i32 1
  %61 = load i8, i8* %60, align 2, !tbaa !21
  %62 = zext i8 %61 to i32
  %63 = load i32, i32* %30, align 8, !tbaa !21
  %64 = icmp eq i32 %63, %62
  br i1 %64, label %65, label %66

; <label>:65:                                     ; preds = %57
  store i8 %28, i8* %60, align 2, !tbaa !21
  br label %66

; <label>:66:                                     ; preds = %65, %57
  %67 = phi i32 [ 1, %65 ], [ %33, %57 ]
  %68 = icmp ne i32 %38, 10
  %69 = xor i1 %56, true
  %70 = or i1 %68, %69
  br i1 %70, label %79, label %71

; <label>:71:                                     ; preds = %66
  %72 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %34, i64 0, i32 1, i32 1
  %73 = bitcast %union.anon.8* %72 to i16*
  %74 = load i16, i16* %73, align 8, !tbaa !21
  %75 = sext i16 %74 to i32
  %76 = load i32, i32* %30, align 8, !tbaa !21
  %77 = icmp eq i32 %76, %75
  br i1 %77, label %78, label %79

; <label>:78:                                     ; preds = %71
  store i16 %31, i16* %73, align 8, !tbaa !21
  br label %79

; <label>:79:                                     ; preds = %55, %66, %78, %71, %54, %46, %44, %36
  %80 = phi i32 [ 1, %54 ], [ %33, %46 ], [ %33, %44 ], [ 1, %78 ], [ %67, %71 ], [ %67, %66 ], [ %33, %36 ], [ %33, %55 ]
  %81 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %34, i64 0, i32 0
  %82 = load %struct.LHS_assign*, %struct.LHS_assign** %81, align 8, !tbaa !306
  br label %32

; <label>:83:                                     ; preds = %32
  %84 = icmp eq i32 %33, 0
  br i1 %84, label %96, label %85

; <label>:85:                                     ; preds = %83
  %86 = zext i8 %28 to i32
  %87 = load i32, i32* %20, align 8, !tbaa !273
  %88 = icmp eq i32 %87, 8
  %89 = select i1 %88, i32 0, i32 7
  %90 = load i32, i32* %30, align 8, !tbaa !21
  %91 = shl nuw nsw i32 %86, 7
  %92 = or i32 %89, %91
  %93 = shl i32 %90, 16
  %94 = or i32 %92, %93
  %95 = call fastcc i32 @luaK_code(%struct.FuncState* %26, i32 %94) #17
  call fastcc void @luaK_reserveregs(%struct.FuncState* %26, i32 1) #17
  br label %96

; <label>:96:                                     ; preds = %85, %83, %16
  %97 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %98 = load %struct.lua_State*, %struct.lua_State** %97, align 8, !tbaa !259
  call fastcc void @luaE_enterCcall(%struct.lua_State* %98) #16
  %99 = add nsw i32 %2, 1
  call fastcc void @restassign(%struct.LexState* %0, %struct.LHS_assign* nonnull %5, i32 %99) #16
  %100 = load %struct.lua_State*, %struct.lua_State** %97, align 8, !tbaa !259
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %100, i64 0, i32 19
  %102 = load i32, i32* %101, align 8, !tbaa !54
  %103 = add i32 %102, -1
  store i32 %103, i32* %101, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %17) #7
  br label %112

; <label>:104:                                    ; preds = %13
  tail call fastcc void @checknext(%struct.LexState* %0, i32 61) #16
  %105 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %4) #16
  %106 = icmp eq i32 %105, %2
  br i1 %106, label %108, label %107

; <label>:107:                                    ; preds = %104
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 %2, i32 %105, %struct.expdesc* nonnull %4) #16
  br label %112

; <label>:108:                                    ; preds = %104
  %109 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %110 = load %struct.FuncState*, %struct.FuncState** %109, align 8, !tbaa !263
  call fastcc void @luaK_setoneret(%struct.FuncState* %110, %struct.expdesc* nonnull %4) #16
  %111 = load %struct.FuncState*, %struct.FuncState** %109, align 8, !tbaa !263
  call fastcc void @luaK_storevar(%struct.FuncState* %111, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4) #16
  br label %124

; <label>:112:                                    ; preds = %107, %96
  %113 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %114 = load %struct.FuncState*, %struct.FuncState** %113, align 8, !tbaa !263
  %115 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %114, i64 0, i32 15
  %116 = load i8, i8* %115, align 4, !tbaa !301
  %117 = zext i8 %116 to i32
  %118 = add nsw i32 %117, -1
  %119 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %119, align 8, !tbaa !270
  %120 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %120, align 4, !tbaa !272
  %121 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 7, i32* %121, align 8, !tbaa !273
  %122 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %123 = bitcast %union.anon.8* %122 to i32*
  store i32 %118, i32* %123, align 8, !tbaa !21
  call fastcc void @luaK_storevar(%struct.FuncState* %114, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4) #16
  br label %124

; <label>:124:                                    ; preds = %108, %112
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @luaM_shrinkvector_(%struct.lua_State*, i8*, i32* nocapture, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = load i32, i32* %2, align 4, !tbaa !74
  %9 = mul nsw i32 %8, %4
  %10 = sext i32 %9 to i64
  %11 = mul nsw i32 %4, %3
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %14 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %13, align 8, !tbaa !45
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !46
  %17 = tail call i8* %14(i8* %16, i8* %1, i64 %10, i64 %12) #17
  %18 = icmp eq i8* %17, null
  %19 = icmp sgt i32 %3, 0
  %20 = and i1 %19, %18
  br i1 %20, label %21, label %22, !prof !47

; <label>:21:                                     ; preds = %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:22:                                     ; preds = %5
  %23 = sub nsw i64 %12, %10
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !11
  %26 = add i64 %23, %25
  store i64 %26, i64* %24, align 8, !tbaa !11
  store i32 %3, i32* %2, align 4, !tbaa !74
  ret i8* %17
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpByte(i32, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %3) #7
  %4 = trunc i32 %0 to i8
  store i8 %4, i8* %3, align 1, !tbaa !21
  call fastcc void @DumpBlock(i8* nonnull %3, i64 1, %struct.DumpState* %1) #16
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %3) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpFunction(%struct.Proto* readonly, %struct.TString* readnone, %struct.DumpState*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 3
  %5 = load i32, i32* %4, align 8, !tbaa !183
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !108
  %10 = icmp eq %struct.TString* %9, %1
  br i1 %10, label %11, label %12

; <label>:11:                                     ; preds = %3, %7
  tail call fastcc void @DumpSize(i64 0, %struct.DumpState* nonnull %2) #17
  br label %13

; <label>:12:                                     ; preds = %7
  tail call fastcc void @DumpString(%struct.TString* %9, %struct.DumpState* nonnull %2) #16
  br label %13

; <label>:13:                                     ; preds = %12, %11
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  %15 = load i32, i32* %14, align 4, !tbaa !110
  tail call fastcc void @DumpInt(i32 %15, %struct.DumpState* nonnull %2) #16
  %16 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 14
  %17 = load i32, i32* %16, align 8, !tbaa !111
  tail call fastcc void @DumpInt(i32 %17, %struct.DumpState* nonnull %2) #16
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 3
  %19 = load i8, i8* %18, align 2, !tbaa !117
  %20 = zext i8 %19 to i32
  tail call fastcc void @DumpByte(i32 %20, %struct.DumpState* nonnull %2) #16
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 4
  %22 = load i8, i8* %21, align 1, !tbaa !102
  %23 = zext i8 %22 to i32
  tail call fastcc void @DumpByte(i32 %23, %struct.DumpState* nonnull %2) #16
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 5
  %25 = load i8, i8* %24, align 4, !tbaa !153
  %26 = zext i8 %25 to i32
  tail call fastcc void @DumpByte(i32 %26, %struct.DumpState* nonnull %2) #16
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 8
  %28 = load i32, i32* %27, align 8, !tbaa !218
  tail call fastcc void @DumpInt(i32 %28, %struct.DumpState* nonnull %2) #17
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  %30 = bitcast i32** %29 to i8**
  %31 = load i8*, i8** %30, align 8, !tbaa !119
  %32 = load i32, i32* %27, align 8, !tbaa !218
  %33 = sext i32 %32 to i64
  %34 = shl nsw i64 %33, 2
  tail call fastcc void @DumpBlock(i8* %31, i64 %34, %struct.DumpState* nonnull %2) #17
  %35 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 7
  %36 = load i32, i32* %35, align 4, !tbaa !222
  tail call fastcc void @DumpInt(i32 %36, %struct.DumpState* nonnull %2) #17
  %37 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %38 = sext i32 %36 to i64
  br label %39

; <label>:39:                                     ; preds = %63, %13
  %40 = phi i64 [ %64, %63 ], [ 0, %13 ]
  %41 = icmp slt i64 %40, %38
  br i1 %41, label %42, label %65

; <label>:42:                                     ; preds = %39
  %43 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !221
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 %40
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 %40, i32 1
  %46 = load i8, i8* %45, align 8, !tbaa !22
  %47 = and i8 %46, 63
  %48 = zext i8 %47 to i32
  tail call fastcc void @DumpByte(i32 %48, %struct.DumpState* %2) #17
  %49 = load i8, i8* %45, align 8, !tbaa !22
  %50 = trunc i8 %49 to i6
  switch i6 %50, label %63 [
    i6 -28, label %60
    i6 1, label %51
    i6 19, label %54
    i6 -29, label %57
    i6 20, label %60
  ]

; <label>:51:                                     ; preds = %42
  %52 = bitcast %struct.TValue* %44 to i32*
  %53 = load i32, i32* %52, align 8, !tbaa !21
  tail call fastcc void @DumpByte(i32 %53, %struct.DumpState* %2) #17
  br label %63

; <label>:54:                                     ; preds = %42
  %55 = bitcast %struct.TValue* %44 to double*
  %56 = load double, double* %55, align 8, !tbaa !21
  tail call fastcc void @DumpNumber(double %56, %struct.DumpState* %2) #17
  br label %63

; <label>:57:                                     ; preds = %42
  %58 = bitcast %struct.TValue* %44 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !21
  tail call fastcc void @DumpInteger(i64 %59, %struct.DumpState* %2) #17
  br label %63

; <label>:60:                                     ; preds = %42, %42
  %61 = bitcast %struct.TValue* %44 to %struct.TString**
  %62 = load %struct.TString*, %struct.TString** %61, align 8, !tbaa !21
  tail call fastcc void @DumpString(%struct.TString* %62, %struct.DumpState* %2) #17
  br label %63

; <label>:63:                                     ; preds = %60, %57, %54, %51, %42
  %64 = add nuw nsw i64 %40, 1
  br label %39

; <label>:65:                                     ; preds = %39
  %66 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 6
  %67 = load i32, i32* %66, align 8, !tbaa !185
  tail call fastcc void @DumpInt(i32 %67, %struct.DumpState* %2) #17
  %68 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %69 = sext i32 %67 to i64
  br label %70

; <label>:70:                                     ; preds = %73, %65
  %71 = phi i64 [ %82, %73 ], [ 0, %65 ]
  %72 = icmp slt i64 %71, %69
  br i1 %72, label %73, label %83

; <label>:73:                                     ; preds = %70
  %74 = load %struct.Upvaldesc*, %struct.Upvaldesc** %68, align 8, !tbaa !193
  %75 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %74, i64 %71, i32 1
  %76 = load i8, i8* %75, align 8, !tbaa !238
  %77 = zext i8 %76 to i32
  tail call fastcc void @DumpByte(i32 %77, %struct.DumpState* %2) #17
  %78 = load %struct.Upvaldesc*, %struct.Upvaldesc** %68, align 8, !tbaa !193
  %79 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %78, i64 %71, i32 2
  %80 = load i8, i8* %79, align 1, !tbaa !239
  %81 = zext i8 %80 to i32
  tail call fastcc void @DumpByte(i32 %81, %struct.DumpState* %2) #17
  %82 = add nuw nsw i64 %71, 1
  br label %70

; <label>:83:                                     ; preds = %70
  %84 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 10
  %85 = load i32, i32* %84, align 8, !tbaa !220
  tail call fastcc void @DumpInt(i32 %85, %struct.DumpState* %2) #17
  %86 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 17
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %88 = sext i32 %85 to i64
  br label %89

; <label>:89:                                     ; preds = %92, %83
  %90 = phi i64 [ %97, %92 ], [ 0, %83 ]
  %91 = icmp slt i64 %90, %88
  br i1 %91, label %92, label %98

; <label>:92:                                     ; preds = %89
  %93 = load %struct.Proto**, %struct.Proto*** %86, align 8, !tbaa !219
  %94 = getelementptr inbounds %struct.Proto*, %struct.Proto** %93, i64 %90
  %95 = load %struct.Proto*, %struct.Proto** %94, align 8, !tbaa !39
  %96 = load %struct.TString*, %struct.TString** %87, align 8, !tbaa !108
  tail call fastcc void @DumpFunction(%struct.Proto* %95, %struct.TString* %96, %struct.DumpState* %2) #17
  %97 = add nuw nsw i64 %90, 1
  br label %89

; <label>:98:                                     ; preds = %89
  %99 = load i32, i32* %4, align 8, !tbaa !183
  %100 = icmp eq i32 %99, 0
  br i1 %100, label %101, label %104

; <label>:101:                                    ; preds = %98
  %102 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 9
  %103 = load i32, i32* %102, align 4, !tbaa !123
  br label %104

; <label>:104:                                    ; preds = %101, %98
  %105 = phi i32 [ %103, %101 ], [ 0, %98 ]
  tail call fastcc void @DumpInt(i32 %105, %struct.DumpState* nonnull %2) #17
  %106 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %107 = load i8*, i8** %106, align 8, !tbaa !124
  %108 = sext i32 %105 to i64
  tail call fastcc void @DumpBlock(i8* %107, i64 %108, %struct.DumpState* nonnull %2) #17
  %109 = load i32, i32* %4, align 8, !tbaa !183
  %110 = icmp eq i32 %109, 0
  br i1 %110, label %111, label %114

; <label>:111:                                    ; preds = %104
  %112 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %113 = load i32, i32* %112, align 8, !tbaa !224
  br label %114

; <label>:114:                                    ; preds = %111, %104
  %115 = phi i32 [ %113, %111 ], [ 0, %104 ]
  tail call fastcc void @DumpInt(i32 %115, %struct.DumpState* nonnull %2) #17
  %116 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %117 = sext i32 %115 to i64
  br label %118

; <label>:118:                                    ; preds = %121, %114
  %119 = phi i64 [ %128, %121 ], [ 0, %114 ]
  %120 = icmp slt i64 %119, %117
  br i1 %120, label %121, label %129

; <label>:121:                                    ; preds = %118
  %122 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %116, align 8, !tbaa !223
  %123 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %122, i64 %119, i32 0
  %124 = load i32, i32* %123, align 4, !tbaa !236
  tail call fastcc void @DumpInt(i32 %124, %struct.DumpState* %2) #17
  %125 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %116, align 8, !tbaa !223
  %126 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %125, i64 %119, i32 1
  %127 = load i32, i32* %126, align 4, !tbaa !274
  tail call fastcc void @DumpInt(i32 %127, %struct.DumpState* %2) #17
  %128 = add nuw nsw i64 %119, 1
  br label %118

; <label>:129:                                    ; preds = %118
  %130 = load i32, i32* %4, align 8, !tbaa !183
  %131 = icmp eq i32 %130, 0
  br i1 %131, label %132, label %135

; <label>:132:                                    ; preds = %129
  %133 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %134 = load i32, i32* %133, align 4, !tbaa !95
  br label %135

; <label>:135:                                    ; preds = %132, %129
  %136 = phi i32 [ %134, %132 ], [ 0, %129 ]
  tail call fastcc void @DumpInt(i32 %136, %struct.DumpState* nonnull %2) #17
  %137 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %138 = sext i32 %136 to i64
  br label %139

; <label>:139:                                    ; preds = %142, %135
  %140 = phi i64 [ %152, %142 ], [ 0, %135 ]
  %141 = icmp slt i64 %140, %138
  br i1 %141, label %142, label %153

; <label>:142:                                    ; preds = %139
  %143 = load %struct.LocVar*, %struct.LocVar** %137, align 8, !tbaa !97
  %144 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %143, i64 %140, i32 0
  %145 = load %struct.TString*, %struct.TString** %144, align 8, !tbaa !101
  tail call fastcc void @DumpString(%struct.TString* %145, %struct.DumpState* %2) #17
  %146 = load %struct.LocVar*, %struct.LocVar** %137, align 8, !tbaa !97
  %147 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %146, i64 %140, i32 1
  %148 = load i32, i32* %147, align 8, !tbaa !98
  tail call fastcc void @DumpInt(i32 %148, %struct.DumpState* %2) #17
  %149 = load %struct.LocVar*, %struct.LocVar** %137, align 8, !tbaa !97
  %150 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %149, i64 %140, i32 2
  %151 = load i32, i32* %150, align 4, !tbaa !100
  tail call fastcc void @DumpInt(i32 %151, %struct.DumpState* %2) #17
  %152 = add nuw nsw i64 %140, 1
  br label %139

; <label>:153:                                    ; preds = %139
  %154 = load i32, i32* %4, align 8, !tbaa !183
  %155 = icmp eq i32 %154, 0
  br i1 %155, label %156, label %158

; <label>:156:                                    ; preds = %153
  %157 = load i32, i32* %66, align 8, !tbaa !185
  br label %158

; <label>:158:                                    ; preds = %156, %153
  %159 = phi i32 [ %157, %156 ], [ 0, %153 ]
  tail call fastcc void @DumpInt(i32 %159, %struct.DumpState* nonnull %2) #17
  %160 = sext i32 %159 to i64
  br label %161

; <label>:161:                                    ; preds = %164, %158
  %162 = phi i64 [ %168, %164 ], [ 0, %158 ]
  %163 = icmp slt i64 %162, %160
  br i1 %163, label %164, label %169

; <label>:164:                                    ; preds = %161
  %165 = load %struct.Upvaldesc*, %struct.Upvaldesc** %68, align 8, !tbaa !193
  %166 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %165, i64 %162, i32 0
  %167 = load %struct.TString*, %struct.TString** %166, align 8, !tbaa !194
  tail call fastcc void @DumpString(%struct.TString* %167, %struct.DumpState* %2) #17
  %168 = add nuw nsw i64 %162, 1
  br label %161

; <label>:169:                                    ; preds = %161
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpBlock(i8*, i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 4
  %5 = load i32, i32* %4, align 4, !tbaa !184
  %6 = icmp eq i32 %5, 0
  %7 = icmp ne i64 %1, 0
  %8 = and i1 %7, %6
  br i1 %8, label %9, label %17

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %11 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %10, align 8, !tbaa !181
  %12 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %13 = load %struct.lua_State*, %struct.lua_State** %12, align 8, !tbaa !179
  %14 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %15 = load i8*, i8** %14, align 8, !tbaa !182
  %16 = tail call i32 %11(%struct.lua_State* %13, i8* %0, i64 %1, i8* %15) #17
  store i32 %16, i32* %4, align 4, !tbaa !184
  br label %17

; <label>:17:                                     ; preds = %9, %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpInt(i32, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = sext i32 %0 to i64
  tail call fastcc void @DumpSize(i64 %3, %struct.DumpState* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpInteger(i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca i64, align 8
  store i64 %0, i64* %3, align 8, !tbaa !129
  %4 = bitcast i64* %3 to i8*
  call fastcc void @DumpBlock(i8* nonnull %4, i64 8, %struct.DumpState* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpNumber(double, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca double, align 8
  store double %0, double* %3, align 8, !tbaa !127
  %4 = bitcast double* %3 to i8*
  call fastcc void @DumpBlock(i8* nonnull %4, i64 8, %struct.DumpState* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpSize(i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca [10 x i8], align 1
  %4 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %4) #7
  br label %5

; <label>:5:                                      ; preds = %5, %2
  %6 = phi i64 [ %10, %5 ], [ 0, %2 ]
  %7 = phi i64 [ %13, %5 ], [ %0, %2 ]
  %8 = trunc i64 %7 to i8
  %9 = and i8 %8, 127
  %10 = add nuw nsw i64 %6, 1
  %11 = sub nsw i64 9, %6
  %12 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 %11
  store i8 %9, i8* %12, align 1, !tbaa !21
  %13 = lshr i64 %7, 7
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %15, label %5

; <label>:15:                                     ; preds = %5
  %16 = and i64 %10, 4294967295
  %17 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 9
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = or i8 %18, -128
  store i8 %19, i8* %17, align 1, !tbaa !21
  %20 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 10
  %21 = sub nsw i64 0, %16
  %22 = getelementptr inbounds i8, i8* %20, i64 %21
  call fastcc void @DumpBlock(i8* nonnull %22, i64 %16, %struct.DumpState* %1) #16
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %4) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @DumpString(%struct.TString*, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = icmp eq %struct.TString* %0, null
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @DumpSize(i64 0, %struct.DumpState* %1) #16
  br label %21

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !72
  %8 = icmp eq i8 %7, 20
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !109
  %12 = zext i8 %11 to i64
  br label %16

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %13, %9
  %17 = phi i64 [ %12, %9 ], [ %15, %13 ]
  %18 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %19 = bitcast %struct.TString* %18 to i8*
  %20 = add i64 %17, 1
  tail call fastcc void @DumpSize(i64 %20, %struct.DumpState* %1) #16
  tail call fastcc void @DumpBlock(i8* nonnull %19, i64 %17, %struct.DumpState* %1) #16
  br label %21

; <label>:21:                                     ; preds = %16, %4
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @trynewtbcupval(%struct.lua_State*, i8*) #0 {
  %3 = bitcast i8* %1 to %union.StackValue*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 25, %union.StackValue* %3, %struct.UpVal** nonnull %4) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @copy2buff(%union.StackValue* nocapture readonly, i32, i8* nocapture) unnamed_addr #0 {
  %4 = sext i32 %1 to i64
  br label %5

; <label>:5:                                      ; preds = %22, %3
  %6 = phi i64 [ %28, %22 ], [ %4, %3 ]
  %7 = phi i64 [ %27, %22 ], [ 0, %3 ]
  %8 = sub nsw i64 0, %6
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %0, i64 %8, i32 0, i32 0, i32 0
  %10 = bitcast %struct.GCObject** %9 to %struct.TString**
  %11 = load %struct.TString*, %struct.TString** %10, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = icmp eq i8 %13, 20
  br i1 %14, label %15, label %19

; <label>:15:                                     ; preds = %5
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 4
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  br label %22

; <label>:19:                                     ; preds = %5
  %20 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 6, i32 0
  %21 = load i64, i64* %20, align 8, !tbaa !21
  br label %22

; <label>:22:                                     ; preds = %19, %15
  %23 = phi i64 [ %18, %15 ], [ %21, %19 ]
  %24 = getelementptr inbounds i8, i8* %2, i64 %7
  %25 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 1
  %26 = bitcast %struct.TString* %25 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* nonnull %26, i64 %23, i32 1, i1 false)
  %27 = add i64 %23, %7
  %28 = add nsw i64 %6, -1
  %29 = icmp sgt i64 %6, 1
  br i1 %29, label %5, label %30

; <label>:30:                                     ; preds = %22
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @findfield(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %32, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #16
  %7 = icmp eq i32 %6, 5
  br i1 %7, label %8, label %32

; <label>:8:                                      ; preds = %5
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 0, i8* %12, align 8, !tbaa !21
  %13 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %9, align 8, !tbaa !20
  %15 = add nsw i32 %2, -1
  br label %16

; <label>:16:                                     ; preds = %31, %8
  %17 = tail call i32 @lua_next(%struct.lua_State* %0, i32 -2) #16
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %32, label %19

; <label>:19:                                     ; preds = %16
  %20 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -2) #16
  %21 = icmp eq i32 %20, 4
  br i1 %21, label %22, label %31

; <label>:22:                                     ; preds = %19
  %23 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 %1, i32 -1) #16
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %26, label %25

; <label>:25:                                     ; preds = %22
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %32

; <label>:26:                                     ; preds = %22
  %27 = tail call fastcc i32 @findfield(%struct.lua_State* %0, i32 %1, i32 %15) #16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %26
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %30 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0)) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  tail call void @lua_concat(%struct.lua_State* %0, i32 3) #16
  br label %32

; <label>:31:                                     ; preds = %26, %19
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %16

; <label>:32:                                     ; preds = %16, %3, %5, %29, %25
  %33 = phi i32 [ 1, %25 ], [ 1, %29 ], [ 0, %5 ], [ 0, %3 ], [ 0, %16 ]
  ret i32 %33
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @resizebox(%struct.lua_State*, i32, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  %7 = load i8*, i8** %6, align 8, !tbaa !46
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  %9 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %8, align 8, !tbaa !45
  %10 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1) #16
  %11 = bitcast i8* %10 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !330
  %13 = getelementptr inbounds i8, i8* %10, i64 8
  %14 = bitcast i8* %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !332
  %16 = tail call i8* %9(i8* %7, i8* %12, i64 %15, i64 %2) #17
  %17 = icmp eq i8* %16, null
  %18 = icmp ne i64 %2, 0
  %19 = and i1 %18, %17
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %3
  %21 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.293, i64 0, i64 0)) #16
  unreachable

; <label>:22:                                     ; preds = %3
  store i8* %16, i8** %11, align 8, !tbaa !330
  store i64 %2, i64* %14, align 8, !tbaa !332
  ret i8* %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @boxgc(%struct.lua_State*) #0 {
  %2 = tail call fastcc i8* @resizebox(%struct.lua_State* %0, i32 1, i64 0) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize
declare i32 @_IO_getc(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i32 @feof(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i64 @fread(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare void @free(i8* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i32 @fflush(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_assert(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %7

; <label>:4:                                      ; preds = %1
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.324, i64 0, i64 0)) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %6 = tail call i32 @luaB_error(%struct.lua_State* %0) #16
  unreachable

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  ret i32 %19
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_collectgarbage(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i64 0, i64 0), i8** getelementptr inbounds ([11 x i8*], [11 x i8*]* @luaB_collectgarbage.opts, i64 0, i64 0)) #16
  %3 = sext i32 %2 to i64
  %4 = getelementptr inbounds [10 x i32], [10 x i32]* @luaB_collectgarbage.optsnum, i64 0, i64 %3
  %5 = load i32, i32* %4, align 4, !tbaa !74
  switch i32 %5, label %70 [
    i32 3, label %6
    i32 5, label %20
    i32 6, label %33
    i32 7, label %33
    i32 9, label %45
    i32 10, label %56
    i32 11, label %62
  ]

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 3) #16
  %8 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 4) #16
  %9 = sitofp i32 %7 to double
  %10 = sitofp i32 %8 to double
  %11 = fmul double %10, 0x3F50000000000000
  %12 = fadd double %11, %9
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = bitcast %struct.TValue* %15 to double*
  store double %12, double* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 19, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %13, align 8, !tbaa !20
  br label %80

; <label>:20:                                     ; preds = %1
  %21 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %22 = trunc i64 %21 to i32
  %23 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 5, i32 %22) #16
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %25 = bitcast %union.StackValue** %24 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %27 = icmp ne i32 %23, 0
  %28 = zext i1 %27 to i32
  %29 = bitcast %struct.TValue* %26 to i32*
  store i32 %28, i32* %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 1, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %24, align 8, !tbaa !20
  br label %80

; <label>:33:                                     ; preds = %1, %1
  %34 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %35 = trunc i64 %34 to i32
  %36 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %35) #16
  %37 = sext i32 %36 to i64
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %39 = bitcast %union.StackValue** %38 to %struct.TValue**
  %40 = load %struct.TValue*, %struct.TValue** %39, align 8, !tbaa !20
  %41 = bitcast %struct.TValue* %40 to i64*
  store i64 %37, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 1
  store %union.StackValue* %44, %union.StackValue** %38, align 8, !tbaa !20
  br label %80

; <label>:45:                                     ; preds = %1
  %46 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 9) #16
  %47 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %48 = bitcast %union.StackValue** %47 to %struct.TValue**
  %49 = load %struct.TValue*, %struct.TValue** %48, align 8, !tbaa !20
  %50 = icmp ne i32 %46, 0
  %51 = zext i1 %50 to i32
  %52 = bitcast %struct.TValue* %49 to i32*
  store i32 %51, i32* %52, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 0, i32 1
  store i8 1, i8* %53, align 8, !tbaa !22
  %54 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !20
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 1
  store %union.StackValue* %55, %union.StackValue** %47, align 8, !tbaa !20
  br label %80

; <label>:56:                                     ; preds = %1
  %57 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %58 = trunc i64 %57 to i32
  %59 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %60 = trunc i64 %59 to i32
  %61 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 %58, i32 %60) #16
  tail call fastcc void @pushmode(%struct.lua_State* %0, i32 %61) #16
  br label %80

; <label>:62:                                     ; preds = %1
  %63 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %64 = trunc i64 %63 to i32
  %65 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %66 = trunc i64 %65 to i32
  %67 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 0) #16
  %68 = trunc i64 %67 to i32
  %69 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 11, i32 %64, i32 %66, i32 %68) #16
  tail call fastcc void @pushmode(%struct.lua_State* %0, i32 %69) #16
  br label %80

; <label>:70:                                     ; preds = %1
  %71 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5) #16
  %72 = sext i32 %71 to i64
  %73 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %74 = bitcast %union.StackValue** %73 to %struct.TValue**
  %75 = load %struct.TValue*, %struct.TValue** %74, align 8, !tbaa !20
  %76 = bitcast %struct.TValue* %75 to i64*
  store i64 %72, i64* %76, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 1
  store i8 35, i8* %77, align 8, !tbaa !22
  %78 = load %union.StackValue*, %union.StackValue** %73, align 8, !tbaa !20
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 1
  store %union.StackValue* %79, %union.StackValue** %73, align 8, !tbaa !20
  br label %80

; <label>:80:                                     ; preds = %70, %62, %56, %45, %33, %20, %6
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_dofile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %2, i8* null) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @lua_error(%struct.lua_State* %0) #16
  unreachable

; <label>:7:                                      ; preds = %1
  tail call void @lua_callk(%struct.lua_State* %0, i32 0, i32 -1, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @dofilecont) #16
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, -1
  ret i32 %20
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal i32 @luaB_error(%struct.lua_State*) #5 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = trunc i64 %2 to i32
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %5 = icmp eq i32 %4, 4
  %6 = icmp sgt i32 %3, 0
  %7 = and i1 %6, %5
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %1
  tail call void @luaL_where(%struct.lua_State* %0, i32 %3) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  tail call void @lua_concat(%struct.lua_State* %0, i32 2) #16
  br label %9

; <label>:9:                                      ; preds = %8, %1
  %10 = tail call i32 @lua_error(%struct.lua_State* %0) #16
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %13

; <label>:11:                                     ; preds = %1
  %12 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0)) #16
  br label %13

; <label>:13:                                     ; preds = %11, %4
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_ipairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @ipairsaux, i32 (%struct.lua_State*)** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 38, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %9 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %10 = bitcast %struct.TValue* %9 to i64*
  store i64 0, i64* %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 35, i8* %11, align 8, !tbaa !22
  %12 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1
  store %union.StackValue* %13, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_loadfile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* null, i64* null) #16
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 3) #16
  %5 = icmp eq i32 %4, -1
  %6 = select i1 %5, i32 0, i32 3
  %7 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %2, i8* %3) #16
  %8 = tail call fastcc i32 @load_aux(%struct.lua_State* %0, i32 %7, i32 %6) #16
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_load(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.335, i64 0, i64 0), i64* null) #16
  %6 = call i32 @lua_type(%struct.lua_State* %0, i32 4) #16
  %7 = icmp eq i32 %6, -1
  %8 = select i1 %7, i32 0, i32 4
  %9 = icmp eq i8* %4, null
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* nonnull %4, i64* null) #16
  %12 = load i64, i64* %2, align 8, !tbaa !135
  %13 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %4, i64 %12, i8* %11, i8* %5) #16
  br label %17

; <label>:14:                                     ; preds = %1
  %15 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.336, i64 0, i64 0), i64* null) #16
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  call void @lua_settop(%struct.lua_State* %0, i32 5) #16
  %16 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @generic_reader, i8* null, i8* %15, i8* %5) #16
  br label %17

; <label>:17:                                     ; preds = %14, %10
  %18 = phi i32 [ %13, %10 ], [ %16, %14 ]
  %19 = call fastcc i32 @load_aux(%struct.lua_State* %0, i32 %18, i32 %8) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %19
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_next(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_next(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %1, %4
  %12 = phi i32 [ 1, %4 ], [ 2, %1 ]
  ret i32 %12
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_pairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.339, i64 0, i64 0)) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %16

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @luaB_next, i32 (%struct.lua_State*)** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 38, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %12 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %5, align 8, !tbaa !20
  br label %20

; <label>:16:                                     ; preds = %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %19, i32 3) #17
  br label %20

; <label>:20:                                     ; preds = %16, %4
  ret i32 3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_pcall(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32*
  store i32 1, i32* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 1, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1) #16
  %9 = bitcast %union.StackValue** %2 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, -2
  %21 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %20, i32 -1, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall) #16
  %22 = tail call i32 @finishpcall(%struct.lua_State* %0, i32 %21, i64 0) #16
  ret i32 %22
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_print(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = bitcast i64* %2 to i8*
  br label %16

; <label>:16:                                     ; preds = %25, %1
  %17 = phi i32 [ 1, %1 ], [ %29, %25 ]
  %18 = icmp sgt i32 %17, %14
  br i1 %18, label %30, label %19

; <label>:19:                                     ; preds = %16
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %15) #7
  %20 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %17, i64* nonnull %2) #16
  %21 = icmp ugt i32 %17, 1
  br i1 %21, label %22, label %25

; <label>:22:                                     ; preds = %19
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %24 = call i32 @fputc(i32 9, %struct._IO_FILE* %23)
  br label %25

; <label>:25:                                     ; preds = %22, %19
  %26 = load i64, i64* %2, align 8, !tbaa !135
  %27 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %28 = call i64 @fwrite(i8* %20, i64 1, i64 %26, %struct._IO_FILE* %27) #16
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %15) #7
  %29 = add nuw nsw i32 %17, 1
  br label %16

; <label>:30:                                     ; preds = %16
  %31 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %32 = call i32 @fputc(i32 10, %struct._IO_FILE* %31)
  %33 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %34 = call i32 @fflush(%struct._IO_FILE* %33) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_warn(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 43
  %6 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %5, align 8, !tbaa !187
  %7 = icmp eq void (i8*, i8*, i32)* %6, null
  br i1 %7, label %12, label %8

; <label>:8:                                      ; preds = %1
  %9 = tail call i32 @lua_toboolean(%struct.lua_State* nonnull %0, i32 2) #16
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 44
  %11 = load i8*, i8** %10, align 8, !tbaa !186
  tail call void %6(i8* %11, i8* %2, i32 %9) #17
  br label %12

; <label>:12:                                     ; preds = %1, %8
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_rawequal(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %2, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_rawlen(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = or i32 %2, 1
  %4 = icmp eq i32 %3, 5
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.341, i64 0, i64 0)) #16
  br label %7

; <label>:7:                                      ; preds = %5, %1
  %8 = tail call i64 @lua_rawlen(%struct.lua_State* %0, i32 1) #16
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = bitcast %struct.TValue* %11 to i64*
  store i64 %8, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 35, i8* %13, align 8, !tbaa !22
  %14 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %9, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_rawget(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_rawset(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 3) #16
  tail call void @lua_rawset(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_select(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %15 = icmp eq i32 %14, 4
  br i1 %15, label %16, label %30

; <label>:16:                                     ; preds = %1
  %17 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = icmp eq i8 %18, 35
  br i1 %19, label %20, label %30

; <label>:20:                                     ; preds = %16
  %21 = shl i64 %11, 28
  %22 = add i64 %21, -4294967296
  %23 = ashr exact i64 %22, 32
  %24 = bitcast %union.StackValue** %2 to %struct.TValue**
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !20
  %26 = bitcast %struct.TValue* %25 to i64*
  store i64 %23, i64* %26, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  store i8 35, i8* %27, align 8, !tbaa !22
  %28 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  store %union.StackValue* %29, %union.StackValue** %2, align 8, !tbaa !20
  br label %45

; <label>:30:                                     ; preds = %16, %1
  %31 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %32 = icmp slt i64 %31, 0
  %33 = shl i64 %11, 28
  %34 = ashr exact i64 %33, 32
  %35 = add nsw i64 %31, %34
  %36 = icmp sgt i64 %31, %34
  %37 = select i1 %36, i64 %34, i64 %31
  %38 = select i1 %32, i64 %35, i64 %37
  %39 = icmp sgt i64 %38, 0
  br i1 %39, label %42, label %40

; <label>:40:                                     ; preds = %30
  %41 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.342, i64 0, i64 0)) #16
  br label %42

; <label>:42:                                     ; preds = %40, %30
  %43 = trunc i64 %38 to i32
  %44 = sub nsw i32 %13, %43
  br label %45

; <label>:45:                                     ; preds = %42, %20
  %46 = phi i32 [ 1, %20 ], [ %44, %42 ]
  ret i32 %46
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_setmetatable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %1
  %4 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0)) #16
  br label %5

; <label>:5:                                      ; preds = %1, %1, %3
  %6 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0)) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.344, i64 0, i64 0)) #16
  unreachable

; <label>:10:                                     ; preds = %5
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %11 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_tonumber(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %8 = icmp eq i32 %7, 3
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %6
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  br label %111

; <label>:10:                                     ; preds = %6
  %11 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %11) #7
  %12 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %13 = icmp eq i8* %12, null
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %10
  %15 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %12) #16
  %16 = load i64, i64* %2, align 8, !tbaa !135
  %17 = add i64 %16, 1
  %18 = icmp eq i64 %15, %17
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %10, %14
  call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %11) #7
  br label %104

; <label>:20:                                     ; preds = %14
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %11) #7
  br label %111

; <label>:21:                                     ; preds = %1
  %22 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %22) #7
  %23 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 4) #16
  %24 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %25 = add i64 %23, -2
  %26 = icmp ult i64 %25, 35
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %21
  %28 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.345, i64 0, i64 0)) #16
  br label %29

; <label>:29:                                     ; preds = %21, %27
  %30 = trunc i64 %23 to i32
  %31 = call i64 @strspn(i8* %24, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #21
  %32 = getelementptr inbounds i8, i8* %24, i64 %31
  %33 = load i8, i8* %32, align 1, !tbaa !21
  switch i8 %33, label %38 [
    i8 45, label %34
    i8 43, label %36
  ]

; <label>:34:                                     ; preds = %29
  %35 = getelementptr inbounds i8, i8* %32, i64 1
  br label %38

; <label>:36:                                     ; preds = %29
  %37 = getelementptr inbounds i8, i8* %32, i64 1
  br label %38

; <label>:38:                                     ; preds = %36, %34, %29
  %39 = phi i32 [ 1, %34 ], [ 0, %36 ], [ 0, %29 ]
  %40 = phi i8* [ %35, %34 ], [ %37, %36 ], [ %32, %29 ]
  %41 = tail call i16** @__ctype_b_loc() #22
  %42 = load i16*, i16** %41, align 8, !tbaa !39
  %43 = load i8, i8* %40, align 1, !tbaa !21
  %44 = zext i8 %43 to i64
  %45 = getelementptr inbounds i16, i16* %42, i64 %44
  %46 = load i16, i16* %45, align 2, !tbaa !317
  %47 = and i16 %46, 8
  %48 = icmp eq i16 %47, 0
  br i1 %48, label %89, label %49

; <label>:49:                                     ; preds = %38
  %50 = shl i64 %23, 32
  %51 = ashr exact i64 %50, 32
  br label %52

; <label>:52:                                     ; preds = %72, %49
  %53 = phi i16 [ %46, %49 ], [ %80, %72 ]
  %54 = phi i8 [ %43, %49 ], [ %77, %72 ]
  %55 = phi i64 [ 0, %49 ], [ %75, %72 ]
  %56 = phi i8* [ %40, %49 ], [ %76, %72 ]
  %57 = and i16 %53, 2048
  %58 = icmp eq i16 %57, 0
  br i1 %58, label %62, label %59

; <label>:59:                                     ; preds = %52
  %60 = sext i8 %54 to i32
  %61 = add nsw i32 %60, -48
  br label %69

; <label>:62:                                     ; preds = %52
  %63 = zext i8 %54 to i64
  %64 = tail call i32** @__ctype_toupper_loc() #22
  %65 = load i32*, i32** %64, align 8, !tbaa !39
  %66 = getelementptr inbounds i32, i32* %65, i64 %63
  %67 = load i32, i32* %66, align 4, !tbaa !74
  %68 = add nsw i32 %67, -55
  br label %69

; <label>:69:                                     ; preds = %62, %59
  %70 = phi i32 [ %61, %59 ], [ %68, %62 ]
  %71 = icmp slt i32 %70, %30
  br i1 %71, label %72, label %89

; <label>:72:                                     ; preds = %69
  %73 = mul i64 %55, %51
  %74 = sext i32 %70 to i64
  %75 = add i64 %73, %74
  %76 = getelementptr inbounds i8, i8* %56, i64 1
  %77 = load i8, i8* %76, align 1, !tbaa !21
  %78 = zext i8 %77 to i64
  %79 = getelementptr inbounds i16, i16* %42, i64 %78
  %80 = load i16, i16* %79, align 2, !tbaa !317
  %81 = and i16 %80, 8
  %82 = icmp eq i16 %81, 0
  br i1 %82, label %83, label %52

; <label>:83:                                     ; preds = %72
  %84 = call i64 @strspn(i8* nonnull %76, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #21
  %85 = getelementptr inbounds i8, i8* %76, i64 %84
  %86 = icmp eq i32 %39, 0
  %87 = sub i64 0, %75
  %88 = select i1 %86, i64 %75, i64 %87
  br label %89

; <label>:89:                                     ; preds = %69, %38, %83
  %90 = phi i64 [ 0, %38 ], [ %88, %83 ], [ 0, %69 ]
  %91 = phi i8* [ null, %38 ], [ %85, %83 ], [ null, %69 ]
  %92 = load i64, i64* %3, align 8, !tbaa !135
  %93 = getelementptr inbounds i8, i8* %24, i64 %92
  %94 = icmp eq i8* %91, %93
  br i1 %94, label %95, label %103

; <label>:95:                                     ; preds = %89
  %96 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %97 = bitcast %union.StackValue** %96 to %struct.TValue**
  %98 = load %struct.TValue*, %struct.TValue** %97, align 8, !tbaa !20
  %99 = bitcast %struct.TValue* %98 to i64*
  store i64 %90, i64* %99, align 8, !tbaa !21
  %100 = getelementptr inbounds %struct.TValue, %struct.TValue* %98, i64 0, i32 1
  store i8 35, i8* %100, align 8, !tbaa !22
  %101 = load %union.StackValue*, %union.StackValue** %96, align 8, !tbaa !20
  %102 = getelementptr inbounds %union.StackValue, %union.StackValue* %101, i64 1
  store %union.StackValue* %102, %union.StackValue** %96, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %22) #7
  br label %111

; <label>:103:                                    ; preds = %89
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %22) #7
  br label %104

; <label>:104:                                    ; preds = %103, %19
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %106 = bitcast %union.StackValue** %105 to %struct.TValue**
  %107 = load %struct.TValue*, %struct.TValue** %106, align 8, !tbaa !20
  %108 = getelementptr inbounds %struct.TValue, %struct.TValue* %107, i64 0, i32 1
  store i8 0, i8* %108, align 8, !tbaa !21
  %109 = load %union.StackValue*, %union.StackValue** %105, align 8, !tbaa !20
  %110 = getelementptr inbounds %union.StackValue, %union.StackValue* %109, i64 1
  store %union.StackValue* %110, %union.StackValue** %105, align 8, !tbaa !20
  br label %111

; <label>:111:                                    ; preds = %95, %20, %104, %9
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_tostring(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i8* @luaL_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_type(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = add nsw i32 %2, 1
  %8 = sext i32 %7 to i64
  %9 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %8
  %10 = load i8*, i8** %9, align 8, !tbaa !39
  %11 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %10) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_xpcall(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 2, i32 6) #16
  %14 = bitcast %union.StackValue** %2 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = bitcast %struct.TValue* %15 to i32*
  store i32 1, i32* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 1, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 3, i32 2) #16
  %20 = add nsw i32 %13, -2
  %21 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %20, i32 -1, i32 2, i64 2, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall) #16
  %22 = tail call i32 @finishpcall(%struct.lua_State* %0, i32 %21, i64 2) #16
  ret i32 %22
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @pushmode(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 11
  %4 = select i1 %3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i64 0, i64 0)
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %4) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize readonly uwtable
define internal i32 @dofilecont(%struct.lua_State* nocapture readonly, i32, i64) #3 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !49
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !61
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, -1
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @ipairsaux(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %3 = add nsw i64 %2, 1
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to i64*
  store i64 %3, i64* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 35, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  %11 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3) #16
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, i32 1, i32 2
  ret i32 %13
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @load_aux(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %11

; <label>:5:                                      ; preds = %3
  %6 = icmp eq i32 %2, 0
  br i1 %6, label %18, label %7

; <label>:7:                                      ; preds = %5
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %2) #16
  %8 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 -2, i32 1) #16
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %18

; <label>:10:                                     ; preds = %7
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %18

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to %struct.TValue**
  %14 = load %struct.TValue*, %struct.TValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 0, i8* %15, align 8, !tbaa !21
  %16 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 1
  store %union.StackValue* %17, %union.StackValue** %12, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %18

; <label>:18:                                     ; preds = %10, %5, %7, %11
  %19 = phi i32 [ 2, %11 ], [ 1, %7 ], [ 1, %5 ], [ 1, %10 ]
  ret i32 %19
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i8* @generic_reader(%struct.lua_State*, i8* nocapture readnone, i64*) #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.337, i64 0, i64 0)) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %6, i32 1) #17
  %7 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %3
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  store i64 0, i64* %2, align 8, !tbaa !135
  br label %17

; <label>:10:                                     ; preds = %3
  %11 = tail call i32 @lua_isstring(%struct.lua_State* nonnull %0, i32 -1) #16
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %10
  %14 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.338, i64 0, i64 0)) #16
  unreachable

; <label>:15:                                     ; preds = %10
  tail call void @lua_copy(%struct.lua_State* nonnull %0, i32 -1, i32 5) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  %16 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 5, i64* %2) #16
  br label %17

; <label>:17:                                     ; preds = %15, %9
  %18 = phi i8* [ null, %9 ], [ %16, %15 ]
  ret i8* %18
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal i32 @finishpcall(%struct.lua_State* nocapture, i32, i64) #2 {
  %4 = icmp ugt i32 %1, 1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %4, label %6, label %13

; <label>:6:                                      ; preds = %3
  %7 = bitcast %union.StackValue** %5 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32*
  store i32 0, i32* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 1, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %5, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2) #16
  br label %27

; <label>:13:                                     ; preds = %3
  %14 = bitcast %union.StackValue** %5 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %17 = load %struct.CallInfo*, %struct.CallInfo** %16, align 8, !tbaa !49
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %17, i64 0, i32 0
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !61
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  %21 = ptrtoint %union.StackValue* %20 to i64
  %22 = sub i64 %15, %21
  %23 = lshr exact i64 %22, 4
  %24 = trunc i64 %23 to i32
  %25 = trunc i64 %2 to i32
  %26 = sub nsw i32 %24, %25
  br label %27

; <label>:27:                                     ; preds = %13, %6
  %28 = phi i32 [ 2, %6 ], [ %26, %13 ]
  ret i32 %28
}

; Function Attrs: minsize nounwind optsize
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize readnone
declare i16** @__ctype_b_loc() local_unnamed_addr #8

; Function Attrs: minsize nounwind optsize readnone
declare i32** @__ctype_toupper_loc() local_unnamed_addr #8

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_cocreate(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  %2 = tail call %struct.lua_State* @lua_newthread(%struct.lua_State* %0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* nonnull %2, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_coresume(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = add nsw i32 %14, -1
  %16 = tail call fastcc i32 @auxresume(%struct.lua_State* %0, %struct.lua_State* %2, i32 %15) #16
  %17 = icmp slt i32 %16, 0
  %18 = bitcast %union.StackValue** %3 to %struct.TValue**
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %19 to i32*
  br i1 %17, label %21, label %25

; <label>:21:                                     ; preds = %1
  store i32 0, i32* %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 1, i8* %22, align 8, !tbaa !22
  %23 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %3, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  br label %31

; <label>:25:                                     ; preds = %1
  store i32 1, i32* %20, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 1, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %3, align 8, !tbaa !20
  %29 = add nsw i32 %16, 1
  %30 = xor i32 %16, -1
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 %30, i32 1) #16
  br label %31

; <label>:31:                                     ; preds = %25, %21
  %32 = phi i32 [ 2, %21 ], [ %29, %25 ]
  ret i32 %32
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal i32 @luaB_corunning(%struct.lua_State*) #2 {
  %2 = tail call i32 @lua_pushthread(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %2, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret i32 2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_costatus(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @auxstatus(%struct.lua_State* %0, %struct.lua_State* %2) #16
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !39
  %7 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %6) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_cowrap(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaB_cocreate(%struct.lua_State* %0) #16
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @luaB_auxwrap, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_yield(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = tail call i32 @lua_yieldk(%struct.lua_State* %0, i32 %13, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_yieldable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = phi %struct.lua_State* [ %5, %4 ], [ %0, %1 ]
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 19
  %9 = load i32, i32* %8, align 8, !tbaa !54
  %10 = icmp ult i32 %9, 65536
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = zext i1 %10 to i32
  %15 = bitcast %struct.TValue* %13 to i32*
  store i32 %14, i32* %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 1, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %11, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_kill(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @auxstatus(%struct.lua_State* %0, %struct.lua_State* %2) #16
  %4 = add i32 %3, -1
  %5 = icmp ult i32 %4, 2
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @lua_resetthread(%struct.lua_State* %2) #16
  %8 = icmp eq i32 %7, 0
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = bitcast %struct.TValue* %11 to i32*
  br i1 %8, label %13, label %17

; <label>:13:                                     ; preds = %6
  store i32 1, i32* %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 1, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %9, align 8, !tbaa !20
  br label %26

; <label>:17:                                     ; preds = %6
  store i32 0, i32* %12, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 1, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %9, align 8, !tbaa !20
  tail call void @lua_xmove(%struct.lua_State* %2, %struct.lua_State* nonnull %0, i32 1) #16
  br label %26

; <label>:21:                                     ; preds = %1
  %22 = sext i32 %3 to i64
  %23 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %22
  %24 = load i8*, i8** %23, align 8, !tbaa !39
  %25 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.360, i64 0, i64 0), i8* %24) #16
  unreachable

; <label>:26:                                     ; preds = %17, %13
  %27 = phi i32 [ 1, %13 ], [ 2, %17 ]
  ret i32 %27
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct.lua_State* @getco(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq %struct.lua_State* %2, null
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i64 0, i64 0)) #16
  br label %6

; <label>:6:                                      ; preds = %1, %4
  ret %struct.lua_State* %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @auxresume(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.355, i64 0, i64 0)) #16
  br label %43

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 3
  %12 = load i8, i8* %11, align 2, !tbaa !57
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %30

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %16 = bitcast %union.StackValue** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !20
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 8
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !49
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 0
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !61
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  %23 = ptrtoint %union.StackValue* %22 to i64
  %24 = sub i64 %17, %23
  %25 = lshr exact i64 %24, 4
  %26 = trunc i64 %25 to i32
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %14
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0)) #16
  br label %43

; <label>:30:                                     ; preds = %14, %10
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* nonnull %1, i32 %2) #16
  %31 = call i32 @lua_resume(%struct.lua_State* nonnull %1, %struct.lua_State* %0, i32 %2, i32* nonnull %4) #16
  %32 = icmp ult i32 %31, 2
  br i1 %32, label %33, label %42

; <label>:33:                                     ; preds = %30
  %34 = load i32, i32* %4, align 4, !tbaa !74
  %35 = add nsw i32 %34, 1
  %36 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %35) #16
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %38, label %41

; <label>:38:                                     ; preds = %33
  %39 = xor i32 %34, -1
  tail call void @lua_settop(%struct.lua_State* nonnull %1, i32 %39) #16
  %40 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.356, i64 0, i64 0)) #16
  br label %43

; <label>:41:                                     ; preds = %33
  tail call void @lua_xmove(%struct.lua_State* nonnull %1, %struct.lua_State* %0, i32 %34) #16
  br label %43

; <label>:42:                                     ; preds = %30
  tail call void @lua_xmove(%struct.lua_State* nonnull %1, %struct.lua_State* %0, i32 1) #16
  br label %43

; <label>:43:                                     ; preds = %42, %41, %38, %28, %8
  %44 = phi i32 [ -1, %28 ], [ %34, %41 ], [ -1, %38 ], [ -1, %42 ], [ -1, %8 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  ret i32 %44
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @auxstatus(%struct.lua_State* readnone, %struct.lua_State* readonly) unnamed_addr #0 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 3
  %7 = load i8, i8* %6, align 2, !tbaa !57
  switch i8 %7, label %29 [
    i8 1, label %30
    i8 0, label %8
  ]

; <label>:8:                                      ; preds = %5
  %9 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %9) #7
  %10 = call i32 @lua_getstack(%struct.lua_State* nonnull %1, i32 0, %struct.lua_Debug* nonnull %3) #16
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %27

; <label>:12:                                     ; preds = %8
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 8
  %17 = load %struct.CallInfo*, %struct.CallInfo** %16, align 8, !tbaa !49
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %17, i64 0, i32 0
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !61
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  %21 = ptrtoint %union.StackValue* %20 to i64
  %22 = sub i64 %15, %21
  %23 = lshr exact i64 %22, 4
  %24 = trunc i64 %23 to i32
  %25 = icmp eq i32 %24, 0
  %26 = select i1 %25, i32 1, i32 2
  br label %27

; <label>:27:                                     ; preds = %12, %8
  %28 = phi i32 [ 3, %8 ], [ %26, %12 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %9) #7
  br label %30

; <label>:29:                                     ; preds = %5
  br label %30

; <label>:30:                                     ; preds = %5, %2, %29, %27
  %31 = phi i32 [ 1, %29 ], [ %28, %27 ], [ 0, %2 ], [ 2, %5 ]
  ret i32 %31
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @luaB_auxwrap(%struct.lua_State*) #0 {
  %2 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 -1001001) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = tail call fastcc i32 @auxresume(%struct.lua_State* %0, %struct.lua_State* %2, i32 %14) #16
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %17, label %31

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 3
  %19 = load i8, i8* %18, align 2, !tbaa !57
  %20 = icmp ugt i8 %19, 1
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %17
  %22 = tail call i32 @lua_resetthread(%struct.lua_State* nonnull %2) #16
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %21
  tail call void @lua_xmove(%struct.lua_State* nonnull %2, %struct.lua_State* nonnull %0, i32 1) #16
  br label %25

; <label>:25:                                     ; preds = %21, %24, %17
  %26 = tail call i32 @lua_type(%struct.lua_State* nonnull %0, i32 -1) #16
  %27 = icmp eq i32 %26, 4
  br i1 %27, label %28, label %29

; <label>:28:                                     ; preds = %25
  tail call void @luaL_where(%struct.lua_State* nonnull %0, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  tail call void @lua_concat(%struct.lua_State* nonnull %0, i32 2) #16
  br label %29

; <label>:29:                                     ; preds = %28, %25
  %30 = tail call i32 @lua_error(%struct.lua_State* nonnull %0) #16
  unreachable

; <label>:31:                                     ; preds = %1
  ret i32 %15
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_debug(%struct.lua_State*) #0 {
  %2 = alloca [250 x i8], align 16
  %3 = getelementptr inbounds [250 x i8], [250 x i8]* %2, i64 0, i64 0
  br label %4

; <label>:4:                                      ; preds = %28, %1
  call void @llvm.lifetime.start.p0i8(i64 250, i8* nonnull %3) #7
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %6 = call i32 @fputs(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.375, i64 0, i64 0), %struct._IO_FILE* %5) #24
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %8 = call i32 @fflush(%struct._IO_FILE* %7) #16
  %9 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !39
  %10 = call i8* @fgets(i8* nonnull %3, i32 250, %struct._IO_FILE* %9) #16
  %11 = icmp eq i8* %10, null
  br i1 %11, label %29, label %12

; <label>:12:                                     ; preds = %4
  %13 = call i32 @strcmp(i8* nonnull %3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.376, i64 0, i64 0)) #21
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %29, label %15

; <label>:15:                                     ; preds = %12
  %16 = call i64 @strlen(i8* nonnull %3) #21
  %17 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %3, i64 %16, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.377, i64 0, i64 0), i8* null) #16
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %22

; <label>:19:                                     ; preds = %15
  %20 = call i32 @lua_pcallk(%struct.lua_State* %0, i32 0, i32 0, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %28, label %22

; <label>:22:                                     ; preds = %19, %15
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %24 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %25 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %23, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %24) #23
  %26 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !39
  %27 = call i32 @fflush(%struct._IO_FILE* %26) #16
  br label %28

; <label>:28:                                     ; preds = %19, %22
  call void @lua_settop(%struct.lua_State* %0, i32 0) #16
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %3) #7
  br label %4

; <label>:29:                                     ; preds = %4, %12
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %3) #7
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_getuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %4 = icmp eq i32 %3, 7
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  br label %18

; <label>:9:                                      ; preds = %1
  %10 = trunc i64 %2 to i32
  %11 = tail call i32 @lua_getiuservalue(%struct.lua_State* %0, i32 1, i32 %10) #16
  %12 = icmp eq i32 %11, -1
  br i1 %12, label %26, label %13

; <label>:13:                                     ; preds = %9
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = bitcast %struct.TValue* %16 to i32*
  store i32 1, i32* %17, align 8, !tbaa !21
  br label %18

; <label>:18:                                     ; preds = %13, %5
  %19 = phi %struct.TValue* [ %8, %5 ], [ %16, %13 ]
  %20 = phi i8 [ 0, %5 ], [ 1, %13 ]
  %21 = phi %union.StackValue** [ %6, %5 ], [ %14, %13 ]
  %22 = phi i32 [ 1, %5 ], [ 2, %13 ]
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %20, i8* %23, align 8, !tbaa !21
  %24 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %21, align 8, !tbaa !20
  br label %26

; <label>:26:                                     ; preds = %18, %9
  %27 = phi i32 [ 1, %9 ], [ %22, %18 ]
  ret i32 %27
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_gethook(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca [5 x i8], align 1
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2) #16
  %6 = getelementptr inbounds [5 x i8], [5 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 5, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 23
  %8 = load i32, i32* %7, align 8, !tbaa !23
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 17
  %10 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %9, align 8, !tbaa !25
  %11 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %10, null
  br i1 %11, label %12, label %19

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 0, i8* %16, align 8, !tbaa !21
  %17 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %13, align 8, !tbaa !20
  br label %27

; <label>:19:                                     ; preds = %1
  %20 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %10, @hookf
  br i1 %20, label %23, label %21

; <label>:21:                                     ; preds = %19
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.378, i64 0, i64 0)) #16
  br label %27

; <label>:23:                                     ; preds = %19
  %24 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1) #16
  %25 = tail call i32 @lua_pushthread(%struct.lua_State* %5) #16
  tail call void @lua_xmove(%struct.lua_State* %5, %struct.lua_State* %0, i32 1) #16
  %26 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %27

; <label>:27:                                     ; preds = %21, %23, %12
  %28 = and i32 %8, 1
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %31, label %30

; <label>:30:                                     ; preds = %27
  store i8 99, i8* %6, align 1, !tbaa !21
  br label %31

; <label>:31:                                     ; preds = %30, %27
  %32 = phi i32 [ 1, %30 ], [ 0, %27 ]
  %33 = and i32 %8, 2
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %39, label %35

; <label>:35:                                     ; preds = %31
  %36 = add nuw nsw i32 %32, 1
  %37 = zext i32 %32 to i64
  %38 = getelementptr inbounds [5 x i8], [5 x i8]* %3, i64 0, i64 %37
  store i8 114, i8* %38, align 1, !tbaa !21
  br label %39

; <label>:39:                                     ; preds = %35, %31
  %40 = phi i32 [ %36, %35 ], [ %32, %31 ]
  %41 = and i32 %8, 4
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %47, label %43

; <label>:43:                                     ; preds = %39
  %44 = add nsw i32 %40, 1
  %45 = sext i32 %40 to i64
  %46 = getelementptr inbounds [5 x i8], [5 x i8]* %3, i64 0, i64 %45
  store i8 108, i8* %46, align 1, !tbaa !21
  br label %47

; <label>:47:                                     ; preds = %39, %43
  %48 = phi i32 [ %44, %43 ], [ %40, %39 ]
  %49 = sext i32 %48 to i64
  %50 = getelementptr inbounds [5 x i8], [5 x i8]* %3, i64 0, i64 %49
  store i8 0, i8* %50, align 1, !tbaa !21
  %51 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %6) #16
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 21
  %53 = load i32, i32* %52, align 8, !tbaa !24
  %54 = sext i32 %53 to i64
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %56 = bitcast %union.StackValue** %55 to %struct.TValue**
  %57 = load %struct.TValue*, %struct.TValue** %56, align 8, !tbaa !20
  %58 = bitcast %struct.TValue* %57 to i64*
  store i64 %54, i64* %58, align 8, !tbaa !21
  %59 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 0, i32 1
  store i8 35, i8* %59, align 8, !tbaa !22
  %60 = load %union.StackValue*, %union.StackValue** %55, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %60, i64 1
  store %union.StackValue* %61, %union.StackValue** %55, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 5, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_getinfo(%struct.lua_State*) #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = alloca i32, align 4
  %4 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %4) #7
  %5 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %3) #16
  %7 = load i32, i32* %3, align 4, !tbaa !74
  %8 = add nsw i32 %7, 2
  %9 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.381, i64 0, i64 0), i64* null) #16
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %6, i32 3) #16
  %10 = add nsw i32 %7, 1
  %11 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %10) #16
  %12 = icmp eq i32 %11, 6
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %1
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.382, i64 0, i64 0), i8* %9) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %10) #16
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* %6, i32 1) #16
  br label %27

; <label>:15:                                     ; preds = %1
  %16 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %10) #16
  %17 = trunc i64 %16 to i32
  %18 = call i32 @lua_getstack(%struct.lua_State* %6, i32 %17, %struct.lua_Debug* nonnull %2) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %27

; <label>:20:                                     ; preds = %15
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to %struct.TValue**
  %23 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !20
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  store i8 0, i8* %24, align 8, !tbaa !21
  %25 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %21, align 8, !tbaa !20
  br label %101

; <label>:27:                                     ; preds = %15, %13
  %28 = phi i8* [ %14, %13 ], [ %9, %15 ]
  %29 = call i32 @lua_getinfo(%struct.lua_State* %6, i8* %28, %struct.lua_Debug* nonnull %2) #16
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %31, label %33

; <label>:31:                                     ; preds = %27
  %32 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.383, i64 0, i64 0)) #16
  br label %101

; <label>:33:                                     ; preds = %27
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0) #16
  %34 = tail call i8* @strchr(i8* %28, i32 83) #21
  %35 = icmp eq i8* %34, null
  br i1 %35, label %49, label %36

; <label>:36:                                     ; preds = %33
  %37 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 4
  %38 = load i8*, i8** %37, align 8, !tbaa !104
  %39 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 5
  %40 = load i64, i64* %39, align 8, !tbaa !105
  %41 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %38, i64 %40) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.384, i64 0, i64 0)) #16
  %42 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 15, i64 0
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.385, i64 0, i64 0), i8* nonnull %42) #16
  %43 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 7
  %44 = load i32, i32* %43, align 4, !tbaa !106
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.386, i64 0, i64 0), i32 %44) #16
  %45 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 8
  %46 = load i32, i32* %45, align 8, !tbaa !107
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.387, i64 0, i64 0), i32 %46) #16
  %47 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 3
  %48 = load i8*, i8** %47, align 8, !tbaa !112
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.388, i64 0, i64 0), i8* %48) #16
  br label %49

; <label>:49:                                     ; preds = %33, %36
  %50 = call i8* @strchr(i8* %28, i32 108) #21
  %51 = icmp eq i8* %50, null
  br i1 %51, label %55, label %52

; <label>:52:                                     ; preds = %49
  %53 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %54 = load i32, i32* %53, align 8, !tbaa !113
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.389, i64 0, i64 0), i32 %54) #16
  br label %55

; <label>:55:                                     ; preds = %49, %52
  %56 = call i8* @strchr(i8* %28, i32 117) #21
  %57 = icmp eq i8* %56, null
  br i1 %57, label %68, label %58

; <label>:58:                                     ; preds = %55
  %59 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %60 = load i8, i8* %59, align 4, !tbaa !114
  %61 = zext i8 %60 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.390, i64 0, i64 0), i32 %61) #16
  %62 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %63 = load i8, i8* %62, align 1, !tbaa !116
  %64 = zext i8 %63 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.391, i64 0, i64 0), i32 %64) #16
  %65 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %66 = load i8, i8* %65, align 2, !tbaa !115
  %67 = sext i8 %66 to i32
  call fastcc void @settabsb(%struct.lua_State* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.392, i64 0, i64 0), i32 %67) #16
  br label %68

; <label>:68:                                     ; preds = %55, %58
  %69 = call i8* @strchr(i8* %28, i32 110) #21
  %70 = icmp eq i8* %69, null
  br i1 %70, label %76, label %71

; <label>:71:                                     ; preds = %68
  %72 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %73 = load i8*, i8** %72, align 8, !tbaa !197
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.393, i64 0, i64 0), i8* %73) #16
  %74 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %75 = load i8*, i8** %74, align 8, !tbaa !120
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.394, i64 0, i64 0), i8* %75) #16
  br label %76

; <label>:76:                                     ; preds = %68, %71
  %77 = call i8* @strchr(i8* %28, i32 114) #21
  %78 = icmp eq i8* %77, null
  br i1 %78, label %86, label %79

; <label>:79:                                     ; preds = %76
  %80 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %81 = load i16, i16* %80, align 8, !tbaa !122
  %82 = zext i16 %81 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.395, i64 0, i64 0), i32 %82) #16
  %83 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %84 = load i16, i16* %83, align 2, !tbaa !121
  %85 = zext i16 %84 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.396, i64 0, i64 0), i32 %85) #16
  br label %86

; <label>:86:                                     ; preds = %76, %79
  %87 = call i8* @strchr(i8* %28, i32 116) #21
  %88 = icmp eq i8* %87, null
  br i1 %88, label %93, label %89

; <label>:89:                                     ; preds = %86
  %90 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %91 = load i8, i8* %90, align 1, !tbaa !118
  %92 = sext i8 %91 to i32
  call fastcc void @settabsb(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.397, i64 0, i64 0), i32 %92) #16
  br label %93

; <label>:93:                                     ; preds = %86, %89
  %94 = call i8* @strchr(i8* %28, i32 76) #21
  %95 = icmp eq i8* %94, null
  br i1 %95, label %97, label %96

; <label>:96:                                     ; preds = %93
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %6, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.398, i64 0, i64 0)) #16
  br label %97

; <label>:97:                                     ; preds = %93, %96
  %98 = call i8* @strchr(i8* %28, i32 102) #21
  %99 = icmp eq i8* %98, null
  br i1 %99, label %101, label %100

; <label>:100:                                    ; preds = %97
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.399, i64 0, i64 0)) #16
  br label %101

; <label>:101:                                    ; preds = %100, %97, %31, %20
  %102 = phi i32 [ %32, %31 ], [ 1, %20 ], [ 1, %97 ], [ 1, %100 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %4) #7
  ret i32 %102
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_getlocal(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2) #16
  %6 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = load i32, i32* %2, align 4, !tbaa !74
  %8 = add nsw i32 %7, 2
  %9 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %8) #16
  %10 = trunc i64 %9 to i32
  %11 = add nsw i32 %7, 1
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %11) #16
  %13 = icmp eq i32 %12, 6
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %11) #16
  %15 = tail call i8* @lua_getlocal(%struct.lua_State* %0, %struct.lua_Debug* null, i32 %10) #16
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %15) #16
  br label %36

; <label>:17:                                     ; preds = %1
  %18 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %11) #16
  %19 = trunc i64 %18 to i32
  %20 = call i32 @lua_getstack(%struct.lua_State* %5, i32 %19, %struct.lua_Debug* nonnull %3) #16
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %17
  %23 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %11, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0)) #16
  br label %36

; <label>:24:                                     ; preds = %17
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1) #16
  %25 = call i8* @lua_getlocal(%struct.lua_State* %5, %struct.lua_Debug* nonnull %3, i32 %10) #16
  %26 = icmp eq i8* %25, null
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  call void @lua_xmove(%struct.lua_State* %5, %struct.lua_State* %0, i32 1) #16
  %28 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %25) #16
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %36

; <label>:29:                                     ; preds = %24
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = bitcast %union.StackValue** %30 to %struct.TValue**
  %32 = load %struct.TValue*, %struct.TValue** %31, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  store i8 0, i8* %33, align 8, !tbaa !21
  %34 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %30, align 8, !tbaa !20
  br label %36

; <label>:36:                                     ; preds = %22, %27, %29, %14
  %37 = phi i32 [ 1, %14 ], [ 2, %27 ], [ 1, %29 ], [ %23, %22 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 %37
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal i32 @db_getregistry(%struct.lua_State* nocapture) #2 {
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1001000) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %1, %4
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_getupvalue(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_upvaluejoin(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 3, i32 4) #16
  %4 = tail call i32 @lua_iscfunction(%struct.lua_State* %0, i32 1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0)) #16
  br label %8

; <label>:8:                                      ; preds = %1, %6
  %9 = tail call i32 @lua_iscfunction(%struct.lua_State* %0, i32 3) #16
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0)) #16
  br label %13

; <label>:13:                                     ; preds = %8, %11
  tail call void @lua_upvaluejoin(%struct.lua_State* %0, i32 1, i32 %2, i32 3, i32 %3) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_upvalueid(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = tail call i8* @lua_upvalueid(%struct.lua_State* %0, i32 1, i32 %2) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to i8**
  store i8* %3, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_setuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %3 = trunc i64 %2 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 7) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %4 = tail call i32 @lua_setiuservalue(%struct.lua_State* %0, i32 1, i32 %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %13

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %10, align 8, !tbaa !21
  %11 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %7, align 8, !tbaa !20
  br label %13

; <label>:13:                                     ; preds = %1, %6
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_sethook(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2) #16
  %5 = load i32, i32* %2, align 4, !tbaa !74
  %6 = add nsw i32 %5, 1
  %7 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %6) #16
  %8 = icmp slt i32 %7, 1
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %6) #16
  br label %30

; <label>:10:                                     ; preds = %1
  %11 = add nsw i32 %5, 2
  %12 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %11, i64* null) #16
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %6, i32 6) #16
  %13 = add nsw i32 %5, 3
  %14 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 %13, i64 0) #16
  %15 = trunc i64 %14 to i32
  %16 = tail call i8* @strchr(i8* %12, i32 99) #21
  %17 = icmp ne i8* %16, null
  %18 = zext i1 %17 to i32
  %19 = tail call i8* @strchr(i8* %12, i32 114) #21
  %20 = icmp eq i8* %19, null
  %21 = or i32 %18, 2
  %22 = select i1 %20, i32 %18, i32 %21
  %23 = tail call i8* @strchr(i8* %12, i32 108) #21
  %24 = icmp eq i8* %23, null
  %25 = or i32 %22, 4
  %26 = select i1 %24, i32 %22, i32 %25
  %27 = icmp sgt i32 %15, 0
  %28 = or i32 %26, 8
  %29 = select i1 %27, i32 %28, i32 %26
  br label %30

; <label>:30:                                     ; preds = %10, %9
  %31 = phi void (%struct.lua_State*, %struct.lua_Debug*)* [ null, %9 ], [ @hookf, %10 ]
  %32 = phi i32 [ 0, %9 ], [ %15, %10 ]
  %33 = phi i32 [ 0, %9 ], [ %29, %10 ]
  %34 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %30
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 2) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_rawsetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %37 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.403, i64 0, i64 0)) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i64 0, i64 0)) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  %38 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #16
  br label %39

; <label>:39:                                     ; preds = %36, %30
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %4, i32 1) #16
  %40 = tail call i32 @lua_pushthread(%struct.lua_State* %4) #16
  tail call void @lua_xmove(%struct.lua_State* %4, %struct.lua_State* %0, i32 1) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %6) #16
  tail call void @lua_rawset(%struct.lua_State* %0, i32 -3) #16
  tail call void @lua_sethook(%struct.lua_State* %4, void (%struct.lua_State*, %struct.lua_Debug*)* %31, i32 %33, i32 %32) #16
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_setlocal(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2) #16
  %6 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = load i32, i32* %2, align 4, !tbaa !74
  %8 = add nsw i32 %7, 1
  %9 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %8) #16
  %10 = trunc i64 %9 to i32
  %11 = add nsw i32 %7, 2
  %12 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %11) #16
  %13 = call i32 @lua_getstack(%struct.lua_State* %5, i32 %10, %struct.lua_Debug* nonnull %3) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %17

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0)) #16
  br label %25

; <label>:17:                                     ; preds = %1
  %18 = trunc i64 %12 to i32
  %19 = add nsw i32 %7, 3
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 %19) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 %19) #16
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1) #16
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* %5, i32 1) #16
  %20 = call i8* @lua_setlocal(%struct.lua_State* %5, %struct.lua_Debug* nonnull %3, i32 %18) #16
  %21 = icmp eq i8* %20, null
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call void @lua_settop(%struct.lua_State* %5, i32 -2) #16
  br label %23

; <label>:23:                                     ; preds = %22, %17
  %24 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %20) #16
  br label %25

; <label>:25:                                     ; preds = %23, %15
  %26 = phi i32 [ 1, %23 ], [ %16, %15 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 %26
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_setmetatable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %1
  %4 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0)) #16
  br label %5

; <label>:5:                                      ; preds = %1, %1, %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %6 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_setupvalue(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3) #16
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @db_traceback(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2) #16
  %5 = load i32, i32* %2, align 4, !tbaa !74
  %6 = add nsw i32 %5, 1
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %6, i64* null) #16
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %1
  %10 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %6) #16
  %11 = icmp slt i32 %10, 1
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %6) #16
  br label %19

; <label>:13:                                     ; preds = %9, %1
  %14 = add nsw i32 %5, 2
  %15 = icmp eq %struct.lua_State* %4, %0
  %16 = zext i1 %15 to i64
  %17 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 %14, i64 %16) #16
  %18 = trunc i64 %17 to i32
  tail call void @luaL_traceback(%struct.lua_State* %0, %struct.lua_State* %4, i8* %7, i32 %18) #16
  br label %19

; <label>:19:                                     ; preds = %13, %12
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize
declare i8* @fgets(i8*, i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc %struct.lua_State* @getthread(%struct.lua_State* readonly, i32* nocapture) unnamed_addr #2 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %4 = icmp eq i32 %3, 8
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  store i32 1, i32* %1, align 4, !tbaa !74
  %6 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1) #16
  br label %8

; <label>:7:                                      ; preds = %2
  store i32 0, i32* %1, align 4, !tbaa !74
  br label %8

; <label>:8:                                      ; preds = %7, %5
  %9 = phi %struct.lua_State* [ %6, %5 ], [ %0, %7 ]
  ret %struct.lua_State* %9
}

; Function Attrs: minsize nounwind optsize uwtable
define internal void @hookf(%struct.lua_State*, %struct.lua_Debug* nocapture readonly) #0 {
  %3 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %4 = tail call i32 @lua_pushthread(%struct.lua_State* %0) #16
  %5 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #16
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %35

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !240
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds [5 x i8*], [5 x i8*]* @hookf.hooknames, i64 0, i64 %10
  %12 = load i8*, i8** %11, align 8, !tbaa !39
  %13 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %12) #16
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 6
  %15 = load i32, i32* %14, align 8, !tbaa !113
  %16 = icmp sgt i32 %15, -1
  br i1 %16, label %17, label %23

; <label>:17:                                     ; preds = %7
  %18 = sext i32 %15 to i64
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = bitcast %union.StackValue** %19 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = bitcast %struct.TValue* %21 to i64*
  store i64 %18, i64* %22, align 8, !tbaa !21
  br label %27

; <label>:23:                                     ; preds = %7
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %25 = bitcast %union.StackValue** %24 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  br label %27

; <label>:27:                                     ; preds = %23, %17
  %28 = phi %struct.TValue* [ %26, %23 ], [ %21, %17 ]
  %29 = phi i8 [ 0, %23 ], [ 35, %17 ]
  %30 = phi %union.StackValue** [ %24, %23 ], [ %19, %17 ]
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %29, i8* %31, align 8, !tbaa !21
  %32 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 1
  store %union.StackValue* %33, %union.StackValue** %30, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %34, i32 0) #17
  br label %35

; <label>:35:                                     ; preds = %27, %2
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checkstack(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #16
  unreachable

; <label>:10:                                     ; preds = %5, %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @settabss(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2) #16
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @settabsi(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = sext i32 %2 to i64
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to i64*
  store i64 %4, i64* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 35, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @settabsb(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = icmp ne i32 %2, 0
  %8 = zext i1 %7 to i32
  %9 = bitcast %struct.TValue* %6 to i32*
  store i32 %8, i32* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 1, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %4, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @treatstackoption(%struct.lua_State*, %struct.lua_State*, i8*) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %3
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %7

; <label>:6:                                      ; preds = %3
  tail call void @lua_xmove(%struct.lua_State* %1, %struct.lua_State* %0, i32 1) #16
  br label %7

; <label>:7:                                      ; preds = %6, %5
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @auxupvalue(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %4 = trunc i64 %3 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  %5 = icmp eq i32 %1, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %2
  %7 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 1, i32 %4) #16
  br label %10

; <label>:8:                                      ; preds = %2
  %9 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 1, i32 %4) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  %12 = icmp eq i8* %11, null
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %10
  %14 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11) #16
  %15 = add nsw i32 %1, 1
  %16 = xor i32 %1, -1
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 1) #16
  br label %17

; <label>:17:                                     ; preds = %10, %13
  %18 = phi i32 [ %15, %13 ], [ 0, %10 ]
  ret i32 %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @checkupval(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %2) #16
  %5 = trunc i64 %4 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 6) #16
  %6 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 %1, i32 %5) #16
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.402, i64 0, i64 0)) #16
  br label %10

; <label>:10:                                     ; preds = %3, %8
  ret i32 %5
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_close(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #16
  br label %6

; <label>:6:                                      ; preds = %4, %1
  %7 = tail call i32 @f_close(%struct.lua_State* %0) #16
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #16
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2) #16
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null) #16
  ret i32 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_input(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_lines(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %4, %1
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %11
  %15 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0)) #16
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %16 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 0) #16
  br label %28

; <label>:17:                                     ; preds = %11
  %18 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  tail call fastcc void @opencheck(%struct.lua_State* %0, i8* %18, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 1) #16
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = bitcast %union.StackValue** %19 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  store i8 0, i8* %22, align 8, !tbaa !21
  %23 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %19, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1, i32 0, i32 1
  store i8 0, i8* %25, align 8, !tbaa !21
  %26 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 1
  store %union.StackValue* %27, %union.StackValue** %19, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  br label %28

; <label>:28:                                     ; preds = %14, %17
  %29 = phi i32 [ 4, %17 ], [ 1, %14 ]
  ret i32 %29
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_open(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null) #16
  %4 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0) #16
  %5 = load i8, i8* %3, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %20, label %7

; <label>:7:                                      ; preds = %1
  %8 = sext i8 %5 to i32
  %9 = getelementptr inbounds i8, i8* %3, i64 1
  %10 = tail call i8* @memchr(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.422, i64 0, i64 0), i32 %8, i64 4) #7
  %11 = icmp eq i8* %10, null
  br i1 %11, label %20, label %12

; <label>:12:                                     ; preds = %7
  %13 = load i8, i8* %9, align 1, !tbaa !21
  %14 = icmp eq i8 %13, 43
  %15 = getelementptr inbounds i8, i8* %3, i64 2
  %16 = select i1 %14, i8* %15, i8* %9
  %17 = tail call i64 @strspn(i8* nonnull %16, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.423, i64 0, i64 0)) #21
  %18 = tail call i64 @strlen(i8* nonnull %16) #21
  %19 = icmp eq i64 %17, %18
  br i1 %19, label %22, label %20

; <label>:20:                                     ; preds = %12, %1, %7
  %21 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.421, i64 0, i64 0)) #16
  br label %22

; <label>:22:                                     ; preds = %12, %20
  %23 = tail call %struct._IO_FILE* @fopen64(i8* %2, i8* %3) #16
  %24 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %4, i64 0, i32 0
  store %struct._IO_FILE* %23, %struct._IO_FILE** %24, align 8, !tbaa !212
  %25 = icmp eq %struct._IO_FILE* %23, null
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %22
  %27 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* %2) #16
  br label %28

; <label>:28:                                     ; preds = %22, %26
  %29 = phi i32 [ %27, %26 ], [ 1, %22 ]
  ret i32 %29
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_output(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.424, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal i32 @io_popen(%struct.lua_State*) #5 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null) #16
  %4 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0) #16
  %5 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.425, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0)) #16
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1) #16
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_tmpfile(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0) #16
  %3 = tail call %struct._IO_FILE* @tmpfile64() #16
  %4 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 0
  store %struct._IO_FILE* %3, %struct._IO_FILE** %4, align 8, !tbaa !212
  %5 = icmp eq %struct._IO_FILE* %3, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %8

; <label>:8:                                      ; preds = %1, %6
  %9 = phi i32 [ %7, %6 ], [ 1, %1 ]
  ret i32 %9
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_type(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %20

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds i8, i8* %2, i64 8
  %13 = bitcast i8* %12 to i32 (%struct.lua_State*)**
  %14 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !214
  %15 = icmp eq i32 (%struct.lua_State*)* %14, null
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %11
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.426, i64 0, i64 0)) #16
  br label %20

; <label>:18:                                     ; preds = %11
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.427, i64 0, i64 0)) #16
  br label %20

; <label>:20:                                     ; preds = %16, %18, %4
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #16
  %3 = tail call fastcc i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1) #16
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_close(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @aux_close(%struct.lua_State* %0) #16
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct._IO_FILE* @tofile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !214
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.412, i64 0, i64 0)) #16
  unreachable

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !212
  ret %struct._IO_FILE* %11
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @aux_close(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4)
  %5 = getelementptr inbounds i8, i8* %3, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = bitcast i8* %5 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !214
  store volatile i64 %8, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %6, align 8, !tbaa !214
  %9 = load volatile i64, i64* %2, align 8
  %10 = inttoptr i64 %9 to i32 (%struct.lua_State*)*
  %11 = tail call i32 %10(%struct.lua_State* %0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4)
  ret i32 %11
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc %struct._IO_FILE* @getiofile(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1) #16
  %5 = getelementptr inbounds i8, i8* %4, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %6, align 8, !tbaa !214
  %8 = icmp eq i32 (%struct.lua_State*)* %7, null
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds i8, i8* %1, i64 4
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.413, i64 0, i64 0), i8* nonnull %10) #16
  unreachable

; <label>:12:                                     ; preds = %2
  %13 = bitcast i8* %4 to %struct._IO_FILE**
  %14 = load %struct._IO_FILE*, %struct._IO_FILE** %13, align 8, !tbaa !212
  ret %struct._IO_FILE* %14
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @g_iofile(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %8 = icmp eq i8* %7, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %6
  tail call fastcc void @opencheck(%struct.lua_State* %0, i8* nonnull %7, i8* %2) #16
  br label %12

; <label>:10:                                     ; preds = %6
  %11 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  br label %12

; <label>:12:                                     ; preds = %10, %9
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  br label %13

; <label>:13:                                     ; preds = %12, %3
  %14 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @opencheck(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0) #16
  %5 = tail call %struct._IO_FILE* @fopen64(i8* %1, i8* %2) #16
  %6 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %4, i64 0, i32 0
  store %struct._IO_FILE* %5, %struct._IO_FILE** %6, align 8, !tbaa !212
  %7 = icmp eq %struct._IO_FILE* %5, null
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %3
  %9 = tail call i32* @__errno_location() #22
  %10 = load i32, i32* %9, align 4, !tbaa !74
  %11 = tail call i8* @strerror(i32 %10) #17
  %12 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.414, i64 0, i64 0), i8* %1, i8* %11) #16
  unreachable

; <label>:13:                                     ; preds = %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc nonnull %struct.luaL_Stream* @newfile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 0
  store %struct._IO_FILE* null, %struct._IO_FILE** %3, align 8, !tbaa !212
  %4 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 1
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !214
  ret %struct.luaL_Stream* %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc nonnull %struct.luaL_Stream* @newprefile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #16
  %3 = bitcast i8* %2 to %struct.luaL_Stream*
  %4 = getelementptr inbounds i8, i8* %2, i64 8
  %5 = bitcast i8* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %5, align 8, !tbaa !214
  tail call void @luaL_setmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  ret %struct.luaL_Stream* %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_fclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = bitcast i8* %2 to %struct._IO_FILE**
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** %3, align 8, !tbaa !212
  %5 = tail call i32 @fclose(%struct._IO_FILE* %4) #16
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  %8 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %7, i8* null) #16
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @aux_lines(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = icmp slt i32 %14, 252
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %2
  %17 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 252, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  br label %18

; <label>:18:                                     ; preds = %16, %2
  tail call void @lua_pushvalue(%struct.lua_State* nonnull %0, i32 1) #16
  %19 = shl i64 %12, 28
  %20 = add i64 %19, -4294967296
  %21 = ashr exact i64 %20, 32
  %22 = bitcast %union.StackValue** %3 to %struct.TValue**
  %23 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !20
  %24 = bitcast %struct.TValue* %23 to i64*
  store i64 %21, i64* %24, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  store i8 35, i8* %25, align 8, !tbaa !22
  %26 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 1
  store %union.StackValue* %27, %union.StackValue** %3, align 8, !tbaa !20
  %28 = icmp ne i32 %1, 0
  %29 = zext i1 %28 to i32
  %30 = bitcast %union.StackValue* %27 to i32*
  store i32 %29, i32* %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 1, i32 0, i32 1
  store i8 1, i8* %31, align 8, !tbaa !22
  %32 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 1
  store %union.StackValue* %33, %union.StackValue** %3, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 2, i32 3) #16
  %34 = add nsw i32 %14, 2
  tail call void @lua_pushcclosure(%struct.lua_State* nonnull %0, i32 (%struct.lua_State*)* nonnull @io_readline, i32 %34) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_readline(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %3 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1001002, i32* null) #16
  %4 = trunc i64 %3 to i32
  %5 = getelementptr inbounds i8, i8* %2, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %6, align 8, !tbaa !214
  %8 = icmp eq i32 (%struct.lua_State*)* %7, null
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %1
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.416, i64 0, i64 0)) #16
  unreachable

; <label>:11:                                     ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  br label %12

; <label>:12:                                     ; preds = %15, %11
  %13 = phi i32 [ 1, %11 ], [ %17, %15 ]
  %14 = icmp sgt i32 %13, %4
  br i1 %14, label %18, label %15

; <label>:15:                                     ; preds = %12
  %16 = sub nuw i32 -1001003, %13
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %16) #16
  %17 = add nuw nsw i32 %13, 1
  br label %12

; <label>:18:                                     ; preds = %12
  %19 = bitcast i8* %2 to %struct._IO_FILE**
  %20 = load %struct._IO_FILE*, %struct._IO_FILE** %19, align 8, !tbaa !212
  %21 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %20, i32 2) #16
  %22 = sub nsw i32 0, %21
  %23 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 %22) #16
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %36

; <label>:25:                                     ; preds = %18
  %26 = icmp sgt i32 %21, 1
  br i1 %26, label %27, label %31

; <label>:27:                                     ; preds = %25
  %28 = sub i32 1, %21
  %29 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %28, i64* null) #16
  %30 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* %29) #16
  unreachable

; <label>:31:                                     ; preds = %25
  %32 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1001003) #16
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %31
  tail call void @lua_settop(%struct.lua_State* %0, i32 0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1001001) #16
  %35 = tail call fastcc i32 @aux_close(%struct.lua_State* %0) #16
  br label %36

; <label>:36:                                     ; preds = %34, %31, %18
  %37 = phi i32 [ %21, %18 ], [ 0, %31 ], [ 0, %34 ]
  ret i32 %37
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @g_read(%struct.lua_State*, %struct._IO_FILE*, i32) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = alloca %struct.RN, align 8
  %6 = alloca [2 x i8], align 1
  %7 = alloca %struct.luaL_Buffer, align 8
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, -1
  tail call void @clearerr(%struct._IO_FILE* %1) #17
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %25

; <label>:22:                                     ; preds = %3
  %23 = tail call fastcc i32 @read_line(%struct.lua_State* nonnull %0, %struct._IO_FILE* %1, i32 1) #16
  %24 = add nsw i32 %2, 1
  br label %162

; <label>:25:                                     ; preds = %3
  %26 = add nsw i32 %19, 19
  tail call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 %26, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  %27 = bitcast %struct.luaL_Buffer* %7 to i8*
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 3
  %29 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 4
  %30 = bitcast %struct.luaL_Buffer* %7 to %union.anon.6**
  %31 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 2
  %32 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 1
  %33 = bitcast %struct.RN* %5 to i8*
  %34 = getelementptr inbounds [2 x i8], [2 x i8]* %6, i64 0, i64 0
  %35 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 0
  %36 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 2
  %37 = getelementptr inbounds [2 x i8], [2 x i8]* %6, i64 0, i64 1
  %38 = bitcast %struct.luaL_Buffer* %4 to i8*
  %39 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 3
  %40 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 4
  %41 = bitcast %struct.luaL_Buffer* %4 to %union.anon.6**
  %42 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %43 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %44 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 1
  %45 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 3, i64 0
  %46 = bitcast %union.StackValue** %8 to %struct.TValue**
  %47 = bitcast i64* %32 to <2 x i64>*
  %48 = bitcast i64* %43 to <2 x i64>*
  br label %49

; <label>:49:                                     ; preds = %159, %25
  %50 = phi i32 [ %20, %25 ], [ %53, %159 ]
  %51 = phi i32 [ %2, %25 ], [ %161, %159 ]
  %52 = phi i32 [ 1, %25 ], [ %160, %159 ]
  %53 = add nsw i32 %50, -1
  %54 = icmp ne i32 %50, 0
  %55 = icmp ne i32 %52, 0
  %56 = and i1 %54, %55
  br i1 %56, label %57, label %162

; <label>:57:                                     ; preds = %49
  %58 = call i32 @lua_type(%struct.lua_State* %0, i32 %51) #16
  %59 = icmp eq i32 %58, 3
  br i1 %59, label %60, label %76

; <label>:60:                                     ; preds = %57
  %61 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %51) #16
  %62 = icmp eq i64 %61, 0
  br i1 %62, label %63, label %69

; <label>:63:                                     ; preds = %60
  %64 = call i32 @_IO_getc(%struct._IO_FILE* %1) #17
  %65 = call i32 @ungetc(i32 %64, %struct._IO_FILE* %1) #17
  %66 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #17
  %67 = icmp ne i32 %64, -1
  %68 = zext i1 %67 to i32
  br label %159

; <label>:69:                                     ; preds = %60
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %27) #7
  store %struct.lua_State* %0, %struct.lua_State** %28, align 8, !tbaa !202
  store %union.anon.6* %29, %union.anon.6** %30, align 8, !tbaa !201
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %47, align 8, !tbaa !135
  %70 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %61) #17
  %71 = call i64 @fread(i8* %70, i64 1, i64 %61, %struct._IO_FILE* %1) #17
  %72 = load i64, i64* %31, align 8, !tbaa !200
  %73 = add i64 %72, %71
  store i64 %73, i64* %31, align 8, !tbaa !200
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %7) #17
  %74 = icmp ne i64 %71, 0
  %75 = zext i1 %74 to i32
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %27) #7
  br label %159

; <label>:76:                                     ; preds = %57
  %77 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %51, i64* null) #16
  %78 = load i8, i8* %77, align 1, !tbaa !21
  %79 = icmp eq i8 %78, 42
  %80 = getelementptr inbounds i8, i8* %77, i64 1
  %81 = select i1 %79, i8* %80, i8* %77
  %82 = load i8, i8* %81, align 1, !tbaa !21
  %83 = sext i8 %82 to i32
  switch i32 %83, label %157 [
    i32 110, label %84
    i32 108, label %145
    i32 76, label %147
    i32 97, label %149
  ]

; <label>:84:                                     ; preds = %76
  call void @llvm.lifetime.start.p0i8(i64 224, i8* nonnull %33) #7
  call void @llvm.lifetime.start.p0i8(i64 2, i8* nonnull %34) #7
  store %struct._IO_FILE* %1, %struct._IO_FILE** %35, align 8, !tbaa !333
  store i32 0, i32* %36, align 4, !tbaa !335
  %85 = call %struct.lconv* @localeconv() #17
  %86 = getelementptr inbounds %struct.lconv, %struct.lconv* %85, i64 0, i32 0
  %87 = load i8*, i8** %86, align 8, !tbaa !133
  %88 = load i8, i8* %87, align 1, !tbaa !21
  store i8 %88, i8* %34, align 1, !tbaa !21
  store i8 46, i8* %37, align 1, !tbaa !21
  br label %89

; <label>:89:                                     ; preds = %89, %84
  %90 = call i32 @_IO_getc(%struct._IO_FILE* %1) #17
  %91 = tail call i16** @__ctype_b_loc() #22
  %92 = load i16*, i16** %91, align 8, !tbaa !39
  %93 = sext i32 %90 to i64
  %94 = getelementptr inbounds i16, i16* %92, i64 %93
  %95 = load i16, i16* %94, align 2, !tbaa !317
  %96 = and i16 %95, 8192
  %97 = icmp eq i16 %96, 0
  br i1 %97, label %98, label %89

; <label>:98:                                     ; preds = %89
  store i32 %90, i32* %44, align 8, !tbaa !336
  %99 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0)) #17
  %100 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.418, i64 0, i64 0)) #17
  %101 = icmp eq i32 %100, 0
  br i1 %101, label %108, label %102

; <label>:102:                                    ; preds = %98
  %103 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.246, i64 0, i64 0)) #17
  %104 = icmp eq i32 %103, 0
  %105 = zext i1 %104 to i32
  %106 = xor i1 %104, true
  %107 = zext i1 %106 to i32
  br label %108

; <label>:108:                                    ; preds = %102, %98
  %109 = phi i32 [ 0, %98 ], [ %105, %102 ]
  %110 = phi i32 [ 0, %98 ], [ %107, %102 ]
  %111 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 %110) #17
  %112 = add nsw i32 %111, %109
  %113 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* nonnull %34) #17
  %114 = icmp eq i32 %113, 0
  br i1 %114, label %118, label %115

; <label>:115:                                    ; preds = %108
  %116 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 %110) #17
  %117 = add nsw i32 %116, %112
  br label %118

; <label>:118:                                    ; preds = %115, %108
  %119 = phi i32 [ %117, %115 ], [ %112, %108 ]
  %120 = icmp sgt i32 %119, 0
  br i1 %120, label %121, label %129

; <label>:121:                                    ; preds = %118
  %122 = icmp eq i32 %110, 0
  %123 = select i1 %122, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.420, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.419, i64 0, i64 0)
  %124 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* %123) #17
  %125 = icmp eq i32 %124, 0
  br i1 %125, label %129, label %126

; <label>:126:                                    ; preds = %121
  %127 = call fastcc i32 @test2(%struct.RN* nonnull %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0)) #17
  %128 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 0) #17
  br label %129

; <label>:129:                                    ; preds = %126, %121, %118
  %130 = load i32, i32* %44, align 8, !tbaa !336
  %131 = load %struct._IO_FILE*, %struct._IO_FILE** %35, align 8, !tbaa !333
  %132 = call i32 @ungetc(i32 %130, %struct._IO_FILE* %131) #17
  %133 = load i32, i32* %36, align 4, !tbaa !335
  %134 = sext i32 %133 to i64
  %135 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 3, i64 %134
  store i8 0, i8* %135, align 1, !tbaa !21
  %136 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %45) #17
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %138, label %143

; <label>:138:                                    ; preds = %129
  %139 = load %struct.TValue*, %struct.TValue** %46, align 8, !tbaa !20
  %140 = getelementptr inbounds %struct.TValue, %struct.TValue* %139, i64 0, i32 1
  store i8 0, i8* %140, align 8, !tbaa !21
  %141 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %142 = getelementptr inbounds %union.StackValue, %union.StackValue* %141, i64 1
  store %union.StackValue* %142, %union.StackValue** %8, align 8, !tbaa !20
  br label %143

; <label>:143:                                    ; preds = %129, %138
  %144 = phi i32 [ 0, %138 ], [ 1, %129 ]
  call void @llvm.lifetime.end.p0i8(i64 2, i8* nonnull %34) #7
  call void @llvm.lifetime.end.p0i8(i64 224, i8* nonnull %33) #7
  br label %159

; <label>:145:                                    ; preds = %76
  %146 = call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 1) #16
  br label %159

; <label>:147:                                    ; preds = %76
  %148 = call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 0) #16
  br label %159

; <label>:149:                                    ; preds = %76
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %38) #7
  store %struct.lua_State* %0, %struct.lua_State** %39, align 8, !tbaa !202
  store %union.anon.6* %40, %union.anon.6** %41, align 8, !tbaa !201
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %48, align 8, !tbaa !135
  br label %150

; <label>:150:                                    ; preds = %150, %149
  %151 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1024) #17
  %152 = call i64 @fread(i8* %151, i64 1, i64 1024, %struct._IO_FILE* %1) #17
  %153 = load i64, i64* %42, align 8, !tbaa !200
  %154 = add i64 %153, %152
  store i64 %154, i64* %42, align 8, !tbaa !200
  %155 = icmp eq i64 %152, 1024
  br i1 %155, label %150, label %156

; <label>:156:                                    ; preds = %150
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %38) #7
  br label %159

; <label>:157:                                    ; preds = %76
  %158 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %51, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.417, i64 0, i64 0)) #16
  br label %179

; <label>:159:                                    ; preds = %143, %145, %147, %156, %63, %69
  %160 = phi i32 [ %68, %63 ], [ %75, %69 ], [ %144, %143 ], [ %146, %145 ], [ %148, %147 ], [ 1, %156 ]
  %161 = add nsw i32 %51, 1
  br label %49

; <label>:162:                                    ; preds = %49, %22
  %163 = phi i32 [ %24, %22 ], [ %51, %49 ]
  %164 = phi i32 [ %23, %22 ], [ %52, %49 ]
  %165 = call i32 @ferror(%struct._IO_FILE* %1) #17
  %166 = icmp eq i32 %165, 0
  br i1 %166, label %169, label %167

; <label>:167:                                    ; preds = %162
  %168 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %179

; <label>:169:                                    ; preds = %162
  %170 = icmp eq i32 %164, 0
  br i1 %170, label %171, label %177

; <label>:171:                                    ; preds = %169
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %172 = bitcast %union.StackValue** %8 to %struct.TValue**
  %173 = load %struct.TValue*, %struct.TValue** %172, align 8, !tbaa !20
  %174 = getelementptr inbounds %struct.TValue, %struct.TValue* %173, i64 0, i32 1
  store i8 0, i8* %174, align 8, !tbaa !21
  %175 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %176 = getelementptr inbounds %union.StackValue, %union.StackValue* %175, i64 1
  store %union.StackValue* %176, %union.StackValue** %8, align 8, !tbaa !20
  br label %177

; <label>:177:                                    ; preds = %169, %171
  %178 = sub nsw i32 %163, %2
  br label %179

; <label>:179:                                    ; preds = %157, %177, %167
  %180 = phi i32 [ %168, %167 ], [ %178, %177 ], [ %158, %157 ]
  ret i32 %180
}

; Function Attrs: minsize nounwind optsize
declare void @clearerr(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @read_line(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %6, align 8, !tbaa !202
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 4
  %8 = bitcast %struct.luaL_Buffer* %4 to %union.anon.6**
  store %union.anon.6* %7, %union.anon.6** %8, align 8, !tbaa !201
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %11 = bitcast i64* %10 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %11, align 8, !tbaa !135
  br label %12

; <label>:12:                                     ; preds = %27, %3
  %13 = phi i64 [ 0, %3 ], [ %31, %27 ]
  %14 = phi i32 [ 0, %3 ], [ %28, %27 ]
  switch i32 %14, label %15 [
    i32 -1, label %32
    i32 10, label %32
  ]

; <label>:15:                                     ; preds = %12
  %16 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1024) #16
  br label %17

; <label>:17:                                     ; preds = %23, %15
  %18 = phi i64 [ %25, %23 ], [ 0, %15 ]
  %19 = phi i32 [ %22, %23 ], [ %14, %15 ]
  %20 = icmp ult i64 %18, 1024
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %17
  %22 = call i32 @_IO_getc(%struct._IO_FILE* %1) #16
  switch i32 %22, label %23 [
    i32 -1, label %27
    i32 10, label %27
  ]

; <label>:23:                                     ; preds = %21
  %24 = trunc i32 %22 to i8
  %25 = add nuw nsw i64 %18, 1
  %26 = getelementptr inbounds i8, i8* %16, i64 %18
  store i8 %24, i8* %26, align 1, !tbaa !21
  br label %17

; <label>:27:                                     ; preds = %21, %21, %17
  %28 = phi i32 [ %22, %21 ], [ %19, %17 ], [ %22, %21 ]
  %29 = and i64 %18, 4294967295
  %30 = load i64, i64* %9, align 8, !tbaa !200
  %31 = add i64 %30, %29
  store i64 %31, i64* %9, align 8, !tbaa !200
  br label %12

; <label>:32:                                     ; preds = %12, %12
  %33 = icmp eq i32 %2, 0
  %34 = icmp eq i32 %14, 10
  %35 = and i1 %33, %34
  br i1 %35, label %36, label %48

; <label>:36:                                     ; preds = %32
  %37 = load i64, i64* %10, align 8, !tbaa !198
  %38 = icmp ult i64 %13, %37
  br i1 %38, label %42, label %39

; <label>:39:                                     ; preds = %36
  %40 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1) #16
  %41 = load i64, i64* %9, align 8, !tbaa !200
  br label %42

; <label>:42:                                     ; preds = %39, %36
  %43 = phi i64 [ %41, %39 ], [ %13, %36 ]
  %44 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 0
  %45 = load i8*, i8** %44, align 8, !tbaa !201
  %46 = add i64 %43, 1
  store i64 %46, i64* %9, align 8, !tbaa !200
  %47 = getelementptr inbounds i8, i8* %45, i64 %43
  store i8 10, i8* %47, align 1, !tbaa !21
  br label %48

; <label>:48:                                     ; preds = %32, %42
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4) #16
  br i1 %34, label %53, label %49

; <label>:49:                                     ; preds = %48
  %50 = call i64 @lua_rawlen(%struct.lua_State* %0, i32 -1) #16
  %51 = icmp ne i64 %50, 0
  %52 = zext i1 %51 to i32
  br label %53

; <label>:53:                                     ; preds = %49, %48
  %54 = phi i32 [ 1, %48 ], [ %52, %49 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  ret i32 %54
}

; Function Attrs: minsize nounwind optsize
declare i32 @ungetc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @test2(%struct.RN* nocapture, i8* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  %4 = load i32, i32* %3, align 8, !tbaa !336
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %13, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds i8, i8* %1, i64 1
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %4, %11
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %8, %2
  %14 = tail call fastcc i32 @nextc(%struct.RN* nonnull %0) #16
  br label %15

; <label>:15:                                     ; preds = %8, %13
  %16 = phi i32 [ %14, %13 ], [ 0, %8 ]
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @readdigits(%struct.RN* nocapture, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  %4 = tail call i16** @__ctype_b_loc() #22
  %5 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  br label %6

; <label>:6:                                      ; preds = %23, %2
  %7 = phi i32 [ 0, %2 ], [ %24, %23 ]
  %8 = load i16*, i16** %4, align 8, !tbaa !39
  %9 = load i32, i32* %5, align 8, !tbaa !336
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i16, i16* %8, i64 %10
  %12 = load i16, i16* %11, align 2, !tbaa !317
  %13 = zext i16 %12 to i32
  br i1 %3, label %17, label %14

; <label>:14:                                     ; preds = %6
  %15 = and i32 %13, 4096
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %25, label %20

; <label>:17:                                     ; preds = %6
  %18 = and i32 %13, 2048
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %14, %17
  %21 = tail call fastcc i32 @nextc(%struct.RN* nonnull %0) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %20
  %24 = add nuw nsw i32 %7, 1
  br label %6

; <label>:25:                                     ; preds = %20, %14, %17
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @nextc(%struct.RN* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 2
  %3 = load i32, i32* %2, align 4, !tbaa !335
  %4 = icmp sgt i32 %3, 199
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 0
  store i8 0, i8* %6, align 8, !tbaa !21
  br label %17

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 8, !tbaa !336
  %10 = trunc i32 %9 to i8
  %11 = add nsw i32 %3, 1
  store i32 %11, i32* %2, align 4, !tbaa !335
  %12 = sext i32 %3 to i64
  %13 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 %12
  store i8 %10, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 0
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %14, align 8, !tbaa !333
  %16 = tail call i32 @_IO_getc(%struct._IO_FILE* %15) #16
  store i32 %16, i32* %8, align 8, !tbaa !336
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ 0, %5 ], [ 1, %7 ]
  ret i32 %18
}

; Function Attrs: minsize nounwind optsize
declare noalias %struct._IO_FILE* @tmpfile64() local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @g_write(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !49
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !61
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  %13 = ptrtoint %union.StackValue* %12 to i64
  %14 = sub i64 %7, %13
  %15 = lshr exact i64 %14, 4
  %16 = trunc i64 %15 to i32
  %17 = sub nsw i32 %16, %2
  %18 = bitcast i64* %4 to i8*
  br label %19

; <label>:19:                                     ; preds = %52, %3
  %20 = phi i32 [ %17, %3 ], [ %23, %52 ]
  %21 = phi i32 [ 1, %3 ], [ %54, %52 ]
  %22 = phi i32 [ %2, %3 ], [ %55, %52 ]
  %23 = add nsw i32 %20, -1
  %24 = icmp eq i32 %20, 0
  br i1 %24, label %56, label %25

; <label>:25:                                     ; preds = %19
  %26 = call i32 @lua_type(%struct.lua_State* %0, i32 %22) #16
  %27 = icmp eq i32 %26, 3
  br i1 %27, label %28, label %42

; <label>:28:                                     ; preds = %25
  %29 = call i32 @lua_isinteger(%struct.lua_State* %0, i32 %22) #16
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %28
  %32 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %22, i32* null) #16
  %33 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %32) #16
  br label %37

; <label>:34:                                     ; preds = %28
  %35 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %22, i32* null) #16
  %36 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %35) #16
  br label %37

; <label>:37:                                     ; preds = %34, %31
  %38 = phi i32 [ %33, %31 ], [ %36, %34 ]
  %39 = icmp ne i32 %21, 0
  %40 = icmp sgt i32 %38, 0
  %41 = and i1 %39, %40
  br label %52

; <label>:42:                                     ; preds = %25
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %18) #7
  %43 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %22, i64* nonnull %4) #16
  %44 = icmp eq i32 %21, 0
  br i1 %44, label %50, label %45

; <label>:45:                                     ; preds = %42
  %46 = load i64, i64* %4, align 8, !tbaa !135
  %47 = call i64 @fwrite(i8* %43, i64 1, i64 %46, %struct._IO_FILE* %1) #16
  %48 = load i64, i64* %4, align 8, !tbaa !135
  %49 = icmp eq i64 %47, %48
  br label %50

; <label>:50:                                     ; preds = %42, %45
  %51 = phi i1 [ false, %42 ], [ %49, %45 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %18) #7
  br label %52

; <label>:52:                                     ; preds = %37, %50
  %53 = phi i1 [ %41, %37 ], [ %51, %50 ]
  %54 = zext i1 %53 to i32
  %55 = add nsw i32 %22, 1
  br label %19

; <label>:56:                                     ; preds = %19
  %57 = icmp eq i32 %21, 0
  br i1 %57, label %58, label %60

; <label>:58:                                     ; preds = %56
  %59 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %60

; <label>:60:                                     ; preds = %56, %58
  %61 = phi i32 [ %59, %58 ], [ 1, %56 ]
  ret i32 %61
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2) #16
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null) #16
  ret i32 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_lines(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 0) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 2) #16
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_seek(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i64 0, i64 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_seek.modenames, i64 0, i64 0)) #16
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_seek.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !74
  %8 = tail call i32 @fseek(%struct._IO_FILE* %2, i64 %4, i32 %7) #16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %1
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %21

; <label>:12:                                     ; preds = %1
  %13 = tail call i64 @ftell(%struct._IO_FILE* %2) #16
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = bitcast %struct.TValue* %16 to i64*
  store i64 %13, i64* %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 35, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %14, align 8, !tbaa !20
  br label %21

; <label>:21:                                     ; preds = %12, %10
  %22 = phi i32 [ %11, %10 ], [ 1, %12 ]
  ret i32 %22
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_setvbuf(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* null, i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_setvbuf.modenames, i64 0, i64 0)) #16
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1024) #16
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_setvbuf.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !74
  %8 = tail call i32 @setvbuf(%struct._IO_FILE* %2, i8* null, i32 %7, i64 %4) #17
  %9 = icmp eq i32 %8, 0
  %10 = zext i1 %9 to i32
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %10, i8* null) #16
  ret i32 %11
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %3 = tail call fastcc i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 2) #16
  ret i32 %3
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_gc(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !214
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %13, label %7

; <label>:7:                                      ; preds = %1
  %8 = bitcast i8* %2 to %struct._IO_FILE**
  %9 = load %struct._IO_FILE*, %struct._IO_FILE** %8, align 8, !tbaa !212
  %10 = icmp eq %struct._IO_FILE* %9, null
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %7
  %12 = tail call fastcc i32 @aux_close(%struct.lua_State* %0) #16
  br label %13

; <label>:13:                                     ; preds = %7, %11, %1
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @f_tostring(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !214
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.435, i64 0, i64 0)) #16
  br label %13

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !212
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.436, i64 0, i64 0), %struct._IO_FILE* %11) #16
  br label %13

; <label>:13:                                     ; preds = %9, %7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize
declare i32 @fseek(%struct._IO_FILE* nocapture, i64, i32) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i64 @ftell(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i32 @setvbuf(%struct._IO_FILE* nocapture, i8*, i32, i64) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @io_noclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !214
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  %11 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.437, i64 0, i64 0)) #16
  ret i32 2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_abs(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %13, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null) #16
  %6 = icmp slt i64 %5, 0
  %7 = sub i64 0, %5
  %8 = select i1 %6, i64 %7, i64 %5
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = bitcast %struct.TValue* %11 to i64*
  store i64 %8, i64* %12, align 8, !tbaa !21
  br label %20

; <label>:13:                                     ; preds = %1
  %14 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %15 = tail call double @llvm.fabs.f64(double %14)
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = bitcast %union.StackValue** %16 to %struct.TValue**
  %18 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !20
  %19 = bitcast %struct.TValue* %18 to double*
  store double %15, double* %19, align 8, !tbaa !21
  br label %20

; <label>:20:                                     ; preds = %13, %4
  %21 = phi %struct.TValue* [ %18, %13 ], [ %11, %4 ]
  %22 = phi i8 [ 19, %13 ], [ 35, %4 ]
  %23 = phi %union.StackValue** [ %16, %13 ], [ %9, %4 ]
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  store i8 %22, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %23, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_acos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @acos(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_asin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @asin(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_atan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @luaL_optnumber(%struct.lua_State* %0, i32 2, double 1.000000e+00) #16
  %4 = tail call double @atan2(double %2, double %3) #17
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_ceil(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  br label %8

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %7 = tail call double @llvm.ceil.f64(double %6)
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %7) #16
  br label %8

; <label>:8:                                      ; preds = %5, %4
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_cos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @cos(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_deg(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = fmul double %2, 0x404CA5DC1A63C1F8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_exp(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @exp(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_toint(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* nonnull %2) #16
  %5 = load i32, i32* %2, align 4, !tbaa !74
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = bitcast %struct.TValue* %10 to i64*
  store i64 %4, i64* %11, align 8, !tbaa !21
  br label %16

; <label>:12:                                     ; preds = %1
  call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  br label %16

; <label>:16:                                     ; preds = %12, %7
  %17 = phi %struct.TValue* [ %15, %12 ], [ %10, %7 ]
  %18 = phi i8 [ 0, %12 ], [ 35, %7 ]
  %19 = phi %union.StackValue** [ %13, %12 ], [ %8, %7 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 %18, i8* %20, align 8, !tbaa !21
  %21 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  store %union.StackValue* %22, %union.StackValue** %19, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_floor(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  br label %8

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %7 = tail call double @llvm.floor.f64(double %6)
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %7) #16
  br label %8

; <label>:8:                                      ; preds = %5, %4
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_fmod(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %27, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 2) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %27, label %7

; <label>:7:                                      ; preds = %4
  %8 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 2, i32* null) #16
  %9 = add i64 %8, 1
  %10 = icmp ult i64 %9, 2
  br i1 %10, label %11, label %20

; <label>:11:                                     ; preds = %7
  %12 = icmp eq i64 %8, 0
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.460, i64 0, i64 0)) #16
  br label %15

; <label>:15:                                     ; preds = %11, %13
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = bitcast %union.StackValue** %16 to %struct.TValue**
  %18 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !20
  %19 = bitcast %struct.TValue* %18 to i64*
  store i64 0, i64* %19, align 8, !tbaa !21
  br label %35

; <label>:20:                                     ; preds = %7
  %21 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null) #16
  %22 = srem i64 %21, %8
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = bitcast %union.StackValue** %23 to %struct.TValue**
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !20
  %26 = bitcast %struct.TValue* %25 to i64*
  store i64 %22, i64* %26, align 8, !tbaa !21
  br label %35

; <label>:27:                                     ; preds = %4, %1
  %28 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %29 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 2) #16
  %30 = tail call double @fmod(double %28, double %29) #17
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = bitcast %union.StackValue** %31 to %struct.TValue**
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %34 = bitcast %struct.TValue* %33 to double*
  store double %30, double* %34, align 8, !tbaa !21
  br label %35

; <label>:35:                                     ; preds = %15, %20, %27
  %36 = phi %struct.TValue* [ %18, %15 ], [ %25, %20 ], [ %33, %27 ]
  %37 = phi i8 [ 35, %15 ], [ 35, %20 ], [ 19, %27 ]
  %38 = phi %union.StackValue** [ %16, %15 ], [ %23, %20 ], [ %31, %27 ]
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  store i8 %37, i8* %39, align 8, !tbaa !22
  %40 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %38, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_ult(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %4 = icmp ult i64 %2, %3
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = zext i1 %4 to i32
  %9 = bitcast %struct.TValue* %7 to i32*
  store i32 %8, i32* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 1, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_log(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call double @log(double %2) #17
  br label %20

; <label>:7:                                      ; preds = %1
  %8 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 2) #16
  %9 = fcmp oeq double %8, 2.000000e+00
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %7
  %11 = tail call double @log2(double %2) #17
  br label %20

; <label>:12:                                     ; preds = %7
  %13 = fcmp oeq double %8, 1.000000e+01
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %12
  %15 = tail call double @log10(double %2) #17
  br label %20

; <label>:16:                                     ; preds = %12
  %17 = tail call double @log(double %2) #17
  %18 = tail call double @log(double %8) #17
  %19 = fdiv double %17, %18
  br label %20

; <label>:20:                                     ; preds = %10, %16, %14, %5
  %21 = phi double [ %6, %5 ], [ %11, %10 ], [ %15, %14 ], [ %19, %16 ]
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = bitcast %union.StackValue** %22 to %struct.TValue**
  %24 = load %struct.TValue*, %struct.TValue** %23, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to double*
  store double %21, double* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 19, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %22, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_max(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %17

; <label>:17:                                     ; preds = %15, %1
  br label %18

; <label>:18:                                     ; preds = %17, %22
  %19 = phi i32 [ %25, %22 ], [ 1, %17 ]
  %20 = phi i32 [ %26, %22 ], [ 2, %17 ]
  %21 = icmp sgt i32 %20, %13
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %18
  %23 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %19, i32 %20, i32 1) #16
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 %19, i32 %20
  %26 = add nuw nsw i32 %20, 1
  br label %18

; <label>:27:                                     ; preds = %18
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %19) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_min(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %17

; <label>:17:                                     ; preds = %15, %1
  br label %18

; <label>:18:                                     ; preds = %17, %22
  %19 = phi i32 [ %25, %22 ], [ 1, %17 ]
  %20 = phi i32 [ %26, %22 ], [ 2, %17 ]
  %21 = icmp sgt i32 %20, %13
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %18
  %23 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %20, i32 %19, i32 1) #16
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 %19, i32 %20
  %26 = add nuw nsw i32 %20, 1
  br label %18

; <label>:27:                                     ; preds = %18
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %19) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_modf(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  br label %14

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %7 = fcmp olt double %6, 0.000000e+00
  %8 = tail call double @llvm.ceil.f64(double %6)
  %9 = tail call double @llvm.floor.f64(double %6)
  %10 = select i1 %7, double %8, double %9
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %10) #16
  %11 = fcmp oeq double %6, %10
  %12 = fsub double %6, %10
  %13 = select i1 %11, double 0.000000e+00, double %12
  br label %14

; <label>:14:                                     ; preds = %5, %4
  %15 = phi double [ %13, %5 ], [ 0.000000e+00, %4 ]
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = bitcast %union.StackValue** %16 to %struct.TValue**
  %18 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !20
  %19 = bitcast %struct.TValue* %18 to double*
  store double %15, double* %19, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 19, i8* %20, align 8, !tbaa !22
  %21 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  store %union.StackValue* %22, %union.StackValue** %16, align 8, !tbaa !20
  ret i32 2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_rad(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = fmul double %2, 0x3F91DF46A2529D39
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_sin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @sin(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_sqrt(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @sqrt(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_tan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @tan(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_type(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 3
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1) #16
  %6 = icmp eq i32 %5, 0
  %7 = select i1 %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.462, i64 0, i64 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.461, i64 0, i64 0)
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7) #16
  br label %16

; <label>:9:                                      ; preds = %1
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %10, align 8, !tbaa !20
  br label %16

; <label>:16:                                     ; preds = %9, %4
  ret i32 1
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.fabs.f64(double) #14

; Function Attrs: minsize nounwind optsize
declare double @acos(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @asin(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @atan2(double, double) local_unnamed_addr #9

; Function Attrs: nounwind readnone speculatable
declare double @llvm.ceil.f64(double) #14

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @pushnumint(%struct.lua_State* nocapture, double) unnamed_addr #2 {
  %3 = fcmp oge double %1, 0xC3E0000000000000
  %4 = fcmp olt double %1, 0x43E0000000000000
  %5 = and i1 %3, %4
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = fptosi double %1 to i64
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = bitcast %struct.TValue* %10 to i64*
  store i64 %7, i64* %11, align 8, !tbaa !21
  br label %17

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = bitcast %struct.TValue* %15 to double*
  store double %1, double* %16, align 8, !tbaa !21
  br label %17

; <label>:17:                                     ; preds = %12, %6
  %18 = phi %struct.TValue* [ %15, %12 ], [ %10, %6 ]
  %19 = phi i8 [ 19, %12 ], [ 35, %6 ]
  %20 = phi %union.StackValue** [ %13, %12 ], [ %8, %6 ]
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 %19, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %20, align 8, !tbaa !20
  ret void
}

; Function Attrs: minsize nounwind optsize
declare double @cos(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @exp(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @log(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @log2(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @log10(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @sin(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @sqrt(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare double @tan(double) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @randseed(%struct.lua_State*, %struct.RanState* nocapture) unnamed_addr #0 {
  %3 = tail call i64 @time(i64* null) #17
  %4 = ptrtoint %struct.lua_State* %0 to i64
  %5 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 0
  tail call fastcc void @setseed(i64* %5, i64 %3, i64 %4) #16
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @setseed(i64* nocapture, i64, i64) unnamed_addr #2 {
  store i64 %1, i64* %0, align 8, !tbaa !135
  %4 = getelementptr inbounds i64, i64* %0, i64 1
  store i64 255, i64* %4, align 8, !tbaa !135
  %5 = getelementptr inbounds i64, i64* %0, i64 2
  store i64 %2, i64* %5, align 8, !tbaa !135
  %6 = getelementptr inbounds i64, i64* %0, i64 3
  store i64 0, i64* %6, align 8, !tbaa !135
  br label %7

; <label>:7:                                      ; preds = %10, %3
  %8 = phi i32 [ 0, %3 ], [ %12, %10 ]
  %9 = icmp eq i32 %8, 16
  br i1 %9, label %13, label %10

; <label>:10:                                     ; preds = %7
  %11 = tail call fastcc i64 @nextrand(i64* %0) #16
  %12 = add nuw nsw i32 %8, 1
  br label %7

; <label>:13:                                     ; preds = %7
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i64 @nextrand(i64* nocapture) unnamed_addr #2 {
  %2 = load i64, i64* %0, align 8, !tbaa !135
  %3 = getelementptr inbounds i64, i64* %0, i64 1
  %4 = load i64, i64* %3, align 8, !tbaa !135
  %5 = getelementptr inbounds i64, i64* %0, i64 2
  %6 = load i64, i64* %5, align 8, !tbaa !135
  %7 = xor i64 %6, %2
  %8 = getelementptr inbounds i64, i64* %0, i64 3
  %9 = load i64, i64* %8, align 8, !tbaa !135
  %10 = xor i64 %9, %4
  %11 = mul i64 %4, 5
  %12 = mul i64 %4, 640
  %13 = lshr i64 %11, 57
  %14 = or i64 %13, %12
  %15 = mul i64 %14, 9
  %16 = xor i64 %10, %2
  store i64 %16, i64* %0, align 8, !tbaa !135
  %17 = xor i64 %7, %4
  store i64 %17, i64* %3, align 8, !tbaa !135
  %18 = shl i64 %4, 17
  %19 = xor i64 %7, %18
  store i64 %19, i64* %5, align 8, !tbaa !135
  %20 = shl i64 %10, 45
  %21 = lshr i64 %10, 19
  %22 = or i64 %21, %20
  store i64 %22, i64* %8, align 8, !tbaa !135
  ret i64 %15
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_random(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %3 = bitcast i8* %2 to i64*
  %4 = tail call fastcc i64 @nextrand(i64* %3) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !49
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !61
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  %13 = ptrtoint %union.StackValue* %12 to i64
  %14 = sub i64 %7, %13
  %15 = lshr exact i64 %14, 4
  %16 = trunc i64 %15 to i32
  switch i32 %16, label %33 [
    i32 0, label %17
    i32 1, label %23
    i32 2, label %30
  ]

; <label>:17:                                     ; preds = %1
  %18 = inttoptr i64 %7 to %struct.TValue*
  %19 = lshr i64 %4, 11
  %20 = uitofp i64 %19 to double
  %21 = fmul double %20, 0x3CA0000000000000
  %22 = inttoptr i64 %7 to double*
  store double %21, double* %22, align 8, !tbaa !21
  br label %72

; <label>:23:                                     ; preds = %1
  %24 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %26, label %35

; <label>:26:                                     ; preds = %23
  %27 = bitcast %union.StackValue** %5 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %28 to i64*
  store i64 %4, i64* %29, align 8, !tbaa !21
  br label %72

; <label>:30:                                     ; preds = %1
  %31 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %32 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #16
  br label %35

; <label>:33:                                     ; preds = %1
  %34 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.463, i64 0, i64 0)) #16
  unreachable

; <label>:35:                                     ; preds = %23, %30
  %36 = phi i64 [ %32, %30 ], [ %24, %23 ]
  %37 = phi i64 [ %31, %30 ], [ 1, %23 ]
  %38 = icmp slt i64 %36, %37
  br i1 %38, label %39, label %41

; <label>:39:                                     ; preds = %35
  %40 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.464, i64 0, i64 0)) #16
  br label %41

; <label>:41:                                     ; preds = %35, %39
  %42 = sub i64 %36, %37
  %43 = add i64 %42, 1
  %44 = and i64 %43, %42
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %59, label %46

; <label>:46:                                     ; preds = %41
  %47 = lshr i64 %42, 1
  %48 = or i64 %47, %42
  %49 = lshr i64 %48, 2
  %50 = or i64 %49, %48
  %51 = lshr i64 %50, 4
  %52 = or i64 %51, %50
  %53 = lshr i64 %52, 8
  %54 = or i64 %53, %52
  %55 = lshr i64 %54, 16
  %56 = or i64 %55, %54
  %57 = lshr i64 %56, 32
  %58 = or i64 %57, %56
  br label %59

; <label>:59:                                     ; preds = %46, %41
  %60 = phi i64 [ %58, %46 ], [ %42, %41 ]
  br label %61

; <label>:61:                                     ; preds = %65, %59
  %62 = phi i64 [ %4, %59 ], [ %66, %65 ]
  %63 = and i64 %62, %60
  %64 = icmp ugt i64 %63, %42
  br i1 %64, label %65, label %67

; <label>:65:                                     ; preds = %61
  %66 = tail call fastcc i64 @nextrand(i64* %3) #17
  br label %61

; <label>:67:                                     ; preds = %61
  %68 = add i64 %63, %37
  %69 = bitcast %union.StackValue** %5 to %struct.TValue**
  %70 = load %struct.TValue*, %struct.TValue** %69, align 8, !tbaa !20
  %71 = bitcast %struct.TValue* %70 to i64*
  store i64 %68, i64* %71, align 8, !tbaa !21
  br label %72

; <label>:72:                                     ; preds = %67, %26, %17
  %73 = phi %struct.TValue* [ %70, %67 ], [ %28, %26 ], [ %18, %17 ]
  %74 = phi i8 [ 35, %67 ], [ 35, %26 ], [ 19, %17 ]
  %75 = getelementptr inbounds %struct.TValue, %struct.TValue* %73, i64 0, i32 1
  store i8 %74, i8* %75, align 8, !tbaa !22
  %76 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %77 = getelementptr inbounds %union.StackValue, %union.StackValue* %76, i64 1
  store %union.StackValue* %77, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @math_randomseed(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = bitcast i8* %2 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* %0, %struct.RanState* %6) #16
  br label %11

; <label>:7:                                      ; preds = %1
  %8 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1) #16
  %9 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %10 = bitcast i8* %2 to i64*
  tail call fastcc void @setseed(i64* %10, i64 %8, i64 %9) #16
  br label %11

; <label>:11:                                     ; preds = %7, %5
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @gctm(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  br label %3

; <label>:3:                                      ; preds = %6, %1
  %4 = phi i64 [ %2, %1 ], [ %8, %6 ]
  %5 = icmp sgt i64 %4, 0
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 1, i64 %4) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %8 = add nsw i64 %4, -1
  br label %3

; <label>:9:                                      ; preds = %3
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @ll_loadlib(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %2, i8* %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %16, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %10, align 8, !tbaa !21
  %11 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %7, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  %13 = icmp eq i32 %4, 1
  %14 = select i1 %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.468, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.469, i64 0, i64 0)
  %15 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %14) #16
  br label %16

; <label>:16:                                     ; preds = %1, %6
  %17 = phi i32 [ 3, %6 ], [ 1, %1 ]
  ret i32 %17
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @ll_searchpath(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i64* null) #16
  %5 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0), i64* null) #16
  %6 = tail call fastcc i8* @searchpath(%struct.lua_State* %0, i8* %2, i8* %3, i8* %4, i8* %5) #16
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 0, i8* %12, align 8, !tbaa !21
  %13 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %9, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %15

; <label>:15:                                     ; preds = %1, %8
  %16 = phi i32 [ 2, %8 ], [ 1, %1 ]
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @lookforfunc(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*)) #17
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1) #17
  %6 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1) #17
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3) #17
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0)) #17
  br label %23

; <label>:10:                                     ; preds = %3
  %11 = load i8, i8* %2, align 1, !tbaa !21
  %12 = icmp eq i8 %11, 42
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %10
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = bitcast %struct.TValue* %16 to i32*
  store i32 1, i32* %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 1, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %14, align 8, !tbaa !20
  br label %23

; <label>:21:                                     ; preds = %10
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0)) #17
  br label %23

; <label>:23:                                     ; preds = %21, %13, %8
  %24 = phi i32 [ 1, %8 ], [ 0, %13 ], [ 2, %21 ]
  ret i32 %24
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @searchpath(%struct.lua_State*, i8*, i8*, i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {
  %6 = alloca %struct.luaL_Buffer, align 8
  %7 = alloca %struct.luaL_Buffer, align 8
  %8 = bitcast %struct.luaL_Buffer* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %8) #7
  %9 = load i8, i8* %3, align 1, !tbaa !21
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %17, label %11

; <label>:11:                                     ; preds = %5
  %12 = sext i8 %9 to i32
  %13 = tail call i8* @strchr(i8* %1, i32 %12) #21
  %14 = icmp eq i8* %13, null
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %11
  %16 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %1, i8* nonnull %3, i8* %4) #16
  br label %17

; <label>:17:                                     ; preds = %11, %5, %15
  %18 = phi i8* [ %16, %15 ], [ %1, %11 ], [ %1, %5 ]
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %19, align 8, !tbaa !202
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 4
  %21 = bitcast %struct.luaL_Buffer* %7 to %union.anon.6**
  store %union.anon.6* %20, %union.anon.6** %21, align 8, !tbaa !201
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 2
  %23 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 1
  %24 = bitcast i64* %23 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %24, align 8, !tbaa !135
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %7, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %18) #16
  %25 = load i64, i64* %22, align 8, !tbaa !200
  %26 = load i64, i64* %23, align 8, !tbaa !198
  %27 = icmp ult i64 %25, %26
  br i1 %27, label %31, label %28

; <label>:28:                                     ; preds = %17
  %29 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1) #16
  %30 = load i64, i64* %22, align 8, !tbaa !200
  br label %31

; <label>:31:                                     ; preds = %28, %17
  %32 = phi i64 [ %30, %28 ], [ %25, %17 ]
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 0
  %34 = load i8*, i8** %33, align 8, !tbaa !201
  %35 = add i64 %32, 1
  store i64 %35, i64* %22, align 8, !tbaa !200
  %36 = getelementptr inbounds i8, i8* %34, i64 %32
  store i8 0, i8* %36, align 1, !tbaa !21
  %37 = load i8*, i8** %33, align 8, !tbaa !201
  %38 = load i64, i64* %22, align 8, !tbaa !200
  %39 = getelementptr inbounds i8, i8* %37, i64 %38
  %40 = getelementptr inbounds i8, i8* %39, i64 -1
  br label %41

; <label>:41:                                     ; preds = %49, %31
  %42 = phi i8* [ %37, %31 ], [ %53, %49 ]
  %43 = icmp eq i8* %42, %40
  br i1 %43, label %59, label %44

; <label>:44:                                     ; preds = %41
  %45 = load i8, i8* %42, align 1, !tbaa !21
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %44
  store i8 59, i8* %42, align 1, !tbaa !21
  %48 = getelementptr inbounds i8, i8* %42, i64 1
  br label %49

; <label>:49:                                     ; preds = %47, %44
  %50 = phi i8* [ %48, %47 ], [ %42, %44 ]
  %51 = call i8* @strchr(i8* nonnull %50, i32 59) #21
  %52 = icmp eq i8* %51, null
  %53 = select i1 %52, i8* %40, i8* %51
  store i8 0, i8* %53, align 1, !tbaa !21
  %54 = call %struct._IO_FILE* @fopen64(i8* nonnull %50, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #17
  %55 = icmp eq %struct._IO_FILE* %54, null
  br i1 %55, label %41, label %56

; <label>:56:                                     ; preds = %49
  %57 = call i32 @fclose(%struct._IO_FILE* nonnull %54) #17
  %58 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %50) #16
  br label %67

; <label>:59:                                     ; preds = %41
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %7) #16
  %60 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %61 = bitcast %struct.luaL_Buffer* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %61) #7
  %62 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %62, align 8, !tbaa !202
  %63 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 4
  %64 = bitcast %struct.luaL_Buffer* %6 to %union.anon.6**
  store %union.anon.6* %63, %union.anon.6** %64, align 8, !tbaa !201
  %65 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 1
  %66 = bitcast i64* %65 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %66, align 8, !tbaa !135
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %6, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.473, i64 0, i64 0)) #17
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %6, i8* %60, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.472, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.474, i64 0, i64 0)) #17
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.475, i64 0, i64 0)) #17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %6) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %61) #7
  br label %67

; <label>:67:                                     ; preds = %59, %56
  %68 = phi i8* [ %58, %56 ], [ null, %59 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %8) #7
  ret i8* %68
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @searcher_preload(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0)) #16
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %2) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.476, i64 0, i64 0), i8* %2) #16
  br label %10

; <label>:8:                                      ; preds = %1
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.477, i64 0, i64 0)) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i32 [ 1, %6 ], [ 2, %8 ]
  ret i32 %11
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @searcher_Lua(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0)) #16
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* nonnull %3, i8* null) #16
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3) #16
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @searcher_C(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0)) #16
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %3, i8* %2) #16
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3) #16
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @searcher_Croot(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @strchr(i8* %2, i32 46) #21
  %4 = icmp eq i8* %3, null
  br i1 %4, label %20, label %5

; <label>:5:                                      ; preds = %1
  %6 = ptrtoint i8* %3 to i64
  %7 = ptrtoint i8* %2 to i64
  %8 = sub i64 %6, %7
  %9 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %2, i64 %8) #16
  %10 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %11 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0)) #16
  %12 = icmp eq i8* %11, null
  br i1 %12, label %20, label %13

; <label>:13:                                     ; preds = %5
  %14 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %11, i8* %2) #16
  switch i32 %14, label %15 [
    i32 0, label %18
    i32 2, label %16
  ]

; <label>:15:                                     ; preds = %13
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 0, i8* nonnull %11) #16
  br label %20

; <label>:16:                                     ; preds = %13
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.483, i64 0, i64 0), i8* %2, i8* nonnull %11) #16
  br label %20

; <label>:18:                                     ; preds = %13
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11) #16
  br label %20

; <label>:20:                                     ; preds = %5, %1, %18, %16, %15
  %21 = phi i32 [ 2, %15 ], [ 1, %16 ], [ 2, %18 ], [ 0, %1 ], [ 1, %5 ]
  ret i32 %21
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @findfile(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001001, i8* %2) #16
  %5 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %6 = icmp eq i8* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.478, i64 0, i64 0), i8* %2) #16
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = tail call fastcc i8* @searchpath(%struct.lua_State* %0, i8* %1, i8* nonnull %5, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0)) #16
  ret i8* %10
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checkload(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %9

; <label>:5:                                      ; preds = %3
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.479, i64 0, i64 0), i8* %6, i8* %2, i8* %7) #16
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @loadfunc(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.480, i64 0, i64 0)) #16
  %5 = tail call i8* @strchr(i8* %4, i32 45) #21
  %6 = icmp eq i8* %5, null
  br i1 %6, label %16, label %7

; <label>:7:                                      ; preds = %3
  %8 = ptrtoint i8* %5 to i64
  %9 = ptrtoint i8* %4 to i64
  %10 = sub i64 %8, %9
  %11 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %4, i64 %10) #16
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* nonnull %11) #16
  %13 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %12) #16
  %14 = icmp eq i32 %13, 2
  %15 = getelementptr inbounds i8, i8* %5, i64 1
  br i1 %14, label %16, label %20

; <label>:16:                                     ; preds = %3, %7
  %17 = phi i8* [ %15, %7 ], [ %4, %3 ]
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* %17) #16
  %19 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %18) #16
  br label %20

; <label>:20:                                     ; preds = %7, %16
  %21 = phi i32 [ %19, %16 ], [ %13, %7 ]
  ret i32 %21
}

; Function Attrs: minsize nounwind optsize readonly
declare i8* @getenv(i8* nocapture) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @ll_require(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 2, i8* %3) #16
  %6 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %59

; <label>:8:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %9 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %9) #7
  %10 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001001, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0)) #17
  %11 = icmp eq i32 %10, 5
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %8
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.489, i64 0, i64 0)) #17
  unreachable

; <label>:14:                                     ; preds = %8
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %15, align 8, !tbaa !202
  %16 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %17 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %16, %union.anon.6** %17, align 8, !tbaa !201
  %18 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %19 = bitcast i64* %18 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %19, align 8, !tbaa !135
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %21

; <label>:21:                                     ; preds = %39, %14
  %22 = phi i64 [ %40, %39 ], [ 1, %14 ]
  %23 = call i32 @lua_rawgeti(%struct.lua_State* %0, i32 3, i64 %22) #17
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %28

; <label>:25:                                     ; preds = %21
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #17
  %26 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %27 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.490, i64 0, i64 0), i8* %3, i8* %26) #17
  unreachable

; <label>:28:                                     ; preds = %21
  %29 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3) #17
  %30 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -2
  call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %31, i32 2) #17
  %32 = call i32 @lua_type(%struct.lua_State* %0, i32 -2) #17
  %33 = icmp eq i32 %32, 6
  br i1 %33, label %41, label %34

; <label>:34:                                     ; preds = %28
  %35 = call i32 @lua_isstring(%struct.lua_State* nonnull %0, i32 -2) #17
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %34
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #17
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %2) #17
  br label %39

; <label>:38:                                     ; preds = %34
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 -3) #17
  br label %39

; <label>:39:                                     ; preds = %38, %37
  %40 = add nuw i64 %22, 1
  br label %21

; <label>:41:                                     ; preds = %28
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %9) #7
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  call void @lua_pushvalue(%struct.lua_State* nonnull %0, i32 1) #16
  call void @lua_pushvalue(%struct.lua_State* nonnull %0, i32 -3) #16
  %42 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -3
  call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %43, i32 1) #17
  %44 = call i32 @lua_type(%struct.lua_State* nonnull %0, i32 -1) #16
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %47, label %46

; <label>:46:                                     ; preds = %41
  call void @lua_setfield(%struct.lua_State* nonnull %0, i32 2, i8* %3) #16
  br label %48

; <label>:47:                                     ; preds = %41
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  br label %48

; <label>:48:                                     ; preds = %47, %46
  %49 = call i32 @lua_getfield(%struct.lua_State* nonnull %0, i32 2, i8* %3) #16
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %51, label %58

; <label>:51:                                     ; preds = %48
  %52 = bitcast %union.StackValue** %20 to %struct.TValue**
  %53 = load %struct.TValue*, %struct.TValue** %52, align 8, !tbaa !20
  %54 = bitcast %struct.TValue* %53 to i32*
  store i32 1, i32* %54, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  store i8 1, i8* %55, align 8, !tbaa !22
  %56 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 1
  store %union.StackValue* %57, %union.StackValue** %20, align 8, !tbaa !20
  call void @lua_copy(%struct.lua_State* nonnull %0, i32 -1, i32 -2) #16
  call void @lua_setfield(%struct.lua_State* nonnull %0, i32 2, i8* %3) #16
  br label %58

; <label>:58:                                     ; preds = %51, %48
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  br label %59

; <label>:59:                                     ; preds = %1, %58
  %60 = phi i32 [ 2, %58 ], [ 1, %1 ]
  ret i32 %60
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_clock(%struct.lua_State* nocapture) #0 {
  %2 = tail call i64 @clock() #17
  %3 = sitofp i64 %2 to double
  %4 = fdiv double %3, 1.000000e+06
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_date(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca [4 x i8], align 1
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.501, i64 0, i64 0), i64* nonnull %2) #16
  %8 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  %10 = icmp slt i32 %9, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %1
  %12 = call i64 @time(i64* null) #17
  br label %15

; <label>:13:                                     ; preds = %1
  %14 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #17
  br label %15

; <label>:15:                                     ; preds = %13, %11
  %16 = phi i64 [ %12, %11 ], [ %14, %13 ]
  store i64 %16, i64* %3, align 8, !tbaa !135
  %17 = load i64, i64* %2, align 8, !tbaa !135
  %18 = getelementptr inbounds i8, i8* %7, i64 %17
  %19 = load i8, i8* %7, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 33
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %15
  %22 = call %struct.tm* @gmtime(i64* nonnull %3) #17
  %23 = getelementptr inbounds i8, i8* %7, i64 1
  br label %26

; <label>:24:                                     ; preds = %15
  %25 = call %struct.tm* @localtime(i64* nonnull %3) #17
  br label %26

; <label>:26:                                     ; preds = %24, %21
  %27 = phi %struct.tm* [ %22, %21 ], [ %25, %24 ]
  %28 = phi i8* [ %23, %21 ], [ %7, %24 ]
  %29 = icmp eq %struct.tm* %27, null
  br i1 %29, label %30, label %32

; <label>:30:                                     ; preds = %26
  %31 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0)) #16
  unreachable

; <label>:32:                                     ; preds = %26
  %33 = call i32 @strcmp(i8* nonnull %28, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.503, i64 0, i64 0)) #21
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %35, label %36

; <label>:35:                                     ; preds = %32
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 9) #16
  call fastcc void @setallfields(%struct.lua_State* %0, %struct.tm* nonnull %27) #16
  br label %108

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %37) #7
  %38 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %38) #7
  store i8 37, i8* %37, align 1, !tbaa !21
  %39 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %39, align 8, !tbaa !202
  %40 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %41 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %40, %union.anon.6** %41, align 8, !tbaa !201
  %42 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %43 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %44 = bitcast i64* %43 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %44, align 8, !tbaa !135
  %45 = ptrtoint i8* %18 to i64
  %46 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 1
  %47 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  br label %48

; <label>:48:                                     ; preds = %105, %36
  %49 = phi i8* [ %28, %36 ], [ %106, %105 ]
  %50 = icmp ult i8* %49, %18
  br i1 %50, label %51, label %107

; <label>:51:                                     ; preds = %48
  %52 = load i8, i8* %49, align 1, !tbaa !21
  %53 = icmp eq i8 %52, 37
  br i1 %53, label %69, label %54

; <label>:54:                                     ; preds = %51
  %55 = load i64, i64* %42, align 8, !tbaa !200
  %56 = load i64, i64* %43, align 8, !tbaa !198
  %57 = icmp ult i64 %55, %56
  br i1 %57, label %62, label %58

; <label>:58:                                     ; preds = %54
  %59 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #16
  %60 = load i8, i8* %49, align 1, !tbaa !21
  %61 = load i64, i64* %42, align 8, !tbaa !200
  br label %62

; <label>:62:                                     ; preds = %58, %54
  %63 = phi i64 [ %61, %58 ], [ %55, %54 ]
  %64 = phi i8 [ %60, %58 ], [ %52, %54 ]
  %65 = getelementptr inbounds i8, i8* %49, i64 1
  %66 = load i8*, i8** %47, align 8, !tbaa !201
  %67 = add i64 %63, 1
  store i64 %67, i64* %42, align 8, !tbaa !200
  %68 = getelementptr inbounds i8, i8* %66, i64 %63
  store i8 %64, i8* %68, align 1, !tbaa !21
  br label %105

; <label>:69:                                     ; preds = %51
  %70 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 250) #16
  %71 = getelementptr inbounds i8, i8* %49, i64 1
  %72 = ptrtoint i8* %71 to i64
  %73 = sub i64 %45, %72
  br label %74

; <label>:74:                                     ; preds = %93, %69
  %75 = phi i8* [ getelementptr inbounds ([78 x i8], [78 x i8]* @.str.513, i64 0, i64 0), %69 ], [ %96, %93 ]
  %76 = phi i32 [ 1, %69 ], [ %95, %93 ]
  %77 = load i8, i8* %75, align 1, !tbaa !21
  %78 = icmp eq i8 %77, 0
  br i1 %78, label %97, label %79

; <label>:79:                                     ; preds = %74
  %80 = sext i32 %76 to i64
  %81 = icmp slt i64 %73, %80
  br i1 %81, label %97, label %82

; <label>:82:                                     ; preds = %79
  %83 = icmp eq i8 %77, 124
  br i1 %83, label %84, label %87

; <label>:84:                                     ; preds = %82
  %85 = add nsw i32 %76, 1
  %86 = sext i32 %85 to i64
  br label %93

; <label>:87:                                     ; preds = %82
  %88 = call i32 @memcmp(i8* nonnull %71, i8* %75, i64 %80) #21
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %90, label %93

; <label>:90:                                     ; preds = %87
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %46, i8* nonnull %71, i64 %80, i32 1, i1 false) #7
  %91 = getelementptr inbounds i8, i8* %46, i64 %80
  store i8 0, i8* %91, align 1, !tbaa !21
  %92 = getelementptr inbounds i8, i8* %71, i64 %80
  br label %100

; <label>:93:                                     ; preds = %87, %84
  %94 = phi i64 [ %86, %84 ], [ %80, %87 ]
  %95 = phi i32 [ %85, %84 ], [ %76, %87 ]
  %96 = getelementptr inbounds i8, i8* %75, i64 %94
  br label %74

; <label>:97:                                     ; preds = %79, %74
  %98 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.514, i64 0, i64 0), i8* nonnull %71) #17
  %99 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* nonnull %98) #17
  br label %100

; <label>:100:                                    ; preds = %90, %97
  %101 = phi i8* [ %92, %90 ], [ %71, %97 ]
  %102 = call i64 @strftime(i8* %70, i64 250, i8* nonnull %37, %struct.tm* nonnull %27) #17
  %103 = load i64, i64* %42, align 8, !tbaa !200
  %104 = add i64 %103, %102
  store i64 %104, i64* %42, align 8, !tbaa !200
  br label %105

; <label>:105:                                    ; preds = %100, %62
  %106 = phi i8* [ %65, %62 ], [ %101, %100 ]
  br label %48

; <label>:107:                                    ; preds = %48
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %38) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %37) #7
  br label %108

; <label>:108:                                    ; preds = %35, %107
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_difftime(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1) #17
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #17
  %4 = tail call double @difftime(i64 %2, i64 %3) #22
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_execute(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i32 @system(i8* %2) #17
  %4 = icmp eq i8* %2, null
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_execresult(%struct.lua_State* %0, i32 %3) #16
  br label %17

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = icmp ne i32 %3, 0
  %12 = zext i1 %11 to i32
  %13 = bitcast %struct.TValue* %10 to i32*
  store i32 %12, i32* %13, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 1, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %8, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ %6, %5 ], [ 1, %7 ]
  ret i32 %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_exit(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %4, label %8

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 1) #16
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  br label %11

; <label>:8:                                      ; preds = %1
  %9 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 1, i64 0) #16
  %10 = trunc i64 %9 to i32
  br label %11

; <label>:11:                                     ; preds = %8, %4
  %12 = phi i32 [ %7, %4 ], [ %10, %8 ]
  %13 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %16, label %15

; <label>:15:                                     ; preds = %11
  tail call void @lua_close(%struct.lua_State* %0) #16
  br label %16

; <label>:16:                                     ; preds = %11, %15
  %17 = icmp eq %struct.lua_State* %0, null
  br i1 %17, label %19, label %18

; <label>:18:                                     ; preds = %16
  tail call void @exit(i32 %12) #19
  unreachable

; <label>:19:                                     ; preds = %16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_getenv(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @getenv(i8* %2) #17
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_remove(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i32 @remove(i8* %2) #17
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* %2) #16
  ret i32 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_rename(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call i32 @rename(i8* %2, i8* %3) #17
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  %7 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %6, i8* null) #16
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_setlocale(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i64 0, i64 0), i8** getelementptr inbounds ([7 x i8*], [7 x i8*]* @os_setlocale.catnames, i64 0, i64 0)) #16
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [6 x i32], [6 x i32]* @os_setlocale.cat, i64 0, i64 %4
  %6 = load i32, i32* %5, align 4, !tbaa !74
  %7 = tail call i8* @setlocale(i32 %6, i8* %2) #17
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_time(%struct.lua_State*) #0 {
  %2 = alloca %struct.tm, align 8
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call i64 @time(i64* null) #17
  br label %29

; <label>:7:                                      ; preds = %1
  %8 = bitcast %struct.tm* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %8) #7
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %9 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0), i32 0, i32 0) #16
  %10 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 0
  store i32 %9, i32* %10, align 8, !tbaa !337
  %11 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0), i32 0, i32 0) #16
  %12 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 1
  store i32 %11, i32* %12, align 4, !tbaa !339
  %13 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0), i32 12, i32 0) #16
  %14 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 2
  store i32 %13, i32* %14, align 8, !tbaa !340
  %15 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0), i32 -1, i32 0) #16
  %16 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 3
  store i32 %15, i32* %16, align 4, !tbaa !341
  %17 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0), i32 -1, i32 1) #16
  %18 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 4
  store i32 %17, i32* %18, align 8, !tbaa !342
  %19 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0), i32 -1, i32 1900) #16
  %20 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 5
  store i32 %19, i32* %20, align 4, !tbaa !343
  %21 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0)) #17
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %7
  %24 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1) #17
  br label %25

; <label>:25:                                     ; preds = %7, %23
  %26 = phi i32 [ %24, %23 ], [ -1, %7 ]
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  %27 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 8
  store i32 %26, i32* %27, align 8, !tbaa !344
  %28 = call i64 @mktime(%struct.tm* nonnull %2) #17
  call fastcc void @setallfields(%struct.lua_State* %0, %struct.tm* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %8) #7
  br label %29

; <label>:29:                                     ; preds = %25, %5
  %30 = phi i64 [ %6, %5 ], [ %28, %25 ]
  %31 = icmp eq i64 %30, -1
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %29
  %33 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0)) #16
  unreachable

; <label>:34:                                     ; preds = %29
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %36 = bitcast %union.StackValue** %35 to %struct.TValue**
  %37 = load %struct.TValue*, %struct.TValue** %36, align 8, !tbaa !20
  %38 = bitcast %struct.TValue* %37 to i64*
  store i64 %30, i64* %38, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %37, i64 0, i32 1
  store i8 35, i8* %39, align 8, !tbaa !22
  %40 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %35, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @os_tmpname(%struct.lua_State*) #0 {
  %2 = alloca [20 x i8], align 16
  %3 = getelementptr inbounds [20 x i8], [20 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %3) #7
  %4 = call i8* @tmpnam(i8* nonnull %3) #17
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.523, i64 0, i64 0)) #16
  unreachable

; <label>:8:                                      ; preds = %1
  %9 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize
declare i64 @clock() local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare %struct.tm* @gmtime(i64*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare %struct.tm* @localtime(i64*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @setallfields(%struct.lua_State*, %struct.tm* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !337
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0), i32 %4) #16
  %5 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !339
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0), i32 %6) #16
  %7 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !340
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0), i32 %8) #16
  %9 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !341
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0), i32 %10) #16
  %11 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 4
  %12 = load i32, i32* %11, align 8, !tbaa !342
  %13 = add nsw i32 %12, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0), i32 %13) #16
  %14 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !343
  %16 = add nsw i32 %15, 1900
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0), i32 %16) #16
  %17 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 6
  %18 = load i32, i32* %17, align 8, !tbaa !345
  %19 = add nsw i32 %18, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.510, i64 0, i64 0), i32 %19) #16
  %20 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 7
  %21 = load i32, i32* %20, align 4, !tbaa !346
  %22 = add nsw i32 %21, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.511, i64 0, i64 0), i32 %22) #16
  %23 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 8
  %24 = load i32, i32* %23, align 8, !tbaa !344
  %25 = icmp slt i32 %24, 0
  br i1 %25, label %36, label %26

; <label>:26:                                     ; preds = %2
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %28 = bitcast %union.StackValue** %27 to %struct.TValue**
  %29 = load %struct.TValue*, %struct.TValue** %28, align 8, !tbaa !20
  %30 = icmp ne i32 %24, 0
  %31 = zext i1 %30 to i32
  %32 = bitcast %struct.TValue* %29 to i32*
  store i32 %31, i32* %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %29, i64 0, i32 1
  store i8 1, i8* %33, align 8, !tbaa !22
  %34 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %27, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0)) #17
  br label %36

; <label>:36:                                     ; preds = %2, %26
  ret void
}

; Function Attrs: minsize nounwind optsize
declare i64 @strftime(i8*, i64, i8*, %struct.tm*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @setfield(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = sext i32 %2 to i64
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to i64*
  store i64 %4, i64* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 35, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize readnone
declare double @difftime(i64, i64) local_unnamed_addr #8

; Function Attrs: minsize optsize
declare i32 @system(i8* nocapture readonly) local_unnamed_addr #11

; Function Attrs: minsize noreturn nounwind optsize
declare void @exit(i32) local_unnamed_addr #15

; Function Attrs: minsize nounwind optsize
declare i32 @remove(i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i32 @rename(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i8* @setlocale(i32, i8*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @getfield(%struct.lua_State*, i8*, i32, i32) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %6) #7
  %7 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1) #16
  %8 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %5) #16
  %9 = load i32, i32* %5, align 4, !tbaa !74
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %21

; <label>:11:                                     ; preds = %4
  %12 = icmp eq i32 %7, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %11
  %14 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.520, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = icmp slt i32 %2, 0
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %15
  %18 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.521, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:19:                                     ; preds = %15
  %20 = sext i32 %2 to i64
  br label %29

; <label>:21:                                     ; preds = %4
  %22 = add i64 %8, 1073741823
  %23 = icmp ult i64 %22, 2147483647
  br i1 %23, label %26, label %24

; <label>:24:                                     ; preds = %21
  %25 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.522, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:26:                                     ; preds = %21
  %27 = sext i32 %3 to i64
  %28 = sub nsw i64 %8, %27
  br label %29

; <label>:29:                                     ; preds = %19, %26
  %30 = phi i64 [ %28, %26 ], [ %20, %19 ]
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %31 = trunc i64 %30 to i32
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #7
  ret i32 %31
}

; Function Attrs: minsize nounwind optsize
declare i64 @mktime(%struct.tm* nocapture) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize
declare i8* @tmpnam(i8*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_byte(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %6 = load i64, i64* %2, align 8, !tbaa !135
  %7 = call fastcc i64 @posrelatI(i64 %5, i64 %6) #16
  %8 = call fastcc i64 @getendpos(%struct.lua_State* %0, i64 %5, i64 %6) #16
  %9 = icmp ult i64 %8, %7
  br i1 %9, label %37, label %10

; <label>:10:                                     ; preds = %1
  %11 = sub i64 %8, %7
  %12 = icmp ugt i64 %11, 2147483646
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %10
  %14 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  unreachable

; <label>:15:                                     ; preds = %10
  %16 = trunc i64 %11 to i32
  %17 = add nsw i32 %16, 1
  call void @luaL_checkstack(%struct.lua_State* %0, i32 %17, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  %18 = add i64 %7, -1
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = bitcast %union.StackValue** %19 to %struct.TValue**
  %21 = shl i64 %11, 32
  %22 = ashr exact i64 %21, 32
  br label %23

; <label>:23:                                     ; preds = %26, %15
  %24 = phi i64 [ %36, %26 ], [ 0, %15 ]
  %25 = icmp sgt i64 %24, %22
  br i1 %25, label %37, label %26

; <label>:26:                                     ; preds = %23
  %27 = add i64 %18, %24
  %28 = getelementptr inbounds i8, i8* %4, i64 %27
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = zext i8 %29 to i64
  %31 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to i64*
  store i64 %30, i64* %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 35, i8* %33, align 8, !tbaa !22
  %34 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %19, align 8, !tbaa !20
  %36 = add nuw nsw i64 %24, 1
  br label %23

; <label>:37:                                     ; preds = %23, %1
  %38 = phi i32 [ 0, %1 ], [ %17, %23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %38
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_char(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %13) #7
  %14 = shl i64 %12, 28
  %15 = ashr exact i64 %14, 32
  %16 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %15) #16
  %17 = shl i64 %12, 28
  %18 = ashr i64 %17, 32
  br label %19

; <label>:19:                                     ; preds = %28, %1
  %20 = phi i64 [ %32, %28 ], [ 1, %1 ]
  %21 = icmp sgt i64 %20, %18
  br i1 %21, label %33, label %22

; <label>:22:                                     ; preds = %19
  %23 = trunc i64 %20 to i32
  %24 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %23) #16
  %25 = icmp ult i64 %24, 256
  br i1 %25, label %28, label %26

; <label>:26:                                     ; preds = %22
  %27 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %23, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0)) #16
  br label %28

; <label>:28:                                     ; preds = %26, %22
  %29 = trunc i64 %24 to i8
  %30 = add nsw i64 %20, -1
  %31 = getelementptr inbounds i8, i8* %16, i64 %30
  store i8 %29, i8* %31, align 1, !tbaa !21
  %32 = add nuw nsw i64 %20, 1
  br label %19

; <label>:33:                                     ; preds = %19
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %2, i64 %15) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %13) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_dump(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %3) #7
  %4 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2) #16
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %5 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !202
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %7 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %6, %union.anon.6** %7, align 8, !tbaa !201
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %9 = bitcast i64* %8 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %9, align 8, !tbaa !135
  %10 = call i32 @lua_dump(%struct.lua_State* %0, i32 (%struct.lua_State*, i8*, i64, i8*)* nonnull @writer, i8* nonnull %3, i32 %4) #16
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %1
  %13 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.543, i64 0, i64 0)) #16
  unreachable

; <label>:14:                                     ; preds = %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_find(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_format(%struct.lua_State*) #0 {
  %2 = alloca [10 x i8], align 1
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = alloca [32 x i8], align 16
  %7 = alloca i64, align 8
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !49
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !61
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %21 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %4) #16
  %22 = load i64, i64* %4, align 8, !tbaa !135
  %23 = getelementptr inbounds i8, i8* %21, i64 %22
  %24 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %24) #7
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %25, align 8, !tbaa !202
  %26 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %27 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %26, %union.anon.6** %27, align 8, !tbaa !201
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %29 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %30 = bitcast i64* %29 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %30, align 8, !tbaa !135
  %31 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 0
  %32 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %33 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 1
  %34 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 2
  %35 = bitcast i64* %7 to i8*
  %36 = bitcast i64* %3 to i8*
  %37 = getelementptr inbounds [10 x i8], [10 x i8]* %2, i64 0, i64 0
  br label %38

; <label>:38:                                     ; preds = %361, %1
  %39 = phi i8* [ %164, %361 ], [ %21, %1 ]
  %40 = phi i32 [ %85, %361 ], [ 1, %1 ]
  br label %41

; <label>:41:                                     ; preds = %81, %38
  %42 = phi i8* [ %39, %38 ], [ %82, %81 ]
  %43 = icmp ult i8* %42, %23
  br i1 %43, label %44, label %368

; <label>:44:                                     ; preds = %41
  %45 = load i8, i8* %42, align 1, !tbaa !21
  %46 = icmp eq i8 %45, 37
  br i1 %46, label %62, label %47

; <label>:47:                                     ; preds = %44
  %48 = load i64, i64* %28, align 8, !tbaa !200
  %49 = load i64, i64* %29, align 8, !tbaa !198
  %50 = icmp ult i64 %48, %49
  br i1 %50, label %55, label %51

; <label>:51:                                     ; preds = %47
  %52 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #16
  %53 = load i8, i8* %42, align 1, !tbaa !21
  %54 = load i64, i64* %28, align 8, !tbaa !200
  br label %55

; <label>:55:                                     ; preds = %51, %47
  %56 = phi i64 [ %54, %51 ], [ %48, %47 ]
  %57 = phi i8 [ %53, %51 ], [ %45, %47 ]
  %58 = getelementptr inbounds i8, i8* %42, i64 1
  %59 = load i8*, i8** %32, align 8, !tbaa !201
  %60 = add i64 %56, 1
  store i64 %60, i64* %28, align 8, !tbaa !200
  %61 = getelementptr inbounds i8, i8* %59, i64 %56
  store i8 %57, i8* %61, align 1, !tbaa !21
  br label %81

; <label>:62:                                     ; preds = %44
  %63 = getelementptr inbounds i8, i8* %42, i64 1
  %64 = load i8, i8* %63, align 1, !tbaa !21
  %65 = icmp eq i8 %64, 37
  br i1 %65, label %66, label %83

; <label>:66:                                     ; preds = %62
  %67 = load i64, i64* %28, align 8, !tbaa !200
  %68 = load i64, i64* %29, align 8, !tbaa !198
  %69 = icmp ult i64 %67, %68
  br i1 %69, label %74, label %70

; <label>:70:                                     ; preds = %66
  %71 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #16
  %72 = load i8, i8* %63, align 1, !tbaa !21
  %73 = load i64, i64* %28, align 8, !tbaa !200
  br label %74

; <label>:74:                                     ; preds = %70, %66
  %75 = phi i64 [ %73, %70 ], [ %67, %66 ]
  %76 = phi i8 [ %72, %70 ], [ 37, %66 ]
  %77 = getelementptr inbounds i8, i8* %42, i64 2
  %78 = load i8*, i8** %32, align 8, !tbaa !201
  %79 = add i64 %75, 1
  store i64 %79, i64* %28, align 8, !tbaa !200
  %80 = getelementptr inbounds i8, i8* %78, i64 %75
  store i8 %76, i8* %80, align 1, !tbaa !21
  br label %81

; <label>:81:                                     ; preds = %74, %55
  %82 = phi i8* [ %58, %55 ], [ %77, %74 ]
  br label %41

; <label>:83:                                     ; preds = %62
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %31) #7
  %84 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 120) #16
  %85 = add nuw nsw i32 %40, 1
  %86 = icmp slt i32 %40, %19
  br i1 %86, label %87, label %366

; <label>:87:                                     ; preds = %83
  br label %88

; <label>:88:                                     ; preds = %87, %100
  %89 = phi i8* [ %101, %100 ], [ %63, %87 ]
  %90 = load i8, i8* %89, align 1, !tbaa !21
  %91 = icmp eq i8 %90, 0
  br i1 %91, label %102, label %92

; <label>:92:                                     ; preds = %88
  %93 = sext i8 %90 to i64
  %94 = and i64 %93, 4294967295
  %95 = icmp ult i64 %94, 64
  %96 = shl i64 1, %94
  %97 = and i64 %96, 325494096527361
  %98 = icmp ne i64 %97, 0
  %99 = and i1 %95, %98
  br i1 %99, label %100, label %102

; <label>:100:                                    ; preds = %92
  %101 = getelementptr inbounds i8, i8* %89, i64 1
  br label %88

; <label>:102:                                    ; preds = %92, %88
  %103 = phi i8 [ 0, %88 ], [ %90, %92 ]
  %104 = ptrtoint i8* %89 to i64
  %105 = ptrtoint i8* %63 to i64
  %106 = sub i64 %104, %105
  %107 = icmp ugt i64 %106, 5
  br i1 %107, label %108, label %110

; <label>:108:                                    ; preds = %102
  %109 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.559, i64 0, i64 0)) #17
  unreachable

; <label>:110:                                    ; preds = %102
  %111 = tail call i16** @__ctype_b_loc() #22
  %112 = load i16*, i16** %111, align 8, !tbaa !39
  %113 = zext i8 %103 to i64
  %114 = getelementptr inbounds i16, i16* %112, i64 %113
  %115 = load i16, i16* %114, align 2, !tbaa !317
  %116 = and i16 %115, 2048
  %117 = icmp eq i16 %116, 0
  %118 = getelementptr inbounds i8, i8* %89, i64 1
  %119 = select i1 %117, i8* %89, i8* %118
  %120 = load i8, i8* %119, align 1, !tbaa !21
  %121 = zext i8 %120 to i64
  %122 = getelementptr inbounds i16, i16* %112, i64 %121
  %123 = load i16, i16* %122, align 2, !tbaa !317
  %124 = and i16 %123, 2048
  %125 = icmp eq i16 %124, 0
  %126 = getelementptr inbounds i8, i8* %119, i64 1
  %127 = select i1 %125, i8* %119, i8* %126
  %128 = load i8, i8* %127, align 1, !tbaa !21
  %129 = icmp eq i8 %128, 46
  br i1 %129, label %130, label %149

; <label>:130:                                    ; preds = %110
  %131 = getelementptr inbounds i8, i8* %127, i64 1
  %132 = load i8, i8* %131, align 1, !tbaa !21
  %133 = zext i8 %132 to i64
  %134 = getelementptr inbounds i16, i16* %112, i64 %133
  %135 = load i16, i16* %134, align 2, !tbaa !317
  %136 = and i16 %135, 2048
  %137 = icmp eq i16 %136, 0
  %138 = getelementptr inbounds i8, i8* %127, i64 2
  %139 = select i1 %137, i8* %131, i8* %138
  %140 = load i8, i8* %139, align 1, !tbaa !21
  %141 = zext i8 %140 to i64
  %142 = getelementptr inbounds i16, i16* %112, i64 %141
  %143 = load i16, i16* %142, align 2, !tbaa !317
  %144 = and i16 %143, 2048
  %145 = icmp eq i16 %144, 0
  %146 = getelementptr inbounds i8, i8* %139, i64 1
  %147 = select i1 %145, i8* %139, i8* %146
  %148 = load i8, i8* %147, align 1, !tbaa !21
  br label %149

; <label>:149:                                    ; preds = %130, %110
  %150 = phi i8 [ %128, %110 ], [ %148, %130 ]
  %151 = phi i8* [ %127, %110 ], [ %147, %130 ]
  %152 = zext i8 %150 to i64
  %153 = getelementptr inbounds i16, i16* %112, i64 %152
  %154 = load i16, i16* %153, align 2, !tbaa !317
  %155 = and i16 %154, 2048
  %156 = icmp eq i16 %155, 0
  br i1 %156, label %159, label %157

; <label>:157:                                    ; preds = %149
  %158 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.560, i64 0, i64 0)) #17
  unreachable

; <label>:159:                                    ; preds = %149
  store i8 37, i8* %31, align 16, !tbaa !21
  %160 = ptrtoint i8* %151 to i64
  %161 = sub i64 %160, %105
  %162 = add nsw i64 %161, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %33, i8* nonnull %63, i64 %162, i32 1, i1 false) #7
  %163 = getelementptr inbounds i8, i8* %33, i64 %162
  store i8 0, i8* %163, align 1, !tbaa !21
  %164 = getelementptr inbounds i8, i8* %151, i64 1
  %165 = load i8, i8* %151, align 1, !tbaa !21
  %166 = sext i8 %165 to i32
  switch i32 %166, label %359 [
    i32 99, label %167
    i32 100, label %171
    i32 105, label %171
    i32 111, label %171
    i32 117, label %171
    i32 120, label %171
    i32 88, label %171
    i32 97, label %174
    i32 65, label %174
    i32 101, label %177
    i32 69, label %177
    i32 102, label %177
    i32 103, label %177
    i32 71, label %177
    i32 112, label %190
    i32 113, label %193
    i32 115, label %336
  ]

; <label>:167:                                    ; preds = %159
  %168 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %85) #16
  %169 = trunc i64 %168 to i32
  %170 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %84, i64 120, i8* nonnull %31, i32 %169) #17
  br label %361

; <label>:171:                                    ; preds = %159, %159, %159, %159, %159, %159
  %172 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %85) #16
  call fastcc void @addlenmod(i8* nonnull %31, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.554, i64 0, i64 0)) #16
  %173 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %84, i64 120, i8* nonnull %31, i64 %172) #17
  br label %361

; <label>:174:                                    ; preds = %159, %159
  call fastcc void @addlenmod(i8* nonnull %31, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  %175 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %85) #16
  %176 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %84, i64 120, i8* nonnull %31, double %175) #17
  br label %361

; <label>:177:                                    ; preds = %159, %159, %159, %159, %159
  %178 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %85) #16
  %179 = load i8, i8* %151, align 1, !tbaa !21
  %180 = icmp ne i8 %179, 102
  %181 = call double @llvm.fabs.f64(double %178)
  %182 = fcmp ult double %181, 1.000000e+100
  %183 = or i1 %180, %182
  br i1 %183, label %186, label %184

; <label>:184:                                    ; preds = %177
  %185 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 418) #16
  br label %186

; <label>:186:                                    ; preds = %177, %184
  %187 = phi i8* [ %185, %184 ], [ %84, %177 ]
  %188 = phi i64 [ 418, %184 ], [ 120, %177 ]
  call fastcc void @addlenmod(i8* nonnull %31, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  %189 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %187, i64 %188, i8* nonnull %31, double %178) #17
  br label %361

; <label>:190:                                    ; preds = %159
  %191 = call i8* @lua_topointer(%struct.lua_State* %0, i32 %85) #16
  %192 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %84, i64 120, i8* nonnull %31, i8* %191) #17
  br label %361

; <label>:193:                                    ; preds = %159
  %194 = load i8, i8* %34, align 2, !tbaa !21
  %195 = icmp eq i8 %194, 0
  br i1 %195, label %198, label %196

; <label>:196:                                    ; preds = %193
  %197 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.555, i64 0, i64 0)) #16
  unreachable

; <label>:198:                                    ; preds = %193
  %199 = call i32 @lua_type(%struct.lua_State* %0, i32 %85) #17
  switch i32 %199, label %334 [
    i32 4, label %200
    i32 3, label %294
    i32 0, label %332
    i32 1, label %332
  ]

; <label>:200:                                    ; preds = %198
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %36) #7
  %201 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %85, i64* nonnull %3) #17
  %202 = load i64, i64* %3, align 8, !tbaa !135
  %203 = load i64, i64* %28, align 8, !tbaa !200
  %204 = load i64, i64* %29, align 8, !tbaa !198
  %205 = icmp ult i64 %203, %204
  br i1 %205, label %209, label %206

; <label>:206:                                    ; preds = %200
  %207 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #17
  %208 = load i64, i64* %28, align 8, !tbaa !200
  br label %209

; <label>:209:                                    ; preds = %206, %200
  %210 = phi i64 [ %208, %206 ], [ %203, %200 ]
  %211 = load i8*, i8** %32, align 8, !tbaa !201
  %212 = add i64 %210, 1
  store i64 %212, i64* %28, align 8, !tbaa !200
  %213 = getelementptr inbounds i8, i8* %211, i64 %210
  store i8 34, i8* %213, align 1, !tbaa !21
  br label %214

; <label>:214:                                    ; preds = %280, %209
  %215 = phi i8* [ %201, %209 ], [ %281, %280 ]
  %216 = phi i64 [ %202, %209 ], [ %217, %280 ]
  %217 = add i64 %216, -1
  %218 = icmp eq i64 %216, 0
  br i1 %218, label %282, label %219

; <label>:219:                                    ; preds = %214
  %220 = load i8, i8* %215, align 1, !tbaa !21
  switch i8 %220, label %245 [
    i8 34, label %221
    i8 92, label %221
    i8 10, label %221
  ]

; <label>:221:                                    ; preds = %219, %219, %219
  %222 = load i64, i64* %28, align 8, !tbaa !200
  %223 = load i64, i64* %29, align 8, !tbaa !198
  %224 = icmp ult i64 %222, %223
  br i1 %224, label %228, label %225

; <label>:225:                                    ; preds = %221
  %226 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #17
  %227 = load i64, i64* %28, align 8, !tbaa !200
  br label %228

; <label>:228:                                    ; preds = %225, %221
  %229 = phi i64 [ %227, %225 ], [ %222, %221 ]
  %230 = load i8*, i8** %32, align 8, !tbaa !201
  %231 = add i64 %229, 1
  store i64 %231, i64* %28, align 8, !tbaa !200
  %232 = getelementptr inbounds i8, i8* %230, i64 %229
  store i8 92, i8* %232, align 1, !tbaa !21
  %233 = load i64, i64* %28, align 8, !tbaa !200
  %234 = load i64, i64* %29, align 8, !tbaa !198
  %235 = icmp ult i64 %233, %234
  br i1 %235, label %239, label %236

; <label>:236:                                    ; preds = %228
  %237 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #17
  %238 = load i64, i64* %28, align 8, !tbaa !200
  br label %239

; <label>:239:                                    ; preds = %236, %228
  %240 = phi i64 [ %238, %236 ], [ %233, %228 ]
  %241 = load i8, i8* %215, align 1, !tbaa !21
  %242 = load i8*, i8** %32, align 8, !tbaa !201
  %243 = add i64 %240, 1
  store i64 %243, i64* %28, align 8, !tbaa !200
  %244 = getelementptr inbounds i8, i8* %242, i64 %240
  store i8 %241, i8* %244, align 1, !tbaa !21
  br label %280

; <label>:245:                                    ; preds = %219
  %246 = load i16*, i16** %111, align 8, !tbaa !39
  %247 = zext i8 %220 to i64
  %248 = getelementptr inbounds i16, i16* %246, i64 %247
  %249 = load i16, i16* %248, align 2, !tbaa !317
  %250 = and i16 %249, 2
  %251 = icmp eq i16 %250, 0
  br i1 %251, label %266, label %252

; <label>:252:                                    ; preds = %245
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %37) #7
  %253 = getelementptr inbounds i8, i8* %215, i64 1
  %254 = load i8, i8* %253, align 1, !tbaa !21
  %255 = zext i8 %254 to i64
  %256 = getelementptr inbounds i16, i16* %246, i64 %255
  %257 = load i16, i16* %256, align 2, !tbaa !317
  %258 = and i16 %257, 2048
  %259 = icmp eq i16 %258, 0
  %260 = zext i8 %220 to i32
  br i1 %259, label %261, label %263

; <label>:261:                                    ; preds = %252
  %262 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %37, i64 10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.563, i64 0, i64 0), i32 %260) #17
  br label %265

; <label>:263:                                    ; preds = %252
  %264 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %37, i64 10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.564, i64 0, i64 0), i32 %260) #17
  br label %265

; <label>:265:                                    ; preds = %263, %261
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %37) #17
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %37) #7
  br label %280

; <label>:266:                                    ; preds = %245
  %267 = load i64, i64* %28, align 8, !tbaa !200
  %268 = load i64, i64* %29, align 8, !tbaa !198
  %269 = icmp ult i64 %267, %268
  br i1 %269, label %274, label %270

; <label>:270:                                    ; preds = %266
  %271 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #17
  %272 = load i8, i8* %215, align 1, !tbaa !21
  %273 = load i64, i64* %28, align 8, !tbaa !200
  br label %274

; <label>:274:                                    ; preds = %270, %266
  %275 = phi i64 [ %273, %270 ], [ %267, %266 ]
  %276 = phi i8 [ %272, %270 ], [ %220, %266 ]
  %277 = load i8*, i8** %32, align 8, !tbaa !201
  %278 = add i64 %275, 1
  store i64 %278, i64* %28, align 8, !tbaa !200
  %279 = getelementptr inbounds i8, i8* %277, i64 %275
  store i8 %276, i8* %279, align 1, !tbaa !21
  br label %280

; <label>:280:                                    ; preds = %274, %265, %239
  %281 = getelementptr inbounds i8, i8* %215, i64 1
  br label %214

; <label>:282:                                    ; preds = %214
  %283 = load i64, i64* %28, align 8, !tbaa !200
  %284 = load i64, i64* %29, align 8, !tbaa !198
  %285 = icmp ult i64 %283, %284
  br i1 %285, label %289, label %286

; <label>:286:                                    ; preds = %282
  %287 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1) #17
  %288 = load i64, i64* %28, align 8, !tbaa !200
  br label %289

; <label>:289:                                    ; preds = %286, %282
  %290 = phi i64 [ %288, %286 ], [ %283, %282 ]
  %291 = load i8*, i8** %32, align 8, !tbaa !201
  %292 = add i64 %290, 1
  store i64 %292, i64* %28, align 8, !tbaa !200
  %293 = getelementptr inbounds i8, i8* %291, i64 %290
  store i8 34, i8* %293, align 1, !tbaa !21
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %36) #7
  br label %361

; <label>:294:                                    ; preds = %198
  %295 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 120) #17
  %296 = call i32 @lua_isinteger(%struct.lua_State* %0, i32 %85) #17
  %297 = icmp eq i32 %296, 0
  br i1 %297, label %298, label %322

; <label>:298:                                    ; preds = %294
  %299 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %85, i32* null) #17
  %300 = fcmp oeq double %299, 0x7FF0000000000000
  br i1 %300, label %319, label %301

; <label>:301:                                    ; preds = %298
  %302 = fcmp oeq double %299, 0xFFF0000000000000
  br i1 %302, label %319, label %303

; <label>:303:                                    ; preds = %301
  %304 = fcmp uno double %299, 0.000000e+00
  br i1 %304, label %319, label %305

; <label>:305:                                    ; preds = %303
  %306 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %295, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.568, i64 0, i64 0), double %299) #17
  %307 = sext i32 %306 to i64
  %308 = call i8* @memchr(i8* %295, i32 46, i64 %307) #21
  %309 = icmp eq i8* %308, null
  br i1 %309, label %310, label %327

; <label>:310:                                    ; preds = %305
  %311 = call %struct.lconv* @localeconv() #17
  %312 = getelementptr inbounds %struct.lconv, %struct.lconv* %311, i64 0, i32 0
  %313 = load i8*, i8** %312, align 8, !tbaa !133
  %314 = load i8, i8* %313, align 1, !tbaa !21
  %315 = sext i8 %314 to i32
  %316 = call i8* @memchr(i8* %295, i32 %315, i64 %307) #21
  %317 = icmp eq i8* %316, null
  br i1 %317, label %327, label %318

; <label>:318:                                    ; preds = %310
  store i8 46, i8* %316, align 1, !tbaa !21
  br label %327

; <label>:319:                                    ; preds = %303, %301, %298
  %320 = phi i8* [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.565, i64 0, i64 0), %298 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.566, i64 0, i64 0), %301 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.567, i64 0, i64 0), %303 ]
  %321 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %295, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* nonnull %320) #17
  br label %327

; <label>:322:                                    ; preds = %294
  %323 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %85, i32* null) #17
  %324 = icmp eq i64 %323, -9223372036854775808
  %325 = select i1 %324, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.561, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0)
  %326 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %295, i64 120, i8* %325, i64 %323) #17
  br label %327

; <label>:327:                                    ; preds = %322, %319, %318, %310, %305
  %328 = phi i32 [ %326, %322 ], [ %321, %319 ], [ %306, %318 ], [ %306, %310 ], [ %306, %305 ]
  %329 = sext i32 %328 to i64
  %330 = load i64, i64* %28, align 8, !tbaa !200
  %331 = add i64 %330, %329
  store i64 %331, i64* %28, align 8, !tbaa !200
  br label %361

; <label>:332:                                    ; preds = %198, %198
  %333 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %85, i64* null) #17
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #17
  br label %361

; <label>:334:                                    ; preds = %198
  %335 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %85, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.562, i64 0, i64 0)) #17
  br label %361

; <label>:336:                                    ; preds = %159
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %35) #7
  %337 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %85, i64* nonnull %7) #16
  %338 = load i8, i8* %34, align 2, !tbaa !21
  %339 = icmp eq i8 %338, 0
  br i1 %339, label %340, label %341

; <label>:340:                                    ; preds = %336
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #16
  br label %357

; <label>:341:                                    ; preds = %336
  %342 = load i64, i64* %7, align 8, !tbaa !135
  %343 = call i64 @strlen(i8* %337) #21
  %344 = icmp eq i64 %342, %343
  br i1 %344, label %348, label %345

; <label>:345:                                    ; preds = %341
  %346 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %85, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0)) #16
  %347 = load i64, i64* %7, align 8
  br label %348

; <label>:348:                                    ; preds = %345, %341
  %349 = phi i64 [ %347, %345 ], [ %342, %341 ]
  %350 = call i8* @strchr(i8* nonnull %31, i32 46) #21
  %351 = icmp eq i8* %350, null
  %352 = icmp ugt i64 %349, 99
  %353 = and i1 %351, %352
  br i1 %353, label %354, label %355

; <label>:354:                                    ; preds = %348
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #16
  br label %357

; <label>:355:                                    ; preds = %348
  %356 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %84, i64 120, i8* nonnull %31, i8* %337) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %357

; <label>:357:                                    ; preds = %354, %355, %340
  %358 = phi i32 [ 0, %340 ], [ 0, %354 ], [ %356, %355 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %35) #7
  br label %361

; <label>:359:                                    ; preds = %159
  %360 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.557, i64 0, i64 0), i8* nonnull %31) #16
  unreachable

; <label>:361:                                    ; preds = %167, %171, %174, %186, %190, %357, %289, %327, %332, %334
  %362 = phi i32 [ %358, %357 ], [ %192, %190 ], [ %189, %186 ], [ %176, %174 ], [ %173, %171 ], [ %170, %167 ], [ 0, %289 ], [ 0, %327 ], [ 0, %332 ], [ 0, %334 ]
  %363 = sext i32 %362 to i64
  %364 = load i64, i64* %28, align 8, !tbaa !200
  %365 = add i64 %364, %363
  store i64 %365, i64* %28, align 8, !tbaa !200
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %31) #7
  br label %38

; <label>:366:                                    ; preds = %83
  %367 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %85, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i64 0, i64 0)) #16
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %31) #7
  br label %369

; <label>:368:                                    ; preds = %41
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  br label %369

; <label>:369:                                    ; preds = %366, %368
  %370 = phi i32 [ %367, %366 ], [ 1, %368 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %24) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  ret i32 %370
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @gmatch(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %3) #16
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %9 = load i64, i64* %2, align 8, !tbaa !135
  %10 = call fastcc i64 @posrelatI(i64 %8, i64 %9) #16
  %11 = add i64 %10, -1
  call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %12 = call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 576, i32 0) #16
  %13 = load i64, i64* %2, align 8, !tbaa !135
  %14 = icmp ugt i64 %11, %13
  %15 = add i64 %13, 1
  %16 = select i1 %14, i64 %15, i64 %11
  %17 = getelementptr inbounds i8, i8* %12, i64 24
  %18 = load i64, i64* %3, align 8, !tbaa !135
  %19 = getelementptr inbounds i8, i8* %12, i64 48
  %20 = bitcast i8* %19 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %20, align 8, !tbaa !347
  %21 = getelementptr inbounds i8, i8* %12, i64 56
  %22 = bitcast i8* %21 to i32*
  store i32 200, i32* %22, align 8, !tbaa !349
  %23 = bitcast i8* %17 to i8**
  store i8* %6, i8** %23, align 8, !tbaa !350
  %24 = getelementptr inbounds i8, i8* %6, i64 %13
  %25 = getelementptr inbounds i8, i8* %12, i64 32
  %26 = bitcast i8* %25 to i8**
  store i8* %24, i8** %26, align 8, !tbaa !351
  %27 = getelementptr inbounds i8, i8* %7, i64 %18
  %28 = getelementptr inbounds i8, i8* %12, i64 40
  %29 = bitcast i8* %28 to i8**
  store i8* %27, i8** %29, align 8, !tbaa !352
  %30 = getelementptr inbounds i8, i8* %6, i64 %16
  %31 = bitcast i8* %12 to i8**
  store i8* %30, i8** %31, align 8, !tbaa !353
  %32 = getelementptr inbounds i8, i8* %12, i64 8
  %33 = bitcast i8* %32 to i8**
  store i8* %7, i8** %33, align 8, !tbaa !355
  %34 = getelementptr inbounds i8, i8* %12, i64 16
  %35 = bitcast i8* %34 to i8**
  store i8* null, i8** %35, align 8, !tbaa !356
  call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @gmatch_aux, i32 3) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_gsub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca %struct.MatchState, align 8
  %7 = alloca %struct.luaL_Buffer, align 8
  %8 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %4) #16
  %11 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %5) #16
  %12 = call i32 @lua_type(%struct.lua_State* %0, i32 3) #16
  %13 = load i64, i64* %4, align 8, !tbaa !135
  %14 = add i64 %13, 1
  %15 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 %14) #16
  %16 = load i8, i8* %11, align 1, !tbaa !21
  %17 = icmp eq i8 %16, 94
  %18 = bitcast %struct.MatchState* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %18) #7
  %19 = bitcast %struct.luaL_Buffer* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %19) #7
  %20 = add i32 %12, -3
  %21 = icmp ult i32 %20, 4
  br i1 %21, label %24, label %22

; <label>:22:                                     ; preds = %1
  %23 = call i32 @luaL_typeerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.569, i64 0, i64 0)) #16
  br label %24

; <label>:24:                                     ; preds = %22, %1
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %25, align 8, !tbaa !202
  %26 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 4
  %27 = bitcast %struct.luaL_Buffer* %7 to %union.anon.6**
  store %union.anon.6* %26, %union.anon.6** %27, align 8, !tbaa !201
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 2
  %29 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 1
  %30 = bitcast i64* %29 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %30, align 8, !tbaa !135
  br i1 %17, label %33, label %31

; <label>:31:                                     ; preds = %24
  %32 = load i64, i64* %5, align 8, !tbaa !135
  br label %37

; <label>:33:                                     ; preds = %24
  %34 = getelementptr inbounds i8, i8* %11, i64 1
  %35 = load i64, i64* %5, align 8, !tbaa !135
  %36 = add i64 %35, -1
  store i64 %36, i64* %5, align 8, !tbaa !135
  br label %37

; <label>:37:                                     ; preds = %31, %33
  %38 = phi i64 [ %36, %33 ], [ %32, %31 ]
  %39 = phi i8* [ %34, %33 ], [ %11, %31 ]
  %40 = load i64, i64* %4, align 8, !tbaa !135
  %41 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %41, align 8, !tbaa !347
  %42 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 4
  store i32 200, i32* %42, align 8, !tbaa !349
  %43 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 0
  store i8* %10, i8** %43, align 8, !tbaa !350
  %44 = getelementptr inbounds i8, i8* %10, i64 %40
  %45 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 1
  store i8* %44, i8** %45, align 8, !tbaa !351
  %46 = getelementptr inbounds i8, i8* %39, i64 %38
  %47 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 2
  store i8* %46, i8** %47, align 8, !tbaa !352
  %48 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 5
  %49 = bitcast i64* %2 to i8*
  %50 = bitcast i8** %3 to i8*
  %51 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 0
  br label %52

; <label>:52:                                     ; preds = %166, %37
  %53 = phi i8* [ null, %37 ], [ %167, %166 ]
  %54 = phi i64 [ 0, %37 ], [ %168, %166 ]
  %55 = phi i32 [ 0, %37 ], [ %169, %166 ]
  %56 = phi i8* [ %10, %37 ], [ %170, %166 ]
  %57 = icmp slt i64 %54, %15
  br i1 %57, label %58, label %171

; <label>:58:                                     ; preds = %52
  store i8 0, i8* %48, align 4, !tbaa !357
  %59 = call fastcc i8* @match(%struct.MatchState* nonnull %6, i8* %56, i8* %39) #16
  %60 = icmp eq i8* %59, null
  %61 = icmp eq i8* %59, %53
  %62 = or i1 %60, %61
  br i1 %62, label %149, label %63

; <label>:63:                                     ; preds = %58
  %64 = add nsw i64 %54, 1
  %65 = load %struct.lua_State*, %struct.lua_State** %41, align 8, !tbaa !347
  switch i32 %12, label %70 [
    i32 6, label %66
    i32 5, label %68
  ]

; <label>:66:                                     ; preds = %63
  call void @lua_pushvalue(%struct.lua_State* %65, i32 3) #17
  %67 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %6, i8* %56, i8* nonnull %59) #17
  call void @lua_callk(%struct.lua_State* %65, i32 %67, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #17
  br label %128

; <label>:68:                                     ; preds = %63
  call fastcc void @push_onecapture(%struct.MatchState* nonnull %6, i32 0, i8* %56, i8* nonnull %59) #17
  %69 = call i32 @lua_gettable(%struct.lua_State* %65, i32 3) #17
  br label %128

; <label>:70:                                     ; preds = %63
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %49) #7
  %71 = call i8* @lua_tolstring(%struct.lua_State* %65, i32 3, i64* nonnull %2) #17
  %72 = ptrtoint i8* %59 to i64
  %73 = ptrtoint i8* %56 to i64
  %74 = sub i64 %72, %73
  %75 = load i64, i64* %2, align 8, !tbaa !135
  br label %76

; <label>:76:                                     ; preds = %121, %70
  %77 = phi i64 [ %75, %70 ], [ %126, %121 ]
  %78 = phi i8* [ %71, %70 ], [ %122, %121 ]
  %79 = call i8* @memchr(i8* %78, i32 37, i64 %77) #21
  %80 = icmp eq i8* %79, null
  br i1 %80, label %127, label %81

; <label>:81:                                     ; preds = %76
  %82 = ptrtoint i8* %79 to i64
  %83 = ptrtoint i8* %78 to i64
  %84 = sub i64 %82, %83
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %78, i64 %84) #17
  %85 = getelementptr inbounds i8, i8* %79, i64 1
  %86 = load i8, i8* %85, align 1, !tbaa !21
  switch i8 %86, label %102 [
    i8 37, label %87
    i8 48, label %101
  ]

; <label>:87:                                     ; preds = %81
  %88 = load i64, i64* %28, align 8, !tbaa !200
  %89 = load i64, i64* %29, align 8, !tbaa !198
  %90 = icmp ult i64 %88, %89
  br i1 %90, label %95, label %91

; <label>:91:                                     ; preds = %87
  %92 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1) #17
  %93 = load i8, i8* %85, align 1, !tbaa !21
  %94 = load i64, i64* %28, align 8, !tbaa !200
  br label %95

; <label>:95:                                     ; preds = %91, %87
  %96 = phi i64 [ %94, %91 ], [ %88, %87 ]
  %97 = phi i8 [ %93, %91 ], [ 37, %87 ]
  %98 = load i8*, i8** %51, align 8, !tbaa !201
  %99 = add i64 %96, 1
  store i64 %99, i64* %28, align 8, !tbaa !200
  %100 = getelementptr inbounds i8, i8* %98, i64 %96
  store i8 %97, i8* %100, align 1, !tbaa !21
  br label %121

; <label>:101:                                    ; preds = %81
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %56, i64 %74) #17
  br label %121

; <label>:102:                                    ; preds = %81
  %103 = tail call i16** @__ctype_b_loc() #22
  %104 = load i16*, i16** %103, align 8, !tbaa !39
  %105 = zext i8 %86 to i64
  %106 = getelementptr inbounds i16, i16* %104, i64 %105
  %107 = load i16, i16* %106, align 2, !tbaa !317
  %108 = and i16 %107, 2048
  %109 = icmp eq i16 %108, 0
  br i1 %109, label %119, label %110

; <label>:110:                                    ; preds = %102
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %50) #7
  %111 = sext i8 %86 to i32
  %112 = add nsw i32 %111, -49
  %113 = call fastcc i64 @get_onecapture(%struct.MatchState* nonnull %6, i32 %112, i8* %56, i8* %59, i8** nonnull %3) #17
  %114 = icmp eq i64 %113, -2
  br i1 %114, label %115, label %116

; <label>:115:                                    ; preds = %110
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %7) #17
  br label %118

; <label>:116:                                    ; preds = %110
  %117 = load i8*, i8** %3, align 8, !tbaa !39
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %117, i64 %113) #17
  br label %118

; <label>:118:                                    ; preds = %116, %115
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %50) #7
  br label %121

; <label>:119:                                    ; preds = %102
  %120 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %65, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.571, i64 0, i64 0), i32 37) #17
  unreachable

; <label>:121:                                    ; preds = %118, %101, %95
  %122 = getelementptr inbounds i8, i8* %79, i64 2
  %123 = ptrtoint i8* %122 to i64
  %124 = load i64, i64* %2, align 8, !tbaa !135
  %125 = sub i64 %83, %123
  %126 = add i64 %124, %125
  store i64 %126, i64* %2, align 8, !tbaa !135
  br label %76

; <label>:127:                                    ; preds = %76
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %78, i64 %77) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %49) #7
  br label %146

; <label>:128:                                    ; preds = %68, %66
  %129 = call i32 @lua_toboolean(%struct.lua_State* %65, i32 -1) #17
  %130 = icmp eq i32 %129, 0
  br i1 %130, label %131, label %135

; <label>:131:                                    ; preds = %128
  call void @lua_settop(%struct.lua_State* %65, i32 -2) #17
  %132 = ptrtoint i8* %59 to i64
  %133 = ptrtoint i8* %56 to i64
  %134 = sub i64 %132, %133
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %56, i64 %134) #17
  br label %146

; <label>:135:                                    ; preds = %128
  %136 = call i32 @lua_isstring(%struct.lua_State* %65, i32 -1) #17
  %137 = icmp eq i32 %136, 0
  br i1 %137, label %138, label %145

; <label>:138:                                    ; preds = %135
  %139 = call i32 @lua_type(%struct.lua_State* %65, i32 -1) #17
  %140 = add nsw i32 %139, 1
  %141 = sext i32 %140 to i64
  %142 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %141
  %143 = load i8*, i8** %142, align 8, !tbaa !39
  %144 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %65, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.570, i64 0, i64 0), i8* %143) #17
  unreachable

; <label>:145:                                    ; preds = %135
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %7) #17
  br label %146

; <label>:146:                                    ; preds = %127, %131, %145
  %147 = phi i32 [ 1, %127 ], [ 1, %145 ], [ 0, %131 ]
  %148 = or i32 %147, %55
  br label %166

; <label>:149:                                    ; preds = %58
  %150 = load i8*, i8** %45, align 8, !tbaa !351
  %151 = icmp ult i8* %56, %150
  br i1 %151, label %152, label %171

; <label>:152:                                    ; preds = %149
  %153 = load i64, i64* %28, align 8, !tbaa !200
  %154 = load i64, i64* %29, align 8, !tbaa !198
  %155 = icmp ult i64 %153, %154
  br i1 %155, label %159, label %156

; <label>:156:                                    ; preds = %152
  %157 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1) #16
  %158 = load i64, i64* %28, align 8, !tbaa !200
  br label %159

; <label>:159:                                    ; preds = %156, %152
  %160 = phi i64 [ %158, %156 ], [ %153, %152 ]
  %161 = getelementptr inbounds i8, i8* %56, i64 1
  %162 = load i8, i8* %56, align 1, !tbaa !21
  %163 = load i8*, i8** %51, align 8, !tbaa !201
  %164 = add i64 %160, 1
  store i64 %164, i64* %28, align 8, !tbaa !200
  %165 = getelementptr inbounds i8, i8* %163, i64 %160
  store i8 %162, i8* %165, align 1, !tbaa !21
  br label %166

; <label>:166:                                    ; preds = %146, %159
  %167 = phi i8* [ %59, %146 ], [ %53, %159 ]
  %168 = phi i64 [ %64, %146 ], [ %54, %159 ]
  %169 = phi i32 [ %148, %146 ], [ %55, %159 ]
  %170 = phi i8* [ %59, %146 ], [ %161, %159 ]
  br i1 %17, label %171, label %52

; <label>:171:                                    ; preds = %166, %149, %52
  %172 = phi i64 [ %168, %166 ], [ %54, %52 ], [ %54, %149 ]
  %173 = phi i32 [ %169, %166 ], [ %55, %52 ], [ %55, %149 ]
  %174 = phi i8* [ %170, %166 ], [ %56, %52 ], [ %56, %149 ]
  %175 = icmp eq i32 %173, 0
  br i1 %175, label %176, label %177

; <label>:176:                                    ; preds = %171
  call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  br label %182

; <label>:177:                                    ; preds = %171
  %178 = bitcast i8** %45 to i64*
  %179 = load i64, i64* %178, align 8, !tbaa !351
  %180 = ptrtoint i8* %174 to i64
  %181 = sub i64 %179, %180
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %7, i8* %174, i64 %181) #16
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %7) #16
  br label %182

; <label>:182:                                    ; preds = %177, %176
  %183 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %184 = bitcast %union.StackValue** %183 to %struct.TValue**
  %185 = load %struct.TValue*, %struct.TValue** %184, align 8, !tbaa !20
  %186 = bitcast %struct.TValue* %185 to i64*
  store i64 %172, i64* %186, align 8, !tbaa !21
  %187 = getelementptr inbounds %struct.TValue, %struct.TValue* %185, i64 0, i32 1
  store i8 35, i8* %187, align 8, !tbaa !22
  %188 = load %union.StackValue*, %union.StackValue** %183, align 8, !tbaa !20
  %189 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 1
  store %union.StackValue* %189, %union.StackValue** %183, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %19) #7
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %18) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  ret i32 2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_len(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = load i64, i64* %2, align 8, !tbaa !135
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 35, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_lower(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !135
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7) #16
  br label %9

; <label>:9:                                      ; preds = %13, %1
  %10 = phi i64 [ 0, %1 ], [ %23, %13 ]
  %11 = load i64, i64* %2, align 8, !tbaa !135
  %12 = icmp ult i64 %10, %11
  br i1 %12, label %13, label %24

; <label>:13:                                     ; preds = %9
  %14 = tail call i32** @__ctype_tolower_loc() #22
  %15 = load i32*, i32** %14, align 8, !tbaa !39
  %16 = getelementptr inbounds i8, i8* %6, i64 %10
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  %19 = getelementptr inbounds i32, i32* %15, i64 %18
  %20 = load i32, i32* %19, align 4, !tbaa !74
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds i8, i8* %8, i64 %10
  store i8 %21, i8* %22, align 1, !tbaa !21
  %23 = add i64 %10, 1
  br label %9

; <label>:24:                                     ; preds = %9
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %11) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_match(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_rep(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %8 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %9 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3) #16
  %10 = icmp slt i64 %8, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %1
  %12 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %47

; <label>:13:                                     ; preds = %1
  %14 = load i64, i64* %2, align 8, !tbaa !135
  %15 = load i64, i64* %3, align 8, !tbaa !135
  %16 = add i64 %15, %14
  %17 = icmp ult i64 %16, %14
  br i1 %17, label %21, label %18

; <label>:18:                                     ; preds = %13
  %19 = udiv i64 2147483647, %8
  %20 = icmp ugt i64 %16, %19
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %18, %13
  %22 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.572, i64 0, i64 0)) #16
  unreachable

; <label>:23:                                     ; preds = %18
  %24 = mul i64 %14, %8
  %25 = add nsw i64 %8, -1
  %26 = mul i64 %15, %25
  %27 = add i64 %26, %24
  %28 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %28) #7
  %29 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %4, i64 %27) #16
  br label %30

; <label>:30:                                     ; preds = %41, %23
  %31 = phi i64 [ %8, %23 ], [ %33, %41 ]
  %32 = phi i8* [ %29, %23 ], [ %42, %41 ]
  %33 = add nsw i64 %31, -1
  %34 = icmp sgt i64 %31, 1
  %35 = load i64, i64* %2, align 8, !tbaa !135
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %32, i8* %7, i64 %35, i32 1, i1 false)
  br i1 %34, label %36, label %46

; <label>:36:                                     ; preds = %30
  %37 = load i64, i64* %2, align 8, !tbaa !135
  %38 = getelementptr inbounds i8, i8* %32, i64 %37
  %39 = load i64, i64* %3, align 8, !tbaa !135
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %41, label %43

; <label>:41:                                     ; preds = %36, %43
  %42 = phi i8* [ %38, %36 ], [ %45, %43 ]
  br label %30

; <label>:43:                                     ; preds = %36
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %38, i8* %9, i64 %39, i32 1, i1 false)
  %44 = load i64, i64* %3, align 8, !tbaa !135
  %45 = getelementptr inbounds i8, i8* %38, i64 %44
  br label %41

; <label>:46:                                     ; preds = %30
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %4, i64 %27) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %28) #7
  br label %47

; <label>:47:                                     ; preds = %11, %46
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_reverse(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !135
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7) #16
  br label %9

; <label>:9:                                      ; preds = %13, %1
  %10 = phi i64 [ 0, %1 ], [ %19, %13 ]
  %11 = load i64, i64* %2, align 8, !tbaa !135
  %12 = icmp ugt i64 %11, %10
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %9
  %14 = xor i64 %10, -1
  %15 = add i64 %11, %14
  %16 = getelementptr inbounds i8, i8* %6, i64 %15
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = getelementptr inbounds i8, i8* %8, i64 %10
  store i8 %17, i8* %18, align 1, !tbaa !21
  %19 = add i64 %10, 1
  br label %9

; <label>:20:                                     ; preds = %9
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %11) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_sub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %6 = load i64, i64* %2, align 8, !tbaa !135
  %7 = call fastcc i64 @posrelatI(i64 %5, i64 %6) #16
  %8 = call fastcc i64 @getendpos(%struct.lua_State* %0, i64 -1, i64 %6) #16
  %9 = icmp ult i64 %8, %7
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds i8, i8* %4, i64 %7
  %12 = getelementptr inbounds i8, i8* %11, i64 -1
  %13 = sub i64 1, %7
  %14 = add i64 %13, %8
  %15 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* nonnull %12, i64 %14) #16
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_upper(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !135
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7) #16
  br label %9

; <label>:9:                                      ; preds = %13, %1
  %10 = phi i64 [ 0, %1 ], [ %23, %13 ]
  %11 = load i64, i64* %2, align 8, !tbaa !135
  %12 = icmp ult i64 %10, %11
  br i1 %12, label %13, label %24

; <label>:13:                                     ; preds = %9
  %14 = tail call i32** @__ctype_toupper_loc() #22
  %15 = load i32*, i32** %14, align 8, !tbaa !39
  %16 = getelementptr inbounds i8, i8* %6, i64 %10
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  %19 = getelementptr inbounds i32, i32* %15, i64 %18
  %20 = load i32, i32* %19, align 4, !tbaa !74
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds i8, i8* %8, i64 %10
  store i8 %21, i8* %22, align 1, !tbaa !21
  %23 = add i64 %10, 1
  br label %9

; <label>:24:                                     ; preds = %9
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %11) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_pack(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca %struct.Header, align 8
  %4 = alloca i8*, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %11) #7
  %12 = bitcast %struct.Header* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %12) #7
  %13 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %13) #7
  %14 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %14, i8** %4, align 8, !tbaa !39
  %15 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %15, align 8, !tbaa !358
  %16 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  store i32 1, i32* %16, align 8, !tbaa !360
  %17 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 2
  store i32 1, i32* %17, align 4, !tbaa !361
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = bitcast %union.StackValue** %18 to %struct.TValue**
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !20
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  store i8 0, i8* %21, align 8, !tbaa !21
  %22 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %18, align 8, !tbaa !20
  %24 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %24, align 8, !tbaa !202
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %26 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %25, %union.anon.6** %26, align 8, !tbaa !201
  %27 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %29 = bitcast i64* %28 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %29, align 8, !tbaa !135
  %30 = bitcast i32* %5 to i8*
  %31 = bitcast i32* %6 to i8*
  %32 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  %33 = bitcast %union.Ftypes* %7 to i8*
  %34 = bitcast i64* %8 to i8*
  %35 = bitcast i64* %9 to i8*
  %36 = bitcast i64* %10 to i8*
  %37 = bitcast %union.Ftypes* %7 to float*
  %38 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  br label %39

; <label>:39:                                     ; preds = %193, %1
  %40 = phi i8* [ %14, %1 ], [ %196, %193 ]
  %41 = phi i64 [ 0, %1 ], [ %194, %193 ]
  %42 = phi i32 [ 1, %1 ], [ %195, %193 ]
  %43 = load i8, i8* %40, align 1, !tbaa !21
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %197, label %45

; <label>:45:                                     ; preds = %39
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %30) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %31) #7
  %46 = call fastcc i32 @getdetails(%struct.Header* nonnull %3, i64 %41, i8** nonnull %4, i32* nonnull %5, i32* nonnull %6) #16
  %47 = load i32, i32* %6, align 4, !tbaa !74
  %48 = load i32, i32* %5, align 4, !tbaa !74
  %49 = add nsw i32 %48, %47
  %50 = sext i32 %49 to i64
  br label %51

; <label>:51:                                     ; preds = %62, %45
  %52 = phi i32 [ %53, %62 ], [ %47, %45 ]
  %53 = add nsw i32 %52, -1
  %54 = icmp sgt i32 %52, 0
  br i1 %54, label %55, label %67

; <label>:55:                                     ; preds = %51
  %56 = load i64, i64* %27, align 8, !tbaa !200
  %57 = load i64, i64* %28, align 8, !tbaa !198
  %58 = icmp ult i64 %56, %57
  br i1 %58, label %62, label %59

; <label>:59:                                     ; preds = %55
  %60 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1) #16
  %61 = load i64, i64* %27, align 8, !tbaa !200
  br label %62

; <label>:62:                                     ; preds = %59, %55
  %63 = phi i64 [ %61, %59 ], [ %56, %55 ]
  %64 = load i8*, i8** %32, align 8, !tbaa !201
  %65 = add i64 %63, 1
  store i64 %65, i64* %27, align 8, !tbaa !200
  %66 = getelementptr inbounds i8, i8* %64, i64 %63
  store i8 0, i8* %66, align 1, !tbaa !21
  br label %51

; <label>:67:                                     ; preds = %51
  %68 = add i64 %41, %50
  store i32 %53, i32* %6, align 4, !tbaa !74
  %69 = add nsw i32 %42, 1
  switch i32 %46, label %193 [
    i32 0, label %70
    i32 1, label %88
    i32 2, label %100
    i32 3, label %112
    i32 4, label %139
    i32 5, label %156
    i32 6, label %180
    i32 7, label %192
    i32 8, label %192
  ]

; <label>:70:                                     ; preds = %67
  %71 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %69) #16
  %72 = icmp slt i32 %48, 8
  br i1 %72, label %73, label %84

; <label>:73:                                     ; preds = %70
  %74 = shl i32 %48, 3
  %75 = add nsw i32 %74, -1
  %76 = zext i32 %75 to i64
  %77 = shl i64 1, %76
  %78 = sub nsw i64 0, %77
  %79 = icmp sge i64 %71, %78
  %80 = icmp slt i64 %71, %77
  %81 = and i1 %79, %80
  br i1 %81, label %84, label %82

; <label>:82:                                     ; preds = %73
  %83 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %69, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0)) #16
  br label %84

; <label>:84:                                     ; preds = %82, %73, %70
  %85 = load i32, i32* %16, align 8, !tbaa !360
  %86 = lshr i64 %71, 63
  %87 = trunc i64 %86 to i32
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %71, i32 %85, i32 %48, i32 %87) #16
  br label %193

; <label>:88:                                     ; preds = %67
  %89 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %69) #16
  %90 = icmp slt i32 %48, 8
  br i1 %90, label %91, label %98

; <label>:91:                                     ; preds = %88
  %92 = shl nsw i32 %48, 3
  %93 = zext i32 %92 to i64
  %94 = shl i64 1, %93
  %95 = icmp ult i64 %89, %94
  br i1 %95, label %98, label %96

; <label>:96:                                     ; preds = %91
  %97 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %69, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.573, i64 0, i64 0)) #16
  br label %98

; <label>:98:                                     ; preds = %91, %96, %88
  %99 = load i32, i32* %16, align 8, !tbaa !360
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %89, i32 %99, i32 %48, i32 0) #16
  br label %193

; <label>:100:                                    ; preds = %67
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %33) #7
  %101 = sext i32 %48 to i64
  %102 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %101) #16
  %103 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %69) #16
  %104 = icmp eq i32 %48, 4
  br i1 %104, label %105, label %107

; <label>:105:                                    ; preds = %100
  %106 = fptrunc double %103 to float
  store volatile float %106, float* %37, align 8, !tbaa !21
  br label %108

; <label>:107:                                    ; preds = %100
  store volatile double %103, double* %38, align 8, !tbaa !21
  br label %108

; <label>:108:                                    ; preds = %107, %105
  %109 = load i32, i32* %16, align 8, !tbaa !360
  call fastcc void @copywithendian(i8* %102, i8* nonnull %33, i32 %48, i32 %109) #16
  %110 = load i64, i64* %27, align 8, !tbaa !200
  %111 = add i64 %110, %101
  store i64 %111, i64* %27, align 8, !tbaa !200
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %33) #7
  br label %193

; <label>:112:                                    ; preds = %67
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %34) #7
  %113 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %69, i64* nonnull %8) #16
  %114 = load i64, i64* %8, align 8, !tbaa !135
  %115 = sext i32 %48 to i64
  %116 = icmp ugt i64 %114, %115
  br i1 %116, label %117, label %120

; <label>:117:                                    ; preds = %112
  %118 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %69, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.574, i64 0, i64 0)) #16
  %119 = load i64, i64* %8, align 8, !tbaa !135
  br label %120

; <label>:120:                                    ; preds = %112, %117
  %121 = phi i64 [ %114, %112 ], [ %119, %117 ]
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %113, i64 %121) #16
  br label %122

; <label>:122:                                    ; preds = %133, %120
  %123 = load i64, i64* %8, align 8, !tbaa !135
  %124 = add i64 %123, 1
  store i64 %124, i64* %8, align 8, !tbaa !135
  %125 = icmp ult i64 %123, %115
  br i1 %125, label %126, label %138

; <label>:126:                                    ; preds = %122
  %127 = load i64, i64* %27, align 8, !tbaa !200
  %128 = load i64, i64* %28, align 8, !tbaa !198
  %129 = icmp ult i64 %127, %128
  br i1 %129, label %133, label %130

; <label>:130:                                    ; preds = %126
  %131 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1) #16
  %132 = load i64, i64* %27, align 8, !tbaa !200
  br label %133

; <label>:133:                                    ; preds = %130, %126
  %134 = phi i64 [ %132, %130 ], [ %127, %126 ]
  %135 = load i8*, i8** %32, align 8, !tbaa !201
  %136 = add i64 %134, 1
  store i64 %136, i64* %27, align 8, !tbaa !200
  %137 = getelementptr inbounds i8, i8* %135, i64 %134
  store i8 0, i8* %137, align 1, !tbaa !21
  br label %122

; <label>:138:                                    ; preds = %122
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %34) #7
  br label %193

; <label>:139:                                    ; preds = %67
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %35) #7
  %140 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %69, i64* nonnull %9) #16
  %141 = icmp sgt i32 %48, 7
  br i1 %141, label %150, label %142

; <label>:142:                                    ; preds = %139
  %143 = load i64, i64* %9, align 8, !tbaa !135
  %144 = shl nsw i32 %48, 3
  %145 = zext i32 %144 to i64
  %146 = shl i64 1, %145
  %147 = icmp ult i64 %143, %146
  br i1 %147, label %150, label %148

; <label>:148:                                    ; preds = %142
  %149 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %69, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.575, i64 0, i64 0)) #16
  br label %150

; <label>:150:                                    ; preds = %148, %142, %139
  %151 = load i64, i64* %9, align 8, !tbaa !135
  %152 = load i32, i32* %16, align 8, !tbaa !360
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %151, i32 %152, i32 %48, i32 0) #16
  %153 = load i64, i64* %9, align 8, !tbaa !135
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %140, i64 %153) #16
  %154 = load i64, i64* %9, align 8, !tbaa !135
  %155 = add i64 %154, %68
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %35) #7
  br label %193

; <label>:156:                                    ; preds = %67
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %36) #7
  %157 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %69, i64* nonnull %10) #16
  %158 = call i64 @strlen(i8* %157) #21
  %159 = load i64, i64* %10, align 8, !tbaa !135
  %160 = icmp eq i64 %158, %159
  br i1 %160, label %164, label %161

; <label>:161:                                    ; preds = %156
  %162 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %69, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0)) #16
  %163 = load i64, i64* %10, align 8, !tbaa !135
  br label %164

; <label>:164:                                    ; preds = %161, %156
  %165 = phi i64 [ %163, %161 ], [ %158, %156 ]
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %157, i64 %165) #16
  %166 = load i64, i64* %27, align 8, !tbaa !200
  %167 = load i64, i64* %28, align 8, !tbaa !198
  %168 = icmp ult i64 %166, %167
  br i1 %168, label %172, label %169

; <label>:169:                                    ; preds = %164
  %170 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1) #16
  %171 = load i64, i64* %27, align 8, !tbaa !200
  br label %172

; <label>:172:                                    ; preds = %169, %164
  %173 = phi i64 [ %171, %169 ], [ %166, %164 ]
  %174 = load i8*, i8** %32, align 8, !tbaa !201
  %175 = add i64 %173, 1
  store i64 %175, i64* %27, align 8, !tbaa !200
  %176 = getelementptr inbounds i8, i8* %174, i64 %173
  store i8 0, i8* %176, align 1, !tbaa !21
  %177 = load i64, i64* %10, align 8, !tbaa !135
  %178 = add i64 %68, 1
  %179 = add i64 %178, %177
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %36) #7
  br label %193

; <label>:180:                                    ; preds = %67
  %181 = load i64, i64* %27, align 8, !tbaa !200
  %182 = load i64, i64* %28, align 8, !tbaa !198
  %183 = icmp ult i64 %181, %182
  br i1 %183, label %187, label %184

; <label>:184:                                    ; preds = %180
  %185 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1) #16
  %186 = load i64, i64* %27, align 8, !tbaa !200
  br label %187

; <label>:187:                                    ; preds = %184, %180
  %188 = phi i64 [ %186, %184 ], [ %181, %180 ]
  %189 = load i8*, i8** %32, align 8, !tbaa !201
  %190 = add i64 %188, 1
  store i64 %190, i64* %27, align 8, !tbaa !200
  %191 = getelementptr inbounds i8, i8* %189, i64 %188
  store i8 0, i8* %191, align 1, !tbaa !21
  br label %192

; <label>:192:                                    ; preds = %67, %67, %187
  br label %193

; <label>:193:                                    ; preds = %67, %192, %172, %150, %138, %108, %98, %84
  %194 = phi i64 [ %68, %67 ], [ %68, %192 ], [ %179, %172 ], [ %155, %150 ], [ %68, %138 ], [ %68, %108 ], [ %68, %98 ], [ %68, %84 ]
  %195 = phi i32 [ %69, %67 ], [ %42, %192 ], [ %69, %172 ], [ %69, %150 ], [ %69, %138 ], [ %69, %108 ], [ %69, %98 ], [ %69, %84 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %31) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %30) #7
  %196 = load i8*, i8** %4, align 8, !tbaa !39
  br label %39

; <label>:197:                                    ; preds = %39
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %11) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_packsize(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %8, i8** %3, align 8, !tbaa !39
  %9 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %9, align 8, !tbaa !358
  %10 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  store i32 1, i32* %10, align 8, !tbaa !360
  %11 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 2
  store i32 1, i32* %11, align 4, !tbaa !361
  %12 = bitcast i32* %4 to i8*
  %13 = bitcast i32* %5 to i8*
  br label %14

; <label>:14:                                     ; preds = %34, %1
  %15 = phi i8* [ %8, %1 ], [ %36, %34 ]
  %16 = phi i64 [ 0, %1 ], [ %35, %34 ]
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %37, label %19

; <label>:19:                                     ; preds = %14
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %13) #7
  %20 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %16, i8** nonnull %3, i32* nonnull %4, i32* nonnull %5) #16
  %21 = or i32 %20, 1
  %22 = icmp eq i32 %21, 5
  br i1 %22, label %23, label %25

; <label>:23:                                     ; preds = %19
  %24 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.581, i64 0, i64 0)) #16
  br label %25

; <label>:25:                                     ; preds = %19, %23
  %26 = load i32, i32* %5, align 4, !tbaa !74
  %27 = load i32, i32* %4, align 4, !tbaa !74
  %28 = add nsw i32 %27, %26
  store i32 %28, i32* %4, align 4, !tbaa !74
  %29 = sext i32 %28 to i64
  %30 = sub nsw i64 2147483647, %29
  %31 = icmp ugt i64 %16, %30
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %25
  %33 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.582, i64 0, i64 0)) #16
  br label %34

; <label>:34:                                     ; preds = %25, %32
  %35 = add i64 %16, %29
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #7
  %36 = load i8*, i8** %3, align 8, !tbaa !39
  br label %14

; <label>:37:                                     ; preds = %14
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %39 = bitcast %union.StackValue** %38 to %struct.TValue**
  %40 = load %struct.TValue*, %struct.TValue** %39, align 8, !tbaa !20
  %41 = bitcast %struct.TValue* %40 to i64*
  store i64 %16, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 1
  store %union.StackValue* %44, %union.StackValue** %38, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @str_unpack(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i64, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %10, i8** %3, align 8, !tbaa !39
  %11 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %11) #7
  %12 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4) #16
  %13 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %14 = load i64, i64* %4, align 8, !tbaa !135
  %15 = call fastcc i64 @posrelatI(i64 %13, i64 %14) #16
  %16 = add i64 %15, -1
  %17 = icmp ugt i64 %16, %14
  br i1 %17, label %18, label %20

; <label>:18:                                     ; preds = %1
  %19 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0)) #16
  br label %20

; <label>:20:                                     ; preds = %1, %18
  %21 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %21, align 8, !tbaa !358
  %22 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  store i32 1, i32* %22, align 8, !tbaa !360
  %23 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 2
  store i32 1, i32* %23, align 4, !tbaa !361
  %24 = bitcast i32* %5 to i8*
  %25 = bitcast i32* %6 to i8*
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = bitcast %union.Ftypes* %7 to i8*
  %29 = bitcast %union.Ftypes* %7 to float*
  %30 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  br label %31

; <label>:31:                                     ; preds = %110, %20
  %32 = phi i8* [ %10, %20 ], [ %114, %110 ]
  %33 = phi i32 [ 0, %20 ], [ %111, %110 ]
  %34 = phi i64 [ %16, %20 ], [ %113, %110 ]
  %35 = load i8, i8* %32, align 1, !tbaa !21
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %115, label %37

; <label>:37:                                     ; preds = %31
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %24) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %25) #7
  %38 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %34, i8** nonnull %3, i32* nonnull %5, i32* nonnull %6) #16
  %39 = load i32, i32* %6, align 4, !tbaa !74
  %40 = sext i32 %39 to i64
  %41 = load i32, i32* %5, align 4, !tbaa !74
  %42 = sext i32 %41 to i64
  %43 = add nsw i64 %42, %40
  %44 = load i64, i64* %4, align 8, !tbaa !135
  %45 = sub i64 %44, %34
  %46 = icmp ugt i64 %43, %45
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %37
  %48 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0)) #16
  br label %49

; <label>:49:                                     ; preds = %37, %47
  %50 = add i64 %34, %40
  call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.585, i64 0, i64 0)) #16
  %51 = add nsw i32 %33, 1
  switch i32 %38, label %110 [
    i32 0, label %52
    i32 1, label %52
    i32 2, label %63
    i32 3, label %79
    i32 4, label %82
    i32 5, label %96
    i32 7, label %109
    i32 6, label %109
    i32 8, label %109
  ]

; <label>:52:                                     ; preds = %49, %49
  %53 = getelementptr inbounds i8, i8* %12, i64 %50
  %54 = load i32, i32* %22, align 8, !tbaa !360
  %55 = icmp eq i32 %38, 0
  %56 = zext i1 %55 to i32
  %57 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %53, i32 %54, i32 %41, i32 %56) #16
  %58 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %59 = bitcast %struct.TValue* %58 to i64*
  store i64 %57, i64* %59, align 8, !tbaa !21
  %60 = getelementptr inbounds %struct.TValue, %struct.TValue* %58, i64 0, i32 1
  store i8 35, i8* %60, align 8, !tbaa !22
  %61 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 1
  store %union.StackValue* %62, %union.StackValue** %26, align 8, !tbaa !20
  br label %110

; <label>:63:                                     ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %28) #7
  %64 = getelementptr inbounds i8, i8* %12, i64 %50
  %65 = load i32, i32* %22, align 8, !tbaa !360
  call fastcc void @copywithendian(i8* nonnull %28, i8* %64, i32 %41, i32 %65) #16
  %66 = icmp eq i32 %41, 4
  br i1 %66, label %67, label %70

; <label>:67:                                     ; preds = %63
  %68 = load volatile float, float* %29, align 8, !tbaa !21
  %69 = fpext float %68 to double
  br label %72

; <label>:70:                                     ; preds = %63
  %71 = load volatile double, double* %30, align 8, !tbaa !21
  br label %72

; <label>:72:                                     ; preds = %70, %67
  %73 = phi double [ %69, %67 ], [ %71, %70 ]
  %74 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %75 = bitcast %struct.TValue* %74 to double*
  store double %73, double* %75, align 8, !tbaa !21
  %76 = getelementptr inbounds %struct.TValue, %struct.TValue* %74, i64 0, i32 1
  store i8 19, i8* %76, align 8, !tbaa !22
  %77 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %77, i64 1
  store %union.StackValue* %78, %union.StackValue** %26, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %28) #7
  br label %110

; <label>:79:                                     ; preds = %49
  %80 = getelementptr inbounds i8, i8* %12, i64 %50
  %81 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %80, i64 %42) #16
  br label %110

; <label>:82:                                     ; preds = %49
  %83 = getelementptr inbounds i8, i8* %12, i64 %50
  %84 = load i32, i32* %22, align 8, !tbaa !360
  %85 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %83, i32 %84, i32 %41, i32 0) #16
  %86 = load i64, i64* %4, align 8, !tbaa !135
  %87 = add i64 %50, %42
  %88 = sub i64 %86, %87
  %89 = icmp ugt i64 %85, %88
  br i1 %89, label %90, label %92

; <label>:90:                                     ; preds = %82
  %91 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0)) #16
  br label %92

; <label>:92:                                     ; preds = %82, %90
  %93 = getelementptr inbounds i8, i8* %83, i64 %42
  %94 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %93, i64 %85) #16
  %95 = add i64 %85, %50
  br label %110

; <label>:96:                                     ; preds = %49
  %97 = getelementptr inbounds i8, i8* %12, i64 %50
  %98 = call i64 @strlen(i8* %97) #21
  %99 = shl i64 %98, 32
  %100 = ashr exact i64 %99, 32
  %101 = add i64 %100, %50
  %102 = load i64, i64* %4, align 8, !tbaa !135
  %103 = icmp ult i64 %101, %102
  br i1 %103, label %106, label %104

; <label>:104:                                    ; preds = %96
  %105 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.586, i64 0, i64 0)) #16
  br label %106

; <label>:106:                                    ; preds = %104, %96
  %107 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %97, i64 %100) #16
  %108 = add i64 %101, 1
  br label %110

; <label>:109:                                    ; preds = %49, %49, %49
  br label %110

; <label>:110:                                    ; preds = %49, %109, %106, %92, %79, %72, %52
  %111 = phi i32 [ %51, %49 ], [ %33, %109 ], [ %51, %106 ], [ %51, %92 ], [ %51, %79 ], [ %51, %72 ], [ %51, %52 ]
  %112 = phi i64 [ %50, %49 ], [ %50, %109 ], [ %108, %106 ], [ %95, %92 ], [ %50, %79 ], [ %50, %72 ], [ %50, %52 ]
  %113 = add i64 %112, %42
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %25) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %24) #7
  %114 = load i8*, i8** %3, align 8, !tbaa !39
  br label %31

; <label>:115:                                    ; preds = %31
  %116 = add i64 %34, 1
  %117 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %118 = bitcast %struct.TValue* %117 to i64*
  store i64 %116, i64* %118, align 8, !tbaa !21
  %119 = getelementptr inbounds %struct.TValue, %struct.TValue* %117, i64 0, i32 1
  store i8 35, i8* %119, align 8, !tbaa !22
  %120 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %120, i64 1
  store %union.StackValue* %121, %union.StackValue** %26, align 8, !tbaa !20
  %122 = add nsw i32 %33, 1
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %122
}

; Function Attrs: minsize norecurse nounwind optsize readnone uwtable
define internal fastcc i64 @posrelatI(i64, i64) unnamed_addr #6 {
  %3 = icmp sgt i64 %0, 0
  br i1 %3, label %12, label %4

; <label>:4:                                      ; preds = %2
  %5 = icmp eq i64 %0, 0
  %6 = sub nsw i64 0, %1
  %7 = icmp sgt i64 %6, %0
  %8 = or i1 %5, %7
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %4
  %10 = add i64 %0, 1
  %11 = add i64 %10, %1
  br label %12

; <label>:12:                                     ; preds = %4, %2, %9
  %13 = phi i64 [ %11, %9 ], [ %0, %2 ], [ 1, %4 ]
  ret i64 %13
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @getendpos(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %1) #16
  %5 = icmp sgt i64 %4, %2
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %3
  %7 = icmp sgt i64 %4, -1
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %6
  %9 = sub nsw i64 0, %2
  %10 = icmp slt i64 %4, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %8
  %12 = add i64 %2, 1
  %13 = add i64 %12, %4
  br label %14

; <label>:14:                                     ; preds = %8, %6, %3, %11
  %15 = phi i64 [ %13, %11 ], [ %2, %3 ], [ %4, %6 ], [ 0, %8 ]
  ret i64 %15
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @writer(%struct.lua_State* nocapture readnone, i8* nocapture readonly, i64, i8*) #0 {
  %5 = bitcast i8* %3 to %struct.luaL_Buffer*
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %5, i8* %1, i64 %2) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @str_find_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.MatchState, align 8
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %9 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4) #16
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %11 = load i64, i64* %3, align 8, !tbaa !135
  %12 = call fastcc i64 @posrelatI(i64 %10, i64 %11) #16
  %13 = add i64 %12, -1
  %14 = icmp ult i64 %11, %13
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %2
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = bitcast %union.StackValue** %16 to %struct.TValue**
  %18 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !20
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 0, i8* %19, align 8, !tbaa !21
  %20 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %16, align 8, !tbaa !20
  br label %152

; <label>:22:                                     ; preds = %2
  %23 = icmp ne i32 %1, 0
  br i1 %23, label %24, label %88

; <label>:24:                                     ; preds = %22
  %25 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4) #16
  %26 = icmp eq i32 %25, 0
  %27 = load i64, i64* %4, align 8, !tbaa !135
  br i1 %26, label %28, label %39

; <label>:28:                                     ; preds = %24
  br label %29

; <label>:29:                                     ; preds = %28, %34
  %30 = phi i64 [ %37, %34 ], [ 0, %28 ]
  %31 = getelementptr inbounds i8, i8* %9, i64 %30
  %32 = call i8* @strpbrk(i8* %31, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.544, i64 0, i64 0)) #21
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %88

; <label>:34:                                     ; preds = %29
  %35 = call i64 @strlen(i8* %31) #21
  %36 = add i64 %30, 1
  %37 = add i64 %36, %35
  %38 = icmp ugt i64 %37, %27
  br i1 %38, label %39, label %29

; <label>:39:                                     ; preds = %34, %24
  %40 = getelementptr inbounds i8, i8* %8, i64 %13
  %41 = sub i64 %11, %13
  %42 = icmp eq i64 %27, 0
  br i1 %42, label %67, label %43

; <label>:43:                                     ; preds = %39
  %44 = icmp ugt i64 %27, %41
  br i1 %44, label %145, label %45

; <label>:45:                                     ; preds = %43
  %46 = add i64 %27, -1
  %47 = sub i64 %41, %46
  %48 = getelementptr inbounds i8, i8* %9, i64 1
  br label %49

; <label>:49:                                     ; preds = %62, %45
  %50 = phi i8* [ %40, %45 ], [ %59, %62 ]
  %51 = phi i64 [ %47, %45 ], [ %66, %62 ]
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %145, label %53

; <label>:53:                                     ; preds = %49
  %54 = load i8, i8* %9, align 1, !tbaa !21
  %55 = sext i8 %54 to i32
  %56 = call i8* @memchr(i8* %50, i32 %55, i64 %51) #21
  %57 = icmp eq i8* %56, null
  br i1 %57, label %145, label %58

; <label>:58:                                     ; preds = %53
  %59 = getelementptr inbounds i8, i8* %56, i64 1
  %60 = call i32 @memcmp(i8* nonnull %59, i8* nonnull %48, i64 %46) #21
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %69, label %62

; <label>:62:                                     ; preds = %58
  %63 = ptrtoint i8* %59 to i64
  %64 = ptrtoint i8* %50 to i64
  %65 = add i64 %51, %64
  %66 = sub i64 %65, %63
  br label %49

; <label>:67:                                     ; preds = %39
  %68 = icmp eq i8* %40, null
  br i1 %68, label %145, label %69

; <label>:69:                                     ; preds = %58, %67
  %70 = phi i8* [ %40, %67 ], [ %56, %58 ]
  %71 = ptrtoint i8* %70 to i64
  %72 = ptrtoint i8* %8 to i64
  %73 = sub i64 %71, %72
  %74 = add nsw i64 %73, 1
  %75 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %76 = bitcast %union.StackValue** %75 to %struct.TValue**
  %77 = load %struct.TValue*, %struct.TValue** %76, align 8, !tbaa !20
  %78 = bitcast %struct.TValue* %77 to i64*
  store i64 %74, i64* %78, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.TValue, %struct.TValue* %77, i64 0, i32 1
  store i8 35, i8* %79, align 8, !tbaa !22
  %80 = load %union.StackValue*, %union.StackValue** %75, align 8, !tbaa !20
  %81 = getelementptr inbounds %union.StackValue, %union.StackValue* %80, i64 1
  store %union.StackValue* %81, %union.StackValue** %75, align 8, !tbaa !20
  %82 = load i64, i64* %4, align 8, !tbaa !135
  %83 = add i64 %82, %73
  %84 = bitcast %union.StackValue* %81 to i64*
  store i64 %83, i64* %84, align 8, !tbaa !21
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %80, i64 1, i32 0, i32 1
  store i8 35, i8* %85, align 8, !tbaa !22
  %86 = load %union.StackValue*, %union.StackValue** %75, align 8, !tbaa !20
  %87 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 1
  store %union.StackValue* %87, %union.StackValue** %75, align 8, !tbaa !20
  br label %152

; <label>:88:                                     ; preds = %29, %22
  %89 = bitcast %struct.MatchState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %89) #7
  %90 = getelementptr inbounds i8, i8* %8, i64 %13
  %91 = load i8, i8* %9, align 1, !tbaa !21
  %92 = icmp eq i8 %91, 94
  br i1 %92, label %95, label %93

; <label>:93:                                     ; preds = %88
  %94 = load i64, i64* %4, align 8, !tbaa !135
  br label %99

; <label>:95:                                     ; preds = %88
  %96 = getelementptr inbounds i8, i8* %9, i64 1
  %97 = load i64, i64* %4, align 8, !tbaa !135
  %98 = add i64 %97, -1
  store i64 %98, i64* %4, align 8, !tbaa !135
  br label %99

; <label>:99:                                     ; preds = %93, %95
  %100 = phi i64 [ %98, %95 ], [ %94, %93 ]
  %101 = phi i8* [ %96, %95 ], [ %9, %93 ]
  %102 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %102, align 8, !tbaa !347
  %103 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 4
  store i32 200, i32* %103, align 8, !tbaa !349
  %104 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 0
  store i8* %8, i8** %104, align 8, !tbaa !350
  %105 = getelementptr inbounds i8, i8* %8, i64 %11
  %106 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 1
  store i8* %105, i8** %106, align 8, !tbaa !351
  %107 = getelementptr inbounds i8, i8* %101, i64 %100
  %108 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 2
  store i8* %107, i8** %108, align 8, !tbaa !352
  %109 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 5
  br label %110

; <label>:110:                                    ; preds = %140, %99
  %111 = phi i8* [ %90, %99 ], [ %141, %140 ]
  store i8 0, i8* %109, align 4, !tbaa !357
  %112 = call fastcc i8* @match(%struct.MatchState* nonnull %5, i8* %111, i8* %101) #16
  %113 = icmp eq i8* %112, null
  br i1 %113, label %137, label %114

; <label>:114:                                    ; preds = %110
  br i1 %23, label %115, label %135

; <label>:115:                                    ; preds = %114
  %116 = ptrtoint i8* %111 to i64
  %117 = ptrtoint i8* %8 to i64
  %118 = sub i64 1, %117
  %119 = add i64 %118, %116
  %120 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %121 = bitcast %union.StackValue** %120 to %struct.TValue**
  %122 = load %struct.TValue*, %struct.TValue** %121, align 8, !tbaa !20
  %123 = bitcast %struct.TValue* %122 to i64*
  store i64 %119, i64* %123, align 8, !tbaa !21
  %124 = getelementptr inbounds %struct.TValue, %struct.TValue* %122, i64 0, i32 1
  store i8 35, i8* %124, align 8, !tbaa !22
  %125 = load %union.StackValue*, %union.StackValue** %120, align 8, !tbaa !20
  %126 = getelementptr inbounds %union.StackValue, %union.StackValue* %125, i64 1
  store %union.StackValue* %126, %union.StackValue** %120, align 8, !tbaa !20
  %127 = ptrtoint i8* %112 to i64
  %128 = sub i64 %127, %117
  %129 = bitcast %union.StackValue* %126 to i64*
  store i64 %128, i64* %129, align 8, !tbaa !21
  %130 = getelementptr inbounds %union.StackValue, %union.StackValue* %125, i64 1, i32 0, i32 1
  store i8 35, i8* %130, align 8, !tbaa !22
  %131 = load %union.StackValue*, %union.StackValue** %120, align 8, !tbaa !20
  %132 = getelementptr inbounds %union.StackValue, %union.StackValue* %131, i64 1
  store %union.StackValue* %132, %union.StackValue** %120, align 8, !tbaa !20
  %133 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* null, i8* null) #16
  %134 = add nsw i32 %133, 2
  br label %143

; <label>:135:                                    ; preds = %114
  %136 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* %111, i8* nonnull %112) #16
  br label %143

; <label>:137:                                    ; preds = %110
  %138 = load i8*, i8** %106, align 8, !tbaa !351
  %139 = icmp ult i8* %111, %138
  br i1 %139, label %140, label %142

; <label>:140:                                    ; preds = %137
  %141 = getelementptr inbounds i8, i8* %111, i64 1
  br i1 %92, label %142, label %110

; <label>:142:                                    ; preds = %140, %137
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %89) #7
  br label %145

; <label>:143:                                    ; preds = %115, %135
  %144 = phi i32 [ %136, %135 ], [ %134, %115 ]
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %89) #7
  br label %152

; <label>:145:                                    ; preds = %53, %49, %43, %142, %67
  %146 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %147 = bitcast %union.StackValue** %146 to %struct.TValue**
  %148 = load %struct.TValue*, %struct.TValue** %147, align 8, !tbaa !20
  %149 = getelementptr inbounds %struct.TValue, %struct.TValue* %148, i64 0, i32 1
  store i8 0, i8* %149, align 8, !tbaa !21
  %150 = load %union.StackValue*, %union.StackValue** %146, align 8, !tbaa !20
  %151 = getelementptr inbounds %union.StackValue, %union.StackValue* %150, i64 1
  store %union.StackValue* %151, %union.StackValue** %146, align 8, !tbaa !20
  br label %152

; <label>:152:                                    ; preds = %143, %69, %145, %15
  %153 = phi i32 [ 1, %15 ], [ 1, %145 ], [ %144, %143 ], [ 2, %69 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 %153
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @match(%struct.MatchState*, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !349
  %6 = add nsw i32 %5, -1
  store i32 %6, i32* %4, align 8, !tbaa !349
  %7 = icmp eq i32 %5, 0
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !347
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.545, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %14 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 0
  %15 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %17 = bitcast i8** %16 to i64*
  br label %18

; <label>:18:                                     ; preds = %116, %12
  %19 = phi i8* [ %2, %12 ], [ %117, %116 ]
  %20 = phi i8* [ %1, %12 ], [ %118, %116 ]
  %21 = getelementptr inbounds i8, i8* %20, i64 -1
  %22 = getelementptr inbounds i8, i8* %20, i64 1
  br label %23

; <label>:23:                                     ; preds = %185, %18
  %24 = phi i8* [ %19, %18 ], [ %186, %185 ]
  br label %25

; <label>:25:                                     ; preds = %139, %23
  %26 = phi i8* [ %128, %139 ], [ %24, %23 ]
  %27 = load i8*, i8** %13, align 8, !tbaa !352
  %28 = icmp eq i8* %26, %27
  br i1 %28, label %226, label %29

; <label>:29:                                     ; preds = %25
  %30 = load i8, i8* %26, align 1, !tbaa !21
  %31 = sext i8 %30 to i32
  switch i32 %31, label %177 [
    i32 40, label %32
    i32 41, label %41
    i32 36, label %69
    i32 37, label %76
  ]

; <label>:32:                                     ; preds = %29
  %33 = getelementptr inbounds i8, i8* %26, i64 1
  %34 = load i8, i8* %33, align 1, !tbaa !21
  %35 = icmp eq i8 %34, 41
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds i8, i8* %26, i64 2
  %38 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %37, i32 -2) #16
  br label %226

; <label>:39:                                     ; preds = %32
  %40 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %33, i32 -1) #16
  br label %226

; <label>:41:                                     ; preds = %29
  %42 = getelementptr inbounds i8, i8* %26, i64 1
  %43 = load i8, i8* %15, align 4, !tbaa !357
  %44 = zext i8 %43 to i64
  br label %45

; <label>:45:                                     ; preds = %49, %41
  %46 = phi i64 [ %47, %49 ], [ %44, %41 ]
  %47 = add nsw i64 %46, -1
  %48 = icmp sgt i64 %46, 0
  br i1 %48, label %49, label %53

; <label>:49:                                     ; preds = %45
  %50 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %47, i32 1
  %51 = load i64, i64* %50, align 8, !tbaa !362
  %52 = icmp eq i64 %51, -1
  br i1 %52, label %57, label %45

; <label>:53:                                     ; preds = %45
  %54 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %55 = load %struct.lua_State*, %struct.lua_State** %54, align 8, !tbaa !347
  %56 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %55, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.548, i64 0, i64 0)) #17
  unreachable

; <label>:57:                                     ; preds = %49
  %58 = shl i64 %47, 32
  %59 = ashr exact i64 %58, 32
  %60 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %59
  %61 = bitcast %struct.anon.11* %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !364
  %63 = ptrtoint i8* %20 to i64
  %64 = sub i64 %63, %62
  %65 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %59, i32 1
  store i64 %64, i64* %65, align 8, !tbaa !362
  %66 = tail call fastcc i8* @match(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %42) #17
  %67 = icmp eq i8* %66, null
  br i1 %67, label %68, label %226

; <label>:68:                                     ; preds = %57
  store i64 -1, i64* %65, align 8, !tbaa !362
  br label %226

; <label>:69:                                     ; preds = %29
  %70 = getelementptr inbounds i8, i8* %26, i64 1
  %71 = icmp eq i8* %70, %27
  br i1 %71, label %72, label %177

; <label>:72:                                     ; preds = %69
  %73 = load i8*, i8** %16, align 8, !tbaa !351
  %74 = icmp eq i8* %20, %73
  %75 = select i1 %74, i8* %20, i8* null
  br label %226

; <label>:76:                                     ; preds = %29
  %77 = getelementptr inbounds i8, i8* %26, i64 1
  %78 = load i8, i8* %77, align 1, !tbaa !21
  %79 = sext i8 %78 to i32
  switch i32 %79, label %177 [
    i32 98, label %80
    i32 102, label %119
    i32 48, label %144
    i32 49, label %144
    i32 50, label %144
    i32 51, label %144
    i32 52, label %144
    i32 53, label %144
    i32 54, label %144
    i32 55, label %144
    i32 56, label %144
    i32 57, label %144
  ]

; <label>:80:                                     ; preds = %76
  %81 = getelementptr inbounds i8, i8* %26, i64 2
  %82 = getelementptr inbounds i8, i8* %27, i64 -1
  %83 = icmp ugt i8* %82, %81
  br i1 %83, label %88, label %84

; <label>:84:                                     ; preds = %80
  %85 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %86 = load %struct.lua_State*, %struct.lua_State** %85, align 8, !tbaa !347
  %87 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %86, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.549, i64 0, i64 0)) #17
  unreachable

; <label>:88:                                     ; preds = %80
  %89 = load i8, i8* %20, align 1, !tbaa !21
  %90 = load i8, i8* %81, align 1, !tbaa !21
  %91 = icmp eq i8 %89, %90
  br i1 %91, label %92, label %226

; <label>:92:                                     ; preds = %88
  %93 = getelementptr inbounds i8, i8* %26, i64 3
  %94 = load i8, i8* %93, align 1, !tbaa !21
  %95 = load i8*, i8** %16, align 8, !tbaa !351
  br label %96

; <label>:96:                                     ; preds = %111, %92
  %97 = phi i8* [ %20, %92 ], [ %99, %111 ]
  %98 = phi i32 [ 1, %92 ], [ %112, %111 ]
  %99 = getelementptr inbounds i8, i8* %97, i64 1
  %100 = icmp ult i8* %99, %95
  br i1 %100, label %101, label %226

; <label>:101:                                    ; preds = %96
  %102 = load i8, i8* %99, align 1, !tbaa !21
  %103 = icmp eq i8 %102, %94
  br i1 %103, label %104, label %107

; <label>:104:                                    ; preds = %101
  %105 = add nsw i32 %98, -1
  %106 = icmp eq i32 %105, 0
  br i1 %106, label %113, label %111

; <label>:107:                                    ; preds = %101
  %108 = icmp eq i8 %102, %89
  %109 = zext i1 %108 to i32
  %110 = add nsw i32 %98, %109
  br label %111

; <label>:111:                                    ; preds = %107, %104
  %112 = phi i32 [ %110, %107 ], [ %105, %104 ]
  br label %96

; <label>:113:                                    ; preds = %104
  %114 = getelementptr inbounds i8, i8* %97, i64 2
  %115 = getelementptr inbounds i8, i8* %26, i64 4
  br label %116

; <label>:116:                                    ; preds = %113, %175, %224
  %117 = phi i8* [ %178, %224 ], [ %176, %175 ], [ %115, %113 ]
  %118 = phi i8* [ %225, %224 ], [ %172, %175 ], [ %114, %113 ]
  br label %18

; <label>:119:                                    ; preds = %76
  %120 = getelementptr inbounds i8, i8* %26, i64 2
  %121 = load i8, i8* %120, align 1, !tbaa !21
  %122 = icmp eq i8 %121, 91
  br i1 %122, label %127, label %123

; <label>:123:                                    ; preds = %119
  %124 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %125 = load %struct.lua_State*, %struct.lua_State** %124, align 8, !tbaa !347
  %126 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %125, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.546, i64 0, i64 0)) #16
  unreachable

; <label>:127:                                    ; preds = %119
  %128 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %120) #16
  %129 = load i8*, i8** %14, align 8, !tbaa !350
  %130 = icmp eq i8* %20, %129
  br i1 %130, label %133, label %131

; <label>:131:                                    ; preds = %127
  %132 = load i8, i8* %21, align 1, !tbaa !21
  br label %133

; <label>:133:                                    ; preds = %127, %131
  %134 = phi i8 [ %132, %131 ], [ 0, %127 ]
  %135 = zext i8 %134 to i32
  %136 = getelementptr inbounds i8, i8* %128, i64 -1
  %137 = tail call fastcc i32 @matchbracketclass(i32 %135, i8* nonnull %120, i8* nonnull %136) #16
  %138 = icmp eq i32 %137, 0
  br i1 %138, label %139, label %226

; <label>:139:                                    ; preds = %133
  %140 = load i8, i8* %20, align 1, !tbaa !21
  %141 = zext i8 %140 to i32
  %142 = tail call fastcc i32 @matchbracketclass(i32 %141, i8* nonnull %120, i8* nonnull %136) #16
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %226, label %25

; <label>:144:                                    ; preds = %76, %76, %76, %76, %76, %76, %76, %76, %76, %76
  %145 = zext i8 %78 to i32
  %146 = add nsw i32 %145, -49
  %147 = icmp ult i8 %78, 49
  br i1 %147, label %157, label %148

; <label>:148:                                    ; preds = %144
  %149 = load i8, i8* %15, align 4, !tbaa !357
  %150 = zext i8 %149 to i32
  %151 = icmp slt i32 %146, %150
  br i1 %151, label %152, label %157

; <label>:152:                                    ; preds = %148
  %153 = sext i32 %146 to i64
  %154 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %153, i32 1
  %155 = load i64, i64* %154, align 8, !tbaa !362
  %156 = icmp eq i64 %155, -1
  br i1 %156, label %157, label %162

; <label>:157:                                    ; preds = %152, %148, %144
  %158 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %159 = load %struct.lua_State*, %struct.lua_State** %158, align 8, !tbaa !347
  %160 = add nsw i32 %145, -48
  %161 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %159, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %160) #17
  unreachable

; <label>:162:                                    ; preds = %152
  %163 = load i64, i64* %17, align 8, !tbaa !351
  %164 = ptrtoint i8* %20 to i64
  %165 = sub i64 %163, %164
  %166 = icmp ult i64 %165, %155
  br i1 %166, label %226, label %167

; <label>:167:                                    ; preds = %162
  %168 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %153, i32 0
  %169 = load i8*, i8** %168, align 8, !tbaa !364
  %170 = tail call i32 @memcmp(i8* %169, i8* %20, i64 %155) #21
  %171 = icmp ne i32 %170, 0
  %172 = getelementptr inbounds i8, i8* %20, i64 %155
  %173 = icmp eq i8* %172, null
  %174 = or i1 %173, %171
  br i1 %174, label %226, label %175

; <label>:175:                                    ; preds = %167
  %176 = getelementptr inbounds i8, i8* %26, i64 2
  br label %116

; <label>:177:                                    ; preds = %29, %76, %69
  %178 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %26) #16
  %179 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %20, i8* nonnull %26, i8* nonnull %178) #16
  %180 = icmp eq i32 %179, 0
  %181 = load i8, i8* %178, align 1, !tbaa !21
  br i1 %180, label %182, label %187

; <label>:182:                                    ; preds = %177
  switch i8 %181, label %226 [
    i8 42, label %183
    i8 63, label %183
    i8 45, label %183
  ]

; <label>:183:                                    ; preds = %182, %182, %182
  %184 = getelementptr inbounds i8, i8* %178, i64 1
  br label %185

; <label>:185:                                    ; preds = %183, %189
  %186 = phi i8* [ %184, %183 ], [ %190, %189 ]
  br label %23

; <label>:187:                                    ; preds = %177
  %188 = sext i8 %181 to i32
  switch i32 %188, label %224 [
    i32 63, label %189
    i32 43, label %193
    i32 42, label %195
    i32 45, label %214
  ]

; <label>:189:                                    ; preds = %187
  %190 = getelementptr inbounds i8, i8* %178, i64 1
  %191 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* nonnull %22, i8* nonnull %190) #16
  %192 = icmp eq i8* %191, null
  br i1 %192, label %185, label %226

; <label>:193:                                    ; preds = %187
  %194 = getelementptr inbounds i8, i8* %20, i64 1
  br label %195

; <label>:195:                                    ; preds = %187, %193
  %196 = phi i8* [ %194, %193 ], [ %20, %187 ]
  br label %197

; <label>:197:                                    ; preds = %197, %195
  %198 = phi i64 [ 0, %195 ], [ %202, %197 ]
  %199 = getelementptr inbounds i8, i8* %196, i64 %198
  %200 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %199, i8* %26, i8* nonnull %178) #17
  %201 = icmp eq i32 %200, 0
  %202 = add nuw nsw i64 %198, 1
  br i1 %201, label %203, label %197

; <label>:203:                                    ; preds = %197
  %204 = getelementptr inbounds i8, i8* %178, i64 1
  br label %205

; <label>:205:                                    ; preds = %208, %203
  %206 = phi i64 [ %198, %203 ], [ %213, %208 ]
  %207 = icmp sgt i64 %206, -1
  br i1 %207, label %208, label %226

; <label>:208:                                    ; preds = %205
  %209 = getelementptr inbounds i8, i8* %196, i64 %206
  %210 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %209, i8* nonnull %204) #17
  %211 = icmp eq i8* %210, null
  %212 = sext i1 %211 to i64
  %213 = add nsw i64 %206, %212
  br i1 %211, label %205, label %226

; <label>:214:                                    ; preds = %187
  %215 = getelementptr inbounds i8, i8* %178, i64 1
  br label %216

; <label>:216:                                    ; preds = %220, %214
  %217 = phi i8* [ %20, %214 ], [ %223, %220 ]
  %218 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %217, i8* nonnull %215) #17
  %219 = icmp eq i8* %218, null
  br i1 %219, label %220, label %226

; <label>:220:                                    ; preds = %216
  %221 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %217, i8* %26, i8* nonnull %178) #17
  %222 = icmp eq i32 %221, 0
  %223 = getelementptr inbounds i8, i8* %217, i64 1
  br i1 %222, label %226, label %216

; <label>:224:                                    ; preds = %187
  %225 = getelementptr inbounds i8, i8* %20, i64 1
  br label %116

; <label>:226:                                    ; preds = %182, %189, %167, %162, %88, %133, %139, %25, %96, %216, %220, %205, %208, %68, %57, %72, %39, %36
  %227 = phi i8* [ %75, %72 ], [ %38, %36 ], [ %40, %39 ], [ %66, %57 ], [ null, %68 ], [ null, %205 ], [ %210, %208 ], [ %218, %216 ], [ null, %220 ], [ null, %96 ], [ %20, %25 ], [ null, %139 ], [ null, %133 ], [ %191, %189 ], [ null, %182 ], [ null, %167 ], [ null, %162 ], [ null, %88 ]
  %228 = load i32, i32* %4, align 8, !tbaa !349
  %229 = add nsw i32 %228, 1
  store i32 %229, i32* %4, align 8, !tbaa !349
  ret i8* %227
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @push_captures(%struct.MatchState* nocapture readonly, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %5 = load i8, i8* %4, align 4, !tbaa !357
  %6 = icmp eq i8 %5, 0
  %7 = icmp ne i8* %1, null
  %8 = and i1 %7, %6
  %9 = zext i8 %5 to i32
  %10 = select i1 %8, i32 1, i32 %9
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !347
  tail call void @luaL_checkstack(%struct.lua_State* %12, i32 %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0)) #16
  br label %13

; <label>:13:                                     ; preds = %16, %3
  %14 = phi i32 [ 0, %3 ], [ %17, %16 ]
  %15 = icmp eq i32 %14, %10
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %13
  tail call fastcc void @push_onecapture(%struct.MatchState* %0, i32 %14, i8* %1, i8* %2) #16
  %17 = add nuw nsw i32 %14, 1
  br label %13

; <label>:18:                                     ; preds = %13
  ret i32 %10
}

; Function Attrs: minsize nounwind optsize readonly
declare i8* @memchr(i8*, i32, i64) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i8* @start_capture(%struct.MatchState*, i8*, i8*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %6 = load i8, i8* %5, align 4, !tbaa !357
  %7 = icmp ugt i8 %6, 31
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !347
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %4
  %13 = zext i8 %6 to i64
  %14 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 0
  store i8* %1, i8** %14, align 8, !tbaa !364
  %15 = sext i32 %3 to i64
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 1
  store i64 %15, i64* %16, align 8, !tbaa !362
  %17 = add i8 %6, 1
  store i8 %17, i8* %5, align 4, !tbaa !357
  %18 = tail call fastcc i8* @match(%struct.MatchState* nonnull %0, i8* %1, i8* %2) #16
  %19 = icmp eq i8* %18, null
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %12
  %21 = load i8, i8* %5, align 4, !tbaa !357
  %22 = add i8 %21, -1
  store i8 %22, i8* %5, align 4, !tbaa !357
  br label %23

; <label>:23:                                     ; preds = %20, %12
  ret i8* %18
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc nonnull i8* @classend(%struct.MatchState* nocapture readonly, i8* readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds i8, i8* %1, i64 1
  %4 = load i8, i8* %1, align 1, !tbaa !21
  %5 = sext i8 %4 to i32
  switch i32 %5, label %42 [
    i32 37, label %6
    i32 91, label %16
  ]

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %8 = load i8*, i8** %7, align 8, !tbaa !352
  %9 = icmp eq i8* %3, %8
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !347
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %12, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.550, i64 0, i64 0)) #16
  unreachable

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds i8, i8* %1, i64 2
  br label %42

; <label>:16:                                     ; preds = %2
  %17 = load i8, i8* %3, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 94
  %19 = getelementptr inbounds i8, i8* %1, i64 2
  %20 = select i1 %18, i8* %19, i8* %3
  %21 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %22 = load i8*, i8** %21, align 8, !tbaa !352
  br label %23

; <label>:23:                                     ; preds = %30, %16
  %24 = phi i8* [ %20, %16 ], [ %37, %30 ]
  %25 = icmp eq i8* %24, %22
  br i1 %25, label %26, label %30

; <label>:26:                                     ; preds = %23
  %27 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %28 = load %struct.lua_State*, %struct.lua_State** %27, align 8, !tbaa !347
  %29 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %28, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.551, i64 0, i64 0)) #16
  unreachable

; <label>:30:                                     ; preds = %23
  %31 = getelementptr inbounds i8, i8* %24, i64 1
  %32 = load i8, i8* %24, align 1, !tbaa !21
  %33 = icmp eq i8 %32, 37
  %34 = icmp ult i8* %31, %22
  %35 = getelementptr inbounds i8, i8* %24, i64 2
  %36 = and i1 %34, %33
  %37 = select i1 %36, i8* %35, i8* %31
  %38 = load i8, i8* %37, align 1, !tbaa !21
  %39 = icmp eq i8 %38, 93
  br i1 %39, label %40, label %23

; <label>:40:                                     ; preds = %30
  %41 = getelementptr inbounds i8, i8* %37, i64 1
  br label %42

; <label>:42:                                     ; preds = %2, %40, %14
  %43 = phi i8* [ %41, %40 ], [ %15, %14 ], [ %3, %2 ]
  ret i8* %43
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @matchbracketclass(i32, i8* readonly, i8* readnone) unnamed_addr #12 {
  %4 = getelementptr inbounds i8, i8* %1, i64 1
  %5 = load i8, i8* %4, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 94
  %7 = select i1 %6, i8* %4, i8* %1
  %8 = xor i1 %6, true
  %9 = zext i1 %8 to i32
  br label %10

; <label>:10:                                     ; preds = %23, %3
  %11 = phi i8* [ %7, %3 ], [ %24, %23 ]
  %12 = getelementptr inbounds i8, i8* %11, i64 1
  %13 = icmp ult i8* %12, %2
  br i1 %13, label %14, label %40

; <label>:14:                                     ; preds = %10
  %15 = load i8, i8* %12, align 1, !tbaa !21
  %16 = icmp eq i8 %15, 37
  %17 = getelementptr inbounds i8, i8* %11, i64 2
  %18 = load i8, i8* %17, align 1, !tbaa !21
  br i1 %16, label %19, label %25

; <label>:19:                                     ; preds = %14
  %20 = zext i8 %18 to i32
  %21 = tail call fastcc i32 @match_class(i32 %0, i32 %20) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %42

; <label>:23:                                     ; preds = %19, %33, %30, %37
  %24 = phi i8* [ %17, %19 ], [ %28, %33 ], [ %28, %30 ], [ %12, %37 ]
  br label %10

; <label>:25:                                     ; preds = %14
  %26 = icmp eq i8 %18, 45
  br i1 %26, label %27, label %37

; <label>:27:                                     ; preds = %25
  %28 = getelementptr inbounds i8, i8* %11, i64 3
  %29 = icmp ult i8* %28, %2
  br i1 %29, label %30, label %37

; <label>:30:                                     ; preds = %27
  %31 = zext i8 %15 to i32
  %32 = icmp sgt i32 %31, %0
  br i1 %32, label %23, label %33

; <label>:33:                                     ; preds = %30
  %34 = load i8, i8* %28, align 1, !tbaa !21
  %35 = zext i8 %34 to i32
  %36 = icmp slt i32 %35, %0
  br i1 %36, label %23, label %42

; <label>:37:                                     ; preds = %27, %25
  %38 = zext i8 %15 to i32
  %39 = icmp eq i32 %38, %0
  br i1 %39, label %42, label %23

; <label>:40:                                     ; preds = %10
  %41 = xor i32 %9, 1
  br label %42

; <label>:42:                                     ; preds = %37, %33, %19, %40
  %43 = phi i32 [ %41, %40 ], [ %9, %19 ], [ %9, %33 ], [ %9, %37 ]
  ret i32 %43
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @singlematch(%struct.MatchState* nocapture readonly, i8* readonly, i8* readonly, i8* readnone) unnamed_addr #12 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %6 = load i8*, i8** %5, align 8, !tbaa !351
  %7 = icmp ugt i8* %6, %1
  br i1 %7, label %8, label %24

; <label>:8:                                      ; preds = %4
  %9 = load i8, i8* %1, align 1, !tbaa !21
  %10 = zext i8 %9 to i32
  %11 = load i8, i8* %2, align 1, !tbaa !21
  %12 = sext i8 %11 to i32
  switch i32 %12, label %21 [
    i32 46, label %24
    i32 37, label %13
    i32 91, label %18
  ]

; <label>:13:                                     ; preds = %8
  %14 = getelementptr inbounds i8, i8* %2, i64 1
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = zext i8 %15 to i32
  %17 = tail call fastcc i32 @match_class(i32 %10, i32 %16) #16
  br label %24

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds i8, i8* %3, i64 -1
  %20 = tail call fastcc i32 @matchbracketclass(i32 %10, i8* nonnull %2, i8* nonnull %19) #16
  br label %24

; <label>:21:                                     ; preds = %8
  %22 = icmp eq i8 %11, %9
  %23 = zext i1 %22 to i32
  br label %24

; <label>:24:                                     ; preds = %13, %18, %21, %8, %4
  %25 = phi i32 [ 0, %4 ], [ %23, %21 ], [ %20, %18 ], [ %17, %13 ], [ 1, %8 ]
  ret i32 %25
}

; Function Attrs: minsize nounwind optsize readonly uwtable
define internal fastcc i32 @match_class(i32, i32) unnamed_addr #12 {
  %3 = tail call i32 @tolower(i32 %1) #21
  switch i32 %3, label %88 [
    i32 97, label %4
    i32 99, label %12
    i32 100, label %20
    i32 103, label %28
    i32 108, label %36
    i32 112, label %44
    i32 115, label %52
    i32 117, label %60
    i32 119, label %68
    i32 120, label %76
    i32 122, label %84
  ]

; <label>:4:                                      ; preds = %2
  %5 = tail call i16** @__ctype_b_loc() #22
  %6 = load i16*, i16** %5, align 8, !tbaa !39
  %7 = sext i32 %0 to i64
  %8 = getelementptr inbounds i16, i16* %6, i64 %7
  %9 = load i16, i16* %8, align 2, !tbaa !317
  %10 = and i16 %9, 1024
  %11 = zext i16 %10 to i32
  br label %91

; <label>:12:                                     ; preds = %2
  %13 = tail call i16** @__ctype_b_loc() #22
  %14 = load i16*, i16** %13, align 8, !tbaa !39
  %15 = sext i32 %0 to i64
  %16 = getelementptr inbounds i16, i16* %14, i64 %15
  %17 = load i16, i16* %16, align 2, !tbaa !317
  %18 = and i16 %17, 2
  %19 = zext i16 %18 to i32
  br label %91

; <label>:20:                                     ; preds = %2
  %21 = tail call i16** @__ctype_b_loc() #22
  %22 = load i16*, i16** %21, align 8, !tbaa !39
  %23 = sext i32 %0 to i64
  %24 = getelementptr inbounds i16, i16* %22, i64 %23
  %25 = load i16, i16* %24, align 2, !tbaa !317
  %26 = and i16 %25, 2048
  %27 = zext i16 %26 to i32
  br label %91

; <label>:28:                                     ; preds = %2
  %29 = tail call i16** @__ctype_b_loc() #22
  %30 = load i16*, i16** %29, align 8, !tbaa !39
  %31 = sext i32 %0 to i64
  %32 = getelementptr inbounds i16, i16* %30, i64 %31
  %33 = load i16, i16* %32, align 2, !tbaa !317
  %34 = and i16 %33, -32768
  %35 = zext i16 %34 to i32
  br label %91

; <label>:36:                                     ; preds = %2
  %37 = tail call i16** @__ctype_b_loc() #22
  %38 = load i16*, i16** %37, align 8, !tbaa !39
  %39 = sext i32 %0 to i64
  %40 = getelementptr inbounds i16, i16* %38, i64 %39
  %41 = load i16, i16* %40, align 2, !tbaa !317
  %42 = and i16 %41, 512
  %43 = zext i16 %42 to i32
  br label %91

; <label>:44:                                     ; preds = %2
  %45 = tail call i16** @__ctype_b_loc() #22
  %46 = load i16*, i16** %45, align 8, !tbaa !39
  %47 = sext i32 %0 to i64
  %48 = getelementptr inbounds i16, i16* %46, i64 %47
  %49 = load i16, i16* %48, align 2, !tbaa !317
  %50 = and i16 %49, 4
  %51 = zext i16 %50 to i32
  br label %91

; <label>:52:                                     ; preds = %2
  %53 = tail call i16** @__ctype_b_loc() #22
  %54 = load i16*, i16** %53, align 8, !tbaa !39
  %55 = sext i32 %0 to i64
  %56 = getelementptr inbounds i16, i16* %54, i64 %55
  %57 = load i16, i16* %56, align 2, !tbaa !317
  %58 = and i16 %57, 8192
  %59 = zext i16 %58 to i32
  br label %91

; <label>:60:                                     ; preds = %2
  %61 = tail call i16** @__ctype_b_loc() #22
  %62 = load i16*, i16** %61, align 8, !tbaa !39
  %63 = sext i32 %0 to i64
  %64 = getelementptr inbounds i16, i16* %62, i64 %63
  %65 = load i16, i16* %64, align 2, !tbaa !317
  %66 = and i16 %65, 256
  %67 = zext i16 %66 to i32
  br label %91

; <label>:68:                                     ; preds = %2
  %69 = tail call i16** @__ctype_b_loc() #22
  %70 = load i16*, i16** %69, align 8, !tbaa !39
  %71 = sext i32 %0 to i64
  %72 = getelementptr inbounds i16, i16* %70, i64 %71
  %73 = load i16, i16* %72, align 2, !tbaa !317
  %74 = and i16 %73, 8
  %75 = zext i16 %74 to i32
  br label %91

; <label>:76:                                     ; preds = %2
  %77 = tail call i16** @__ctype_b_loc() #22
  %78 = load i16*, i16** %77, align 8, !tbaa !39
  %79 = sext i32 %0 to i64
  %80 = getelementptr inbounds i16, i16* %78, i64 %79
  %81 = load i16, i16* %80, align 2, !tbaa !317
  %82 = and i16 %81, 4096
  %83 = zext i16 %82 to i32
  br label %91

; <label>:84:                                     ; preds = %2
  %85 = icmp eq i32 %0, 0
  %86 = zext i1 %85 to i32
  %87 = tail call i16** @__ctype_b_loc() #22
  br label %91

; <label>:88:                                     ; preds = %2
  %89 = icmp eq i32 %1, %0
  %90 = zext i1 %89 to i32
  br label %103

; <label>:91:                                     ; preds = %84, %76, %68, %60, %52, %44, %36, %28, %20, %12, %4
  %92 = phi i16** [ %87, %84 ], [ %77, %76 ], [ %69, %68 ], [ %61, %60 ], [ %53, %52 ], [ %45, %44 ], [ %37, %36 ], [ %29, %28 ], [ %21, %20 ], [ %13, %12 ], [ %5, %4 ]
  %93 = phi i32 [ %86, %84 ], [ %83, %76 ], [ %75, %68 ], [ %67, %60 ], [ %59, %52 ], [ %51, %44 ], [ %43, %36 ], [ %35, %28 ], [ %27, %20 ], [ %19, %12 ], [ %11, %4 ]
  %94 = load i16*, i16** %92, align 8, !tbaa !39
  %95 = sext i32 %1 to i64
  %96 = getelementptr inbounds i16, i16* %94, i64 %95
  %97 = load i16, i16* %96, align 2, !tbaa !317
  %98 = and i16 %97, 512
  %99 = icmp eq i16 %98, 0
  %100 = icmp eq i32 %93, 0
  %101 = zext i1 %100 to i32
  %102 = select i1 %99, i32 %101, i32 %93
  br label %103

; <label>:103:                                    ; preds = %91, %88
  %104 = phi i32 [ %90, %88 ], [ %102, %91 ]
  ret i32 %104
}

; Function Attrs: minsize nounwind optsize readonly
declare i32 @tolower(i32) local_unnamed_addr #4

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @push_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call fastcc i64 @get_onecapture(%struct.MatchState* %0, i32 %1, i8* %2, i8* %3, i8** nonnull %5) #16
  %8 = icmp eq i64 %7, -2
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !347
  %12 = load i8*, i8** %5, align 8, !tbaa !39
  %13 = tail call i8* @lua_pushlstring(%struct.lua_State* %11, i8* %12, i64 %7) #16
  br label %14

; <label>:14:                                     ; preds = %4, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @get_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*, i8** nocapture) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %7 = load i8, i8* %6, align 4, !tbaa !357
  %8 = zext i8 %7 to i32
  %9 = icmp sgt i32 %8, %1
  br i1 %9, label %21, label %10

; <label>:10:                                     ; preds = %5
  %11 = icmp eq i32 %1, 0
  br i1 %11, label %17, label %12

; <label>:12:                                     ; preds = %10
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !347
  %15 = add nsw i32 %1, 1
  %16 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %14, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %15) #16
  unreachable

; <label>:17:                                     ; preds = %10
  store i8* %2, i8** %4, align 8, !tbaa !39
  %18 = ptrtoint i8* %3 to i64
  %19 = ptrtoint i8* %2 to i64
  %20 = sub i64 %18, %19
  br label %48

; <label>:21:                                     ; preds = %5
  %22 = sext i32 %1 to i64
  %23 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 1
  %24 = load i64, i64* %23, align 8, !tbaa !362
  %25 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 0
  %26 = bitcast i8** %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !364
  %28 = bitcast i8** %4 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !39
  switch i64 %24, label %48 [
    i64 -1, label %29
    i64 -2, label %33
  ]

; <label>:29:                                     ; preds = %21
  %30 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !347
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.553, i64 0, i64 0)) #16
  unreachable

; <label>:33:                                     ; preds = %21
  %34 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %35 = load %struct.lua_State*, %struct.lua_State** %34, align 8, !tbaa !347
  %36 = load i64, i64* %26, align 8, !tbaa !364
  %37 = bitcast %struct.MatchState* %0 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !350
  %39 = add i64 %36, 1
  %40 = sub i64 %39, %38
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %35, i64 0, i32 6
  %42 = bitcast %union.StackValue** %41 to %struct.TValue**
  %43 = load %struct.TValue*, %struct.TValue** %42, align 8, !tbaa !20
  %44 = bitcast %struct.TValue* %43 to i64*
  store i64 %40, i64* %44, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 0, i32 1
  store i8 35, i8* %45, align 8, !tbaa !22
  %46 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 1
  store %union.StackValue* %47, %union.StackValue** %41, align 8, !tbaa !20
  br label %48

; <label>:48:                                     ; preds = %33, %21, %17
  %49 = phi i64 [ %20, %17 ], [ %24, %21 ], [ -2, %33 ]
  ret i64 %49
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @addlenmod(i8*, i8* nocapture readonly) unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %0) #21
  %4 = tail call i64 @strlen(i8* %1) #21
  %5 = add i64 %3, -1
  %6 = getelementptr inbounds i8, i8* %0, i64 %5
  %7 = load i8, i8* %6, align 1, !tbaa !21
  %8 = getelementptr inbounds i8, i8* %0, i64 %3
  %9 = getelementptr inbounds i8, i8* %8, i64 -1
  %10 = tail call i8* @strcpy(i8* nonnull %9, i8* %1) #17
  %11 = add i64 %4, %3
  %12 = add i64 %11, -1
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  store i8 %7, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds i8, i8* %0, i64 %11
  store i8 0, i8* %14, align 1, !tbaa !21
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @gmatch_aux(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001003) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 24
  %4 = bitcast i8* %3 to %struct.MatchState*
  %5 = getelementptr inbounds i8, i8* %2, i64 48
  %6 = bitcast i8* %5 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %6, align 8, !tbaa !365
  %7 = bitcast i8* %2 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !353
  %9 = getelementptr inbounds i8, i8* %2, i64 32
  %10 = bitcast i8* %9 to i8**
  %11 = getelementptr inbounds i8, i8* %2, i64 60
  %12 = getelementptr inbounds i8, i8* %2, i64 8
  %13 = bitcast i8* %12 to i8**
  %14 = getelementptr inbounds i8, i8* %2, i64 16
  %15 = bitcast i8* %14 to i8**
  br label %16

; <label>:16:                                     ; preds = %29, %1
  %17 = phi i8* [ %8, %1 ], [ %30, %29 ]
  %18 = load i8*, i8** %10, align 8, !tbaa !366
  %19 = icmp ugt i8* %17, %18
  br i1 %19, label %31, label %20

; <label>:20:                                     ; preds = %16
  store i8 0, i8* %11, align 4, !tbaa !357
  %21 = load i8*, i8** %13, align 8, !tbaa !355
  %22 = tail call fastcc i8* @match(%struct.MatchState* nonnull %4, i8* %17, i8* %21) #16
  %23 = icmp eq i8* %22, null
  br i1 %23, label %29, label %24

; <label>:24:                                     ; preds = %20
  %25 = load i8*, i8** %15, align 8, !tbaa !356
  %26 = icmp eq i8* %22, %25
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  store i8* %22, i8** %15, align 8, !tbaa !356
  store i8* %22, i8** %7, align 8, !tbaa !353
  %28 = tail call fastcc i32 @push_captures(%struct.MatchState* nonnull %4, i8* %17, i8* nonnull %22) #16
  br label %31

; <label>:29:                                     ; preds = %24, %20
  %30 = getelementptr inbounds i8, i8* %17, i64 1
  br label %16

; <label>:31:                                     ; preds = %16, %27
  %32 = phi i32 [ %28, %27 ], [ 0, %16 ]
  ret i32 %32
}

; Function Attrs: minsize nounwind optsize readnone
declare i32** @__ctype_tolower_loc() local_unnamed_addr #8

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @getdetails(%struct.Header* nocapture, i64, i8** nocapture, i32* nocapture, i32* nocapture) unnamed_addr #0 {
  %6 = alloca i32, align 4
  %7 = tail call fastcc i32 @getoption(%struct.Header* %0, i8** %2, i32* %3) #16
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  %9 = load i32, i32* %3, align 4, !tbaa !74
  store i32 %9, i32* %6, align 4, !tbaa !74
  %10 = icmp eq i32 %7, 7
  br i1 %10, label %11, label %26

; <label>:11:                                     ; preds = %5
  %12 = load i8*, i8** %2, align 8, !tbaa !39
  %13 = load i8, i8* %12, align 1, !tbaa !21
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %21, label %15

; <label>:15:                                     ; preds = %11
  %16 = call fastcc i32 @getoption(%struct.Header* %0, i8** nonnull %2, i32* nonnull %6) #16
  %17 = icmp eq i32 %16, 3
  %18 = load i32, i32* %6, align 4
  %19 = icmp eq i32 %18, 0
  %20 = or i1 %17, %19
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %15, %11
  %22 = phi i32 [ %18, %15 ], [ %9, %11 ]
  %23 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %24 = load %struct.lua_State*, %struct.lua_State** %23, align 8, !tbaa !358
  %25 = tail call i32 @luaL_argerror(%struct.lua_State* %24, i32 1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.576, i64 0, i64 0)) #16
  br label %26

; <label>:26:                                     ; preds = %21, %15, %5
  %27 = phi i32 [ %22, %21 ], [ %18, %15 ], [ %9, %5 ]
  %28 = icmp slt i32 %27, 2
  %29 = icmp eq i32 %7, 3
  %30 = or i1 %29, %28
  br i1 %30, label %50, label %31

; <label>:31:                                     ; preds = %26
  %32 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  %33 = load i32, i32* %32, align 4, !tbaa !361
  %34 = icmp sgt i32 %27, %33
  br i1 %34, label %35, label %36

; <label>:35:                                     ; preds = %31
  store i32 %33, i32* %6, align 4, !tbaa !74
  br label %36

; <label>:36:                                     ; preds = %35, %31
  %37 = phi i32 [ %33, %35 ], [ %27, %31 ]
  %38 = add nsw i32 %37, -1
  %39 = and i32 %38, %37
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %45, label %41

; <label>:41:                                     ; preds = %36
  %42 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %43 = load %struct.lua_State*, %struct.lua_State** %42, align 8, !tbaa !358
  %44 = tail call i32 @luaL_argerror(%struct.lua_State* %43, i32 1, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.577, i64 0, i64 0)) #16
  br label %45

; <label>:45:                                     ; preds = %36, %41
  %46 = trunc i64 %1 to i32
  %47 = and i32 %38, %46
  %48 = sub nsw i32 %37, %47
  %49 = and i32 %48, %38
  br label %50

; <label>:50:                                     ; preds = %26, %45
  %51 = phi i32 [ %49, %45 ], [ 0, %26 ]
  store i32 %51, i32* %4, align 4, !tbaa !74
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  ret i32 %7
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @packint(%struct.luaL_Buffer*, i64, i32, i32, i32) unnamed_addr #0 {
  %6 = sext i32 %3 to i64
  %7 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %0, i64 %6) #16
  %8 = trunc i64 %1 to i8
  %9 = icmp ne i32 %2, 0
  %10 = add nsw i32 %3, -1
  %11 = sext i32 %10 to i64
  %12 = select i1 %9, i64 0, i64 %11
  %13 = getelementptr inbounds i8, i8* %7, i64 %12
  store i8 %8, i8* %13, align 1, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %18, %5
  %15 = phi i64 [ %1, %5 ], [ %19, %18 ]
  %16 = phi i32 [ 1, %5 ], [ %25, %18 ]
  %17 = icmp slt i32 %16, %3
  br i1 %17, label %18, label %26

; <label>:18:                                     ; preds = %14
  %19 = lshr i64 %15, 8
  %20 = trunc i64 %19 to i8
  %21 = sub nsw i32 %10, %16
  %22 = select i1 %9, i32 %16, i32 %21
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i8, i8* %7, i64 %23
  store i8 %20, i8* %24, align 1, !tbaa !21
  %25 = add nuw nsw i32 %16, 1
  br label %14

; <label>:26:                                     ; preds = %14
  %27 = icmp ne i32 %4, 0
  %28 = icmp sgt i32 %3, 8
  %29 = and i1 %28, %27
  br i1 %29, label %30, label %40

; <label>:30:                                     ; preds = %26
  br label %31

; <label>:31:                                     ; preds = %30, %34
  %32 = phi i32 [ %39, %34 ], [ 8, %30 ]
  %33 = icmp eq i32 %32, %3
  br i1 %33, label %40, label %34

; <label>:34:                                     ; preds = %31
  %35 = sub nsw i32 %10, %32
  %36 = select i1 %9, i32 %32, i32 %35
  %37 = sext i32 %36 to i64
  %38 = getelementptr inbounds i8, i8* %7, i64 %37
  store i8 -1, i8* %38, align 1, !tbaa !21
  %39 = add nuw nsw i32 %32, 1
  br label %31

; <label>:40:                                     ; preds = %31, %26
  %41 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %42 = load i64, i64* %41, align 8, !tbaa !200
  %43 = add i64 %42, %6
  store i64 %43, i64* %41, align 8, !tbaa !200
  ret void
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc void @copywithendian(i8*, i8*, i32, i32) unnamed_addr #2 {
  %5 = icmp eq i32 %3, 1
  br i1 %5, label %6, label %17

; <label>:6:                                      ; preds = %4
  br label %7

; <label>:7:                                      ; preds = %6, %12
  %8 = phi i8* [ %14, %12 ], [ %1, %6 ]
  %9 = phi i32 [ %13, %12 ], [ %2, %6 ]
  %10 = phi i8* [ %16, %12 ], [ %0, %6 ]
  %11 = icmp eq i32 %9, 0
  br i1 %11, label %31, label %12

; <label>:12:                                     ; preds = %7
  %13 = add nsw i32 %9, -1
  %14 = getelementptr inbounds i8, i8* %8, i64 1
  %15 = load volatile i8, i8* %8, align 1, !tbaa !21
  %16 = getelementptr inbounds i8, i8* %10, i64 1
  store volatile i8 %15, i8* %10, align 1, !tbaa !21
  br label %7

; <label>:17:                                     ; preds = %4
  %18 = add nsw i32 %2, -1
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i8, i8* %0, i64 %19
  br label %21

; <label>:21:                                     ; preds = %26, %17
  %22 = phi i8* [ %1, %17 ], [ %28, %26 ]
  %23 = phi i32 [ %2, %17 ], [ %27, %26 ]
  %24 = phi i8* [ %20, %17 ], [ %30, %26 ]
  %25 = icmp eq i32 %23, 0
  br i1 %25, label %31, label %26

; <label>:26:                                     ; preds = %21
  %27 = add nsw i32 %23, -1
  %28 = getelementptr inbounds i8, i8* %22, i64 1
  %29 = load volatile i8, i8* %22, align 1, !tbaa !21
  %30 = getelementptr inbounds i8, i8* %24, i64 -1
  store volatile i8 %29, i8* %24, align 1, !tbaa !21
  br label %21

; <label>:31:                                     ; preds = %21, %7
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @getoption(%struct.Header* nocapture, i8** nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = load i8*, i8** %1, align 8, !tbaa !39
  %5 = getelementptr inbounds i8, i8* %4, i64 1
  store i8* %5, i8** %1, align 8, !tbaa !39
  %6 = load i8, i8* %4, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  store i32 0, i32* %2, align 4, !tbaa !74
  switch i32 %7, label %44 [
    i32 98, label %8
    i32 66, label %9
    i32 104, label %10
    i32 72, label %11
    i32 108, label %12
    i32 76, label %13
    i32 106, label %14
    i32 74, label %15
    i32 84, label %16
    i32 102, label %17
    i32 100, label %18
    i32 110, label %19
    i32 105, label %20
    i32 73, label %22
    i32 115, label %24
    i32 99, label %26
    i32 122, label %49
    i32 120, label %33
    i32 88, label %34
    i32 32, label %48
    i32 60, label %35
    i32 62, label %37
    i32 61, label %39
    i32 33, label %41
  ]

; <label>:8:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:9:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:10:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:11:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:12:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:13:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:14:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:15:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:16:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:17:                                     ; preds = %3
  store i32 4, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:18:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:19:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4) #16
  store i32 %21, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:22:                                     ; preds = %3
  %23 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4) #16
  store i32 %23, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:24:                                     ; preds = %3
  %25 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8) #16
  store i32 %25, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:26:                                     ; preds = %3
  %27 = tail call fastcc i32 @getnum(i8** nonnull %1, i32 -1) #16
  store i32 %27, i32* %2, align 4, !tbaa !74
  %28 = icmp eq i32 %27, -1
  br i1 %28, label %29, label %49

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !358
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.578, i64 0, i64 0)) #16
  unreachable

; <label>:33:                                     ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !74
  br label %49

; <label>:34:                                     ; preds = %3
  br label %49

; <label>:35:                                     ; preds = %3
  %36 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %36, align 8, !tbaa !360
  br label %48

; <label>:37:                                     ; preds = %3
  %38 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 0, i32* %38, align 8, !tbaa !360
  br label %48

; <label>:39:                                     ; preds = %3
  %40 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %40, align 8, !tbaa !360
  br label %48

; <label>:41:                                     ; preds = %3
  %42 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8) #16
  %43 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  store i32 %42, i32* %43, align 4, !tbaa !361
  br label %48

; <label>:44:                                     ; preds = %3
  %45 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %46 = load %struct.lua_State*, %struct.lua_State** %45, align 8, !tbaa !358
  %47 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %46, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.579, i64 0, i64 0), i32 %7) #16
  unreachable

; <label>:48:                                     ; preds = %41, %39, %37, %35, %3
  br label %49

; <label>:49:                                     ; preds = %3, %26, %48, %34, %33, %24, %22, %20, %19, %18, %17, %16, %15, %14, %13, %12, %11, %10, %9, %8
  %50 = phi i32 [ 8, %48 ], [ 7, %34 ], [ 6, %33 ], [ 4, %24 ], [ 1, %22 ], [ 0, %20 ], [ 2, %19 ], [ 2, %18 ], [ 2, %17 ], [ 1, %16 ], [ 1, %15 ], [ 0, %14 ], [ 1, %13 ], [ 0, %12 ], [ 1, %11 ], [ 0, %10 ], [ 1, %9 ], [ 0, %8 ], [ 3, %26 ], [ 5, %3 ]
  ret i32 %50
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @getnumlimit(%struct.Header* nocapture readonly, i8** nocapture, i32) unnamed_addr #0 {
  %4 = tail call fastcc i32 @getnum(i8** %1, i32 %2) #16
  %5 = add i32 %4, -1
  %6 = icmp ugt i32 %5, 15
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !358
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %9, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.580, i64 0, i64 0), i32 %4, i32 16) #16
  unreachable

; <label>:11:                                     ; preds = %3
  ret i32 %4
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i32 @getnum(i8** nocapture, i32) unnamed_addr #2 {
  %3 = load i8*, i8** %0, align 8, !tbaa !39
  %4 = load i8, i8* %3, align 1, !tbaa !21
  %5 = sext i8 %4 to i32
  %6 = add nsw i32 %5, -48
  %7 = icmp ugt i32 %6, 9
  br i1 %7, label %24, label %8

; <label>:8:                                      ; preds = %2
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i8* [ %13, %9 ], [ %3, %8 ]
  %11 = phi i32 [ %17, %9 ], [ 0, %8 ]
  %12 = mul nsw i32 %11, 10
  %13 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %13, i8** %0, align 8, !tbaa !39
  %14 = load i8, i8* %10, align 1, !tbaa !21
  %15 = sext i8 %14 to i32
  %16 = add i32 %12, -48
  %17 = add i32 %16, %15
  %18 = load i8, i8* %13, align 1, !tbaa !21
  %19 = sext i8 %18 to i32
  %20 = add nsw i32 %19, -48
  %21 = icmp ult i32 %20, 10
  %22 = icmp slt i32 %17, 214748364
  %23 = and i1 %22, %21
  br i1 %23, label %9, label %24

; <label>:24:                                     ; preds = %9, %2
  %25 = phi i32 [ %1, %2 ], [ %17, %9 ]
  ret i32 %25
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i64 @unpackint(%struct.lua_State*, i8* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %6 = icmp slt i32 %3, 8
  %7 = icmp eq i32 %2, 0
  %8 = add nsw i32 %3, -1
  %9 = select i1 %6, i32 %3, i32 8
  br label %10

; <label>:10:                                     ; preds = %5, %15
  %11 = phi i32 [ %13, %15 ], [ %9, %5 ]
  %12 = phi i64 [ %24, %15 ], [ 0, %5 ]
  %13 = add nsw i32 %11, -1
  %14 = icmp sgt i32 %11, 0
  br i1 %14, label %15, label %25

; <label>:15:                                     ; preds = %10
  %16 = shl i64 %12, 8
  %17 = sub i32 1, %11
  %18 = add i32 %8, %17
  %19 = select i1 %7, i32 %18, i32 %13
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i8, i8* %1, i64 %20
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  %24 = or i64 %16, %23
  br label %10

; <label>:25:                                     ; preds = %10
  br i1 %6, label %26, label %35

; <label>:26:                                     ; preds = %25
  %27 = icmp eq i32 %4, 0
  br i1 %27, label %56, label %28

; <label>:28:                                     ; preds = %26
  %29 = shl i32 %3, 3
  %30 = add nsw i32 %29, -1
  %31 = zext i32 %30 to i64
  %32 = shl i64 1, %31
  %33 = xor i64 %12, %32
  %34 = sub i64 %33, %32
  br label %56

; <label>:35:                                     ; preds = %25
  %36 = icmp eq i32 %3, 8
  br i1 %36, label %56, label %37

; <label>:37:                                     ; preds = %35
  %38 = icmp eq i32 %4, 0
  %39 = icmp sgt i64 %12, -1
  %40 = or i1 %38, %39
  %41 = select i1 %40, i32 0, i32 255
  br label %42

; <label>:42:                                     ; preds = %45, %37
  %43 = phi i32 [ 8, %37 ], [ %53, %45 ]
  %44 = icmp slt i32 %43, %3
  br i1 %44, label %45, label %56

; <label>:45:                                     ; preds = %42
  %46 = sub i32 %8, %43
  %47 = select i1 %7, i32 %46, i32 %43
  %48 = sext i32 %47 to i64
  %49 = getelementptr inbounds i8, i8* %1, i64 %48
  %50 = load i8, i8* %49, align 1, !tbaa !21
  %51 = zext i8 %50 to i32
  %52 = icmp eq i32 %41, %51
  %53 = add nuw nsw i32 %43, 1
  br i1 %52, label %42, label %54

; <label>:54:                                     ; preds = %45
  %55 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.587, i64 0, i64 0), i32 %3) #16
  unreachable

; <label>:56:                                     ; preds = %42, %26, %35, %28
  %57 = phi i64 [ %34, %28 ], [ %12, %26 ], [ %12, %35 ], [ %12, %42 ]
  ret i64 %57
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_add(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_sub(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_mul(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_mod(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_pow(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_div(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_idiv(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @arith_unm(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 12, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @arith(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 2) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %6
  tail call void @lua_arith(%struct.lua_State* %0, i32 %1) #16
  br label %33

; <label>:10:                                     ; preds = %6, %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #17
  %11 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #17
  %12 = icmp eq i32 %11, 4
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %10
  %14 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 2, i8* %2) #17
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %29

; <label>:16:                                     ; preds = %13, %10
  %17 = getelementptr inbounds i8, i8* %2, i64 2
  %18 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -2) #17
  %19 = add nsw i32 %18, 1
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %20
  %22 = load i8*, i8** %21, align 8, !tbaa !39
  %23 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #17
  %24 = add nsw i32 %23, 1
  %25 = sext i32 %24 to i64
  %26 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %25
  %27 = load i8*, i8** %26, align 8, !tbaa !39
  %28 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.588, i64 0, i64 0), i8* nonnull %17, i8* %22, i8* %27) #17
  unreachable

; <label>:29:                                     ; preds = %13
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -3, i32 1) #17
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %32, i32 1) #17
  br label %33

; <label>:33:                                     ; preds = %29, %9
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @tonum(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 3
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %1) #16
  br label %19

; <label>:7:                                      ; preds = %2
  %8 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* nonnull %3) #16
  %10 = icmp eq i8* %9, null
  br i1 %10, label %17, label %11

; <label>:11:                                     ; preds = %7
  %12 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %9) #16
  %13 = load i64, i64* %3, align 8, !tbaa !135
  %14 = add i64 %13, 1
  %15 = icmp eq i64 %12, %14
  %16 = zext i1 %15 to i32
  br label %17

; <label>:17:                                     ; preds = %7, %11
  %18 = phi i32 [ 0, %7 ], [ %16, %11 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  br label %19

; <label>:19:                                     ; preds = %17, %6
  %20 = phi i32 [ 1, %6 ], [ %18, %17 ]
  ret i32 %20
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tconcat(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca i64, align 8
  %4 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 5) #16
  %5 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3) #16
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %9 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 %5) #16
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %10, align 8, !tbaa !202
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %12 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %11, %union.anon.6** %12, align 8, !tbaa !201
  %13 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %14 = bitcast i64* %13 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %14, align 8, !tbaa !135
  br label %15

; <label>:15:                                     ; preds = %18, %1
  %16 = phi i64 [ %8, %1 ], [ %20, %18 ]
  %17 = icmp slt i64 %16, %9
  br i1 %17, label %18, label %21

; <label>:18:                                     ; preds = %15
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %16) #16
  %19 = load i64, i64* %3, align 8, !tbaa !135
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %7, i64 %19) #16
  %20 = add nsw i64 %16, 1
  br label %15

; <label>:21:                                     ; preds = %15
  %22 = icmp eq i64 %16, %9
  br i1 %22, label %23, label %24

; <label>:23:                                     ; preds = %21
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %9) #16
  br label %24

; <label>:24:                                     ; preds = %23, %21
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tinsert(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = add nsw i64 %2, 1
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !49
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !61
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  switch i32 %15, label %29 [
    i32 2, label %31
    i32 3, label %16
  ]

; <label>:16:                                     ; preds = %1
  %17 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #16
  %18 = add i64 %17, -1
  %19 = icmp ult i64 %18, %3
  br i1 %19, label %22, label %20

; <label>:20:                                     ; preds = %16
  %21 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0)) #16
  br label %22

; <label>:22:                                     ; preds = %20, %16
  br label %23

; <label>:23:                                     ; preds = %22, %26
  %24 = phi i64 [ %27, %26 ], [ %3, %22 ]
  %25 = icmp sgt i64 %24, %17
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %23
  %27 = add nsw i64 %24, -1
  %28 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %27) #16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %24) #16
  br label %23

; <label>:29:                                     ; preds = %1
  %30 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.595, i64 0, i64 0)) #16
  unreachable

; <label>:31:                                     ; preds = %23, %1
  %32 = phi i64 [ %3, %1 ], [ %17, %23 ]
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %32) #16
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tpack(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !49
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !61
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %13, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1) #16
  %14 = shl i64 %11, 28
  %15 = ashr exact i64 %14, 32
  br label %16

; <label>:16:                                     ; preds = %19, %1
  %17 = phi i64 [ %20, %19 ], [ %15, %1 ]
  %18 = icmp sgt i64 %17, 0
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %17) #16
  %20 = add nsw i64 %17, -1
  br label %16

; <label>:21:                                     ; preds = %16
  %22 = shl i64 %11, 28
  %23 = ashr exact i64 %22, 32
  %24 = bitcast %union.StackValue** %2 to %struct.TValue**
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !20
  %26 = bitcast %struct.TValue* %25 to i64*
  store i64 %23, i64* %26, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  store i8 35, i8* %27, align 8, !tbaa !22
  %28 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  store %union.StackValue* %29, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_setfield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tunpack(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 3) #16
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  br label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 3) #16
  br label %9

; <label>:9:                                      ; preds = %7, %5
  %10 = phi i64 [ %6, %5 ], [ %8, %7 ]
  %11 = icmp slt i64 %10, %2
  br i1 %11, label %31, label %12

; <label>:12:                                     ; preds = %9
  %13 = sub i64 %10, %2
  %14 = icmp ugt i64 %13, 2147483646
  br i1 %14, label %21, label %15

; <label>:15:                                     ; preds = %12
  %16 = trunc i64 %13 to i32
  %17 = add i32 %16, 1
  %18 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %17) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %15
  br label %23

; <label>:21:                                     ; preds = %15, %12
  %22 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.596, i64 0, i64 0)) #16
  unreachable

; <label>:23:                                     ; preds = %20, %26
  %24 = phi i64 [ %28, %26 ], [ %2, %20 ]
  %25 = icmp slt i64 %24, %10
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %23
  %27 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %24) #16
  %28 = add nsw i64 %24, 1
  br label %23

; <label>:29:                                     ; preds = %23
  %30 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %10) #16
  br label %31

; <label>:31:                                     ; preds = %9, %29
  %32 = phi i32 [ %17, %29 ], [ 0, %9 ]
  ret i32 %32
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tremove(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 %2) #16
  %4 = icmp ne i64 %3, %2
  %5 = add i64 %3, -1
  %6 = icmp ugt i64 %5, %2
  %7 = and i1 %4, %6
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %1
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0)) #16
  br label %10

; <label>:10:                                     ; preds = %1, %8
  %11 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3) #16
  br label %12

; <label>:12:                                     ; preds = %15, %10
  %13 = phi i64 [ %3, %10 ], [ %16, %15 ]
  %14 = icmp slt i64 %13, %2
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %12
  %16 = add nsw i64 %13, 1
  %17 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %16) #16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %13) #16
  br label %12

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = bitcast %union.StackValue** %19 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  store i8 0, i8* %22, align 8, !tbaa !21
  %23 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %19, align 8, !tbaa !20
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %13) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @tmove(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 3) #16
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 4) #16
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 5) #16
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %6, i32 5, i32 1
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 1) #16
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 %7, i32 2) #16
  %8 = icmp slt i64 %3, %2
  br i1 %8, label %48, label %9

; <label>:9:                                      ; preds = %1
  %10 = icmp sgt i64 %2, 0
  %11 = add nsw i64 %2, 9223372036854775807
  %12 = icmp slt i64 %3, %11
  %13 = or i1 %10, %12
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %9
  %15 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.597, i64 0, i64 0)) #16
  br label %16

; <label>:16:                                     ; preds = %14, %9
  %17 = sub nsw i64 %3, %2
  %18 = sub i64 9223372036854775807, %17
  %19 = icmp sgt i64 %4, %18
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %16
  %21 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.598, i64 0, i64 0)) #16
  br label %22

; <label>:22:                                     ; preds = %16, %20
  %23 = icmp sle i64 %4, %3
  %24 = icmp sgt i64 %4, %2
  %25 = and i1 %23, %24
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %22
  br i1 %6, label %28, label %27

; <label>:27:                                     ; preds = %28, %26
  br label %40

; <label>:28:                                     ; preds = %26
  %29 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 1, i32 %7, i32 0) #16
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %31, label %27

; <label>:31:                                     ; preds = %22, %28
  br label %32

; <label>:32:                                     ; preds = %31, %35
  %33 = phi i64 [ %39, %35 ], [ 0, %31 ]
  %34 = icmp sgt i64 %33, %17
  br i1 %34, label %48, label %35

; <label>:35:                                     ; preds = %32
  %36 = add nsw i64 %33, %2
  %37 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %36) #16
  %38 = add nsw i64 %33, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %7, i64 %38) #16
  %39 = add nuw nsw i64 %33, 1
  br label %32

; <label>:40:                                     ; preds = %27, %43
  %41 = phi i64 [ %47, %43 ], [ %17, %27 ]
  %42 = icmp sgt i64 %41, -1
  br i1 %42, label %43, label %48

; <label>:43:                                     ; preds = %40
  %44 = add nsw i64 %41, %2
  %45 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %44) #16
  %46 = add nsw i64 %41, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %7, i64 %46) #16
  %47 = add nsw i64 %41, -1
  br label %40

; <label>:48:                                     ; preds = %40, %32, %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %7) #16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @sort(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = icmp sgt i64 %2, 1
  br i1 %3, label %4, label %14

; <label>:4:                                      ; preds = %1
  %5 = icmp slt i64 %2, 2147483647
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.599, i64 0, i64 0)) #16
  br label %8

; <label>:8:                                      ; preds = %6, %4
  %9 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  %10 = icmp slt i32 %9, 1
  br i1 %10, label %12, label %11

; <label>:11:                                     ; preds = %8
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 2, i32 6) #16
  br label %12

; <label>:12:                                     ; preds = %11, %8
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %13 = trunc i64 %2 to i32
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 1, i32 %13, i32 0) #16
  br label %14

; <label>:14:                                     ; preds = %12, %1
  ret i32 0
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @checktab(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 5
  br i1 %5, label %35, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %34, label %9

; <label>:9:                                      ; preds = %6
  %10 = and i32 %2, 1
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %15, label %12

; <label>:12:                                     ; preds = %9
  %13 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0), i32 2) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %34, label %15

; <label>:15:                                     ; preds = %12, %9
  %16 = phi i32 [ 2, %12 ], [ 1, %9 ]
  %17 = and i32 %2, 2
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %15
  %20 = add nuw nsw i32 %16, 1
  %21 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i64 0, i64 0), i32 %20) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %34, label %23

; <label>:23:                                     ; preds = %19, %15
  %24 = phi i32 [ %20, %19 ], [ %16, %15 ]
  %25 = and i32 %2, 4
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %23
  %28 = add nsw i32 %24, 1
  %29 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i64 0, i64 0), i32 %28) #16
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %27, %23
  %32 = phi i32 [ %28, %27 ], [ %24, %23 ]
  %33 = xor i32 %32, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %33) #16
  br label %35

; <label>:34:                                     ; preds = %12, %19, %27, %6
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 5) #16
  br label %35

; <label>:35:                                     ; preds = %31, %34, %3
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @addfield(%struct.lua_State*, %struct.luaL_Buffer*, i64) unnamed_addr #0 {
  %4 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %2) #16
  %5 = tail call i32 @lua_isstring(%struct.lua_State* %0, i32 -1) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %14

; <label>:7:                                      ; preds = %3
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #16
  %9 = add nsw i32 %8, 1
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %10
  %12 = load i8*, i8** %11, align 8, !tbaa !39
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.593, i64 0, i64 0), i8* %12, i64 %2) #16
  unreachable

; <label>:14:                                     ; preds = %3
  tail call void @luaL_addvalue(%struct.luaL_Buffer* %1) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @checkfield(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1) #16
  %5 = sub nsw i32 0, %2
  %6 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 %5) #16
  %7 = icmp ne i32 %6, 0
  %8 = zext i1 %7 to i32
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @auxsort(%struct.lua_State*, i32, i32, i32) unnamed_addr #0 {
  %5 = alloca [4 x i32], align 16
  %6 = bitcast [4 x i32]* %5 to i8*
  %7 = bitcast [4 x i32]* %5 to i64*
  %8 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i64 2
  %9 = bitcast i32* %8 to i64*
  br label %10

; <label>:10:                                     ; preds = %121, %4
  %11 = phi i32 [ %103, %121 ], [ %1, %4 ]
  %12 = phi i32 [ %104, %121 ], [ %2, %4 ]
  %13 = phi i32 [ %114, %121 ], [ %3, %4 ]
  %14 = icmp eq i32 %13, 0
  br label %15

; <label>:15:                                     ; preds = %10, %102
  %16 = phi i32 [ %103, %102 ], [ %11, %10 ]
  %17 = phi i32 [ %104, %102 ], [ %12, %10 ]
  %18 = icmp ugt i32 %17, %16
  br i1 %18, label %19, label %122

; <label>:19:                                     ; preds = %15
  %20 = zext i32 %16 to i64
  %21 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %20) #16
  %22 = zext i32 %17 to i64
  %23 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %22) #16
  %24 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %16, i32 %17) #16
  br label %28

; <label>:27:                                     ; preds = %19
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3) #16
  br label %28

; <label>:28:                                     ; preds = %27, %26
  %29 = sub i32 %17, %16
  %30 = icmp eq i32 %29, 1
  br i1 %30, label %122, label %31

; <label>:31:                                     ; preds = %28
  %32 = icmp ult i32 %29, 100
  %33 = or i1 %32, %14
  br i1 %33, label %34, label %37

; <label>:34:                                     ; preds = %31
  %35 = add i32 %17, %16
  %36 = lshr i32 %35, 1
  br label %43

; <label>:37:                                     ; preds = %31
  %38 = lshr i32 %29, 2
  %39 = shl nuw nsw i32 %38, 1
  %40 = urem i32 %13, %39
  %41 = add i32 %38, %16
  %42 = add i32 %41, %40
  br label %43

; <label>:43:                                     ; preds = %37, %34
  %44 = phi i32 [ %36, %34 ], [ %42, %37 ]
  %45 = zext i32 %44 to i64
  %46 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %45) #16
  %47 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %20) #16
  %48 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -2, i32 -1) #16
  %49 = icmp eq i32 %48, 0
  br i1 %49, label %51, label %50

; <label>:50:                                     ; preds = %43
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %44, i32 %16) #16
  br label %57

; <label>:51:                                     ; preds = %43
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %52 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %22) #16
  %53 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %56, label %55

; <label>:55:                                     ; preds = %51
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %44, i32 %17) #16
  br label %57

; <label>:56:                                     ; preds = %51
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3) #16
  br label %57

; <label>:57:                                     ; preds = %55, %56, %50
  %58 = icmp eq i32 %29, 2
  br i1 %58, label %122, label %59

; <label>:59:                                     ; preds = %57
  %60 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %45) #16
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1) #16
  %61 = add i32 %17, -1
  %62 = zext i32 %61 to i64
  %63 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %62) #16
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %44, i32 %61) #16
  br label %64

; <label>:64:                                     ; preds = %93, %59
  %65 = phi i32 [ %16, %59 ], [ %69, %93 ]
  %66 = phi i32 [ %61, %59 ], [ %82, %93 ]
  br label %67

; <label>:67:                                     ; preds = %79, %64
  %68 = phi i32 [ %65, %64 ], [ %69, %79 ]
  %69 = add i32 %68, 1
  %70 = zext i32 %69 to i64
  %71 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %70) #17
  %72 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #17
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %74, label %75

; <label>:74:                                     ; preds = %67
  br label %80

; <label>:75:                                     ; preds = %67
  %76 = icmp eq i32 %69, %61
  br i1 %76, label %77, label %79

; <label>:77:                                     ; preds = %75
  %78 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0)) #17
  unreachable

; <label>:79:                                     ; preds = %75
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  br label %67

; <label>:80:                                     ; preds = %74, %91
  %81 = phi i32 [ %82, %91 ], [ %66, %74 ]
  %82 = add i32 %81, -1
  %83 = zext i32 %82 to i64
  %84 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %83) #17
  %85 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -3, i32 -1) #17
  %86 = icmp eq i32 %85, 0
  %87 = icmp ult i32 %82, %69
  br i1 %86, label %92, label %88

; <label>:88:                                     ; preds = %80
  br i1 %87, label %89, label %91

; <label>:89:                                     ; preds = %88
  %90 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0)) #17
  unreachable

; <label>:91:                                     ; preds = %88
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  br label %80

; <label>:92:                                     ; preds = %80
  br i1 %87, label %94, label %93

; <label>:93:                                     ; preds = %92
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %69, i32 %82) #17
  br label %64

; <label>:94:                                     ; preds = %92
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %61, i32 %69) #17
  %95 = sub i32 %69, %16
  %96 = sub i32 %17, %69
  %97 = icmp ult i32 %95, %96
  br i1 %97, label %98, label %100

; <label>:98:                                     ; preds = %94
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 %16, i32 %68, i32 %13) #16
  %99 = add i32 %68, 2
  br label %102

; <label>:100:                                    ; preds = %94
  %101 = add i32 %68, 2
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 %101, i32 %17, i32 %13) #16
  br label %102

; <label>:102:                                    ; preds = %100, %98
  %103 = phi i32 [ %99, %98 ], [ %16, %100 ]
  %104 = phi i32 [ %17, %98 ], [ %68, %100 ]
  %105 = phi i32 [ %95, %98 ], [ %96, %100 ]
  %106 = sub i32 %104, %103
  %107 = lshr i32 %106, 7
  %108 = icmp ugt i32 %107, %105
  br i1 %108, label %109, label %15

; <label>:109:                                    ; preds = %102
  %110 = tail call i64 @clock() #17
  %111 = tail call i64 @time(i64* null) #17
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  store i64 %110, i64* %7, align 16
  store i64 %111, i64* %9, align 8
  br label %112

; <label>:112:                                    ; preds = %116, %109
  %113 = phi i64 [ %120, %116 ], [ 0, %109 ]
  %114 = phi i32 [ %119, %116 ], [ 0, %109 ]
  %115 = icmp eq i64 %113, 4
  br i1 %115, label %121, label %116

; <label>:116:                                    ; preds = %112
  %117 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i64 %113
  %118 = load i32, i32* %117, align 4, !tbaa !74
  %119 = add i32 %118, %114
  %120 = add nuw nsw i64 %113, 1
  br label %112

; <label>:121:                                    ; preds = %112
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  br label %10

; <label>:122:                                    ; preds = %28, %57, %15
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @sort_comp(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %1, i32 %2, i32 1) #16
  br label %15

; <label>:8:                                      ; preds = %3
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 2) #16
  %9 = add nsw i32 %1, -1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %9) #16
  %10 = add nsw i32 %2, -2
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %10) #16
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %13, i32 1) #17
  %14 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  br label %15

; <label>:15:                                     ; preds = %8, %6
  %16 = phi i32 [ %7, %6 ], [ %14, %8 ]
  ret i32 %16
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @set2(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = zext i32 %1 to i64
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %4) #16
  %5 = zext i32 %2 to i64
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %5) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @byteoffset(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %6 = icmp sgt i64 %5, -1
  %7 = load i64, i64* %2, align 8
  %8 = add i64 %7, 1
  %9 = select i1 %6, i64 1, i64 %8
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %9) #16
  %11 = load i64, i64* %2, align 8, !tbaa !135
  %12 = icmp sgt i64 %10, -1
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %1
  %14 = sub i64 0, %10
  %15 = icmp ult i64 %11, %14
  br i1 %15, label %25, label %16

; <label>:16:                                     ; preds = %13
  %17 = add i64 %10, 1
  %18 = add i64 %17, %11
  br label %19

; <label>:19:                                     ; preds = %1, %16
  %20 = phi i64 [ %18, %16 ], [ %10, %1 ]
  %21 = icmp sgt i64 %20, 0
  br i1 %21, label %22, label %25

; <label>:22:                                     ; preds = %19
  %23 = add nsw i64 %20, -1
  %24 = icmp sgt i64 %23, %11
  br i1 %24, label %25, label %28

; <label>:25:                                     ; preds = %13, %22, %19
  %26 = phi i64 [ %23, %22 ], [ %20, %19 ], [ 0, %13 ]
  %27 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.604, i64 0, i64 0)) #16
  br label %28

; <label>:28:                                     ; preds = %22, %25
  %29 = phi i64 [ %23, %22 ], [ %26, %25 ]
  %30 = icmp eq i64 %5, 0
  br i1 %30, label %31, label %42

; <label>:31:                                     ; preds = %28
  br label %32

; <label>:32:                                     ; preds = %31, %40
  %33 = phi i64 [ %41, %40 ], [ %29, %31 ]
  %34 = icmp sgt i64 %33, 0
  br i1 %34, label %35, label %92

; <label>:35:                                     ; preds = %32
  %36 = getelementptr inbounds i8, i8* %4, i64 %33
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = and i8 %37, -64
  %39 = icmp eq i8 %38, -128
  br i1 %39, label %40, label %92

; <label>:40:                                     ; preds = %35
  %41 = add nsw i64 %33, -1
  br label %32

; <label>:42:                                     ; preds = %28
  %43 = getelementptr inbounds i8, i8* %4, i64 %29
  %44 = load i8, i8* %43, align 1, !tbaa !21
  %45 = and i8 %44, -64
  %46 = icmp eq i8 %45, -128
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %42
  %48 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.605, i64 0, i64 0)) #16
  unreachable

; <label>:49:                                     ; preds = %42
  %50 = icmp slt i64 %5, 0
  br i1 %50, label %51, label %70

; <label>:51:                                     ; preds = %49
  br label %52

; <label>:52:                                     ; preds = %51, %68
  %53 = phi i64 [ %69, %68 ], [ %5, %51 ]
  %54 = phi i64 [ %61, %68 ], [ %29, %51 ]
  %55 = icmp slt i64 %53, 0
  %56 = icmp sgt i64 %54, 0
  %57 = and i1 %55, %56
  br i1 %57, label %58, label %88

; <label>:58:                                     ; preds = %52
  br label %59

; <label>:59:                                     ; preds = %58, %63
  %60 = phi i64 [ %61, %63 ], [ %54, %58 ]
  %61 = add nsw i64 %60, -1
  %62 = icmp sgt i64 %60, 1
  br i1 %62, label %63, label %68

; <label>:63:                                     ; preds = %59
  %64 = getelementptr inbounds i8, i8* %4, i64 %61
  %65 = load i8, i8* %64, align 1, !tbaa !21
  %66 = and i8 %65, -64
  %67 = icmp eq i8 %66, -128
  br i1 %67, label %59, label %68

; <label>:68:                                     ; preds = %59, %63
  %69 = add nsw i64 %53, 1
  br label %52

; <label>:70:                                     ; preds = %49
  %71 = load i64, i64* %2, align 8
  br label %73

; <label>:72:                                     ; preds = %81
  br label %73

; <label>:73:                                     ; preds = %72, %70
  %74 = phi i64 [ %5, %70 ], [ %76, %72 ]
  %75 = phi i64 [ %29, %70 ], [ %83, %72 ]
  %76 = add nsw i64 %74, -1
  %77 = icmp sgt i64 %74, 1
  %78 = icmp slt i64 %75, %71
  %79 = and i1 %77, %78
  br i1 %79, label %80, label %88

; <label>:80:                                     ; preds = %73
  br label %81

; <label>:81:                                     ; preds = %80, %81
  %82 = phi i64 [ %83, %81 ], [ %75, %80 ]
  %83 = add nsw i64 %82, 1
  %84 = getelementptr inbounds i8, i8* %4, i64 %83
  %85 = load i8, i8* %84, align 1, !tbaa !21
  %86 = and i8 %85, -64
  %87 = icmp eq i8 %86, -128
  br i1 %87, label %81, label %72

; <label>:88:                                     ; preds = %73, %52
  %89 = phi i64 [ %53, %52 ], [ %76, %73 ]
  %90 = phi i64 [ %54, %52 ], [ %75, %73 ]
  %91 = icmp eq i64 %89, 0
  br i1 %91, label %92, label %99

; <label>:92:                                     ; preds = %35, %32, %88
  %93 = phi i64 [ %90, %88 ], [ %33, %32 ], [ %33, %35 ]
  %94 = add nsw i64 %93, 1
  %95 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %96 = bitcast %union.StackValue** %95 to %struct.TValue**
  %97 = load %struct.TValue*, %struct.TValue** %96, align 8, !tbaa !20
  %98 = bitcast %struct.TValue* %97 to i64*
  store i64 %94, i64* %98, align 8, !tbaa !21
  br label %103

; <label>:99:                                     ; preds = %88
  %100 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %101 = bitcast %union.StackValue** %100 to %struct.TValue**
  %102 = load %struct.TValue*, %struct.TValue** %101, align 8, !tbaa !20
  br label %103

; <label>:103:                                    ; preds = %92, %99
  %104 = phi %struct.TValue* [ %97, %92 ], [ %102, %99 ]
  %105 = phi i8 [ 35, %92 ], [ 0, %99 ]
  %106 = phi %union.StackValue** [ %95, %92 ], [ %100, %99 ]
  %107 = getelementptr inbounds %struct.TValue, %struct.TValue* %104, i64 0, i32 1
  store i8 %105, i8* %107, align 8, !tbaa !21
  %108 = load %union.StackValue*, %union.StackValue** %106, align 8, !tbaa !20
  %109 = getelementptr inbounds %union.StackValue, %union.StackValue* %108, i64 1
  store %union.StackValue* %109, %union.StackValue** %106, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @codepoint(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i32, align 4
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %6 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %7 = load i64, i64* %2, align 8, !tbaa !135
  %8 = icmp sgt i64 %6, -1
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %1
  %10 = sub i64 0, %6
  %11 = icmp ult i64 %7, %10
  br i1 %11, label %15, label %12

; <label>:12:                                     ; preds = %9
  %13 = add i64 %6, 1
  %14 = add i64 %13, %7
  br label %15

; <label>:15:                                     ; preds = %1, %9, %12
  %16 = phi i64 [ %14, %12 ], [ %6, %1 ], [ 0, %9 ]
  %17 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %16) #16
  %18 = load i64, i64* %2, align 8, !tbaa !135
  %19 = icmp sgt i64 %17, -1
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %15
  %21 = sub i64 0, %17
  %22 = icmp ult i64 %18, %21
  br i1 %22, label %26, label %23

; <label>:23:                                     ; preds = %20
  %24 = add i64 %17, 1
  %25 = add i64 %24, %18
  br label %26

; <label>:26:                                     ; preds = %15, %20, %23
  %27 = phi i64 [ %25, %23 ], [ %17, %15 ], [ 0, %20 ]
  %28 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4) #16
  %29 = icmp sgt i64 %16, 0
  br i1 %29, label %33, label %30

; <label>:30:                                     ; preds = %26
  %31 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0)) #16
  %32 = load i64, i64* %2, align 8, !tbaa !135
  br label %33

; <label>:33:                                     ; preds = %30, %26
  %34 = phi i64 [ %32, %30 ], [ %18, %26 ]
  %35 = icmp sgt i64 %27, %34
  br i1 %35, label %36, label %38

; <label>:36:                                     ; preds = %33
  %37 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0)) #16
  br label %38

; <label>:38:                                     ; preds = %33, %36
  %39 = icmp slt i64 %27, %16
  br i1 %39, label %74, label %40

; <label>:40:                                     ; preds = %38
  %41 = sub nsw i64 %27, %16
  %42 = icmp sgt i64 %41, 2147483646
  br i1 %42, label %43, label %45

; <label>:43:                                     ; preds = %40
  %44 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  unreachable

; <label>:45:                                     ; preds = %40
  %46 = trunc i64 %41 to i32
  %47 = add nsw i32 %46, 1
  call void @luaL_checkstack(%struct.lua_State* %0, i32 %47, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  %48 = getelementptr inbounds i8, i8* %5, i64 %27
  %49 = add nsw i64 %16, -1
  %50 = getelementptr inbounds i8, i8* %5, i64 %49
  %51 = bitcast i32* %3 to i8*
  %52 = icmp eq i32 %28, 0
  %53 = zext i1 %52 to i32
  %54 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %55 = bitcast %union.StackValue** %54 to %struct.TValue**
  br label %56

; <label>:56:                                     ; preds = %65, %45
  %57 = phi i8* [ %50, %45 ], [ %61, %65 ]
  %58 = phi i32 [ 0, %45 ], [ %73, %65 ]
  %59 = icmp ult i8* %57, %48
  br i1 %59, label %60, label %74

; <label>:60:                                     ; preds = %56
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %51) #7
  %61 = call fastcc i8* @utf8_decode(i8* %57, i32* nonnull %3, i32 %53) #16
  %62 = icmp eq i8* %61, null
  br i1 %62, label %63, label %65

; <label>:63:                                     ; preds = %60
  %64 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0)) #16
  unreachable

; <label>:65:                                     ; preds = %60
  %66 = load i32, i32* %3, align 4, !tbaa !74
  %67 = zext i32 %66 to i64
  %68 = load %struct.TValue*, %struct.TValue** %55, align 8, !tbaa !20
  %69 = bitcast %struct.TValue* %68 to i64*
  store i64 %67, i64* %69, align 8, !tbaa !21
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %68, i64 0, i32 1
  store i8 35, i8* %70, align 8, !tbaa !22
  %71 = load %union.StackValue*, %union.StackValue** %54, align 8, !tbaa !20
  %72 = getelementptr inbounds %union.StackValue, %union.StackValue* %71, i64 1
  store %union.StackValue* %72, %union.StackValue** %54, align 8, !tbaa !20
  %73 = add nuw nsw i32 %58, 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %51) #7
  br label %56

; <label>:74:                                     ; preds = %56, %38
  %75 = phi i32 [ 0, %38 ], [ %58, %56 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %75
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @utfchar(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !61
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = icmp eq i32 %14, 1
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %1
  tail call fastcc void @pushutfchar(%struct.lua_State* nonnull %0, i32 1) #16
  br label %30

; <label>:17:                                     ; preds = %1
  %18 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %18) #7
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %19, align 8, !tbaa !202
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %21 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %20, %union.anon.6** %21, align 8, !tbaa !201
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %23 = bitcast i64* %22 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %23, align 8, !tbaa !135
  br label %24

; <label>:24:                                     ; preds = %27, %17
  %25 = phi i32 [ 1, %17 ], [ %28, %27 ]
  %26 = icmp sgt i32 %25, %14
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  call fastcc void @pushutfchar(%struct.lua_State* %0, i32 %25) #16
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %2) #16
  %28 = add nuw nsw i32 %25, 1
  br label %24

; <label>:29:                                     ; preds = %24
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %18) #7
  br label %30

; <label>:30:                                     ; preds = %29, %16
  ret i32 1
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @utflen(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %6 = load i64, i64* %2, align 8, !tbaa !135
  %7 = icmp sgt i64 %5, -1
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %1
  %9 = sub i64 0, %5
  %10 = icmp ult i64 %6, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %8
  %12 = add i64 %5, 1
  %13 = add i64 %12, %6
  br label %14

; <label>:14:                                     ; preds = %1, %8, %11
  %15 = phi i64 [ %13, %11 ], [ %5, %1 ], [ 0, %8 ]
  %16 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 -1) #16
  %17 = load i64, i64* %2, align 8, !tbaa !135
  %18 = icmp sgt i64 %16, -1
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %14
  %20 = sub i64 0, %16
  %21 = icmp ult i64 %17, %20
  br i1 %21, label %25, label %22

; <label>:22:                                     ; preds = %19
  %23 = add i64 %16, 1
  %24 = add i64 %23, %17
  br label %25

; <label>:25:                                     ; preds = %14, %19, %22
  %26 = phi i64 [ %24, %22 ], [ %16, %14 ], [ 0, %19 ]
  %27 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4) #16
  %28 = icmp sgt i64 %15, 0
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %25
  %30 = add nsw i64 %15, -1
  %31 = icmp sgt i64 %30, %17
  br i1 %31, label %32, label %36

; <label>:32:                                     ; preds = %29, %25
  %33 = phi i64 [ %30, %29 ], [ %15, %25 ]
  %34 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0)) #16
  %35 = load i64, i64* %2, align 8, !tbaa !135
  br label %36

; <label>:36:                                     ; preds = %29, %32
  %37 = phi i64 [ %17, %29 ], [ %35, %32 ]
  %38 = phi i64 [ %30, %29 ], [ %33, %32 ]
  %39 = icmp sgt i64 %26, %37
  br i1 %39, label %40, label %42

; <label>:40:                                     ; preds = %36
  %41 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.609, i64 0, i64 0)) #16
  br label %42

; <label>:42:                                     ; preds = %36, %40
  %43 = icmp eq i32 %27, 0
  %44 = zext i1 %43 to i32
  %45 = ptrtoint i8* %4 to i64
  br label %46

; <label>:46:                                     ; preds = %64, %42
  %47 = phi i64 [ %38, %42 ], [ %66, %64 ]
  %48 = phi i64 [ 0, %42 ], [ %67, %64 ]
  %49 = icmp slt i64 %47, %26
  br i1 %49, label %50, label %68

; <label>:50:                                     ; preds = %46
  %51 = getelementptr inbounds i8, i8* %4, i64 %47
  %52 = call fastcc i8* @utf8_decode(i8* %51, i32* null, i32 %44) #16
  %53 = icmp eq i8* %52, null
  br i1 %53, label %54, label %64

; <label>:54:                                     ; preds = %50
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %56 = bitcast %union.StackValue** %55 to %struct.TValue**
  %57 = load %struct.TValue*, %struct.TValue** %56, align 8, !tbaa !20
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 0, i32 1
  store i8 0, i8* %58, align 8, !tbaa !21
  %59 = load %union.StackValue*, %union.StackValue** %55, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 1
  store %union.StackValue* %60, %union.StackValue** %55, align 8, !tbaa !20
  %61 = add nsw i64 %47, 1
  %62 = bitcast %union.StackValue* %60 to i64*
  store i64 %61, i64* %62, align 8, !tbaa !21
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 1, i32 0, i32 1
  br label %74

; <label>:64:                                     ; preds = %50
  %65 = ptrtoint i8* %52 to i64
  %66 = sub i64 %65, %45
  %67 = add nuw nsw i64 %48, 1
  br label %46

; <label>:68:                                     ; preds = %46
  %69 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %70 = bitcast %union.StackValue** %69 to %struct.TValue**
  %71 = load %struct.TValue*, %struct.TValue** %70, align 8, !tbaa !20
  %72 = bitcast %struct.TValue* %71 to i64*
  store i64 %48, i64* %72, align 8, !tbaa !21
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %71, i64 0, i32 1
  br label %74

; <label>:74:                                     ; preds = %54, %68
  %75 = phi i8* [ %63, %54 ], [ %73, %68 ]
  %76 = phi %union.StackValue** [ %55, %54 ], [ %69, %68 ]
  %77 = phi i32 [ 2, %54 ], [ 1, %68 ]
  store i8 35, i8* %75, align 8, !tbaa !22
  %78 = load %union.StackValue*, %union.StackValue** %76, align 8, !tbaa !20
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 1
  store %union.StackValue* %79, %union.StackValue** %76, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %77
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @iter_codes(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %4 = icmp eq i32 %2, 0
  %5 = select i1 %4, i32 (%struct.lua_State*)* @iter_auxstrict, i32 (%struct.lua_State*)* @iter_auxlax
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %5, i32 (%struct.lua_State*)** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 38, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1) #16
  %13 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to i64*
  store i64 0, i64* %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 35, i8* %15, align 8, !tbaa !22
  %16 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 1
  store %union.StackValue* %17, %union.StackValue** %6, align 8, !tbaa !20
  ret i32 3
}

; Function Attrs: minsize norecurse nounwind optsize uwtable
define internal fastcc i8* @utf8_decode(i8* readonly, i32*, i32) unnamed_addr #2 {
  %4 = load i8, i8* %0, align 1, !tbaa !21
  %5 = zext i8 %4 to i32
  %6 = icmp sgt i8 %4, -1
  br i1 %6, label %41, label %7

; <label>:7:                                      ; preds = %3
  br label %8

; <label>:8:                                      ; preds = %7, %21
  %9 = phi i64 [ %15, %21 ], [ 0, %7 ]
  %10 = phi i32 [ %25, %21 ], [ %5, %7 ]
  %11 = phi i32 [ %24, %21 ], [ 0, %7 ]
  %12 = and i32 %10, 64
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %26, label %14

; <label>:14:                                     ; preds = %8
  %15 = add nuw i64 %9, 1
  %16 = getelementptr inbounds i8, i8* %0, i64 %15
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  %19 = and i32 %18, 192
  %20 = icmp eq i32 %19, 128
  br i1 %20, label %21, label %55

; <label>:21:                                     ; preds = %14
  %22 = shl i32 %11, 6
  %23 = and i32 %18, 63
  %24 = or i32 %23, %22
  %25 = shl i32 %10, 1
  br label %8

; <label>:26:                                     ; preds = %8
  %27 = trunc i64 %9 to i32
  %28 = and i32 %10, 127
  %29 = mul nsw i32 %27, 5
  %30 = shl i32 %28, %29
  %31 = or i32 %30, %11
  %32 = icmp ugt i32 %27, 5
  %33 = icmp slt i32 %31, 0
  %34 = or i1 %32, %33
  br i1 %34, label %55, label %35

; <label>:35:                                     ; preds = %26
  %36 = and i64 %9, 4294967295
  %37 = getelementptr inbounds [6 x i32], [6 x i32]* @utf8_decode.limits, i64 0, i64 %36
  %38 = load i32, i32* %37, align 4, !tbaa !74
  %39 = icmp ult i32 %31, %38
  %40 = getelementptr inbounds i8, i8* %0, i64 %36
  br i1 %39, label %55, label %41

; <label>:41:                                     ; preds = %35, %3
  %42 = phi i8* [ %0, %3 ], [ %40, %35 ]
  %43 = phi i32 [ %5, %3 ], [ %31, %35 ]
  %44 = icmp eq i32 %2, 0
  br i1 %44, label %50, label %45

; <label>:45:                                     ; preds = %41
  %46 = icmp ugt i32 %43, 1114111
  %47 = and i32 %43, -2048
  %48 = icmp eq i32 %47, 55296
  %49 = or i1 %46, %48
  br i1 %49, label %55, label %50

; <label>:50:                                     ; preds = %45, %41
  %51 = icmp eq i32* %1, null
  br i1 %51, label %53, label %52

; <label>:52:                                     ; preds = %50
  store i32 %43, i32* %1, align 4, !tbaa !74
  br label %53

; <label>:53:                                     ; preds = %50, %52
  %54 = getelementptr inbounds i8, i8* %42, i64 1
  br label %55

; <label>:55:                                     ; preds = %14, %35, %26, %45, %53
  %56 = phi i8* [ %54, %53 ], [ null, %45 ], [ null, %26 ], [ null, %35 ], [ null, %14 ]
  ret i8* %56
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @pushutfchar(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1) #16
  %4 = icmp ult i64 %3, 2147483648
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0)) #16
  br label %7

; <label>:7:                                      ; preds = %5, %2
  %8 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.608, i64 0, i64 0), i64 %3) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @iter_auxlax(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @iter_auxstrict(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @iter_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %7 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 2, i32* null) #16
  %8 = icmp slt i64 %7, 1
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %2
  %10 = load i64, i64* %3, align 8, !tbaa !135
  br label %23

; <label>:11:                                     ; preds = %2
  %12 = add nsw i64 %7, -1
  %13 = load i64, i64* %3, align 8, !tbaa !135
  %14 = icmp sgt i64 %7, %13
  br i1 %14, label %23, label %15

; <label>:15:                                     ; preds = %11
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi i64 [ %22, %16 ], [ %7, %15 ]
  %18 = getelementptr inbounds i8, i8* %6, i64 %17
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = and i8 %19, -64
  %21 = icmp eq i8 %20, -128
  %22 = add nsw i64 %17, 1
  br i1 %21, label %16, label %23

; <label>:23:                                     ; preds = %16, %9, %11
  %24 = phi i64 [ %13, %11 ], [ %10, %9 ], [ %13, %16 ]
  %25 = phi i64 [ %12, %11 ], [ 0, %9 ], [ %17, %16 ]
  %26 = icmp slt i64 %25, %24
  br i1 %26, label %27, label %49

; <label>:27:                                     ; preds = %23
  %28 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %28) #7
  %29 = getelementptr inbounds i8, i8* %6, i64 %25
  %30 = call fastcc i8* @utf8_decode(i8* %29, i32* nonnull %4, i32 %1) #16
  %31 = icmp eq i8* %30, null
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %27
  %33 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0)) #16
  unreachable

; <label>:34:                                     ; preds = %27
  %35 = add nsw i64 %25, 1
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %37 = bitcast %union.StackValue** %36 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to i64*
  store i64 %35, i64* %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 35, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %36, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %36, align 8, !tbaa !20
  %43 = load i32, i32* %4, align 4, !tbaa !74
  %44 = zext i32 %43 to i64
  %45 = bitcast %union.StackValue* %42 to i64*
  store i64 %44, i64* %45, align 8, !tbaa !21
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1, i32 0, i32 1
  store i8 35, i8* %46, align 8, !tbaa !22
  %47 = load %union.StackValue*, %union.StackValue** %36, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 1
  store %union.StackValue* %48, %union.StackValue** %36, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %28) #7
  br label %49

; <label>:49:                                     ; preds = %23, %34
  %50 = phi i32 [ 2, %34 ], [ 0, %23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 %50
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @print_version() unnamed_addr #0 {
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %2 = tail call i64 @fwrite(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.621, i64 0, i64 0), i64 1, i64 51, %struct._IO_FILE* %1) #16
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %4 = tail call i32 @fputc(i32 10, %struct._IO_FILE* %3)
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @createargtable(%struct.lua_State*, i8** nocapture readonly, i32, i32) unnamed_addr #0 {
  %5 = icmp eq i32 %3, %2
  %6 = select i1 %5, i32 0, i32 %3
  %7 = add nsw i32 %6, 1
  %8 = sub nsw i32 %2, %7
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %8, i32 %7) #16
  %9 = sext i32 %2 to i64
  %10 = sext i32 %6 to i64
  br label %11

; <label>:11:                                     ; preds = %14, %4
  %12 = phi i64 [ %19, %14 ], [ 0, %4 ]
  %13 = icmp slt i64 %12, %9
  br i1 %13, label %14, label %20

; <label>:14:                                     ; preds = %11
  %15 = getelementptr inbounds i8*, i8** %1, i64 %12
  %16 = load i8*, i8** %15, align 8, !tbaa !39
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %16) #16
  %18 = sub nsw i64 %12, %10
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 -2, i64 %18) #16
  %19 = add nuw nsw i64 %12, 1
  br label %11

; <label>:20:                                     ; preds = %11
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0)) #16
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc void @doREPL(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = load i64, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !39
  store i8* null, i8** @progname, align 8, !tbaa !39
  %5 = bitcast i64* %3 to i8*
  %6 = bitcast i64* %2 to i8*
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to i64*
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  br label %10

; <label>:10:                                     ; preds = %65, %1
  call void @lua_settop(%struct.lua_State* %0, i32 0) #17
  %11 = call fastcc i32 @pushline(%struct.lua_State* %0, i32 1) #17
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %69, label %13

; <label>:13:                                     ; preds = %10
  %14 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %15 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.636, i64 0, i64 0), i8* %14) #17
  %16 = call i64 @strlen(i8* nonnull %15) #21
  %17 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %15, i64 %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null) #17
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %20

; <label>:19:                                     ; preds = %13
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  br label %43

; <label>:20:                                     ; preds = %13
  call void @lua_settop(%struct.lua_State* %0, i32 -3) #17
  br label %21

; <label>:21:                                     ; preds = %39, %20
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %22 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #17
  %23 = load i64, i64* %3, align 8, !tbaa !135
  %24 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %22, i64 %23, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null) #17
  %25 = icmp eq i32 %24, 3
  br i1 %25, label %26, label %42

; <label>:26:                                     ; preds = %21
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %27 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* nonnull %2) #17
  %28 = load i64, i64* %2, align 8, !tbaa !135
  %29 = icmp ugt i64 %28, 4
  br i1 %29, label %30, label %35

; <label>:30:                                     ; preds = %26
  %31 = getelementptr inbounds i8, i8* %27, i64 %28
  %32 = getelementptr inbounds i8, i8* %31, i64 -5
  %33 = call i32 @strcmp(i8* nonnull %32, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i64 0, i64 0)) #21
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %36, label %35

; <label>:35:                                     ; preds = %30, %26
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  br label %41

; <label>:36:                                     ; preds = %30
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  %37 = call fastcc i32 @pushline(%struct.lua_State* %0, i32 0) #17
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %41, label %39

; <label>:39:                                     ; preds = %36
  %40 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.300, i64 0, i64 0)) #17
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #17
  call void @lua_concat(%struct.lua_State* %0, i32 3) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  br label %21

; <label>:41:                                     ; preds = %36, %35
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  br label %66

; <label>:42:                                     ; preds = %21
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1) #17
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #17
  switch i32 %24, label %66 [
    i32 -1, label %69
    i32 0, label %43
  ]

; <label>:43:                                     ; preds = %42, %19
  %44 = call fastcc i32 @docall(%struct.lua_State* %0, i32 0, i32 -1) #16
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %66

; <label>:46:                                     ; preds = %43
  %47 = load i64, i64* %8, align 8, !tbaa !20
  %48 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !49
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %48, i64 0, i32 0
  %50 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !61
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %50, i64 1
  %52 = ptrtoint %union.StackValue* %51 to i64
  %53 = sub i64 %47, %52
  %54 = lshr exact i64 %53, 4
  %55 = trunc i64 %54 to i32
  %56 = icmp sgt i32 %55, 0
  br i1 %56, label %57, label %65

; <label>:57:                                     ; preds = %46
  call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 20, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.637, i64 0, i64 0)) #17
  %58 = call i32 @lua_getglobal(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i64 0, i64 0)) #17
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 1, i32 1) #17
  %59 = call i32 @lua_pcallk(%struct.lua_State* nonnull %0, i32 %55, i32 0, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #17
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %65, label %61

; <label>:61:                                     ; preds = %57
  %62 = load i8*, i8** @progname, align 8, !tbaa !39
  %63 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #17
  %64 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.638, i64 0, i64 0), i8* %63) #17
  call fastcc void @l_message(i8* %62, i8* nonnull %64) #17
  br label %65

; <label>:65:                                     ; preds = %61, %57, %46, %66
  br label %10

; <label>:66:                                     ; preds = %41, %42, %43
  %67 = phi i32 [ %44, %43 ], [ 3, %41 ], [ %24, %42 ]
  %68 = call fastcc i32 @report(%struct.lua_State* %0, i32 %67) #16
  br label %65

; <label>:69:                                     ; preds = %10, %42
  call void @lua_settop(%struct.lua_State* %0, i32 0) #16
  %70 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %71 = call i32 @fputc(i32 10, %struct._IO_FILE* %70)
  %72 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %73 = call i32 @fflush(%struct._IO_FILE* %72) #16
  store i64 %4, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !39
  ret void
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @dostring(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i64 @strlen(i8* %1) #21
  %5 = tail call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %4, i8* %2, i8* null) #16
  %6 = tail call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %5) #16
  ret i32 %6
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @dochunk(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %2
  %5 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 0, i32 0) #16
  br label %6

; <label>:6:                                      ; preds = %4, %2
  %7 = phi i32 [ %5, %4 ], [ %1, %2 ]
  %8 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %7) #16
  ret i32 %8
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @docall(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !49
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !61
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = sub nsw i32 %15, %1
  %17 = inttoptr i64 %6 to %struct.TValue*
  %18 = inttoptr i64 %6 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @msghandler, i32 (%struct.lua_State*)** %18, align 8, !tbaa !21
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 38, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %4, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 1) #16
  store %struct.lua_State* %0, %struct.lua_State** @globalL, align 8, !tbaa !39
  %22 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* nonnull @laction) #17
  %23 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %1, i32 %2, i32 %16, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  %24 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* null) #17
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  ret i32 %23
}

; Function Attrs: minsize nounwind optsize uwtable
define internal i32 @msghandler(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %17

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0)) #16
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1) #16
  %9 = icmp eq i32 %8, 4
  br i1 %9, label %19, label %10

; <label>:10:                                     ; preds = %4, %7
  %11 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1) #16
  %12 = add nsw i32 %11, 1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %13
  %15 = load i8*, i8** %14, align 8, !tbaa !39
  %16 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.625, i64 0, i64 0), i8* %15) #16
  br label %17

; <label>:17:                                     ; preds = %10, %1
  %18 = phi i8* [ %16, %10 ], [ %2, %1 ]
  tail call void @luaL_traceback(%struct.lua_State* %0, %struct.lua_State* %0, i8* nonnull %18, i32 1) #16
  br label %19

; <label>:19:                                     ; preds = %7, %17
  ret i32 1
}

; Function Attrs: minsize nounwind optsize
declare void (i32)* @__sysv_signal(i32, void (i32)*) local_unnamed_addr #9

; Function Attrs: minsize nounwind optsize uwtable
define internal void @laction(i32) #0 {
  %2 = tail call void (i32)* @__sysv_signal(i32 %0, void (i32)* null) #17
  %3 = load %struct.lua_State*, %struct.lua_State** @globalL, align 8, !tbaa !39
  tail call void @lua_sethook(%struct.lua_State* %3, void (%struct.lua_State*, %struct.lua_Debug*)* nonnull @lstop, i32 11, i32 1) #16
  ret void
}

; Function Attrs: minsize noreturn nounwind optsize uwtable
define internal void @lstop(%struct.lua_State*, %struct.lua_Debug* nocapture readnone) #5 {
  tail call void @lua_sethook(%struct.lua_State* %0, void (%struct.lua_State*, %struct.lua_Debug*)* null, i32 0, i32 0) #16
  %3 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.626, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: minsize nounwind optsize uwtable
define internal fastcc i32 @pushline(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [512 x i8], align 16
  %4 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %4) #7
  %5 = icmp ne i32 %1, 0
  %6 = select i1 %5, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.632, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.633, i64 0, i64 0)
  %7 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* %6) #17
  %8 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %9 = icmp eq i8* %8, null
  %10 = select i1 %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.634, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.635, i64 0, i64 0)
  %11 = select i1 %9, i8* %10, i8* %8
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %13 = tail call i32 @fputs(i8* %11, %struct._IO_FILE* %12) #16
  %14 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !39
  %15 = tail call i32 @fflush(%struct._IO_FILE* %14) #16
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !39
  %17 = call i8* @fgets(i8* nonnull %4, i32 512, %struct._IO_FILE* %16) #16
  %18 = icmp eq i8* %17, null
  br i1 %18, label %38, label %19

; <label>:19:                                     ; preds = %2
  call void @lua_settop(%struct.lua_State* %0, i32 -2) #16
  %20 = call i64 @strlen(i8* nonnull %4) #21
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %28, label %22

; <label>:22:                                     ; preds = %19
  %23 = add i64 %20, -1
  %24 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 %23
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = icmp eq i8 %25, 10
  br i1 %26, label %27, label %28

; <label>:27:                                     ; preds = %22
  store i8 0, i8* %24, align 1, !tbaa !21
  br label %28

; <label>:28:                                     ; preds = %19, %27, %22
  %29 = phi i64 [ %23, %27 ], [ %20, %22 ], [ 0, %19 ]
  %30 = load i8, i8* %4, align 16
  %31 = icmp eq i8 %30, 61
  %32 = and i1 %5, %31
  br i1 %32, label %33, label %36

; <label>:33:                                     ; preds = %28
  %34 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 1
  %35 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.631, i64 0, i64 0), i8* nonnull %34) #16
  br label %38

; <label>:36:                                     ; preds = %28
  %37 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* nonnull %4, i64 %29) #16
  br label %38

; <label>:38:                                     ; preds = %33, %36, %2
  %39 = phi i32 [ 0, %2 ], [ 1, %36 ], [ 1, %33 ]
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %4) #7
  ret i32 %39
}

; Function Attrs: minsize nounwind optsize
declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #7

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

attributes #0 = { minsize nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { minsize norecurse nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { minsize norecurse nounwind optsize readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { minsize nounwind optsize readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { minsize noreturn nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { minsize norecurse nounwind optsize readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { minsize nounwind optsize readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { minsize nounwind optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { argmemonly minsize nounwind optsize readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { minsize optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #12 = { minsize nounwind optsize readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #13 = { minsize nounwind optsize returns_twice "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #14 = { nounwind readnone speculatable }
attributes #15 = { minsize noreturn nounwind optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #16 = { minsize optsize }
attributes #17 = { minsize nounwind optsize }
attributes #18 = { minsize noreturn optsize }
attributes #19 = { minsize noreturn nounwind optsize }
attributes #20 = { minsize nounwind optsize returns_twice }
attributes #21 = { minsize nounwind optsize readonly }
attributes #22 = { minsize nounwind optsize readnone }
attributes #23 = { cold minsize optsize }
attributes #24 = { cold }
attributes #25 = { cold minsize nounwind optsize }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"lua_State", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !7, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !8, i64 96, !4, i64 160, !9, i64 168, !10, i64 176, !10, i64 180, !10, i64 184, !10, i64 188, !10, i64 192}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"short", !5, i64 0}
!8 = !{!"CallInfo", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !5, i64 32, !5, i64 56, !7, i64 60, !7, i64 62}
!9 = !{!"long", !5, i64 0}
!10 = !{!"int", !5, i64 0}
!11 = !{!12, !9, i64 24}
!12 = !{!"global_State", !4, i64 0, !4, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !13, i64 48, !14, i64 64, !14, i64 80, !10, i64 96, !5, i64 100, !5, i64 101, !5, i64 102, !5, i64 103, !5, i64 104, !5, i64 105, !5, i64 106, !5, i64 107, !5, i64 108, !5, i64 109, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !5, i64 272, !5, i64 472, !5, i64 544, !4, i64 1392, !4, i64 1400}
!13 = !{!"stringtable", !4, i64 0, !10, i64 8, !10, i64 12}
!14 = !{!"TValue", !5, i64 0, !5, i64 8}
!15 = !{!12, !5, i64 100}
!16 = !{!3, !5, i64 9}
!17 = !{!3, !5, i64 8}
!18 = !{!12, !4, i64 112}
!19 = !{!3, !4, i64 0}
!20 = !{!3, !4, i64 16}
!21 = !{!5, !5, i64 0}
!22 = !{!14, !5, i64 8}
!23 = !{!3, !10, i64 192}
!24 = !{!3, !10, i64 184}
!25 = !{!3, !4, i64 160}
!26 = !{!3, !10, i64 188}
!27 = !{!12, !4, i64 256}
!28 = !{!12, !5, i64 105}
!29 = !{!12, !5, i64 102}
!30 = !{!12, !9, i64 40}
!31 = !{!12, !9, i64 16}
!32 = !{!12, !9, i64 32}
!33 = !{!12, !5, i64 104}
!34 = !{!12, !4, i64 192}
!35 = !{!12, !4, i64 208}
!36 = !{!12, !4, i64 128}
!37 = !{!12, !4, i64 232}
!38 = !{!12, !4, i64 200}
!39 = !{!4, !4, i64 0}
!40 = !{!12, !4, i64 216}
!41 = !{!12, !4, i64 224}
!42 = !{!12, !5, i64 108}
!43 = !{!12, !5, i64 109}
!44 = !{!12, !5, i64 101}
!45 = !{!12, !4, i64 0}
!46 = !{!12, !4, i64 8}
!47 = !{!"branch_weights", i32 1, i32 2000}
!48 = !{!3, !4, i64 56}
!49 = !{!3, !4, i64 32}
!50 = !{!3, !7, i64 12}
!51 = !{!3, !10, i64 180}
!52 = !{!3, !4, i64 80}
!53 = !{!3, !4, i64 88}
!54 = !{!3, !10, i64 176}
!55 = !{!3, !5, i64 11}
!56 = !{!3, !4, i64 64}
!57 = !{!3, !5, i64 10}
!58 = !{!3, !9, i64 168}
!59 = !{!3, !4, i64 48}
!60 = !{!8, !7, i64 62}
!61 = !{!8, !4, i64 0}
!62 = !{!8, !7, i64 60}
!63 = !{!8, !4, i64 8}
!64 = !{!65, !4, i64 16}
!65 = !{!"UpVal", !4, i64 0, !5, i64 8, !5, i64 9, !4, i64 16, !5, i64 24}
!66 = !{!65, !5, i64 9}
!67 = !{!68, !5, i64 9}
!68 = !{!"GCObject", !4, i64 0, !5, i64 8, !5, i64 9}
!69 = !{!65, !5, i64 8}
!70 = !{!"branch_weights", i32 2000, i32 1}
!71 = !{!12, !4, i64 264}
!72 = !{!73, !5, i64 8}
!73 = !{!"TString", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !5, i64 16}
!74 = !{!10, !10, i64 0}
!75 = !{!12, !10, i64 96}
!76 = !{!12, !5, i64 72}
!77 = !{!12, !4, i64 248}
!78 = !{!12, !5, i64 106}
!79 = !{!12, !5, i64 107}
!80 = !{!12, !5, i64 103}
!81 = !{!82, !10, i64 208}
!82 = !{!"lua_longjmp", !4, i64 0, !5, i64 8, !10, i64 208}
!83 = !{!82, !4, i64 0}
!84 = !{!13, !4, i64 0}
!85 = !{!13, !10, i64 12}
!86 = !{!73, !5, i64 10}
!87 = !{!12, !5, i64 88}
!88 = !{!12, !4, i64 184}
!89 = !{!12, !4, i64 48}
!90 = !{!12, !10, i64 60}
!91 = !{!3, !4, i64 40}
!92 = !{!8, !4, i64 16}
!93 = !{!94, !4, i64 128}
!94 = !{!"lua_Debug", !10, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !9, i64 40, !10, i64 48, !10, i64 52, !10, i64 56, !5, i64 60, !5, i64 61, !5, i64 62, !5, i64 63, !7, i64 64, !7, i64 66, !5, i64 68, !4, i64 128}
!95 = !{!96, !10, i64 36}
!96 = !{!"Proto", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !5, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120}
!97 = !{!96, !4, i64 104}
!98 = !{!99, !10, i64 8}
!99 = !{!"LocVar", !4, i64 0, !10, i64 8, !10, i64 12}
!100 = !{!99, !10, i64 12}
!101 = !{!99, !4, i64 0}
!102 = !{!96, !5, i64 11}
!103 = !{!8, !4, i64 24}
!104 = !{!94, !4, i64 32}
!105 = !{!94, !9, i64 40}
!106 = !{!94, !10, i64 52}
!107 = !{!94, !10, i64 56}
!108 = !{!96, !4, i64 112}
!109 = !{!73, !5, i64 11}
!110 = !{!96, !10, i64 44}
!111 = !{!96, !10, i64 48}
!112 = !{!94, !4, i64 24}
!113 = !{!94, !10, i64 48}
!114 = !{!94, !5, i64 60}
!115 = !{!94, !5, i64 62}
!116 = !{!94, !5, i64 61}
!117 = !{!96, !5, i64 10}
!118 = !{!94, !5, i64 63}
!119 = !{!96, !4, i64 64}
!120 = !{!94, !4, i64 16}
!121 = !{!94, !7, i64 66}
!122 = !{!94, !7, i64 64}
!123 = !{!96, !10, i64 28}
!124 = !{!96, !4, i64 88}
!125 = !{!126, !5, i64 10}
!126 = !{!"CClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!127 = !{!128, !128, i64 0}
!128 = !{!"double", !5, i64 0}
!129 = !{!130, !130, i64 0}
!130 = !{!"long long", !5, i64 0}
!131 = !{!132, !5, i64 10}
!132 = !{!"Table", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!133 = !{!134, !4, i64 0}
!134 = !{!"lconv", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !5, i64 80, !5, i64 81, !5, i64 82, !5, i64 83, !5, i64 84, !5, i64 85, !5, i64 86, !5, i64 87, !5, i64 88, !5, i64 89, !5, i64 90, !5, i64 91, !5, i64 92, !5, i64 93}
!135 = !{!9, !9, i64 0}
!136 = !{!132, !10, i64 12}
!137 = !{!132, !4, i64 16}
!138 = !{!132, !5, i64 9}
!139 = !{!132, !4, i64 32}
!140 = !{!73, !5, i64 9}
!141 = !{!13, !10, i64 8}
!142 = !{!143, !10, i64 12}
!143 = !{!"BuffFS", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!144 = !{!143, !10, i64 8}
!145 = !{!143, !4, i64 0}
!146 = !{!126, !4, i64 24}
!147 = !{!132, !4, i64 24}
!148 = !{!132, !5, i64 11}
!149 = !{!132, !4, i64 40}
!150 = !{!12, !4, i64 144}
!151 = !{!12, !4, i64 120}
!152 = !{!68, !4, i64 0}
!153 = !{!96, !5, i64 12}
!154 = !{!155, !4, i64 0}
!155 = !{!"CallS", !4, i64 0, !10, i64 8}
!156 = !{!155, !10, i64 8}
!157 = !{!158, !4, i64 32}
!158 = !{!"Zio", !9, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32}
!159 = !{!158, !4, i64 16}
!160 = !{!158, !4, i64 24}
!161 = !{!162, !4, i64 0}
!162 = !{!"SParser", !4, i64 0, !163, i64 8, !164, i64 32, !4, i64 80, !4, i64 88}
!163 = !{!"Mbuffer", !4, i64 0, !9, i64 8, !9, i64 16}
!164 = !{!"Dyndata", !165, i64 0, !166, i64 16, !166, i64 32}
!165 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12}
!166 = !{!"Labellist", !4, i64 0, !10, i64 8, !10, i64 12}
!167 = !{!162, !4, i64 88}
!168 = !{!162, !4, i64 80}
!169 = !{!162, !10, i64 44}
!170 = !{!162, !4, i64 48}
!171 = !{!162, !10, i64 60}
!172 = !{!162, !4, i64 64}
!173 = !{!162, !10, i64 76}
!174 = !{!162, !4, i64 8}
!175 = !{!162, !9, i64 24}
!176 = !{!162, !4, i64 32}
!177 = !{!178, !5, i64 10}
!178 = !{!"LClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!179 = !{!180, !4, i64 0}
!180 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16, !10, i64 24, !10, i64 28}
!181 = !{!180, !4, i64 8}
!182 = !{!180, !4, i64 16}
!183 = !{!180, !10, i64 24}
!184 = !{!180, !10, i64 28}
!185 = !{!96, !10, i64 16}
!186 = !{!12, !4, i64 1400}
!187 = !{!12, !4, i64 1392}
!188 = !{!189, !9, i64 16}
!189 = !{!"Udata", !4, i64 0, !5, i64 8, !5, i64 9, !7, i64 10, !9, i64 16, !4, i64 24, !4, i64 32, !5, i64 40}
!190 = !{!189, !7, i64 10}
!191 = !{!189, !4, i64 24}
!192 = !{!178, !4, i64 24}
!193 = !{!96, !4, i64 80}
!194 = !{!195, !4, i64 0}
!195 = !{!"Upvaldesc", !4, i64 0, !5, i64 8, !5, i64 9}
!196 = !{!178, !5, i64 9}
!197 = !{!94, !4, i64 8}
!198 = !{!199, !9, i64 8}
!199 = !{!"luaL_Buffer", !4, i64 0, !9, i64 8, !9, i64 16, !4, i64 24, !5, i64 32}
!200 = !{!199, !9, i64 16}
!201 = !{!199, !4, i64 0}
!202 = !{!199, !4, i64 24}
!203 = !{!204, !4, i64 8}
!204 = !{!"LoadF", !10, i64 0, !4, i64 8, !5, i64 16}
!205 = !{!204, !10, i64 0}
!206 = !{!207, !4, i64 0}
!207 = !{!"LoadS", !4, i64 0, !9, i64 8}
!208 = !{!207, !9, i64 8}
!209 = !{!210, !4, i64 0}
!210 = !{!"luaL_Reg", !4, i64 0, !4, i64 8}
!211 = !{!210, !4, i64 8}
!212 = !{!213, !4, i64 0}
!213 = !{!"luaL_Stream", !4, i64 0, !4, i64 8}
!214 = !{!213, !4, i64 8}
!215 = !{!73, !10, i64 12}
!216 = !{!12, !4, i64 176}
!217 = !{!68, !5, i64 8}
!218 = !{!96, !10, i64 24}
!219 = !{!96, !4, i64 72}
!220 = !{!96, !10, i64 32}
!221 = !{!96, !4, i64 56}
!222 = !{!96, !10, i64 20}
!223 = !{!96, !4, i64 96}
!224 = !{!96, !10, i64 40}
!225 = !{!12, !4, i64 136}
!226 = !{!12, !4, i64 152}
!227 = !{!12, !4, i64 168}
!228 = !{!12, !4, i64 160}
!229 = !{!132, !4, i64 48}
!230 = !{!189, !4, i64 32}
!231 = !{!189, !5, i64 9}
!232 = !{!96, !5, i64 9}
!233 = !{!3, !4, i64 72}
!234 = !{!12, !4, i64 240}
!235 = !{!12, !10, i64 56}
!236 = !{!237, !10, i64 0}
!237 = !{!"AbsLineInfo", !10, i64 0, !10, i64 4}
!238 = !{!195, !5, i64 8}
!239 = !{!195, !5, i64 9}
!240 = !{!94, !10, i64 0}
!241 = !{i64 0, i64 8, !39, i64 0, i64 8, !39, i64 0, i64 4, !74, i64 0, i64 8, !39, i64 0, i64 8, !129, i64 0, i64 8, !127, i64 8, i64 1, !21, i64 9, i64 1, !21, i64 12, i64 4, !74, i64 16, i64 8, !39, i64 16, i64 8, !39, i64 16, i64 4, !74, i64 16, i64 8, !39, i64 16, i64 8, !129, i64 16, i64 8, !127, i64 0, i64 8, !39, i64 0, i64 8, !39, i64 0, i64 4, !74, i64 0, i64 8, !39, i64 0, i64 8, !129, i64 0, i64 8, !127, i64 8, i64 1, !21}
!242 = !{!158, !9, i64 0}
!243 = !{!158, !4, i64 8}
!244 = !{!245, !4, i64 16}
!245 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16}
!246 = !{!245, !4, i64 0}
!247 = !{!245, !4, i64 8}
!248 = !{!249, !4, i64 80}
!249 = !{!"LexState", !10, i64 0, !10, i64 4, !10, i64 8, !250, i64 16, !250, i64 32, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104}
!250 = !{!"Token", !10, i64 0, !5, i64 8}
!251 = !{!252, !4, i64 0}
!252 = !{!"FuncState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !10, i64 52, !10, i64 56, !10, i64 60, !7, i64 64, !5, i64 66, !5, i64 67, !5, i64 68, !5, i64 69, !5, i64 70}
!253 = !{!249, !4, i64 72}
!254 = !{!249, !4, i64 88}
!255 = !{!164, !10, i64 40}
!256 = !{!164, !10, i64 24}
!257 = !{!164, !10, i64 8}
!258 = !{!249, !10, i64 16}
!259 = !{!249, !4, i64 56}
!260 = !{!249, !10, i64 0}
!261 = !{!249, !10, i64 32}
!262 = !{!249, !4, i64 64}
!263 = !{!249, !4, i64 48}
!264 = !{!249, !10, i64 4}
!265 = !{!249, !10, i64 8}
!266 = !{!249, !4, i64 96}
!267 = !{!249, !4, i64 104}
!268 = !{!163, !4, i64 0}
!269 = !{!163, !9, i64 16}
!270 = !{!271, !10, i64 16}
!271 = !{!"expdesc", !5, i64 0, !5, i64 8, !10, i64 16, !10, i64 20}
!272 = !{!271, !10, i64 20}
!273 = !{!271, !5, i64 0}
!274 = !{!237, !10, i64 4}
!275 = !{!252, !4, i64 8}
!276 = !{!252, !4, i64 16}
!277 = !{!252, !10, i64 32}
!278 = !{!252, !10, i64 40}
!279 = !{!252, !10, i64 36}
!280 = !{!252, !10, i64 44}
!281 = !{!252, !10, i64 52}
!282 = !{!252, !10, i64 48}
!283 = !{!252, !10, i64 56}
!284 = !{!252, !10, i64 60}
!285 = !{!252, !4, i64 24}
!286 = !{!252, !5, i64 67}
!287 = !{i64 0, i64 4, !74, i64 8, i64 8, !127, i64 8, i64 8, !129, i64 8, i64 8, !39}
!288 = !{!252, !5, i64 66}
!289 = !{!252, !5, i64 70}
!290 = !{!252, !7, i64 64}
!291 = !{!292, !5, i64 18}
!292 = !{!"BlockCnt", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19}
!293 = !{!292, !5, i64 16}
!294 = !{!292, !10, i64 8}
!295 = !{!292, !10, i64 12}
!296 = !{!292, !5, i64 17}
!297 = !{!292, !5, i64 19}
!298 = !{!292, !4, i64 0}
!299 = !{!252, !5, i64 69}
!300 = !{!163, !9, i64 8}
!301 = !{!252, !5, i64 68}
!302 = !{!303, !10, i64 12}
!303 = !{!"Labeldesc", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17}
!304 = !{!303, !5, i64 16}
!305 = !{!303, !10, i64 8}
!306 = !{!307, !4, i64 0}
!307 = !{!"LHS_assign", !4, i64 0, !271, i64 8}
!308 = !{!307, !5, i64 8}
!309 = !{!166, !10, i64 8}
!310 = !{!166, !4, i64 0}
!311 = !{!303, !5, i64 17}
!312 = !{!164, !4, i64 16}
!313 = !{!314, !5, i64 0}
!314 = !{!"", !5, i64 0, !5, i64 1}
!315 = !{!314, !5, i64 1}
!316 = !{i64 0, i64 4, !21, i64 8, i64 8, !129, i64 8, i64 8, !127, i64 8, i64 4, !74, i64 8, i64 2, !317, i64 10, i64 1, !21, i64 16, i64 4, !74, i64 20, i64 4, !74}
!317 = !{!7, !7, i64 0}
!318 = !{!319, !10, i64 40}
!319 = !{!"ConsControl", !271, i64 0, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40}
!320 = !{!319, !10, i64 32}
!321 = !{!319, !10, i64 36}
!322 = !{!319, !4, i64 24}
!323 = !{!319, !5, i64 0}
!324 = !{!164, !4, i64 0}
!325 = !{!326, !7, i64 0}
!326 = !{!"Vardesc", !7, i64 0}
!327 = !{!164, !4, i64 32}
!328 = !{!303, !4, i64 0}
!329 = !{i64 0, i64 8, !39, i64 8, i64 4, !74, i64 12, i64 4, !74, i64 16, i64 1, !21, i64 17, i64 1, !21}
!330 = !{!331, !4, i64 0}
!331 = !{!"UBox", !4, i64 0, !9, i64 8}
!332 = !{!331, !9, i64 8}
!333 = !{!334, !4, i64 0}
!334 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!335 = !{!334, !10, i64 12}
!336 = !{!334, !10, i64 8}
!337 = !{!338, !10, i64 0}
!338 = !{!"tm", !10, i64 0, !10, i64 4, !10, i64 8, !10, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !9, i64 40, !4, i64 48}
!339 = !{!338, !10, i64 4}
!340 = !{!338, !10, i64 8}
!341 = !{!338, !10, i64 12}
!342 = !{!338, !10, i64 16}
!343 = !{!338, !10, i64 20}
!344 = !{!338, !10, i64 32}
!345 = !{!338, !10, i64 24}
!346 = !{!338, !10, i64 28}
!347 = !{!348, !4, i64 24}
!348 = !{!"MatchState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !5, i64 36, !5, i64 40}
!349 = !{!348, !10, i64 32}
!350 = !{!348, !4, i64 0}
!351 = !{!348, !4, i64 8}
!352 = !{!348, !4, i64 16}
!353 = !{!354, !4, i64 0}
!354 = !{!"GMatchState", !4, i64 0, !4, i64 8, !4, i64 16, !348, i64 24}
!355 = !{!354, !4, i64 8}
!356 = !{!354, !4, i64 16}
!357 = !{!348, !5, i64 36}
!358 = !{!359, !4, i64 0}
!359 = !{!"Header", !4, i64 0, !10, i64 8, !10, i64 12}
!360 = !{!359, !10, i64 8}
!361 = !{!359, !10, i64 12}
!362 = !{!363, !9, i64 8}
!363 = !{!"", !4, i64 0, !9, i64 8}
!364 = !{!363, !4, i64 0}
!365 = !{!354, !4, i64 48}
!366 = !{!354, !4, i64 32}
