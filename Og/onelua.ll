; ModuleID = 'onelua.c'
source_filename = "onelua.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.luaL_Reg = type { i8*, i32 (%struct.lua_State*)* }
%struct.lua_State = type { %struct.GCObject*, i8, i8, i8, i8, i16, %union.StackValue*, %struct.global_State*, %struct.CallInfo*, i32*, %union.StackValue*, %union.StackValue*, %struct.UpVal*, %struct.GCObject*, %struct.lua_State*, %struct.lua_longjmp*, %struct.CallInfo, void (%struct.lua_State*, %struct.lua_Debug*)*, i64, i32, i32, i32, i32, i32 }
%struct.global_State = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable, %struct.TValue, %struct.TValue, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %struct.GCObject*, %struct.GCObject**, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.lua_State*, i32 (%struct.lua_State*)*, %struct.lua_State*, %struct.TString*, [25 x %struct.TString*], [9 x %struct.Table*], [53 x [2 x %struct.TString*]], void (i8*, i8*, i32)*, i8* }
%struct.stringtable = type { %struct.TString**, i32, i32 }
%struct.TValue = type { %union.Value, i8 }
%union.Value = type { %struct.GCObject* }
%struct.TString = type { %struct.GCObject*, i8, i8, i8, i8, i32, %union.anon }
%union.anon = type { i64 }
%struct.Table = type { %struct.GCObject*, i8, i8, i8, i8, i32, %struct.TValue*, %union.Node*, %union.Node*, %struct.Table*, %struct.GCObject* }
%union.Node = type { %struct.NodeKey }
%struct.NodeKey = type { %union.Value, i8, i8, i32, %union.Value }
%union.StackValue = type { %struct.TValue }
%struct.UpVal = type { %struct.GCObject*, i8, i8, %struct.TValue*, %union.anon.4 }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %struct.UpVal*, %struct.UpVal** }
%struct.GCObject = type { %struct.GCObject*, i8, i8 }
%struct.lua_longjmp = type { %struct.lua_longjmp*, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.CallInfo = type { %union.StackValue*, %union.StackValue*, %struct.CallInfo*, %struct.CallInfo*, %union.anon.0, %union.anon.2, i16, i16 }
%union.anon.0 = type { %struct.anon.1 }
%struct.anon.1 = type { i32 (%struct.lua_State*, i32, i64)*, i64, i64 }
%union.anon.2 = type { i32 }
%struct.lua_Debug = type { i32, i8*, i8*, i8*, i8*, i64, i32, i32, i32, i8, i8, i8, i8, i16, i16, [60 x i8], %struct.CallInfo* }
%struct.anon.10 = type { i8, i8 }
%struct.expdesc = type { i32, %union.anon.8, i32, i32 }
%union.anon.8 = type { i64 }
%struct.LClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, %struct.Proto*, [1 x %struct.UpVal*] }
%struct.Proto = type { %struct.GCObject*, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.TValue*, i32*, %struct.Proto**, %struct.Upvaldesc*, i8*, %struct.AbsLineInfo*, %struct.LocVar*, %struct.TString*, %struct.GCObject* }
%struct.Upvaldesc = type { %struct.TString*, i8, i8 }
%struct.AbsLineInfo = type { i32, i32 }
%struct.LocVar = type { %struct.TString*, i32, i32 }
%union.Closure = type { %struct.CClosure }
%struct.CClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, i32 (%struct.lua_State*)*, [1 x %struct.TValue] }
%struct.anon.3 = type { i16, i16 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.Udata = type { %struct.GCObject*, i8, i8, i16, i64, %struct.Table*, %struct.GCObject*, [1 x %union.UValue] }
%union.UValue = type { %struct.TValue }
%struct.BuffFS = type { %struct.lua_State*, i32, i32, [400 x i8] }
%union.GCUnion = type { %struct.lua_State }
%struct.CallS = type { %union.StackValue*, i32 }
%struct.Zio = type { i64, i8*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, %struct.lua_State* }
%struct.SParser = type { %struct.Zio*, %struct.Mbuffer, %struct.Dyndata, i8*, i8* }
%struct.Mbuffer = type { i8*, i64, i64 }
%struct.Dyndata = type { %struct.anon.7, %struct.Labellist, %struct.Labellist }
%struct.anon.7 = type { %struct.Vardesc*, i32, i32 }
%struct.Vardesc = type { i16 }
%struct.Labellist = type { %struct.Labeldesc*, i32, i32 }
%struct.Labeldesc = type { %struct.TString*, i32, i32, i8, i8 }
%struct.DumpState = type { %struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32, i32 }
%struct.luaL_Buffer = type { i8*, i64, i64, %struct.lua_State*, %union.anon.6 }
%union.anon.6 = type { double, [1016 x i8] }
%struct.LoadF = type { i32, %struct._IO_FILE*, [8192 x i8] }
%struct.LoadS = type { i8*, i64 }
%struct.luaL_Stream = type { %struct._IO_FILE*, i32 (%struct.lua_State*)* }
%struct.RanState = type { [4 x i64] }
%struct.anon = type { i32*, i32, i32 }
%struct.lconv = type { i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.LoadState = type { %struct.lua_State*, %struct.Zio*, i8* }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState*, %struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Table*, %struct.Dyndata*, %struct.TString*, %struct.TString* }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.FuncState = type { %struct.Proto*, %struct.FuncState*, %struct.LexState*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8, i8, i8 }
%struct.BlockCnt = type { %struct.BlockCnt*, i32, i32, i8, i8, i8, i8 }
%struct.LHS_assign = type { %struct.LHS_assign*, %struct.expdesc }
%struct.anon.9 = type { i16, i8 }
%struct.ConsControl = type { %struct.expdesc, %struct.expdesc*, i32, i32, i32 }
%struct.RN = type { %struct._IO_FILE*, i32, i32, [201 x i8] }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.MatchState = type { i8*, i8*, i8*, %struct.lua_State*, i32, i8, [32 x %struct.anon.11] }
%struct.anon.11 = type { i8*, i64 }
%struct.Header = type { %struct.lua_State*, i32, i32 }
%union.Ftypes = type { double, [32 x i8] }

@.str = private unnamed_addr constant [38 x i8] c"cannot resume non-suspended coroutine\00", align 1
@.str.1 = private unnamed_addr constant [29 x i8] c"cannot resume dead coroutine\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str.3 = private unnamed_addr constant [42 x i8] c"attempt to yield across a C-call boundary\00", align 1
@.str.4 = private unnamed_addr constant [42 x i8] c"attempt to yield from outside a coroutine\00", align 1
@lua_ident = local_unnamed_addr constant [129 x i8] c"$LuaVersion: Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio $$LuaAuthors: R. Ierusalimschy, L. H. de Figueiredo, W. Celes $\00", align 16
@luaT_typenames_ = internal unnamed_addr constant [12 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.182, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.183, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.187, i32 0, i32 0)], align 16
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.8 = private unnamed_addr constant [17 x i8] c"stack traceback:\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"\0A\09...\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"Slnt\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"\0A\09%s:\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c" in \00", align 1
@.str.14 = private unnamed_addr constant [21 x i8] c"\0A\09(...tail calls...)\00", align 1
@.str.15 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str.16 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.18 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str.19 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"__name\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"light userdata\00", align 1
@.str.22 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str.23 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str.25 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str.26 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"invalid option '%s'\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str.29 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str.31 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@stdin = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.32 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str.33 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.39 = private unnamed_addr constant [32 x i8] c"object length is not an integer\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str.41 = private unnamed_addr constant [34 x i8] c"'__tostring' must return a string\00", align 1
@.str.42 = private unnamed_addr constant [3 x i8] c"%I\00", align 1
@.str.43 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.44 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.45 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.46 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"%s: %p\00", align 1
@.str.48 = private unnamed_addr constant [18 x i8] c"too many upvalues\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.50 = private unnamed_addr constant [49 x i8] c"core and library have incompatible numeric types\00", align 1
@.str.51 = private unnamed_addr constant [54 x i8] c"version mismatch: app. needs %f, Lua core provides %f\00", align 1
@base_funcs = internal constant [26 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.301, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_assert }, %struct.luaL_Reg { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.302, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_collectgarbage }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.303, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_dofile }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.304, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_error }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.306, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_ipairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.307, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_loadfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.308, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_load }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.309, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_next }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.310, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.311, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_print }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.313, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_warn }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.314, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawequal }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.315, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawlen }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.316, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawget }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.317, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawset }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.318, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_select }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.320, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tonumber }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.321, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tostring }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.323, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_xpcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.52 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"Lua 5.4\00", align 1
@.str.54 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@co_funcs = internal constant [9 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.347, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cocreate }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.348, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_coresume }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_corunning }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.350, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_costatus }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.351, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cowrap }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.352, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yield }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.353, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yieldable }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.354, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_kill }, %struct.luaL_Reg zeroinitializer], align 16
@dblib = internal constant [17 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @db_debug }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.362, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.363, i32 0, i32 0), i32 (%struct.lua_State*)* @db_gethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.364, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getinfo }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.365, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.366, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getregistry }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.367, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.368, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvaluejoin }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.369, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvalueid }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.370, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.371, i32 0, i32 0), i32 (%struct.lua_State*)* @db_sethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.372, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.373, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.374, i32 0, i32 0), i32 (%struct.lua_State*)* @db_traceback }, %struct.luaL_Reg zeroinitializer], align 16
@iolib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @io_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @io_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.406, i32 0, i32 0), i32 (%struct.lua_State*)* @io_input }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @io_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i32 0, i32 0), i32 (%struct.lua_State*)* @io_open }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.407, i32 0, i32 0), i32 (%struct.lua_State*)* @io_output }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.408, i32 0, i32 0), i32 (%struct.lua_State*)* @io_popen }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @io_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.409, i32 0, i32 0), i32 (%struct.lua_State*)* @io_tmpfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @io_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @io_write }, %struct.luaL_Reg zeroinitializer], align 16
@.str.55 = private unnamed_addr constant [10 x i8] c"_IO_input\00", align 1
@.str.56 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@stdout = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.57 = private unnamed_addr constant [11 x i8] c"_IO_output\00", align 1
@.str.58 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@stderr = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.59 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@mathlib = internal constant [28 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.438, i32 0, i32 0), i32 (%struct.lua_State*)* @math_abs }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.439, i32 0, i32 0), i32 (%struct.lua_State*)* @math_acos }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.440, i32 0, i32 0), i32 (%struct.lua_State*)* @math_asin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.441, i32 0, i32 0), i32 (%struct.lua_State*)* @math_atan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.442, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ceil }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.443, i32 0, i32 0), i32 (%struct.lua_State*)* @math_cos }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.444, i32 0, i32 0), i32 (%struct.lua_State*)* @math_deg }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.445, i32 0, i32 0), i32 (%struct.lua_State*)* @math_exp }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.446, i32 0, i32 0), i32 (%struct.lua_State*)* @math_toint }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.447, i32 0, i32 0), i32 (%struct.lua_State*)* @math_floor }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.448, i32 0, i32 0), i32 (%struct.lua_State*)* @math_fmod }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.449, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ult }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.450, i32 0, i32 0), i32 (%struct.lua_State*)* @math_log }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.451, i32 0, i32 0), i32 (%struct.lua_State*)* @math_max }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i32 0, i32 0), i32 (%struct.lua_State*)* @math_min }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.453, i32 0, i32 0), i32 (%struct.lua_State*)* @math_modf }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.454, i32 0, i32 0), i32 (%struct.lua_State*)* @math_rad }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.455, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.456, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sqrt }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.457, i32 0, i32 0), i32 (%struct.lua_State*)* @math_tan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @math_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.60 = private unnamed_addr constant [3 x i8] c"pi\00", align 1
@.str.61 = private unnamed_addr constant [5 x i8] c"huge\00", align 1
@.str.62 = private unnamed_addr constant [11 x i8] c"maxinteger\00", align 1
@.str.63 = private unnamed_addr constant [11 x i8] c"mininteger\00", align 1
@pk_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.465, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_loadlib }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.466, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_searchpath }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.64 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.65 = private unnamed_addr constant [9 x i8] c"LUA_PATH\00", align 1
@.str.66 = private unnamed_addr constant [151 x i8] c"/usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"cpath\00", align 1
@.str.68 = private unnamed_addr constant [10 x i8] c"LUA_CPATH\00", align 1
@.str.69 = private unnamed_addr constant [69 x i8] c"/usr/local/lib/lua/5.4/?.so;/usr/local/lib/lua/5.4/loadall.so;./?.so\00", align 1
@.str.70 = private unnamed_addr constant [11 x i8] c"/\0A;\0A?\0A!\0A-\0A\00", align 1
@.str.71 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str.72 = private unnamed_addr constant [7 x i8] c"loaded\00", align 1
@.str.73 = private unnamed_addr constant [9 x i8] c"_PRELOAD\00", align 1
@.str.74 = private unnamed_addr constant [8 x i8] c"preload\00", align 1
@ll_funcs = internal constant [2 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_require }, %struct.luaL_Reg zeroinitializer], align 16
@syslib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.491, i32 0, i32 0), i32 (%struct.lua_State*)* @os_clock }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.492, i32 0, i32 0), i32 (%struct.lua_State*)* @os_date }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.493, i32 0, i32 0), i32 (%struct.lua_State*)* @os_difftime }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.494, i32 0, i32 0), i32 (%struct.lua_State*)* @os_execute }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i32 0, i32 0), i32 (%struct.lua_State*)* @os_exit }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.495, i32 0, i32 0), i32 (%struct.lua_State*)* @os_getenv }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @os_remove }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.497, i32 0, i32 0), i32 (%struct.lua_State*)* @os_rename }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.498, i32 0, i32 0), i32 (%struct.lua_State*)* @os_setlocale }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i32 (%struct.lua_State*)* @os_time }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.500, i32 0, i32 0), i32 (%struct.lua_State*)* @os_tmpname }, %struct.luaL_Reg zeroinitializer], align 16
@strlib = internal constant [18 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.524, i32 0, i32 0), i32 (%struct.lua_State*)* @str_byte }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @str_char }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.526, i32 0, i32 0), i32 (%struct.lua_State*)* @str_dump }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.527, i32 0, i32 0), i32 (%struct.lua_State*)* @str_find }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.528, i32 0, i32 0), i32 (%struct.lua_State*)* @str_format }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.529, i32 0, i32 0), i32 (%struct.lua_State*)* @gmatch }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.530, i32 0, i32 0), i32 (%struct.lua_State*)* @str_gsub }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @str_len }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.532, i32 0, i32 0), i32 (%struct.lua_State*)* @str_lower }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.533, i32 0, i32 0), i32 (%struct.lua_State*)* @str_match }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.534, i32 0, i32 0), i32 (%struct.lua_State*)* @str_rep }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.535, i32 0, i32 0), i32 (%struct.lua_State*)* @str_reverse }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.536, i32 0, i32 0), i32 (%struct.lua_State*)* @str_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.537, i32 0, i32 0), i32 (%struct.lua_State*)* @str_upper }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @str_pack }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.539, i32 0, i32 0), i32 (%struct.lua_State*)* @str_packsize }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @str_unpack }, %struct.luaL_Reg zeroinitializer], align 16
@tab_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.589, i32 0, i32 0), i32 (%struct.lua_State*)* @tconcat }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.590, i32 0, i32 0), i32 (%struct.lua_State*)* @tinsert }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @tpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @tunpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @tremove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.591, i32 0, i32 0), i32 (%struct.lua_State*)* @tmove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.592, i32 0, i32 0), i32 (%struct.lua_State*)* @sort }, %struct.luaL_Reg zeroinitializer], align 16
@funcs = internal constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.601, i32 0, i32 0), i32 (%struct.lua_State*)* @byteoffset }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.602, i32 0, i32 0), i32 (%struct.lua_State*)* @codepoint }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @utfchar }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @utflen }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.603, i32 0, i32 0), i32 (%struct.lua_State*)* @iter_codes }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.75 = private unnamed_addr constant [15 x i8] c"[\00-\7F\C2-\FD][\80-\BF]*\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"charpattern\00", align 1
@loadedlibs = internal unnamed_addr constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_base }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.610, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_package }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.611, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_coroutine }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_table }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.612, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_io }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.613, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_os }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_string }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.614, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_math }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.615, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_utf8 }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_debug }, %struct.luaL_Reg zeroinitializer], align 16
@.str.77 = private unnamed_addr constant [39 x i8] c"cannot create state: not enough memory\00", align 1
@.str.78 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@luaT_init.luaT_eventname = internal unnamed_addr constant [25 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.92, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.94, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.95, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.96, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0)], align 16
@.str.79 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.80 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str.81 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.83 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str.85 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str.86 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str.87 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str.88 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str.89 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str.90 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"__idiv\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"__band\00", align 1
@.str.93 = private unnamed_addr constant [6 x i8] c"__bor\00", align 1
@.str.94 = private unnamed_addr constant [7 x i8] c"__bxor\00", align 1
@.str.95 = private unnamed_addr constant [6 x i8] c"__shl\00", align 1
@.str.96 = private unnamed_addr constant [6 x i8] c"__shr\00", align 1
@.str.97 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str.98 = private unnamed_addr constant [7 x i8] c"__bnot\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str.101 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str.102 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@.str.103 = private unnamed_addr constant [8 x i8] c"__close\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"_ENV\00", align 1
@luaX_tokens = internal unnamed_addr constant [37 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.105, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.107, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.113, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.115, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.117, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.118, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.119, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.121, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.122, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.125, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.127, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.129, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.130, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.131, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.132, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.133, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.135, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.136, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.138, i32 0, i32 0)], align 16
@.str.105 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.108 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.109 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str.110 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.111 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.112 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"goto\00", align 1
@.str.114 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.115 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.116 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.117 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.118 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.119 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str.120 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.121 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str.122 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.123 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.124 = private unnamed_addr constant [3 x i8] c"//\00", align 1
@.str.125 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.127 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str.128 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.129 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.130 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str.131 = private unnamed_addr constant [3 x i8] c"<<\00", align 1
@.str.132 = private unnamed_addr constant [3 x i8] c">>\00", align 1
@.str.133 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str.134 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str.135 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str.136 = private unnamed_addr constant [10 x i8] c"<integer>\00", align 1
@.str.137 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str.138 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@.str.139 = private unnamed_addr constant [29 x i8] c"error object is not a string\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"error in __gc metamethod (\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c")\00", align 1
@absentkey = internal constant %struct.TValue { %union.Value zeroinitializer, i8 32 }, align 8
@sweepgen.nextage = internal unnamed_addr constant [7 x i8] c"\01\03\03\04\04\05\06", align 1
@.str.142 = private unnamed_addr constant [12 x i8] c"(temporary)\00", align 1
@.str.143 = private unnamed_addr constant [14 x i8] c"(C temporary)\00", align 1
@.str.144 = private unnamed_addr constant [9 x i8] c"(vararg)\00", align 1
@.str.145 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str.146 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.147 = private unnamed_addr constant [3 x i8] c"=?\00", align 1
@.str.148 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str.150 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str.151 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@.str.152 = private unnamed_addr constant [11 x i8] c"metamethod\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"hook\00", align 1
@.str.154 = private unnamed_addr constant [13 x i8] c"for iterator\00", align 1
@.str.155 = private unnamed_addr constant [6 x i8] c"order\00", align 1
@.str.156 = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str.157 = private unnamed_addr constant [14 x i8] c"integer index\00", align 1
@.str.158 = private unnamed_addr constant [6 x i8] c"field\00", align 1
@.str.159 = private unnamed_addr constant [8 x i8] c"upvalue\00", align 1
@.str.160 = private unnamed_addr constant [9 x i8] c"constant\00", align 1
@luaP_opmodes = internal unnamed_addr constant [84 x i8] c"\08\0A\0A\09\09\08\08\08\00\08\08\08\08\00\00\00\00\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\00\00\04\10\10\10\10\10\10\10\10\10\10\18hh \00\00\09\09\01\00\09 \09H\08\03", align 16
@.str.161 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str.162 = private unnamed_addr constant [44 x i8] c"attempt to close non-closable variable '%s'\00", align 1
@.str.163 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@luaV_execute.disptab = internal unnamed_addr constant [84 x i8*] [i8* blockaddress(@luaV_execute, %455), i8* blockaddress(@luaV_execute, %505), i8* blockaddress(@luaV_execute, %521), i8* blockaddress(@luaV_execute, %485), i8* blockaddress(@luaV_execute, %537), i8* blockaddress(@luaV_execute, %559), i8* blockaddress(@luaV_execute, %577), i8* blockaddress(@luaV_execute, %598), i8* blockaddress(@luaV_execute, %622), i8* blockaddress(@luaV_execute, %664), i8* blockaddress(@luaV_execute, %710), i8* blockaddress(@luaV_execute, %783), i8* blockaddress(@luaV_execute, %838), i8* blockaddress(@luaV_execute, %881), i8* blockaddress(@luaV_execute, %953), i8* blockaddress(@luaV_execute, %1049), i8* blockaddress(@luaV_execute, %1127), i8* blockaddress(@luaV_execute, %1193), i8* blockaddress(@luaV_execute, %1226), i8* blockaddress(@luaV_execute, %1279), i8* blockaddress(@luaV_execute, %1320), i8* blockaddress(@luaV_execute, %1359), i8* blockaddress(@luaV_execute, %1400), i8* blockaddress(@luaV_execute, %1439), i8* blockaddress(@luaV_execute, %1477), i8* blockaddress(@luaV_execute, %1515), i8* blockaddress(@luaV_execute, %1555), i8* blockaddress(@luaV_execute, %1615), i8* blockaddress(@luaV_execute, %1673), i8* blockaddress(@luaV_execute, %1733), i8* blockaddress(@luaV_execute, %1791), i8* blockaddress(@luaV_execute, %1839), i8* blockaddress(@luaV_execute, %1887), i8* blockaddress(@luaV_execute, %2333), i8* blockaddress(@luaV_execute, %2373), i8* blockaddress(@luaV_execute, %2413), i8* blockaddress(@luaV_execute, %2597), i8* blockaddress(@luaV_execute, %2643), i8* blockaddress(@luaV_execute, %1946), i8* blockaddress(@luaV_execute, %2004), i8* blockaddress(@luaV_execute, %2062), i8* blockaddress(@luaV_execute, %2120), i8* blockaddress(@luaV_execute, %2178), i8* blockaddress(@luaV_execute, %2226), i8* blockaddress(@luaV_execute, %2274), i8* blockaddress(@luaV_execute, %2453), i8* blockaddress(@luaV_execute, %2501), i8* blockaddress(@luaV_execute, %2549), i8* blockaddress(@luaV_execute, %2730), i8* blockaddress(@luaV_execute, %2681), i8* blockaddress(@luaV_execute, %2778), i8* blockaddress(@luaV_execute, %2812), i8* blockaddress(@luaV_execute, %2846), i8* blockaddress(@luaV_execute, %2876), i8* blockaddress(@luaV_execute, %2893), i8* blockaddress(@luaV_execute, %2915), i8* blockaddress(@luaV_execute, %2929), i8* blockaddress(@luaV_execute, %2940), i8* blockaddress(@luaV_execute, %2956), i8* blockaddress(@luaV_execute, %2986), i8* blockaddress(@luaV_execute, %3048), i8* blockaddress(@luaV_execute, %3110), i8* blockaddress(@luaV_execute, %3142), i8* blockaddress(@luaV_execute, %3188), i8* blockaddress(@luaV_execute, %3240), i8* blockaddress(@luaV_execute, %3292), i8* blockaddress(@luaV_execute, %3344), i8* blockaddress(@luaV_execute, %3396), i8* blockaddress(@luaV_execute, %3438), i8* blockaddress(@luaV_execute, %3489), i8* blockaddress(@luaV_execute, %3510), i8* blockaddress(@luaV_execute, %3579), i8* blockaddress(@luaV_execute, %3616), i8* blockaddress(@luaV_execute, %3643), i8* blockaddress(@luaV_execute, %3681), i8* blockaddress(@luaV_execute, %3740), i8* blockaddress(@luaV_execute, %3860), i8* blockaddress(@luaV_execute, %3873), i8* blockaddress(@luaV_execute, %3896), i8* blockaddress(@luaV_execute, %3928), i8* blockaddress(@luaV_execute, %4011), i8* blockaddress(@luaV_execute, %4038), i8* blockaddress(@luaV_execute, %4053), i8* blockaddress(@luaV_execute, %4068)], align 16
@.str.164 = private unnamed_addr constant [19 x i8] c"'for' step is zero\00", align 1
@.str.165 = private unnamed_addr constant [6 x i8] c"limit\00", align 1
@.str.166 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@.str.167 = private unnamed_addr constant [14 x i8] c"initial value\00", align 1
@.str.168 = private unnamed_addr constant [26 x i8] c"attempt to perform 'n%%0'\00", align 1
@.str.169 = private unnamed_addr constant [26 x i8] c"attempt to divide by zero\00", align 1
@.str.170 = private unnamed_addr constant [29 x i8] c"perform bitwise operation on\00", align 1
@.str.171 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str.172 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@.str.173 = private unnamed_addr constant [27 x i8] c"attempt to %s a %s value%s\00", align 1
@.str.174 = private unnamed_addr constant [11 x i8] c" (%s '%s')\00", align 1
@.str.175 = private unnamed_addr constant [39 x i8] c"number%s has no integer representation\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str.177 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.179 = private unnamed_addr constant [39 x i8] c"bad 'for' %s (number expected, got %s)\00", align 1
@.str.180 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.181 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str.182 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@udatatypename = internal constant [9 x i8] c"userdata\00", align 1
@.str.183 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.184 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.185 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.186 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str.187 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@luai_ctype_ = internal unnamed_addr constant [257 x i8] c"\00\00\00\00\00\00\00\00\00\00\08\08\08\08\08\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0C\04\04\04\04\04\04\04\04\04\04\04\04\04\04\04\16\16\16\16\16\16\16\16\16\16\04\04\04\04\04\04\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\05\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 16
@.str.188 = private unnamed_addr constant [6 x i8] c".xXnN\00", align 1
@.str.189 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.190 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str.191 = private unnamed_addr constant [12 x i8] c"-0123456789\00", align 1
@.str.192 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@.str.193 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.194 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.195 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.196 = private unnamed_addr constant [43 x i8] c"invalid option '%%%c' to 'lua_pushfstring'\00", align 1
@.str.197 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.198 = private unnamed_addr constant [40 x i8] c"'__index' chain too long; possible loop\00", align 1
@dummynode_ = internal constant %union.Node { %struct.NodeKey { %union.Value zeroinitializer, i8 16, i8 0, i32 0, %union.Value zeroinitializer } }, align 8
@.str.199 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@luaO_ceillog2.log_2 = internal unnamed_addr constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str.200 = private unnamed_addr constant [43 x i8] c"'__newindex' chain too long; possible loop\00", align 1
@.str.201 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str.202 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@.str.203 = private unnamed_addr constant [7 x i8] c"binary\00", align 1
@.str.204 = private unnamed_addr constant [5 x i8] c"text\00", align 1
@.str.205 = private unnamed_addr constant [42 x i8] c"attempt to load a %s chunk (mode is '%s')\00", align 1
@.str.206 = private unnamed_addr constant [14 x i8] c"binary string\00", align 1
@.str.207 = private unnamed_addr constant [19 x i8] c"not a binary chunk\00", align 1
@.str.208 = private unnamed_addr constant [17 x i8] c"version mismatch\00", align 1
@.str.209 = private unnamed_addr constant [16 x i8] c"format mismatch\00", align 1
@.str.210 = private unnamed_addr constant [7 x i8] c"\19\93\0D\0A\1A\0A\00", align 1
@.str.211 = private unnamed_addr constant [16 x i8] c"corrupted chunk\00", align 1
@.str.212 = private unnamed_addr constant [12 x i8] c"Instruction\00", align 1
@.str.213 = private unnamed_addr constant [12 x i8] c"lua_Integer\00", align 1
@.str.214 = private unnamed_addr constant [11 x i8] c"lua_Number\00", align 1
@.str.215 = private unnamed_addr constant [24 x i8] c"integer format mismatch\00", align 1
@.str.216 = private unnamed_addr constant [22 x i8] c"float format mismatch\00", align 1
@.str.217 = private unnamed_addr constant [16 x i8] c"truncated chunk\00", align 1
@.str.218 = private unnamed_addr constant [17 x i8] c"integer overflow\00", align 1
@.str.219 = private unnamed_addr constant [27 x i8] c"%s: bad binary format (%s)\00", align 1
@.str.220 = private unnamed_addr constant [17 x i8] c"%s size mismatch\00", align 1
@.str.221 = private unnamed_addr constant [31 x i8] c"bad format for constant string\00", align 1
@.str.222 = private unnamed_addr constant [8 x i8] c"opcodes\00", align 1
@.str.223 = private unnamed_addr constant [26 x i8] c"too many %s (limit is %d)\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.225 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str.226 = private unnamed_addr constant [14 x i8] c"main function\00", align 1
@.str.227 = private unnamed_addr constant [20 x i8] c"function at line %d\00", align 1
@.str.228 = private unnamed_addr constant [32 x i8] c"too many %s (limit is %d) in %s\00", align 1
@.str.229 = private unnamed_addr constant [11 x i8] c"%s near %s\00", align 1
@.str.230 = private unnamed_addr constant [5 x i8] c"'%s'\00", align 1
@.str.231 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str.232 = private unnamed_addr constant [5 x i8] c"'%c'\00", align 1
@.str.233 = private unnamed_addr constant [8 x i8] c"'<\5C%d>'\00", align 1
@.str.234 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str.235 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str.236 = private unnamed_addr constant [8 x i8] c"comment\00", align 1
@.str.237 = private unnamed_addr constant [41 x i8] c"unfinished long %s (starting at line %d)\00", align 1
@.str.238 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str.239 = private unnamed_addr constant [24 x i8] c"invalid escape sequence\00", align 1
@.str.240 = private unnamed_addr constant [27 x i8] c"hexadecimal digit expected\00", align 1
@.str.241 = private unnamed_addr constant [12 x i8] c"missing '{'\00", align 1
@.str.242 = private unnamed_addr constant [22 x i8] c"UTF-8 value too large\00", align 1
@.str.243 = private unnamed_addr constant [12 x i8] c"missing '}'\00", align 1
@.str.244 = private unnamed_addr constant [25 x i8] c"decimal escape too large\00", align 1
@.str.245 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str.246 = private unnamed_addr constant [3 x i8] c"xX\00", align 1
@.str.247 = private unnamed_addr constant [3 x i8] c"Pp\00", align 1
@.str.248 = private unnamed_addr constant [3 x i8] c"-+\00", align 1
@.str.249 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@priority = internal unnamed_addr constant [21 x %struct.anon.10] [%struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 14, i8 13 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 6, i8 6 }, %struct.anon.10 { i8 4, i8 4 }, %struct.anon.10 { i8 5, i8 5 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 9, i8 8 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 2, i8 2 }, %struct.anon.10 { i8 1, i8 1 }], align 16
@luaK_prefix.ef = internal constant %struct.expdesc { i32 6, %union.anon.8 zeroinitializer, i32 -1, i32 -1 }, align 8
@previousinstruction.invalidinstruction = internal constant i32 -1, align 4
@.str.250 = private unnamed_addr constant [10 x i8] c"constants\00", align 1
@.str.251 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@.str.252 = private unnamed_addr constant [48 x i8] c"function or expression needs too many registers\00", align 1
@.str.253 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str.254 = private unnamed_addr constant [21 x i8] c"constructor too long\00", align 1
@.str.255 = private unnamed_addr constant [23 x i8] c"items in a constructor\00", align 1
@.str.256 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str.257 = private unnamed_addr constant [10 x i8] c"functions\00", align 1
@.str.258 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str.259 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str.260 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str.261 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str.262 = private unnamed_addr constant [13 x i8] c"labels/gotos\00", align 1
@.str.263 = private unnamed_addr constant [56 x i8] c"<goto %s> at line %d jumps into the scope of local '%s'\00", align 1
@.str.264 = private unnamed_addr constant [30 x i8] c"break outside loop at line %d\00", align 1
@.str.265 = private unnamed_addr constant [44 x i8] c"no visible label '%s' for <goto> at line %d\00", align 1
@.str.266 = private unnamed_addr constant [37 x i8] c"%s expected (to close %s at line %d)\00", align 1
@.str.267 = private unnamed_addr constant [12 x i8] c"%s expected\00", align 1
@.str.268 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str.269 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str.270 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str.271 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@forbody.forprep = internal unnamed_addr constant [2 x i32] [i32 75, i32 76], align 4
@forbody.forloop = internal unnamed_addr constant [2 x i32] [i32 74, i32 78], align 4
@.str.272 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str.273 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str.274 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str.275 = private unnamed_addr constant [14 x i8] c"(for toclose)\00", align 1
@.str.276 = private unnamed_addr constant [8 x i8] c"toclose\00", align 1
@.str.277 = private unnamed_addr constant [23 x i8] c"unknown attribute '%s'\00", align 1
@.str.278 = private unnamed_addr constant [38 x i8] c"label '%s' already defined on line %d\00", align 1
@.str.279 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.280 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@.str.281 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@.str.282 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str.283 = private unnamed_addr constant [10 x i8] c"(no name)\00", align 1
@.str.284 = private unnamed_addr constant [14 x i8] c"function '%s'\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"%s '%s'\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"main chunk\00", align 1
@.str.287 = private unnamed_addr constant [17 x i8] c"function <%s:%d>\00", align 1
@.str.288 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.289 = private unnamed_addr constant [4 x i8] c"_G.\00", align 1
@.str.290 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.291 = private unnamed_addr constant [37 x i8] c"number has no integer representation\00", align 1
@.str.292 = private unnamed_addr constant [17 x i8] c"buffer too large\00", align 1
@.str.293 = private unnamed_addr constant [40 x i8] c"not enough memory for buffer allocation\00", align 1
@.str.294 = private unnamed_addr constant [7 x i8] c"_UBOX*\00", align 1
@boxmt = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg zeroinitializer], align 16
@.str.295 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str.296 = private unnamed_addr constant [4 x i8] c"\EF\BB\BF\00", align 1
@.str.297 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@.str.298 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.299 = private unnamed_addr constant [14 x i8] c"Lua warning: \00", align 1
@.str.300 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.301 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str.302 = private unnamed_addr constant [15 x i8] c"collectgarbage\00", align 1
@.str.303 = private unnamed_addr constant [7 x i8] c"dofile\00", align 1
@.str.304 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.305 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str.306 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str.307 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str.308 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.310 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str.311 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str.312 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.313 = private unnamed_addr constant [5 x i8] c"warn\00", align 1
@.str.314 = private unnamed_addr constant [9 x i8] c"rawequal\00", align 1
@.str.315 = private unnamed_addr constant [7 x i8] c"rawlen\00", align 1
@.str.316 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str.317 = private unnamed_addr constant [7 x i8] c"rawset\00", align 1
@.str.318 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.319 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.320 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str.321 = private unnamed_addr constant [9 x i8] c"tostring\00", align 1
@.str.322 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.323 = private unnamed_addr constant [7 x i8] c"xpcall\00", align 1
@.str.324 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@luaB_collectgarbage.opts = internal constant [11 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.325, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.326, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.329, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.330, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.331, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i32 0, i32 0), i8* null], align 16
@.str.325 = private unnamed_addr constant [5 x i8] c"stop\00", align 1
@.str.326 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str.327 = private unnamed_addr constant [8 x i8] c"collect\00", align 1
@.str.328 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"setpause\00", align 1
@.str.330 = private unnamed_addr constant [11 x i8] c"setstepmul\00", align 1
@.str.331 = private unnamed_addr constant [10 x i8] c"isrunning\00", align 1
@.str.332 = private unnamed_addr constant [13 x i8] c"generational\00", align 1
@.str.333 = private unnamed_addr constant [12 x i8] c"incremental\00", align 1
@luaB_collectgarbage.optsnum = internal unnamed_addr constant [10 x i32] [i32 0, i32 1, i32 2, i32 3, i32 5, i32 6, i32 7, i32 9, i32 10, i32 11], align 16
@.str.334 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str.335 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str.336 = private unnamed_addr constant [8 x i8] c"=(load)\00", align 1
@.str.337 = private unnamed_addr constant [26 x i8] c"too many nested functions\00", align 1
@.str.338 = private unnamed_addr constant [37 x i8] c"reader function must return a string\00", align 1
@.str.339 = private unnamed_addr constant [8 x i8] c"__pairs\00", align 1
@.str.341 = private unnamed_addr constant [16 x i8] c"table or string\00", align 1
@.str.342 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@.str.343 = private unnamed_addr constant [13 x i8] c"nil or table\00", align 1
@.str.344 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str.345 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str.346 = private unnamed_addr constant [7 x i8] c" \0C\0A\0D\09\0B\00", align 1
@.str.347 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str.348 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@.str.349 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str.350 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str.351 = private unnamed_addr constant [5 x i8] c"wrap\00", align 1
@.str.352 = private unnamed_addr constant [6 x i8] c"yield\00", align 1
@.str.353 = private unnamed_addr constant [12 x i8] c"isyieldable\00", align 1
@.str.354 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@.str.355 = private unnamed_addr constant [29 x i8] c"too many arguments to resume\00", align 1
@.str.356 = private unnamed_addr constant [27 x i8] c"too many results to resume\00", align 1
@statname = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.357, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.358, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.359, i32 0, i32 0)], align 16
@.str.357 = private unnamed_addr constant [5 x i8] c"dead\00", align 1
@.str.358 = private unnamed_addr constant [10 x i8] c"suspended\00", align 1
@.str.359 = private unnamed_addr constant [7 x i8] c"normal\00", align 1
@.str.360 = private unnamed_addr constant [27 x i8] c"cannot kill a %s coroutine\00", align 1
@.str.361 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.362 = private unnamed_addr constant [13 x i8] c"getuservalue\00", align 1
@.str.363 = private unnamed_addr constant [8 x i8] c"gethook\00", align 1
@.str.364 = private unnamed_addr constant [8 x i8] c"getinfo\00", align 1
@.str.365 = private unnamed_addr constant [9 x i8] c"getlocal\00", align 1
@.str.366 = private unnamed_addr constant [12 x i8] c"getregistry\00", align 1
@.str.367 = private unnamed_addr constant [11 x i8] c"getupvalue\00", align 1
@.str.368 = private unnamed_addr constant [12 x i8] c"upvaluejoin\00", align 1
@.str.369 = private unnamed_addr constant [10 x i8] c"upvalueid\00", align 1
@.str.370 = private unnamed_addr constant [13 x i8] c"setuservalue\00", align 1
@.str.371 = private unnamed_addr constant [8 x i8] c"sethook\00", align 1
@.str.372 = private unnamed_addr constant [9 x i8] c"setlocal\00", align 1
@.str.373 = private unnamed_addr constant [11 x i8] c"setupvalue\00", align 1
@.str.374 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str.375 = private unnamed_addr constant [12 x i8] c"lua_debug> \00", align 1
@.str.376 = private unnamed_addr constant [6 x i8] c"cont\0A\00", align 1
@.str.377 = private unnamed_addr constant [17 x i8] c"=(debug command)\00", align 1
@.str.378 = private unnamed_addr constant [14 x i8] c"external hook\00", align 1
@HOOKKEY = internal constant i32 0, align 4
@hookf.hooknames = internal unnamed_addr constant [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.380, i32 0, i32 0)], align 16
@.str.379 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str.380 = private unnamed_addr constant [10 x i8] c"tail call\00", align 1
@.str.381 = private unnamed_addr constant [8 x i8] c"flnSrtu\00", align 1
@.str.382 = private unnamed_addr constant [4 x i8] c">%s\00", align 1
@.str.383 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.384 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str.385 = private unnamed_addr constant [10 x i8] c"short_src\00", align 1
@.str.386 = private unnamed_addr constant [12 x i8] c"linedefined\00", align 1
@.str.387 = private unnamed_addr constant [16 x i8] c"lastlinedefined\00", align 1
@.str.388 = private unnamed_addr constant [5 x i8] c"what\00", align 1
@.str.389 = private unnamed_addr constant [12 x i8] c"currentline\00", align 1
@.str.390 = private unnamed_addr constant [5 x i8] c"nups\00", align 1
@.str.391 = private unnamed_addr constant [8 x i8] c"nparams\00", align 1
@.str.392 = private unnamed_addr constant [9 x i8] c"isvararg\00", align 1
@.str.393 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.394 = private unnamed_addr constant [9 x i8] c"namewhat\00", align 1
@.str.395 = private unnamed_addr constant [10 x i8] c"ftransfer\00", align 1
@.str.396 = private unnamed_addr constant [10 x i8] c"ntransfer\00", align 1
@.str.397 = private unnamed_addr constant [11 x i8] c"istailcall\00", align 1
@.str.398 = private unnamed_addr constant [12 x i8] c"activelines\00", align 1
@.str.399 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.400 = private unnamed_addr constant [19 x i8] c"level out of range\00", align 1
@.str.401 = private unnamed_addr constant [22 x i8] c"Lua function expected\00", align 1
@.str.402 = private unnamed_addr constant [22 x i8] c"invalid upvalue index\00", align 1
@.str.403 = private unnamed_addr constant [2 x i8] c"k\00", align 1
@.str.404 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.405 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.406 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.407 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.408 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str.409 = private unnamed_addr constant [8 x i8] c"tmpfile\00", align 1
@.str.410 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.411 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@.str.412 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@.str.413 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@.str.414 = private unnamed_addr constant [27 x i8] c"cannot open file '%s' (%s)\00", align 1
@.str.415 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str.416 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str.417 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str.418 = private unnamed_addr constant [3 x i8] c"00\00", align 1
@.str.419 = private unnamed_addr constant [3 x i8] c"pP\00", align 1
@.str.420 = private unnamed_addr constant [3 x i8] c"eE\00", align 1
@.str.421 = private unnamed_addr constant [13 x i8] c"invalid mode\00", align 1
@.str.422 = private unnamed_addr constant [4 x i8] c"rwa\00", align 1
@.str.423 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@.str.424 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.425 = private unnamed_addr constant [22 x i8] c"'popen' not supported\00", align 1
@.str.426 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str.427 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@flib = internal constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @f_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @f_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @f_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @f_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.428, i32 0, i32 0), i32 (%struct.lua_State*)* @f_seek }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.429, i32 0, i32 0), i32 (%struct.lua_State*)* @f_setvbuf }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @f_write }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i32 (%struct.lua_State*)* @f_tostring }, %struct.luaL_Reg zeroinitializer], align 16
@.str.428 = private unnamed_addr constant [5 x i8] c"seek\00", align 1
@.str.429 = private unnamed_addr constant [8 x i8] c"setvbuf\00", align 1
@f_seek.mode = internal unnamed_addr constant [3 x i32] [i32 0, i32 1, i32 2], align 4
@f_seek.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.430, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* null], align 16
@.str.430 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.431 = private unnamed_addr constant [4 x i8] c"cur\00", align 1
@f_setvbuf.mode = internal unnamed_addr constant [3 x i32] [i32 2, i32 0, i32 1], align 4
@f_setvbuf.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.433, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.434, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* null], align 16
@.str.433 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.434 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str.435 = private unnamed_addr constant [14 x i8] c"file (closed)\00", align 1
@.str.436 = private unnamed_addr constant [10 x i8] c"file (%p)\00", align 1
@.str.437 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@.str.438 = private unnamed_addr constant [4 x i8] c"abs\00", align 1
@.str.439 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str.440 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str.441 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str.442 = private unnamed_addr constant [5 x i8] c"ceil\00", align 1
@.str.443 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str.444 = private unnamed_addr constant [4 x i8] c"deg\00", align 1
@.str.445 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str.446 = private unnamed_addr constant [10 x i8] c"tointeger\00", align 1
@.str.447 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str.448 = private unnamed_addr constant [5 x i8] c"fmod\00", align 1
@.str.449 = private unnamed_addr constant [4 x i8] c"ult\00", align 1
@.str.450 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str.451 = private unnamed_addr constant [4 x i8] c"max\00", align 1
@.str.452 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str.453 = private unnamed_addr constant [5 x i8] c"modf\00", align 1
@.str.454 = private unnamed_addr constant [4 x i8] c"rad\00", align 1
@.str.455 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str.456 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str.457 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str.458 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.459 = private unnamed_addr constant [11 x i8] c"randomseed\00", align 1
@.str.460 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
@.str.461 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.462 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@randfuncs = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* @math_random }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* @math_randomseed }, %struct.luaL_Reg zeroinitializer], align 16
@.str.463 = private unnamed_addr constant [26 x i8] c"wrong number of arguments\00", align 1
@.str.464 = private unnamed_addr constant [18 x i8] c"interval is empty\00", align 1
@CLIBS = internal constant i32 0, align 4
@.str.465 = private unnamed_addr constant [8 x i8] c"loadlib\00", align 1
@.str.466 = private unnamed_addr constant [11 x i8] c"searchpath\00", align 1
@.str.467 = private unnamed_addr constant [10 x i8] c"searchers\00", align 1
@.str.468 = private unnamed_addr constant [7 x i8] c"absent\00", align 1
@.str.469 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.470 = private unnamed_addr constant [59 x i8] c"dynamic libraries not enabled; check your Lua installation\00", align 1
@.str.471 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.472 = private unnamed_addr constant [2 x i8] c";\00", align 1
@.str.473 = private unnamed_addr constant [12 x i8] c"\0A\09no file '\00", align 1
@.str.474 = private unnamed_addr constant [13 x i8] c"'\0A\09no file '\00", align 1
@.str.475 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@createsearcherstable.searchers = internal unnamed_addr constant [5 x i32 (%struct.lua_State*)*] [i32 (%struct.lua_State*)* @searcher_preload, i32 (%struct.lua_State*)* @searcher_Lua, i32 (%struct.lua_State*)* @searcher_C, i32 (%struct.lua_State*)* @searcher_Croot, i32 (%struct.lua_State*)* null], align 16
@.str.476 = private unnamed_addr constant [33 x i8] c"\0A\09no field package.preload['%s']\00", align 1
@.str.477 = private unnamed_addr constant [10 x i8] c":preload:\00", align 1
@.str.478 = private unnamed_addr constant [30 x i8] c"'package.%s' must be a string\00", align 1
@.str.479 = private unnamed_addr constant [46 x i8] c"error loading module '%s' from file '%s':\0A\09%s\00", align 1
@.str.480 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.481 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.482 = private unnamed_addr constant [11 x i8] c"luaopen_%s\00", align 1
@.str.483 = private unnamed_addr constant [30 x i8] c"\0A\09no module '%s' in file '%s'\00", align 1
@.str.484 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@.str.485 = private unnamed_addr constant [5 x i8] c"_5_4\00", align 1
@.str.486 = private unnamed_addr constant [3 x i8] c";;\00", align 1
@.str.487 = private unnamed_addr constant [10 x i8] c"LUA_NOENV\00", align 1
@.str.488 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.489 = private unnamed_addr constant [36 x i8] c"'package.searchers' must be a table\00", align 1
@.str.490 = private unnamed_addr constant [25 x i8] c"module '%s' not found:%s\00", align 1
@.str.491 = private unnamed_addr constant [6 x i8] c"clock\00", align 1
@.str.492 = private unnamed_addr constant [5 x i8] c"date\00", align 1
@.str.493 = private unnamed_addr constant [9 x i8] c"difftime\00", align 1
@.str.494 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str.495 = private unnamed_addr constant [7 x i8] c"getenv\00", align 1
@.str.496 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.497 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@.str.498 = private unnamed_addr constant [10 x i8] c"setlocale\00", align 1
@.str.499 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str.500 = private unnamed_addr constant [8 x i8] c"tmpname\00", align 1
@.str.501 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.502 = private unnamed_addr constant [55 x i8] c"time result cannot be represented in this installation\00", align 1
@.str.503 = private unnamed_addr constant [3 x i8] c"*t\00", align 1
@.str.505 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
@.str.506 = private unnamed_addr constant [5 x i8] c"hour\00", align 1
@.str.507 = private unnamed_addr constant [4 x i8] c"day\00", align 1
@.str.508 = private unnamed_addr constant [6 x i8] c"month\00", align 1
@.str.509 = private unnamed_addr constant [5 x i8] c"year\00", align 1
@.str.510 = private unnamed_addr constant [5 x i8] c"wday\00", align 1
@.str.511 = private unnamed_addr constant [5 x i8] c"yday\00", align 1
@.str.512 = private unnamed_addr constant [6 x i8] c"isdst\00", align 1
@.str.513 = private unnamed_addr constant [78 x i8] c"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy\00", align 1
@.str.514 = private unnamed_addr constant [36 x i8] c"invalid conversion specifier '%%%s'\00", align 1
@os_setlocale.cat = internal unnamed_addr constant [6 x i32] [i32 6, i32 3, i32 0, i32 4, i32 1, i32 2], align 16
@os_setlocale.catnames = internal constant [7 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.516, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.517, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.518, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.519, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i8* null], align 16
@.str.515 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.516 = private unnamed_addr constant [8 x i8] c"collate\00", align 1
@.str.517 = private unnamed_addr constant [6 x i8] c"ctype\00", align 1
@.str.518 = private unnamed_addr constant [9 x i8] c"monetary\00", align 1
@.str.519 = private unnamed_addr constant [8 x i8] c"numeric\00", align 1
@.str.520 = private unnamed_addr constant [29 x i8] c"field '%s' is not an integer\00", align 1
@.str.521 = private unnamed_addr constant [33 x i8] c"field '%s' missing in date table\00", align 1
@.str.522 = private unnamed_addr constant [27 x i8] c"field '%s' is out-of-bound\00", align 1
@.str.523 = private unnamed_addr constant [37 x i8] c"unable to generate a unique filename\00", align 1
@.str.524 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str.525 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str.526 = private unnamed_addr constant [5 x i8] c"dump\00", align 1
@.str.527 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.528 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str.529 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str.530 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str.531 = private unnamed_addr constant [4 x i8] c"len\00", align 1
@.str.532 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str.533 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str.534 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str.535 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str.536 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.537 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str.538 = private unnamed_addr constant [5 x i8] c"pack\00", align 1
@.str.539 = private unnamed_addr constant [9 x i8] c"packsize\00", align 1
@.str.540 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str.541 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str.542 = private unnamed_addr constant [19 x i8] c"value out of range\00", align 1
@.str.543 = private unnamed_addr constant [30 x i8] c"unable to dump given function\00", align 1
@.str.544 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str.545 = private unnamed_addr constant [20 x i8] c"pattern too complex\00", align 1
@.str.546 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str.547 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str.548 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str.549 = private unnamed_addr constant [47 x i8] c"malformed pattern (missing arguments to '%%b')\00", align 1
@.str.550 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str.551 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str.552 = private unnamed_addr constant [27 x i8] c"invalid capture index %%%d\00", align 1
@.str.553 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str.554 = private unnamed_addr constant [3 x i8] c"ll\00", align 1
@.str.555 = private unnamed_addr constant [38 x i8] c"specifier '%%q' cannot have modifiers\00", align 1
@.str.556 = private unnamed_addr constant [22 x i8] c"string contains zeros\00", align 1
@.str.557 = private unnamed_addr constant [36 x i8] c"invalid conversion '%s' to 'format'\00", align 1
@.str.559 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str.560 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str.561 = private unnamed_addr constant [7 x i8] c"0x%llx\00", align 1
@.str.562 = private unnamed_addr constant [26 x i8] c"value has no literal form\00", align 1
@.str.563 = private unnamed_addr constant [4 x i8] c"\5C%d\00", align 1
@.str.564 = private unnamed_addr constant [6 x i8] c"\5C%03d\00", align 1
@.str.565 = private unnamed_addr constant [7 x i8] c"1e9999\00", align 1
@.str.566 = private unnamed_addr constant [8 x i8] c"-1e9999\00", align 1
@.str.567 = private unnamed_addr constant [6 x i8] c"(0/0)\00", align 1
@.str.568 = private unnamed_addr constant [3 x i8] c"%a\00", align 1
@.str.569 = private unnamed_addr constant [22 x i8] c"string/function/table\00", align 1
@.str.570 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str.571 = private unnamed_addr constant [42 x i8] c"invalid use of '%c' in replacement string\00", align 1
@.str.572 = private unnamed_addr constant [27 x i8] c"resulting string too large\00", align 1
@.str.573 = private unnamed_addr constant [18 x i8] c"unsigned overflow\00", align 1
@.str.574 = private unnamed_addr constant [30 x i8] c"string longer than given size\00", align 1
@.str.575 = private unnamed_addr constant [41 x i8] c"string length does not fit in given size\00", align 1
@.str.576 = private unnamed_addr constant [35 x i8] c"invalid next option for option 'X'\00", align 1
@.str.577 = private unnamed_addr constant [41 x i8] c"format asks for alignment not power of 2\00", align 1
@.str.578 = private unnamed_addr constant [35 x i8] c"missing size for format option 'c'\00", align 1
@.str.579 = private unnamed_addr constant [27 x i8] c"invalid format option '%c'\00", align 1
@.str.580 = private unnamed_addr constant [40 x i8] c"integral size (%d) out of limits [1,%d]\00", align 1
@.str.581 = private unnamed_addr constant [23 x i8] c"variable-length format\00", align 1
@.str.582 = private unnamed_addr constant [24 x i8] c"format result too large\00", align 1
@.str.583 = private unnamed_addr constant [31 x i8] c"initial position out of string\00", align 1
@.str.584 = private unnamed_addr constant [22 x i8] c"data string too short\00", align 1
@.str.585 = private unnamed_addr constant [17 x i8] c"too many results\00", align 1
@.str.586 = private unnamed_addr constant [33 x i8] c"unfinished string for format 'z'\00", align 1
@.str.587 = private unnamed_addr constant [46 x i8] c"%d-byte integer does not fit into Lua Integer\00", align 1
@stringmetamethods = internal constant [10 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_add }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mul }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mod }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_pow }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_div }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_idiv }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_unm }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.588 = private unnamed_addr constant [33 x i8] c"attempt to %s a '%s' with a '%s'\00", align 1
@.str.589 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.590 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.591 = private unnamed_addr constant [5 x i8] c"move\00", align 1
@.str.592 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str.593 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str.594 = private unnamed_addr constant [23 x i8] c"position out of bounds\00", align 1
@.str.595 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str.596 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str.597 = private unnamed_addr constant [26 x i8] c"too many elements to move\00", align 1
@.str.598 = private unnamed_addr constant [24 x i8] c"destination wrap around\00", align 1
@.str.599 = private unnamed_addr constant [14 x i8] c"array too big\00", align 1
@.str.600 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@.str.601 = private unnamed_addr constant [7 x i8] c"offset\00", align 1
@.str.602 = private unnamed_addr constant [10 x i8] c"codepoint\00", align 1
@.str.603 = private unnamed_addr constant [6 x i8] c"codes\00", align 1
@.str.604 = private unnamed_addr constant [22 x i8] c"position out of range\00", align 1
@.str.605 = private unnamed_addr constant [40 x i8] c"initial position is a continuation byte\00", align 1
@.str.606 = private unnamed_addr constant [13 x i8] c"out of range\00", align 1
@.str.607 = private unnamed_addr constant [19 x i8] c"invalid UTF-8 code\00", align 1
@utf8_decode.limits = internal unnamed_addr constant [6 x i32] [i32 -1, i32 128, i32 2048, i32 65536, i32 2097152, i32 67108864], align 16
@.str.608 = private unnamed_addr constant [3 x i8] c"%U\00", align 1
@.str.609 = private unnamed_addr constant [29 x i8] c"final position out of string\00", align 1
@.str.610 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@.str.611 = private unnamed_addr constant [10 x i8] c"coroutine\00", align 1
@.str.612 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.613 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str.614 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@.str.615 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str.616 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@progname = internal unnamed_addr global i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.617, i64 0, i64 0), align 8
@.str.617 = private unnamed_addr constant [4 x i8] c"lua\00", align 1
@.str.618 = private unnamed_addr constant [21 x i8] c"'%s' needs argument\0A\00", align 1
@.str.619 = private unnamed_addr constant [26 x i8] c"unrecognized option '%s'\0A\00", align 1
@.str.620 = private unnamed_addr constant [365 x i8] c"usage: %s [options] [script [args]]\0AAvailable options are:\0A  -e stat  execute string 'stat'\0A  -i       enter interactive mode after executing 'script'\0A  -l name  require library 'name' into global 'name'\0A  -v       show version information\0A  -E       ignore environment variables\0A  --       stop handling options\0A  -        stop handling options and execute stdin\0A\00", align 1
@.str.621 = private unnamed_addr constant [52 x i8] c"Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio\00", align 1
@.str.622 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str.623 = private unnamed_addr constant [14 x i8] c"=LUA_INIT_5_4\00", align 1
@.str.624 = private unnamed_addr constant [10 x i8] c"=LUA_INIT\00", align 1
@globalL = internal unnamed_addr global %struct.lua_State* null, align 8
@.str.625 = private unnamed_addr constant [29 x i8] c"(error object is a %s value)\00", align 1
@.str.626 = private unnamed_addr constant [13 x i8] c"interrupted!\00", align 1
@.str.627 = private unnamed_addr constant [16 x i8] c"=(command line)\00", align 1
@.str.628 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str.629 = private unnamed_addr constant [21 x i8] c"'arg' is not a table\00", align 1
@.str.630 = private unnamed_addr constant [29 x i8] c"too many arguments to script\00", align 1
@.str.631 = private unnamed_addr constant [10 x i8] c"return %s\00", align 1
@.str.632 = private unnamed_addr constant [8 x i8] c"_PROMPT\00", align 1
@.str.633 = private unnamed_addr constant [9 x i8] c"_PROMPT2\00", align 1
@.str.634 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str.635 = private unnamed_addr constant [4 x i8] c">> \00", align 1
@.str.636 = private unnamed_addr constant [11 x i8] c"return %s;\00", align 1
@.str.637 = private unnamed_addr constant [26 x i8] c"too many results to print\00", align 1
@.str.638 = private unnamed_addr constant [27 x i8] c"error calling 'print' (%s)\00", align 1

; Function Attrs: nounwind uwtable
define nonnull %struct.lua_State* @lua_newthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %5 = load i64, i64* %4, align 8, !tbaa !11
  %6 = icmp sgt i64 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %8

; <label>:8:                                      ; preds = %7, %1
  %9 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* nonnull %0, i64 208, i32 8)
  %10 = getelementptr inbounds i8, i8* %9, i64 8
  %11 = bitcast i8* %10 to %struct.lua_State*
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %13 = load i8, i8* %12, align 4, !tbaa !15
  %14 = and i8 %13, 24
  %15 = getelementptr inbounds i8, i8* %9, i64 17
  store i8 %14, i8* %15, align 1, !tbaa !16
  %16 = getelementptr inbounds i8, i8* %9, i64 16
  store i8 8, i8* %16, align 8, !tbaa !17
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %18 = bitcast %struct.GCObject** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !18
  %20 = bitcast i8* %10 to i64*
  store i64 %19, i64* %20, align 8, !tbaa !19
  %21 = bitcast %struct.GCObject** %17 to i8**
  store i8* %10, i8** %21, align 8, !tbaa !18
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = bitcast %union.StackValue** %22 to %struct.TValue**
  %24 = load %struct.TValue*, %struct.TValue** %23, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i8**
  store i8* %10, i8** %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 72, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %22, align 8, !tbaa !20
  tail call fastcc void @preinit_thread(%struct.lua_State* nonnull %11, %struct.global_State* %3)
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %30 = load i32, i32* %29, align 8, !tbaa !23
  %31 = getelementptr inbounds i8, i8* %9, i64 200
  %32 = bitcast i8* %31 to i32*
  store i32 %30, i32* %32, align 8, !tbaa !23
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %34 = load i32, i32* %33, align 8, !tbaa !24
  %35 = getelementptr inbounds i8, i8* %9, i64 192
  %36 = bitcast i8* %35 to i32*
  store i32 %34, i32* %36, align 8, !tbaa !24
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %38 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %37, align 8, !tbaa !25
  %39 = getelementptr inbounds i8, i8* %9, i64 168
  %40 = bitcast i8* %39 to void (%struct.lua_State*, %struct.lua_Debug*)**
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %38, void (%struct.lua_State*, %struct.lua_Debug*)** %40, align 8, !tbaa !25
  %41 = getelementptr inbounds i8, i8* %9, i64 196
  %42 = bitcast i8* %41 to i32*
  store i32 %34, i32* %42, align 4, !tbaa !26
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %44 = bitcast %struct.lua_State** %43 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !27
  %46 = getelementptr inbounds i8, i8* %45, i64 -8
  %47 = bitcast i8* %46 to i64*
  %48 = bitcast i8* %9 to i64*
  %49 = load i64, i64* %47, align 1
  store i64 %49, i64* %48, align 1
  tail call fastcc void @stack_init(%struct.lua_State* nonnull %11, %struct.lua_State* nonnull %0)
  ret %struct.lua_State* %11
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_step(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 15
  %5 = load i8, i8* %4, align 1, !tbaa !28
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %17, label %7

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 12
  %9 = load i8, i8* %8, align 2, !tbaa !29
  %10 = icmp eq i8 %9, 1
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %7
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 5
  %13 = load i64, i64* %12, align 8, !tbaa !30
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %16, label %15

; <label>:15:                                     ; preds = %11, %7
  tail call fastcc void @genstep(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3)
  br label %17

; <label>:16:                                     ; preds = %11
  tail call fastcc void @incstep(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3)
  br label %17

; <label>:17:                                     ; preds = %1, %15, %16
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaM_malloc_(%struct.lua_State*, i64, i32) unnamed_addr #0 {
  %4 = icmp eq i64 %1, 0
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %9 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %8, align 8, !tbaa !31
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %11 = load i8*, i8** %10, align 8, !tbaa !32
  %12 = sext i32 %2 to i64
  %13 = tail call i8* %9(i8* %11, i8* null, i64 %12, i64 %1) #7
  %14 = icmp eq i8* %13, null
  br i1 %14, label %15, label %19, !prof !33

; <label>:15:                                     ; preds = %5
  %16 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* null, i64 %12, i64 %1)
  %17 = icmp eq i8* %16, null
  br i1 %17, label %18, label %19

; <label>:18:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #17
  unreachable

; <label>:19:                                     ; preds = %15, %5
  %20 = phi i8* [ %16, %15 ], [ %13, %5 ]
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %22 = load i64, i64* %21, align 8, !tbaa !11
  %23 = add i64 %22, %1
  store i64 %23, i64* %21, align 8, !tbaa !11
  br label %24

; <label>:24:                                     ; preds = %3, %19
  %25 = phi i8* [ %20, %19 ], [ null, %3 ]
  ret i8* %25
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @preinit_thread(%struct.lua_State*, %struct.global_State*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  store %struct.global_State* %1, %struct.global_State** %3, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !34
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* null, %struct.CallInfo** %5, align 8, !tbaa !35
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  store i16 0, i16* %6, align 4, !tbaa !36
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  store i32 0, i32* %7, align 4, !tbaa !37
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 14
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !38
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  store %struct.lua_longjmp* null, %struct.lua_longjmp** %9, align 8, !tbaa !39
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 0, i32* %10, align 8, !tbaa !40
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %11, align 8, !tbaa !25
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  store i32 0, i32* %12, align 8, !tbaa !23
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  store i32 0, i32* %13, align 8, !tbaa !24
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  store i8 1, i8* %14, align 1, !tbaa !41
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  store i32 0, i32* %15, align 4, !tbaa !26
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  store %struct.UpVal* null, %struct.UpVal** %16, align 8, !tbaa !42
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 0, i8* %17, align 2, !tbaa !43
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 0, i64* %18, align 8, !tbaa !44
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind uwtable
define internal fastcc void @stack_init(%struct.lua_State*, %struct.lua_State*) unnamed_addr #0 {
  %3 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %1, i64 640, i32 0)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = bitcast %union.StackValue** %4 to i8**
  store i8* %3, i8** %5, align 8, !tbaa !34
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  store i32 40, i32* %6, align 4, !tbaa !37
  %7 = bitcast i8* %3 to %union.StackValue*
  br label %8

; <label>:8:                                      ; preds = %8, %2
  %9 = phi i64 [ 0, %2 ], [ %12, %8 ]
  %10 = phi %union.StackValue* [ %7, %2 ], [ %13, %8 ]
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 %9, i32 0, i32 1
  store i8 0, i8* %11, align 8, !tbaa !21
  %12 = add nuw nsw i64 %9, 1
  %13 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !34
  %14 = icmp eq i64 %12, 40
  br i1 %14, label %15, label %8

; <label>:15:                                     ; preds = %8
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %13, %union.StackValue** %16, align 8, !tbaa !20
  %17 = load i32, i32* %6, align 4, !tbaa !37
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 %18
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -5
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %20, %union.StackValue** %21, align 8, !tbaa !45
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 2
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  %25 = bitcast %struct.CallInfo** %23 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %25, i8 0, i64 16, i32 8, i1 false)
  store i16 2, i16* %24, align 2, !tbaa !46
  %26 = bitcast %union.StackValue** %16 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !20
  %28 = bitcast %struct.CallInfo* %22 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !47
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* null, i32 (%struct.lua_State*, i32, i64)** %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 6
  store i16 0, i16* %30, align 4, !tbaa !48
  %31 = bitcast %union.StackValue** %16 to %struct.TValue**
  %32 = load %struct.TValue*, %struct.TValue** %31, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  store i8 0, i8* %33, align 8, !tbaa !21
  %34 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %16, align 8, !tbaa !20
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 21
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %36, %union.StackValue** %37, align 8, !tbaa !49
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %22, %struct.CallInfo** %38, align 8, !tbaa !35
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_resetthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !34
  %5 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4, i32 -2)
  %6 = bitcast %union.StackValue** %3 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !34
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = icmp eq i32 %5, -2
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !34
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  br i1 %9, label %13, label %12

; <label>:12:                                     ; preds = %1
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %5, %union.StackValue* nonnull %11)
  br label %15

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %11, %union.StackValue** %14, align 8, !tbaa !20
  br label %15

; <label>:15:                                     ; preds = %13, %12
  %16 = phi i32 [ %5, %12 ], [ 0, %13 ]
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  store i16 2, i16* %17, align 2, !tbaa !46
  %18 = bitcast %union.StackValue** %3 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !34
  %20 = bitcast %struct.CallInfo* %2 to i64*
  store i64 %19, i64* %20, align 8, !tbaa !47
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 20
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %23, %union.StackValue** %24, align 8, !tbaa !49
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %2, %struct.CallInfo** %25, align 8, !tbaa !35
  %26 = trunc i32 %16 to i8
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %26, i8* %27, align 2, !tbaa !43
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaF_close(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = load %struct.UpVal*, %struct.UpVal** %4, align 8, !tbaa !42
  %6 = icmp eq %struct.UpVal* %5, null
  br i1 %6, label %72, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = bitcast %union.StackValue** %8 to i8**
  br label %11

; <label>:11:                                     ; preds = %7, %67
  %12 = phi %struct.UpVal* [ %5, %7 ], [ %70, %67 ]
  %13 = phi %union.StackValue* [ %1, %7 ], [ %69, %67 ]
  %14 = phi i32 [ %2, %7 ], [ %68, %67 ]
  %15 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %12, i64 0, i32 3
  %16 = bitcast %struct.TValue** %15 to %union.StackValue**
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !50
  %18 = icmp ult %union.StackValue* %17, %13
  br i1 %18, label %72, label %19

; <label>:19:                                     ; preds = %11
  %20 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %12, i64 0, i32 4
  tail call fastcc void @luaF_unlinkupval(%struct.UpVal* nonnull %12)
  %21 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !50
  %22 = bitcast %struct.TValue* %21 to i64*
  %23 = bitcast %union.anon.4* %20 to i64*
  %24 = load i64, i64* %22, align 8
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %12, i64 0, i32 4, i32 0, i32 1
  %28 = bitcast %struct.UpVal*** %27 to i8*
  store i8 %26, i8* %28, align 8, !tbaa !22
  %29 = bitcast %struct.TValue** %15 to %union.anon.4**
  store %union.anon.4* %20, %union.anon.4** %29, align 8, !tbaa !50
  %30 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %12, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !52
  %32 = and i8 %31, 24
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %36

; <label>:34:                                     ; preds = %19
  %35 = or i8 %31, 32
  store i8 %35, i8* %30, align 1, !tbaa !52
  br label %36

; <label>:36:                                     ; preds = %19, %34
  %37 = and i8 %26, 64
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %52, label %39

; <label>:39:                                     ; preds = %36
  %40 = load i8, i8* %30, align 1, !tbaa !52
  %41 = and i8 %40, 32
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %52, label %43

; <label>:43:                                     ; preds = %39
  %44 = bitcast %union.anon.4* %20 to %struct.GCObject**
  %45 = load %struct.GCObject*, %struct.GCObject** %44, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %45, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !53
  %48 = and i8 %47, 24
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %52, label %50

; <label>:50:                                     ; preds = %43
  %51 = bitcast %struct.UpVal* %12 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %51, %struct.GCObject* %45)
  br label %52

; <label>:52:                                     ; preds = %43, %39, %36, %50
  %53 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %12, i64 0, i32 1
  %54 = load i8, i8* %53, align 8, !tbaa !55
  %55 = icmp eq i8 %54, 25
  %56 = icmp ne i32 %14, -1
  %57 = and i1 %56, %55
  br i1 %57, label %58, label %67

; <label>:58:                                     ; preds = %52
  %59 = load i64, i64* %9, align 8, !tbaa !34
  %60 = ptrtoint %union.StackValue* %13 to i64
  %61 = sub i64 %60, %59
  %62 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !50
  %63 = tail call fastcc i32 @callclosemth(%struct.lua_State* nonnull %0, %struct.TValue* %62, %union.StackValue* %17, i32 %14)
  %64 = load i8*, i8** %10, align 8, !tbaa !34
  %65 = getelementptr inbounds i8, i8* %64, i64 %61
  %66 = bitcast i8* %65 to %union.StackValue*
  br label %67

; <label>:67:                                     ; preds = %58, %52
  %68 = phi i32 [ %63, %58 ], [ %14, %52 ]
  %69 = phi %union.StackValue* [ %66, %58 ], [ %13, %52 ]
  %70 = load %struct.UpVal*, %struct.UpVal** %4, align 8, !tbaa !42
  %71 = icmp eq %struct.UpVal* %70, null
  br i1 %71, label %72, label %11

; <label>:72:                                     ; preds = %67, %11, %3
  %73 = phi i32 [ %2, %3 ], [ %14, %11 ], [ %68, %67 ]
  ret i32 %73
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_seterrorobj(%struct.lua_State*, i32, %union.StackValue*) unnamed_addr #0 {
  switch i32 %1, label %19 [
    i32 4, label %4
    i32 5, label %13
    i32 -2, label %28
  ]

; <label>:4:                                      ; preds = %3
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 39
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !56
  %9 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %8, %struct.TString** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %8, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !57
  %12 = or i8 %11, 64
  br label %28

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.163, i64 0, i64 0), i64 23)
  %15 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %14, %struct.TString** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %14, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !57
  %18 = or i8 %17, 64
  br label %28

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = bitcast %struct.TValue* %22 to i64*
  %24 = bitcast %union.StackValue* %2 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  br label %28

; <label>:28:                                     ; preds = %3, %19, %13, %4
  %29 = phi i8 [ %27, %19 ], [ %18, %13 ], [ %12, %4 ], [ 0, %3 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %31, %union.StackValue** %32, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)*, i8*) #0 {
  %3 = tail call i8* %0(i8* %1, i8* null, i64 8, i64 1616) #7
  %4 = icmp eq i8* %3, null
  br i1 %4, label %52, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds i8, i8* %3, i64 8
  %7 = bitcast i8* %6 to %struct.lua_State*
  %8 = getelementptr inbounds i8, i8* %3, i64 208
  %9 = bitcast i8* %8 to %struct.global_State*
  %10 = getelementptr inbounds i8, i8* %3, i64 16
  store i8 8, i8* %10, align 8, !tbaa !17
  %11 = getelementptr inbounds i8, i8* %3, i64 308
  store i8 8, i8* %11, align 4, !tbaa !15
  %12 = getelementptr inbounds i8, i8* %3, i64 17
  store i8 8, i8* %12, align 1, !tbaa !16
  tail call fastcc void @preinit_thread(%struct.lua_State* nonnull %7, %struct.global_State* nonnull %9)
  %13 = getelementptr inbounds i8, i8* %3, i64 320
  %14 = bitcast i8* %13 to i8**
  store i8* %6, i8** %14, align 8, !tbaa !18
  %15 = bitcast i8* %6 to %struct.GCObject**
  store %struct.GCObject* null, %struct.GCObject** %15, align 8, !tbaa !19
  %16 = bitcast i8* %8 to i8* (i8*, i8*, i64, i64)**
  store i8* (i8*, i8*, i64, i64)* %0, i8* (i8*, i8*, i64, i64)** %16, align 8, !tbaa !31
  %17 = getelementptr inbounds i8, i8* %3, i64 216
  %18 = bitcast i8* %17 to i8**
  store i8* %1, i8** %18, align 8, !tbaa !32
  %19 = getelementptr inbounds i8, i8* %3, i64 1600
  %20 = getelementptr inbounds i8, i8* %3, i64 464
  %21 = bitcast i8* %20 to i8**
  call void @llvm.memset.p0i8.i64(i8* nonnull %19, i8 0, i64 16, i32 8, i1 false)
  store i8* %6, i8** %21, align 8, !tbaa !27
  %22 = tail call fastcc i32 @luai_makeseed(%struct.lua_State* nonnull %7)
  %23 = getelementptr inbounds i8, i8* %3, i64 304
  %24 = bitcast i8* %23 to i32*
  store i32 %22, i32* %24, align 8, !tbaa !59
  %25 = getelementptr inbounds i8, i8* %3, i64 313
  store i8 0, i8* %25, align 1, !tbaa !28
  %26 = getelementptr inbounds i8, i8* %3, i64 256
  %27 = getelementptr inbounds i8, i8* %3, i64 280
  store i8 0, i8* %27, align 8, !tbaa !60
  %28 = getelementptr inbounds i8, i8* %3, i64 456
  %29 = bitcast i8* %28 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %29, align 8, !tbaa !61
  %30 = getelementptr inbounds i8, i8* %3, i64 309
  call void @llvm.memset.p0i8.i64(i8* nonnull %26, i8 0, i64 16, i32 8, i1 false)
  store i8 8, i8* %30, align 1, !tbaa !62
  %31 = getelementptr inbounds i8, i8* %3, i64 310
  store i8 0, i8* %31, align 2, !tbaa !29
  %32 = getelementptr inbounds i8, i8* %3, i64 314
  store i8 0, i8* %32, align 2, !tbaa !63
  %33 = getelementptr inbounds i8, i8* %3, i64 328
  %34 = getelementptr inbounds i8, i8* %3, i64 224
  %35 = bitcast i8* %34 to i64*
  call void @llvm.memset.p0i8.i64(i8* nonnull %33, i8 0, i64 128, i32 8, i1 false)
  store i64 1616, i64* %35, align 8, !tbaa !64
  %36 = getelementptr inbounds i8, i8* %3, i64 232
  %37 = bitcast i8* %36 to i64*
  store i64 0, i64* %37, align 8, !tbaa !11
  %38 = getelementptr inbounds i8, i8* %3, i64 248
  %39 = bitcast i8* %38 to i64*
  store i64 0, i64* %39, align 8, !tbaa !30
  %40 = getelementptr inbounds i8, i8* %3, i64 288
  %41 = bitcast i8* %40 to i64*
  store i64 0, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds i8, i8* %3, i64 296
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = getelementptr inbounds i8, i8* %3, i64 315
  store i8 50, i8* %43, align 1, !tbaa !65
  %44 = getelementptr inbounds i8, i8* %3, i64 316
  store i8 25, i8* %44, align 4, !tbaa !66
  %45 = getelementptr inbounds i8, i8* %3, i64 317
  store i8 13, i8* %45, align 1, !tbaa !67
  %46 = getelementptr inbounds i8, i8* %3, i64 312
  store i8 25, i8* %46, align 8, !tbaa !68
  %47 = getelementptr inbounds i8, i8* %3, i64 311
  store i8 20, i8* %47, align 1, !tbaa !69
  %48 = getelementptr inbounds i8, i8* %3, i64 680
  call void @llvm.memset.p0i8.i64(i8* nonnull %48, i8 0, i64 72, i32 8, i1 false)
  %49 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %7, void (%struct.lua_State*, i8*)* nonnull @f_luaopen, i8* null)
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %52, label %51

; <label>:51:                                     ; preds = %5
  tail call fastcc void @close_state(%struct.lua_State* nonnull %7)
  br label %52

; <label>:52:                                     ; preds = %51, %5, %2
  %53 = phi %struct.lua_State* [ null, %2 ], [ null, %51 ], [ %7, %5 ]
  ret %struct.lua_State* %53
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luai_makeseed(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca [24 x i8], align 16
  %3 = alloca i32, align 4
  %4 = getelementptr inbounds [24 x i8], [24 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = tail call i64 @time(i64* null) #7
  %7 = trunc i64 %6 to i32
  store i32 %7, i32* %3, align 4, !tbaa !70
  %8 = ptrtoint %struct.lua_State* %0 to i64
  %9 = bitcast [24 x i8]* %2 to i64*
  store i64 %8, i64* %9, align 16
  %10 = ptrtoint i32* %3 to i64
  %11 = getelementptr inbounds [24 x i8], [24 x i8]* %2, i64 0, i64 8
  %12 = bitcast i8* %11 to i64*
  store i64 %10, i64* %12, align 8
  %13 = getelementptr inbounds [24 x i8], [24 x i8]* %2, i64 0, i64 16
  %14 = bitcast i8* %13 to i64*
  store i64 ptrtoint (%struct.lua_State* (i8* (i8*, i8*, i64, i64)*, i8*)* @lua_newstate to i64), i64* %14, align 16
  %15 = call fastcc i32 @luaS_hash(i8* nonnull %4, i64 24, i32 %7)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_rawrunprotected(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*) unnamed_addr #0 {
  %4 = alloca %struct.lua_longjmp, align 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %6 = load i32, i32* %5, align 8, !tbaa !40
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %8 = load i16, i16* %7, align 4, !tbaa !36
  %9 = zext i16 %8 to i32
  %10 = sub i32 %6, %9
  %11 = bitcast %struct.lua_longjmp* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 216, i8* nonnull %11) #7
  %12 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 0, i32* %12, align 8, !tbaa !71
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %14 = bitcast %struct.lua_longjmp** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !39
  %16 = bitcast %struct.lua_longjmp* %4 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !73
  store %struct.lua_longjmp* %4, %struct.lua_longjmp** %13, align 8, !tbaa !39
  %17 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  %18 = call i32 @_setjmp(%struct.__jmp_buf_tag* nonnull %17) #18
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %3
  call void %1(%struct.lua_State* nonnull %0, i8* %2) #7
  br label %21

; <label>:21:                                     ; preds = %20, %3
  %22 = load i64, i64* %16, align 8, !tbaa !73
  store i64 %22, i64* %14, align 8, !tbaa !39
  %23 = load i16, i16* %7, align 4, !tbaa !36
  %24 = zext i16 %23 to i32
  %25 = add i32 %10, %24
  store i32 %25, i32* %5, align 8, !tbaa !40
  %26 = load volatile i32, i32* %12, align 8, !tbaa !71
  call void @llvm.lifetime.end.p0i8(i64 216, i8* nonnull %11) #7
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal void @f_luaopen(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  tail call fastcc void @stack_init(%struct.lua_State* %0, %struct.lua_State* %0)
  tail call fastcc void @init_registry(%struct.lua_State* %0, %struct.global_State* %4)
  tail call fastcc void @luaS_init(%struct.lua_State* %0)
  tail call fastcc void @luaT_init(%struct.lua_State* %0)
  tail call fastcc void @luaX_init(%struct.lua_State* %0)
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 15
  store i8 1, i8* %5, align 1, !tbaa !28
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 8, i32 1
  store i8 0, i8* %6, align 8, !tbaa !74
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @close_state(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !34
  %6 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %5, i32 -2)
  tail call fastcc void @luaC_freeallobjects(%struct.lua_State* %0)
  %7 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6
  %9 = bitcast %struct.stringtable* %8 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !75
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !76
  %13 = sext i32 %12 to i64
  %14 = shl nsw i64 %13, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %10, i64 %14)
  tail call fastcc void @freestack(%struct.lua_State* %0)
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 0
  %16 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %15, align 8, !tbaa !31
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 1
  %18 = load i8*, i8** %17, align 8, !tbaa !32
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 -1, i32 23
  %20 = bitcast i32* %19 to i8*
  %21 = tail call i8* %16(i8* %18, i8* nonnull %20, i64 1616, i64 0) #7
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_close(%struct.lua_State* nocapture readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !27
  tail call fastcc void @close_state(%struct.lua_State* %5)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_sethook(%struct.lua_State*, void (%struct.lua_State*, %struct.lua_Debug*)*, i32, i32) local_unnamed_addr #2 {
  %5 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %1, null
  %6 = icmp eq i32 %2, 0
  %7 = or i1 %5, %6
  %8 = select i1 %7, i32 0, i32 %2
  %9 = select i1 %7, void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)* %1
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !35
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 7
  %13 = load i16, i16* %12, align 2, !tbaa !46
  %14 = and i16 %13, 2
  %15 = icmp eq i16 %14, 0
  br i1 %15, label %16, label %22

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 4
  %18 = bitcast %union.anon.0* %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %21 = bitcast i32** %20 to i64*
  store i64 %19, i64* %21, align 8, !tbaa !77
  br label %22

; <label>:22:                                     ; preds = %4, %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %9, void (%struct.lua_State*, %struct.lua_Debug*)** %23, align 8, !tbaa !25
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  store i32 %3, i32* %24, align 8, !tbaa !24
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  store i32 %3, i32* %25, align 4, !tbaa !26
  %26 = and i32 %8, 255
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  store i32 %26, i32* %27, align 8, !tbaa !23
  %28 = icmp eq i32 %8, 0
  br i1 %28, label %30, label %29

; <label>:29:                                     ; preds = %22
  tail call fastcc void @settraps(%struct.CallInfo* %11)
  br label %30

; <label>:30:                                     ; preds = %22, %29
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @settraps(%struct.CallInfo*) unnamed_addr #2 {
  %2 = icmp eq %struct.CallInfo* %0, null
  br i1 %2, label %17, label %3

; <label>:3:                                      ; preds = %1
  br label %4

; <label>:4:                                      ; preds = %3, %13
  %5 = phi %struct.CallInfo* [ %15, %13 ], [ %0, %3 ]
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 7
  %7 = load i16, i16* %6, align 2, !tbaa !46
  %8 = and i16 %7, 2
  %9 = icmp eq i16 %8, 0
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 4, i32 0, i32 1
  %12 = bitcast i64* %11 to i32*
  store i32 1, i32* %12, align 8, !tbaa !21
  br label %13

; <label>:13:                                     ; preds = %4, %10
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 2
  %15 = load %struct.CallInfo*, %struct.CallInfo** %14, align 8, !tbaa !78
  %16 = icmp eq %struct.CallInfo* %15, null
  br i1 %16, label %17, label %4

; <label>:17:                                     ; preds = %13, %1
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void (%struct.lua_State*, %struct.lua_Debug*)* @lua_gethook(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %3 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %2, align 8, !tbaa !25
  ret void (%struct.lua_State*, %struct.lua_Debug*)* %3
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_gethookmask(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %3 = load i32, i32* %2, align 8, !tbaa !23
  ret i32 %3
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_gethookcount(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %3 = load i32, i32* %2, align 8, !tbaa !24
  ret i32 %3
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_getstack(%struct.lua_State* readonly, i32, %struct.lua_Debug* nocapture) local_unnamed_addr #2 {
  %4 = icmp slt i32 %1, 0
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !79
  %8 = icmp ne i32 %1, 0
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %10 = icmp ne %struct.CallInfo* %7, %9
  %11 = and i1 %8, %10
  br i1 %11, label %12, label %22

; <label>:12:                                     ; preds = %5
  br label %13

; <label>:13:                                     ; preds = %12, %13
  %14 = phi %struct.CallInfo* [ %18, %13 ], [ %7, %12 ]
  %15 = phi i32 [ %16, %13 ], [ %1, %12 ]
  %16 = add nsw i32 %15, -1
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %14, i64 0, i32 2
  %18 = load %struct.CallInfo*, %struct.CallInfo** %17, align 8, !tbaa !79
  %19 = icmp sgt i32 %15, 1
  %20 = icmp ne %struct.CallInfo* %18, %9
  %21 = and i1 %19, %20
  br i1 %21, label %13, label %22

; <label>:22:                                     ; preds = %13, %5
  %23 = phi i32 [ %1, %5 ], [ %16, %13 ]
  %24 = phi %struct.CallInfo* [ %7, %5 ], [ %18, %13 ]
  %25 = icmp ne i32 %23, 0
  %26 = icmp eq %struct.CallInfo* %24, %9
  %27 = or i1 %25, %26
  br i1 %27, label %30, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %24, %struct.CallInfo** %29, align 8, !tbaa !80
  br label %30

; <label>:30:                                     ; preds = %28, %22, %3
  %31 = phi i32 [ 0, %3 ], [ 1, %28 ], [ 0, %22 ]
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i8* @lua_getlocal(%struct.lua_State* nocapture, %struct.lua_Debug* readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = icmp eq %struct.lua_Debug* %1, null
  br i1 %5, label %6, label %19

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !21
  %11 = icmp eq i8 %10, 86
  br i1 %11, label %12, label %40

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 0, i32 0
  %14 = bitcast %struct.GCObject** %13 to %struct.LClosure**
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %17, i32 %2, i32 0)
  br label %40

; <label>:19:                                     ; preds = %3
  %20 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !79
  %21 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %22 = load %struct.CallInfo*, %struct.CallInfo** %21, align 8, !tbaa !80
  %23 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %22, i32 %2, %union.StackValue** nonnull %4)
  %24 = icmp eq i8* %23, null
  br i1 %24, label %39, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %union.StackValue** %4 to %struct.TValue**
  %30 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !79
  %31 = bitcast %struct.TValue* %30 to i64*
  %32 = bitcast %struct.TValue* %28 to i64*
  %33 = load i64, i64* %31, align 8
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !22
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %26, align 8, !tbaa !20
  br label %39

; <label>:39:                                     ; preds = %19, %25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %40

; <label>:40:                                     ; preds = %6, %12, %39
  %41 = phi i8* [ %18, %12 ], [ %23, %39 ], [ null, %6 ]
  ret i8* %41
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i8* @luaF_getlocalname(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %5 = load i32, i32* %4, align 4, !tbaa !82
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %35

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %9 = load %struct.LocVar*, %struct.LocVar** %8, align 8, !tbaa !84
  br label %10

; <label>:10:                                     ; preds = %7, %29
  %11 = phi i64 [ 0, %7 ], [ %31, %29 ]
  %12 = phi i32 [ %1, %7 ], [ %30, %29 ]
  %13 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %11, i32 1
  %14 = load i32, i32* %13, align 8, !tbaa !85
  %15 = icmp sgt i32 %14, %2
  br i1 %15, label %35, label %16

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %11, i32 2
  %18 = load i32, i32* %17, align 4, !tbaa !87
  %19 = icmp sgt i32 %18, %2
  br i1 %19, label %20, label %29

; <label>:20:                                     ; preds = %16
  %21 = add nsw i32 %12, -1
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %29

; <label>:23:                                     ; preds = %20
  %24 = and i64 %11, 4294967295
  %25 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %24, i32 0
  %26 = bitcast %struct.TString** %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !88
  %28 = getelementptr inbounds i8, i8* %27, i64 24
  br label %35

; <label>:29:                                     ; preds = %16, %20
  %30 = phi i32 [ %21, %20 ], [ %12, %16 ]
  %31 = add nuw nsw i64 %11, 1
  %32 = load i32, i32* %4, align 4, !tbaa !82
  %33 = sext i32 %32 to i64
  %34 = icmp slt i64 %31, %33
  br i1 %34, label %10, label %35

; <label>:35:                                     ; preds = %10, %29, %3, %23
  %36 = phi i8* [ %28, %23 ], [ null, %3 ], [ null, %29 ], [ null, %10 ]
  ret i8* %36
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @luaG_findlocal(%struct.lua_State* nocapture readonly, %struct.CallInfo* readonly, i32, %union.StackValue**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !47
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !46
  %10 = and i16 %9, 2
  %11 = icmp eq i16 %10, 0
  br i1 %11, label %12, label %25

; <label>:12:                                     ; preds = %4
  %13 = icmp slt i32 %2, 0
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %12
  %15 = sub nsw i32 0, %2
  %16 = tail call fastcc i8* @findvararg(%struct.CallInfo* nonnull %1, i32 %15, %union.StackValue** %3)
  br label %55

; <label>:17:                                     ; preds = %12
  %18 = bitcast %union.StackValue* %6 to %struct.LClosure**
  %19 = load %struct.LClosure*, %struct.LClosure** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %19, i64 0, i32 5
  %21 = load %struct.Proto*, %struct.Proto** %20, align 8, !tbaa !21
  %22 = tail call fastcc i32 @currentpc(%struct.CallInfo* nonnull %1)
  %23 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %21, i32 %2, i32 %22)
  %24 = icmp eq i8* %23, null
  br i1 %24, label %25, label %48

; <label>:25:                                     ; preds = %4, %17
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %27 = load %struct.CallInfo*, %struct.CallInfo** %26, align 8, !tbaa !35
  %28 = icmp eq %struct.CallInfo* %27, %1
  br i1 %28, label %29, label %31

; <label>:29:                                     ; preds = %25
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %35

; <label>:31:                                     ; preds = %25
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 3
  %33 = load %struct.CallInfo*, %struct.CallInfo** %32, align 8, !tbaa !89
  %34 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %33, i64 0, i32 0
  br label %35

; <label>:35:                                     ; preds = %31, %29
  %36 = phi %union.StackValue** [ %30, %29 ], [ %34, %31 ]
  %37 = bitcast %union.StackValue** %36 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !79
  %39 = ptrtoint %union.StackValue* %7 to i64
  %40 = sub i64 %38, %39
  %41 = ashr exact i64 %40, 4
  %42 = sext i32 %2 to i64
  %43 = icmp sge i64 %41, %42
  %44 = icmp sgt i32 %2, 0
  %45 = and i1 %44, %43
  br i1 %45, label %46, label %55

; <label>:46:                                     ; preds = %35
  %47 = select i1 %11, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.142, i64 0, i64 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.143, i64 0, i64 0)
  br label %48

; <label>:48:                                     ; preds = %46, %17
  %49 = phi i8* [ %23, %17 ], [ %47, %46 ]
  %50 = icmp eq %union.StackValue** %3, null
  br i1 %50, label %55, label %51

; <label>:51:                                     ; preds = %48
  %52 = add nsw i32 %2, -1
  %53 = sext i32 %52 to i64
  %54 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %53
  store %union.StackValue* %54, %union.StackValue** %3, align 8, !tbaa !79
  br label %55

; <label>:55:                                     ; preds = %35, %51, %48, %14
  %56 = phi i8* [ %16, %14 ], [ %49, %48 ], [ %49, %51 ], [ null, %35 ]
  ret i8* %56
}

; Function Attrs: nounwind uwtable
define i8* @lua_setlocal(%struct.lua_State* nocapture, %struct.lua_Debug* nocapture readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !79
  %6 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !80
  %8 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %7, i32 %2, %union.StackValue** nonnull %4)
  %9 = icmp eq i8* %8, null
  br i1 %9, label %24, label %10

; <label>:10:                                     ; preds = %3
  %11 = bitcast %union.StackValue** %4 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !79
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0
  %16 = bitcast %struct.TValue* %15 to i64*
  %17 = bitcast %struct.TValue* %12 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1
  store %union.StackValue* %23, %union.StackValue** %13, align 8, !tbaa !20
  br label %24

; <label>:24:                                     ; preds = %3, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %8
}

; Function Attrs: nounwind uwtable
define i32 @lua_getinfo(%struct.lua_State*, i8* readonly, %struct.lua_Debug* nocapture) local_unnamed_addr #0 {
  %4 = load i8, i8* %1, align 1, !tbaa !21
  %5 = icmp eq i8 %4, 62
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %10 = getelementptr inbounds i8, i8* %1, i64 1
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1
  store %union.StackValue* %11, %union.StackValue** %7, align 8, !tbaa !20
  br label %17

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  %14 = load %struct.CallInfo*, %struct.CallInfo** %13, align 8, !tbaa !80
  %15 = bitcast %struct.CallInfo* %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !47
  br label %17

; <label>:17:                                     ; preds = %12, %6
  %18 = phi %struct.TValue* [ %9, %6 ], [ %16, %12 ]
  %19 = phi %struct.CallInfo* [ null, %6 ], [ %14, %12 ]
  %20 = phi i8* [ %10, %6 ], [ %1, %12 ]
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = and i8 %22, 31
  %24 = icmp eq i8 %23, 22
  br i1 %24, label %25, label %28

; <label>:25:                                     ; preds = %17
  %26 = bitcast %struct.TValue* %18 to %union.Closure**
  %27 = load %union.Closure*, %union.Closure** %26, align 8, !tbaa !21
  br label %28

; <label>:28:                                     ; preds = %17, %25
  %29 = phi %union.Closure* [ %27, %25 ], [ null, %17 ]
  %30 = tail call fastcc i32 @auxgetinfo(%struct.lua_State* %0, i8* nonnull %20, %struct.lua_Debug* %2, %union.Closure* %29, %struct.CallInfo* %19)
  %31 = tail call i8* @strchr(i8* nonnull %20, i32 102) #19
  %32 = icmp eq i8* %31, null
  br i1 %32, label %44, label %33

; <label>:33:                                     ; preds = %28
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %35 = bitcast %union.StackValue** %34 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !20
  %37 = bitcast %struct.TValue* %18 to i64*
  %38 = bitcast %struct.TValue* %36 to i64*
  %39 = load i64, i64* %37, align 8
  store i64 %39, i64* %38, align 8
  %40 = load i8, i8* %21, align 8, !tbaa !22
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  store i8 %40, i8* %41, align 8, !tbaa !22
  %42 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 1
  store %union.StackValue* %43, %union.StackValue** %34, align 8, !tbaa !20
  br label %44

; <label>:44:                                     ; preds = %28, %33
  %45 = tail call i8* @strchr(i8* nonnull %20, i32 76) #19
  %46 = icmp eq i8* %45, null
  br i1 %46, label %48, label %47

; <label>:47:                                     ; preds = %44
  tail call fastcc void @collectvalidlines(%struct.lua_State* %0, %union.Closure* %29)
  br label %48

; <label>:48:                                     ; preds = %44, %47
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @auxgetinfo(%struct.lua_State* nocapture readonly, i8* nocapture readonly, %struct.lua_Debug* nocapture, %union.Closure* readonly, %struct.CallInfo*) unnamed_addr #0 {
  %6 = load i8, i8* %1, align 1, !tbaa !21
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %93, label %8

; <label>:8:                                      ; preds = %5
  %9 = icmp eq %struct.CallInfo* %4, null
  %10 = icmp eq %union.Closure* %3, null
  %11 = icmp eq %struct.CallInfo* %4, null
  %12 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %13 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %14 = icmp eq %struct.CallInfo* %4, null
  %15 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %17 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %18 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %19 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %20 = getelementptr inbounds %union.Closure, %union.Closure* %3, i64 0, i32 0, i32 3
  %21 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %22 = getelementptr inbounds %union.Closure, %union.Closure* %3, i64 0, i32 0, i32 1
  %23 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %25 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %26 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %28 = getelementptr inbounds %union.Closure, %union.Closure* %3, i64 0, i32 0, i32 5
  %29 = bitcast i32 (%struct.lua_State*)** %28 to %struct.Proto**
  %30 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %31 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 5
  %33 = bitcast %union.anon.2* %32 to %struct.anon.3*
  %34 = bitcast %union.anon.2* %32 to i16*
  %35 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %36 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %33, i64 0, i32 1
  %37 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  br label %38

; <label>:38:                                     ; preds = %8, %88
  %39 = phi i8 [ %6, %8 ], [ %91, %88 ]
  %40 = phi i32 [ 1, %8 ], [ %89, %88 ]
  %41 = phi i8* [ %1, %8 ], [ %90, %88 ]
  %42 = sext i8 %39 to i32
  switch i32 %42, label %87 [
    i32 83, label %43
    i32 108, label %44
    i32 117, label %53
    i32 116, label %67
    i32 110, label %74
    i32 114, label %78
    i32 76, label %88
    i32 102, label %88
  ]

; <label>:43:                                     ; preds = %38
  tail call fastcc void @funcinfo(%struct.lua_Debug* %2, %union.Closure* %3)
  br label %88

; <label>:44:                                     ; preds = %38
  br i1 %9, label %51, label %45

; <label>:45:                                     ; preds = %44
  %46 = load i16, i16* %16, align 2, !tbaa !46
  %47 = and i16 %46, 2
  %48 = icmp eq i16 %47, 0
  br i1 %48, label %49, label %51

; <label>:49:                                     ; preds = %45
  %50 = tail call fastcc i32 @currentline(%struct.CallInfo* nonnull %4)
  br label %51

; <label>:51:                                     ; preds = %45, %44, %49
  %52 = phi i32 [ %50, %49 ], [ -1, %45 ], [ -1, %44 ]
  store i32 %52, i32* %15, align 8, !tbaa !90
  br label %88

; <label>:53:                                     ; preds = %38
  br i1 %10, label %58, label %54

; <label>:54:                                     ; preds = %53
  %55 = load i8, i8* %20, align 2, !tbaa !21
  store i8 %55, i8* %21, align 4, !tbaa !91
  %56 = load i8, i8* %22, align 8, !tbaa !21
  %57 = icmp eq i8 %56, 54
  br i1 %57, label %59, label %60

; <label>:58:                                     ; preds = %53
  store i8 0, i8* %17, align 4, !tbaa !91
  br label %59

; <label>:59:                                     ; preds = %58, %54
  store i8 1, i8* %18, align 2, !tbaa !92
  store i8 0, i8* %19, align 1, !tbaa !93
  br label %88

; <label>:60:                                     ; preds = %54
  %61 = load %struct.Proto*, %struct.Proto** %29, align 8, !tbaa !21
  %62 = getelementptr inbounds %struct.Proto, %struct.Proto* %61, i64 0, i32 4
  %63 = load i8, i8* %62, align 1, !tbaa !94
  store i8 %63, i8* %30, align 2, !tbaa !92
  %64 = load %struct.Proto*, %struct.Proto** %29, align 8, !tbaa !21
  %65 = getelementptr inbounds %struct.Proto, %struct.Proto* %64, i64 0, i32 3
  %66 = load i8, i8* %65, align 2, !tbaa !95
  store i8 %66, i8* %31, align 1, !tbaa !93
  br label %88

; <label>:67:                                     ; preds = %38
  br i1 %11, label %72, label %68

; <label>:68:                                     ; preds = %67
  %69 = load i16, i16* %24, align 2, !tbaa !46
  %70 = trunc i16 %69 to i8
  %71 = and i8 %70, 16
  br label %72

; <label>:72:                                     ; preds = %67, %68
  %73 = phi i8 [ %71, %68 ], [ 0, %67 ]
  store i8 %73, i8* %23, align 1, !tbaa !96
  br label %88

; <label>:74:                                     ; preds = %38
  %75 = tail call fastcc i8* @getfuncname(%struct.lua_State* %0, %struct.CallInfo* %4, i8** nonnull %12)
  store i8* %75, i8** %13, align 8, !tbaa !97
  %76 = icmp eq i8* %75, null
  br i1 %76, label %77, label %88

; <label>:77:                                     ; preds = %74
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i8** %13, align 8, !tbaa !97
  store i8* null, i8** %12, align 8, !tbaa !98
  br label %88

; <label>:78:                                     ; preds = %38
  br i1 %14, label %83, label %79

; <label>:79:                                     ; preds = %78
  %80 = load i16, i16* %27, align 2, !tbaa !46
  %81 = trunc i16 %80 to i8
  %82 = icmp slt i8 %81, 0
  br i1 %82, label %84, label %83

; <label>:83:                                     ; preds = %79, %78
  store i16 0, i16* %25, align 2, !tbaa !99
  store i16 0, i16* %26, align 8, !tbaa !100
  br label %88

; <label>:84:                                     ; preds = %79
  %85 = load i16, i16* %34, align 8, !tbaa !21
  store i16 %85, i16* %35, align 8, !tbaa !100
  %86 = load i16, i16* %36, align 2, !tbaa !21
  store i16 %86, i16* %37, align 2, !tbaa !99
  br label %88

; <label>:87:                                     ; preds = %38
  br label %88

; <label>:88:                                     ; preds = %43, %51, %72, %87, %60, %59, %77, %74, %83, %84, %38, %38
  %89 = phi i32 [ 0, %87 ], [ %40, %38 ], [ %40, %38 ], [ %40, %83 ], [ %40, %84 ], [ %40, %77 ], [ %40, %74 ], [ %40, %72 ], [ %40, %59 ], [ %40, %60 ], [ %40, %51 ], [ %40, %43 ]
  %90 = getelementptr inbounds i8, i8* %41, i64 1
  %91 = load i8, i8* %90, align 1, !tbaa !21
  %92 = icmp eq i8 %91, 0
  br i1 %92, label %93, label %38

; <label>:93:                                     ; preds = %88, %5
  %94 = phi i32 [ 1, %5 ], [ %89, %88 ]
  ret i32 %94
}

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc void @collectvalidlines(%struct.lua_State*, %union.Closure* readonly) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = icmp eq %union.Closure* %1, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %union.Closure, %union.Closure* %1, i64 0, i32 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !21
  %8 = icmp eq i8 %7, 54
  br i1 %8, label %9, label %16

; <label>:9:                                      ; preds = %5, %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %10, align 8, !tbaa !20
  br label %46

; <label>:16:                                     ; preds = %5
  %17 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %17) #7
  %18 = getelementptr inbounds %union.Closure, %union.Closure* %1, i64 0, i32 0, i32 5
  %19 = bitcast i32 (%struct.lua_State*)** %18 to %struct.Proto**
  %20 = load %struct.Proto*, %struct.Proto** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %20, i64 0, i32 13
  %22 = load i32, i32* %21, align 4, !tbaa !101
  %23 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %25 = bitcast %union.StackValue** %24 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %27 = bitcast %struct.TValue* %26 to %struct.Table**
  store %struct.Table* %23, %struct.Table** %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 69, i8* %28, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %24, align 8, !tbaa !20
  %31 = bitcast %struct.TValue* %3 to i32*
  store i32 1, i32* %31, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 1, i8* %32, align 8, !tbaa !22
  %33 = getelementptr inbounds %struct.Proto, %struct.Proto* %20, i64 0, i32 9
  %34 = load i32, i32* %33, align 4, !tbaa !102
  %35 = icmp sgt i32 %34, 0
  br i1 %35, label %36, label %45

; <label>:36:                                     ; preds = %16
  br label %37

; <label>:37:                                     ; preds = %36, %37
  %38 = phi i32 [ %42, %37 ], [ 0, %36 ]
  %39 = phi i32 [ %40, %37 ], [ %22, %36 ]
  %40 = tail call fastcc i32 @nextline(%struct.Proto* nonnull %20, i32 %39, i32 %38)
  %41 = sext i32 %40 to i64
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %23, i64 %41, %struct.TValue* nonnull %3)
  %42 = add nuw nsw i32 %38, 1
  %43 = load i32, i32* %33, align 4, !tbaa !102
  %44 = icmp slt i32 %42, %43
  br i1 %44, label %37, label %45

; <label>:45:                                     ; preds = %37, %16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %17) #7
  br label %46

; <label>:46:                                     ; preds = %45, %9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_resume(%struct.lua_State*, %struct.lua_State* readonly, i32, i32* nocapture) local_unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  store i32 %2, i32* %5, align 4, !tbaa !70
  %7 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %9 = load i8, i8* %8, align 2, !tbaa !43
  switch i8 %9, label %16 [
    i8 0, label %10
    i8 1, label %17
  ]

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !35
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %14 = icmp eq %struct.CallInfo* %12, %13
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %10
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str, i64 0, i64 0), i32 %2)
  br label %86

; <label>:16:                                     ; preds = %4
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0), i32 %2)
  br label %86

; <label>:17:                                     ; preds = %4, %10
  %18 = icmp eq %struct.lua_State* %1, null
  br i1 %18, label %32, label %19

; <label>:19:                                     ; preds = %17
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 19
  %21 = load i32, i32* %20, align 8, !tbaa !40
  %22 = and i32 %21, 65535
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 5
  %24 = load i16, i16* %23, align 4, !tbaa !36
  %25 = zext i16 %24 to i32
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %27 = load i16, i16* %26, align 4, !tbaa !36
  %28 = zext i16 %27 to i32
  %29 = add nuw nsw i32 %22, 10
  %30 = sub nsw i32 %29, %25
  %31 = add nsw i32 %30, %28
  br label %32

; <label>:32:                                     ; preds = %17, %19
  %33 = phi i32 [ %31, %19 ], [ 1, %17 ]
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 %33, i32* %34, align 8, !tbaa !40
  %35 = icmp ugt i32 %33, 2199
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %32
  tail call fastcc void @resume_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0), i32 %2)
  br label %86

; <label>:37:                                     ; preds = %32
  %38 = bitcast i32* %5 to i8*
  %39 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @resume, i8* nonnull %38)
  store i32 %39, i32* %6, align 4, !tbaa !70
  %40 = icmp sgt i32 %39, 1
  br i1 %40, label %41, label %63

; <label>:41:                                     ; preds = %37
  br label %42

; <label>:42:                                     ; preds = %41, %46
  %43 = phi i32 [ %47, %46 ], [ %39, %41 ]
  %44 = call fastcc i32 @recover(%struct.lua_State* %0, i32 %43)
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %49, label %46

; <label>:46:                                     ; preds = %42
  %47 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @unroll, i8* nonnull %7)
  store i32 %47, i32* %6, align 4, !tbaa !70
  %48 = icmp sgt i32 %47, 1
  br i1 %48, label %42, label %63

; <label>:49:                                     ; preds = %42
  %50 = load i32, i32* %6, align 4, !tbaa !70
  %51 = icmp slt i32 %50, 2
  br i1 %51, label %63, label %52, !prof !103

; <label>:52:                                     ; preds = %49
  %53 = trunc i32 %50 to i8
  store i8 %53, i8* %8, align 2, !tbaa !43
  %54 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %55 = load %union.StackValue*, %union.StackValue** %54, align 8, !tbaa !20
  call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %50, %union.StackValue* %55)
  %56 = bitcast %union.StackValue** %54 to i64*
  %57 = load i64, i64* %56, align 8, !tbaa !20
  %58 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %59 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !35
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 1
  %61 = bitcast %union.StackValue** %60 to i64*
  store i64 %57, i64* %61, align 8, !tbaa !49
  %62 = load i32, i32* %6, align 4, !tbaa !70
  br label %63

; <label>:63:                                     ; preds = %46, %37, %49, %52
  %64 = phi i32 [ %50, %49 ], [ %62, %52 ], [ %39, %37 ], [ %47, %46 ]
  %65 = icmp eq i32 %64, 1
  br i1 %65, label %66, label %71

; <label>:66:                                     ; preds = %63
  %67 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %68 = load %struct.CallInfo*, %struct.CallInfo** %67, align 8, !tbaa !35
  %69 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %68, i64 0, i32 5, i32 0
  %70 = load i32, i32* %69, align 8, !tbaa !21
  br label %84

; <label>:71:                                     ; preds = %63
  %72 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %73 = bitcast %union.StackValue** %72 to i64*
  %74 = load i64, i64* %73, align 8, !tbaa !20
  %75 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %76 = load %struct.CallInfo*, %struct.CallInfo** %75, align 8, !tbaa !35
  %77 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %76, i64 0, i32 0
  %78 = load %union.StackValue*, %union.StackValue** %77, align 8, !tbaa !47
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 1
  %80 = ptrtoint %union.StackValue* %79 to i64
  %81 = sub i64 %74, %80
  %82 = lshr exact i64 %81, 4
  %83 = trunc i64 %82 to i32
  br label %84

; <label>:84:                                     ; preds = %71, %66
  %85 = phi i32 [ %70, %66 ], [ %83, %71 ]
  store i32 %85, i32* %3, align 4, !tbaa !70
  br label %86

; <label>:86:                                     ; preds = %84, %36, %16, %15
  %87 = phi i32 [ 2, %15 ], [ 2, %36 ], [ %64, %84 ], [ 2, %16 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  ret i32 %87
}

; Function Attrs: nounwind uwtable
define internal fastcc void @resume_error(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = sext i32 %2 to i64
  %7 = sub nsw i64 0, %6
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 %7
  store %union.StackValue* %8, %union.StackValue** %4, align 8, !tbaa !20
  %9 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %1)
  %10 = bitcast %union.StackValue* %8 to %struct.TString**
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !57
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 %7, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @resume(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !70
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %8 = load i8, i8* %7, align 2, !tbaa !43
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = sext i32 %4 to i64
  %14 = sub nsw i64 0, %13
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 %14
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %16, i32 -1)
  br label %34

; <label>:17:                                     ; preds = %2
  store i8 0, i8* %7, align 2, !tbaa !43
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %19 = load i16, i16* %18, align 2, !tbaa !46
  %20 = and i16 %19, 2
  %21 = icmp eq i16 %20, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6)
  br label %33

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  %25 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %24, align 8, !tbaa !21
  %26 = icmp eq i32 (%struct.lua_State*, i32, i64)* %25, null
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %23
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %25(%struct.lua_State* nonnull %0, i32 1, i64 %29) #7
  br label %31

; <label>:31:                                     ; preds = %23, %27
  %32 = phi i32 [ %30, %27 ], [ %4, %23 ]
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6, i32 %32)
  br label %33

; <label>:33:                                     ; preds = %31, %22
  tail call void @unroll(%struct.lua_State* nonnull %0, i8* null)
  br label %34

; <label>:34:                                     ; preds = %33, %10
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @recover(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call fastcc %struct.CallInfo* @findpcall(%struct.lua_State* %0)
  %4 = icmp eq %struct.CallInfo* %3, null
  br i1 %4, label %29, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !34
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 5, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i8, i8* %8, i64 %11
  %13 = bitcast i8* %12 to %union.StackValue*
  %14 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %13, i32 %1)
  %15 = load i8*, i8** %7, align 8, !tbaa !34
  %16 = load i32, i32* %9, align 8, !tbaa !21
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i8, i8* %15, i64 %17
  %19 = bitcast i8* %18 to %union.StackValue*
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %1, %union.StackValue* %19)
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %3, %struct.CallInfo** %20, align 8, !tbaa !35
  %21 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 7
  %22 = load i16, i16* %21, align 2, !tbaa !46
  %23 = trunc i16 %22 to i8
  %24 = and i8 %23, 1
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  store i8 %24, i8* %25, align 1, !tbaa !41
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* %0)
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 4, i32 0, i32 1
  %27 = load i64, i64* %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 %27, i64* %28, align 8, !tbaa !44
  br label %29

; <label>:29:                                     ; preds = %2, %5
  %30 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal void @unroll(%struct.lua_State*, i8* readonly) #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %7, label %4

; <label>:4:                                      ; preds = %2
  %5 = bitcast i8* %1 to i32*
  %6 = load i32, i32* %5, align 4, !tbaa !70
  tail call fastcc void @finishCcall(%struct.lua_State* %0, i32 %6)
  br label %7

; <label>:7:                                      ; preds = %2, %4
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !35
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %11 = icmp eq %struct.CallInfo* %9, %10
  br i1 %11, label %24, label %12

; <label>:12:                                     ; preds = %7
  br label %13

; <label>:13:                                     ; preds = %12, %21
  %14 = phi %struct.CallInfo* [ %22, %21 ], [ %9, %12 ]
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %14, i64 0, i32 7
  %16 = load i16, i16* %15, align 2, !tbaa !46
  %17 = and i16 %16, 2
  %18 = icmp eq i16 %17, 0
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %13
  tail call fastcc void @finishCcall(%struct.lua_State* nonnull %0, i32 1)
  br label %21

; <label>:20:                                     ; preds = %13
  tail call fastcc void @luaV_finishOp(%struct.lua_State* nonnull %0)
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %14)
  br label %21

; <label>:21:                                     ; preds = %20, %19
  %22 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !35
  %23 = icmp eq %struct.CallInfo* %22, %10
  br i1 %23, label %24, label %13

; <label>:24:                                     ; preds = %21, %7
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_isyieldable(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !40
  %4 = icmp ult i32 %3, 65536
  %5 = zext i1 %4 to i32
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @lua_yieldk(%struct.lua_State*, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %8 = load i32, i32* %7, align 8, !tbaa !40
  %9 = icmp ugt i32 %8, 65535
  br i1 %9, label %10, label %18, !prof !33

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 38
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !27
  %15 = icmp eq %struct.lua_State* %14, %0
  br i1 %15, label %17, label %16

; <label>:16:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3, i64 0, i64 0)) #17
  unreachable

; <label>:17:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.4, i64 0, i64 0)) #17
  unreachable

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 1, i8* %19, align 2, !tbaa !43
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %21 = load i16, i16* %20, align 2, !tbaa !46
  %22 = and i16 %21, 2
  %23 = icmp eq i16 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 0, i32* %25, align 8, !tbaa !21
  ret i32 0

; <label>:26:                                     ; preds = %18
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %3, i32 (%struct.lua_State*, i32, i64)** %27, align 8, !tbaa !21
  %28 = icmp eq i32 (%struct.lua_State*, i32, i64)* %3, null
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  store i64 %2, i64* %30, align 8, !tbaa !21
  br label %31

; <label>:31:                                     ; preds = %26, %29
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 %1, i32* %32, align 8, !tbaa !21
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal void @luaG_runerror(%struct.lua_State*, i8*, ...) unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !35
  %6 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %13

; <label>:13:                                     ; preds = %12, %2
  %14 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %6)
  %15 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* nonnull %0, i8* %1, %struct.__va_list_tag* nonnull %14)
  call void @llvm.va_end(i8* nonnull %6)
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 7
  %17 = load i16, i16* %16, align 2, !tbaa !46
  %18 = and i16 %17, 2
  %19 = icmp eq i16 %18, 0
  br i1 %19, label %20, label %30

; <label>:20:                                     ; preds = %13
  %21 = bitcast %struct.CallInfo* %5 to %struct.LClosure***
  %22 = load %struct.LClosure**, %struct.LClosure*** %21, align 8, !tbaa !47
  %23 = load %struct.LClosure*, %struct.LClosure** %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %23, i64 0, i32 5
  %25 = load %struct.Proto*, %struct.Proto** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %25, i64 0, i32 22
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !104
  %28 = call fastcc i32 @currentline(%struct.CallInfo* nonnull %5)
  %29 = call fastcc i8* @luaG_addinfo(%struct.lua_State* nonnull %0, i8* nonnull %15, %struct.TString* %27, i32 %28)
  br label %30

; <label>:30:                                     ; preds = %13, %20
  call fastcc void @luaG_errormsg(%struct.lua_State* nonnull %0) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaD_throw(%struct.lua_State*, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %4 = load %struct.lua_longjmp*, %struct.lua_longjmp** %3, align 8, !tbaa !39
  %5 = icmp eq %struct.lua_longjmp* %4, null
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 %1, i32* %7, align 8, !tbaa !71
  %8 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  tail call void @longjmp(%struct.__jmp_buf_tag* nonnull %8, i32 1) #20
  unreachable

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !34
  %14 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %13, i32 %1)
  %15 = trunc i32 %14 to i8
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %15, i8* %16, align 2, !tbaa !43
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 38
  %18 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !27
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 15
  %20 = load %struct.lua_longjmp*, %struct.lua_longjmp** %19, align 8, !tbaa !39
  %21 = icmp eq %struct.lua_longjmp* %20, null
  br i1 %21, label %36, label %22

; <label>:22:                                     ; preds = %9
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %23, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0
  %29 = bitcast %struct.TValue* %28 to i64*
  %30 = bitcast %union.StackValue* %24 to i64*
  %31 = load i64, i64* %29, align 8
  store i64 %31, i64* %30, align 8
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 0, i32 0, i32 1
  store i8 %33, i8* %34, align 8, !tbaa !22
  %35 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !27
  tail call fastcc void @luaD_throw(%struct.lua_State* %35, i32 %14) #17
  unreachable

; <label>:36:                                     ; preds = %9
  %37 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 37
  %38 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !61
  %39 = icmp eq i32 (%struct.lua_State*)* %38, null
  br i1 %39, label %53, label %40

; <label>:40:                                     ; preds = %36
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %42 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %14, %union.StackValue* %42)
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %44 = load %struct.CallInfo*, %struct.CallInfo** %43, align 8, !tbaa !35
  %45 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %44, i64 0, i32 1
  %46 = load %union.StackValue*, %union.StackValue** %45, align 8, !tbaa !49
  %47 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %48 = icmp ult %union.StackValue* %46, %47
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %40
  store %union.StackValue* %47, %union.StackValue** %45, align 8, !tbaa !49
  br label %50

; <label>:50:                                     ; preds = %49, %40
  %51 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !61
  %52 = tail call i32 %51(%struct.lua_State* nonnull %0) #7
  br label %53

; <label>:53:                                     ; preds = %36, %50
  tail call void @abort() #20
  unreachable
}

; Function Attrs: nounwind uwtable
define i32 @lua_checkstack(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !35
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !45
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = sub i64 %7, %10
  %12 = ashr exact i64 %11, 4
  %13 = sext i32 %1 to i64
  %14 = icmp sgt i64 %12, %13
  br i1 %14, label %28, label %15

; <label>:15:                                     ; preds = %2
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %17 = bitcast %union.StackValue** %16 to i64*
  %18 = load i64, i64* %17, align 8, !tbaa !34
  %19 = sub i64 %10, %18
  %20 = lshr exact i64 %19, 4
  %21 = trunc i64 %20 to i32
  %22 = add nsw i32 %21, 5
  %23 = sub nsw i32 1000000, %1
  %24 = icmp sgt i32 %22, %23
  br i1 %24, label %36, label %25

; <label>:25:                                     ; preds = %15
  %26 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %1, i32 0)
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %36, label %28

; <label>:28:                                     ; preds = %2, %25
  %29 = phi i32 [ %26, %25 ], [ 1, %2 ]
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !49
  %32 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 %13
  %34 = icmp ult %union.StackValue* %31, %33
  br i1 %34, label %35, label %36

; <label>:35:                                     ; preds = %28
  store %union.StackValue* %33, %union.StackValue** %30, align 8, !tbaa !49
  br label %36

; <label>:36:                                     ; preds = %15, %25, %35, %28
  %37 = phi i32 [ 0, %25 ], [ %29, %35 ], [ %29, %28 ], [ 0, %15 ]
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_growstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !37
  %6 = icmp sgt i32 %5, 1000000
  br i1 %6, label %7, label %10, !prof !33

; <label>:7:                                      ; preds = %3
  %8 = icmp eq i32 %2, 0
  br i1 %8, label %34, label %9

; <label>:9:                                      ; preds = %7
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #17
  unreachable

; <label>:10:                                     ; preds = %3
  %11 = shl nsw i32 %5, 1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %16 = bitcast %union.StackValue** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !34
  %18 = sub i64 %14, %17
  %19 = lshr exact i64 %18, 4
  %20 = trunc i64 %19 to i32
  %21 = add i32 %1, 5
  %22 = add i32 %21, %20
  %23 = icmp sgt i32 %5, 500000
  %24 = select i1 %23, i32 1000000, i32 %11
  %25 = icmp slt i32 %24, %22
  %26 = select i1 %25, i32 %22, i32 %24
  %27 = icmp sgt i32 %26, 1000000
  br i1 %27, label %28, label %32, !prof !33

; <label>:28:                                     ; preds = %10
  %29 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 1000200, i32 %2)
  %30 = icmp eq i32 %2, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #17
  unreachable

; <label>:32:                                     ; preds = %10
  %33 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %26, i32 %2)
  br label %34

; <label>:34:                                     ; preds = %28, %7, %32
  %35 = phi i32 [ %33, %32 ], [ 0, %7 ], [ 0, %28 ]
  ret i32 %35
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_xmove(%struct.lua_State*, %struct.lua_State*, i32) local_unnamed_addr #2 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %31, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = sext i32 %2 to i64
  %9 = sub nsw i64 0, %8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %9
  store %union.StackValue* %10, %union.StackValue** %6, align 8, !tbaa !20
  %11 = icmp sgt i32 %2, 0
  br i1 %11, label %12, label %31

; <label>:12:                                     ; preds = %5
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = zext i32 %2 to i64
  br label %16

; <label>:16:                                     ; preds = %16, %12
  %17 = phi i64 [ 0, %12 ], [ %29, %16 ]
  %18 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %19 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 %17, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %18 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 %17, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %13, align 8, !tbaa !20
  %29 = add nuw nsw i64 %17, 1
  %30 = icmp eq i64 %29, %15
  br i1 %30, label %31, label %16

; <label>:31:                                     ; preds = %16, %5, %3
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i32 (%struct.lua_State*)* @lua_atpanic(%struct.lua_State* nocapture readonly, i32 (%struct.lua_State*)*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 37
  %6 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %5, align 8, !tbaa !61
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %5, align 8, !tbaa !61
  ret i32 (%struct.lua_State*)* %6
}

; Function Attrs: norecurse nounwind readnone uwtable
define double @lua_version(%struct.lua_State* nocapture readnone) local_unnamed_addr #6 {
  ret double 5.040000e+02
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_absindex(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = add i32 %1, 1000999
  %4 = icmp ugt i32 %3, 1000999
  br i1 %4, label %17, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = bitcast %struct.CallInfo** %9 to i64**
  %11 = load i64*, i64** %10, align 8, !tbaa !35
  %12 = load i64, i64* %11, align 8, !tbaa !47
  %13 = sub i64 %8, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, %1
  br label %17

; <label>:17:                                     ; preds = %2, %5
  %18 = phi i32 [ %16, %5 ], [ %1, %2 ]
  ret i32 %18
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_gettop(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !47
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define void @lua_settop(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, -1
  br i1 %3, label %4, label %23

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !47
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = sext i32 %1 to i64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %10
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = icmp ult %union.StackValue* %13, %11
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %4
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi %union.StackValue* [ %20, %16 ], [ %13, %15 ]
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %12, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 0, i32 0, i32 1
  store i8 0, i8* %19, align 8, !tbaa !21
  %20 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %21 = icmp ult %union.StackValue* %20, %11
  br i1 %21, label %16, label %22

; <label>:22:                                     ; preds = %16, %4
  store %union.StackValue* %11, %union.StackValue** %12, align 8, !tbaa !20
  br label %29

; <label>:23:                                     ; preds = %2
  %24 = add nsw i32 %1, 1
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %26 = load %union.StackValue*, %union.StackValue** %25, align 8, !tbaa !20
  %27 = sext i32 %24 to i64
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 %27
  store %union.StackValue* %28, %union.StackValue** %25, align 8, !tbaa !20
  br label %29

; <label>:29:                                     ; preds = %23, %22
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %32 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %31, i32 0)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_rotate(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  %7 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %1)
  %8 = icmp sgt i32 %2, -1
  %9 = sext i32 %2 to i64
  %10 = sub nsw i64 0, %9
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %10
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %10
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 -1
  %14 = select i1 %8, %union.StackValue* %11, %union.StackValue* %13
  tail call fastcc void @reverse(%union.StackValue* %7, %union.StackValue* nonnull %14)
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  tail call fastcc void @reverse(%union.StackValue* nonnull %15, %union.StackValue* nonnull %6)
  tail call fastcc void @reverse(%union.StackValue* %7, %union.StackValue* nonnull %6)
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %union.StackValue* @index2stack(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %4, label %8

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  br label %10

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %10

; <label>:10:                                     ; preds = %8, %4
  %11 = phi %union.StackValue** [ %9, %8 ], [ %7, %4 ]
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !79
  %13 = sext i32 %1 to i64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 %13
  ret %union.StackValue* %14
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @reverse(%union.StackValue*, %union.StackValue*) unnamed_addr #2 {
  %3 = icmp ult %union.StackValue* %0, %1
  br i1 %3, label %4, label %19

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi %union.StackValue* [ %16, %5 ], [ %0, %4 ]
  %7 = phi %union.StackValue* [ %17, %5 ], [ %1, %4 ]
  %8 = bitcast %union.StackValue* %6 to i64*
  %9 = load i64, i64* %8, align 8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = bitcast %union.StackValue* %7 to i64*
  %13 = load i64, i64* %12, align 8
  store i64 %13, i64* %8, align 8
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  store i8 %15, i8* %10, align 8, !tbaa !22
  store i64 %9, i64* %12, align 8
  store i8 %11, i8* %14, align 8, !tbaa !22
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1
  %18 = icmp ult %union.StackValue* %16, %17
  br i1 %18, label %5, label %19

; <label>:19:                                     ; preds = %5, %2
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_copy(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2)
  %6 = bitcast %struct.TValue* %4 to i64*
  %7 = bitcast %struct.TValue* %5 to i64*
  %8 = load i64, i64* %6, align 8
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  %12 = icmp slt i32 %2, -1001000
  br i1 %12, label %13, label %36

; <label>:13:                                     ; preds = %3
  %14 = load i8, i8* %9, align 8, !tbaa !22
  %15 = and i8 %14, 64
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %36, label %17

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = bitcast %struct.CallInfo** %18 to %struct.CClosure****
  %20 = load %struct.CClosure***, %struct.CClosure**** %19, align 8, !tbaa !35
  %21 = load %struct.CClosure**, %struct.CClosure*** %20, align 8, !tbaa !47
  %22 = load %struct.CClosure*, %struct.CClosure** %21, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %22, i64 0, i32 2
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = and i8 %24, 32
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %36, label %27

; <label>:27:                                     ; preds = %17
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %29 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !53
  %32 = and i8 %31, 24
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %27
  %35 = bitcast %struct.CClosure* %22 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %35, %struct.GCObject* %29)
  br label %36

; <label>:36:                                     ; preds = %27, %17, %13, %34, %3
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.TValue* @index2value(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !35
  %5 = icmp sgt i32 %1, 0
  br i1 %5, label %6, label %20

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !47
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %9
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = icmp ult %union.StackValue* %10, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  br label %59

; <label>:18:                                     ; preds = %6
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  br label %59

; <label>:20:                                     ; preds = %2
  %21 = icmp slt i32 %1, -1000999
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %20
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = sext i32 %1 to i64
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %25, i32 0
  br label %59

; <label>:27:                                     ; preds = %20
  %28 = icmp eq i32 %1, -1001000
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %27
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %31 = load %struct.global_State*, %struct.global_State** %30, align 8, !tbaa !2
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %31, i64 0, i32 7
  br label %59

; <label>:33:                                     ; preds = %27
  %34 = sub nsw i32 -1001000, %1
  %35 = bitcast %struct.CallInfo* %4 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !47
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !21
  %39 = icmp eq i8 %38, 38
  br i1 %39, label %40, label %44

; <label>:40:                                     ; preds = %33
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %42 = load %struct.global_State*, %struct.global_State** %41, align 8, !tbaa !2
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %42, i64 0, i32 8
  br label %59

; <label>:44:                                     ; preds = %33
  %45 = bitcast %struct.TValue* %36 to %struct.CClosure**
  %46 = load %struct.CClosure*, %struct.CClosure** %45, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 3
  %48 = load i8, i8* %47, align 2, !tbaa !105
  %49 = zext i8 %48 to i32
  %50 = icmp sgt i32 %34, %49
  br i1 %50, label %55, label %51

; <label>:51:                                     ; preds = %44
  %52 = add nsw i32 %34, -1
  %53 = sext i32 %52 to i64
  %54 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 6, i64 %53
  br label %59

; <label>:55:                                     ; preds = %44
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %57 = load %struct.global_State*, %struct.global_State** %56, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 8
  br label %59

; <label>:59:                                     ; preds = %51, %55, %14, %18, %40, %29, %22
  %60 = phi %struct.TValue* [ %32, %29 ], [ %43, %40 ], [ %26, %22 ], [ %17, %14 ], [ %19, %18 ], [ %54, %51 ], [ %58, %55 ]
  ret %struct.TValue* %60
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_barrier_(%struct.lua_State* nocapture readonly, %struct.GCObject* nocapture, %struct.GCObject*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %7 = load i8, i8* %6, align 1, !tbaa !62
  %8 = icmp ult i8 %7, 3
  br i1 %8, label %9, label %18

; <label>:9:                                      ; preds = %3
  tail call fastcc void @reallymarkobject(%struct.global_State* %5, %struct.GCObject* %2)
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !53
  %12 = and i8 %11, 6
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %30, label %14

; <label>:14:                                     ; preds = %9
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !53
  %17 = and i8 %16, -8
  br label %25

; <label>:18:                                     ; preds = %3
  %19 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !53
  %21 = and i8 %20, -64
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %23 = load i8, i8* %22, align 4, !tbaa !15
  %24 = and i8 %23, 24
  br label %25

; <label>:25:                                     ; preds = %18, %14
  %26 = phi i8 [ 2, %14 ], [ %21, %18 ]
  %27 = phi i8 [ %17, %14 ], [ %24, %18 ]
  %28 = phi i8* [ %15, %14 ], [ %19, %18 ]
  %29 = or i8 %27, %26
  store i8 %29, i8* %28, align 1, !tbaa !53
  br label %30

; <label>:30:                                     ; preds = %25, %9
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushvalue(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_type(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 8
  %12 = icmp eq %struct.TValue* %3, %11
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %8, %2
  %14 = zext i8 %6 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %13
  %16 = phi i32 [ %14, %13 ], [ -1, %8 ]
  ret i32 %16
}

; Function Attrs: norecurse nounwind readnone uwtable
define i8* @lua_typename(%struct.lua_State* nocapture readnone, i32) local_unnamed_addr #6 {
  %3 = add nsw i32 %1, 1
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !79
  ret i8* %6
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_iscfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 38
  %7 = icmp eq i8 %5, 118
  %8 = or i1 %6, %7
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_isinteger(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 35
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @lua_isnumber(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #0 {
  %3 = alloca double, align 8
  %4 = bitcast double* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 19
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %5 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  %12 = bitcast double* %3 to i64*
  store i64 %11, i64* %12, align 8, !tbaa !107
  br label %15

; <label>:13:                                     ; preds = %2
  %14 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %5, double* nonnull %3)
  br label %15

; <label>:15:                                     ; preds = %13, %9
  %16 = phi i32 [ 1, %9 ], [ %14, %13 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_tonumber_(%struct.TValue* nocapture readonly, double* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 35
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %0 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !21
  %11 = sitofp i64 %10 to double
  store double %11, double* %1, align 8, !tbaa !107
  br label %45

; <label>:12:                                     ; preds = %2
  %13 = and i8 %6, 15
  %14 = icmp eq i8 %13, 4
  br i1 %14, label %15, label %45

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %0 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds i8, i8* %17, i64 24
  %19 = call fastcc i64 @luaO_str2num(i8* nonnull %18, %struct.TValue* nonnull %3)
  %20 = bitcast %struct.TValue* %0 to %struct.TString**
  %21 = load %struct.TString*, %struct.TString** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !21
  %24 = icmp eq i8 %23, 20
  br i1 %24, label %25, label %29

; <label>:25:                                     ; preds = %15
  %26 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 4
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = zext i8 %27 to i64
  br label %32

; <label>:29:                                     ; preds = %15
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 6, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %29, %25
  %33 = phi i64 [ %28, %25 ], [ %31, %29 ]
  %34 = add i64 %33, 1
  %35 = icmp eq i64 %19, %34
  br i1 %35, label %36, label %45

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 35
  %40 = bitcast %struct.TValue* %3 to i64*
  %41 = load i64, i64* %40, align 8
  %42 = sitofp i64 %41 to double
  %43 = bitcast i64 %41 to double
  %44 = select i1 %39, double %42, double %43
  store double %44, double* %1, align 8, !tbaa !107
  br label %45

; <label>:45:                                     ; preds = %12, %32, %36, %8
  %46 = phi i32 [ 1, %8 ], [ 1, %36 ], [ 0, %32 ], [ 0, %12 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %46
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_isstring(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_isuserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 7
  %8 = icmp eq i8 %5, 2
  %9 = or i1 %8, %7
  %10 = zext i1 %9 to i32
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define i32 @lua_rawequal(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2)
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  %14 = icmp eq %struct.TValue* %4, %13
  br i1 %14, label %27, label %15

; <label>:15:                                     ; preds = %10, %3
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %25

; <label>:20:                                     ; preds = %15
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 8
  %24 = icmp eq %struct.TValue* %5, %23
  br i1 %24, label %27, label %25

; <label>:25:                                     ; preds = %20, %15
  %26 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %4, %struct.TValue* nonnull %5)
  br label %27

; <label>:27:                                     ; preds = %10, %20, %25
  %28 = phi i32 [ %26, %25 ], [ 0, %20 ], [ 0, %10 ]
  ret i32 %28
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_equalobj(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = xor i8 %9, %7
  %11 = and i8 %10, 63
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %45, label %13

; <label>:13:                                     ; preds = %3
  %14 = and i8 %7, 15
  %15 = and i8 %9, 15
  %16 = icmp eq i8 %14, %15
  %17 = icmp eq i8 %14, 3
  %18 = and i1 %17, %16
  br i1 %18, label %19, label %195

; <label>:19:                                     ; preds = %13
  %20 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %21 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %21) #7
  %22 = icmp eq i8 %7, 35
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %19
  %24 = bitcast %struct.TValue* %1 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !21
  store i64 %25, i64* %4, align 8, !tbaa !109
  br label %29

; <label>:26:                                     ; preds = %19
  %27 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %1, i64* nonnull %4, i32 0)
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %43, label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = load i8, i8* %8, align 8, !tbaa !22
  %31 = icmp eq i8 %30, 35
  br i1 %31, label %32, label %35

; <label>:32:                                     ; preds = %29
  %33 = bitcast %struct.TValue* %2 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !21
  store i64 %34, i64* %5, align 8, !tbaa !109
  br label %38

; <label>:35:                                     ; preds = %29
  %36 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2, i64* nonnull %5, i32 0)
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %43, label %38

; <label>:38:                                     ; preds = %35, %32
  %39 = load i64, i64* %4, align 8, !tbaa !109
  %40 = load i64, i64* %5, align 8, !tbaa !109
  %41 = icmp eq i64 %39, %40
  %42 = zext i1 %41 to i32
  br label %43

; <label>:43:                                     ; preds = %35, %26, %38
  %44 = phi i32 [ 0, %35 ], [ 0, %26 ], [ %42, %38 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %21) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %195

; <label>:45:                                     ; preds = %3
  %46 = trunc i8 %7 to i6
  switch i6 %46, label %163 [
    i6 0, label %195
    i6 -29, label %47
    i6 19, label %54
    i6 1, label %61
    i6 2, label %68
    i6 -26, label %75
    i6 20, label %82
    i6 -28, label %89
    i6 7, label %95
    i6 5, label %129
  ]

; <label>:47:                                     ; preds = %45
  %48 = bitcast %struct.TValue* %1 to i64*
  %49 = load i64, i64* %48, align 8, !tbaa !21
  %50 = bitcast %struct.TValue* %2 to i64*
  %51 = load i64, i64* %50, align 8, !tbaa !21
  %52 = icmp eq i64 %49, %51
  %53 = zext i1 %52 to i32
  br label %195

; <label>:54:                                     ; preds = %45
  %55 = bitcast %struct.TValue* %1 to double*
  %56 = load double, double* %55, align 8, !tbaa !21
  %57 = bitcast %struct.TValue* %2 to double*
  %58 = load double, double* %57, align 8, !tbaa !21
  %59 = fcmp oeq double %56, %58
  %60 = zext i1 %59 to i32
  br label %195

; <label>:61:                                     ; preds = %45
  %62 = bitcast %struct.TValue* %1 to i32*
  %63 = load i32, i32* %62, align 8, !tbaa !21
  %64 = bitcast %struct.TValue* %2 to i32*
  %65 = load i32, i32* %64, align 8, !tbaa !21
  %66 = icmp eq i32 %63, %65
  %67 = zext i1 %66 to i32
  br label %195

; <label>:68:                                     ; preds = %45
  %69 = bitcast %struct.TValue* %1 to i8**
  %70 = load i8*, i8** %69, align 8, !tbaa !21
  %71 = bitcast %struct.TValue* %2 to i8**
  %72 = load i8*, i8** %71, align 8, !tbaa !21
  %73 = icmp eq i8* %70, %72
  %74 = zext i1 %73 to i32
  br label %195

; <label>:75:                                     ; preds = %45
  %76 = bitcast %struct.TValue* %1 to i32 (%struct.lua_State*)**
  %77 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %76, align 8, !tbaa !21
  %78 = bitcast %struct.TValue* %2 to i32 (%struct.lua_State*)**
  %79 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %78, align 8, !tbaa !21
  %80 = icmp eq i32 (%struct.lua_State*)* %77, %79
  %81 = zext i1 %80 to i32
  br label %195

; <label>:82:                                     ; preds = %45
  %83 = bitcast %struct.TValue* %1 to %struct.TString**
  %84 = load %struct.TString*, %struct.TString** %83, align 8, !tbaa !21
  %85 = bitcast %struct.TValue* %2 to %struct.TString**
  %86 = load %struct.TString*, %struct.TString** %85, align 8, !tbaa !21
  %87 = icmp eq %struct.TString* %84, %86
  %88 = zext i1 %87 to i32
  br label %195

; <label>:89:                                     ; preds = %45
  %90 = bitcast %struct.TValue* %1 to %struct.TString**
  %91 = load %struct.TString*, %struct.TString** %90, align 8, !tbaa !21
  %92 = bitcast %struct.TValue* %2 to %struct.TString**
  %93 = load %struct.TString*, %struct.TString** %92, align 8, !tbaa !21
  %94 = tail call fastcc i32 @luaS_eqlngstr(%struct.TString* %91, %struct.TString* %93)
  br label %195

; <label>:95:                                     ; preds = %45
  %96 = bitcast %struct.TValue* %1 to %struct.Udata**
  %97 = load %struct.Udata*, %struct.Udata** %96, align 8, !tbaa !21
  %98 = bitcast %struct.TValue* %2 to %struct.Udata**
  %99 = load %struct.Udata*, %struct.Udata** %98, align 8, !tbaa !21
  %100 = icmp eq %struct.Udata* %97, %99
  br i1 %100, label %195, label %101

; <label>:101:                                    ; preds = %95
  %102 = icmp eq %struct.lua_State* %0, null
  br i1 %102, label %195, label %103

; <label>:103:                                    ; preds = %101
  %104 = getelementptr inbounds %struct.Udata, %struct.Udata* %97, i64 0, i32 5
  %105 = load %struct.Table*, %struct.Table** %104, align 8, !tbaa !21
  %106 = icmp eq %struct.Table* %105, null
  br i1 %106, label %119, label %107

; <label>:107:                                    ; preds = %103
  %108 = getelementptr inbounds %struct.Table, %struct.Table* %105, i64 0, i32 3
  %109 = load i8, i8* %108, align 2, !tbaa !111
  %110 = and i8 %109, 32
  %111 = icmp eq i8 %110, 0
  br i1 %111, label %112, label %119

; <label>:112:                                    ; preds = %107
  %113 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %114 = load %struct.global_State*, %struct.global_State** %113, align 8, !tbaa !2
  %115 = getelementptr inbounds %struct.global_State, %struct.global_State* %114, i64 0, i32 40, i64 5
  %116 = load %struct.TString*, %struct.TString** %115, align 8, !tbaa !79
  %117 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %105, i32 5, %struct.TString* %116)
  %118 = icmp eq %struct.TValue* %117, null
  br i1 %118, label %119, label %178

; <label>:119:                                    ; preds = %107, %103, %112
  %120 = load %struct.Udata*, %struct.Udata** %98, align 8, !tbaa !21
  %121 = getelementptr inbounds %struct.Udata, %struct.Udata* %120, i64 0, i32 5
  %122 = load %struct.Table*, %struct.Table** %121, align 8, !tbaa !21
  %123 = icmp eq %struct.Table* %122, null
  br i1 %123, label %195, label %124

; <label>:124:                                    ; preds = %119
  %125 = getelementptr inbounds %struct.Table, %struct.Table* %122, i64 0, i32 3
  %126 = load i8, i8* %125, align 2, !tbaa !111
  %127 = and i8 %126, 32
  %128 = icmp eq i8 %127, 0
  br i1 %128, label %170, label %195

; <label>:129:                                    ; preds = %45
  %130 = bitcast %struct.TValue* %1 to %struct.Table**
  %131 = load %struct.Table*, %struct.Table** %130, align 8, !tbaa !21
  %132 = bitcast %struct.TValue* %2 to %struct.Table**
  %133 = load %struct.Table*, %struct.Table** %132, align 8, !tbaa !21
  %134 = icmp eq %struct.Table* %131, %133
  br i1 %134, label %195, label %135

; <label>:135:                                    ; preds = %129
  %136 = icmp eq %struct.lua_State* %0, null
  br i1 %136, label %195, label %137

; <label>:137:                                    ; preds = %135
  %138 = getelementptr inbounds %struct.Table, %struct.Table* %131, i64 0, i32 9
  %139 = load %struct.Table*, %struct.Table** %138, align 8, !tbaa !21
  %140 = icmp eq %struct.Table* %139, null
  br i1 %140, label %153, label %141

; <label>:141:                                    ; preds = %137
  %142 = getelementptr inbounds %struct.Table, %struct.Table* %139, i64 0, i32 3
  %143 = load i8, i8* %142, align 2, !tbaa !111
  %144 = and i8 %143, 32
  %145 = icmp eq i8 %144, 0
  br i1 %145, label %146, label %153

; <label>:146:                                    ; preds = %141
  %147 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %148 = load %struct.global_State*, %struct.global_State** %147, align 8, !tbaa !2
  %149 = getelementptr inbounds %struct.global_State, %struct.global_State* %148, i64 0, i32 40, i64 5
  %150 = load %struct.TString*, %struct.TString** %149, align 8, !tbaa !79
  %151 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %139, i32 5, %struct.TString* %150)
  %152 = icmp eq %struct.TValue* %151, null
  br i1 %152, label %153, label %178

; <label>:153:                                    ; preds = %141, %137, %146
  %154 = load %struct.Table*, %struct.Table** %132, align 8, !tbaa !21
  %155 = getelementptr inbounds %struct.Table, %struct.Table* %154, i64 0, i32 9
  %156 = load %struct.Table*, %struct.Table** %155, align 8, !tbaa !21
  %157 = icmp eq %struct.Table* %156, null
  br i1 %157, label %195, label %158

; <label>:158:                                    ; preds = %153
  %159 = getelementptr inbounds %struct.Table, %struct.Table* %156, i64 0, i32 3
  %160 = load i8, i8* %159, align 2, !tbaa !111
  %161 = and i8 %160, 32
  %162 = icmp eq i8 %161, 0
  br i1 %162, label %170, label %195

; <label>:163:                                    ; preds = %45
  %164 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %165 = load %struct.GCObject*, %struct.GCObject** %164, align 8, !tbaa !21
  %166 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %167 = load %struct.GCObject*, %struct.GCObject** %166, align 8, !tbaa !21
  %168 = icmp eq %struct.GCObject* %165, %167
  %169 = zext i1 %168 to i32
  br label %195

; <label>:170:                                    ; preds = %158, %124
  %171 = phi %struct.Table* [ %122, %124 ], [ %156, %158 ]
  %172 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %173 = load %struct.global_State*, %struct.global_State** %172, align 8, !tbaa !2
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %173, i64 0, i32 40, i64 5
  %175 = load %struct.TString*, %struct.TString** %174, align 8, !tbaa !79
  %176 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %171, i32 5, %struct.TString* %175)
  %177 = icmp eq %struct.TValue* %176, null
  br i1 %177, label %195, label %178

; <label>:178:                                    ; preds = %112, %146, %170
  %179 = phi %struct.TValue* [ %176, %170 ], [ %117, %112 ], [ %151, %146 ]
  %180 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %181 = load %union.StackValue*, %union.StackValue** %180, align 8, !tbaa !20
  tail call fastcc void @luaT_callTMres(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %179, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2, %union.StackValue* %181)
  %182 = bitcast %union.StackValue** %180 to %struct.TValue**
  %183 = load %struct.TValue*, %struct.TValue** %182, align 8, !tbaa !20
  %184 = getelementptr inbounds %struct.TValue, %struct.TValue* %183, i64 0, i32 1
  %185 = load i8, i8* %184, align 8, !tbaa !21
  %186 = and i8 %185, 15
  %187 = icmp eq i8 %186, 0
  br i1 %187, label %195, label %188

; <label>:188:                                    ; preds = %178
  %189 = icmp eq i8 %185, 1
  br i1 %189, label %190, label %195

; <label>:190:                                    ; preds = %188
  %191 = bitcast %struct.TValue* %183 to i32*
  %192 = load i32, i32* %191, align 8, !tbaa !21
  %193 = icmp ne i32 %192, 0
  %194 = zext i1 %193 to i32
  br label %195

; <label>:195:                                    ; preds = %158, %153, %124, %119, %178, %190, %188, %170, %135, %129, %101, %95, %45, %13, %163, %89, %82, %75, %68, %61, %54, %47, %43
  %196 = phi i32 [ %44, %43 ], [ %169, %163 ], [ %94, %89 ], [ %88, %82 ], [ %81, %75 ], [ %74, %68 ], [ %67, %61 ], [ %60, %54 ], [ %53, %47 ], [ 0, %13 ], [ 1, %45 ], [ 1, %95 ], [ 0, %101 ], [ 1, %129 ], [ 0, %135 ], [ 0, %170 ], [ 0, %178 ], [ 1, %188 ], [ %194, %190 ], [ 0, %119 ], [ 0, %124 ], [ 0, %153 ], [ 0, %158 ]
  ret i32 %196
}

; Function Attrs: nounwind uwtable
define void @lua_arith(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = or i32 %1, 1
  %4 = icmp eq i32 %3, 13
  br i1 %4, label %5, label %17

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0
  %9 = bitcast %struct.TValue* %8 to i64*
  %10 = bitcast %union.StackValue* %7 to i64*
  %11 = load i64, i64* %9, align 8
  store i64 %11, i64* %10, align 8
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %6, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %2, %5
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -2
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 0, i32 0
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  tail call fastcc void @luaO_arith(%struct.lua_State* %0, i32 %1, %struct.TValue* nonnull %21, %struct.TValue* nonnull %22, %union.StackValue* nonnull %20)
  %23 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 -1
  store %union.StackValue* %24, %union.StackValue** %18, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaO_arith(%struct.lua_State*, i32, %struct.TValue*, %struct.TValue*, %union.StackValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 0, i32 0
  %7 = tail call fastcc i32 @luaO_rawarith(%struct.lua_State* %0, i32 %1, %struct.TValue* %2, %struct.TValue* %3, %struct.TValue* %6)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %5
  %10 = add nsw i32 %1, 6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2, %struct.TValue* %3, %union.StackValue* %4, i32 %10)
  br label %11

; <label>:11:                                     ; preds = %5, %9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_compare(%struct.lua_State*, i32, i32, i32) local_unnamed_addr #0 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  %15 = icmp eq %struct.TValue* %5, %14
  br i1 %15, label %33, label %16

; <label>:16:                                     ; preds = %11, %4
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 8
  %25 = icmp eq %struct.TValue* %6, %24
  br i1 %25, label %33, label %26

; <label>:26:                                     ; preds = %21, %16
  switch i32 %3, label %33 [
    i32 0, label %27
    i32 1, label %29
    i32 2, label %31
  ]

; <label>:27:                                     ; preds = %26
  %28 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %6)
  br label %33

; <label>:29:                                     ; preds = %26
  %30 = tail call fastcc i32 @luaV_lessthan(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %6)
  br label %33

; <label>:31:                                     ; preds = %26
  %32 = tail call fastcc i32 @luaV_lessequal(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %6)
  br label %33

; <label>:33:                                     ; preds = %11, %21, %27, %29, %31, %26
  %34 = phi i32 [ 0, %26 ], [ %32, %31 ], [ %30, %29 ], [ %28, %27 ], [ 0, %21 ], [ 0, %11 ]
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_lessthan(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 3
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 3
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %8
  %14 = tail call fastcc i32 @LTnum(%struct.TValue* nonnull %1, %struct.TValue* nonnull %2)
  br label %17

; <label>:15:                                     ; preds = %8, %3
  %16 = tail call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2)
  br label %17

; <label>:17:                                     ; preds = %15, %13
  %18 = phi i32 [ %14, %13 ], [ %16, %15 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_lessequal(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 3
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 3
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %8
  %14 = tail call fastcc i32 @LEnum(%struct.TValue* nonnull %1, %struct.TValue* nonnull %2)
  br label %17

; <label>:15:                                     ; preds = %8, %3
  %16 = tail call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2)
  br label %17

; <label>:17:                                     ; preds = %15, %13
  %18 = phi i32 [ %14, %13 ], [ %16, %15 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define i64 @lua_stringtonumber(%struct.lua_State* nocapture, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc i64 @luaO_str2num(i8* %1, %struct.TValue* %5)
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %2
  %9 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %3, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %2, %8
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @luaO_str2num(i8*, %struct.TValue* nocapture) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca double, align 8
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call fastcc i8* @l_str2int(i8* %0, i64* nonnull %3)
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %14

; <label>:9:                                      ; preds = %2
  %10 = call fastcc i8* @l_str2d(i8* %0, double* nonnull %4)
  %11 = icmp eq i8* %10, null
  br i1 %11, label %25, label %12

; <label>:12:                                     ; preds = %9
  %13 = bitcast double* %4 to i64*
  br label %14

; <label>:14:                                     ; preds = %2, %12
  %15 = phi i64* [ %13, %12 ], [ %3, %2 ]
  %16 = phi i8 [ 19, %12 ], [ 35, %2 ]
  %17 = phi i8* [ %10, %12 ], [ %7, %2 ]
  %18 = load i64, i64* %15, align 8, !tbaa !21
  %19 = bitcast %struct.TValue* %1 to i64*
  store i64 %18, i64* %19, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 %16, i8* %20, align 8, !tbaa !22
  %21 = ptrtoint i8* %17 to i64
  %22 = ptrtoint i8* %0 to i64
  %23 = sub i64 1, %22
  %24 = add i64 %23, %21
  br label %25

; <label>:25:                                     ; preds = %9, %14
  %26 = phi i64 [ %24, %14 ], [ 0, %9 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %26
}

; Function Attrs: nounwind uwtable
define double @lua_tonumberx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca double, align 8
  %5 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 19
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = bitcast double* %4 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !107
  br label %18

; <label>:14:                                     ; preds = %3
  %15 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %6, double* nonnull %4)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  store double 0.000000e+00, double* %4, align 8, !tbaa !107
  br label %18

; <label>:18:                                     ; preds = %10, %14, %17
  %19 = phi i32 [ 1, %10 ], [ %15, %14 ], [ 0, %17 ]
  %20 = icmp eq i32* %2, null
  br i1 %20, label %22, label %21

; <label>:21:                                     ; preds = %18
  store i32 %19, i32* %2, align 4, !tbaa !70
  br label %22

; <label>:22:                                     ; preds = %18, %21
  %23 = load double, double* %4, align 8, !tbaa !107
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret double %23
}

; Function Attrs: nounwind uwtable
define i64 @lua_tointegerx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 35
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %4, align 8, !tbaa !109
  br label %17

; <label>:13:                                     ; preds = %3
  %14 = call fastcc i32 @luaV_tointeger(%struct.TValue* %6, i64* nonnull %4, i32 0)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %13
  store i64 0, i64* %4, align 8, !tbaa !109
  br label %17

; <label>:17:                                     ; preds = %10, %13, %16
  %18 = phi i32 [ 1, %10 ], [ %14, %13 ], [ 0, %16 ]
  %19 = icmp eq i32* %2, null
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %17
  store i32 %18, i32* %2, align 4, !tbaa !70
  br label %21

; <label>:21:                                     ; preds = %17, %20
  %22 = load i64, i64* %4, align 8, !tbaa !109
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %22
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_tointeger(%struct.TValue* nocapture readonly, i64* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 4
  br i1 %9, label %10, label %32

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %0 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds i8, i8* %12, i64 24
  %14 = call fastcc i64 @luaO_str2num(i8* nonnull %13, %struct.TValue* nonnull %4)
  %15 = bitcast %struct.TValue* %0 to %struct.TString**
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !21
  %19 = icmp eq i8 %18, 20
  br i1 %19, label %20, label %24

; <label>:20:                                     ; preds = %10
  %21 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 4
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  br label %27

; <label>:24:                                     ; preds = %10
  %25 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 6, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !21
  br label %27

; <label>:27:                                     ; preds = %24, %20
  %28 = phi i64 [ %23, %20 ], [ %26, %24 ]
  %29 = add i64 %28, 1
  %30 = icmp eq i64 %14, %29
  %31 = select i1 %30, %struct.TValue* %4, %struct.TValue* %0
  br label %32

; <label>:32:                                     ; preds = %27, %3
  %33 = phi %struct.TValue* [ %0, %3 ], [ %31, %27 ]
  %34 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %33, i64* %1, i32 %2)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %34
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_toboolean(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %15, label %8

; <label>:8:                                      ; preds = %2
  %9 = icmp eq i8 %5, 1
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %8
  %11 = bitcast %struct.TValue* %3 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = icmp ne i32 %12, 0
  %14 = zext i1 %13 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %10, %2
  %16 = phi i32 [ 0, %2 ], [ 1, %8 ], [ %14, %10 ]
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define i8* @lua_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i4
  switch i4 %7, label %8 [
    i4 4, label %20
    i4 3, label %11
  ]

; <label>:8:                                      ; preds = %3
  %9 = icmp eq i64* %2, null
  br i1 %9, label %42, label %10

; <label>:10:                                     ; preds = %8
  store i64 0, i64* %2, align 8, !tbaa !113
  br label %42

; <label>:11:                                     ; preds = %3
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* %4)
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 3
  %15 = load i64, i64* %14, align 8, !tbaa !11
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %11
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %18

; <label>:18:                                     ; preds = %17, %11
  %19 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %1)
  br label %20

; <label>:20:                                     ; preds = %3, %18
  %21 = phi %struct.TValue* [ %4, %3 ], [ %19, %18 ]
  %22 = icmp eq i64* %2, null
  br i1 %22, label %38, label %23

; <label>:23:                                     ; preds = %20
  %24 = bitcast %struct.TValue* %21 to %struct.TString**
  %25 = load %struct.TString*, %struct.TString** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !21
  %28 = icmp eq i8 %27, 20
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 4
  %31 = load i8, i8* %30, align 1, !tbaa !21
  %32 = zext i8 %31 to i64
  br label %36

; <label>:33:                                     ; preds = %23
  %34 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 6, i32 0
  %35 = load i64, i64* %34, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %33, %29
  %37 = phi i64 [ %32, %29 ], [ %35, %33 ]
  store i64 %37, i64* %2, align 8, !tbaa !113
  br label %38

; <label>:38:                                     ; preds = %20, %36
  %39 = bitcast %struct.TValue* %21 to i8**
  %40 = load i8*, i8** %39, align 8, !tbaa !21
  %41 = getelementptr inbounds i8, i8* %40, i64 24
  br label %42

; <label>:42:                                     ; preds = %10, %8, %38
  %43 = phi i8* [ %41, %38 ], [ null, %8 ], [ null, %10 ]
  ret i8* %43
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaO_tostring(%struct.lua_State*, %struct.TValue* nocapture) unnamed_addr #0 {
  %3 = alloca [50 x i8], align 16
  %4 = getelementptr inbounds [50 x i8], [50 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %4) #7
  %5 = call fastcc i64 @tostringbuff(%struct.TValue* %1, i8* nonnull %4)
  %6 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %4, i64 %5)
  %7 = bitcast %struct.TValue* %1 to %struct.TString**
  store %struct.TString* %6, %struct.TString** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %6, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !57
  %10 = or i8 %9, 64
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %4) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i64 @lua_rawlen(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %27 [
    i6 20, label %7
    i6 -28, label %13
    i6 7, label %18
    i6 5, label %23
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.TString**
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = zext i8 %11 to i64
  br label %27

; <label>:13:                                     ; preds = %2
  %14 = bitcast %struct.TValue* %3 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 0, i32 6, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !21
  br label %27

; <label>:18:                                     ; preds = %2
  %19 = bitcast %struct.TValue* %3 to %struct.Udata**
  %20 = load %struct.Udata*, %struct.Udata** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.Udata, %struct.Udata* %20, i64 0, i32 4
  %22 = load i64, i64* %21, align 8, !tbaa !21
  br label %27

; <label>:23:                                     ; preds = %2
  %24 = bitcast %struct.TValue* %3 to %struct.Table**
  %25 = load %struct.Table*, %struct.Table** %24, align 8, !tbaa !21
  %26 = tail call fastcc i64 @luaH_getn(%struct.Table* %25)
  br label %27

; <label>:27:                                     ; preds = %2, %23, %18, %13, %7
  %28 = phi i64 [ %26, %23 ], [ %22, %18 ], [ %17, %13 ], [ %12, %7 ], [ 0, %2 ]
  ret i64 %28
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i64 @luaH_getn(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %3 = load i32, i32* %2, align 4, !tbaa !114
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %47, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !115
  %8 = add i32 %3, -1
  %9 = zext i32 %8 to i64
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %9, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = and i8 %11, 15
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %47

; <label>:14:                                     ; preds = %5
  %15 = icmp ugt i32 %3, 1
  br i1 %15, label %16, label %33

; <label>:16:                                     ; preds = %14
  %17 = add i32 %3, -2
  %18 = zext i32 %17 to i64
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %18, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %33, label %23

; <label>:23:                                     ; preds = %16
  %24 = tail call fastcc i32 @ispow2realasize(%struct.Table* nonnull %0)
  %25 = icmp eq i32 %24, 0
  %26 = and i32 %8, %17
  %27 = icmp eq i32 %26, 0
  %28 = or i1 %27, %25
  br i1 %28, label %92, label %29

; <label>:29:                                     ; preds = %23
  store i32 %8, i32* %2, align 4, !tbaa !114
  %30 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !116
  %32 = or i8 %31, -128
  store i8 %32, i8* %30, align 1, !tbaa !116
  br label %92

; <label>:33:                                     ; preds = %16, %14
  %34 = tail call fastcc i32 @binsearch(%struct.TValue* %7, i32 0, i32 %3)
  %35 = tail call fastcc i32 @ispow2realasize(%struct.Table* nonnull %0)
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %45, label %37

; <label>:37:                                     ; preds = %33
  %38 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0)
  %39 = lshr i32 %38, 1
  %40 = icmp ugt i32 %34, %39
  br i1 %40, label %41, label %45

; <label>:41:                                     ; preds = %37
  store i32 %34, i32* %2, align 4, !tbaa !114
  %42 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %43 = load i8, i8* %42, align 1, !tbaa !116
  %44 = or i8 %43, -128
  store i8 %44, i8* %42, align 1, !tbaa !116
  br label %45

; <label>:45:                                     ; preds = %33, %41, %37
  %46 = zext i32 %34 to i64
  br label %92

; <label>:47:                                     ; preds = %1, %5
  %48 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !116
  %50 = icmp slt i8 %49, 0
  br i1 %50, label %51, label %74

; <label>:51:                                     ; preds = %47
  %52 = add i32 %3, -1
  %53 = and i32 %52, %3
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %74, label %55

; <label>:55:                                     ; preds = %51
  %56 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %57 = load %struct.TValue*, %struct.TValue** %56, align 8, !tbaa !115
  %58 = zext i32 %3 to i64
  %59 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 %58, i32 1
  %60 = load i8, i8* %59, align 8, !tbaa !22
  %61 = and i8 %60, 15
  %62 = icmp eq i8 %61, 0
  br i1 %62, label %92, label %63

; <label>:63:                                     ; preds = %55
  %64 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0)
  %65 = add i32 %64, -1
  %66 = zext i32 %65 to i64
  %67 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 %66, i32 1
  %68 = load i8, i8* %67, align 8, !tbaa !22
  %69 = and i8 %68, 15
  %70 = icmp eq i8 %69, 0
  br i1 %70, label %71, label %74

; <label>:71:                                     ; preds = %63
  %72 = tail call fastcc i32 @binsearch(%struct.TValue* nonnull %57, i32 %3, i32 %64)
  store i32 %72, i32* %2, align 4, !tbaa !114
  %73 = zext i32 %72 to i64
  br label %92

; <label>:74:                                     ; preds = %63, %51, %47
  %75 = phi i32 [ %3, %51 ], [ %64, %63 ], [ %3, %47 ]
  %76 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 8
  %77 = load %union.Node*, %union.Node** %76, align 8, !tbaa !117
  %78 = icmp eq %union.Node* %77, null
  br i1 %78, label %87, label %79

; <label>:79:                                     ; preds = %74
  %80 = add i32 %75, 1
  %81 = zext i32 %80 to i64
  %82 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* nonnull %0, i64 %81)
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %82, i64 0, i32 1
  %84 = load i8, i8* %83, align 8, !tbaa !22
  %85 = and i8 %84, 15
  %86 = icmp eq i8 %85, 0
  br i1 %86, label %87, label %89

; <label>:87:                                     ; preds = %79, %74
  %88 = zext i32 %75 to i64
  br label %92

; <label>:89:                                     ; preds = %79
  %90 = zext i32 %75 to i64
  %91 = tail call fastcc i64 @hash_search(%struct.Table* nonnull %0, i64 %90)
  br label %92

; <label>:92:                                     ; preds = %55, %29, %23, %89, %87, %71, %45
  %93 = phi i64 [ %46, %45 ], [ %88, %87 ], [ %91, %89 ], [ %73, %71 ], [ %9, %23 ], [ %9, %29 ], [ %58, %55 ]
  ret i64 %93
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 (%struct.lua_State*)* @lua_tocfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %15 [
    i8 38, label %6
    i8 118, label %8
  ]

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %3 to i32 (%struct.lua_State*)**
  br label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %3 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %12

; <label>:12:                                     ; preds = %6, %8
  %13 = phi i32 (%struct.lua_State*)** [ %11, %8 ], [ %7, %6 ]
  %14 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %2
  %16 = phi i32 (%struct.lua_State*)* [ null, %2 ], [ %14, %12 ]
  ret i32 (%struct.lua_State*)* %16
}

; Function Attrs: norecurse nounwind readonly uwtable
define i8* @lua_touserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = tail call fastcc i8* @touserdata(%struct.TValue* %3)
  ret i8* %4
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i8* @touserdata(%struct.TValue* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %3 = load i8, i8* %2, align 8, !tbaa !22
  %4 = trunc i8 %3 to i4
  switch i4 %4, label %20 [
    i4 7, label %5
    i4 2, label %17
  ]

; <label>:5:                                      ; preds = %1
  %6 = bitcast %struct.TValue* %0 to %struct.Udata**
  %7 = load %struct.Udata*, %struct.Udata** %6, align 8, !tbaa !21
  %8 = bitcast %struct.Udata* %7 to i8*
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %7, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = icmp eq i16 %10, 0
  %12 = zext i16 %10 to i64
  %13 = shl nuw nsw i64 %12, 4
  %14 = add nuw nsw i64 %13, 40
  %15 = select i1 %11, i64 32, i64 %14
  %16 = getelementptr inbounds i8, i8* %8, i64 %15
  br label %20

; <label>:17:                                     ; preds = %1
  %18 = bitcast %struct.TValue* %0 to i8**
  %19 = load i8*, i8** %18, align 8, !tbaa !21
  br label %20

; <label>:20:                                     ; preds = %1, %17, %5
  %21 = phi i8* [ %19, %17 ], [ %16, %5 ], [ null, %1 ]
  ret i8* %21
}

; Function Attrs: norecurse nounwind readonly uwtable
define %struct.lua_State* @lua_tothread(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 72
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.lua_State**
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !21
  br label %10

; <label>:10:                                     ; preds = %2, %7
  %11 = phi %struct.lua_State* [ %9, %7 ], [ null, %2 ]
  ret %struct.lua_State* %11
}

; Function Attrs: norecurse nounwind readonly uwtable
define i8* @lua_topointer(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %12 [
    i6 -26, label %7
    i6 7, label %10
    i6 2, label %10
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !21
  br label %18

; <label>:10:                                     ; preds = %2, %2
  %11 = tail call fastcc i8* @touserdata(%struct.TValue* %3)
  br label %18

; <label>:12:                                     ; preds = %2
  %13 = and i8 %5, 64
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %18, label %15

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %3 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !21
  br label %18

; <label>:18:                                     ; preds = %12, %15, %10, %7
  %19 = phi i8* [ %17, %15 ], [ %11, %10 ], [ %9, %7 ], [ null, %12 ]
  ret i8* %19
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushnil(%struct.lua_State* nocapture) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 0, i8* %5, align 8, !tbaa !21
  %6 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %2, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushnumber(%struct.lua_State* nocapture, double) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to double*
  store double %1, double* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 19, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushinteger(%struct.lua_State* nocapture, i64) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i64*
  store i64 %1, i64* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define nonnull i8* @lua_pushlstring(%struct.lua_State*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  br label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %2)
  br label %9

; <label>:9:                                      ; preds = %7, %5
  %10 = phi %struct.TString* [ %6, %5 ], [ %8, %7 ]
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !57
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %11, align 8, !tbaa !20
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = icmp sgt i64 %24, 0
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %9
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %27

; <label>:27:                                     ; preds = %26, %9
  %28 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %29 = bitcast %struct.TString* %28 to i8*
  ret i8* %29
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @luaS_new(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = ptrtoint i8* %1 to i64
  %4 = trunc i64 %3 to i32
  %5 = urem i32 %4, 53
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = zext i32 %5 to i64
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 0
  br label %13

; <label>:10:                                     ; preds = %13
  %11 = add nuw nsw i64 %14, 1
  %12 = icmp ult i64 %11, 2
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %2, %10
  %14 = phi i64 [ 0, %2 ], [ 1, %10 ]
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 %14
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !79
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = tail call i32 @strcmp(i8* %1, i8* nonnull %18) #19
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %29, label %10

; <label>:21:                                     ; preds = %10
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 0
  %23 = bitcast %struct.TString** %22 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !79
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 1
  %26 = bitcast %struct.TString** %25 to i64*
  store i64 %24, i64* %26, align 8, !tbaa !79
  %27 = tail call i64 @strlen(i8* %1) #19
  %28 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %27)
  store %struct.TString* %28, %struct.TString** %9, align 8, !tbaa !79
  br label %29

; <label>:29:                                     ; preds = %13, %21
  %30 = phi %struct.TString* [ %28, %21 ], [ %16, %13 ]
  ret %struct.TString* %30
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @luaS_newlstr(%struct.lua_State*, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 41
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TString* @internshrstr(%struct.lua_State* %0, i8* %1, i64 %2)
  br label %14

; <label>:7:                                      ; preds = %3
  %8 = icmp ugt i64 %2, 9223372036854775782
  br i1 %8, label %9, label %10, !prof !33

; <label>:9:                                      ; preds = %7
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #17
  unreachable

; <label>:10:                                     ; preds = %7
  %11 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %0, i64 %2)
  %12 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 1
  %13 = bitcast %struct.TString* %12 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %13, i8* %1, i64 %2, i32 1, i1 false)
  br label %14

; <label>:14:                                     ; preds = %10, %5
  %15 = phi %struct.TString* [ %6, %5 ], [ %11, %10 ]
  ret %struct.TString* %15
}

; Function Attrs: nounwind uwtable
define i8* @lua_pushstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  br label %21

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* nonnull %1)
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !57
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %20 = bitcast %struct.TString* %19 to i8*
  br label %21

; <label>:21:                                     ; preds = %9, %4
  %22 = phi i8* [ null, %4 ], [ %20, %9 ]
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %23, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %32

; <label>:31:                                     ; preds = %21
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %32

; <label>:32:                                     ; preds = %31, %21
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define nonnull i8* @lua_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) local_unnamed_addr #0 {
  %4 = tail call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* %2)
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = icmp sgt i64 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %3
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %11

; <label>:11:                                     ; preds = %10, %3
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define internal fastcc nonnull i8* @luaO_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) unnamed_addr #0 {
  %4 = alloca %struct.BuffFS, align 8
  %5 = alloca i8, align 1
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = alloca [8 x i8], align 1
  %10 = bitcast %struct.BuffFS* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 416, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 2
  store i32 0, i32* %11, align 4, !tbaa !118
  %12 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 1
  store i32 0, i32* %12, align 8, !tbaa !120
  %13 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %13, align 8, !tbaa !121
  %14 = call i8* @strchr(i8* %1, i32 37) #19
  %15 = icmp eq i8* %14, null
  br i1 %15, label %183, label %16

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %18 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %19 = bitcast %struct.TValue* %6 to i8*
  %20 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %21 = bitcast %struct.TValue* %7 to i8*
  %22 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %23 = bitcast %struct.TValue* %8 to i8*
  %24 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 1
  %25 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %26 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 0
  %27 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %28 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %29 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %30 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %31 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %32 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %33 = bitcast %struct.TValue* %6 to i64*
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %35 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %36 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %37 = bitcast %struct.TValue* %7 to i64*
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %39 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %40 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %41 = bitcast %struct.TValue* %8 to i64*
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %43 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %44 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %45 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %46 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %47 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 8
  %48 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  br label %49

; <label>:49:                                     ; preds = %16, %179
  %50 = phi i8* [ %14, %16 ], [ %181, %179 ]
  %51 = phi i8* [ %1, %16 ], [ %180, %179 ]
  %52 = ptrtoint i8* %50 to i64
  %53 = ptrtoint i8* %51 to i64
  %54 = sub i64 %52, %53
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %51, i64 %54)
  %55 = getelementptr inbounds i8, i8* %50, i64 1
  %56 = load i8, i8* %55, align 1, !tbaa !21
  %57 = sext i8 %56 to i32
  switch i32 %57, label %177 [
    i32 115, label %58
    i32 99, label %76
    i32 100, label %92
    i32 73, label %108
    i32 102, label %123
    i32 112, label %138
    i32 85, label %157
    i32 37, label %176
  ]

; <label>:58:                                     ; preds = %49
  %59 = load i32, i32* %17, align 8
  %60 = icmp ult i32 %59, 41
  br i1 %60, label %61, label %66

; <label>:61:                                     ; preds = %58
  %62 = load i8*, i8** %28, align 8
  %63 = sext i32 %59 to i64
  %64 = getelementptr i8, i8* %62, i64 %63
  %65 = add i32 %59, 8
  store i32 %65, i32* %17, align 8
  br label %69

; <label>:66:                                     ; preds = %58
  %67 = load i8*, i8** %29, align 8
  %68 = getelementptr i8, i8* %67, i64 8
  store i8* %68, i8** %29, align 8
  br label %69

; <label>:69:                                     ; preds = %66, %61
  %70 = phi i8* [ %64, %61 ], [ %67, %66 ]
  %71 = bitcast i8* %70 to i8**
  %72 = load i8*, i8** %71, align 8
  %73 = icmp eq i8* %72, null
  %74 = select i1 %73, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.193, i64 0, i64 0), i8* %72
  %75 = call i64 @strlen(i8* %74) #19
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %74, i64 %75)
  br label %179

; <label>:76:                                     ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #7
  %77 = load i32, i32* %18, align 8
  %78 = icmp ult i32 %77, 41
  br i1 %78, label %79, label %84

; <label>:79:                                     ; preds = %76
  %80 = load i8*, i8** %30, align 8
  %81 = sext i32 %77 to i64
  %82 = getelementptr i8, i8* %80, i64 %81
  %83 = add i32 %77, 8
  store i32 %83, i32* %18, align 8
  br label %87

; <label>:84:                                     ; preds = %76
  %85 = load i8*, i8** %31, align 8
  %86 = getelementptr i8, i8* %85, i64 8
  store i8* %86, i8** %31, align 8
  br label %87

; <label>:87:                                     ; preds = %84, %79
  %88 = phi i8* [ %82, %79 ], [ %85, %84 ]
  %89 = bitcast i8* %88 to i32*
  %90 = load i32, i32* %89, align 4
  %91 = trunc i32 %90 to i8
  store i8 %91, i8* %5, align 1, !tbaa !21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %5, i64 1)
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #7
  br label %179

; <label>:92:                                     ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %19) #7
  %93 = load i32, i32* %20, align 8
  %94 = icmp ult i32 %93, 41
  br i1 %94, label %95, label %100

; <label>:95:                                     ; preds = %92
  %96 = load i8*, i8** %32, align 8
  %97 = sext i32 %93 to i64
  %98 = getelementptr i8, i8* %96, i64 %97
  %99 = add i32 %93, 8
  store i32 %99, i32* %20, align 8
  br label %103

; <label>:100:                                    ; preds = %92
  %101 = load i8*, i8** %35, align 8
  %102 = getelementptr i8, i8* %101, i64 8
  store i8* %102, i8** %35, align 8
  br label %103

; <label>:103:                                    ; preds = %100, %95
  %104 = phi i8* [ %98, %95 ], [ %101, %100 ]
  %105 = bitcast i8* %104 to i32*
  %106 = load i32, i32* %105, align 4
  %107 = sext i32 %106 to i64
  store i64 %107, i64* %33, align 8, !tbaa !21
  store i8 35, i8* %34, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %6)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %19) #7
  br label %179

; <label>:108:                                    ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %21) #7
  %109 = load i32, i32* %22, align 8
  %110 = icmp ult i32 %109, 41
  br i1 %110, label %111, label %116

; <label>:111:                                    ; preds = %108
  %112 = load i8*, i8** %36, align 8
  %113 = sext i32 %109 to i64
  %114 = getelementptr i8, i8* %112, i64 %113
  %115 = add i32 %109, 8
  store i32 %115, i32* %22, align 8
  br label %119

; <label>:116:                                    ; preds = %108
  %117 = load i8*, i8** %39, align 8
  %118 = getelementptr i8, i8* %117, i64 8
  store i8* %118, i8** %39, align 8
  br label %119

; <label>:119:                                    ; preds = %116, %111
  %120 = phi i8* [ %114, %111 ], [ %117, %116 ]
  %121 = bitcast i8* %120 to i64*
  %122 = load i64, i64* %121, align 8
  store i64 %122, i64* %37, align 8, !tbaa !21
  store i8 35, i8* %38, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %7)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %21) #7
  br label %179

; <label>:123:                                    ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %23) #7
  %124 = load i32, i32* %24, align 4
  %125 = icmp ult i32 %124, 161
  br i1 %125, label %126, label %131

; <label>:126:                                    ; preds = %123
  %127 = load i8*, i8** %40, align 8
  %128 = sext i32 %124 to i64
  %129 = getelementptr i8, i8* %127, i64 %128
  %130 = add i32 %124, 16
  store i32 %130, i32* %24, align 4
  br label %134

; <label>:131:                                    ; preds = %123
  %132 = load i8*, i8** %43, align 8
  %133 = getelementptr i8, i8* %132, i64 8
  store i8* %133, i8** %43, align 8
  br label %134

; <label>:134:                                    ; preds = %131, %126
  %135 = phi i8* [ %129, %126 ], [ %132, %131 ]
  %136 = bitcast i8* %135 to i64*
  %137 = load i64, i64* %136, align 8
  store i64 %137, i64* %41, align 8, !tbaa !21
  store i8 19, i8* %42, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %8)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %23) #7
  br label %179

; <label>:138:                                    ; preds = %49
  %139 = call fastcc i8* @getbuff(%struct.BuffFS* nonnull %4, i64 32)
  %140 = load i32, i32* %25, align 8
  %141 = icmp ult i32 %140, 41
  br i1 %141, label %142, label %147

; <label>:142:                                    ; preds = %138
  %143 = load i8*, i8** %44, align 8
  %144 = sext i32 %140 to i64
  %145 = getelementptr i8, i8* %143, i64 %144
  %146 = add i32 %140, 8
  store i32 %146, i32* %25, align 8
  br label %150

; <label>:147:                                    ; preds = %138
  %148 = load i8*, i8** %45, align 8
  %149 = getelementptr i8, i8* %148, i64 8
  store i8* %149, i8** %45, align 8
  br label %150

; <label>:150:                                    ; preds = %147, %142
  %151 = phi i8* [ %145, %142 ], [ %148, %147 ]
  %152 = bitcast i8* %151 to i8**
  %153 = load i8*, i8** %152, align 8
  %154 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %139, i64 32, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.194, i64 0, i64 0), i8* %153) #7
  %155 = load i32, i32* %11, align 4, !tbaa !118
  %156 = add nsw i32 %155, %154
  store i32 %156, i32* %11, align 4, !tbaa !118
  br label %179

; <label>:157:                                    ; preds = %49
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %26) #7
  %158 = load i32, i32* %27, align 8
  %159 = icmp ult i32 %158, 41
  br i1 %159, label %160, label %165

; <label>:160:                                    ; preds = %157
  %161 = load i8*, i8** %46, align 8
  %162 = sext i32 %158 to i64
  %163 = getelementptr i8, i8* %161, i64 %162
  %164 = add i32 %158, 8
  store i32 %164, i32* %27, align 8
  br label %168

; <label>:165:                                    ; preds = %157
  %166 = load i8*, i8** %48, align 8
  %167 = getelementptr i8, i8* %166, i64 8
  store i8* %167, i8** %48, align 8
  br label %168

; <label>:168:                                    ; preds = %165, %160
  %169 = phi i8* [ %163, %160 ], [ %166, %165 ]
  %170 = bitcast i8* %169 to i64*
  %171 = load i64, i64* %170, align 8
  %172 = call fastcc i32 @luaO_utf8esc(i8* nonnull %26, i64 %171)
  %173 = sext i32 %172 to i64
  %174 = sub nsw i64 0, %173
  %175 = getelementptr inbounds i8, i8* %47, i64 %174
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %175, i64 %173)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %26) #7
  br label %179

; <label>:176:                                    ; preds = %49
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.195, i64 0, i64 0), i64 1)
  br label %179

; <label>:177:                                    ; preds = %49
  %178 = sext i8 %56 to i32
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.196, i64 0, i64 0), i32 %178) #17
  unreachable

; <label>:179:                                    ; preds = %176, %168, %150, %134, %119, %103, %87, %69
  %180 = getelementptr inbounds i8, i8* %50, i64 2
  %181 = call i8* @strchr(i8* nonnull %180, i32 37) #19
  %182 = icmp eq i8* %181, null
  br i1 %182, label %183, label %49

; <label>:183:                                    ; preds = %179, %3
  %184 = phi i8* [ %1, %3 ], [ %180, %179 ]
  %185 = call i64 @strlen(i8* %184) #19
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %184, i64 %185)
  call fastcc void @clearbuff(%struct.BuffFS* nonnull %4)
  %186 = load i32, i32* %12, align 8, !tbaa !120
  %187 = icmp sgt i32 %186, 1
  br i1 %187, label %188, label %189

; <label>:188:                                    ; preds = %183
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %186)
  br label %189

; <label>:189:                                    ; preds = %188, %183
  %190 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %191 = load %union.StackValue*, %union.StackValue** %190, align 8, !tbaa !20
  %192 = getelementptr inbounds %union.StackValue, %union.StackValue* %191, i64 -1, i32 0, i32 0, i32 0
  %193 = bitcast %struct.GCObject** %192 to i8**
  %194 = load i8*, i8** %193, align 8, !tbaa !21
  %195 = getelementptr inbounds i8, i8* %194, i64 24
  call void @llvm.lifetime.end.p0i8(i64 416, i8* nonnull %10) #7
  ret i8* %195
}

; Function Attrs: nounwind uwtable
define nonnull i8* @lua_pushfstring(%struct.lua_State*, i8*, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5)
  call void @llvm.va_end(i8* nonnull %4)
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %13

; <label>:13:                                     ; preds = %12, %2
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: nounwind uwtable
define void @lua_pushcclosure(%struct.lua_State*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 38, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  br label %49

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc %struct.CClosure* @luaF_newCclosure(%struct.lua_State* %0, i32 %2)
  %15 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %14, i64 0, i32 5
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %15, align 8, !tbaa !122
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %18 = sext i32 %2 to i64
  %19 = sub nsw i64 0, %18
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 %19
  store %union.StackValue* %20, %union.StackValue** %16, align 8, !tbaa !20
  %21 = sext i32 %2 to i64
  br label %22

; <label>:22:                                     ; preds = %13, %22
  %23 = phi i64 [ %21, %13 ], [ %24, %22 ]
  %24 = add nsw i64 %23, -1
  %25 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %14, i64 0, i32 6, i64 %24
  %26 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 %24, i32 0
  %28 = bitcast %struct.TValue* %27 to i64*
  %29 = bitcast %struct.TValue* %25 to i64*
  %30 = load i64, i64* %28, align 8
  store i64 %30, i64* %29, align 8
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 %24, i32 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %14, i64 0, i32 6, i64 %24, i32 1
  store i8 %32, i8* %33, align 8, !tbaa !22
  %34 = trunc i64 %24 to i32
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %22

; <label>:36:                                     ; preds = %22
  %37 = bitcast %union.StackValue** %16 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to %struct.CClosure**
  store %struct.CClosure* %14, %struct.CClosure** %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 118, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %16, align 8, !tbaa !20
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %44 = load %struct.global_State*, %struct.global_State** %43, align 8, !tbaa !2
  %45 = getelementptr inbounds %struct.global_State, %struct.global_State* %44, i64 0, i32 3
  %46 = load i64, i64* %45, align 8, !tbaa !11
  %47 = icmp sgt i64 %46, 0
  br i1 %47, label %48, label %49

; <label>:48:                                     ; preds = %36
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %49

; <label>:49:                                     ; preds = %36, %48, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.CClosure* @luaF_newCclosure(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 4
  %4 = add nsw i32 %3, 32
  %5 = sext i32 %4 to i64
  %6 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 54, i64 %5)
  %7 = bitcast %struct.GCObject* %6 to %struct.CClosure*
  %8 = trunc i32 %1 to i8
  %9 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %7, i64 0, i32 3
  store i8 %8, i8* %9, align 2, !tbaa !105
  ret %struct.CClosure* %7
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushboolean(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %1, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_pushlightuserdata(%struct.lua_State* nocapture, i8*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i8**
  store i8* %1, i8** %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 2, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_pushthread(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 72, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 38
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !27
  %13 = icmp eq %struct.lua_State* %12, %0
  %14 = zext i1 %13 to i32
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define i32 @lua_getglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2)
  %9 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1)
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @auxgetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %27

; <label>:8:                                      ; preds = %3
  %9 = bitcast %struct.TValue* %1 to %struct.Table**
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %10, %struct.TString* %4)
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %27, label %16

; <label>:16:                                     ; preds = %8
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to %struct.TValue**
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %11 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = load i8, i8* %12, align 8, !tbaa !22
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %23, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %17, align 8, !tbaa !20
  br label %40

; <label>:27:                                     ; preds = %3, %8
  %28 = phi %struct.TValue* [ %11, %8 ], [ null, %3 ]
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %30 = bitcast %union.StackValue** %29 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !57
  %35 = or i8 %34, 64
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %29, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %39, %union.StackValue* %37, %struct.TValue* %28)
  br label %40

; <label>:40:                                     ; preds = %27, %16
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %42 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -1, i32 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !21
  %45 = and i8 %44, 15
  %46 = zext i8 %45 to i32
  ret i32 %46
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %struct.TValue* @luaH_getint(%struct.Table* nocapture, i64) unnamed_addr #2 {
  %3 = add i64 %1, -1
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %5 = load i32, i32* %4, align 4, !tbaa !114
  %6 = zext i32 %5 to i64
  %7 = icmp ult i64 %3, %6
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !115
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 %3
  br label %62

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %14 = load i8, i8* %13, align 1, !tbaa !116
  %15 = icmp slt i8 %14, 0
  br i1 %15, label %16, label %33

; <label>:16:                                     ; preds = %12
  %17 = add i32 %5, -1
  %18 = and i32 %17, %5
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %33, label %20

; <label>:20:                                     ; preds = %16
  %21 = add i32 %5, 1
  %22 = zext i32 %21 to i64
  %23 = icmp eq i64 %22, %1
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %20
  %25 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0)
  %26 = zext i32 %25 to i64
  %27 = icmp ult i64 %3, %26
  br i1 %27, label %28, label %33

; <label>:28:                                     ; preds = %24, %20
  %29 = trunc i64 %1 to i32
  store i32 %29, i32* %4, align 4, !tbaa !114
  %30 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !115
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 %3
  br label %62

; <label>:33:                                     ; preds = %24, %16, %12
  %34 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %35 = load %union.Node*, %union.Node** %34, align 8, !tbaa !123
  %36 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %37 = load i8, i8* %36, align 1, !tbaa !124
  %38 = zext i8 %37 to i32
  %39 = shl i32 1, %38
  %40 = add nsw i32 %39, -1
  %41 = trunc i64 %1 to i32
  %42 = and i32 %40, %41
  br label %43

; <label>:43:                                     ; preds = %58, %33
  %44 = phi i32 [ %42, %33 ], [ %60, %58 ]
  %45 = phi %union.Node* [ %35, %33 ], [ %47, %58 ]
  %46 = sext i32 %44 to i64
  %47 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46
  %48 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !21
  %50 = icmp eq i8 %49, 35
  br i1 %50, label %51, label %58

; <label>:51:                                     ; preds = %43
  %52 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 4
  %53 = bitcast %union.Value* %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21
  %55 = icmp eq i64 %54, %1
  br i1 %55, label %56, label %58

; <label>:56:                                     ; preds = %51
  %57 = bitcast %union.Node* %47 to %struct.TValue*
  br label %62

; <label>:58:                                     ; preds = %51, %43
  %59 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 3
  %60 = load i32, i32* %59, align 4, !tbaa !21
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %62, label %43

; <label>:62:                                     ; preds = %58, %56, %28, %8
  %63 = phi %struct.TValue* [ %11, %8 ], [ %32, %28 ], [ %57, %56 ], [ @absentkey, %58 ]
  ret %struct.TValue* %63
}

; Function Attrs: nounwind uwtable
define i32 @lua_gettable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %7, label %26

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %9, %struct.TValue* nonnull %12)
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %26, label %18

; <label>:18:                                     ; preds = %7
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %13 to i64*
  %22 = bitcast %struct.TValue* %20 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = load i8, i8* %14, align 8, !tbaa !22
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  br label %32

; <label>:26:                                     ; preds = %2, %7
  %27 = phi %struct.TValue* [ %13, %7 ], [ null, %2 ]
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %29 = load %union.StackValue*, %union.StackValue** %28, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %31, %union.StackValue* nonnull %30, %struct.TValue* %27)
  br label %32

; <label>:32:                                     ; preds = %26, %18
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %34 = load %union.StackValue*, %union.StackValue** %33, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 -1, i32 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !21
  %37 = and i8 %36, 15
  %38 = zext i8 %37 to i32
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TValue* @luaH_get(%struct.Table* nocapture, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %25 [
    i6 20, label %7
    i6 -29, label %11
    i6 0, label %27
    i6 19, label %15
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %1 to %struct.TString**
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !21
  %10 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* %9)
  br label %27

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %1 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %13)
  br label %27

; <label>:15:                                     ; preds = %2
  %16 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %16) #7
  %17 = bitcast %struct.TValue* %1 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  %19 = call fastcc i32 @luaV_flttointeger(double %18, i64* nonnull %3, i32 0)
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %15
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %16) #7
  br label %25

; <label>:22:                                     ; preds = %15
  %23 = load i64, i64* %3, align 8, !tbaa !109
  %24 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %23)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %16) #7
  br label %27

; <label>:25:                                     ; preds = %21, %2
  %26 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %1)
  br label %27

; <label>:27:                                     ; preds = %22, %2, %25, %11, %7
  %28 = phi %struct.TValue* [ %26, %25 ], [ %24, %22 ], [ %14, %11 ], [ %10, %7 ], [ @absentkey, %2 ]
  ret %struct.TValue* %28
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_finishget(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, %struct.TValue* readnone) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %5, %62
  %8 = phi %struct.TValue* [ %1, %5 ], [ %39, %62 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %63, %62 ]
  %10 = phi i32 [ 0, %5 ], [ %64, %62 ]
  %11 = icmp eq %struct.TValue* %9, null
  br i1 %11, label %12, label %19

; <label>:12:                                     ; preds = %7
  %13 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %8, i32 0)
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %38, !prof !33

; <label>:18:                                     ; preds = %12
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #17
  unreachable

; <label>:19:                                     ; preds = %7
  %20 = bitcast %struct.TValue* %8 to %struct.Table**
  %21 = load %struct.Table*, %struct.Table** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.Table, %struct.Table* %21, i64 0, i32 9
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  br i1 %24, label %36, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %23, i64 0, i32 3
  %27 = load i8, i8* %26, align 2, !tbaa !111
  %28 = and i8 %27, 1
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %30, label %36

; <label>:30:                                     ; preds = %25
  %31 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %31, i64 0, i32 40, i64 0
  %33 = load %struct.TString*, %struct.TString** %32, align 8, !tbaa !79
  %34 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %23, i32 0, %struct.TString* %33)
  %35 = icmp eq %struct.TValue* %34, null
  br i1 %35, label %36, label %38

; <label>:36:                                     ; preds = %25, %19, %30
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 0, i8* %37, align 8, !tbaa !21
  br label %67

; <label>:38:                                     ; preds = %30, %12
  %39 = phi %struct.TValue* [ %13, %12 ], [ %34, %30 ]
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %39, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = and i8 %41, 15
  %43 = icmp eq i8 %42, 6
  br i1 %43, label %44, label %45

; <label>:44:                                     ; preds = %38
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %39, %struct.TValue* %8, %struct.TValue* %2, %union.StackValue* %3)
  br label %67

; <label>:45:                                     ; preds = %38
  %46 = icmp eq i8 %41, 69
  br i1 %46, label %47, label %62

; <label>:47:                                     ; preds = %45
  %48 = bitcast %struct.TValue* %39 to %struct.Table**
  %49 = load %struct.Table*, %struct.Table** %48, align 8, !tbaa !21
  %50 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %49, %struct.TValue* %2)
  %51 = getelementptr inbounds %struct.TValue, %struct.TValue* %50, i64 0, i32 1
  %52 = load i8, i8* %51, align 8, !tbaa !22
  %53 = and i8 %52, 15
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %62, label %55

; <label>:55:                                     ; preds = %47
  %56 = getelementptr inbounds %struct.TValue, %struct.TValue* %50, i64 0, i32 1
  %57 = bitcast %struct.TValue* %50 to i64*
  %58 = bitcast %union.StackValue* %3 to i64*
  %59 = load i64, i64* %57, align 8
  store i64 %59, i64* %58, align 8
  %60 = load i8, i8* %56, align 8, !tbaa !22
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 %60, i8* %61, align 8, !tbaa !22
  br label %67

; <label>:62:                                     ; preds = %45, %47
  %63 = phi %struct.TValue* [ %50, %47 ], [ null, %45 ]
  %64 = add nuw nsw i32 %10, 1
  %65 = icmp ult i32 %64, 2000
  br i1 %65, label %7, label %66

; <label>:66:                                     ; preds = %62
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.198, i64 0, i64 0)) #17
  unreachable

; <label>:67:                                     ; preds = %55, %44, %36
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_getfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2)
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @lua_geti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %38

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = bitcast %struct.TValue* %5 to %struct.Table**
  %12 = load %struct.Table*, %struct.Table** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 5
  %14 = load i32, i32* %13, align 4, !tbaa !21
  %15 = zext i32 %14 to i64
  %16 = icmp ult i64 %10, %15
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 6
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %10
  br label %23

; <label>:21:                                     ; preds = %9
  %22 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %12, i64 %2)
  br label %23

; <label>:23:                                     ; preds = %21, %17
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %38, label %29

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = bitcast %union.StackValue** %30 to %struct.TValue**
  %32 = load %struct.TValue*, %struct.TValue** %31, align 8, !tbaa !20
  %33 = bitcast %struct.TValue* %24 to i64*
  %34 = bitcast %struct.TValue* %32 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = load i8, i8* %25, align 8, !tbaa !22
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  store i8 %36, i8* %37, align 8, !tbaa !22
  br label %45

; <label>:38:                                     ; preds = %3, %23
  %39 = phi %struct.TValue* [ %24, %23 ], [ null, %3 ]
  %40 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %40) #7
  %41 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %44 = load %union.StackValue*, %union.StackValue** %43, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %union.StackValue* %44, %struct.TValue* %39)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %40) #7
  br label %45

; <label>:45:                                     ; preds = %38, %29
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %47 = load %union.StackValue*, %union.StackValue** %46, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 1
  store %union.StackValue* %48, %union.StackValue** %46, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 0, i32 0, i32 1
  %50 = load i8, i8* %49, align 8, !tbaa !21
  %51 = and i8 %50, 15
  %52 = zext i8 %51 to i32
  ret i32 %52
}

; Function Attrs: nounwind uwtable
define i32 @lua_rawget(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0
  %7 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %3, %struct.TValue* nonnull %6)
  %8 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1
  store %union.StackValue* %9, %union.StackValue** %4, align 8, !tbaa !20
  %10 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %7)
  ret i32 %10
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.Table* @gettable(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = bitcast %struct.TValue* %3 to %struct.Table**
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !21
  ret %struct.Table* %5
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @finishrawget(%struct.lua_State* nocapture, %struct.TValue* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = and i8 %4, 15
  %6 = icmp eq i8 %5, 0
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  br i1 %6, label %15, label %10

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = bitcast %struct.TValue* %9 to i64*
  %13 = load i64, i64* %11, align 8
  store i64 %13, i64* %12, align 8
  %14 = load i8, i8* %3, align 8, !tbaa !22
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi i8 [ %14, %10 ], [ 0, %2 ]
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 %16, i8* %17, align 8, !tbaa !21
  %18 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %7, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 0, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 15
  %23 = zext i8 %22 to i32
  ret i32 %23
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_rawgeti(%struct.lua_State* nocapture, i32, i64) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %5 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %4, i64 %2)
  %6 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %5)
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define i32 @lua_rawgetp(%struct.lua_State* nocapture, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %7 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %6, %struct.TValue* nonnull %4)
  %10 = tail call fastcc i32 @finishrawget(%struct.lua_State* %0, %struct.TValue* %9)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define void @lua_createtable(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to %struct.Table**
  store %struct.Table* %4, %struct.Table** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 69, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  %12 = icmp sgt i32 %1, 0
  %13 = icmp sgt i32 %2, 0
  %14 = or i1 %12, %13
  br i1 %14, label %15, label %16

; <label>:15:                                     ; preds = %3
  tail call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %4, i32 %1, i32 %2)
  br label %16

; <label>:16:                                     ; preds = %3, %15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 3
  %20 = load i64, i64* %19, align 8, !tbaa !11
  %21 = icmp sgt i64 %20, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %16
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %23

; <label>:23:                                     ; preds = %22, %16
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.Table* @luaH_new(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 5, i64 56)
  %3 = bitcast %struct.GCObject* %2 to %struct.Table*
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2, i32 1
  %5 = bitcast i8* %4 to %struct.Table**
  store %struct.Table* null, %struct.Table** %5, align 8, !tbaa !125
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 3
  store i8 -1, i8* %6, align 2, !tbaa !111
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1
  %8 = bitcast %struct.GCObject* %7 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %8, align 8, !tbaa !115
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 5
  store i32 0, i32* %9, align 4, !tbaa !114
  tail call fastcc void @setnodevector(%struct.lua_State* %0, %struct.Table* %3, i32 0)
  ret %struct.Table* %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaH_resize(%struct.lua_State*, %struct.Table*, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.Table, align 8
  %6 = bitcast %struct.Table* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %6) #7
  %7 = tail call fastcc i32 @setlimittosize(%struct.Table* %1)
  call fastcc void @setnodevector(%struct.lua_State* %0, %struct.Table* nonnull %5, i32 %3)
  %8 = icmp ugt i32 %7, %2
  br i1 %8, label %9, label %28

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %2, i32* %10, align 4, !tbaa !114
  call fastcc void @exchangehashpart(%struct.Table* %1, %struct.Table* nonnull %5)
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %12 = zext i32 %2 to i64
  %13 = zext i32 %7 to i64
  br label %14

; <label>:14:                                     ; preds = %24, %9
  %15 = phi i64 [ %12, %9 ], [ %25, %24 ]
  %16 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !115
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 %15, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %24, label %21

; <label>:21:                                     ; preds = %14
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 %15
  %23 = add nuw nsw i64 %15, 1
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* nonnull %1, i64 %23, %struct.TValue* %22)
  br label %24

; <label>:24:                                     ; preds = %14, %21
  %25 = add nuw nsw i64 %15, 1
  %26 = icmp eq i64 %25, %13
  br i1 %26, label %27, label %14

; <label>:27:                                     ; preds = %24
  store i32 %7, i32* %10, align 4, !tbaa !114
  call fastcc void @exchangehashpart(%struct.Table* nonnull %1, %struct.Table* nonnull %5)
  br label %28

; <label>:28:                                     ; preds = %27, %4
  %29 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %30 = bitcast %struct.TValue** %29 to i8**
  %31 = load i8*, i8** %30, align 8, !tbaa !115
  %32 = zext i32 %7 to i64
  %33 = shl nuw nsw i64 %32, 4
  %34 = zext i32 %2 to i64
  %35 = shl nuw nsw i64 %34, 4
  %36 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %31, i64 %33, i64 %35)
  %37 = icmp eq i8* %36, null
  %38 = icmp ne i32 %2, 0
  %39 = and i1 %38, %37
  br i1 %39, label %40, label %41, !prof !33

; <label>:40:                                     ; preds = %28
  call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* nonnull %5)
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #17
  unreachable

; <label>:41:                                     ; preds = %28
  call fastcc void @exchangehashpart(%struct.Table* nonnull %1, %struct.Table* nonnull %5)
  store i8* %36, i8** %30, align 8, !tbaa !115
  %42 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %2, i32* %42, align 4, !tbaa !114
  %43 = icmp ult i32 %7, %2
  br i1 %43, label %44, label %53

; <label>:44:                                     ; preds = %41
  %45 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !115
  %46 = zext i32 %7 to i64
  %47 = zext i32 %2 to i64
  br label %48

; <label>:48:                                     ; preds = %48, %44
  %49 = phi i64 [ %46, %44 ], [ %51, %48 ]
  %50 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 %49, i32 1
  store i8 16, i8* %50, align 8, !tbaa !22
  %51 = add nuw nsw i64 %49, 1
  %52 = icmp eq i64 %51, %47
  br i1 %52, label %53, label %48

; <label>:53:                                     ; preds = %48, %41
  call fastcc void @reinsert(%struct.lua_State* %0, %struct.Table* nonnull %5, %struct.Table* nonnull %1)
  call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* nonnull %5)
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %6) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_getmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %3 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %2
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  br i1 %24, label %33, label %25

; <label>:25:                                     ; preds = %21
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %28 to %struct.Table**
  store %struct.Table* %23, %struct.Table** %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 69, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %26, align 8, !tbaa !20
  br label %33

; <label>:33:                                     ; preds = %21, %25
  %34 = phi i32 [ 1, %25 ], [ 0, %21 ]
  ret i32 %34
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_getiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = icmp slt i32 %2, 1
  br i1 %4, label %13, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %7 = bitcast %struct.TValue* %6 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp slt i32 %11, %2
  br i1 %12, label %13, label %18

; <label>:13:                                     ; preds = %5, %3
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 0, i8* %17, align 8, !tbaa !21
  br label %36

; <label>:18:                                     ; preds = %5
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = bitcast %union.StackValue** %19 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = add nsw i32 %2, -1
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %23, i32 0
  %25 = bitcast %struct.TValue* %24 to i64*
  %26 = bitcast %struct.TValue* %21 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %23, i32 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !22
  %31 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !21
  %34 = and i8 %33, 15
  %35 = zext i8 %34 to i32
  br label %36

; <label>:36:                                     ; preds = %18, %13
  %37 = phi i32 [ -1, %13 ], [ %35, %18 ]
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %39 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 1
  store %union.StackValue* %40, %union.StackValue** %38, align 8, !tbaa !20
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define void @lua_setglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2)
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @auxsetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %45

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %10 = bitcast %struct.TValue* %1 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %11, %struct.TString* %4)
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %45, label %17

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %12 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  store i8 %25, i8* %13, align 8, !tbaa !22
  %26 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !21
  %29 = and i8 %28, 64
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %59, label %31

; <label>:31:                                     ; preds = %17
  %32 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !53
  %35 = and i8 %34, 32
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %59, label %37

; <label>:37:                                     ; preds = %31
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 0, i32 0
  %39 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %39, i64 0, i32 2
  %41 = load i8, i8* %40, align 1, !tbaa !53
  %42 = and i8 %41, 24
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %59, label %44

; <label>:44:                                     ; preds = %37
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %32)
  br label %59

; <label>:45:                                     ; preds = %3, %8
  %46 = phi %struct.TValue* [ %12, %8 ], [ null, %3 ]
  %47 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %48 = bitcast %union.StackValue** %47 to %struct.TValue**
  %49 = load %struct.TValue*, %struct.TValue** %48, align 8, !tbaa !20
  %50 = bitcast %struct.TValue* %49 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %50, align 8, !tbaa !21
  %51 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %52 = load i8, i8* %51, align 8, !tbaa !57
  %53 = or i8 %52, 64
  %54 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 0, i32 1
  store i8 %53, i8* %54, align 8, !tbaa !22
  %55 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !20
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 1
  store %union.StackValue* %56, %union.StackValue** %47, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 0, i32 0
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %57, %struct.TValue* nonnull %58, %struct.TValue* %46)
  br label %59

; <label>:59:                                     ; preds = %44, %17, %31, %37, %45
  %60 = phi %union.StackValue** [ %47, %45 ], [ %18, %37 ], [ %18, %31 ], [ %18, %17 ], [ %18, %44 ]
  %61 = phi i64 [ -2, %45 ], [ -1, %37 ], [ -1, %31 ], [ -1, %17 ], [ -1, %44 ]
  %62 = load %union.StackValue*, %union.StackValue** %60, align 8, !tbaa !20
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %62, i64 %61
  store %union.StackValue* %63, %union.StackValue** %60, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_settable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %7, label %46

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %9 = bitcast %struct.TValue* %3 to %struct.Table**
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 -2, i32 0
  %14 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %10, %struct.TValue* nonnull %13)
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = and i8 %16, 15
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %46, label %19

; <label>:19:                                     ; preds = %7
  %20 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 -1, i32 0
  %22 = bitcast %struct.TValue* %21 to i64*
  %23 = bitcast %struct.TValue* %14 to i64*
  %24 = load i64, i64* %22, align 8
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 -1, i32 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  store i8 %26, i8* %15, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !21
  %30 = and i8 %29, 64
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %52, label %32

; <label>:32:                                     ; preds = %19
  %33 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !21
  %34 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %33, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !53
  %36 = and i8 %35, 32
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %52, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 0, i32 0
  %40 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !21
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %40, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !53
  %43 = and i8 %42, 24
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %52, label %45

; <label>:45:                                     ; preds = %38
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %33)
  br label %52

; <label>:46:                                     ; preds = %2, %7
  %47 = phi %struct.TValue* [ %14, %7 ], [ null, %2 ]
  %48 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %49 = load %union.StackValue*, %union.StackValue** %48, align 8, !tbaa !20
  %50 = getelementptr inbounds %union.StackValue, %union.StackValue* %49, i64 -2, i32 0
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %49, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %50, %struct.TValue* nonnull %51, %struct.TValue* %47)
  br label %52

; <label>:52:                                     ; preds = %38, %32, %19, %45, %46
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %54 = load %union.StackValue*, %union.StackValue** %53, align 8, !tbaa !20
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 -2
  store %union.StackValue* %55, %union.StackValue** %53, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaC_barrierback_(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %4 = load i8, i8* %3, align 1, !tbaa !53
  %5 = and i8 %4, 7
  %6 = icmp eq i8 %5, 6
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %9, i64 0, i32 24
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !126
  %13 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %1)
  %14 = bitcast %struct.GCObject** %13 to i64*
  store i64 %12, i64* %14, align 8, !tbaa !79
  store %struct.GCObject* %1, %struct.GCObject** %10, align 8, !tbaa !126
  br label %15

; <label>:15:                                     ; preds = %2, %7
  %16 = and i8 %4, -40
  %17 = or i8 %16, 5
  store i8 %17, i8* %3, align 1, !tbaa !53
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_finishset(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %5, %111
  %8 = phi %struct.TValue* [ %1, %5 ], [ %70, %111 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %112, %111 ]
  %10 = phi i32 [ 0, %5 ], [ %113, %111 ]
  %11 = icmp eq %struct.TValue* %9, null
  br i1 %11, label %62, label %12

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 0, i32 0
  %14 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 2, i32 1
  %16 = bitcast i8* %15 to %struct.Table**
  %17 = load %struct.Table*, %struct.Table** %16, align 8, !tbaa !125
  %18 = icmp eq %struct.Table* %17, null
  br i1 %18, label %30, label %19

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 3
  %21 = load i8, i8* %20, align 2, !tbaa !111
  %22 = and i8 %21, 2
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %19
  %25 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 40, i64 1
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !79
  %28 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %17, i32 1, %struct.TString* %27)
  %29 = icmp eq %struct.TValue* %28, null
  br i1 %29, label %30, label %69

; <label>:30:                                     ; preds = %19, %12, %24
  %31 = bitcast %struct.GCObject* %14 to %struct.Table*
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = icmp eq i8 %33, 32
  br i1 %34, label %35, label %37

; <label>:35:                                     ; preds = %30
  %36 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %31, %struct.TValue* %2)
  br label %37

; <label>:37:                                     ; preds = %35, %30
  %38 = phi %struct.TValue* [ %36, %35 ], [ %9, %30 ]
  %39 = bitcast %struct.TValue* %3 to i64*
  %40 = bitcast %struct.TValue* %38 to i64*
  %41 = load i64, i64* %39, align 8
  store i64 %41, i64* %40, align 8
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %43 = load i8, i8* %42, align 8, !tbaa !22
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 %43, i8* %44, align 8, !tbaa !22
  %45 = getelementptr inbounds %struct.Table, %struct.Table* %31, i64 0, i32 3
  store i8 0, i8* %45, align 2, !tbaa !111
  %46 = load i8, i8* %42, align 8, !tbaa !22
  %47 = and i8 %46, 64
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %116, label %49

; <label>:49:                                     ; preds = %37
  %50 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 0, i32 2
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = and i8 %51, 32
  %53 = icmp eq i8 %52, 0
  br i1 %53, label %116, label %54

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %56 = load %struct.GCObject*, %struct.GCObject** %55, align 8, !tbaa !21
  %57 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %56, i64 0, i32 2
  %58 = load i8, i8* %57, align 1, !tbaa !53
  %59 = and i8 %58, 24
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %116, label %61

; <label>:61:                                     ; preds = %54
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %14)
  br label %116

; <label>:62:                                     ; preds = %7
  %63 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %8, i32 1)
  %64 = getelementptr inbounds %struct.TValue, %struct.TValue* %63, i64 0, i32 1
  %65 = load i8, i8* %64, align 8, !tbaa !22
  %66 = and i8 %65, 15
  %67 = icmp eq i8 %66, 0
  br i1 %67, label %68, label %69, !prof !33

; <label>:68:                                     ; preds = %62
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #17
  unreachable

; <label>:69:                                     ; preds = %24, %62
  %70 = phi %struct.TValue* [ %63, %62 ], [ %28, %24 ]
  %71 = getelementptr inbounds %struct.TValue, %struct.TValue* %70, i64 0, i32 1
  %72 = load i8, i8* %71, align 8, !tbaa !22
  %73 = and i8 %72, 15
  %74 = icmp eq i8 %73, 6
  br i1 %74, label %75, label %76

; <label>:75:                                     ; preds = %69
  tail call fastcc void @luaT_callTM(%struct.lua_State* %0, %struct.TValue* %70, %struct.TValue* %8, %struct.TValue* %2, %struct.TValue* %3)
  br label %116

; <label>:76:                                     ; preds = %69
  %77 = icmp eq i8 %72, 69
  br i1 %77, label %78, label %111

; <label>:78:                                     ; preds = %76
  %79 = bitcast %struct.TValue* %70 to %struct.Table**
  %80 = load %struct.Table*, %struct.Table** %79, align 8, !tbaa !21
  %81 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %80, %struct.TValue* %2)
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %81, i64 0, i32 1
  %83 = load i8, i8* %82, align 8, !tbaa !22
  %84 = and i8 %83, 15
  %85 = icmp eq i8 %84, 0
  br i1 %85, label %111, label %86

; <label>:86:                                     ; preds = %78
  %87 = getelementptr inbounds %struct.TValue, %struct.TValue* %81, i64 0, i32 1
  %88 = bitcast %struct.TValue* %3 to i64*
  %89 = bitcast %struct.TValue* %81 to i64*
  %90 = load i64, i64* %88, align 8
  store i64 %90, i64* %89, align 8
  %91 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %92 = load i8, i8* %91, align 8, !tbaa !22
  store i8 %92, i8* %87, align 8, !tbaa !22
  %93 = load i8, i8* %91, align 8, !tbaa !22
  %94 = and i8 %93, 64
  %95 = icmp eq i8 %94, 0
  br i1 %95, label %116, label %96

; <label>:96:                                     ; preds = %86
  %97 = getelementptr inbounds %struct.TValue, %struct.TValue* %70, i64 0, i32 0, i32 0
  %98 = load %struct.GCObject*, %struct.GCObject** %97, align 8, !tbaa !21
  %99 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %98, i64 0, i32 2
  %100 = load i8, i8* %99, align 1, !tbaa !53
  %101 = and i8 %100, 32
  %102 = icmp eq i8 %101, 0
  br i1 %102, label %116, label %103

; <label>:103:                                    ; preds = %96
  %104 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %105 = load %struct.GCObject*, %struct.GCObject** %104, align 8, !tbaa !21
  %106 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %105, i64 0, i32 2
  %107 = load i8, i8* %106, align 1, !tbaa !53
  %108 = and i8 %107, 24
  %109 = icmp eq i8 %108, 0
  br i1 %109, label %116, label %110

; <label>:110:                                    ; preds = %103
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %98)
  br label %116

; <label>:111:                                    ; preds = %76, %78
  %112 = phi %struct.TValue* [ %81, %78 ], [ null, %76 ]
  %113 = add nuw nsw i32 %10, 1
  %114 = icmp ult i32 %113, 2000
  br i1 %114, label %7, label %115

; <label>:115:                                    ; preds = %111
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.200, i64 0, i64 0)) #17
  unreachable

; <label>:116:                                    ; preds = %61, %37, %49, %54, %75, %103, %96, %86, %110
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_setfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_seti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %58

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 0, i32 0
  %12 = bitcast %struct.TValue* %5 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !21
  %16 = zext i32 %15 to i64
  %17 = icmp ult i64 %10, %16
  br i1 %17, label %18, label %22

; <label>:18:                                     ; preds = %9
  %19 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 6
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 %10
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %13, i64 %2)
  br label %24

; <label>:24:                                     ; preds = %22, %18
  %25 = phi %struct.TValue* [ %21, %18 ], [ %23, %22 ]
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = and i8 %27, 15
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %58, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0
  %34 = bitcast %struct.TValue* %33 to i64*
  %35 = bitcast %struct.TValue* %25 to i64*
  %36 = load i64, i64* %34, align 8
  store i64 %36, i64* %35, align 8
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  store i8 %38, i8* %26, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !21
  %42 = and i8 %41, 64
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %66, label %44

; <label>:44:                                     ; preds = %30
  %45 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %45, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !53
  %48 = and i8 %47, 32
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %66, label %50

; <label>:50:                                     ; preds = %44
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 0, i32 0
  %52 = load %struct.GCObject*, %struct.GCObject** %51, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %52, i64 0, i32 2
  %54 = load i8, i8* %53, align 1, !tbaa !53
  %55 = and i8 %54, 24
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %66, label %57

; <label>:57:                                     ; preds = %50
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %45)
  br label %66

; <label>:58:                                     ; preds = %3, %24
  %59 = phi %struct.TValue* [ %25, %24 ], [ null, %3 ]
  %60 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %60) #7
  %61 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %61, align 8, !tbaa !21
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %62, align 8, !tbaa !22
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %64 = load %union.StackValue*, %union.StackValue** %63, align 8, !tbaa !20
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 -1, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %struct.TValue* nonnull %65, %struct.TValue* %59)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %60) #7
  br label %66

; <label>:66:                                     ; preds = %50, %44, %30, %57, %58
  %67 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %68 = load %union.StackValue*, %union.StackValue** %67, align 8, !tbaa !20
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1
  store %union.StackValue* %69, %union.StackValue** %67, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawset(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -2, i32 0
  %7 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %3, %struct.TValue* nonnull %6)
  %8 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %10 = bitcast %struct.TValue* %9 to i64*
  %11 = bitcast %struct.TValue* %7 to i64*
  %12 = load i64, i64* %10, align 8
  store i64 %12, i64* %11, align 8
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 %14, i8* %15, align 8, !tbaa !22
  %16 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 3
  store i8 0, i8* %16, align 2, !tbaa !111
  %17 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !21
  %20 = and i8 %19, 64
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %36, label %22

; <label>:22:                                     ; preds = %2
  %23 = bitcast %struct.Table* %3 to %struct.GCObject*
  %24 = getelementptr inbounds %struct.Table, %struct.Table* %3, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = and i8 %25, 32
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %36, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0, i32 0, i32 0
  %30 = load %struct.GCObject*, %struct.GCObject** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %30, i64 0, i32 2
  %32 = load i8, i8* %31, align 1, !tbaa !53
  %33 = and i8 %32, 24
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %36, label %35

; <label>:35:                                     ; preds = %28
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %23)
  br label %36

; <label>:36:                                     ; preds = %28, %22, %2, %35
  %37 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 -2
  store %union.StackValue* %38, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TValue* @luaH_set(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %1, %struct.TValue* %2)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 32
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %2)
  br label %10

; <label>:10:                                     ; preds = %3, %8
  %11 = phi %struct.TValue* [ %9, %8 ], [ %4, %3 ]
  ret %struct.TValue* %11
}

; Function Attrs: nounwind uwtable
define void @lua_rawseti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %4, i64 %2, %struct.TValue* nonnull %7)
  %8 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !21
  %11 = and i8 %10, 64
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %27, label %13

; <label>:13:                                     ; preds = %3
  %14 = bitcast %struct.Table* %4 to %struct.GCObject*
  %15 = getelementptr inbounds %struct.Table, %struct.Table* %4, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !21
  %17 = and i8 %16, 32
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %27, label %19

; <label>:19:                                     ; preds = %13
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 0, i32 0
  %21 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !53
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %14)
  br label %27

; <label>:27:                                     ; preds = %19, %13, %3, %26
  %28 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 -1
  store %union.StackValue* %29, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaH_setint(%struct.lua_State*, %struct.Table*, i64, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %1, i64 %2)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 32
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %4
  %11 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #7
  %12 = bitcast %struct.TValue* %5 to i64*
  store i64 %2, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %5)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #7
  br label %15

; <label>:15:                                     ; preds = %4, %10
  %16 = phi %struct.TValue* [ %14, %10 ], [ %6, %4 ]
  %17 = bitcast %struct.TValue* %3 to i64*
  %18 = bitcast %struct.TValue* %16 to i64*
  %19 = load i64, i64* %17, align 8
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 %21, i8* %22, align 8, !tbaa !22
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_rawsetp(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %7 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %6, %struct.TValue* nonnull %4)
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = bitcast %struct.TValue* %12 to i64*
  %14 = bitcast %struct.TValue* %9 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %38, label %24

; <label>:24:                                     ; preds = %3
  %25 = bitcast %struct.Table* %6 to %struct.GCObject*
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = and i8 %27, 32
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %38, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !53
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %30
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %25)
  br label %38

; <label>:38:                                     ; preds = %30, %24, %3, %37
  %39 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1
  store %union.StackValue* %40, %union.StackValue** %10, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_setmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !21
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %15, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 0, i32 0
  %12 = bitcast %struct.GCObject** %11 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = bitcast %struct.Table* %13 to %union.GCUnion*
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi %union.GCUnion* [ %14, %10 ], [ null, %2 ]
  %17 = phi %struct.Table* [ %13, %10 ], [ null, %2 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = trunc i8 %19 to i4
  switch i4 %20, label %64 [
    i4 5, label %21
    i4 7, label %43
  ]

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %23 = bitcast %struct.TValue* %3 to %struct.Table**
  %24 = load %struct.Table*, %struct.Table** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.Table, %struct.Table* %24, i64 0, i32 9
  %26 = bitcast %struct.Table** %25 to %union.GCUnion**
  store %union.GCUnion* %16, %union.GCUnion** %26, align 8, !tbaa !21
  %27 = icmp eq %struct.Table* %17, null
  br i1 %27, label %70, label %28

; <label>:28:                                     ; preds = %21
  %29 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !53
  %32 = and i8 %31, 32
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %41, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %36 = load i8, i8* %35, align 1, !tbaa !116
  %37 = and i8 %36, 24
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %41, label %39

; <label>:39:                                     ; preds = %34
  %40 = bitcast %struct.Table* %17 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %29, %struct.GCObject* %40)
  br label %41

; <label>:41:                                     ; preds = %34, %28, %39
  %42 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %42, %struct.Table* nonnull %17)
  br label %70

; <label>:43:                                     ; preds = %15
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %45 = bitcast %struct.TValue* %3 to %struct.Udata**
  %46 = load %struct.Udata*, %struct.Udata** %45, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.Udata, %struct.Udata* %46, i64 0, i32 5
  store %struct.Table* %17, %struct.Table** %47, align 8, !tbaa !21
  %48 = icmp eq %struct.Table* %17, null
  br i1 %48, label %70, label %49

; <label>:49:                                     ; preds = %43
  %50 = load %struct.GCObject*, %struct.GCObject** %44, align 8, !tbaa !21
  %51 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %50, i64 0, i32 2
  %52 = load i8, i8* %51, align 1, !tbaa !21
  %53 = and i8 %52, 32
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %62, label %55

; <label>:55:                                     ; preds = %49
  %56 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %57 = load i8, i8* %56, align 1, !tbaa !116
  %58 = and i8 %57, 24
  %59 = icmp eq i8 %58, 0
  br i1 %59, label %62, label %60

; <label>:60:                                     ; preds = %55
  %61 = bitcast %union.GCUnion* %16 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %50, %struct.GCObject* %61)
  br label %62

; <label>:62:                                     ; preds = %55, %49, %60
  %63 = load %struct.GCObject*, %struct.GCObject** %44, align 8, !tbaa !21
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %63, %struct.Table* nonnull %17)
  br label %70

; <label>:64:                                     ; preds = %15
  %65 = and i8 %19, 15
  %66 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %67 = load %struct.global_State*, %struct.global_State** %66, align 8, !tbaa !2
  %68 = zext i8 %65 to i64
  %69 = getelementptr inbounds %struct.global_State, %struct.global_State* %67, i64 0, i32 41, i64 %68
  store %struct.Table* %17, %struct.Table** %69, align 8, !tbaa !79
  br label %70

; <label>:70:                                     ; preds = %21, %43, %62, %41, %64
  %71 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %72 = getelementptr inbounds %union.StackValue, %union.StackValue* %71, i64 -1
  store %union.StackValue* %72, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_checkfinalizer(%struct.lua_State* nocapture readonly, %struct.GCObject*, %struct.Table*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %7 = load i8, i8* %6, align 1, !tbaa !53
  %8 = and i8 %7, 64
  %9 = icmp ne i8 %8, 0
  %10 = icmp eq %struct.Table* %2, null
  %11 = or i1 %10, %9
  br i1 %11, label %80, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %2, i64 0, i32 3
  %14 = load i8, i8* %13, align 2, !tbaa !111
  %15 = and i8 %14, 4
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %17, label %80

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 40, i64 2
  %19 = load %struct.TString*, %struct.TString** %18, align 8, !tbaa !79
  %20 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %2, i32 2, %struct.TString* %19)
  %21 = icmp eq %struct.TValue* %20, null
  br i1 %21, label %80, label %22

; <label>:22:                                     ; preds = %17
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %24 = load i8, i8* %23, align 1, !tbaa !62
  %25 = add i8 %24, -3
  %26 = icmp ult i8 %25, 4
  br i1 %26, label %27, label %40

; <label>:27:                                     ; preds = %22
  %28 = load i8, i8* %6, align 1, !tbaa !53
  %29 = and i8 %28, -64
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %31 = load i8, i8* %30, align 4, !tbaa !15
  %32 = and i8 %31, 24
  %33 = or i8 %32, %29
  store i8 %33, i8* %6, align 1, !tbaa !53
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 21
  %35 = load %struct.GCObject**, %struct.GCObject*** %34, align 8, !tbaa !127
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 0
  %37 = icmp eq %struct.GCObject** %35, %36
  br i1 %37, label %38, label %64

; <label>:38:                                     ; preds = %27
  %39 = tail call fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* nonnull %0, %struct.GCObject** %35)
  store %struct.GCObject** %39, %struct.GCObject*** %34, align 8, !tbaa !127
  br label %64

; <label>:40:                                     ; preds = %22
  %41 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 30
  %42 = load %struct.GCObject*, %struct.GCObject** %41, align 8, !tbaa !128
  %43 = icmp eq %struct.GCObject* %42, %1
  br i1 %43, label %44, label %48

; <label>:44:                                     ; preds = %40
  %45 = bitcast %struct.GCObject* %1 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !129
  %47 = bitcast %struct.GCObject** %41 to i64*
  store i64 %46, i64* %47, align 8, !tbaa !128
  br label %48

; <label>:48:                                     ; preds = %44, %40
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 31
  %50 = load %struct.GCObject*, %struct.GCObject** %49, align 8, !tbaa !130
  %51 = icmp eq %struct.GCObject* %50, %1
  br i1 %51, label %52, label %56

; <label>:52:                                     ; preds = %48
  %53 = bitcast %struct.GCObject* %1 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !129
  %55 = bitcast %struct.GCObject** %49 to i64*
  store i64 %54, i64* %55, align 8, !tbaa !130
  br label %56

; <label>:56:                                     ; preds = %52, %48
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 32
  %58 = load %struct.GCObject*, %struct.GCObject** %57, align 8, !tbaa !131
  %59 = icmp eq %struct.GCObject* %58, %1
  br i1 %59, label %60, label %64

; <label>:60:                                     ; preds = %56
  %61 = bitcast %struct.GCObject* %1 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !129
  %63 = bitcast %struct.GCObject** %57 to i64*
  store i64 %62, i64* %63, align 8, !tbaa !131
  br label %64

; <label>:64:                                     ; preds = %56, %60, %27, %38
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  br label %66

; <label>:66:                                     ; preds = %66, %64
  %67 = phi %struct.GCObject** [ %65, %64 ], [ %70, %66 ]
  %68 = load %struct.GCObject*, %struct.GCObject** %67, align 8, !tbaa !79
  %69 = icmp eq %struct.GCObject* %68, %1
  %70 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %68, i64 0, i32 0
  br i1 %69, label %71, label %66

; <label>:71:                                     ; preds = %66
  %72 = bitcast %struct.GCObject* %1 to i64*
  %73 = load i64, i64* %72, align 8, !tbaa !129
  %74 = bitcast %struct.GCObject** %67 to i64*
  store i64 %73, i64* %74, align 8, !tbaa !79
  %75 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 22
  %76 = bitcast %struct.GCObject** %75 to i64*
  %77 = load i64, i64* %76, align 8, !tbaa !132
  store i64 %77, i64* %72, align 8, !tbaa !129
  store %struct.GCObject* %1, %struct.GCObject** %75, align 8, !tbaa !132
  %78 = load i8, i8* %6, align 1, !tbaa !53
  %79 = or i8 %78, 64
  store i8 %79, i8* %6, align 1, !tbaa !53
  br label %80

; <label>:80:                                     ; preds = %3, %12, %17, %71
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i32 @lua_setiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = add i32 %2, -1
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %7 = bitcast %struct.TValue* %4 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp ult i32 %5, %11
  br i1 %12, label %13, label %44

; <label>:13:                                     ; preds = %3
  %14 = sext i32 %5 to i64
  %15 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %14, i32 0
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0
  %19 = bitcast %struct.TValue* %18 to i64*
  %20 = bitcast %struct.TValue* %15 to i64*
  %21 = load i64, i64* %19, align 8
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %14, i32 0, i32 1
  store i8 %23, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 -1, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !21
  %28 = and i8 %27, 64
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %44, label %30

; <label>:30:                                     ; preds = %13
  %31 = load %struct.GCObject*, %struct.GCObject** %6, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %31, i64 0, i32 2
  %33 = load i8, i8* %32, align 1, !tbaa !53
  %34 = and i8 %33, 32
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %44, label %36

; <label>:36:                                     ; preds = %30
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 -1, i32 0, i32 0, i32 0
  %38 = load %struct.GCObject*, %struct.GCObject** %37, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %38, i64 0, i32 2
  %40 = load i8, i8* %39, align 1, !tbaa !53
  %41 = and i8 %40, 24
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %44, label %43

; <label>:43:                                     ; preds = %36
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %31)
  br label %44

; <label>:44:                                     ; preds = %43, %13, %30, %36, %3
  %45 = phi i32 [ 0, %3 ], [ 1, %36 ], [ 1, %30 ], [ 1, %13 ], [ 1, %43 ]
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %47 = load %union.StackValue*, %union.StackValue** %46, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  store %union.StackValue* %48, %union.StackValue** %46, align 8, !tbaa !20
  ret i32 %45
}

; Function Attrs: nounwind uwtable
define void @lua_callk(%struct.lua_State*, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = add nsw i32 %1, 1
  %9 = sext i32 %8 to i64
  %10 = sub nsw i64 0, %9
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %10
  %12 = icmp eq i32 (%struct.lua_State*, i32, i64)* %4, null
  br i1 %12, label %23, label %13

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %15 = load i32, i32* %14, align 8, !tbaa !40
  %16 = icmp ult i32 %15, 65536
  br i1 %16, label %17, label %23

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !35
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %4, i32 (%struct.lua_State*, i32, i64)** %20, align 8, !tbaa !21
  %21 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !35
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %21, i64 0, i32 4, i32 0, i32 2
  store i64 %3, i64* %22, align 8, !tbaa !21
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2)
  br label %24

; <label>:23:                                     ; preds = %5, %13
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2)
  br label %24

; <label>:24:                                     ; preds = %23, %17
  %25 = icmp slt i32 %2, 0
  br i1 %25, label %26, label %34

; <label>:26:                                     ; preds = %24
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %28 = load %struct.CallInfo*, %struct.CallInfo** %27, align 8, !tbaa !35
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %28, i64 0, i32 1
  %30 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !49
  %31 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %32 = icmp ult %union.StackValue* %30, %31
  br i1 %32, label %33, label %34

; <label>:33:                                     ; preds = %26
  store %union.StackValue* %31, %union.StackValue** %29, align 8, !tbaa !49
  br label %34

; <label>:34:                                     ; preds = %33, %26, %24
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_call(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  br label %5

; <label>:5:                                      ; preds = %150, %3
  %6 = load i8, i8* %4, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %150 [
    i6 -10, label %8
    i6 -26, label %12
    i6 22, label %74
  ]

; <label>:8:                                      ; preds = %5
  %9 = bitcast %union.StackValue* %1 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %14

; <label>:12:                                     ; preds = %5
  %13 = bitcast %union.StackValue* %1 to i32 (%struct.lua_State*)**
  br label %14

; <label>:14:                                     ; preds = %12, %8
  %15 = phi i32 (%struct.lua_State*)** [ %13, %12 ], [ %11, %8 ]
  %16 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !45
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !20
  %23 = sub i64 %19, %22
  %24 = icmp slt i64 %23, 336
  br i1 %24, label %25, label %43

; <label>:25:                                     ; preds = %14
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %27 = bitcast %union.StackValue** %26 to i64*
  %28 = load i64, i64* %27, align 8, !tbaa !34
  %29 = ptrtoint %union.StackValue* %1 to i64
  %30 = sub i64 %29, %28
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %32 = load %struct.global_State*, %struct.global_State** %31, align 8, !tbaa !2
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %32, i64 0, i32 3
  %34 = load i64, i64* %33, align 8, !tbaa !11
  %35 = icmp sgt i64 %34, 0
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %25
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %37

; <label>:37:                                     ; preds = %36, %25
  %38 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1)
  %39 = bitcast %union.StackValue** %26 to i8**
  %40 = load i8*, i8** %39, align 8, !tbaa !34
  %41 = getelementptr inbounds i8, i8* %40, i64 %30
  %42 = bitcast i8* %41 to %union.StackValue*
  br label %43

; <label>:43:                                     ; preds = %14, %37
  %44 = phi %union.StackValue* [ %42, %37 ], [ %1, %14 ]
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %46 = load %struct.CallInfo*, %struct.CallInfo** %45, align 8, !tbaa !35
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %46, i64 0, i32 3
  %48 = load %struct.CallInfo*, %struct.CallInfo** %47, align 8, !tbaa !89
  %49 = icmp eq %struct.CallInfo* %48, null
  br i1 %49, label %50, label %52

; <label>:50:                                     ; preds = %43
  %51 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0)
  br label %52

; <label>:52:                                     ; preds = %43, %50
  %53 = phi %struct.CallInfo* [ %51, %50 ], [ %48, %43 ]
  store %struct.CallInfo* %53, %struct.CallInfo** %45, align 8, !tbaa !35
  %54 = trunc i32 %2 to i16
  %55 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 6
  store i16 %54, i16* %55, align 4, !tbaa !48
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 7
  store i16 2, i16* %56, align 2, !tbaa !46
  %57 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 20
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 1
  store %union.StackValue* %58, %union.StackValue** %59, align 8, !tbaa !49
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 0
  store %union.StackValue* %44, %union.StackValue** %60, align 8, !tbaa !47
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %62 = load i32, i32* %61, align 8, !tbaa !23
  %63 = and i32 %62, 1
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %72, label %65

; <label>:65:                                     ; preds = %52
  %66 = load i64, i64* %21, align 8, !tbaa !20
  %67 = ptrtoint %union.StackValue* %44 to i64
  %68 = sub i64 %66, %67
  %69 = lshr exact i64 %68, 4
  %70 = trunc i64 %69 to i32
  %71 = add nsw i32 %70, -1
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 0, i32 -1, i32 1, i32 %71)
  br label %72

; <label>:72:                                     ; preds = %52, %65
  %73 = tail call i32 %16(%struct.lua_State* nonnull %0) #7
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %53, i32 %73)
  br label %151

; <label>:74:                                     ; preds = %5
  %75 = bitcast %union.StackValue* %1 to %struct.LClosure**
  %76 = load %struct.LClosure*, %struct.LClosure** %75, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %76, i64 0, i32 5
  %78 = load %struct.Proto*, %struct.Proto** %77, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %80 = bitcast %union.StackValue** %79 to i64*
  %81 = load i64, i64* %80, align 8, !tbaa !20
  %82 = ptrtoint %union.StackValue* %1 to i64
  %83 = sub i64 %81, %82
  %84 = lshr exact i64 %83, 4
  %85 = trunc i64 %84 to i32
  %86 = add nsw i32 %85, -1
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 3
  %88 = load i8, i8* %87, align 2, !tbaa !95
  %89 = zext i8 %88 to i32
  %90 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 5
  %91 = load i8, i8* %90, align 4, !tbaa !133
  %92 = zext i8 %91 to i32
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %94 = bitcast %union.StackValue** %93 to i64*
  %95 = load i64, i64* %94, align 8, !tbaa !45
  %96 = sub i64 %95, %81
  %97 = ashr exact i64 %96, 4
  %98 = zext i8 %91 to i64
  %99 = icmp sgt i64 %97, %98
  br i1 %99, label %117, label %100

; <label>:100:                                    ; preds = %74
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %102 = bitcast %union.StackValue** %101 to i64*
  %103 = load i64, i64* %102, align 8, !tbaa !34
  %104 = sub i64 %82, %103
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %106 = load %struct.global_State*, %struct.global_State** %105, align 8, !tbaa !2
  %107 = getelementptr inbounds %struct.global_State, %struct.global_State* %106, i64 0, i32 3
  %108 = load i64, i64* %107, align 8, !tbaa !11
  %109 = icmp sgt i64 %108, 0
  br i1 %109, label %110, label %111

; <label>:110:                                    ; preds = %100
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %111

; <label>:111:                                    ; preds = %110, %100
  %112 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %92, i32 1)
  %113 = bitcast %union.StackValue** %101 to i8**
  %114 = load i8*, i8** %113, align 8, !tbaa !34
  %115 = getelementptr inbounds i8, i8* %114, i64 %104
  %116 = bitcast i8* %115 to %union.StackValue*
  br label %117

; <label>:117:                                    ; preds = %74, %111
  %118 = phi %union.StackValue* [ %116, %111 ], [ %1, %74 ]
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %120 = load %struct.CallInfo*, %struct.CallInfo** %119, align 8, !tbaa !35
  %121 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %120, i64 0, i32 3
  %122 = load %struct.CallInfo*, %struct.CallInfo** %121, align 8, !tbaa !89
  %123 = icmp eq %struct.CallInfo* %122, null
  br i1 %123, label %124, label %126

; <label>:124:                                    ; preds = %117
  %125 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0)
  br label %126

; <label>:126:                                    ; preds = %117, %124
  %127 = phi %struct.CallInfo* [ %125, %124 ], [ %122, %117 ]
  store %struct.CallInfo* %127, %struct.CallInfo** %119, align 8, !tbaa !35
  %128 = trunc i32 %2 to i16
  %129 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 6
  store i16 %128, i16* %129, align 4, !tbaa !48
  %130 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 16
  %131 = bitcast i32** %130 to i64*
  %132 = load i64, i64* %131, align 8, !tbaa !134
  %133 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 4
  %134 = bitcast %union.anon.0* %133 to i64*
  store i64 %132, i64* %134, align 8, !tbaa !21
  %135 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 7
  store i16 0, i16* %135, align 2, !tbaa !46
  %136 = getelementptr inbounds %union.StackValue, %union.StackValue* %118, i64 1
  %137 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 %98
  %138 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 1
  store %union.StackValue* %137, %union.StackValue** %138, align 8, !tbaa !49
  %139 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 0
  store %union.StackValue* %118, %union.StackValue** %139, align 8, !tbaa !47
  %140 = icmp sgt i32 %85, %89
  br i1 %140, label %149, label %141

; <label>:141:                                    ; preds = %126
  br label %142

; <label>:142:                                    ; preds = %141, %142
  %143 = phi i32 [ %147, %142 ], [ %86, %141 ]
  %144 = load %union.StackValue*, %union.StackValue** %79, align 8, !tbaa !20
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 1
  store %union.StackValue* %145, %union.StackValue** %79, align 8, !tbaa !20
  %146 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 0, i32 0, i32 1
  store i8 0, i8* %146, align 8, !tbaa !21
  %147 = add nsw i32 %143, 1
  %148 = icmp slt i32 %147, %89
  br i1 %148, label %142, label %149

; <label>:149:                                    ; preds = %142, %126
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* %127)
  br label %151

; <label>:150:                                    ; preds = %5
  tail call fastcc void @luaD_tryfuncTM(%struct.lua_State* %0, %union.StackValue* nonnull %1)
  br label %5

; <label>:151:                                    ; preds = %149, %72
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_callnoyield(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %5 = load i32, i32* %4, align 8, !tbaa !40
  %6 = add i32 %5, 65546
  store i32 %6, i32* %4, align 8, !tbaa !40
  %7 = and i32 %6, 65528
  %8 = icmp ugt i32 %7, 2199
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %3
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0)
  br label %10

; <label>:10:                                     ; preds = %9, %3
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %1, i32 %2)
  %11 = load i32, i32* %4, align 8, !tbaa !40
  %12 = add i32 %11, -65546
  store i32 %12, i32* %4, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_pcallk(%struct.lua_State*, i32, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %7 = alloca %struct.CallS, align 8
  %8 = bitcast %struct.CallS* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %17, label %10

; <label>:10:                                     ; preds = %6
  %11 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %3)
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %13 = bitcast %union.StackValue** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !34
  %15 = ptrtoint %union.StackValue* %11 to i64
  %16 = sub i64 %15, %14
  br label %17

; <label>:17:                                     ; preds = %6, %10
  %18 = phi i64 [ %16, %10 ], [ 0, %6 ]
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %21 = add nsw i32 %1, 1
  %22 = sext i32 %21 to i64
  %23 = sub nsw i64 0, %22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 %23
  %25 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 0
  store %union.StackValue* %24, %union.StackValue** %25, align 8, !tbaa !135
  %26 = icmp eq i32 (%struct.lua_State*, i32, i64)* %5, null
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %17
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %29 = load i32, i32* %28, align 8, !tbaa !40
  %30 = icmp ult i32 %29, 65536
  br i1 %30, label %40, label %31

; <label>:31:                                     ; preds = %27, %17
  %32 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 1
  store i32 %2, i32* %32, align 8, !tbaa !137
  %33 = bitcast %struct.CallS* %7 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !135
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %36 = bitcast %union.StackValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !34
  %38 = sub i64 %34, %37
  %39 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %8, i64 %38, i64 %18)
  br label %67

; <label>:40:                                     ; preds = %27
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %42 = load %struct.CallInfo*, %struct.CallInfo** %41, align 8, !tbaa !35
  %43 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %5, i32 (%struct.lua_State*, i32, i64)** %43, align 8, !tbaa !21
  %44 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 4, i32 0, i32 2
  store i64 %4, i64* %44, align 8, !tbaa !21
  %45 = bitcast %struct.CallS* %7 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !135
  %47 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %48 = bitcast %union.StackValue** %47 to i64*
  %49 = load i64, i64* %48, align 8, !tbaa !34
  %50 = sub i64 %46, %49
  %51 = trunc i64 %50 to i32
  %52 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 5, i32 0
  store i32 %51, i32* %52, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %54 = load i64, i64* %53, align 8, !tbaa !44
  %55 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 4, i32 0, i32 1
  store i64 %54, i64* %55, align 8, !tbaa !21
  store i64 %18, i64* %53, align 8, !tbaa !44
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 7
  %57 = load i16, i16* %56, align 2, !tbaa !46
  %58 = and i16 %57, -10
  %59 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %60 = load i8, i8* %59, align 1, !tbaa !41
  %61 = zext i8 %60 to i16
  %62 = or i16 %58, %61
  %63 = or i16 %62, 8
  store i16 %63, i16* %56, align 2, !tbaa !46
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %24, i32 %2)
  %64 = load i16, i16* %56, align 2, !tbaa !46
  %65 = and i16 %64, -9
  store i16 %65, i16* %56, align 2, !tbaa !46
  %66 = load i64, i64* %55, align 8, !tbaa !21
  store i64 %66, i64* %53, align 8, !tbaa !44
  br label %67

; <label>:67:                                     ; preds = %40, %31
  %68 = phi i32 [ %39, %31 ], [ 0, %40 ]
  %69 = icmp slt i32 %2, 0
  br i1 %69, label %70, label %78

; <label>:70:                                     ; preds = %67
  %71 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %72 = load %struct.CallInfo*, %struct.CallInfo** %71, align 8, !tbaa !35
  %73 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %72, i64 0, i32 1
  %74 = load %union.StackValue*, %union.StackValue** %73, align 8, !tbaa !49
  %75 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %76 = icmp ult %union.StackValue* %74, %75
  br i1 %76, label %77, label %78

; <label>:77:                                     ; preds = %70
  store %union.StackValue* %75, %union.StackValue** %73, align 8, !tbaa !49
  br label %78

; <label>:78:                                     ; preds = %77, %70, %67
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %68
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_pcall(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*, i64, i64) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = bitcast %struct.CallInfo** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !35
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !41
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %12 = load i64, i64* %11, align 8, !tbaa !44
  store i64 %4, i64* %11, align 8, !tbaa !44
  %13 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* %1, i8* %2)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %25, label %15, !prof !103

; <label>:15:                                     ; preds = %5
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %17 = bitcast %union.StackValue** %16 to i8**
  %18 = load i8*, i8** %17, align 8, !tbaa !34
  %19 = getelementptr inbounds i8, i8* %18, i64 %3
  %20 = bitcast i8* %19 to %union.StackValue*
  store i64 %8, i64* %7, align 8, !tbaa !35
  store i8 %10, i8* %9, align 1, !tbaa !41
  %21 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %20, i32 %13)
  %22 = load i8*, i8** %17, align 8, !tbaa !34
  %23 = getelementptr inbounds i8, i8* %22, i64 %3
  %24 = bitcast i8* %23 to %union.StackValue*
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %21, %union.StackValue* %24)
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* nonnull %0)
  br label %25

; <label>:25:                                     ; preds = %5, %15
  %26 = phi i32 [ %21, %15 ], [ 0, %5 ]
  store i64 %12, i64* %11, align 8, !tbaa !44
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal void @f_call(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to %union.StackValue**
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !135
  %5 = getelementptr inbounds i8, i8* %1, i64 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6, align 8, !tbaa !137
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* %4, i32 %7)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @lua_load(%struct.lua_State*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.Zio, align 8
  %7 = bitcast %struct.Zio* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %7) #7
  %8 = icmp eq i8* %3, null
  %9 = select i1 %8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %3
  call fastcc void @luaZ_init(%struct.lua_State* %0, %struct.Zio* nonnull %6, i8* (%struct.lua_State*, i8*, i64*)* %1, i8* %2)
  %10 = call fastcc i32 @luaD_protectedparser(%struct.lua_State* %0, %struct.Zio* nonnull %6, i8* %9, i8* %4)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %56

; <label>:12:                                     ; preds = %5
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 0, i32 0
  %16 = bitcast %struct.GCObject** %15 to %struct.LClosure**
  %17 = load %struct.LClosure*, %struct.LClosure** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %17, i64 0, i32 3
  %19 = load i8, i8* %18, align 2, !tbaa !138
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %56, label %21

; <label>:21:                                     ; preds = %12
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 7, i32 0, i32 0
  %25 = bitcast %struct.GCObject** %24 to %struct.Table**
  %26 = load %struct.Table*, %struct.Table** %25, align 8, !tbaa !21
  %27 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %26, i64 2)
  %28 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %17, i64 0, i32 6, i64 0
  %29 = load %struct.UpVal*, %struct.UpVal** %28, align 8, !tbaa !79
  %30 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %29, i64 0, i32 3
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !50
  %32 = bitcast %struct.TValue* %27 to i64*
  %33 = bitcast %struct.TValue* %31 to i64*
  %34 = load i64, i64* %32, align 8
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %36, i8* %37, align 8, !tbaa !22
  %38 = load i8, i8* %35, align 8, !tbaa !22
  %39 = and i8 %38, 64
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %56, label %41

; <label>:41:                                     ; preds = %21
  %42 = load %struct.UpVal*, %struct.UpVal** %28, align 8, !tbaa !79
  %43 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %42, i64 0, i32 2
  %44 = load i8, i8* %43, align 1, !tbaa !52
  %45 = and i8 %44, 32
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %56, label %47

; <label>:47:                                     ; preds = %41
  %48 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 0, i32 0
  %49 = load %struct.GCObject*, %struct.GCObject** %48, align 8, !tbaa !21
  %50 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %49, i64 0, i32 2
  %51 = load i8, i8* %50, align 1, !tbaa !53
  %52 = and i8 %51, 24
  %53 = icmp eq i8 %52, 0
  br i1 %53, label %56, label %54

; <label>:54:                                     ; preds = %47
  %55 = bitcast %struct.UpVal* %42 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %55, %struct.GCObject* %49)
  br label %56

; <label>:56:                                     ; preds = %12, %47, %41, %21, %54, %5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %7) #7
  ret i32 %10
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaZ_init(%struct.lua_State*, %struct.Zio* nocapture, i8* (%struct.lua_State*, i8*, i64*)*, i8*) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.Zio, %struct.Zio* %1, i64 0, i32 4
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !140
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %1, i64 0, i32 2
  store i8* (%struct.lua_State*, i8*, i64*)* %2, i8* (%struct.lua_State*, i8*, i64*)** %6, align 8, !tbaa !142
  %7 = getelementptr inbounds %struct.Zio, %struct.Zio* %1, i64 0, i32 3
  store i8* %3, i8** %7, align 8, !tbaa !143
  %8 = bitcast %struct.Zio* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 16, i32 8, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_protectedparser(%struct.lua_State*, %struct.Zio*, i8*, i8*) unnamed_addr #0 {
  %5 = alloca %struct.SParser, align 8
  %6 = bitcast %struct.SParser* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %8 = load i32, i32* %7, align 8, !tbaa !40
  %9 = add i32 %8, 65536
  store i32 %9, i32* %7, align 8, !tbaa !40
  %10 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 0
  store %struct.Zio* %1, %struct.Zio** %10, align 8, !tbaa !144
  %11 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 4
  store i8* %2, i8** %11, align 8, !tbaa !150
  %12 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 3
  store i8* %3, i8** %12, align 8, !tbaa !151
  %13 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 0, i32 0
  %14 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 0, i32 2
  store i32 0, i32* %14, align 4, !tbaa !152
  %15 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 1, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %15, align 8, !tbaa !153
  %16 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 1, i32 2
  store i32 0, i32* %16, align 4, !tbaa !154
  %17 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 2, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %17, align 8, !tbaa !155
  %18 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 2, i32 2, i32 2
  store i32 0, i32* %18, align 4, !tbaa !156
  %19 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 1, i32 0
  store i8* null, i8** %19, align 8, !tbaa !157
  %20 = getelementptr inbounds %struct.SParser, %struct.SParser* %5, i64 0, i32 1, i32 2
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to i64*
  %23 = bitcast i64* %20 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %23, i8 0, i64 16, i32 8, i1 false)
  %24 = load i64, i64* %22, align 8, !tbaa !20
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %26 = bitcast %union.StackValue** %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !34
  %28 = sub i64 %24, %27
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %30 = load i64, i64* %29, align 8, !tbaa !44
  %31 = call fastcc i32 @luaD_pcall(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @f_parser, i8* nonnull %6, i64 %28, i64 %30)
  %32 = load i8*, i8** %19, align 8, !tbaa !157
  %33 = load i64, i64* %20, align 8, !tbaa !158
  %34 = call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %0, i8* %32, i64 %33, i64 0)
  store i8* %34, i8** %19, align 8, !tbaa !157
  store i64 0, i64* %20, align 8, !tbaa !158
  %35 = bitcast %struct.Vardesc** %13 to i8**
  %36 = load i8*, i8** %35, align 8, !tbaa !159
  %37 = load i32, i32* %14, align 4, !tbaa !152
  %38 = sext i32 %37 to i64
  %39 = shl nsw i64 %38, 1
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %36, i64 %39)
  %40 = bitcast %struct.Labeldesc** %15 to i8**
  %41 = load i8*, i8** %40, align 8, !tbaa !153
  %42 = load i32, i32* %16, align 4, !tbaa !154
  %43 = sext i32 %42 to i64
  %44 = mul nsw i64 %43, 24
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %41, i64 %44)
  %45 = bitcast %struct.Labeldesc** %17 to i8**
  %46 = load i8*, i8** %45, align 8, !tbaa !155
  %47 = load i32, i32* %18, align 4, !tbaa !156
  %48 = sext i32 %47 to i64
  %49 = mul nsw i64 %48, 24
  call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %46, i64 %49)
  %50 = load i32, i32* %7, align 8, !tbaa !40
  %51 = add i32 %50, -65536
  store i32 %51, i32* %7, align 8, !tbaa !40
  call void @llvm.lifetime.end.p0i8(i64 96, i8* nonnull %6) #7
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i32 @lua_dump(%struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32) local_unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 86
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0, i32 0, i32 0
  %12 = bitcast %struct.GCObject** %11 to %struct.LClosure**
  %13 = load %struct.LClosure*, %struct.LClosure** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %13, i64 0, i32 5
  %15 = load %struct.Proto*, %struct.Proto** %14, align 8, !tbaa !21
  %16 = tail call fastcc i32 @luaU_dump(%struct.lua_State* nonnull %0, %struct.Proto* %15, i32 (%struct.lua_State*, i8*, i64, i8*)* %1, i8* %2, i32 %3)
  br label %17

; <label>:17:                                     ; preds = %4, %10
  %18 = phi i32 [ %16, %10 ], [ 1, %4 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaU_dump(%struct.lua_State*, %struct.Proto* nocapture readonly, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32) unnamed_addr #0 {
  %6 = alloca %struct.DumpState, align 8
  %7 = bitcast %struct.DumpState* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %6, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !160
  %9 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %6, i64 0, i32 1
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %2, i32 (%struct.lua_State*, i8*, i64, i8*)** %9, align 8, !tbaa !162
  %10 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %6, i64 0, i32 2
  store i8* %3, i8** %10, align 8, !tbaa !163
  %11 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %6, i64 0, i32 3
  store i32 %4, i32* %11, align 8, !tbaa !164
  %12 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %6, i64 0, i32 4
  store i32 0, i32* %12, align 4, !tbaa !165
  call fastcc void @DumpHeader(%struct.DumpState* nonnull %6)
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  %14 = load i32, i32* %13, align 8, !tbaa !166
  call fastcc void @DumpByte(i32 %14, %struct.DumpState* nonnull %6)
  call fastcc void @DumpFunction(%struct.Proto* %1, %struct.TString* null, %struct.DumpState* nonnull %6)
  %15 = load i32, i32* %12, align 4, !tbaa !165
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %7) #7
  ret i32 %15
}

; Function Attrs: norecurse nounwind readonly uwtable
define i32 @lua_status(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %3 = load i8, i8* %2, align 2, !tbaa !43
  %4 = zext i8 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define i32 @lua_gc(%struct.lua_State*, i32, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  call void @llvm.va_start(i8* nonnull %4)
  switch i32 %1, label %255 [
    i32 0, label %7
    i32 1, label %9
    i32 2, label %11
    i32 3, label %12
    i32 4, label %20
    i32 5, label %28
    i32 6, label %68
    i32 7, label %92
    i32 9, label %116
    i32 10, label %120
    i32 11, label %176
  ]

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 0, i8* %8, align 1, !tbaa !28
  br label %255

; <label>:9:                                      ; preds = %2
  call fastcc void @luaE_setdebt(%struct.global_State* %6, i64 0)
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 1, i8* %10, align 1, !tbaa !28
  br label %255

; <label>:11:                                     ; preds = %2
  call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 0)
  br label %255

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %14 = load i64, i64* %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %16 = load i64, i64* %15, align 8, !tbaa !11
  %17 = add nsw i64 %16, %14
  %18 = lshr i64 %17, 10
  %19 = trunc i64 %18 to i32
  br label %255

; <label>:20:                                     ; preds = %2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %22 = load i64, i64* %21, align 8, !tbaa !64
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = add nsw i64 %24, %22
  %26 = trunc i64 %25 to i32
  %27 = and i32 %26, 1023
  br label %255

; <label>:28:                                     ; preds = %2
  %29 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %30 = load i32, i32* %29, align 16
  %31 = icmp ult i32 %30, 41
  br i1 %31, label %32, label %38

; <label>:32:                                     ; preds = %28
  %33 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %34 = load i8*, i8** %33, align 16
  %35 = sext i32 %30 to i64
  %36 = getelementptr i8, i8* %34, i64 %35
  %37 = add i32 %30, 8
  store i32 %37, i32* %29, align 16
  br label %42

; <label>:38:                                     ; preds = %28
  %39 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %40 = load i8*, i8** %39, align 8
  %41 = getelementptr i8, i8* %40, i64 8
  store i8* %41, i8** %39, align 8
  br label %42

; <label>:42:                                     ; preds = %38, %32
  %43 = phi i8* [ %36, %32 ], [ %40, %38 ]
  %44 = bitcast i8* %43 to i32*
  %45 = load i32, i32* %44, align 4
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %47 = load i8, i8* %46, align 1, !tbaa !28
  store i8 1, i8* %46, align 1, !tbaa !28
  %48 = icmp eq i32 %45, 0
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %42
  call fastcc void @luaE_setdebt(%struct.global_State* nonnull %6, i64 0)
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  store i8 %47, i8* %46, align 1, !tbaa !28
  br label %63

; <label>:50:                                     ; preds = %42
  %51 = sext i32 %45 to i64
  %52 = shl nsw i64 %51, 10
  %53 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %54 = load i64, i64* %53, align 8, !tbaa !11
  %55 = add nsw i64 %54, %52
  call fastcc void @luaE_setdebt(%struct.global_State* nonnull %6, i64 %55)
  %56 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 3
  %58 = load i64, i64* %57, align 8, !tbaa !11
  %59 = icmp sgt i64 %58, 0
  br i1 %59, label %60, label %61

; <label>:60:                                     ; preds = %50
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %61

; <label>:61:                                     ; preds = %50, %60
  store i8 %47, i8* %46, align 1, !tbaa !28
  %62 = icmp sgt i64 %55, 0
  br i1 %62, label %63, label %255

; <label>:63:                                     ; preds = %49, %61
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 11
  %65 = load i8, i8* %64, align 1, !tbaa !62
  %66 = icmp eq i8 %65, 8
  %67 = zext i1 %66 to i32
  br label %255

; <label>:68:                                     ; preds = %2
  %69 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %70 = load i32, i32* %69, align 16
  %71 = icmp ult i32 %70, 41
  br i1 %71, label %72, label %78

; <label>:72:                                     ; preds = %68
  %73 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %74 = load i8*, i8** %73, align 16
  %75 = sext i32 %70 to i64
  %76 = getelementptr i8, i8* %74, i64 %75
  %77 = add i32 %70, 8
  store i32 %77, i32* %69, align 16
  br label %82

; <label>:78:                                     ; preds = %68
  %79 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %80 = load i8*, i8** %79, align 8
  %81 = getelementptr i8, i8* %80, i64 8
  store i8* %81, i8** %79, align 8
  br label %82

; <label>:82:                                     ; preds = %78, %72
  %83 = phi i8* [ %76, %72 ], [ %80, %78 ]
  %84 = bitcast i8* %83 to i32*
  %85 = load i32, i32* %84, align 4
  %86 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  %87 = load i8, i8* %86, align 1, !tbaa !65
  %88 = zext i8 %87 to i32
  %89 = shl nuw nsw i32 %88, 2
  %90 = sdiv i32 %85, 4
  %91 = trunc i32 %90 to i8
  store i8 %91, i8* %86, align 1, !tbaa !65
  br label %255

; <label>:92:                                     ; preds = %2
  %93 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %94 = load i32, i32* %93, align 16
  %95 = icmp ult i32 %94, 41
  br i1 %95, label %96, label %102

; <label>:96:                                     ; preds = %92
  %97 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %98 = load i8*, i8** %97, align 16
  %99 = sext i32 %94 to i64
  %100 = getelementptr i8, i8* %98, i64 %99
  %101 = add i32 %94, 8
  store i32 %101, i32* %93, align 16
  br label %106

; <label>:102:                                    ; preds = %92
  %103 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %104 = load i8*, i8** %103, align 8
  %105 = getelementptr i8, i8* %104, i64 8
  store i8* %105, i8** %103, align 8
  br label %106

; <label>:106:                                    ; preds = %102, %96
  %107 = phi i8* [ %100, %96 ], [ %104, %102 ]
  %108 = bitcast i8* %107 to i32*
  %109 = load i32, i32* %108, align 4
  %110 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  %111 = load i8, i8* %110, align 4, !tbaa !66
  %112 = zext i8 %111 to i32
  %113 = shl nuw nsw i32 %112, 2
  %114 = sdiv i32 %109, 4
  %115 = trunc i32 %114 to i8
  store i8 %115, i8* %110, align 4, !tbaa !66
  br label %255

; <label>:116:                                    ; preds = %2
  %117 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %118 = load i8, i8* %117, align 1, !tbaa !28
  %119 = zext i8 %118 to i32
  br label %255

; <label>:120:                                    ; preds = %2
  %121 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %122 = load i32, i32* %121, align 16
  %123 = icmp ult i32 %122, 41
  br i1 %123, label %124, label %130

; <label>:124:                                    ; preds = %120
  %125 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %126 = load i8*, i8** %125, align 16
  %127 = sext i32 %122 to i64
  %128 = getelementptr i8, i8* %126, i64 %127
  %129 = add i32 %122, 8
  store i32 %129, i32* %121, align 16
  br label %135

; <label>:130:                                    ; preds = %120
  %131 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %132 = load i8*, i8** %131, align 8
  %133 = getelementptr i8, i8* %132, i64 8
  store i8* %133, i8** %131, align 8
  %134 = load i32, i32* %121, align 16
  br label %135

; <label>:135:                                    ; preds = %130, %124
  %136 = phi i32 [ %134, %130 ], [ %129, %124 ]
  %137 = phi i8* [ %132, %130 ], [ %128, %124 ]
  %138 = bitcast i8* %137 to i32*
  %139 = load i32, i32* %138, align 4
  %140 = icmp ult i32 %136, 41
  br i1 %140, label %141, label %147

; <label>:141:                                    ; preds = %135
  %142 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %143 = load i8*, i8** %142, align 16
  %144 = sext i32 %136 to i64
  %145 = getelementptr i8, i8* %143, i64 %144
  %146 = add i32 %136, 8
  store i32 %146, i32* %121, align 16
  br label %151

; <label>:147:                                    ; preds = %135
  %148 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %149 = load i8*, i8** %148, align 8
  %150 = getelementptr i8, i8* %149, i64 8
  store i8* %150, i8** %148, align 8
  br label %151

; <label>:151:                                    ; preds = %147, %141
  %152 = phi i8* [ %145, %141 ], [ %149, %147 ]
  %153 = bitcast i8* %152 to i32*
  %154 = load i32, i32* %153, align 4
  %155 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %156 = load i8, i8* %155, align 2, !tbaa !29
  %157 = icmp eq i8 %156, 1
  br i1 %157, label %163, label %158

; <label>:158:                                    ; preds = %151
  %159 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %160 = load i64, i64* %159, align 8, !tbaa !30
  %161 = icmp eq i64 %160, 0
  %162 = select i1 %161, i32 11, i32 10
  br label %163

; <label>:163:                                    ; preds = %158, %151
  %164 = phi i32 [ 10, %151 ], [ %162, %158 ]
  %165 = icmp eq i32 %139, 0
  br i1 %165, label %169, label %166

; <label>:166:                                    ; preds = %163
  %167 = trunc i32 %139 to i8
  %168 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 13
  store i8 %167, i8* %168, align 1, !tbaa !69
  br label %169

; <label>:169:                                    ; preds = %163, %166
  %170 = icmp eq i32 %154, 0
  br i1 %170, label %175, label %171

; <label>:171:                                    ; preds = %169
  %172 = sdiv i32 %154, 4
  %173 = trunc i32 %172 to i8
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 14
  store i8 %173, i8* %174, align 8, !tbaa !68
  br label %175

; <label>:175:                                    ; preds = %169, %171
  call fastcc void @luaC_changemode(%struct.lua_State* nonnull %0, i32 1)
  br label %255

; <label>:176:                                    ; preds = %2
  %177 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %178 = load i32, i32* %177, align 16
  %179 = icmp ult i32 %178, 41
  br i1 %179, label %180, label %186

; <label>:180:                                    ; preds = %176
  %181 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %182 = load i8*, i8** %181, align 16
  %183 = sext i32 %178 to i64
  %184 = getelementptr i8, i8* %182, i64 %183
  %185 = add i32 %178, 8
  store i32 %185, i32* %177, align 16
  br label %191

; <label>:186:                                    ; preds = %176
  %187 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %188 = load i8*, i8** %187, align 8
  %189 = getelementptr i8, i8* %188, i64 8
  store i8* %189, i8** %187, align 8
  %190 = load i32, i32* %177, align 16
  br label %191

; <label>:191:                                    ; preds = %186, %180
  %192 = phi i32 [ %190, %186 ], [ %185, %180 ]
  %193 = phi i8* [ %188, %186 ], [ %184, %180 ]
  %194 = bitcast i8* %193 to i32*
  %195 = load i32, i32* %194, align 4
  %196 = icmp ult i32 %192, 41
  br i1 %196, label %197, label %203

; <label>:197:                                    ; preds = %191
  %198 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %199 = load i8*, i8** %198, align 16
  %200 = sext i32 %192 to i64
  %201 = getelementptr i8, i8* %199, i64 %200
  %202 = add i32 %192, 8
  store i32 %202, i32* %177, align 16
  br label %208

; <label>:203:                                    ; preds = %191
  %204 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %205 = load i8*, i8** %204, align 8
  %206 = getelementptr i8, i8* %205, i64 8
  store i8* %206, i8** %204, align 8
  %207 = load i32, i32* %177, align 16
  br label %208

; <label>:208:                                    ; preds = %203, %197
  %209 = phi i32 [ %207, %203 ], [ %202, %197 ]
  %210 = phi i8* [ %205, %203 ], [ %201, %197 ]
  %211 = bitcast i8* %210 to i32*
  %212 = load i32, i32* %211, align 4
  %213 = icmp ult i32 %209, 41
  br i1 %213, label %214, label %220

; <label>:214:                                    ; preds = %208
  %215 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %216 = load i8*, i8** %215, align 16
  %217 = sext i32 %209 to i64
  %218 = getelementptr i8, i8* %216, i64 %217
  %219 = add i32 %209, 8
  store i32 %219, i32* %177, align 16
  br label %224

; <label>:220:                                    ; preds = %208
  %221 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %222 = load i8*, i8** %221, align 8
  %223 = getelementptr i8, i8* %222, i64 8
  store i8* %223, i8** %221, align 8
  br label %224

; <label>:224:                                    ; preds = %220, %214
  %225 = phi i8* [ %218, %214 ], [ %222, %220 ]
  %226 = bitcast i8* %225 to i32*
  %227 = load i32, i32* %226, align 4
  %228 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %229 = load i8, i8* %228, align 2, !tbaa !29
  %230 = icmp eq i8 %229, 1
  br i1 %230, label %236, label %231

; <label>:231:                                    ; preds = %224
  %232 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %233 = load i64, i64* %232, align 8, !tbaa !30
  %234 = icmp eq i64 %233, 0
  %235 = select i1 %234, i32 11, i32 10
  br label %236

; <label>:236:                                    ; preds = %231, %224
  %237 = phi i32 [ 10, %224 ], [ %235, %231 ]
  %238 = icmp eq i32 %195, 0
  br i1 %238, label %243, label %239

; <label>:239:                                    ; preds = %236
  %240 = sdiv i32 %195, 4
  %241 = trunc i32 %240 to i8
  %242 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  store i8 %241, i8* %242, align 1, !tbaa !65
  br label %243

; <label>:243:                                    ; preds = %236, %239
  %244 = icmp eq i32 %212, 0
  br i1 %244, label %249, label %245

; <label>:245:                                    ; preds = %243
  %246 = sdiv i32 %212, 4
  %247 = trunc i32 %246 to i8
  %248 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  store i8 %247, i8* %248, align 4, !tbaa !66
  br label %249

; <label>:249:                                    ; preds = %243, %245
  %250 = icmp eq i32 %227, 0
  br i1 %250, label %254, label %251

; <label>:251:                                    ; preds = %249
  %252 = trunc i32 %227 to i8
  %253 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 19
  store i8 %252, i8* %253, align 1, !tbaa !67
  br label %254

; <label>:254:                                    ; preds = %249, %251
  call fastcc void @luaC_changemode(%struct.lua_State* nonnull %0, i32 0)
  br label %255

; <label>:255:                                    ; preds = %63, %2, %61, %254, %175, %116, %106, %82, %20, %12, %11, %9, %7
  %256 = phi i32 [ %237, %254 ], [ %164, %175 ], [ %119, %116 ], [ %113, %106 ], [ %89, %82 ], [ %27, %20 ], [ %19, %12 ], [ 0, %11 ], [ 0, %9 ], [ 0, %7 ], [ 0, %61 ], [ %67, %63 ], [ -1, %2 ]
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i32 %256
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaE_setdebt(%struct.global_State* nocapture, i64) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %4 = load i64, i64* %3, align 8, !tbaa !64
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %6 = load i64, i64* %5, align 8, !tbaa !11
  %7 = add nsw i64 %6, %4
  %8 = add nsw i64 %7, -9223372036854775807
  %9 = icmp sgt i64 %8, %1
  %10 = select i1 %9, i64 %8, i64 %1
  %11 = sub nsw i64 %7, %10
  store i64 %11, i64* %3, align 8, !tbaa !64
  store i64 %10, i64* %5, align 8, !tbaa !11
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_fullgc(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = trunc i32 %1 to i8
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 16
  store i8 %5, i8* %6, align 2, !tbaa !63
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 12
  %8 = load i8, i8* %7, align 2, !tbaa !29
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %2
  tail call fastcc void @fullinc(%struct.lua_State* nonnull %0, %struct.global_State* %4)
  br label %13

; <label>:11:                                     ; preds = %2
  %12 = tail call fastcc i64 @fullgen(%struct.lua_State* nonnull %0, %struct.global_State* %4)
  br label %13

; <label>:13:                                     ; preds = %11, %10
  store i8 0, i8* %6, align 2, !tbaa !63
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_changemode(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 12
  %6 = load i8, i8* %5, align 2, !tbaa !29
  %7 = zext i8 %6 to i32
  %8 = icmp eq i32 %7, %1
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %2
  %10 = icmp eq i32 %1, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %9
  %12 = tail call fastcc i64 @entergen(%struct.lua_State* nonnull %0, %struct.global_State* %4)
  br label %14

; <label>:13:                                     ; preds = %9
  tail call fastcc void @enterinc(%struct.global_State* %4)
  br label %14

; <label>:14:                                     ; preds = %2, %11, %13
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 5
  store i64 0, i64* %15, align 8, !tbaa !30
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define i32 @lua_error(%struct.lua_State*) local_unnamed_addr #5 {
  tail call fastcc void @luaG_errormsg(%struct.lua_State* %0) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_errormsg(%struct.lua_State*) unnamed_addr #5 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %3 = load i64, i64* %2, align 8, !tbaa !44
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !34
  %9 = getelementptr inbounds i8, i8* %8, i64 %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = bitcast %struct.TValue* %12 to i64*
  %14 = bitcast %union.StackValue* %11 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast i8* %9 to i64*
  %22 = bitcast %struct.TValue* %20 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds i8, i8* %9, i64 8
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %10, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %29, i32 1)
  br label %30

; <label>:30:                                     ; preds = %1, %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 2) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define i32 @lua_next(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.Table* @gettable(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  %7 = tail call fastcc i32 @luaH_next(%struct.lua_State* %0, %struct.Table* %3, %union.StackValue* nonnull %6)
  %8 = icmp eq i32 %7, 0
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %12 = select i1 %8, %union.StackValue* %10, %union.StackValue* %11
  store %union.StackValue* %12, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaH_next(%struct.lua_State*, %struct.Table* nocapture readonly, %union.StackValue* nocapture) unnamed_addr #0 {
  %4 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1)
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0
  %6 = tail call fastcc i32 @findindex(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %5, i32 %4)
  %7 = icmp ult i32 %6, %4
  br i1 %7, label %8, label %36

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !115
  br label %13

; <label>:11:                                     ; preds = %13
  %12 = icmp ult i32 %20, %4
  br i1 %12, label %13, label %36

; <label>:13:                                     ; preds = %8, %11
  %14 = phi i32 [ %6, %8 ], [ %20, %11 ]
  %15 = zext i32 %14 to i64
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 %15, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  %20 = add i32 %14, 1
  br i1 %19, label %11, label %21

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %23 = zext i32 %14 to i64
  %24 = zext i32 %20 to i64
  %25 = bitcast %union.StackValue* %2 to i64*
  store i64 %24, i64* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0, i32 1
  store i8 35, i8* %26, align 8, !tbaa !22
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1, i32 0
  %28 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !115
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %23
  %30 = bitcast %struct.TValue* %29 to i64*
  %31 = bitcast %struct.TValue* %27 to i64*
  %32 = load i64, i64* %30, align 8
  store i64 %32, i64* %31, align 8
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %23, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1, i32 0, i32 1
  store i8 %34, i8* %35, align 8, !tbaa !22
  br label %76

; <label>:36:                                     ; preds = %11, %3
  %37 = phi i32 [ %6, %3 ], [ %20, %11 ]
  %38 = sub i32 %37, %4
  %39 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %40 = load i8, i8* %39, align 1, !tbaa !124
  %41 = zext i8 %40 to i32
  %42 = shl i32 1, %41
  %43 = icmp slt i32 %38, %42
  br i1 %43, label %44, label %76

; <label>:44:                                     ; preds = %36
  %45 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %46 = load %union.Node*, %union.Node** %45, align 8, !tbaa !123
  br label %52

; <label>:47:                                     ; preds = %52
  %48 = load i8, i8* %39, align 1, !tbaa !124
  %49 = zext i8 %48 to i32
  %50 = shl i32 1, %49
  %51 = icmp slt i32 %59, %50
  br i1 %51, label %52, label %76

; <label>:52:                                     ; preds = %44, %47
  %53 = phi i32 [ %38, %44 ], [ %59, %47 ]
  %54 = zext i32 %53 to i64
  %55 = getelementptr inbounds %union.Node, %union.Node* %46, i64 %54, i32 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !21
  %57 = and i8 %56, 15
  %58 = icmp eq i8 %57, 0
  %59 = add nsw i32 %53, 1
  br i1 %58, label %47, label %60

; <label>:60:                                     ; preds = %52
  %61 = zext i32 %53 to i64
  %62 = getelementptr inbounds %union.Node, %union.Node* %46, i64 %61, i32 0, i32 4
  %63 = bitcast %union.Value* %62 to i64*
  %64 = bitcast %union.StackValue* %2 to i64*
  %65 = load i64, i64* %63, align 8
  store i64 %65, i64* %64, align 8
  %66 = getelementptr inbounds %union.Node, %union.Node* %46, i64 %61, i32 0, i32 2
  %67 = load i8, i8* %66, align 1, !tbaa !21
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0, i32 1
  store i8 %67, i8* %68, align 8, !tbaa !22
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1, i32 0
  %70 = getelementptr inbounds %union.Node, %union.Node* %46, i64 %61, i32 0, i32 0
  %71 = bitcast %union.Value* %70 to i64*
  %72 = bitcast %struct.TValue* %69 to i64*
  %73 = load i64, i64* %71, align 8
  store i64 %73, i64* %72, align 8
  %74 = load i8, i8* %55, align 8, !tbaa !22
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1, i32 0, i32 1
  store i8 %74, i8* %75, align 8, !tbaa !22
  br label %76

; <label>:76:                                     ; preds = %47, %36, %60, %21
  %77 = phi i32 [ 1, %21 ], [ 1, %60 ], [ 0, %36 ], [ 0, %47 ]
  ret i32 %77
}

; Function Attrs: nounwind uwtable
define void @lua_toclose(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %union.StackValue* @index2stack(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !35
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 6
  %7 = load i16, i16* %6, align 4, !tbaa !48
  tail call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* %3)
  %8 = icmp slt i16 %7, -1
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %2
  %10 = sub i16 -3, %7
  %11 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !35
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 6
  store i16 %10, i16* %12, align 4, !tbaa !48
  br label %13

; <label>:13:                                     ; preds = %9, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaF_newtbcupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = bitcast %union.StackValue* %1 to i8*
  %4 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @trynewtbcupval, i8* %3)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %14, label %6, !prof !103

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 4, %union.StackValue* nonnull %7)
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  %10 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* %0, %struct.TValue* %8, %struct.TValue* nonnull %9)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %6
  tail call void @callclose(%struct.lua_State* %0, i8* null)
  br label %13

; <label>:13:                                     ; preds = %6, %12
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #17
  unreachable

; <label>:14:                                     ; preds = %2
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_concat(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, 1
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %1)
  br label %19

; <label>:5:                                      ; preds = %2
  %6 = icmp eq i32 %1, 0
  br i1 %6, label %7, label %19

; <label>:7:                                      ; preds = %5
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64 0)
  %12 = bitcast %struct.TValue* %10 to %struct.TString**
  store %struct.TString* %11, %struct.TString** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !57
  %15 = or i8 %14, 64
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %8, align 8, !tbaa !20
  br label %19

; <label>:19:                                     ; preds = %5, %7, %4
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = icmp sgt i64 %23, 0
  br i1 %24, label %25, label %26

; <label>:25:                                     ; preds = %19
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %26

; <label>:26:                                     ; preds = %25, %19
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_concat(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [40 x i8], align 16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = getelementptr inbounds [40 x i8], [40 x i8]* %3, i64 0, i64 0
  br label %6

; <label>:6:                                      ; preds = %127, %2
  %7 = phi i32 [ %1, %2 ], [ %130, %127 ]
  %8 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -2
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -2, i32 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !21
  %13 = and i8 %12, 15
  %14 = add nsw i8 %13, -3
  %15 = icmp ult i8 %14, 2
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %6
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !21
  %20 = trunc i8 %19 to i4
  switch i4 %20, label %23 [
    i4 4, label %25
    i4 3, label %21
  ]

; <label>:21:                                     ; preds = %16
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %17)
  %22 = load i8, i8* %18, align 8, !tbaa !21
  br label %25

; <label>:23:                                     ; preds = %6, %16
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %10, %struct.TValue* nonnull %24, %union.StackValue* nonnull %9, i32 22)
  br label %127

; <label>:25:                                     ; preds = %16, %21
  %26 = phi i8 [ %19, %16 ], [ %22, %21 ]
  %27 = icmp eq i8 %26, 84
  br i1 %27, label %28, label %39

; <label>:28:                                     ; preds = %25
  %29 = bitcast %struct.TValue* %17 to %struct.TString**
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.TString, %struct.TString* %30, i64 0, i32 4
  %32 = load i8, i8* %31, align 1, !tbaa !21
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %39

; <label>:34:                                     ; preds = %28
  %35 = load i8, i8* %11, align 8, !tbaa !21
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 3
  br i1 %37, label %38, label %127

; <label>:38:                                     ; preds = %34
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %10)
  br label %127

; <label>:39:                                     ; preds = %28, %25
  %40 = load i8, i8* %11, align 8, !tbaa !21
  %41 = icmp eq i8 %40, 84
  br i1 %41, label %42, label %52

; <label>:42:                                     ; preds = %39
  %43 = bitcast %union.StackValue* %9 to %struct.TString**
  %44 = load %struct.TString*, %struct.TString** %43, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 4
  %46 = load i8, i8* %45, align 1, !tbaa !21
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %48, label %52

; <label>:48:                                     ; preds = %42
  %49 = bitcast %struct.TValue* %17 to i64*
  %50 = bitcast %union.StackValue* %9 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  store i8 %26, i8* %11, align 8, !tbaa !22
  br label %127

; <label>:52:                                     ; preds = %42, %39
  %53 = bitcast %struct.TValue* %17 to %struct.TString**
  %54 = load %struct.TString*, %struct.TString** %53, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !21
  %57 = icmp eq i8 %56, 20
  br i1 %57, label %58, label %62

; <label>:58:                                     ; preds = %52
  %59 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 4
  %60 = load i8, i8* %59, align 1, !tbaa !21
  %61 = zext i8 %60 to i64
  br label %65

; <label>:62:                                     ; preds = %52
  %63 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 6, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !21
  br label %65

; <label>:65:                                     ; preds = %62, %58
  %66 = phi i64 [ %61, %58 ], [ %64, %62 ]
  %67 = icmp sgt i32 %7, 1
  br i1 %67, label %68, label %107

; <label>:68:                                     ; preds = %65
  %69 = sext i32 %7 to i64
  br label %70

; <label>:70:                                     ; preds = %68, %100
  %71 = phi i64 [ 1, %68 ], [ %102, %100 ]
  %72 = phi i32 [ 1, %68 ], [ %103, %100 ]
  %73 = phi i64 [ %66, %68 ], [ %101, %100 ]
  %74 = sub nsw i64 0, %71
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %74
  %76 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 -1
  %77 = getelementptr inbounds %union.StackValue, %union.StackValue* %76, i64 0, i32 0, i32 1
  %78 = load i8, i8* %77, align 8, !tbaa !21
  %79 = trunc i8 %78 to i4
  switch i4 %79, label %105 [
    i4 4, label %82
    i4 3, label %80
  ]

; <label>:80:                                     ; preds = %70
  %81 = getelementptr inbounds %union.StackValue, %union.StackValue* %76, i64 0, i32 0
  tail call fastcc void @luaO_tostring(%struct.lua_State* %0, %struct.TValue* nonnull %81)
  br label %82

; <label>:82:                                     ; preds = %70, %80
  %83 = bitcast %union.StackValue* %76 to %struct.TString**
  %84 = load %struct.TString*, %struct.TString** %83, align 8, !tbaa !21
  %85 = getelementptr inbounds %struct.TString, %struct.TString* %84, i64 0, i32 1
  %86 = load i8, i8* %85, align 8, !tbaa !21
  %87 = icmp eq i8 %86, 20
  br i1 %87, label %88, label %92

; <label>:88:                                     ; preds = %82
  %89 = getelementptr inbounds %struct.TString, %struct.TString* %84, i64 0, i32 4
  %90 = load i8, i8* %89, align 1, !tbaa !21
  %91 = zext i8 %90 to i64
  br label %95

; <label>:92:                                     ; preds = %82
  %93 = getelementptr inbounds %struct.TString, %struct.TString* %84, i64 0, i32 6, i32 0
  %94 = load i64, i64* %93, align 8, !tbaa !21
  br label %95

; <label>:95:                                     ; preds = %92, %88
  %96 = phi i64 [ %91, %88 ], [ %94, %92 ]
  %97 = sub i64 9223372036854775807, %73
  %98 = icmp ult i64 %96, %97
  br i1 %98, label %100, label %99, !prof !103

; <label>:99:                                     ; preds = %95
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.281, i64 0, i64 0)) #17
  unreachable

; <label>:100:                                    ; preds = %95
  %101 = add i64 %96, %73
  %102 = add nuw nsw i64 %71, 1
  %103 = add nuw nsw i32 %72, 1
  %104 = icmp slt i64 %102, %69
  br i1 %104, label %70, label %107

; <label>:105:                                    ; preds = %70
  %106 = trunc i64 %71 to i32
  br label %107

; <label>:107:                                    ; preds = %100, %105, %65
  %108 = phi i64 [ %66, %65 ], [ %73, %105 ], [ %101, %100 ]
  %109 = phi i32 [ 1, %65 ], [ %106, %105 ], [ %103, %100 ]
  %110 = icmp ult i64 %108, 41
  br i1 %110, label %111, label %113

; <label>:111:                                    ; preds = %107
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %5) #7
  call fastcc void @copy2buff(%union.StackValue* nonnull %8, i32 %109, i8* nonnull %5)
  %112 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %5, i64 %108)
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %5) #7
  br label %117

; <label>:113:                                    ; preds = %107
  %114 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %0, i64 %108)
  %115 = getelementptr inbounds %struct.TString, %struct.TString* %114, i64 1
  %116 = bitcast %struct.TString* %115 to i8*
  tail call fastcc void @copy2buff(%union.StackValue* nonnull %8, i32 %109, i8* nonnull %116)
  br label %117

; <label>:117:                                    ; preds = %113, %111
  %118 = phi %struct.TString* [ %112, %111 ], [ %114, %113 ]
  %119 = zext i32 %109 to i64
  %120 = sub nsw i64 0, %119
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %120, i32 0
  %122 = bitcast %struct.TValue* %121 to %struct.TString**
  store %struct.TString* %118, %struct.TString** %122, align 8, !tbaa !21
  %123 = getelementptr inbounds %struct.TString, %struct.TString* %118, i64 0, i32 1
  %124 = load i8, i8* %123, align 8, !tbaa !57
  %125 = or i8 %124, 64
  %126 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %120, i32 0, i32 1
  store i8 %125, i8* %126, align 8, !tbaa !22
  br label %127

; <label>:127:                                    ; preds = %34, %38, %117, %48, %23
  %128 = phi i32 [ 2, %48 ], [ %109, %117 ], [ 2, %23 ], [ 2, %34 ], [ 2, %38 ]
  %129 = add nsw i32 %128, -1
  %130 = sub nsw i32 %7, %129
  %131 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %132 = sext i32 %129 to i64
  %133 = sub nsw i64 0, %132
  %134 = getelementptr inbounds %union.StackValue, %union.StackValue* %131, i64 %133
  store %union.StackValue* %134, %union.StackValue** %4, align 8, !tbaa !20
  %135 = icmp sgt i32 %130, 1
  br i1 %135, label %6, label %136

; <label>:136:                                    ; preds = %127
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  tail call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %5, %struct.TValue* %3)
  %6 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_objlen(%struct.lua_State*, %union.StackValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %44 [
    i6 5, label %7
    i6 20, label %29
    i6 -28, label %37
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %2 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !125
  %12 = icmp eq %struct.Table* %11, null
  br i1 %12, label %25, label %13

; <label>:13:                                     ; preds = %7
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %11, i64 0, i32 3
  %15 = load i8, i8* %14, align 2, !tbaa !111
  %16 = and i8 %15, 16
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %13
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %20 = load %struct.global_State*, %struct.global_State** %19, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 40, i64 4
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !79
  %23 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %11, i32 4, %struct.TString* %22)
  %24 = icmp eq %struct.TValue* %23, null
  br i1 %24, label %25, label %51

; <label>:25:                                     ; preds = %13, %7, %18
  %26 = tail call fastcc i64 @luaH_getn(%struct.Table* %9)
  %27 = bitcast %union.StackValue* %1 to i64*
  store i64 %26, i64* %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %28, align 8, !tbaa !22
  br label %53

; <label>:29:                                     ; preds = %3
  %30 = bitcast %struct.TValue* %2 to %struct.TString**
  %31 = load %struct.TString*, %struct.TString** %30, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.TString, %struct.TString* %31, i64 0, i32 4
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = zext i8 %33 to i64
  %35 = bitcast %union.StackValue* %1 to i64*
  store i64 %34, i64* %35, align 8, !tbaa !21
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %36, align 8, !tbaa !22
  br label %53

; <label>:37:                                     ; preds = %3
  %38 = bitcast %struct.TValue* %2 to %struct.TString**
  %39 = load %struct.TString*, %struct.TString** %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TString, %struct.TString* %39, i64 0, i32 6, i32 0
  %41 = load i64, i64* %40, align 8, !tbaa !21
  %42 = bitcast %union.StackValue* %1 to i64*
  store i64 %41, i64* %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %43, align 8, !tbaa !22
  br label %53

; <label>:44:                                     ; preds = %3
  %45 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* nonnull %2, i32 4)
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %50, label %51, !prof !33

; <label>:50:                                     ; preds = %44
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* nonnull %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.282, i64 0, i64 0)) #17
  unreachable

; <label>:51:                                     ; preds = %18, %44
  %52 = phi %struct.TValue* [ %45, %44 ], [ %23, %18 ]
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %52, %struct.TValue* nonnull %2, %struct.TValue* nonnull %2, %union.StackValue* %1)
  br label %53

; <label>:53:                                     ; preds = %25, %51, %37, %29
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define i8* (i8*, i8*, i64, i64)* @lua_getallocf(%struct.lua_State* nocapture readonly, i8**) local_unnamed_addr #2 {
  %3 = icmp eq i8** %1, null
  br i1 %3, label %11, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %8 = bitcast i8** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !32
  %10 = bitcast i8** %1 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !79
  br label %11

; <label>:11:                                     ; preds = %2, %4
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 0
  %15 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %14, align 8, !tbaa !31
  ret i8* (i8*, i8*, i64, i64)* %15
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_setallocf(%struct.lua_State* nocapture readonly, i8* (i8*, i8*, i64, i64)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  store i8* %2, i8** %6, align 8, !tbaa !32
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  store i8* (i8*, i8*, i64, i64)* %1, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !31
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @lua_setwarnf(%struct.lua_State* nocapture readonly, void (i8*, i8*, i32)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  store i8* %2, i8** %6, align 8, !tbaa !167
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  store void (i8*, i8*, i32)* %1, void (i8*, i8*, i32)** %7, align 8, !tbaa !168
  ret void
}

; Function Attrs: nounwind uwtable
define void @lua_warning(%struct.lua_State* nocapture readonly, i8*, i32) local_unnamed_addr #0 {
  tail call fastcc void @luaE_warning(%struct.lua_State* %0, i8* %1, i32 %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaE_warning(%struct.lua_State* nocapture readonly, i8*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  %7 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %6, align 8, !tbaa !168
  %8 = icmp eq void (i8*, i8*, i32)* %7, null
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  %11 = load i8*, i8** %10, align 8, !tbaa !167
  tail call void %7(i8* %11, i8* %1, i32 %2) #7
  br label %12

; <label>:12:                                     ; preds = %3, %9
  ret void
}

; Function Attrs: nounwind uwtable
define nonnull i8* @lua_newuserdatauv(%struct.lua_State*, i64, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.Udata* @luaS_newudata(%struct.lua_State* %0, i64 %1, i32 %2)
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to %struct.Udata**
  store %struct.Udata* %4, %struct.Udata** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 71, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 3
  %15 = load i64, i64* %14, align 8, !tbaa !11
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %3
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %18

; <label>:18:                                     ; preds = %17, %3
  %19 = bitcast %struct.Udata* %4 to i8*
  %20 = getelementptr inbounds %struct.Udata, %struct.Udata* %4, i64 0, i32 3
  %21 = load i16, i16* %20, align 2, !tbaa !169
  %22 = icmp eq i16 %21, 0
  %23 = zext i16 %21 to i64
  %24 = shl nuw nsw i64 %23, 4
  %25 = add nuw nsw i64 %24, 40
  %26 = select i1 %22, i64 32, i64 %25
  %27 = getelementptr inbounds i8, i8* %19, i64 %26
  ret i8* %27
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.Udata* @luaS_newudata(%struct.lua_State*, i64, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %3
  %6 = sext i32 %2 to i64
  %7 = shl nsw i64 %6, 4
  %8 = sub i64 9223372036854775767, %7
  br label %9

; <label>:9:                                      ; preds = %3, %5
  %10 = phi i64 [ %8, %5 ], [ 9223372036854775775, %3 ]
  %11 = icmp ult i64 %10, %1
  br i1 %11, label %12, label %13, !prof !33

; <label>:12:                                     ; preds = %9
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #17
  unreachable

; <label>:13:                                     ; preds = %9
  br i1 %4, label %18, label %14

; <label>:14:                                     ; preds = %13
  %15 = sext i32 %2 to i64
  %16 = shl nsw i64 %15, 4
  %17 = add nsw i64 %16, 40
  br label %18

; <label>:18:                                     ; preds = %13, %14
  %19 = phi i64 [ %17, %14 ], [ 32, %13 ]
  %20 = add i64 %19, %1
  %21 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 7, i64 %20)
  %22 = bitcast %struct.GCObject* %21 to %struct.Udata*
  %23 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 1
  %24 = bitcast %struct.GCObject* %23 to i64*
  store i64 %1, i64* %24, align 8, !tbaa !171
  %25 = trunc i32 %2 to i16
  %26 = getelementptr inbounds %struct.Udata, %struct.Udata* %22, i64 0, i32 3
  store i16 %25, i16* %26, align 2, !tbaa !169
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 1, i32 1
  %28 = bitcast i8* %27 to %struct.Table**
  store %struct.Table* null, %struct.Table** %28, align 8, !tbaa !172
  %29 = icmp sgt i32 %2, 0
  br i1 %29, label %30, label %39

; <label>:30:                                     ; preds = %18
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 2, i32 1
  %32 = bitcast i8* %31 to [1 x %union.UValue]*
  %33 = zext i32 %2 to i64
  br label %34

; <label>:34:                                     ; preds = %34, %30
  %35 = phi i64 [ 0, %30 ], [ %37, %34 ]
  %36 = getelementptr inbounds [1 x %union.UValue], [1 x %union.UValue]* %32, i64 0, i64 %35, i32 0, i32 1
  store i8 0, i8* %36, align 8, !tbaa !21
  %37 = add nuw nsw i64 %35, 1
  %38 = icmp eq i64 %37, %33
  br i1 %38, label %39, label %34

; <label>:39:                                     ; preds = %34, %18
  ret %struct.Udata* %22
}

; Function Attrs: nounwind uwtable
define i8* @lua_getupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !79
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %7 = call fastcc i8* @aux_upvalue(%struct.TValue* %6, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** null)
  %8 = icmp eq i8* %7, null
  br i1 %8, label %22, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !79
  %14 = bitcast %struct.TValue* %13 to i64*
  %15 = bitcast %struct.TValue* %12 to i64*
  %16 = load i64, i64* %14, align 8
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %18, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %10, align 8, !tbaa !20
  br label %22

; <label>:22:                                     ; preds = %3, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %7
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @aux_upvalue(%struct.TValue* nocapture readonly, i32, %struct.TValue** nocapture, %struct.GCObject**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %53 [
    i6 -10, label %8
    i6 22, label %22
  ]

; <label>:8:                                      ; preds = %4
  %9 = bitcast %struct.TValue* %0 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = add i32 %1, -1
  %12 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 3
  %13 = load i8, i8* %12, align 2, !tbaa !105
  %14 = zext i8 %13 to i32
  %15 = icmp ult i32 %11, %14
  br i1 %15, label %16, label %53

; <label>:16:                                     ; preds = %8
  %17 = sext i32 %11 to i64
  %18 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 6, i64 %17
  store %struct.TValue* %18, %struct.TValue** %2, align 8, !tbaa !79
  %19 = icmp eq %struct.GCObject** %3, null
  br i1 %19, label %53, label %20

; <label>:20:                                     ; preds = %16
  %21 = bitcast %struct.GCObject** %3 to %struct.CClosure**
  store %struct.CClosure* %10, %struct.CClosure** %21, align 8, !tbaa !79
  br label %53

; <label>:22:                                     ; preds = %4
  %23 = bitcast %struct.TValue* %0 to %struct.LClosure**
  %24 = load %struct.LClosure*, %struct.LClosure** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 5
  %26 = load %struct.Proto*, %struct.Proto** %25, align 8, !tbaa !173
  %27 = add i32 %1, -1
  %28 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 6
  %29 = load i32, i32* %28, align 8, !tbaa !166
  %30 = icmp ult i32 %27, %29
  br i1 %30, label %31, label %53

; <label>:31:                                     ; preds = %22
  %32 = sext i32 %27 to i64
  %33 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 6, i64 %32
  %34 = load %struct.UpVal*, %struct.UpVal** %33, align 8, !tbaa !79
  %35 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %34, i64 0, i32 3
  %36 = bitcast %struct.TValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !50
  %38 = bitcast %struct.TValue** %2 to i64*
  store i64 %37, i64* %38, align 8, !tbaa !79
  %39 = icmp eq %struct.GCObject** %3, null
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %31
  %41 = bitcast %struct.UpVal** %33 to i64*
  %42 = load i64, i64* %41, align 8, !tbaa !79
  %43 = bitcast %struct.GCObject** %3 to i64*
  store i64 %42, i64* %43, align 8, !tbaa !79
  br label %44

; <label>:44:                                     ; preds = %31, %40
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 18
  %46 = load %struct.Upvaldesc*, %struct.Upvaldesc** %45, align 8, !tbaa !174
  %47 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %46, i64 %32, i32 0
  %48 = load %struct.TString*, %struct.TString** %47, align 8, !tbaa !175
  %49 = icmp eq %struct.TString* %48, null
  %50 = getelementptr inbounds %struct.TString, %struct.TString* %48, i64 1
  %51 = bitcast %struct.TString* %50 to i8*
  %52 = select i1 %49, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.283, i64 0, i64 0), i8* %51
  br label %53

; <label>:53:                                     ; preds = %4, %44, %22, %8, %16, %20
  %54 = phi i8* [ null, %8 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %16 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %20 ], [ %52, %44 ], [ null, %22 ], [ null, %4 ]
  ret i8* %54
}

; Function Attrs: nounwind uwtable
define i8* @lua_setupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = alloca %struct.GCObject*, align 8
  %6 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !79
  %7 = bitcast %struct.GCObject** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  store %struct.GCObject* null, %struct.GCObject** %5, align 8, !tbaa !79
  %8 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %9 = call fastcc i8* @aux_upvalue(%struct.TValue* %8, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** nonnull %5)
  %10 = icmp eq i8* %9, null
  br i1 %10, label %38, label %11

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1
  store %union.StackValue* %14, %union.StackValue** %12, align 8, !tbaa !20
  %15 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !79
  %16 = bitcast %union.StackValue* %14 to i64*
  %17 = bitcast %struct.TValue* %15 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = and i8 %20, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %38, label %24

; <label>:24:                                     ; preds = %11
  %25 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !79
  %26 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %25, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !53
  %28 = and i8 %27, 32
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %38, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !53
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %30
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %25, %struct.GCObject* %32)
  br label %38

; <label>:38:                                     ; preds = %30, %24, %11, %3, %37
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i8* %9
}

; Function Attrs: norecurse nounwind uwtable
define i8* @lua_upvalueid(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %19 [
    i6 22, label %8
    i6 -10, label %12
  ]

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %1, i32 %2, %struct.LClosure** null)
  %10 = bitcast %struct.UpVal** %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !79
  br label %19

; <label>:12:                                     ; preds = %3
  %13 = bitcast %struct.TValue* %4 to %struct.CClosure**
  %14 = load %struct.CClosure*, %struct.CClosure** %13, align 8, !tbaa !21
  %15 = add nsw i32 %2, -1
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %14, i64 0, i32 6, i64 %16
  %18 = bitcast %struct.TValue* %17 to i8*
  br label %19

; <label>:19:                                     ; preds = %3, %12, %8
  %20 = phi i8* [ %18, %12 ], [ %11, %8 ], [ null, %3 ]
  ret i8* %20
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc nonnull %struct.UpVal** @getupvalref(%struct.lua_State* nocapture readonly, i32, i32, %struct.LClosure**) unnamed_addr #2 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1)
  %6 = bitcast %struct.TValue* %5 to %struct.LClosure**
  %7 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !21
  %8 = icmp eq %struct.LClosure** %3, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %4
  store %struct.LClosure* %7, %struct.LClosure** %3, align 8, !tbaa !79
  br label %10

; <label>:10:                                     ; preds = %4, %9
  %11 = add nsw i32 %2, -1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 6, i64 %12
  ret %struct.UpVal** %13
}

; Function Attrs: nounwind uwtable
define void @lua_upvaluejoin(%struct.lua_State* nocapture readonly, i32, i32, i32, i32) local_unnamed_addr #0 {
  %6 = alloca %struct.LClosure*, align 8
  %7 = bitcast %struct.LClosure** %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %1, i32 %2, %struct.LClosure** nonnull %6)
  %9 = call fastcc %struct.UpVal** @getupvalref(%struct.lua_State* %0, i32 %3, i32 %4, %struct.LClosure** null)
  %10 = load %struct.UpVal*, %struct.UpVal** %9, align 8, !tbaa !79
  store %struct.UpVal* %10, %struct.UpVal** %8, align 8, !tbaa !79
  %11 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !79
  %12 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %11, i64 0, i32 2
  %13 = load i8, i8* %12, align 1, !tbaa !177
  %14 = and i8 %13, 32
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %24, label %16

; <label>:16:                                     ; preds = %5
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %10, i64 0, i32 2
  %18 = load i8, i8* %17, align 1, !tbaa !52
  %19 = and i8 %18, 24
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %24, label %21

; <label>:21:                                     ; preds = %16
  %22 = bitcast %struct.LClosure* %11 to %struct.GCObject*
  %23 = bitcast %struct.UpVal* %10 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %22, %struct.GCObject* %23)
  br label %24

; <label>:24:                                     ; preds = %16, %5, %21
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_traceback(%struct.lua_State*, %struct.lua_State*, i8*, i32) local_unnamed_addr #0 {
  %5 = alloca %struct.lua_Debug, align 8
  %6 = bitcast %struct.lua_Debug* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %8 = tail call fastcc i32 @lastlevel(%struct.lua_State* %1)
  %9 = sub nsw i32 %8, %3
  %10 = icmp sgt i32 %9, 21
  %11 = select i1 %10, i32 10, i32 -1
  %12 = icmp eq i8* %2, null
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %4
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* nonnull %2)
  br label %15

; <label>:15:                                     ; preds = %4, %13
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 10, i8* null)
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.8, i64 0, i64 0))
  %17 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %3, %struct.lua_Debug* nonnull %5)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %52, label %19

; <label>:19:                                     ; preds = %15
  %20 = add nsw i32 %8, -11
  %21 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 15, i64 0
  %22 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 6
  %23 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 12
  br label %24

; <label>:24:                                     ; preds = %19, %47
  %25 = phi i32 [ %11, %19 ], [ %27, %47 ]
  %26 = phi i32 [ %3, %19 ], [ %49, %47 ]
  %27 = add nsw i32 %25, -1
  %28 = icmp eq i32 %25, 0
  br i1 %28, label %29, label %31

; <label>:29:                                     ; preds = %24
  %30 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i64 0, i64 0))
  br label %47

; <label>:31:                                     ; preds = %24
  %32 = call i32 @lua_getinfo(%struct.lua_State* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i64 0, i64 0), %struct.lua_Debug* nonnull %5)
  %33 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i64 0, i64 0), i8* nonnull %21)
  %34 = load i32, i32* %22, align 8, !tbaa !90
  %35 = icmp sgt i32 %34, 0
  br i1 %35, label %36, label %38

; <label>:36:                                     ; preds = %31
  %37 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i64 0, i64 0), i32 %34)
  br label %38

; <label>:38:                                     ; preds = %36, %31
  %39 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i64 0, i64 0))
  call fastcc void @pushfuncname(%struct.lua_State* %0, %struct.lua_Debug* nonnull %5)
  %40 = load i8, i8* %23, align 1, !tbaa !96
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %44, label %42

; <label>:42:                                     ; preds = %38
  %43 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.14, i64 0, i64 0))
  br label %44

; <label>:44:                                     ; preds = %38, %42
  %45 = call i32 @lua_gettop(%struct.lua_State* %0)
  %46 = sub nsw i32 %45, %7
  call void @lua_concat(%struct.lua_State* %0, i32 %46)
  br label %47

; <label>:47:                                     ; preds = %44, %29
  %48 = phi i32 [ %20, %29 ], [ %26, %44 ]
  %49 = add nsw i32 %48, 1
  %50 = call i32 @lua_getstack(%struct.lua_State* %1, i32 %49, %struct.lua_Debug* nonnull %5)
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %52, label %24

; <label>:52:                                     ; preds = %47, %15
  %53 = call i32 @lua_gettop(%struct.lua_State* %0)
  %54 = sub nsw i32 %53, %7
  call void @lua_concat(%struct.lua_State* %0, i32 %54)
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @lastlevel(%struct.lua_State* readonly) unnamed_addr #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %3) #7
  br label %4

; <label>:4:                                      ; preds = %4, %1
  %5 = phi i32 [ 1, %1 ], [ %9, %4 ]
  %6 = phi i32 [ 1, %1 ], [ %5, %4 ]
  %7 = call i32 @lua_getstack(%struct.lua_State* %0, i32 %5, %struct.lua_Debug* nonnull %2)
  %8 = icmp eq i32 %7, 0
  %9 = shl nsw i32 %5, 1
  br i1 %8, label %10, label %4

; <label>:10:                                     ; preds = %4
  %11 = icmp slt i32 %6, %5
  br i1 %11, label %12, label %24

; <label>:12:                                     ; preds = %10
  br label %13

; <label>:13:                                     ; preds = %12, %13
  %14 = phi i32 [ %22, %13 ], [ %6, %12 ]
  %15 = phi i32 [ %21, %13 ], [ %5, %12 ]
  %16 = add nsw i32 %14, %15
  %17 = sdiv i32 %16, 2
  %18 = call i32 @lua_getstack(%struct.lua_State* %0, i32 %17, %struct.lua_Debug* nonnull %2)
  %19 = icmp eq i32 %18, 0
  %20 = add nsw i32 %17, 1
  %21 = select i1 %19, i32 %17, i32 %15
  %22 = select i1 %19, i32 %14, i32 %20
  %23 = icmp slt i32 %22, %21
  br i1 %23, label %13, label %24

; <label>:24:                                     ; preds = %13, %10
  %25 = phi i32 [ %5, %10 ], [ %21, %13 ]
  %26 = add nsw i32 %25, -1
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %3) #7
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define void @luaL_checkstack(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i8* %2, null
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %6
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i64 0, i64 0), i8* nonnull %2)
  unreachable

; <label>:10:                                     ; preds = %6
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0))
  unreachable

; <label>:12:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushfuncname(%struct.lua_State*, %struct.lua_Debug*) unnamed_addr #0 {
  %3 = tail call fastcc i32 @pushglobalfuncname(%struct.lua_State* %0, %struct.lua_Debug* %1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %8, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.284, i64 0, i64 0), i8* %6)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %30

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 2
  %10 = load i8*, i8** %9, align 8, !tbaa !97
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %8
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !98
  %16 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.285, i64 0, i64 0), i8* %10, i8* %15)
  br label %30

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 3
  %19 = load i8*, i8** %18, align 8, !tbaa !178
  %20 = load i8, i8* %19, align 1, !tbaa !21
  switch i8 %20, label %23 [
    i8 109, label %21
    i8 67, label %28
  ]

; <label>:21:                                     ; preds = %17
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.286, i64 0, i64 0))
  br label %30

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 15, i64 0
  %25 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 7
  %26 = load i32, i32* %25, align 4, !tbaa !179
  %27 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.287, i64 0, i64 0), i8* nonnull %24, i32 %26)
  br label %30

; <label>:28:                                     ; preds = %17
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0))
  br label %30

; <label>:30:                                     ; preds = %13, %23, %28, %21, %5
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_argerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.lua_Debug, align 8
  %5 = bitcast %struct.lua_Debug* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %5) #7
  %6 = call i32 @lua_getstack(%struct.lua_State* %0, i32 0, %struct.lua_Debug* nonnull %4)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15, i64 0, i64 0), i32 %1, i8* %2)
  unreachable

; <label>:10:                                     ; preds = %3
  %11 = call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0), %struct.lua_Debug* nonnull %4)
  %12 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 2
  %13 = load i8*, i8** %12, align 8, !tbaa !97
  %14 = tail call i32 @strcmp(i8* %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0)) #19
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %10
  %17 = add nsw i32 %1, -1
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %23

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %21 = load i8*, i8** %20, align 8, !tbaa !98
  %22 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.18, i64 0, i64 0), i8* %21, i8* %2)
  unreachable

; <label>:23:                                     ; preds = %16, %10
  %24 = phi i32 [ %17, %16 ], [ %1, %10 ]
  %25 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %26 = load i8*, i8** %25, align 8, !tbaa !98
  %27 = icmp eq i8* %26, null
  br i1 %27, label %28, label %35

; <label>:28:                                     ; preds = %23
  %29 = call fastcc i32 @pushglobalfuncname(%struct.lua_State* %0, %struct.lua_Debug* nonnull %4)
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %33, label %31

; <label>:31:                                     ; preds = %28
  %32 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  br label %33

; <label>:33:                                     ; preds = %28, %31
  %34 = phi i8* [ %32, %31 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %28 ]
  store i8* %34, i8** %25, align 8, !tbaa !98
  br label %35

; <label>:35:                                     ; preds = %33, %23
  %36 = load i8*, i8** %25, align 8, !tbaa !98
  %37 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.19, i64 0, i64 0), i32 %24, i8* %36, i8* %2)
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define i32 @luaL_error(%struct.lua_State*, i8*, ...) local_unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  call void @luaL_where(%struct.lua_State* %0, i32 1)
  %6 = call i8* @lua_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5)
  call void @llvm.va_end(i8* nonnull %4)
  call void @lua_concat(%struct.lua_State* %0, i32 2)
  %7 = call i32 @lua_error(%struct.lua_State* %0)
  unreachable
}

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc i32 @pushglobalfuncname(%struct.lua_State*, %struct.lua_Debug* nocapture) unnamed_addr #0 {
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = tail call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.288, i64 0, i64 0), %struct.lua_Debug* %1)
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0))
  %6 = add nsw i32 %3, 1
  %7 = tail call fastcc i32 @findfield(%struct.lua_State* %0, i32 %6, i32 2)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %17, label %9

; <label>:9:                                      ; preds = %2
  %10 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %11 = tail call i32 @strncmp(i8* %10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.289, i64 0, i64 0), i64 3) #19
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %16

; <label>:13:                                     ; preds = %9
  %14 = getelementptr inbounds i8, i8* %10, i64 3
  %15 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %14)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %16

; <label>:16:                                     ; preds = %13, %9
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 %6)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %18

; <label>:17:                                     ; preds = %2
  tail call void @lua_settop(%struct.lua_State* %0, i32 %3)
  br label %18

; <label>:18:                                     ; preds = %17, %16
  %19 = phi i32 [ 1, %16 ], [ 0, %17 ]
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define i32 @luaL_typeerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0))
  %5 = icmp eq i32 %4, 4
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  br label %13

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %10 = icmp eq i32 %9, 2
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %9)
  br label %13

; <label>:13:                                     ; preds = %8, %11, %6
  %14 = phi i8* [ %7, %6 ], [ %12, %11 ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i64 0, i64 0), %8 ]
  %15 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.22, i64 0, i64 0), i8* %2, i8* %14)
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %15)
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define i32 @luaL_getmetafield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %12, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2)
  %8 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %6
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %12

; <label>:11:                                     ; preds = %6
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %12

; <label>:12:                                     ; preds = %10, %11, %3
  %13 = phi i32 [ 0, %3 ], [ %8, %11 ], [ 0, %10 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define void @luaL_where(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %4) #7
  %5 = call i32 @lua_getstack(%struct.lua_State* %0, i32 %1, %struct.lua_Debug* nonnull %3)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i64 0, i64 0), %struct.lua_Debug* nonnull %3)
  %9 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 6
  %10 = load i32, i32* %9, align 8, !tbaa !90
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %12, label %15

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 15, i64 0
  %14 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24, i64 0, i64 0), i8* nonnull %13, i32 %10)
  br label %17

; <label>:15:                                     ; preds = %2, %7
  %16 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  br label %17

; <label>:17:                                     ; preds = %15, %12
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_fileresult(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #21
  %5 = load i32, i32* %4, align 4, !tbaa !70
  %6 = icmp eq i32 %1, 0
  br i1 %6, label %8, label %7

; <label>:7:                                      ; preds = %3
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %17

; <label>:8:                                      ; preds = %3
  tail call void @lua_pushnil(%struct.lua_State* %0)
  %9 = icmp eq i8* %2, null
  %10 = tail call i8* @strerror(i32 %5) #7
  br i1 %9, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25, i64 0, i64 0), i8* nonnull %2, i8* %10)
  br label %15

; <label>:13:                                     ; preds = %8
  %14 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %10)
  br label %15

; <label>:15:                                     ; preds = %13, %11
  %16 = sext i32 %5 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %16)
  br label %17

; <label>:17:                                     ; preds = %15, %7
  %18 = phi i32 [ 1, %7 ], [ 3, %15 ]
  ret i32 %18
}

; Function Attrs: nounwind readnone
declare i32* @__errno_location() local_unnamed_addr #8

; Function Attrs: nounwind
declare i8* @strerror(i32) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define i32 @luaL_execresult(%struct.lua_State*, i32) local_unnamed_addr #0 {
  switch i32 %1, label %6 [
    i32 -1, label %3
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %2
  %4 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null)
  br label %10

; <label>:5:                                      ; preds = %2
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %7

; <label>:6:                                      ; preds = %2
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %7

; <label>:7:                                      ; preds = %6, %5
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i64 0, i64 0))
  %9 = sext i32 %1 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %9)
  br label %10

; <label>:10:                                     ; preds = %7, %3
  %11 = phi i32 [ %4, %3 ], [ 3, %7 ]
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @luaL_newmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 2)
  %6 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0))
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  br label %7

; <label>:7:                                      ; preds = %2, %5
  %8 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define void @luaL_setmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %4 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @luaL_testudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i8* %4, null
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %6
  %10 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %2)
  %11 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 -1, i32 -2)
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, i8* null, i8* %4
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %14

; <label>:14:                                     ; preds = %3, %6, %9
  %15 = phi i8* [ %13, %9 ], [ null, %6 ], [ null, %3 ]
  ret i8* %15
}

; Function Attrs: nounwind uwtable
define i8* @luaL_checkudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 %1, i8* %2)
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %2)
  br label %8

; <label>:8:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define i32 @luaL_checkoption(%struct.lua_State*, i32, i8*, i8** nocapture readonly) local_unnamed_addr #0 {
  %5 = icmp eq i8* %2, null
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 %1, i8* nonnull %2, i64* null)
  br label %10

; <label>:8:                                      ; preds = %4
  %9 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* null)
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  %12 = load i8*, i8** %3, align 8, !tbaa !79
  %13 = icmp eq i8* %12, null
  br i1 %13, label %25, label %14

; <label>:14:                                     ; preds = %10
  br label %15

; <label>:15:                                     ; preds = %14, %20
  %16 = phi i64 [ %21, %20 ], [ 0, %14 ]
  %17 = phi i8* [ %23, %20 ], [ %12, %14 ]
  %18 = tail call i32 @strcmp(i8* nonnull %17, i8* %11) #19
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %15
  %21 = add nuw i64 %16, 1
  %22 = getelementptr inbounds i8*, i8** %3, i64 %21
  %23 = load i8*, i8** %22, align 8, !tbaa !79
  %24 = icmp eq i8* %23, null
  br i1 %24, label %25, label %15

; <label>:25:                                     ; preds = %20, %10
  %26 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.27, i64 0, i64 0), i8* %11)
  %27 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %26)
  br label %30

; <label>:28:                                     ; preds = %15
  %29 = trunc i64 %16 to i32
  br label %30

; <label>:30:                                     ; preds = %28, %25
  %31 = phi i32 [ %27, %25 ], [ %29, %28 ]
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i8* @luaL_optlstring(%struct.lua_State*, i32, i8* readonly, i64*) local_unnamed_addr #0 {
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %6 = icmp slt i32 %5, 1
  br i1 %6, label %7, label %15

; <label>:7:                                      ; preds = %4
  %8 = icmp eq i64* %3, null
  br i1 %8, label %17, label %9

; <label>:9:                                      ; preds = %7
  %10 = icmp eq i8* %2, null
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %9
  %12 = tail call i64 @strlen(i8* nonnull %2) #19
  br label %13

; <label>:13:                                     ; preds = %9, %11
  %14 = phi i64 [ %12, %11 ], [ 0, %9 ]
  store i64 %14, i64* %3, align 8, !tbaa !113
  br label %17

; <label>:15:                                     ; preds = %4
  %16 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* %3)
  br label %17

; <label>:17:                                     ; preds = %13, %7, %15
  %18 = phi i8* [ %16, %15 ], [ %2, %7 ], [ %2, %13 ]
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define i8* @luaL_checklstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* %2)
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %3
  tail call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 4)
  br label %7

; <label>:7:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define void @luaL_checktype(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i32 %4, %2
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %3
  tail call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 %2)
  br label %7

; <label>:7:                                      ; preds = %3, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @tag_error(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %2)
  %5 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_checkany(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0))
  br label %7

; <label>:7:                                      ; preds = %5, %2
  ret void
}

; Function Attrs: argmemonly nounwind readonly
declare i64 @strlen(i8* nocapture) local_unnamed_addr #10

; Function Attrs: nounwind uwtable
define double @luaL_checknumber(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* nonnull %3)
  %6 = load i32, i32* %3, align 4, !tbaa !70
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %2
  call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 3)
  br label %9

; <label>:9:                                      ; preds = %2, %8
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret double %5
}

; Function Attrs: nounwind uwtable
define double @luaL_optnumber(%struct.lua_State*, i32, double) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 %1)
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi double [ %7, %6 ], [ %2, %3 ]
  ret double %9
}

; Function Attrs: nounwind uwtable
define i64 @luaL_checkinteger(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* nonnull %3)
  %6 = load i32, i32* %3, align 4, !tbaa !70
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %2
  call fastcc void @interror(%struct.lua_State* %0, i32 %1)
  br label %9

; <label>:9:                                      ; preds = %2, %8
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define internal fastcc void @interror(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i32 @lua_isnumber(%struct.lua_State* %0, i32 %1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.291, i64 0, i64 0))
  br label %8

; <label>:7:                                      ; preds = %2
  tail call fastcc void @tag_error(%struct.lua_State* %0, i32 %1, i32 3)
  br label %8

; <label>:8:                                      ; preds = %7, %5
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @luaL_optinteger(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1)
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi i64 [ %7, %6 ], [ %2, %3 ]
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define i8* @luaL_prepbuffsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %1, i32 -1)
  ret i8* %3
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @prepbuffsize(%struct.luaL_Buffer*, i64, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 1
  %5 = load i64, i64* %4, align 8, !tbaa !180
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !182
  %8 = sub i64 %5, %7
  %9 = icmp ult i64 %8, %1
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %12 = load i8*, i8** %11, align 8, !tbaa !183
  %13 = getelementptr inbounds i8, i8* %12, i64 %7
  br label %34

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %16 = load %struct.lua_State*, %struct.lua_State** %15, align 8, !tbaa !184
  %17 = tail call fastcc i64 @newbuffsize(%struct.luaL_Buffer* nonnull %0, i64 %1)
  %18 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %19 = load i8*, i8** %18, align 8, !tbaa !183
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %21 = bitcast %union.anon.6* %20 to i8*
  %22 = icmp eq i8* %19, %21
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %14
  %24 = tail call fastcc i8* @resizebox(%struct.lua_State* %16, i32 %2, i64 %17)
  br label %30

; <label>:25:                                     ; preds = %14
  tail call void @lua_pushnil(%struct.lua_State* %16)
  tail call fastcc void @newbox(%struct.lua_State* %16)
  %26 = add nsw i32 %2, -1
  tail call void @lua_rotate(%struct.lua_State* %16, i32 %26, i32 2)
  tail call void @lua_toclose(%struct.lua_State* %16, i32 %2)
  %27 = tail call fastcc i8* @resizebox(%struct.lua_State* %16, i32 %2, i64 %17)
  %28 = load i8*, i8** %18, align 8, !tbaa !183
  %29 = load i64, i64* %6, align 8, !tbaa !182
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %27, i8* %28, i64 %29, i32 1, i1 false)
  br label %30

; <label>:30:                                     ; preds = %25, %23
  %31 = phi i8* [ %24, %23 ], [ %27, %25 ]
  store i8* %31, i8** %18, align 8, !tbaa !183
  store i64 %17, i64* %4, align 8, !tbaa !180
  %32 = load i64, i64* %6, align 8, !tbaa !182
  %33 = getelementptr inbounds i8, i8* %31, i64 %32
  br label %34

; <label>:34:                                     ; preds = %30, %10
  %35 = phi i8* [ %13, %10 ], [ %33, %30 ]
  ret i8* %35
}

; Function Attrs: nounwind uwtable
define void @luaL_addlstring(%struct.luaL_Buffer*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %2, i32 -1)
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %1, i64 %2, i32 1, i1 false)
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %8 = load i64, i64* %7, align 8, !tbaa !182
  %9 = add i64 %8, %2
  store i64 %9, i64* %7, align 8, !tbaa !182
  br label %10

; <label>:10:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_addstring(%struct.luaL_Buffer*, i8* nocapture readonly) local_unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %1) #19
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %0, i8* %1, i64 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_pushresult(%struct.luaL_Buffer* readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !184
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %5 = load i8*, i8** %4, align 8, !tbaa !183
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !182
  %8 = tail call i8* @lua_pushlstring(%struct.lua_State* %3, i8* %5, i64 %7)
  %9 = load i8*, i8** %4, align 8, !tbaa !183
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %11 = bitcast %union.anon.6* %10 to i8*
  %12 = icmp eq i8* %9, %11
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %1
  tail call void @lua_copy(%struct.lua_State* %3, i32 -1, i32 -3)
  tail call void @lua_settop(%struct.lua_State* %3, i32 -3)
  br label %14

; <label>:14:                                     ; preds = %1, %13
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_pushresultsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %4 = load i64, i64* %3, align 8, !tbaa !182
  %5 = add i64 %4, %1
  store i64 %5, i64* %3, align 8, !tbaa !182
  tail call void @luaL_pushresult(%struct.luaL_Buffer* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_addvalue(%struct.luaL_Buffer*) local_unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !184
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @lua_tolstring(%struct.lua_State* %4, i32 -1, i64* nonnull %2)
  %7 = load i64, i64* %2, align 8, !tbaa !113
  %8 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %7, i32 -2)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %6, i64 %9, i32 1, i1 false)
  %10 = load i64, i64* %2, align 8, !tbaa !113
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %12 = load i64, i64* %11, align 8, !tbaa !182
  %13 = add i64 %12, %10
  store i64 %13, i64* %11, align 8, !tbaa !182
  call void @lua_settop(%struct.lua_State* %4, i32 -2)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define void @luaL_buffinit(%struct.lua_State*, %struct.luaL_Buffer*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %3, align 8, !tbaa !184
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 4
  %5 = bitcast %struct.luaL_Buffer* %1 to %union.anon.6**
  store %union.anon.6* %4, %union.anon.6** %5, align 8, !tbaa !183
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 2
  store i64 0, i64* %6, align 8, !tbaa !182
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  store i64 1024, i64* %7, align 8, !tbaa !180
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @luaL_buffinitsize(%struct.lua_State*, %struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  tail call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* %1)
  %4 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %1, i64 %2, i32 -1)
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define i32 @luaL_ref(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %2
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %23

; <label>:6:                                      ; preds = %2
  %7 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1)
  %8 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %7, i64 0)
  %9 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* null)
  %10 = trunc i64 %9 to i32
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %6
  %13 = shl i64 %9, 32
  %14 = ashr exact i64 %13, 32
  %15 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %7, i64 %14)
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %7, i64 0)
  br label %20

; <label>:16:                                     ; preds = %6
  %17 = tail call i64 @lua_rawlen(%struct.lua_State* %0, i32 %7)
  %18 = trunc i64 %17 to i32
  %19 = add nsw i32 %18, 1
  br label %20

; <label>:20:                                     ; preds = %16, %12
  %21 = phi i32 [ %10, %12 ], [ %19, %16 ]
  %22 = sext i32 %21 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %7, i64 %22)
  br label %23

; <label>:23:                                     ; preds = %20, %5
  %24 = phi i32 [ -1, %5 ], [ %21, %20 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define void @luaL_unref(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = icmp sgt i32 %2, -1
  br i1 %4, label %5, label %9

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1)
  %7 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %6, i64 0)
  %8 = sext i32 %2 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %6, i64 %8)
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %8)
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %6, i64 0)
  br label %9

; <label>:9:                                      ; preds = %5, %3
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_loadfilex(%struct.lua_State*, i8*, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.LoadF, align 8
  %5 = alloca i32, align 4
  %6 = bitcast %struct.LoadF* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8208, i8* nonnull %6) #7
  %7 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %9 = add nsw i32 %8, 1
  %10 = icmp eq i8* %1, null
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %3
  %12 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0))
  %13 = load i64, i64* bitcast (%struct._IO_FILE** @stdin to i64*), align 8, !tbaa !79
  %14 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %15 = bitcast %struct._IO_FILE** %14 to i64*
  store i64 %13, i64* %15, align 8, !tbaa !185
  br label %22

; <label>:16:                                     ; preds = %3
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.32, i64 0, i64 0), i8* nonnull %1)
  %18 = tail call %struct._IO_FILE* @fopen64(i8* nonnull %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0))
  %19 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  store %struct._IO_FILE* %18, %struct._IO_FILE** %19, align 8, !tbaa !185
  %20 = icmp eq %struct._IO_FILE* %18, null
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %16
  tail call fastcc void @errfile(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i64 0, i64 0), i32 %9)
  br label %67

; <label>:22:                                     ; preds = %16, %11
  %23 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5)
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %31, label %25

; <label>:25:                                     ; preds = %22
  %26 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %27 = load i32, i32* %26, align 8, !tbaa !187
  %28 = add nsw i32 %27, 1
  store i32 %28, i32* %26, align 8, !tbaa !187
  %29 = sext i32 %27 to i64
  %30 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %29
  store i8 10, i8* %30, align 1, !tbaa !21
  br label %31

; <label>:31:                                     ; preds = %22, %25
  %32 = load i32, i32* %5, align 4, !tbaa !70
  %33 = icmp eq i32 %32, 27
  %34 = icmp ne i8* %1, null
  %35 = and i1 %34, %33
  br i1 %35, label %36, label %45

; <label>:36:                                     ; preds = %31
  %37 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %38 = load %struct._IO_FILE*, %struct._IO_FILE** %37, align 8, !tbaa !185
  %39 = tail call %struct._IO_FILE* @freopen64(i8* nonnull %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.36, i64 0, i64 0), %struct._IO_FILE* %38) #7
  store %struct._IO_FILE* %39, %struct._IO_FILE** %37, align 8, !tbaa !185
  %40 = icmp eq %struct._IO_FILE* %39, null
  br i1 %40, label %41, label %42

; <label>:41:                                     ; preds = %36
  tail call fastcc void @errfile(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i64 0, i64 0), i32 %9)
  br label %67

; <label>:42:                                     ; preds = %36
  %43 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5)
  %44 = load i32, i32* %5, align 4, !tbaa !70
  br label %45

; <label>:45:                                     ; preds = %42, %31
  %46 = phi i32 [ %44, %42 ], [ %32, %31 ]
  %47 = icmp eq i32 %46, -1
  br i1 %47, label %55, label %48

; <label>:48:                                     ; preds = %45
  %49 = trunc i32 %46 to i8
  %50 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %51 = load i32, i32* %50, align 8, !tbaa !187
  %52 = add nsw i32 %51, 1
  store i32 %52, i32* %50, align 8, !tbaa !187
  %53 = sext i32 %51 to i64
  %54 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %53
  store i8 %49, i8* %54, align 1, !tbaa !21
  br label %55

; <label>:55:                                     ; preds = %45, %48
  %56 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %57 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getF, i8* nonnull %6, i8* %56, i8* %2)
  %58 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %59 = load %struct._IO_FILE*, %struct._IO_FILE** %58, align 8, !tbaa !185
  %60 = call i32 @ferror(%struct._IO_FILE* %59) #7
  br i1 %34, label %61, label %63

; <label>:61:                                     ; preds = %55
  %62 = call i32 @fclose(%struct._IO_FILE* %59)
  br label %63

; <label>:63:                                     ; preds = %61, %55
  %64 = icmp eq i32 %60, 0
  br i1 %64, label %66, label %65

; <label>:65:                                     ; preds = %63
  call void @lua_settop(%struct.lua_State* %0, i32 %9)
  call fastcc void @errfile(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i64 0, i64 0), i32 %9)
  br label %67

; <label>:66:                                     ; preds = %63
  call void @lua_rotate(%struct.lua_State* %0, i32 %9, i32 -1)
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %67

; <label>:67:                                     ; preds = %66, %65, %41, %21
  %68 = phi i32 [ 6, %41 ], [ 6, %65 ], [ %57, %66 ], [ 6, %21 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8208, i8* nonnull %6) #7
  ret i32 %68
}

; Function Attrs: nounwind
declare noalias %struct._IO_FILE* @fopen64(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc void @errfile(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #21
  %5 = load i32, i32* %4, align 4, !tbaa !70
  %6 = tail call i8* @strerror(i32 %5) #7
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %2, i64* null)
  %8 = getelementptr inbounds i8, i8* %7, i64 1
  %9 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.295, i64 0, i64 0), i8* %1, i8* nonnull %8, i8* %6)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @skipcomment(%struct.LoadF* nocapture, i32* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @skipBOM(%struct.LoadF* %0)
  store i32 %3, i32* %1, align 4, !tbaa !70
  %4 = icmp eq i32 %3, 35
  br i1 %4, label %5, label %14

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  br label %7

; <label>:7:                                      ; preds = %7, %5
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** %6, align 8, !tbaa !185
  %9 = tail call i32 @_IO_getc(%struct._IO_FILE* %8)
  switch i32 %9, label %7 [
    i32 -1, label %10
    i32 10, label %10
  ]

; <label>:10:                                     ; preds = %7, %7
  %11 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** %11, align 8, !tbaa !185
  %13 = tail call i32 @_IO_getc(%struct._IO_FILE* %12)
  store i32 %13, i32* %1, align 4, !tbaa !70
  br label %14

; <label>:14:                                     ; preds = %2, %10
  %15 = phi i32 [ 1, %10 ], [ 0, %2 ]
  ret i32 %15
}

declare %struct._IO_FILE* @freopen64(i8*, i8*, %struct._IO_FILE*) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define internal i8* @getF(%struct.lua_State* nocapture readnone, i8*, i64* nocapture) #0 {
  %4 = bitcast i8* %1 to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !187
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %3
  %8 = sext i32 %5 to i64
  store i64 %8, i64* %2, align 8, !tbaa !113
  store i32 0, i32* %4, align 8, !tbaa !187
  br label %19

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds i8, i8* %1, i64 8
  %11 = bitcast i8* %10 to %struct._IO_FILE**
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** %11, align 8, !tbaa !185
  %13 = tail call i32 @feof(%struct._IO_FILE* %12) #7
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %9
  %16 = getelementptr inbounds i8, i8* %1, i64 16
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** %11, align 8, !tbaa !185
  %18 = tail call i64 @fread(i8* nonnull %16, i64 1, i64 8192, %struct._IO_FILE* %17)
  store i64 %18, i64* %2, align 8, !tbaa !113
  br label %19

; <label>:19:                                     ; preds = %15, %7
  %20 = getelementptr inbounds i8, i8* %1, i64 16
  br label %21

; <label>:21:                                     ; preds = %9, %19
  %22 = phi i8* [ %20, %19 ], [ null, %9 ]
  ret i8* %22
}

; Function Attrs: nounwind readonly
declare i32 @ferror(%struct._IO_FILE* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @fclose(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define i32 @luaL_loadbufferx(%struct.lua_State*, i8*, i64, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.LoadS, align 8
  %7 = bitcast %struct.LoadS* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 0
  store i8* %1, i8** %8, align 8, !tbaa !188
  %9 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 1
  store i64 %2, i64* %9, align 8, !tbaa !190
  %10 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %7, i8* %3, i8* %4)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %7) #7
  ret i32 %10
}

; Function Attrs: norecurse nounwind uwtable
define internal i8* @getS(%struct.lua_State* nocapture readnone, i8* nocapture, i64* nocapture) #2 {
  %4 = getelementptr inbounds i8, i8* %1, i64 8
  %5 = bitcast i8* %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !190
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %3
  store i64 %6, i64* %2, align 8, !tbaa !113
  store i64 0, i64* %5, align 8, !tbaa !190
  %9 = bitcast i8* %1 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !188
  br label %11

; <label>:11:                                     ; preds = %3, %8
  %12 = phi i8* [ %10, %8 ], [ null, %3 ]
  ret i8* %12
}

; Function Attrs: nounwind uwtable
define i32 @luaL_loadstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %1) #19
  %4 = tail call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %3, i8* %1, i8* null)
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define i32 @luaL_callmeta(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1)
  %5 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %4, i8* %2)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %8, label %7

; <label>:7:                                      ; preds = %3
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %4)
  tail call void @lua_callk(%struct.lua_State* %0, i32 1, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  br label %8

; <label>:8:                                      ; preds = %3, %7
  %9 = phi i32 [ 1, %7 ], [ 0, %3 ]
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define i64 @luaL_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  tail call void @lua_len(%struct.lua_State* %0, i32 %1)
  %5 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %3)
  %6 = load i32, i32* %3, align 4, !tbaa !70
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %2
  %9 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.39, i64 0, i64 0))
  unreachable

; <label>:10:                                     ; preds = %2
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i8* @luaL_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0))
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_isstring(%struct.lua_State* %0, i32 -1)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %44

; <label>:9:                                      ; preds = %6
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.41, i64 0, i64 0))
  unreachable

; <label>:11:                                     ; preds = %3
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  switch i32 %12, label %30 [
    i32 3, label %13
    i32 4, label %22
    i32 1, label %23
    i32 0, label %28
  ]

; <label>:13:                                     ; preds = %11
  %14 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 %1)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %13
  %17 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* null)
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.42, i64 0, i64 0), i64 %17)
  br label %44

; <label>:19:                                     ; preds = %13
  %20 = tail call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* null)
  %21 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i64 0, i64 0), double %20)
  br label %44

; <label>:22:                                     ; preds = %11
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %1)
  br label %44

; <label>:23:                                     ; preds = %11
  %24 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 %1)
  %25 = icmp eq i32 %24, 0
  %26 = select i1 %25, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0)
  %27 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %26)
  br label %44

; <label>:28:                                     ; preds = %11
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i64 0, i64 0))
  br label %44

; <label>:30:                                     ; preds = %11
  %31 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0))
  %32 = icmp eq i32 %31, 4
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %30
  %34 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  br label %38

; <label>:35:                                     ; preds = %30
  %36 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %37 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %36)
  br label %38

; <label>:38:                                     ; preds = %35, %33
  %39 = phi i8* [ %34, %33 ], [ %37, %35 ]
  %40 = tail call i8* @lua_topointer(%struct.lua_State* %0, i32 %1)
  %41 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i64 0, i64 0), i8* %39, i8* %40)
  %42 = icmp eq i32 %31, 0
  br i1 %42, label %44, label %43

; <label>:43:                                     ; preds = %38
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %44

; <label>:44:                                     ; preds = %43, %38, %6, %22, %23, %28, %19, %16
  %45 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* %2)
  ret i8* %45
}

; Function Attrs: nounwind uwtable
define void @luaL_setfuncs(%struct.lua_State*, %struct.luaL_Reg* nocapture readonly, i32) local_unnamed_addr #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.48, i64 0, i64 0))
  %4 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %1, i64 0, i32 0
  %5 = load i8*, i8** %4, align 8, !tbaa !191
  %6 = icmp eq i8* %5, null
  br i1 %6, label %26, label %7

; <label>:7:                                      ; preds = %3
  %8 = icmp sgt i32 %2, 0
  %9 = sub nsw i32 0, %2
  %10 = sub i32 -2, %2
  br label %11

; <label>:11:                                     ; preds = %7, %18
  %12 = phi i8** [ %4, %7 ], [ %23, %18 ]
  br i1 %8, label %13, label %18

; <label>:13:                                     ; preds = %11
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i32 [ %16, %14 ], [ 0, %13 ]
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %9)
  %16 = add nuw nsw i32 %15, 1
  %17 = icmp eq i32 %16, %2
  br i1 %17, label %18, label %14

; <label>:18:                                     ; preds = %14, %11
  %19 = getelementptr inbounds i8*, i8** %12, i64 1
  %20 = bitcast i8** %19 to i32 (%struct.lua_State*)**
  %21 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %20, align 8, !tbaa !193
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %21, i32 %2)
  %22 = load i8*, i8** %12, align 8, !tbaa !191
  tail call void @lua_setfield(%struct.lua_State* %0, i32 %10, i8* %22)
  %23 = getelementptr inbounds i8*, i8** %12, i64 2
  %24 = load i8*, i8** %23, align 8, !tbaa !191
  %25 = icmp eq i8* %24, null
  br i1 %25, label %26, label %11

; <label>:26:                                     ; preds = %18, %3
  %27 = xor i32 %2, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %27)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaL_getsubtable(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 %1, i8* %2)
  %5 = icmp eq i32 %4, 5
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %7 = tail call i32 @lua_absindex(%struct.lua_State* %0, i32 %1)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 %7, i8* %2)
  br label %8

; <label>:8:                                      ; preds = %3, %6
  %9 = phi i32 [ 0, %6 ], [ 1, %3 ]
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define void @luaL_requiref(%struct.lua_State*, i8*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %5 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0))
  %6 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1)
  %7 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %4
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %2, i32 0)
  %10 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  tail call void @lua_callk(%struct.lua_State* %0, i32 1, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -3, i8* %1)
  br label %11

; <label>:11:                                     ; preds = %4, %9
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %12 = icmp eq i32 %3, 0
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %11
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* %1)
  br label %14

; <label>:14:                                     ; preds = %11, %13
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_addgsub(%struct.luaL_Buffer*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = tail call i64 @strlen(i8* %2) #19
  %6 = tail call i8* @strstr(i8* %1, i8* %2) #19
  %7 = icmp eq i8* %6, null
  br i1 %7, label %18, label %8

; <label>:8:                                      ; preds = %4
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i8* [ %16, %9 ], [ %6, %8 ]
  %11 = phi i8* [ %15, %9 ], [ %1, %8 ]
  %12 = ptrtoint i8* %10 to i64
  %13 = ptrtoint i8* %11 to i64
  %14 = sub i64 %12, %13
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %0, i8* %11, i64 %14)
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %3)
  %15 = getelementptr inbounds i8, i8* %10, i64 %5
  %16 = tail call i8* @strstr(i8* %15, i8* %2) #19
  %17 = icmp eq i8* %16, null
  br i1 %17, label %18, label %9

; <label>:18:                                     ; preds = %9, %4
  %19 = phi i8* [ %1, %4 ], [ %15, %9 ]
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %19)
  ret void
}

; Function Attrs: nounwind readonly
declare i8* @strstr(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define i8* @luaL_gsub(%struct.lua_State*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %6) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %5)
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %5, i8* %1, i8* %2, i8* %3)
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5)
  %7 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %6) #7
  ret i8* %7
}

; Function Attrs: nounwind uwtable
define %struct.lua_State* @luaL_newstate() local_unnamed_addr #0 {
  %1 = tail call %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)* nonnull @l_alloc, i8* null)
  %2 = icmp eq %struct.lua_State* %1, null
  br i1 %2, label %8, label %3

; <label>:3:                                      ; preds = %0
  %4 = tail call i32 (%struct.lua_State*)* @lua_atpanic(%struct.lua_State* nonnull %1, i32 (%struct.lua_State*)* nonnull @panic)
  %5 = tail call i8* @lua_newuserdatauv(%struct.lua_State* nonnull %1, i64 4, i32 0)
  %6 = bitcast i8* %5 to i32*
  %7 = tail call i32 @luaL_ref(%struct.lua_State* nonnull %1, i32 -1001000)
  store i32 0, i32* %6, align 4, !tbaa !70
  tail call void @lua_setwarnf(%struct.lua_State* nonnull %1, void (i8*, i8*, i32)* nonnull @warnf, i8* nonnull %5)
  br label %8

; <label>:8:                                      ; preds = %0, %3
  ret %struct.lua_State* %1
}

; Function Attrs: nounwind uwtable
define internal noalias i8* @l_alloc(i8* nocapture readnone, i8* nocapture, i64, i64) #0 {
  %5 = icmp eq i64 %3, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call void @free(i8* %1) #7
  br label %9

; <label>:7:                                      ; preds = %4
  %8 = tail call i8* @realloc(i8* %1, i64 %3) #7
  br label %9

; <label>:9:                                      ; preds = %7, %6
  %10 = phi i8* [ null, %6 ], [ %8, %7 ]
  ret i8* %10
}

; Function Attrs: nounwind uwtable
define internal i32 @panic(%struct.lua_State*) #0 {
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %3 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %4 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.297, i64 0, i64 0), i8* %3) #22
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @warnf(i8* nocapture, i8* nocapture readonly, i32) #0 {
  %4 = bitcast i8* %0 to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !70
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %12

; <label>:7:                                      ; preds = %3
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %9 = tail call i64 @fwrite(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.299, i64 0, i64 0), i64 13, i64 1, %struct._IO_FILE* %8) #22
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %11 = tail call i32 @fflush(%struct._IO_FILE* %10)
  br label %12

; <label>:12:                                     ; preds = %3, %7
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %14 = tail call i32 @fputs(i8* %1, %struct._IO_FILE* %13) #22
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %16 = tail call i32 @fflush(%struct._IO_FILE* %15)
  %17 = icmp eq i32 %2, 0
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %12
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %20 = tail call i32 @fputc(i32 10, %struct._IO_FILE* %19) #22
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %22 = tail call i32 @fflush(%struct._IO_FILE* %21)
  br label %23

; <label>:23:                                     ; preds = %12, %18
  store i32 %2, i32* %4, align 4, !tbaa !70
  ret void
}

; Function Attrs: nounwind uwtable
define void @luaL_checkversion_(%struct.lua_State*, double, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 136
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.50, i64 0, i64 0))
  unreachable

; <label>:7:                                      ; preds = %3
  %8 = fcmp une double %1, 5.040000e+02
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %7
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.51, i64 0, i64 0), double %1, double 5.040000e+02)
  unreachable

; <label>:11:                                     ; preds = %7
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_base(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i64 2)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([26 x %struct.luaL_Reg], [26 x %struct.luaL_Reg]* @base_funcs, i64 0, i64 0), i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0))
  %3 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i64 0, i64 0))
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_coroutine(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 8)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([9 x %struct.luaL_Reg], [9 x %struct.luaL_Reg]* @co_funcs, i64 0, i64 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_debug(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 16)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([17 x %struct.luaL_Reg], [17 x %struct.luaL_Reg]* @dblib, i64 0, i64 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_io(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @iolib, i64 0, i64 0), i32 0)
  tail call fastcc void @createmeta(%struct.lua_State* %0)
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !79
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i64 0, i64 0))
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %3, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.58, i64 0, i64 0))
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %4, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createmeta(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i32 @luaL_newmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0))
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @flib, i64 0, i64 0), i32 0)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createstdfile(%struct.lua_State*, %struct._IO_FILE*, i8*, i8*) unnamed_addr #0 {
  %5 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0)
  %6 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 0
  store %struct._IO_FILE* %1, %struct._IO_FILE** %6, align 8, !tbaa !194
  %7 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 1
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %7, align 8, !tbaa !196
  %8 = icmp eq i8* %2, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %4
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* nonnull %2)
  br label %10

; <label>:10:                                     ; preds = %4, %9
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_math(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 27)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([28 x %struct.luaL_Reg], [28 x %struct.luaL_Reg]* @mathlib, i64 0, i64 0), i32 0)
  tail call void @lua_pushnumber(%struct.lua_State* %0, double 0x400921FB54442D18)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i64 0, i64 0))
  tail call void @lua_pushnumber(%struct.lua_State* %0, double 0x7FF0000000000000)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i64 0, i64 0))
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 9223372036854775807)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i64 0, i64 0))
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 -9223372036854775808)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i64 0, i64 0))
  tail call fastcc void @setrandfunc(%struct.lua_State* %0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setrandfunc(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 32, i32 0)
  %3 = bitcast i8* %2 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* %0, %struct.RanState* nonnull %3)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @randfuncs, i64 0, i64 0), i32 1)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_package(%struct.lua_State*) #0 {
  tail call fastcc void @createclibstable(%struct.lua_State* %0)
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @pk_funcs, i64 0, i64 0), i32 0)
  tail call fastcc void @createsearcherstable(%struct.lua_State* %0)
  tail call fastcc void @setpath(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.65, i64 0, i64 0), i8* getelementptr inbounds ([151 x i8], [151 x i8]* @.str.66, i64 0, i64 0))
  tail call fastcc void @setpath(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.68, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.69, i64 0, i64 0))
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.70, i64 0, i64 0))
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.71, i64 0, i64 0))
  %3 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0))
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i64 0, i64 0))
  %4 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0))
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i64 0, i64 0))
  %5 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i64 2)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([2 x %struct.luaL_Reg], [2 x %struct.luaL_Reg]* @ll_funcs, i64 0, i64 0), i32 1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createclibstable(%struct.lua_State*) unnamed_addr #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 1)
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @gctm, i32 0)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0))
  %2 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2)
  tail call void @lua_rawsetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*))
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createsearcherstable(%struct.lua_State*) unnamed_addr #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 4, i32 0)
  br label %2

; <label>:2:                                      ; preds = %1, %2
  %3 = phi i64 [ 0, %1 ], [ %6, %2 ]
  %4 = getelementptr inbounds [5 x i32 (%struct.lua_State*)*], [5 x i32 (%struct.lua_State*)*]* @createsearcherstable.searchers, i64 0, i64 %3
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2)
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !79
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %5, i32 1)
  %6 = add nuw nsw i64 %3, 1
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 -2, i64 %6)
  %7 = icmp eq i64 %6, 4
  br i1 %7, label %8, label %2

; <label>:8:                                      ; preds = %2
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setpath(%struct.lua_State*, i8*, i8*, i8*) unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.484, i64 0, i64 0), i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.485, i64 0, i64 0))
  %7 = tail call i8* @getenv(i8* nonnull %6) #7
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %4
  %10 = tail call i8* @getenv(i8* %2) #7
  %11 = icmp eq i8* %10, null
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %4, %9
  %13 = phi i8* [ %10, %9 ], [ %7, %4 ]
  %14 = tail call fastcc i32 @noenv(%struct.lua_State* %0)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %12, %9
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3)
  br label %67

; <label>:18:                                     ; preds = %12
  %19 = tail call i8* @strstr(i8* nonnull %13, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.486, i64 0, i64 0)) #19
  %20 = icmp eq i8* %19, null
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %18
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %13)
  br label %67

; <label>:23:                                     ; preds = %18
  %24 = tail call i64 @strlen(i8* nonnull %13) #19
  %25 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %25) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %5)
  %26 = icmp ult i8* %13, %19
  br i1 %26, label %27, label %44

; <label>:27:                                     ; preds = %23
  %28 = ptrtoint i8* %19 to i64
  %29 = ptrtoint i8* %13 to i64
  %30 = sub i64 %28, %29
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %13, i64 %30)
  %31 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %32 = load i64, i64* %31, align 8, !tbaa !182
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %34 = load i64, i64* %33, align 8, !tbaa !180
  %35 = icmp ult i64 %32, %34
  br i1 %35, label %38, label %36

; <label>:36:                                     ; preds = %27
  %37 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1)
  br label %38

; <label>:38:                                     ; preds = %36, %27
  %39 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %40 = load i8*, i8** %39, align 8, !tbaa !183
  %41 = load i64, i64* %31, align 8, !tbaa !182
  %42 = add i64 %41, 1
  store i64 %42, i64* %31, align 8, !tbaa !182
  %43 = getelementptr inbounds i8, i8* %40, i64 %41
  store i8 59, i8* %43, align 1, !tbaa !21
  br label %44

; <label>:44:                                     ; preds = %38, %23
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %5, i8* %3)
  %45 = getelementptr inbounds i8, i8* %13, i64 %24
  %46 = getelementptr inbounds i8, i8* %45, i64 -2
  %47 = icmp ult i8* %19, %46
  br i1 %47, label %48, label %66

; <label>:48:                                     ; preds = %44
  %49 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %50 = load i64, i64* %49, align 8, !tbaa !182
  %51 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %52 = load i64, i64* %51, align 8, !tbaa !180
  %53 = icmp ult i64 %50, %52
  br i1 %53, label %56, label %54

; <label>:54:                                     ; preds = %48
  %55 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1)
  br label %56

; <label>:56:                                     ; preds = %54, %48
  %57 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %58 = load i8*, i8** %57, align 8, !tbaa !183
  %59 = load i64, i64* %49, align 8, !tbaa !182
  %60 = add i64 %59, 1
  store i64 %60, i64* %49, align 8, !tbaa !182
  %61 = getelementptr inbounds i8, i8* %58, i64 %59
  store i8 59, i8* %61, align 1, !tbaa !21
  %62 = getelementptr inbounds i8, i8* %19, i64 2
  %63 = ptrtoint i8* %46 to i64
  %64 = ptrtoint i8* %19 to i64
  %65 = sub i64 %63, %64
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %62, i64 %65)
  br label %66

; <label>:66:                                     ; preds = %56, %44
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %25) #7
  br label %67

; <label>:67:                                     ; preds = %21, %66, %16
  call void @lua_setfield(%struct.lua_State* %0, i32 -3, i8* %1)
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_os(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @syslib, i64 0, i64 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_string(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 17)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([18 x %struct.luaL_Reg], [18 x %struct.luaL_Reg]* @strlib, i64 0, i64 0), i32 0)
  tail call fastcc void @createmetatable(%struct.lua_State* %0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createmetatable(%struct.lua_State*) unnamed_addr #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 9)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([10 x %struct.luaL_Reg], [10 x %struct.luaL_Reg]* @stringmetamethods, i64 0, i64 0), i32 0)
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2)
  %3 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0))
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_table(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @tab_funcs, i64 0, i64 0), i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @luaopen_utf8(%struct.lua_State*) #0 {
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 6)
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([7 x %struct.luaL_Reg], [7 x %struct.luaL_Reg]* @funcs, i64 0, i64 0), i32 0)
  %2 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.75, i64 0, i64 0), i64 14)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define void @luaL_openlibs(%struct.lua_State*) local_unnamed_addr #0 {
  br label %2

; <label>:2:                                      ; preds = %1, %2
  %3 = phi i32 (%struct.lua_State*)* [ @luaopen_base, %1 ], [ %9, %2 ]
  %4 = phi %struct.luaL_Reg* [ getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @loadedlibs, i64 0, i64 0), %1 ], [ %7, %2 ]
  %5 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %4, i64 0, i32 0
  %6 = load i8*, i8** %5, align 8, !tbaa !191
  tail call void @luaL_requiref(%struct.lua_State* %0, i8* %6, i32 (%struct.lua_State*)* nonnull %3, i32 1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %7 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %4, i64 1
  %8 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %4, i64 1, i32 1
  %9 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %8, align 8, !tbaa !193
  %10 = icmp eq i32 (%struct.lua_State*)* %9, null
  br i1 %10, label %11, label %2

; <label>:11:                                     ; preds = %2
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @main(i32, i8**) local_unnamed_addr #0 {
  %3 = tail call %struct.lua_State* @luaL_newstate()
  %4 = icmp eq %struct.lua_State* %3, null
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = load i8*, i8** %1, align 8, !tbaa !79
  tail call fastcc void @l_message(i8* %6, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.77, i64 0, i64 0))
  br label %17

; <label>:7:                                      ; preds = %2
  tail call void @lua_pushcclosure(%struct.lua_State* nonnull %3, i32 (%struct.lua_State*)* nonnull @pmain, i32 0)
  %8 = sext i32 %0 to i64
  tail call void @lua_pushinteger(%struct.lua_State* nonnull %3, i64 %8)
  %9 = bitcast i8** %1 to i8*
  tail call void @lua_pushlightuserdata(%struct.lua_State* nonnull %3, i8* %9)
  %10 = tail call i32 @lua_pcallk(%struct.lua_State* nonnull %3, i32 2, i32 1, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %11 = tail call i32 @lua_toboolean(%struct.lua_State* nonnull %3, i32 -1)
  %12 = tail call fastcc i32 @report(%struct.lua_State* nonnull %3, i32 %10)
  tail call void @lua_close(%struct.lua_State* nonnull %3)
  %13 = icmp eq i32 %11, 0
  %14 = icmp ne i32 %10, 0
  %15 = or i1 %14, %13
  %16 = zext i1 %15 to i32
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ 1, %5 ], [ %16, %7 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc void @l_message(i8*, i8*) unnamed_addr #0 {
  %3 = icmp eq i8* %0, null
  br i1 %3, label %9, label %4

; <label>:4:                                      ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %6 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* nonnull %0) #22
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %8 = tail call i32 @fflush(%struct._IO_FILE* %7)
  br label %9

; <label>:9:                                      ; preds = %2, %4
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %11 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %1) #22
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %13 = tail call i32 @fflush(%struct._IO_FILE* %12)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @pmain(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null)
  %4 = trunc i64 %3 to i32
  %5 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 2)
  %6 = bitcast i8* %5 to i8**
  %7 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = call fastcc i32 @collectargs(i8** %6, i32* nonnull %2)
  tail call void @luaL_checkversion_(%struct.lua_State* %0, double 5.040000e+02, i64 136)
  %9 = load i8*, i8** %6, align 8, !tbaa !79
  %10 = icmp eq i8* %9, null
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = load i8, i8* %9, align 1, !tbaa !21
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %11
  store i8* %9, i8** @progname, align 8, !tbaa !79
  br label %15

; <label>:15:                                     ; preds = %11, %1, %14
  %16 = icmp eq i32 %8, 1
  br i1 %16, label %17, label %22

; <label>:17:                                     ; preds = %15
  %18 = load i32, i32* %2, align 4, !tbaa !70
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i8*, i8** %6, i64 %19
  %21 = load i8*, i8** %20, align 8, !tbaa !79
  tail call fastcc void @print_usage(i8* %21)
  br label %59

; <label>:22:                                     ; preds = %15
  %23 = and i32 %8, 4
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %26, label %25

; <label>:25:                                     ; preds = %22
  tail call fastcc void @print_version()
  br label %26

; <label>:26:                                     ; preds = %22, %25
  %27 = and i32 %8, 16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %32, label %29

; <label>:29:                                     ; preds = %26
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0))
  tail call void @luaL_openlibs(%struct.lua_State* %0)
  %30 = load i32, i32* %2, align 4, !tbaa !70
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** %6, i32 %4, i32 %30)
  %31 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0)
  br label %37

; <label>:32:                                     ; preds = %26
  tail call void @luaL_openlibs(%struct.lua_State* %0)
  %33 = load i32, i32* %2, align 4, !tbaa !70
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** %6, i32 %4, i32 %33)
  %34 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0)
  %35 = tail call fastcc i32 @handle_luainit(%struct.lua_State* %0)
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %37, label %59

; <label>:37:                                     ; preds = %29, %32
  %38 = load i32, i32* %2, align 4, !tbaa !70
  %39 = tail call fastcc i32 @runargs(%struct.lua_State* %0, i8** %6, i32 %38)
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %59, label %41

; <label>:41:                                     ; preds = %37
  %42 = icmp slt i32 %38, %4
  br i1 %42, label %43, label %48

; <label>:43:                                     ; preds = %41
  %44 = sext i32 %38 to i64
  %45 = getelementptr inbounds i8*, i8** %6, i64 %44
  %46 = tail call fastcc i32 @handle_script(%struct.lua_State* %0, i8** %45)
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %48, label %59

; <label>:48:                                     ; preds = %43, %41
  %49 = and i32 %8, 2
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %52, label %51

; <label>:51:                                     ; preds = %48
  tail call fastcc void @doREPL(%struct.lua_State* %0)
  br label %58

; <label>:52:                                     ; preds = %48
  %53 = icmp eq i32 %38, %4
  %54 = and i32 %8, 12
  %55 = icmp eq i32 %54, 0
  %56 = and i1 %55, %53
  br i1 %56, label %57, label %58

; <label>:57:                                     ; preds = %52
  tail call fastcc void @print_version()
  tail call fastcc void @doREPL(%struct.lua_State* %0)
  br label %58

; <label>:58:                                     ; preds = %52, %57, %51
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %59

; <label>:59:                                     ; preds = %43, %37, %32, %58, %17
  %60 = phi i32 [ 0, %17 ], [ 1, %58 ], [ 0, %32 ], [ 0, %37 ], [ 0, %43 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  ret i32 %60
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @report(%struct.lua_State*, i32 returned) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %7, label %4

; <label>:4:                                      ; preds = %2
  %5 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %6 = load i8*, i8** @progname, align 8, !tbaa !79
  tail call fastcc void @l_message(i8* %6, i8* %5)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %7

; <label>:7:                                      ; preds = %2, %4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @tryagain(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 8, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !74
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %4
  tail call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 1)
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %13 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %12, align 8, !tbaa !31
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !32
  %16 = tail call i8* %13(i8* %15, i8* %1, i64 %2, i64 %3) #7
  br label %17

; <label>:17:                                     ; preds = %4, %11
  %18 = phi i8* [ %16, %11 ], [ null, %4 ]
  ret i8* %18
}

; Function Attrs: nounwind
declare i64 @time(i64*) local_unnamed_addr #9

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @luaS_hash(i8* nocapture readonly, i64, i32) unnamed_addr #3 {
  %4 = trunc i64 %1 to i32
  %5 = xor i32 %4, %2
  %6 = lshr i64 %1, 5
  %7 = icmp ult i64 %6, %1
  br i1 %7, label %8, label %24

; <label>:8:                                      ; preds = %3
  %9 = xor i64 %6, -1
  br label %10

; <label>:10:                                     ; preds = %8, %10
  %11 = phi i64 [ %1, %8 ], [ %22, %10 ]
  %12 = phi i32 [ %5, %8 ], [ %21, %10 ]
  %13 = shl i32 %12, 5
  %14 = lshr i32 %12, 2
  %15 = add i32 %13, %14
  %16 = add i64 %11, -1
  %17 = getelementptr inbounds i8, i8* %0, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  %20 = add i32 %15, %19
  %21 = xor i32 %20, %12
  %22 = add i64 %11, %9
  %23 = icmp ugt i64 %22, %6
  br i1 %23, label %10, label %24

; <label>:24:                                     ; preds = %10, %3
  %25 = phi i32 [ %5, %3 ], [ %21, %10 ]
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal fastcc void @init_registry(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 7
  %7 = bitcast %struct.TValue* %6 to %struct.Table**
  store %struct.Table* %5, %struct.Table** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 7, i32 1
  store i8 69, i8* %8, align 8, !tbaa !22
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %5, i32 2, i32 0)
  %9 = bitcast %struct.TValue* %3 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 72, i8* %10, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %5, i64 1, %struct.TValue* nonnull %3)
  %11 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %12 = bitcast %struct.TValue* %3 to %struct.Table**
  store %struct.Table* %11, %struct.Table** %12, align 8, !tbaa !21
  store i8 69, i8* %10, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %5, i64 2, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaS_init(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 6
  %5 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 1024, i32 0)
  %6 = bitcast i8* %5 to %struct.TString**
  %7 = bitcast %struct.stringtable* %4 to i8**
  store i8* %5, i8** %7, align 8, !tbaa !197
  tail call fastcc void @tablerehash(%struct.TString** %6, i32 0, i32 128)
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 6, i32 2
  store i32 128, i32* %8, align 4, !tbaa !198
  %9 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.78, i64 0, i64 0), i64 17)
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 39
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !56
  %11 = bitcast %struct.TString* %9 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %11)
  %12 = bitcast %struct.TString** %10 to i64*
  br label %13

; <label>:13:                                     ; preds = %22, %1
  %14 = phi i64 [ 0, %1 ], [ %23, %22 ]
  br label %15

; <label>:15:                                     ; preds = %15, %13
  %16 = phi i64 [ 0, %13 ], [ %20, %15 ]
  %17 = load i64, i64* %12, align 8, !tbaa !56
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 42, i64 %14, i64 %16
  %19 = bitcast %struct.TString** %18 to i64*
  store i64 %17, i64* %19, align 8, !tbaa !79
  %20 = add nuw nsw i64 %16, 1
  %21 = icmp eq i64 %20, 2
  br i1 %21, label %22, label %15

; <label>:22:                                     ; preds = %15
  %23 = add nuw nsw i64 %14, 1
  %24 = icmp eq i64 %23, 53
  br i1 %24, label %25, label %13

; <label>:25:                                     ; preds = %22
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_init(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %3

; <label>:3:                                      ; preds = %3, %1
  %4 = phi i64 [ 0, %1 ], [ %14, %3 ]
  %5 = getelementptr inbounds [25 x i8*], [25 x i8*]* @luaT_init.luaT_eventname, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !79
  %7 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %6)
  %8 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 40, i64 %4
  store %struct.TString* %7, %struct.TString** %9, align 8, !tbaa !79
  %10 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 40, i64 %4
  %12 = bitcast %struct.TString** %11 to %struct.GCObject**
  %13 = load %struct.GCObject*, %struct.GCObject** %12, align 8, !tbaa !79
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %13)
  %14 = add nuw nsw i64 %4, 1
  %15 = icmp eq i64 %14, 25
  br i1 %15, label %16, label %3

; <label>:16:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaX_init(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4)
  %3 = bitcast %struct.TString* %2 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %3)
  br label %4

; <label>:4:                                      ; preds = %4, %1
  %5 = phi i64 [ 0, %1 ], [ %10, %4 ]
  %6 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %5
  %7 = load i8*, i8** %6, align 8, !tbaa !79
  %8 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %7)
  %9 = bitcast %struct.TString* %8 to %struct.GCObject*
  tail call fastcc void @luaC_fix(%struct.lua_State* %0, %struct.GCObject* %9)
  %10 = add nuw nsw i64 %5, 1
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %8, i64 0, i32 3
  %12 = trunc i64 %10 to i8
  store i8 %12, i8* %11, align 2, !tbaa !199
  %13 = icmp eq i64 %10, 22
  br i1 %13, label %14, label %4

; <label>:14:                                     ; preds = %4
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @tablerehash(%struct.TString** nocapture, i32, i32) unnamed_addr #2 {
  %4 = icmp slt i32 %1, %2
  br i1 %4, label %5, label %14

; <label>:5:                                      ; preds = %3
  %6 = sext i32 %1 to i64
  %7 = getelementptr %struct.TString*, %struct.TString** %0, i64 %6
  %8 = bitcast %struct.TString** %7 to i8*
  %9 = add i32 %2, -1
  %10 = sub i32 %9, %1
  %11 = zext i32 %10 to i64
  %12 = shl nuw nsw i64 %11, 3
  %13 = add nuw nsw i64 %12, 8
  call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 %13, i32 8, i1 false)
  br label %14

; <label>:14:                                     ; preds = %5, %3
  %15 = icmp sgt i32 %1, 0
  br i1 %15, label %16, label %42

; <label>:16:                                     ; preds = %14
  %17 = add nsw i32 %2, -1
  %18 = zext i32 %1 to i64
  br label %19

; <label>:19:                                     ; preds = %39, %16
  %20 = phi i64 [ 0, %16 ], [ %40, %39 ]
  %21 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %20
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !79
  store %struct.TString* null, %struct.TString** %21, align 8, !tbaa !79
  %23 = icmp eq %struct.TString* %22, null
  br i1 %23, label %39, label %24

; <label>:24:                                     ; preds = %19
  br label %25

; <label>:25:                                     ; preds = %24, %25
  %26 = phi %struct.TString* [ %29, %25 ], [ %22, %24 ]
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %26, i64 0, i32 6
  %28 = bitcast %union.anon* %27 to %struct.TString**
  %29 = load %struct.TString*, %struct.TString** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %26, i64 0, i32 5
  %31 = load i32, i32* %30, align 4, !tbaa !200
  %32 = and i32 %31, %17
  %33 = zext i32 %32 to i64
  %34 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %33
  %35 = bitcast %struct.TString** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !79
  %37 = getelementptr inbounds %union.anon, %union.anon* %27, i64 0, i32 0
  store i64 %36, i64* %37, align 8, !tbaa !21
  store %struct.TString* %26, %struct.TString** %34, align 8, !tbaa !79
  %38 = icmp eq %struct.TString* %29, null
  br i1 %38, label %39, label %25

; <label>:39:                                     ; preds = %25, %19
  %40 = add nuw nsw i64 %20, 1
  %41 = icmp eq i64 %40, %18
  br i1 %41, label %42, label %19

; <label>:42:                                     ; preds = %39, %14
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaC_fix(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %6 = load i8, i8* %5, align 1, !tbaa !53
  %7 = and i8 %6, -32
  %8 = or i8 %7, 4
  store i8 %8, i8* %5, align 1, !tbaa !53
  %9 = bitcast %struct.GCObject* %1 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !129
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 20
  %12 = bitcast %struct.GCObject** %11 to i64*
  store i64 %10, i64* %12, align 8, !tbaa !18
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 29
  %14 = bitcast %struct.GCObject** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !201
  store i64 %15, i64* %9, align 8, !tbaa !129
  store %struct.GCObject* %1, %struct.GCObject** %13, align 8, !tbaa !201
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_freeallobjects(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  tail call fastcc void @luaC_changemode(%struct.lua_State* %0, i32 0)
  tail call fastcc void @separatetobefnz(%struct.global_State* %3, i32 1)
  tail call fastcc void @callallpendingfinalizers(%struct.lua_State* %0)
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %5 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !18
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %7 = bitcast %struct.lua_State** %6 to %struct.GCObject**
  %8 = load %struct.GCObject*, %struct.GCObject** %7, align 8, !tbaa !27
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %5, %struct.GCObject* %8)
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %10 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !132
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %10, %struct.GCObject* null)
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 29
  %12 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !201
  tail call fastcc void @deletelist(%struct.lua_State* %0, %struct.GCObject* %12, %struct.GCObject* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaM_free_(%struct.lua_State* nocapture readonly, i8*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  %7 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %6, align 8, !tbaa !31
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  %9 = load i8*, i8** %8, align 8, !tbaa !32
  %10 = tail call i8* %7(i8* %9, i8* %1, i64 %2, i64 0) #7
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 3
  %12 = load i64, i64* %11, align 8, !tbaa !11
  %13 = sub i64 %12, %2
  store i64 %13, i64* %11, align 8, !tbaa !11
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @freestack(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !34
  %4 = icmp eq %union.StackValue* %3, null
  br i1 %4, label %14, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %6, %struct.CallInfo** %7, align 8, !tbaa !35
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0)
  %8 = bitcast %union.StackValue** %2 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !34
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %11 = load i32, i32* %10, align 4, !tbaa !37
  %12 = sext i32 %11 to i64
  %13 = shl nsw i64 %12, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* %9, i64 %13)
  br label %14

; <label>:14:                                     ; preds = %1, %5
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @separatetobefnz(%struct.global_State*, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %4 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !79
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 34
  %6 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !202
  %7 = icmp eq %struct.GCObject* %4, %6
  br i1 %7, label %44, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %10 = tail call fastcc %struct.GCObject** @findlast(%struct.GCObject** nonnull %9)
  %11 = icmp ne i32 %1, 0
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %13 = bitcast %struct.GCObject** %12 to i64*
  br label %14

; <label>:14:                                     ; preds = %8, %38
  %15 = phi %struct.GCObject* [ %4, %8 ], [ %41, %38 ]
  %16 = phi %struct.GCObject** [ %10, %8 ], [ %40, %38 ]
  %17 = phi %struct.GCObject** [ %3, %8 ], [ %39, %38 ]
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %15, i64 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !53
  %20 = and i8 %19, 24
  %21 = icmp ne i8 %20, 0
  %22 = or i1 %11, %21
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %14
  %24 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %15, i64 0, i32 0
  br label %38

; <label>:25:                                     ; preds = %14
  %26 = load %struct.GCObject*, %struct.GCObject** %12, align 8, !tbaa !203
  %27 = icmp eq %struct.GCObject* %15, %26
  br i1 %27, label %28, label %31

; <label>:28:                                     ; preds = %25
  %29 = bitcast %struct.GCObject* %15 to i64*
  %30 = load i64, i64* %29, align 8, !tbaa !129
  store i64 %30, i64* %13, align 8, !tbaa !203
  br label %31

; <label>:31:                                     ; preds = %28, %25
  %32 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %15, i64 0, i32 0
  %33 = bitcast %struct.GCObject* %15 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !129
  %35 = bitcast %struct.GCObject** %17 to i64*
  store i64 %34, i64* %35, align 8, !tbaa !79
  %36 = bitcast %struct.GCObject** %16 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !79
  store i64 %37, i64* %33, align 8, !tbaa !129
  store %struct.GCObject* %15, %struct.GCObject** %16, align 8, !tbaa !79
  br label %38

; <label>:38:                                     ; preds = %31, %23
  %39 = phi %struct.GCObject** [ %17, %31 ], [ %24, %23 ]
  %40 = phi %struct.GCObject** [ %32, %31 ], [ %16, %23 ]
  %41 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !79
  %42 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !202
  %43 = icmp eq %struct.GCObject* %41, %42
  br i1 %43, label %44, label %14

; <label>:44:                                     ; preds = %38, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @callallpendingfinalizers(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %5 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !204
  %6 = icmp eq %struct.GCObject* %5, null
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %1
  br label %8

; <label>:8:                                      ; preds = %7, %8
  tail call fastcc void @GCTM(%struct.lua_State* %0)
  %9 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !204
  %10 = icmp eq %struct.GCObject* %9, null
  br i1 %10, label %11, label %8

; <label>:11:                                     ; preds = %8, %1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @deletelist(%struct.lua_State* nocapture readonly, %struct.GCObject*, %struct.GCObject* readnone) unnamed_addr #0 {
  %4 = icmp eq %struct.GCObject* %1, %2
  br i1 %4, label %11, label %5

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %6
  %7 = phi %struct.GCObject* [ %9, %6 ], [ %1, %5 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !129
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* %7)
  %10 = icmp eq %struct.GCObject* %9, %2
  br i1 %10, label %11, label %6

; <label>:11:                                     ; preds = %6, %3
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.GCObject** @findlast(%struct.GCObject** readonly) unnamed_addr #3 {
  br label %2

; <label>:2:                                      ; preds = %2, %1
  %3 = phi %struct.GCObject** [ %0, %1 ], [ %6, %2 ]
  %4 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !79
  %5 = icmp eq %struct.GCObject* %4, null
  %6 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 0, i32 0
  br i1 %5, label %7, label %2

; <label>:7:                                      ; preds = %2
  ret %struct.GCObject** %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @GCTM(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca %struct.TValue, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = bitcast %struct.TValue* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.GCObject* @udata2finalize(%struct.global_State* %4)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  store %struct.GCObject* %6, %struct.GCObject** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !205
  %10 = or i8 %9, 64
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  %12 = call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* nonnull %2, i32 2)
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %67, label %17

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %19 = load i8, i8* %18, align 1, !tbaa !41
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 15
  %21 = load i8, i8* %20, align 1, !tbaa !28
  store i8 0, i8* %18, align 1, !tbaa !41
  store i8 0, i8* %20, align 1, !tbaa !28
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = bitcast %union.StackValue** %22 to %struct.TValue**
  %24 = load %struct.TValue*, %struct.TValue** %23, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %12 to i64*
  %26 = bitcast %struct.TValue* %24 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = load i8, i8* %13, align 8, !tbaa !22
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 %28, i8* %29, align 8, !tbaa !22
  %30 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 1, i32 0
  %32 = bitcast %struct.TValue* %2 to i64*
  %33 = bitcast %struct.TValue* %31 to i64*
  %34 = load i64, i64* %32, align 8
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 1, i32 0, i32 1
  store i8 %10, i8* %35, align 8, !tbaa !22
  %36 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 2
  store %union.StackValue* %37, %union.StackValue** %22, align 8, !tbaa !20
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %39 = load %struct.CallInfo*, %struct.CallInfo** %38, align 8, !tbaa !35
  %40 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %39, i64 0, i32 7
  %41 = load i16, i16* %40, align 2, !tbaa !46
  %42 = or i16 %41, 64
  store i16 %42, i16* %40, align 2, !tbaa !46
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %44 = bitcast %union.StackValue** %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !34
  %46 = ptrtoint %union.StackValue* %36 to i64
  %47 = sub i64 %46, %45
  %48 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @dothecall, i8* null, i64 %47, i64 0)
  %49 = load %struct.CallInfo*, %struct.CallInfo** %38, align 8, !tbaa !35
  %50 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %49, i64 0, i32 7
  %51 = load i16, i16* %50, align 2, !tbaa !46
  %52 = and i16 %51, -65
  store i16 %52, i16* %50, align 2, !tbaa !46
  store i8 %19, i8* %18, align 1, !tbaa !41
  store i8 %21, i8* %20, align 1, !tbaa !28
  %53 = icmp eq i32 %48, 0
  br i1 %53, label %67, label %54

; <label>:54:                                     ; preds = %17
  %55 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 -1, i32 0, i32 1
  %57 = load i8, i8* %56, align 8, !tbaa !21
  %58 = and i8 %57, 15
  %59 = icmp eq i8 %58, 4
  br i1 %59, label %60, label %65

; <label>:60:                                     ; preds = %54
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 -1, i32 0, i32 0, i32 0
  %62 = bitcast %struct.GCObject** %61 to i8**
  %63 = load i8*, i8** %62, align 8, !tbaa !21
  %64 = getelementptr inbounds i8, i8* %63, i64 24
  br label %65

; <label>:65:                                     ; preds = %54, %60
  %66 = phi i8* [ %64, %60 ], [ getelementptr inbounds ([29 x i8], [29 x i8]* @.str.139, i64 0, i64 0), %54 ]
  tail call fastcc void @luaE_warning(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.140, i64 0, i64 0), i32 1)
  tail call fastcc void @luaE_warning(%struct.lua_State* nonnull %0, i8* nonnull %66, i32 1)
  tail call fastcc void @luaE_warning(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.141, i64 0, i64 0), i32 0)
  br label %67

; <label>:67:                                     ; preds = %65, %17, %1
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %struct.GCObject* @udata2finalize(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !204
  %4 = bitcast %struct.GCObject* %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !129
  %6 = bitcast %struct.GCObject** %2 to i64*
  store i64 %5, i64* %6, align 8, !tbaa !204
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 20
  %8 = bitcast %struct.GCObject** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !18
  store i64 %9, i64* %4, align 8, !tbaa !129
  store %struct.GCObject* %3, %struct.GCObject** %7, align 8, !tbaa !18
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !53
  %12 = and i8 %11, -65
  store i8 %12, i8* %10, align 1, !tbaa !53
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %14 = load i8, i8* %13, align 1, !tbaa !62
  %15 = add i8 %14, -3
  %16 = icmp ult i8 %15, 4
  br i1 %16, label %17, label %23

; <label>:17:                                     ; preds = %1
  %18 = and i8 %11, -128
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 10
  %20 = load i8, i8* %19, align 4, !tbaa !15
  %21 = and i8 %20, 24
  %22 = or i8 %21, %18
  store i8 %22, i8* %10, align 1, !tbaa !53
  br label %23

; <label>:23:                                     ; preds = %17, %1
  ret %struct.GCObject* %3
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* nocapture readonly, %struct.TValue* nocapture readonly, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %1 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %1 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %3
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  br i1 %24, label %32, label %27

; <label>:27:                                     ; preds = %21
  %28 = zext i32 %2 to i64
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 40, i64 %28
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !79
  %31 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %23, %struct.TString* %30)
  br label %34

; <label>:32:                                     ; preds = %21
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %34

; <label>:34:                                     ; preds = %32, %27
  %35 = phi %struct.TValue* [ %31, %27 ], [ %33, %32 ]
  ret %struct.TValue* %35
}

; Function Attrs: nounwind uwtable
define internal void @dothecall(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0)
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nocapture readonly, %struct.TString* readonly) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !200
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %8 = load i8, i8* %7, align 1, !tbaa !124
  %9 = zext i8 %8 to i32
  %10 = shl i32 1, %9
  %11 = add nsw i32 %10, -1
  %12 = and i32 %11, %6
  br label %13

; <label>:13:                                     ; preds = %28, %2
  %14 = phi i32 [ %12, %2 ], [ %30, %28 ]
  %15 = phi %union.Node* [ %4, %2 ], [ %17, %28 ]
  %16 = sext i32 %14 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16
  %18 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 84
  br i1 %20, label %21, label %28

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 4, i32 0
  %23 = bitcast %struct.GCObject** %22 to %struct.TString**
  %24 = load %struct.TString*, %struct.TString** %23, align 8, !tbaa !21
  %25 = icmp eq %struct.TString* %24, %1
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %21
  %27 = bitcast %union.Node* %17 to %struct.TValue*
  br label %32

; <label>:28:                                     ; preds = %21, %13
  %29 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 3
  %30 = load i32, i32* %29, align 4, !tbaa !21
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %13

; <label>:32:                                     ; preds = %28, %26
  %33 = phi %struct.TValue* [ %27, %26 ], [ @absentkey, %28 ]
  ret %struct.TValue* %33
}

; Function Attrs: nounwind uwtable
define internal fastcc void @freeobj(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !205
  switch i8 %4, label %56 [
    i8 10, label %5
    i8 9, label %7
    i8 25, label %7
    i8 22, label %9
    i8 54, label %17
    i8 5, label %25
    i8 8, label %27
    i8 7, label %29
    i8 20, label %43
    i8 36, label %50
  ]

; <label>:5:                                      ; preds = %2
  %6 = bitcast %struct.GCObject* %1 to %struct.Proto*
  tail call fastcc void @luaF_freeproto(%struct.lua_State* %0, %struct.Proto* %6)
  br label %56

; <label>:7:                                      ; preds = %2, %2
  %8 = bitcast %struct.GCObject* %1 to %struct.UpVal*
  tail call fastcc void @freeupval(%struct.lua_State* %0, %struct.UpVal* %8)
  br label %56

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.GCObject* %1 to i8*
  %11 = bitcast %struct.GCObject* %1 to %struct.LClosure*
  %12 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %11, i64 0, i32 3
  %13 = load i8, i8* %12, align 2, !tbaa !21
  %14 = zext i8 %13 to i64
  %15 = shl nuw nsw i64 %14, 3
  %16 = add nuw nsw i64 %15, 32
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %10, i64 %16)
  br label %56

; <label>:17:                                     ; preds = %2
  %18 = bitcast %struct.GCObject* %1 to i8*
  %19 = bitcast %struct.GCObject* %1 to %struct.CClosure*
  %20 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %19, i64 0, i32 3
  %21 = load i8, i8* %20, align 2, !tbaa !21
  %22 = zext i8 %21 to i64
  %23 = shl nuw nsw i64 %22, 4
  %24 = add nuw nsw i64 %23, 32
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %18, i64 %24)
  br label %56

; <label>:25:                                     ; preds = %2
  %26 = bitcast %struct.GCObject* %1 to %struct.Table*
  tail call fastcc void @luaH_free(%struct.lua_State* %0, %struct.Table* %26)
  br label %56

; <label>:27:                                     ; preds = %2
  %28 = bitcast %struct.GCObject* %1 to %struct.lua_State*
  tail call fastcc void @luaE_freethread(%struct.lua_State* %0, %struct.lua_State* %28)
  br label %56

; <label>:29:                                     ; preds = %2
  %30 = bitcast %struct.GCObject* %1 to %struct.Udata*
  %31 = bitcast %struct.GCObject* %1 to i8*
  %32 = getelementptr inbounds %struct.Udata, %struct.Udata* %30, i64 0, i32 3
  %33 = load i16, i16* %32, align 2, !tbaa !169
  %34 = icmp eq i16 %33, 0
  %35 = zext i16 %33 to i64
  %36 = shl nuw nsw i64 %35, 4
  %37 = add nuw nsw i64 %36, 40
  %38 = select i1 %34, i64 32, i64 %37
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %40 = bitcast %struct.GCObject* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !171
  %42 = add i64 %38, %41
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %31, i64 %42)
  br label %56

; <label>:43:                                     ; preds = %2
  %44 = bitcast %struct.GCObject* %1 to %struct.TString*
  tail call fastcc void @luaS_remove(%struct.lua_State* %0, %struct.TString* %44)
  %45 = bitcast %struct.GCObject* %1 to i8*
  %46 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 4
  %47 = load i8, i8* %46, align 1, !tbaa !21
  %48 = zext i8 %47 to i64
  %49 = add nuw nsw i64 %48, 25
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %45, i64 %49)
  br label %56

; <label>:50:                                     ; preds = %2
  %51 = bitcast %struct.GCObject* %1 to i8*
  %52 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %53 = bitcast %struct.GCObject* %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21
  %55 = add i64 %54, 25
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %51, i64 %55)
  br label %56

; <label>:56:                                     ; preds = %2, %50, %43, %29, %27, %25, %17, %9, %7, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaF_freeproto(%struct.lua_State* nocapture readonly, %struct.Proto*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 16
  %4 = bitcast i32** %3 to i8**
  %5 = load i8*, i8** %4, align 8, !tbaa !134
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 8
  %7 = load i32, i32* %6, align 8, !tbaa !206
  %8 = sext i32 %7 to i64
  %9 = shl nsw i64 %8, 2
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %5, i64 %9)
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 17
  %11 = bitcast %struct.Proto*** %10 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !207
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 10
  %14 = load i32, i32* %13, align 8, !tbaa !208
  %15 = sext i32 %14 to i64
  %16 = shl nsw i64 %15, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %12, i64 %16)
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 15
  %18 = bitcast %struct.TValue** %17 to i8**
  %19 = load i8*, i8** %18, align 8, !tbaa !209
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 7
  %21 = load i32, i32* %20, align 4, !tbaa !210
  %22 = sext i32 %21 to i64
  %23 = shl nsw i64 %22, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %19, i64 %23)
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  %25 = load i8*, i8** %24, align 8, !tbaa !211
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  %27 = load i32, i32* %26, align 4, !tbaa !102
  %28 = sext i32 %27 to i64
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %25, i64 %28)
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %30 = bitcast %struct.AbsLineInfo** %29 to i8**
  %31 = load i8*, i8** %30, align 8, !tbaa !212
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  %33 = load i32, i32* %32, align 8, !tbaa !213
  %34 = sext i32 %33 to i64
  %35 = shl nsw i64 %34, 3
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %31, i64 %35)
  %36 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 21
  %37 = bitcast %struct.LocVar** %36 to i8**
  %38 = load i8*, i8** %37, align 8, !tbaa !84
  %39 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 11
  %40 = load i32, i32* %39, align 4, !tbaa !82
  %41 = sext i32 %40 to i64
  %42 = shl nsw i64 %41, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %38, i64 %42)
  %43 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %44 = bitcast %struct.Upvaldesc** %43 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !174
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  %47 = load i32, i32* %46, align 8, !tbaa !166
  %48 = sext i32 %47 to i64
  %49 = shl nsw i64 %48, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %45, i64 %49)
  %50 = bitcast %struct.Proto* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %50, i64 128)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @freeupval(%struct.lua_State* nocapture readonly, %struct.UpVal*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %1, i64 0, i32 3
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !50
  %5 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %1, i64 0, i32 4
  %6 = bitcast %union.anon.4* %5 to %struct.TValue*
  %7 = icmp eq %struct.TValue* %4, %6
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %2
  tail call fastcc void @luaF_unlinkupval(%struct.UpVal* nonnull %1)
  br label %9

; <label>:9:                                      ; preds = %2, %8
  %10 = bitcast %struct.UpVal* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %10, i64 40)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaH_free(%struct.lua_State* nocapture readonly, %struct.Table*) unnamed_addr #0 {
  tail call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* %1)
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %4 = bitcast %struct.TValue** %3 to i8**
  %5 = load i8*, i8** %4, align 8, !tbaa !115
  %6 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1)
  %7 = zext i32 %6 to i64
  %8 = shl nuw nsw i64 %7, 4
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %5, i64 %8)
  %9 = bitcast %struct.Table* %1 to i8*
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %9, i64 56)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaE_freethread(%struct.lua_State* nocapture readonly, %struct.lua_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 -1, i32 23
  %4 = bitcast i32* %3 to i8*
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 11
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !34
  %7 = tail call fastcc i32 @luaF_close(%struct.lua_State* %1, %union.StackValue* %6, i32 -1)
  tail call fastcc void @freestack(%struct.lua_State* %1)
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* nonnull %4, i64 208)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaS_remove(%struct.lua_State* nocapture readonly, %struct.TString* readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 0
  %6 = load %struct.TString**, %struct.TString*** %5, align 8, !tbaa !197
  %7 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 5
  %8 = load i32, i32* %7, align 4, !tbaa !200
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 2
  %10 = load i32, i32* %9, align 4, !tbaa !198
  %11 = add nsw i32 %10, -1
  %12 = and i32 %11, %8
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds %struct.TString*, %struct.TString** %6, i64 %13
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !79
  %16 = icmp eq %struct.TString* %15, %1
  br i1 %16, label %26, label %17

; <label>:17:                                     ; preds = %2
  br label %18

; <label>:18:                                     ; preds = %17, %18
  %19 = phi %struct.TString* [ %22, %18 ], [ %15, %17 ]
  %20 = getelementptr inbounds %struct.TString, %struct.TString* %19, i64 0, i32 6
  %21 = bitcast %union.anon* %20 to %struct.TString**
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !79
  %23 = icmp eq %struct.TString* %22, %1
  br i1 %23, label %24, label %18

; <label>:24:                                     ; preds = %18
  %25 = bitcast %union.anon* %20 to %struct.TString**
  br label %26

; <label>:26:                                     ; preds = %24, %2
  %27 = phi %struct.TString** [ %25, %24 ], [ %14, %2 ]
  %28 = phi %struct.TString* [ %22, %24 ], [ %15, %2 ]
  %29 = getelementptr inbounds %struct.TString, %struct.TString* %28, i64 0, i32 6, i32 0
  %30 = load i64, i64* %29, align 8, !tbaa !21
  %31 = bitcast %struct.TString** %27 to i64*
  store i64 %30, i64* %31, align 8, !tbaa !79
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 1
  %33 = load i32, i32* %32, align 8, !tbaa !214
  %34 = add nsw i32 %33, -1
  store i32 %34, i32* %32, align 8, !tbaa !214
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaF_unlinkupval(%struct.UpVal* nocapture readonly) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %0, i64 0, i32 4, i32 0
  %3 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %2, i64 0, i32 0
  %4 = bitcast %struct.anon.5* %2 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %0, i64 0, i32 4, i32 0, i32 1
  %7 = bitcast %struct.UpVal*** %6 to i64**
  %8 = load i64*, i64** %7, align 8, !tbaa !21
  store i64 %5, i64* %8, align 8, !tbaa !79
  %9 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !21
  %10 = icmp eq %struct.UpVal* %9, null
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %1
  %12 = bitcast %struct.UpVal*** %6 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 4, i32 0, i32 1
  %15 = bitcast %struct.UpVal*** %14 to i64*
  store i64 %13, i64* %15, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %1, %11
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @freehash(%struct.lua_State* nocapture readonly, %struct.Table* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !117
  %5 = icmp eq %union.Node* %4, null
  br i1 %5, label %16, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %8 = bitcast %union.Node** %7 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !123
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !124
  %12 = zext i8 %11 to i32
  %13 = shl i32 1, %12
  %14 = sext i32 %13 to i64
  %15 = mul nsw i64 %14, 24
  tail call fastcc void @luaM_free_(%struct.lua_State* %0, i8* %9, i64 %15)
  br label %16

; <label>:16:                                     ; preds = %6, %2
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @luaH_realasize(%struct.Table* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !116
  %4 = icmp slt i8 %3, 0
  br i1 %4, label %5, label %11

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %7 = load i32, i32* %6, align 4, !tbaa !114
  %8 = add i32 %7, -1
  %9 = and i32 %8, %7
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %14

; <label>:11:                                     ; preds = %5, %1
  %12 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %13 = load i32, i32* %12, align 4, !tbaa !114
  br label %26

; <label>:14:                                     ; preds = %5
  %15 = lshr i32 %7, 1
  %16 = or i32 %15, %7
  %17 = lshr i32 %16, 2
  %18 = or i32 %17, %16
  %19 = lshr i32 %18, 4
  %20 = or i32 %19, %18
  %21 = lshr i32 %20, 8
  %22 = or i32 %21, %20
  %23 = lshr i32 %22, 16
  %24 = or i32 %23, %22
  %25 = add i32 %24, 1
  br label %26

; <label>:26:                                     ; preds = %14, %11
  %27 = phi i32 [ %13, %11 ], [ %25, %14 ]
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaE_freeCI(%struct.lua_State* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !35
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 3
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !89
  store %struct.CallInfo* null, %struct.CallInfo** %4, align 8, !tbaa !89
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %7 = load i16, i16* %6, align 4, !tbaa !36
  %8 = zext i16 %7 to i32
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %10 = load i32, i32* %9, align 8, !tbaa !40
  %11 = sub i32 %10, %8
  store i32 %11, i32* %9, align 8, !tbaa !40
  %12 = icmp eq %struct.CallInfo* %5, null
  br i1 %12, label %22, label %13

; <label>:13:                                     ; preds = %1
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi %struct.CallInfo* [ %18, %14 ], [ %5, %13 ]
  %16 = bitcast %struct.CallInfo* %15 to i8*
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 3
  %18 = load %struct.CallInfo*, %struct.CallInfo** %17, align 8, !tbaa !89
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* %16, i64 64)
  %19 = load i16, i16* %6, align 4, !tbaa !36
  %20 = add i16 %19, -1
  store i16 %20, i16* %6, align 4, !tbaa !36
  %21 = icmp eq %struct.CallInfo* %18, null
  br i1 %21, label %22, label %14

; <label>:22:                                     ; preds = %14, %1
  %23 = load i16, i16* %6, align 4, !tbaa !36
  %24 = zext i16 %23 to i32
  %25 = load i32, i32* %9, align 8, !tbaa !40
  %26 = add i32 %25, %24
  store i32 %26, i32* %9, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @genstep(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 5
  %4 = load i64, i64* %3, align 8, !tbaa !30
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @stepgenfull(%struct.lua_State* %0, %struct.global_State* nonnull %1)
  br label %36

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %9 = load i64, i64* %8, align 8, !tbaa !215
  %10 = udiv i64 %9, 100
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 14
  %12 = load i8, i8* %11, align 8, !tbaa !68
  %13 = zext i8 %12 to i64
  %14 = shl nuw nsw i64 %13, 2
  %15 = mul i64 %14, %10
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %17 = load i64, i64* %16, align 8, !tbaa !11
  %18 = icmp sgt i64 %17, 0
  br i1 %18, label %19, label %35

; <label>:19:                                     ; preds = %7
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 2
  %21 = load i64, i64* %20, align 8, !tbaa !64
  %22 = add nsw i64 %21, %17
  %23 = add i64 %15, %9
  %24 = icmp ugt i64 %22, %23
  br i1 %24, label %25, label %35

; <label>:25:                                     ; preds = %19
  %26 = tail call fastcc i64 @fullgen(%struct.lua_State* %0, %struct.global_State* nonnull %1)
  %27 = load i64, i64* %20, align 8, !tbaa !64
  %28 = load i64, i64* %16, align 8, !tbaa !11
  %29 = add nsw i64 %28, %27
  %30 = lshr exact i64 %15, 1
  %31 = add i64 %30, %9
  %32 = icmp ult i64 %29, %31
  br i1 %32, label %33, label %34

; <label>:33:                                     ; preds = %25
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %1)
  br label %36

; <label>:34:                                     ; preds = %25
  store i64 %26, i64* %3, align 8, !tbaa !30
  tail call fastcc void @setpause(%struct.global_State* nonnull %1)
  br label %36

; <label>:35:                                     ; preds = %19, %7
  tail call fastcc void @youngcollection(%struct.lua_State* %0, %struct.global_State* nonnull %1)
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %1)
  store i64 %9, i64* %8, align 8, !tbaa !215
  br label %36

; <label>:36:                                     ; preds = %35, %34, %33, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @incstep(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 18
  %4 = load i8, i8* %3, align 4, !tbaa !66
  %5 = zext i8 %4 to i64
  %6 = shl nuw nsw i64 %5, 2
  %7 = or i64 %6, 1
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %9 = load i64, i64* %8, align 8, !tbaa !11
  %10 = lshr i64 %9, 4
  %11 = mul i64 %7, %10
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 19
  %13 = load i8, i8* %12, align 1, !tbaa !67
  %14 = icmp ult i8 %13, 63
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %2
  %16 = zext i8 %13 to i64
  %17 = shl i64 1, %16
  %18 = lshr i64 %17, 4
  %19 = sub nsw i64 0, %7
  %20 = mul i64 %18, %19
  br label %21

; <label>:21:                                     ; preds = %2, %15
  %22 = phi i64 [ %20, %15 ], [ -9223372036854775807, %2 ]
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  br label %24

; <label>:24:                                     ; preds = %29, %21
  %25 = phi i64 [ %11, %21 ], [ %27, %29 ]
  %26 = tail call fastcc i64 @singlestep(%struct.lua_State* %0)
  %27 = sub i64 %25, %26
  %28 = icmp sgt i64 %27, %22
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %24
  %30 = load i8, i8* %23, align 1, !tbaa !62
  %31 = icmp eq i8 %30, 8
  br i1 %31, label %32, label %24

; <label>:32:                                     ; preds = %29, %24
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  %34 = load i8, i8* %33, align 1, !tbaa !62
  %35 = icmp eq i8 %34, 8
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %32
  tail call fastcc void @setpause(%struct.global_State* nonnull %1)
  br label %40

; <label>:37:                                     ; preds = %32
  %38 = sdiv i64 %27, %7
  %39 = shl i64 %38, 4
  tail call fastcc void @luaE_setdebt(%struct.global_State* nonnull %1, i64 %39)
  br label %40

; <label>:40:                                     ; preds = %37, %36
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @stepgenfull(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 5
  %4 = load i64, i64* %3, align 8, !tbaa !30
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 12
  %6 = load i8, i8* %5, align 2, !tbaa !29
  %7 = icmp eq i8 %6, 1
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %2
  tail call fastcc void @enterinc(%struct.global_State* nonnull %1)
  br label %9

; <label>:9:                                      ; preds = %8, %2
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 1)
  %10 = tail call fastcc i64 @atomic(%struct.lua_State* %0)
  %11 = lshr i64 %4, 3
  %12 = add i64 %11, %4
  %13 = icmp ult i64 %10, %12
  br i1 %13, label %14, label %15

; <label>:14:                                     ; preds = %9
  tail call fastcc void @atomic2gen(%struct.lua_State* %0, %struct.global_State* nonnull %1)
  tail call fastcc void @setminordebt(%struct.global_State* nonnull %1)
  br label %22

; <label>:15:                                     ; preds = %9
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 2
  %17 = load i64, i64* %16, align 8, !tbaa !64
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %19 = load i64, i64* %18, align 8, !tbaa !11
  %20 = add nsw i64 %19, %17
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  store i64 %20, i64* %21, align 8, !tbaa !215
  tail call fastcc void @entersweep(%struct.lua_State* %0)
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 256)
  tail call fastcc void @setpause(%struct.global_State* nonnull %1)
  store i64 %10, i64* %3, align 8, !tbaa !30
  br label %22

; <label>:22:                                     ; preds = %15, %14
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @fullgen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  tail call fastcc void @enterinc(%struct.global_State* %1)
  %3 = tail call fastcc i64 @entergen(%struct.lua_State* %0, %struct.global_State* %1)
  ret i64 %3
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @setminordebt(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %3 = load i64, i64* %2, align 8, !tbaa !64
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %5 = load i64, i64* %4, align 8, !tbaa !11
  %6 = add nsw i64 %5, %3
  %7 = udiv i64 %6, 100
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 13
  %9 = load i8, i8* %8, align 1, !tbaa !69
  %10 = zext i8 %9 to i64
  %11 = sub nsw i64 0, %10
  %12 = mul i64 %7, %11
  tail call fastcc void @luaE_setdebt(%struct.global_State* %0, i64 %12)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @setpause(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 17
  %3 = load i8, i8* %2, align 1, !tbaa !65
  %4 = zext i8 %3 to i64
  %5 = shl nuw nsw i64 %4, 2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 4
  %7 = load i64, i64* %6, align 8, !tbaa !215
  %8 = udiv i64 %7, 100
  %9 = udiv i64 9223372036854775807, %8
  %10 = icmp ult i64 %5, %9
  %11 = mul nsw i64 %8, %5
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 2
  %13 = load i64, i64* %12, align 8, !tbaa !64
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 3
  %15 = load i64, i64* %14, align 8, !tbaa !11
  %16 = add nsw i64 %15, %13
  %17 = sub nsw i64 0, %11
  %18 = select i1 %10, i64 %17, i64 -9223372036854775807
  %19 = add i64 %16, %18
  %20 = icmp slt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  tail call fastcc void @luaE_setdebt(%struct.global_State* %0, i64 %21)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @youngcollection(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 30
  %4 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !128
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 32
  %6 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !131
  tail call fastcc void @markold(%struct.global_State* %1, %struct.GCObject* %4, %struct.GCObject* %6)
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 22
  %8 = load %struct.GCObject*, %struct.GCObject** %7, align 8, !tbaa !132
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 35
  %10 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !216
  tail call fastcc void @markold(%struct.global_State* %1, %struct.GCObject* %8, %struct.GCObject* %10)
  %11 = tail call fastcc i64 @atomic(%struct.lua_State* %0)
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 20
  %13 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !128
  %14 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* %0, %struct.global_State* %1, %struct.GCObject** nonnull %12, %struct.GCObject* %13)
  %15 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !131
  %16 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* %0, %struct.global_State* %1, %struct.GCObject** %14, %struct.GCObject* %15)
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 31
  %18 = bitcast %struct.GCObject** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !130
  %20 = bitcast %struct.GCObject** %5 to i64*
  store i64 %19, i64* %20, align 8, !tbaa !131
  %21 = bitcast %struct.GCObject** %14 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !79
  store i64 %22, i64* %18, align 8, !tbaa !130
  %23 = bitcast %struct.GCObject** %12 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !18
  %25 = bitcast %struct.GCObject** %3 to i64*
  store i64 %24, i64* %25, align 8, !tbaa !128
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 33
  %27 = load %struct.GCObject*, %struct.GCObject** %26, align 8, !tbaa !203
  %28 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* %0, %struct.global_State* %1, %struct.GCObject** nonnull %7, %struct.GCObject* %27)
  %29 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !216
  %30 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* %0, %struct.global_State* %1, %struct.GCObject** %28, %struct.GCObject* %29)
  %31 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 34
  %32 = bitcast %struct.GCObject** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !202
  %34 = bitcast %struct.GCObject** %9 to i64*
  store i64 %33, i64* %34, align 8, !tbaa !216
  %35 = bitcast %struct.GCObject** %28 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !79
  store i64 %36, i64* %32, align 8, !tbaa !202
  %37 = bitcast %struct.GCObject** %7 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !132
  %39 = bitcast %struct.GCObject** %26 to i64*
  store i64 %38, i64* %39, align 8, !tbaa !203
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 28
  %41 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* %0, %struct.global_State* %1, %struct.GCObject** nonnull %40, %struct.GCObject* null)
  tail call fastcc void @finishgencycle(%struct.lua_State* %0, %struct.global_State* %1)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @enterinc(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 20
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !18
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %3)
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 30
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %6 = bitcast %struct.GCObject** %4 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %6, i8 0, i64 24, i32 8, i1 false)
  %7 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !132
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %7)
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !204
  tail call fastcc void @whitelist(%struct.global_State* %0, %struct.GCObject* %9)
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %12 = bitcast %struct.GCObject** %10 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %12, i8 0, i64 24, i32 8, i1 false)
  store i8 8, i8* %11, align 1, !tbaa !62
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  store i8 0, i8* %13, align 2, !tbaa !29
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 5
  store i64 0, i64* %14, align 8, !tbaa !30
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaC_runtilstate(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %6 = load i8, i8* %5, align 1, !tbaa !62
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = and i32 %8, %1
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %19

; <label>:11:                                     ; preds = %2
  br label %12

; <label>:12:                                     ; preds = %11, %12
  %13 = tail call fastcc i64 @singlestep(%struct.lua_State* %0)
  %14 = load i8, i8* %5, align 1, !tbaa !62
  %15 = zext i8 %14 to i32
  %16 = shl i32 1, %15
  %17 = and i32 %16, %1
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %12, label %19

; <label>:19:                                     ; preds = %12, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @atomic(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 24
  %5 = bitcast %struct.GCObject** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !126
  store %struct.GCObject* null, %struct.GCObject** %4, align 8, !tbaa !126
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  store i8 2, i8* %7, align 1, !tbaa !62
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !16
  %10 = and i8 %9, 24
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %1
  %13 = bitcast %struct.lua_State* %0 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %3, %struct.GCObject* %13)
  br label %14

; <label>:14:                                     ; preds = %1, %12
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !60
  %17 = and i8 %16, 64
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %27, label %19

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 0, i32 0
  %21 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !53
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %21)
  br label %27

; <label>:27:                                     ; preds = %19, %14, %26
  tail call fastcc void @markmt(%struct.global_State* nonnull %3)
  %28 = tail call fastcc i64 @propagateall(%struct.global_State* nonnull %3)
  %29 = tail call fastcc i32 @remarkupvals(%struct.global_State* nonnull %3)
  %30 = sext i32 %29 to i64
  %31 = add i64 %28, %30
  %32 = tail call fastcc i64 @propagateall(%struct.global_State* nonnull %3)
  %33 = add i64 %31, %32
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %35 = bitcast %struct.GCObject** %34 to i64*
  store i64 %6, i64* %35, align 8, !tbaa !217
  %36 = tail call fastcc i64 @propagateall(%struct.global_State* nonnull %3)
  %37 = add i64 %33, %36
  tail call fastcc void @convergeephemerons(%struct.global_State* nonnull %3)
  %38 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 25
  %39 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !218
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %39, %struct.GCObject* null)
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 27
  %41 = load %struct.GCObject*, %struct.GCObject** %40, align 8, !tbaa !219
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %41, %struct.GCObject* null)
  %42 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !218
  %43 = load %struct.GCObject*, %struct.GCObject** %40, align 8, !tbaa !219
  tail call fastcc void @separatetobefnz(%struct.global_State* nonnull %3, i32 0)
  %44 = tail call fastcc i64 @markbeingfnz(%struct.global_State* nonnull %3)
  %45 = add i64 %37, %44
  %46 = tail call fastcc i64 @propagateall(%struct.global_State* nonnull %3)
  %47 = add i64 %45, %46
  tail call fastcc void @convergeephemerons(%struct.global_State* nonnull %3)
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 26
  %49 = load %struct.GCObject*, %struct.GCObject** %48, align 8, !tbaa !220
  tail call fastcc void @clearbykeys(%struct.global_State* nonnull %3, %struct.GCObject* %49)
  %50 = load %struct.GCObject*, %struct.GCObject** %40, align 8, !tbaa !219
  tail call fastcc void @clearbykeys(%struct.global_State* nonnull %3, %struct.GCObject* %50)
  %51 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !218
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %51, %struct.GCObject* %42)
  %52 = load %struct.GCObject*, %struct.GCObject** %40, align 8, !tbaa !219
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %52, %struct.GCObject* %43)
  tail call fastcc void @luaS_clearcache(%struct.global_State* nonnull %3)
  %53 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %54 = load i8, i8* %53, align 4, !tbaa !15
  %55 = xor i8 %54, 24
  store i8 %55, i8* %53, align 4, !tbaa !15
  ret i64 %47
}

; Function Attrs: nounwind uwtable
define internal fastcc void @atomic2gen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 20
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %3)
  %4 = bitcast %struct.GCObject** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !18
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 30
  %7 = bitcast %struct.GCObject** %6 to i64*
  store i64 %5, i64* %7, align 8, !tbaa !128
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 31
  %9 = bitcast %struct.GCObject** %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !130
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 32
  %11 = bitcast %struct.GCObject** %10 to i64*
  store i64 %5, i64* %11, align 8, !tbaa !131
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 22
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %12)
  %13 = bitcast %struct.GCObject** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !132
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 33
  %16 = bitcast %struct.GCObject** %15 to i64*
  store i64 %14, i64* %16, align 8, !tbaa !203
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 34
  %18 = bitcast %struct.GCObject** %17 to i64*
  store i64 %14, i64* %18, align 8, !tbaa !202
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 35
  %20 = bitcast %struct.GCObject** %19 to i64*
  store i64 %14, i64* %20, align 8, !tbaa !216
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 28
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %21)
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 12
  store i8 1, i8* %22, align 2, !tbaa !29
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 5
  store i64 0, i64* %23, align 8, !tbaa !30
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 2
  %25 = load i64, i64* %24, align 8, !tbaa !64
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %27 = load i64, i64* %26, align 8, !tbaa !11
  %28 = add nsw i64 %27, %25
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  store i64 %28, i64* %29, align 8, !tbaa !215
  tail call fastcc void @finishgencycle(%struct.lua_State* %0, %struct.global_State* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @entersweep(%struct.lua_State* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  store i8 3, i8* %4, align 1, !tbaa !62
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %6 = tail call fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* %0, %struct.GCObject** nonnull %5)
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 21
  store %struct.GCObject** %6, %struct.GCObject*** %7, align 8, !tbaa !127
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @whitelist(%struct.global_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 10
  %4 = load i8, i8* %3, align 4, !tbaa !15
  %5 = and i8 %4, 24
  %6 = icmp eq %struct.GCObject* %1, null
  br i1 %6, label %17, label %7

; <label>:7:                                      ; preds = %2
  br label %8

; <label>:8:                                      ; preds = %7, %8
  %9 = phi %struct.GCObject* [ %15, %8 ], [ %1, %7 ]
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %9, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !53
  %12 = and i8 %11, -64
  %13 = or i8 %12, %5
  store i8 %13, i8* %10, align 1, !tbaa !53
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %9, i64 0, i32 0
  %15 = load %struct.GCObject*, %struct.GCObject** %14, align 8, !tbaa !129
  %16 = icmp eq %struct.GCObject* %15, null
  br i1 %16, label %17, label %8

; <label>:17:                                     ; preds = %8, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @singlestep(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  %5 = load i8, i8* %4, align 1, !tbaa !62
  switch i8 %5, label %47 [
    i8 8, label %6
    i8 0, label %7
    i8 1, label %14
    i8 3, label %22
    i8 4, label %26
    i8 5, label %30
    i8 6, label %33
    i8 7, label %34
  ]

; <label>:6:                                      ; preds = %1
  tail call fastcc void @restartcollection(%struct.global_State* %3)
  store i8 0, i8* %4, align 1, !tbaa !62
  br label %47

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %9 = load %struct.GCObject*, %struct.GCObject** %8, align 8, !tbaa !217
  %10 = icmp eq %struct.GCObject* %9, null
  br i1 %10, label %11, label %12

; <label>:11:                                     ; preds = %7
  store i8 1, i8* %4, align 1, !tbaa !62
  br label %47

; <label>:12:                                     ; preds = %7
  %13 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3)
  br label %47

; <label>:14:                                     ; preds = %1
  %15 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0)
  tail call fastcc void @entersweep(%struct.lua_State* nonnull %0)
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %17 = load i64, i64* %16, align 8, !tbaa !64
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %19 = load i64, i64* %18, align 8, !tbaa !11
  %20 = add nsw i64 %19, %17
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  store i64 %20, i64* %21, align 8, !tbaa !215
  br label %47

; <label>:22:                                     ; preds = %1
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %24 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 4, %struct.GCObject** nonnull %23)
  %25 = sext i32 %24 to i64
  br label %47

; <label>:26:                                     ; preds = %1
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %28 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 5, %struct.GCObject** nonnull %27)
  %29 = sext i32 %28 to i64
  br label %47

; <label>:30:                                     ; preds = %1
  %31 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 6, %struct.GCObject** null)
  %32 = sext i32 %31 to i64
  br label %47

; <label>:33:                                     ; preds = %1
  tail call fastcc void @checkSizes(%struct.lua_State* nonnull %0, %struct.global_State* %3)
  store i8 7, i8* %4, align 1, !tbaa !62
  br label %47

; <label>:34:                                     ; preds = %1
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %36 = load %struct.GCObject*, %struct.GCObject** %35, align 8, !tbaa !204
  %37 = icmp eq %struct.GCObject* %36, null
  br i1 %37, label %46, label %38

; <label>:38:                                     ; preds = %34
  %39 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 16
  %40 = load i8, i8* %39, align 2, !tbaa !63
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %42, label %46

; <label>:42:                                     ; preds = %38
  %43 = tail call fastcc i32 @runafewfinalizers(%struct.lua_State* nonnull %0)
  %44 = mul nsw i32 %43, 50
  %45 = sext i32 %44 to i64
  br label %47

; <label>:46:                                     ; preds = %38, %34
  store i8 8, i8* %4, align 1, !tbaa !62
  br label %47

; <label>:47:                                     ; preds = %1, %46, %42, %33, %30, %26, %22, %14, %12, %11, %6
  %48 = phi i64 [ 0, %46 ], [ %45, %42 ], [ 0, %33 ], [ %32, %30 ], [ %29, %26 ], [ %25, %22 ], [ %15, %14 ], [ 0, %11 ], [ %13, %12 ], [ 1, %6 ], [ 0, %1 ]
  ret i64 %48
}

; Function Attrs: nounwind uwtable
define internal fastcc void @restartcollection(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 38
  %4 = bitcast %struct.GCObject** %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %4, i8 0, i64 40, i32 8, i1 false)
  %5 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !27
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 2
  %7 = load i8, i8* %6, align 1, !tbaa !16
  %8 = and i8 %7, 24
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %1
  %11 = bitcast %struct.lua_State* %5 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %11)
  br label %12

; <label>:12:                                     ; preds = %1, %10
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 7, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !60
  %15 = and i8 %14, 64
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %25, label %17

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 7, i32 0, i32 0
  %19 = load %struct.GCObject*, %struct.GCObject** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %19, i64 0, i32 2
  %21 = load i8, i8* %20, align 1, !tbaa !53
  %22 = and i8 %21, 24
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %17
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %19)
  br label %25

; <label>:25:                                     ; preds = %17, %12, %24
  tail call fastcc void @markmt(%struct.global_State* nonnull %0)
  %26 = tail call fastcc i64 @markbeingfnz(%struct.global_State* nonnull %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @propagatemark(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !217
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 2
  %5 = load i8, i8* %4, align 1, !tbaa !53
  %6 = or i8 %5, 32
  store i8 %6, i8* %4, align 1, !tbaa !53
  %7 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* %3)
  %8 = bitcast %struct.GCObject** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !79
  %10 = bitcast %struct.GCObject** %2 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !217
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !205
  switch i8 %12, label %42 [
    i8 5, label %13
    i8 7, label %16
    i8 22, label %20
    i8 54, label %24
    i8 10, label %28
    i8 8, label %32
  ]

; <label>:13:                                     ; preds = %1
  %14 = bitcast %struct.GCObject* %3 to %struct.Table*
  %15 = tail call fastcc i64 @traversetable(%struct.global_State* nonnull %0, %struct.Table* %14)
  br label %42

; <label>:16:                                     ; preds = %1
  %17 = bitcast %struct.GCObject* %3 to %struct.Udata*
  %18 = tail call fastcc i32 @traverseudata(%struct.global_State* nonnull %0, %struct.Udata* %17)
  %19 = sext i32 %18 to i64
  br label %42

; <label>:20:                                     ; preds = %1
  %21 = bitcast %struct.GCObject* %3 to %struct.LClosure*
  %22 = tail call fastcc i32 @traverseLclosure(%struct.global_State* nonnull %0, %struct.LClosure* %21)
  %23 = sext i32 %22 to i64
  br label %42

; <label>:24:                                     ; preds = %1
  %25 = bitcast %struct.GCObject* %3 to %struct.CClosure*
  %26 = tail call fastcc i32 @traverseCclosure(%struct.global_State* nonnull %0, %struct.CClosure* %25)
  %27 = sext i32 %26 to i64
  br label %42

; <label>:28:                                     ; preds = %1
  %29 = bitcast %struct.GCObject* %3 to %struct.Proto*
  %30 = tail call fastcc i32 @traverseproto(%struct.global_State* nonnull %0, %struct.Proto* %29)
  %31 = sext i32 %30 to i64
  br label %42

; <label>:32:                                     ; preds = %1
  %33 = bitcast %struct.GCObject* %3 to %struct.lua_State*
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %35 = bitcast %struct.GCObject** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !126
  %37 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4, i32 1
  %38 = bitcast i8* %37 to i64*
  store i64 %36, i64* %38, align 8, !tbaa !221
  store %struct.GCObject* %3, %struct.GCObject** %34, align 8, !tbaa !126
  %39 = and i8 %5, -33
  store i8 %39, i8* %4, align 1, !tbaa !53
  %40 = tail call fastcc i32 @traversethread(%struct.global_State* nonnull %0, %struct.lua_State* %33)
  %41 = sext i32 %40 to i64
  br label %42

; <label>:42:                                     ; preds = %1, %32, %28, %24, %20, %16, %13
  %43 = phi i64 [ %41, %32 ], [ %31, %28 ], [ %27, %24 ], [ %23, %20 ], [ %19, %16 ], [ %15, %13 ], [ 0, %1 ]
  ret i64 %43
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @sweepstep(%struct.lua_State*, %struct.global_State* nocapture, i32, %struct.GCObject**) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 21
  %7 = load %struct.GCObject**, %struct.GCObject*** %6, align 8, !tbaa !127
  %8 = icmp eq %struct.GCObject** %7, null
  br i1 %8, label %20, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %11 = load i64, i64* %10, align 8, !tbaa !11
  %12 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #7
  %13 = call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %7, i32 100, i32* nonnull %5)
  store %struct.GCObject** %13, %struct.GCObject*** %6, align 8, !tbaa !127
  %14 = load i64, i64* %10, align 8, !tbaa !11
  %15 = sub i64 %14, %11
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %17 = load i64, i64* %16, align 8, !tbaa !215
  %18 = add i64 %15, %17
  store i64 %18, i64* %16, align 8, !tbaa !215
  %19 = load i32, i32* %5, align 4, !tbaa !70
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #7
  br label %23

; <label>:20:                                     ; preds = %4
  %21 = trunc i32 %2 to i8
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 %21, i8* %22, align 1, !tbaa !62
  store %struct.GCObject** %3, %struct.GCObject*** %6, align 8, !tbaa !127
  br label %23

; <label>:23:                                     ; preds = %20, %9
  %24 = phi i32 [ %19, %9 ], [ 0, %20 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkSizes(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %4 = load i8, i8* %3, align 2, !tbaa !63
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %6, label %23

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 1
  %10 = load i32, i32* %9, align 8, !tbaa !222
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !76
  %13 = sdiv i32 %12, 4
  %14 = icmp slt i32 %10, %13
  br i1 %14, label %15, label %17

; <label>:15:                                     ; preds = %6
  %16 = sdiv i32 %12, 2
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %16)
  br label %17

; <label>:17:                                     ; preds = %15, %6
  %18 = load i64, i64* %7, align 8, !tbaa !11
  %19 = sub i64 %18, %8
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %21 = load i64, i64* %20, align 8, !tbaa !215
  %22 = add i64 %19, %21
  store i64 %22, i64* %20, align 8, !tbaa !215
  br label %23

; <label>:23:                                     ; preds = %2, %17
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @runafewfinalizers(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  br label %5

; <label>:5:                                      ; preds = %1, %9
  %6 = phi i32 [ 0, %1 ], [ %10, %9 ]
  %7 = load %struct.GCObject*, %struct.GCObject** %4, align 8, !tbaa !204
  %8 = icmp eq %struct.GCObject* %7, null
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %5
  tail call fastcc void @GCTM(%struct.lua_State* %0)
  %10 = add nuw nsw i32 %6, 1
  %11 = icmp ult i32 %10, 10
  br i1 %11, label %5, label %12

; <label>:12:                                     ; preds = %5, %9
  %13 = phi i32 [ %6, %5 ], [ 10, %9 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc void @reallymarkobject(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  br label %3

; <label>:3:                                      ; preds = %26, %2
  %4 = phi %struct.GCObject* [ %1, %2 ], [ %28, %26 ]
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 0, i32 2
  %6 = load i8, i8* %5, align 1, !tbaa !53
  %7 = and i8 %6, -25
  store i8 %7, i8* %5, align 1, !tbaa !53
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !205
  switch i8 %9, label %59 [
    i8 20, label %10
    i8 36, label %10
    i8 9, label %12
    i8 25, label %12
    i8 7, label %33
    i8 22, label %53
    i8 54, label %53
    i8 5, label %53
    i8 8, label %53
    i8 10, label %53
  ]

; <label>:10:                                     ; preds = %3, %3
  %11 = or i8 %7, 32
  store i8 %11, i8* %5, align 1, !tbaa !53
  br label %59

; <label>:12:                                     ; preds = %3, %3
  %13 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 1
  %14 = bitcast %struct.GCObject* %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !50
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 1, i32 1
  %17 = bitcast i8* %16 to %struct.TValue*
  %18 = icmp eq %struct.TValue* %15, %17
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %12
  %20 = or i8 %7, 32
  store i8 %20, i8* %5, align 1, !tbaa !53
  br label %21

; <label>:21:                                     ; preds = %12, %19
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = and i8 %23, 64
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %59, label %26

; <label>:26:                                     ; preds = %21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 0, i32 0
  %28 = load %struct.GCObject*, %struct.GCObject** %27, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %28, i64 0, i32 2
  %30 = load i8, i8* %29, align 1, !tbaa !53
  %31 = and i8 %30, 24
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %59, label %3

; <label>:33:                                     ; preds = %3
  %34 = bitcast %struct.GCObject* %4 to %struct.Udata*
  %35 = getelementptr inbounds %struct.Udata, %struct.Udata* %34, i64 0, i32 3
  %36 = load i16, i16* %35, align 2, !tbaa !169
  %37 = icmp eq i16 %36, 0
  br i1 %37, label %38, label %53

; <label>:38:                                     ; preds = %33
  %39 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4, i64 1, i32 1
  %40 = bitcast i8* %39 to %struct.Table**
  %41 = load %struct.Table*, %struct.Table** %40, align 8, !tbaa !172
  %42 = icmp eq %struct.Table* %41, null
  br i1 %42, label %50, label %43

; <label>:43:                                     ; preds = %38
  %44 = getelementptr inbounds %struct.Table, %struct.Table* %41, i64 0, i32 2
  %45 = load i8, i8* %44, align 1, !tbaa !116
  %46 = and i8 %45, 24
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %50, label %48

; <label>:48:                                     ; preds = %43
  %49 = bitcast %struct.Table* %41 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %49)
  br label %50

; <label>:50:                                     ; preds = %43, %38, %48
  %51 = load i8, i8* %5, align 1, !tbaa !53
  %52 = or i8 %51, 32
  store i8 %52, i8* %5, align 1, !tbaa !53
  br label %59

; <label>:53:                                     ; preds = %3, %3, %3, %3, %3, %33
  %54 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %55 = bitcast %struct.GCObject** %54 to i64*
  %56 = load i64, i64* %55, align 8, !tbaa !217
  %57 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %4)
  %58 = bitcast %struct.GCObject** %57 to i64*
  store i64 %56, i64* %58, align 8, !tbaa !79
  store %struct.GCObject* %4, %struct.GCObject** %54, align 8, !tbaa !217
  br label %59

; <label>:59:                                     ; preds = %21, %26, %3, %50, %53, %10
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @markmt(%struct.global_State*) unnamed_addr #0 {
  br label %2

; <label>:2:                                      ; preds = %14, %1
  %3 = phi i64 [ 0, %1 ], [ %15, %14 ]
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 41, i64 %3
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !79
  %6 = icmp eq %struct.Table* %5, null
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !116
  %10 = and i8 %9, 24
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %7
  %13 = bitcast %struct.Table* %5 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %13)
  br label %14

; <label>:14:                                     ; preds = %7, %2, %12
  %15 = add nuw nsw i64 %3, 1
  %16 = icmp eq i64 %15, 9
  br i1 %16, label %17, label %2

; <label>:17:                                     ; preds = %14
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @markbeingfnz(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !79
  %4 = icmp eq %struct.GCObject* %3, null
  br i1 %4, label %19, label %5

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %5, %15
  %7 = phi %struct.GCObject* [ %17, %15 ], [ %3, %5 ]
  %8 = phi i64 [ %9, %15 ], [ 0, %5 ]
  %9 = add i64 %8, 1
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !53
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %6
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %7)
  br label %15

; <label>:15:                                     ; preds = %6, %14
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %17 = load %struct.GCObject*, %struct.GCObject** %16, align 8, !tbaa !79
  %18 = icmp eq %struct.GCObject* %17, null
  br i1 %18, label %19, label %6

; <label>:19:                                     ; preds = %15, %1
  %20 = phi i64 [ 0, %1 ], [ %9, %15 ]
  ret i64 %20
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.GCObject** @getgclist(%struct.GCObject* readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 0, i32 1
  %3 = load i8, i8* %2, align 8, !tbaa !205
  switch i8 %3, label %18 [
    i8 5, label %4
    i8 22, label %6
    i8 54, label %8
    i8 8, label %10
    i8 10, label %13
    i8 7, label %16
  ]

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 3, i32 0
  br label %18

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 4, i32 1
  %12 = bitcast i8* %11 to %struct.GCObject**
  br label %18

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 7, i32 1
  %15 = bitcast i8* %14 to %struct.GCObject**
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 2, i32 0
  br label %18

; <label>:18:                                     ; preds = %1, %16, %13, %10, %8, %6, %4
  %19 = phi %struct.GCObject** [ %17, %16 ], [ %15, %13 ], [ %12, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ null, %1 ]
  ret %struct.GCObject** %19
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @traversetable(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 9
  %4 = load %struct.Table*, %struct.Table** %3, align 8, !tbaa !125
  %5 = icmp eq %struct.Table* %4, null
  br i1 %5, label %57, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %4, i64 0, i32 3
  %8 = load i8, i8* %7, align 2, !tbaa !111
  %9 = and i8 %8, 8
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %15

; <label>:11:                                     ; preds = %6
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 40, i64 3
  %13 = load %struct.TString*, %struct.TString** %12, align 8, !tbaa !79
  %14 = tail call fastcc %struct.TValue* @luaT_gettm(%struct.Table* nonnull %4, i32 3, %struct.TString* %13)
  br label %15

; <label>:15:                                     ; preds = %6, %11
  %16 = phi %struct.TValue* [ null, %6 ], [ %14, %11 ]
  %17 = load %struct.Table*, %struct.Table** %3, align 8, !tbaa !125
  %18 = icmp eq %struct.Table* %17, null
  br i1 %18, label %26, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %21 = load i8, i8* %20, align 1, !tbaa !116
  %22 = and i8 %21, 24
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %26, label %24

; <label>:24:                                     ; preds = %19
  %25 = bitcast %struct.Table* %17 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %25)
  br label %26

; <label>:26:                                     ; preds = %19, %15, %24
  %27 = icmp eq %struct.TValue* %16, null
  br i1 %27, label %57, label %28

; <label>:28:                                     ; preds = %26
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = and i8 %30, 15
  %32 = icmp eq i8 %31, 4
  br i1 %32, label %33, label %57

; <label>:33:                                     ; preds = %28
  %34 = bitcast %struct.TValue* %16 to i8**
  %35 = load i8*, i8** %34, align 8, !tbaa !21
  %36 = getelementptr inbounds i8, i8* %35, i64 24
  %37 = tail call i8* @strchr(i8* nonnull %36, i32 107) #19
  %38 = tail call i8* @strchr(i8* nonnull %36, i32 118) #19
  %39 = icmp ne i8* %37, null
  %40 = icmp ne i8* %38, null
  %41 = or i1 %39, %40
  br i1 %41, label %42, label %57

; <label>:42:                                     ; preds = %33
  %43 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %44 = load i8, i8* %43, align 1, !tbaa !116
  %45 = and i8 %44, -33
  store i8 %45, i8* %43, align 1, !tbaa !116
  br i1 %39, label %47, label %46

; <label>:46:                                     ; preds = %42
  tail call fastcc void @traverseweakvalue(%struct.global_State* %0, %struct.Table* nonnull %1)
  br label %58

; <label>:47:                                     ; preds = %42
  br i1 %40, label %50, label %48

; <label>:48:                                     ; preds = %47
  %49 = tail call fastcc i32 @traverseephemeron(%struct.global_State* %0, %struct.Table* nonnull %1)
  br label %58

; <label>:50:                                     ; preds = %47
  %51 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %52 = bitcast %struct.GCObject** %51 to i64*
  %53 = load i64, i64* %52, align 8, !tbaa !219
  %54 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %55 = bitcast %struct.GCObject** %54 to i64*
  store i64 %53, i64* %55, align 8, !tbaa !223
  %56 = bitcast %struct.GCObject** %51 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %56, align 8, !tbaa !219
  br label %58

; <label>:57:                                     ; preds = %2, %26, %33, %28
  tail call fastcc void @traversestrongtable(%struct.global_State* %0, %struct.Table* nonnull %1)
  br label %58

; <label>:58:                                     ; preds = %46, %50, %48, %57
  %59 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  %60 = load i32, i32* %59, align 4, !tbaa !114
  %61 = add i32 %60, 1
  %62 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %63 = load %union.Node*, %union.Node** %62, align 8, !tbaa !117
  %64 = icmp eq %union.Node* %63, null
  br i1 %64, label %70, label %65

; <label>:65:                                     ; preds = %58
  %66 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %67 = load i8, i8* %66, align 1, !tbaa !124
  %68 = zext i8 %67 to i32
  %69 = shl i32 2, %68
  br label %70

; <label>:70:                                     ; preds = %58, %65
  %71 = phi i32 [ %69, %65 ], [ 0, %58 ]
  %72 = add i32 %61, %71
  %73 = zext i32 %72 to i64
  ret i64 %73
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traverseudata(%struct.global_State*, %struct.Udata*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 5
  %4 = load %struct.Table*, %struct.Table** %3, align 8, !tbaa !172
  %5 = icmp eq %struct.Table* %4, null
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %4, i64 0, i32 2
  %8 = load i8, i8* %7, align 1, !tbaa !116
  %9 = and i8 %8, 24
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %6
  %12 = bitcast %struct.Table* %4 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %12)
  br label %13

; <label>:13:                                     ; preds = %6, %2, %11
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 3
  %15 = load i16, i16* %14, align 2, !tbaa !169
  %16 = icmp eq i16 %15, 0
  br i1 %16, label %40, label %17

; <label>:17:                                     ; preds = %13
  br label %18

; <label>:18:                                     ; preds = %17, %32
  %19 = phi i64 [ %33, %32 ], [ 0, %17 ]
  %20 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 7, i64 %19, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %32, label %24

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 7, i64 %19, i32 0, i32 0, i32 0
  %26 = load %struct.GCObject*, %struct.GCObject** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !53
  %29 = and i8 %28, 24
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %32, label %31

; <label>:31:                                     ; preds = %24
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %26)
  br label %32

; <label>:32:                                     ; preds = %24, %18, %31
  %33 = add nuw nsw i64 %19, 1
  %34 = load i16, i16* %14, align 2, !tbaa !169
  %35 = zext i16 %34 to i64
  %36 = icmp ult i64 %33, %35
  br i1 %36, label %18, label %37

; <label>:37:                                     ; preds = %32
  %38 = zext i16 %34 to i32
  %39 = add nuw nsw i32 %38, 1
  br label %40

; <label>:40:                                     ; preds = %37, %13
  %41 = phi i32 [ 1, %13 ], [ %39, %37 ]
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %43 = load i8, i8* %42, align 2, !tbaa !29
  %44 = icmp eq i8 %43, 1
  br i1 %44, label %45, label %55

; <label>:45:                                     ; preds = %40
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %47 = bitcast %struct.GCObject** %46 to i64*
  %48 = load i64, i64* %47, align 8, !tbaa !126
  %49 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 6
  %50 = bitcast %struct.GCObject** %49 to i64*
  store i64 %48, i64* %50, align 8, !tbaa !224
  %51 = bitcast %struct.GCObject** %46 to %struct.Udata**
  store %struct.Udata* %1, %struct.Udata** %51, align 8, !tbaa !126
  %52 = getelementptr inbounds %struct.Udata, %struct.Udata* %1, i64 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !225
  %54 = and i8 %53, -33
  store i8 %54, i8* %52, align 1, !tbaa !225
  br label %55

; <label>:55:                                     ; preds = %45, %40
  ret i32 %41
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traverseLclosure(%struct.global_State*, %struct.LClosure* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 5
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !173
  %5 = icmp eq %struct.Proto* %4, null
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 2
  %8 = load i8, i8* %7, align 1, !tbaa !226
  %9 = and i8 %8, 24
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %6
  %12 = bitcast %struct.Proto* %4 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %12)
  br label %13

; <label>:13:                                     ; preds = %6, %2, %11
  %14 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 3
  %15 = load i8, i8* %14, align 2, !tbaa !138
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %38, label %17

; <label>:17:                                     ; preds = %13
  br label %18

; <label>:18:                                     ; preds = %17, %30
  %19 = phi i64 [ %31, %30 ], [ 0, %17 ]
  %20 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 6, i64 %19
  %21 = load %struct.UpVal*, %struct.UpVal** %20, align 8, !tbaa !79
  %22 = icmp eq %struct.UpVal* %21, null
  br i1 %22, label %30, label %23

; <label>:23:                                     ; preds = %18
  %24 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %21, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !52
  %26 = and i8 %25, 24
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %30, label %28

; <label>:28:                                     ; preds = %23
  %29 = bitcast %struct.UpVal* %21 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %29)
  br label %30

; <label>:30:                                     ; preds = %23, %18, %28
  %31 = add nuw nsw i64 %19, 1
  %32 = load i8, i8* %14, align 2, !tbaa !138
  %33 = zext i8 %32 to i64
  %34 = icmp ult i64 %31, %33
  br i1 %34, label %18, label %35

; <label>:35:                                     ; preds = %30
  %36 = zext i8 %32 to i32
  %37 = add nuw nsw i32 %36, 1
  br label %38

; <label>:38:                                     ; preds = %35, %13
  %39 = phi i32 [ 1, %13 ], [ %37, %35 ]
  ret i32 %39
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traverseCclosure(%struct.global_State*, %struct.CClosure* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %1, i64 0, i32 3
  %4 = load i8, i8* %3, align 2, !tbaa !105
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %29, label %6

; <label>:6:                                      ; preds = %2
  br label %7

; <label>:7:                                      ; preds = %6, %21
  %8 = phi i64 [ %22, %21 ], [ 0, %6 ]
  %9 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %1, i64 0, i32 6, i64 %8, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 64
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %7
  %14 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %1, i64 0, i32 6, i64 %8, i32 0, i32 0
  %15 = load %struct.GCObject*, %struct.GCObject** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %15, i64 0, i32 2
  %17 = load i8, i8* %16, align 1, !tbaa !53
  %18 = and i8 %17, 24
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %13
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %15)
  br label %21

; <label>:21:                                     ; preds = %13, %7, %20
  %22 = add nuw nsw i64 %8, 1
  %23 = load i8, i8* %3, align 2, !tbaa !105
  %24 = zext i8 %23 to i64
  %25 = icmp ult i64 %22, %24
  br i1 %25, label %7, label %26

; <label>:26:                                     ; preds = %21
  %27 = zext i8 %23 to i32
  %28 = add nuw nsw i32 %27, 1
  br label %29

; <label>:29:                                     ; preds = %26, %2
  %30 = phi i32 [ 1, %2 ], [ %28, %26 ]
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traverseproto(%struct.global_State*, %struct.Proto* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 22
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !104
  %5 = icmp eq %struct.TString* %4, null
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 2
  %8 = load i8, i8* %7, align 1, !tbaa !227
  %9 = and i8 %8, 24
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %6
  %12 = bitcast %struct.TString* %4 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %12)
  br label %13

; <label>:13:                                     ; preds = %6, %2, %11
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 7
  %15 = load i32, i32* %14, align 4, !tbaa !210
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %17, label %39

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 15
  br label %19

; <label>:19:                                     ; preds = %17, %34
  %20 = phi i64 [ 0, %17 ], [ %35, %34 ]
  %21 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !209
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 %20, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = and i8 %23, 64
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %34, label %26

; <label>:26:                                     ; preds = %19
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 %20, i32 0, i32 0
  %28 = load %struct.GCObject*, %struct.GCObject** %27, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %28, i64 0, i32 2
  %30 = load i8, i8* %29, align 1, !tbaa !53
  %31 = and i8 %30, 24
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %34, label %33

; <label>:33:                                     ; preds = %26
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %28)
  br label %34

; <label>:34:                                     ; preds = %26, %19, %33
  %35 = add nuw nsw i64 %20, 1
  %36 = load i32, i32* %14, align 4, !tbaa !210
  %37 = sext i32 %36 to i64
  %38 = icmp slt i64 %35, %37
  br i1 %38, label %19, label %39

; <label>:39:                                     ; preds = %34, %13
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  %41 = load i32, i32* %40, align 8, !tbaa !166
  %42 = icmp sgt i32 %41, 0
  br i1 %42, label %43, label %63

; <label>:43:                                     ; preds = %39
  %44 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  br label %45

; <label>:45:                                     ; preds = %43, %58
  %46 = phi i64 [ 0, %43 ], [ %59, %58 ]
  %47 = load %struct.Upvaldesc*, %struct.Upvaldesc** %44, align 8, !tbaa !174
  %48 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %47, i64 %46, i32 0
  %49 = load %struct.TString*, %struct.TString** %48, align 8, !tbaa !175
  %50 = icmp eq %struct.TString* %49, null
  br i1 %50, label %58, label %51

; <label>:51:                                     ; preds = %45
  %52 = getelementptr inbounds %struct.TString, %struct.TString* %49, i64 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !227
  %54 = and i8 %53, 24
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %58, label %56

; <label>:56:                                     ; preds = %51
  %57 = bitcast %struct.TString* %49 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %57)
  br label %58

; <label>:58:                                     ; preds = %51, %45, %56
  %59 = add nuw nsw i64 %46, 1
  %60 = load i32, i32* %40, align 8, !tbaa !166
  %61 = sext i32 %60 to i64
  %62 = icmp slt i64 %59, %61
  br i1 %62, label %45, label %63

; <label>:63:                                     ; preds = %58, %39
  %64 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 10
  %65 = load i32, i32* %64, align 8, !tbaa !208
  %66 = icmp sgt i32 %65, 0
  br i1 %66, label %67, label %87

; <label>:67:                                     ; preds = %63
  %68 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 17
  br label %69

; <label>:69:                                     ; preds = %67, %82
  %70 = phi i64 [ 0, %67 ], [ %83, %82 ]
  %71 = load %struct.Proto**, %struct.Proto*** %68, align 8, !tbaa !207
  %72 = getelementptr inbounds %struct.Proto*, %struct.Proto** %71, i64 %70
  %73 = load %struct.Proto*, %struct.Proto** %72, align 8, !tbaa !79
  %74 = icmp eq %struct.Proto* %73, null
  br i1 %74, label %82, label %75

; <label>:75:                                     ; preds = %69
  %76 = getelementptr inbounds %struct.Proto, %struct.Proto* %73, i64 0, i32 2
  %77 = load i8, i8* %76, align 1, !tbaa !226
  %78 = and i8 %77, 24
  %79 = icmp eq i8 %78, 0
  br i1 %79, label %82, label %80

; <label>:80:                                     ; preds = %75
  %81 = bitcast %struct.Proto* %73 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %81)
  br label %82

; <label>:82:                                     ; preds = %75, %69, %80
  %83 = add nuw nsw i64 %70, 1
  %84 = load i32, i32* %64, align 8, !tbaa !208
  %85 = sext i32 %84 to i64
  %86 = icmp slt i64 %83, %85
  br i1 %86, label %69, label %87

; <label>:87:                                     ; preds = %82, %63
  %88 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 11
  %89 = load i32, i32* %88, align 4, !tbaa !82
  %90 = icmp sgt i32 %89, 0
  br i1 %90, label %91, label %111

; <label>:91:                                     ; preds = %87
  %92 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 21
  br label %93

; <label>:93:                                     ; preds = %91, %106
  %94 = phi i64 [ 0, %91 ], [ %107, %106 ]
  %95 = load %struct.LocVar*, %struct.LocVar** %92, align 8, !tbaa !84
  %96 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %95, i64 %94, i32 0
  %97 = load %struct.TString*, %struct.TString** %96, align 8, !tbaa !88
  %98 = icmp eq %struct.TString* %97, null
  br i1 %98, label %106, label %99

; <label>:99:                                     ; preds = %93
  %100 = getelementptr inbounds %struct.TString, %struct.TString* %97, i64 0, i32 2
  %101 = load i8, i8* %100, align 1, !tbaa !227
  %102 = and i8 %101, 24
  %103 = icmp eq i8 %102, 0
  br i1 %103, label %106, label %104

; <label>:104:                                    ; preds = %99
  %105 = bitcast %struct.TString* %97 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %105)
  br label %106

; <label>:106:                                    ; preds = %99, %93, %104
  %107 = add nuw nsw i64 %94, 1
  %108 = load i32, i32* %88, align 4, !tbaa !82
  %109 = sext i32 %108 to i64
  %110 = icmp slt i64 %107, %109
  br i1 %110, label %93, label %111

; <label>:111:                                    ; preds = %106, %87
  %112 = phi i32 [ %89, %87 ], [ %108, %106 ]
  %113 = load i32, i32* %14, align 4, !tbaa !210
  %114 = load i32, i32* %40, align 8, !tbaa !166
  %115 = load i32, i32* %64, align 8, !tbaa !208
  %116 = add i32 %112, 1
  %117 = add i32 %116, %113
  %118 = add i32 %117, %114
  %119 = add i32 %118, %115
  ret i32 %119
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traversethread(%struct.global_State*, %struct.lua_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 11
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !34
  %5 = icmp eq %union.StackValue* %4, null
  br i1 %5, label %89, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %4, %8
  br i1 %9, label %10, label %29

; <label>:10:                                     ; preds = %6
  br label %11

; <label>:11:                                     ; preds = %10, %25
  %12 = phi %union.StackValue* [ %26, %25 ], [ %4, %10 ]
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !21
  %15 = and i8 %14, 64
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %25, label %17

; <label>:17:                                     ; preds = %11
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0, i32 0, i32 0
  %19 = load %struct.GCObject*, %struct.GCObject** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %19, i64 0, i32 2
  %21 = load i8, i8* %20, align 1, !tbaa !53
  %22 = and i8 %21, 24
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %17
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %19)
  br label %25

; <label>:25:                                     ; preds = %17, %11, %24
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1
  %27 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %28 = icmp ult %union.StackValue* %26, %27
  br i1 %28, label %11, label %29

; <label>:29:                                     ; preds = %25, %6
  %30 = phi %union.StackValue* [ %4, %6 ], [ %26, %25 ]
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 12
  %32 = load %struct.UpVal*, %struct.UpVal** %31, align 8, !tbaa !21
  %33 = icmp eq %struct.UpVal* %32, null
  br i1 %33, label %51, label %34

; <label>:34:                                     ; preds = %29
  br label %35

; <label>:35:                                     ; preds = %34, %47
  %36 = phi %struct.UpVal* [ %49, %47 ], [ %32, %34 ]
  %37 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %36, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !55
  %39 = icmp eq i8 %38, 25
  br i1 %39, label %40, label %47

; <label>:40:                                     ; preds = %35
  %41 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %36, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !52
  %43 = and i8 %42, 24
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %47, label %45

; <label>:45:                                     ; preds = %40
  %46 = bitcast %struct.UpVal* %36 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %46)
  br label %47

; <label>:47:                                     ; preds = %40, %35, %45
  %48 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %36, i64 0, i32 4, i32 0, i32 0
  %49 = load %struct.UpVal*, %struct.UpVal** %48, align 8, !tbaa !21
  %50 = icmp eq %struct.UpVal* %49, null
  br i1 %50, label %51, label %35

; <label>:51:                                     ; preds = %47, %29
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %53 = load i8, i8* %52, align 1, !tbaa !62
  %54 = icmp eq i8 %53, 2
  br i1 %54, label %55, label %80

; <label>:55:                                     ; preds = %51
  %56 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !34
  %57 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 20
  %58 = load i32, i32* %57, align 4, !tbaa !37
  %59 = sext i32 %58 to i64
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 %59
  %61 = icmp ult %union.StackValue* %30, %60
  br i1 %61, label %62, label %68

; <label>:62:                                     ; preds = %55
  br label %63

; <label>:63:                                     ; preds = %62, %63
  %64 = phi %union.StackValue* [ %66, %63 ], [ %30, %62 ]
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 0, i32 0, i32 1
  store i8 0, i8* %65, align 8, !tbaa !21
  %66 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 1
  %67 = icmp ult %union.StackValue* %66, %60
  br i1 %67, label %63, label %68

; <label>:68:                                     ; preds = %63, %55
  %69 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 14
  %70 = load %struct.lua_State*, %struct.lua_State** %69, align 8, !tbaa !38
  %71 = icmp eq %struct.lua_State* %70, %1
  br i1 %71, label %72, label %85

; <label>:72:                                     ; preds = %68
  %73 = load %struct.UpVal*, %struct.UpVal** %31, align 8, !tbaa !42
  %74 = icmp eq %struct.UpVal* %73, null
  br i1 %74, label %85, label %75

; <label>:75:                                     ; preds = %72
  %76 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 36
  %77 = bitcast %struct.lua_State** %76 to i64*
  %78 = load i64, i64* %77, align 8, !tbaa !228
  %79 = bitcast %struct.lua_State** %69 to i64*
  store i64 %78, i64* %79, align 8, !tbaa !38
  store %struct.lua_State* %1, %struct.lua_State** %76, align 8, !tbaa !228
  br label %85

; <label>:80:                                     ; preds = %51
  %81 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 16
  %82 = load i8, i8* %81, align 2, !tbaa !63
  %83 = icmp eq i8 %82, 0
  br i1 %83, label %84, label %85

; <label>:84:                                     ; preds = %80
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* %1)
  br label %85

; <label>:85:                                     ; preds = %75, %68, %72, %80, %84
  %86 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 20
  %87 = load i32, i32* %86, align 4, !tbaa !37
  %88 = add nsw i32 %87, 1
  br label %89

; <label>:89:                                     ; preds = %2, %85
  %90 = phi i32 [ %88, %85 ], [ 1, %2 ]
  ret i32 %90
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %struct.TValue* @luaT_gettm(%struct.Table* nocapture, i32, %struct.TString* readonly) unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* %2)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %9, label %15

; <label>:9:                                      ; preds = %3
  %10 = shl i32 1, %1
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 3
  %12 = load i8, i8* %11, align 2, !tbaa !111
  %13 = trunc i32 %10 to i8
  %14 = or i8 %12, %13
  store i8 %14, i8* %11, align 2, !tbaa !111
  br label %15

; <label>:15:                                     ; preds = %3, %9
  %16 = phi %struct.TValue* [ null, %9 ], [ %4, %3 ]
  ret %struct.TValue* %16
}

; Function Attrs: nounwind uwtable
define internal fastcc void @traverseweakvalue(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !124
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds %union.Node, %union.Node* %4, i64 %9
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  %12 = load i32, i32* %11, align 4, !tbaa !114
  %13 = icmp ne i32 %12, 0
  %14 = zext i1 %13 to i32
  %15 = icmp eq i8 %6, 31
  br i1 %15, label %56, label %16

; <label>:16:                                     ; preds = %2
  br label %17

; <label>:17:                                     ; preds = %16, %52
  %18 = phi i32 [ %53, %52 ], [ %14, %16 ]
  %19 = phi %union.Node* [ %54, %52 ], [ %4, %16 ]
  %20 = getelementptr inbounds %union.Node, %union.Node* %19, i64 0, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %25

; <label>:24:                                     ; preds = %17
  tail call fastcc void @clearkey(%union.Node* nonnull %19)
  br label %52

; <label>:25:                                     ; preds = %17
  %26 = getelementptr inbounds %union.Node, %union.Node* %19, i64 0, i32 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = and i8 %27, 64
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %38, label %30

; <label>:30:                                     ; preds = %25
  %31 = getelementptr inbounds %union.Node, %union.Node* %19, i64 0, i32 0, i32 4, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !53
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %30
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %32)
  br label %38

; <label>:38:                                     ; preds = %30, %25, %37
  %39 = icmp eq i32 %18, 0
  br i1 %39, label %40, label %52

; <label>:40:                                     ; preds = %38
  %41 = load i8, i8* %20, align 8, !tbaa !21
  %42 = and i8 %41, 64
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %47, label %44

; <label>:44:                                     ; preds = %40
  %45 = getelementptr inbounds %union.Node, %union.Node* %19, i64 0, i32 0, i32 0, i32 0
  %46 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !21
  br label %47

; <label>:47:                                     ; preds = %40, %44
  %48 = phi %struct.GCObject* [ %46, %44 ], [ null, %40 ]
  %49 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %48)
  %50 = icmp eq i32 %49, 0
  %51 = select i1 %50, i32 %18, i32 1
  br label %52

; <label>:52:                                     ; preds = %47, %38, %24
  %53 = phi i32 [ %18, %24 ], [ %18, %38 ], [ %51, %47 ]
  %54 = getelementptr inbounds %union.Node, %union.Node* %19, i64 1
  %55 = icmp ult %union.Node* %54, %10
  br i1 %55, label %17, label %56

; <label>:56:                                     ; preds = %52, %2
  %57 = phi i32 [ %14, %2 ], [ %53, %52 ]
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %59 = load i8, i8* %58, align 1, !tbaa !62
  %60 = icmp eq i8 %59, 2
  %61 = icmp ne i32 %57, 0
  %62 = and i1 %61, %60
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 25
  %65 = select i1 %62, %struct.GCObject** %64, %struct.GCObject** %63
  %66 = select i1 %62, %struct.GCObject** %64, %struct.GCObject** %63
  %67 = bitcast %struct.GCObject** %65 to i64*
  %68 = load i64, i64* %67, align 8, !tbaa !79
  %69 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %70 = bitcast %struct.GCObject** %69 to i64*
  store i64 %68, i64* %70, align 8, !tbaa !223
  %71 = bitcast %struct.GCObject** %66 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %71, align 8, !tbaa !79
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @traverseephemeron(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !124
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds %union.Node, %union.Node* %4, i64 %9
  %11 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %36, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %15 = zext i32 %11 to i64
  br label %16

; <label>:16:                                     ; preds = %32, %13
  %17 = phi i64 [ 0, %13 ], [ %34, %32 ]
  %18 = phi i32 [ 0, %13 ], [ %33, %32 ]
  %19 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !115
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %17, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %32, label %24

; <label>:24:                                     ; preds = %16
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %17, i32 0, i32 0
  %26 = load %struct.GCObject*, %struct.GCObject** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !53
  %29 = and i8 %28, 24
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %32, label %31

; <label>:31:                                     ; preds = %24
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %26)
  br label %32

; <label>:32:                                     ; preds = %24, %16, %31
  %33 = phi i32 [ 1, %31 ], [ %18, %24 ], [ %18, %16 ]
  %34 = add nuw nsw i64 %17, 1
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %16

; <label>:36:                                     ; preds = %32, %2
  %37 = phi i32 [ 0, %2 ], [ %33, %32 ]
  %38 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %39 = icmp ult %union.Node* %38, %10
  br i1 %39, label %40, label %90

; <label>:40:                                     ; preds = %36
  br label %41

; <label>:41:                                     ; preds = %40, %84
  %42 = phi i32 [ %87, %84 ], [ %37, %40 ]
  %43 = phi i32 [ %86, %84 ], [ 0, %40 ]
  %44 = phi %union.Node* [ %88, %84 ], [ %38, %40 ]
  %45 = phi i32 [ %85, %84 ], [ 0, %40 ]
  %46 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !21
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %50, label %51

; <label>:50:                                     ; preds = %41
  tail call fastcc void @clearkey(%union.Node* nonnull %44)
  br label %84

; <label>:51:                                     ; preds = %41
  %52 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !21
  %54 = and i8 %53, 64
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %59, label %56

; <label>:56:                                     ; preds = %51
  %57 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 4, i32 0
  %58 = load %struct.GCObject*, %struct.GCObject** %57, align 8, !tbaa !21
  br label %59

; <label>:59:                                     ; preds = %51, %56
  %60 = phi %struct.GCObject* [ %58, %56 ], [ null, %51 ]
  %61 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %60)
  %62 = icmp eq i32 %61, 0
  %63 = load i8, i8* %46, align 8, !tbaa !21
  %64 = and i8 %63, 64
  %65 = icmp eq i8 %64, 0
  br i1 %62, label %75, label %66

; <label>:66:                                     ; preds = %59
  br i1 %65, label %84, label %67

; <label>:67:                                     ; preds = %66
  %68 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 0, i32 0
  %69 = load %struct.GCObject*, %struct.GCObject** %68, align 8, !tbaa !21
  %70 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %69, i64 0, i32 2
  %71 = load i8, i8* %70, align 1, !tbaa !53
  %72 = and i8 %71, 24
  %73 = icmp eq i8 %72, 0
  %74 = select i1 %73, i32 %45, i32 1
  br label %84

; <label>:75:                                     ; preds = %59
  br i1 %65, label %84, label %76

; <label>:76:                                     ; preds = %75
  %77 = getelementptr inbounds %union.Node, %union.Node* %44, i64 0, i32 0, i32 0, i32 0
  %78 = load %struct.GCObject*, %struct.GCObject** %77, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %78, i64 0, i32 2
  %80 = load i8, i8* %79, align 1, !tbaa !53
  %81 = and i8 %80, 24
  %82 = icmp eq i8 %81, 0
  br i1 %82, label %84, label %83

; <label>:83:                                     ; preds = %76
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %78)
  br label %84

; <label>:84:                                     ; preds = %67, %66, %76, %75, %50, %83
  %85 = phi i32 [ %45, %50 ], [ %45, %66 ], [ %45, %83 ], [ %45, %76 ], [ %45, %75 ], [ %74, %67 ]
  %86 = phi i32 [ %43, %50 ], [ 1, %66 ], [ %43, %83 ], [ %43, %76 ], [ %43, %75 ], [ 1, %67 ]
  %87 = phi i32 [ %42, %50 ], [ %42, %66 ], [ 1, %83 ], [ %42, %76 ], [ %42, %75 ], [ %42, %67 ]
  %88 = getelementptr inbounds %union.Node, %union.Node* %44, i64 1
  %89 = icmp ult %union.Node* %88, %10
  br i1 %89, label %41, label %90

; <label>:90:                                     ; preds = %84, %36
  %91 = phi i32 [ 0, %36 ], [ %85, %84 ]
  %92 = phi i32 [ 0, %36 ], [ %86, %84 ]
  %93 = phi i32 [ %37, %36 ], [ %87, %84 ]
  %94 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %95 = load i8, i8* %94, align 1, !tbaa !62
  %96 = icmp eq i8 %95, 0
  br i1 %96, label %97, label %104

; <label>:97:                                     ; preds = %90
  %98 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %99 = bitcast %struct.GCObject** %98 to i64*
  %100 = load i64, i64* %99, align 8, !tbaa !126
  %101 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %102 = bitcast %struct.GCObject** %101 to i64*
  store i64 %100, i64* %102, align 8, !tbaa !223
  %103 = bitcast %struct.GCObject** %98 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %103, align 8, !tbaa !126
  br label %137

; <label>:104:                                    ; preds = %90
  %105 = icmp eq i32 %91, 0
  br i1 %105, label %113, label %106

; <label>:106:                                    ; preds = %104
  %107 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  %108 = bitcast %struct.GCObject** %107 to i64*
  %109 = load i64, i64* %108, align 8, !tbaa !220
  %110 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %111 = bitcast %struct.GCObject** %110 to i64*
  store i64 %109, i64* %111, align 8, !tbaa !223
  %112 = bitcast %struct.GCObject** %107 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %112, align 8, !tbaa !220
  br label %137

; <label>:113:                                    ; preds = %104
  %114 = icmp eq i32 %92, 0
  br i1 %114, label %122, label %115

; <label>:115:                                    ; preds = %113
  %116 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %117 = bitcast %struct.GCObject** %116 to i64*
  %118 = load i64, i64* %117, align 8, !tbaa !219
  %119 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %120 = bitcast %struct.GCObject** %119 to i64*
  store i64 %118, i64* %120, align 8, !tbaa !223
  %121 = bitcast %struct.GCObject** %116 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %121, align 8, !tbaa !219
  br label %137

; <label>:122:                                    ; preds = %113
  %123 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %124 = load i8, i8* %123, align 2, !tbaa !29
  %125 = icmp eq i8 %124, 1
  br i1 %125, label %126, label %133

; <label>:126:                                    ; preds = %122
  %127 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %128 = bitcast %struct.GCObject** %127 to i64*
  %129 = load i64, i64* %128, align 8, !tbaa !126
  %130 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %131 = bitcast %struct.GCObject** %130 to i64*
  store i64 %129, i64* %131, align 8, !tbaa !223
  %132 = bitcast %struct.GCObject** %127 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %132, align 8, !tbaa !126
  br label %137

; <label>:133:                                    ; preds = %122
  %134 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %135 = load i8, i8* %134, align 1, !tbaa !116
  %136 = or i8 %135, 32
  store i8 %136, i8* %134, align 1, !tbaa !116
  br label %137

; <label>:137:                                    ; preds = %106, %126, %133, %115, %97
  ret i32 %93
}

; Function Attrs: nounwind uwtable
define internal fastcc void @traversestrongtable(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !124
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds %union.Node, %union.Node* %4, i64 %9
  %11 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %34, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %15 = zext i32 %11 to i64
  br label %16

; <label>:16:                                     ; preds = %31, %13
  %17 = phi i64 [ 0, %13 ], [ %32, %31 ]
  %18 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !115
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 %17, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 64
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %31, label %23

; <label>:23:                                     ; preds = %16
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 %17, i32 0, i32 0
  %25 = load %struct.GCObject*, %struct.GCObject** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %25, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !53
  %28 = and i8 %27, 24
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %31, label %30

; <label>:30:                                     ; preds = %23
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %25)
  br label %31

; <label>:31:                                     ; preds = %23, %16, %30
  %32 = add nuw nsw i64 %17, 1
  %33 = icmp eq i64 %32, %15
  br i1 %33, label %34, label %16

; <label>:34:                                     ; preds = %31, %2
  %35 = load %union.Node*, %union.Node** %3, align 8, !tbaa !123
  %36 = icmp ult %union.Node* %35, %10
  br i1 %36, label %37, label %73

; <label>:37:                                     ; preds = %34
  br label %38

; <label>:38:                                     ; preds = %37, %70
  %39 = phi %union.Node* [ %71, %70 ], [ %35, %37 ]
  %40 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !21
  %42 = and i8 %41, 15
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %44, label %45

; <label>:44:                                     ; preds = %38
  tail call fastcc void @clearkey(%union.Node* nonnull %39)
  br label %70

; <label>:45:                                     ; preds = %38
  %46 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !21
  %48 = and i8 %47, 64
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %58, label %50

; <label>:50:                                     ; preds = %45
  %51 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 4, i32 0
  %52 = load %struct.GCObject*, %struct.GCObject** %51, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %52, i64 0, i32 2
  %54 = load i8, i8* %53, align 1, !tbaa !53
  %55 = and i8 %54, 24
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %58, label %57

; <label>:57:                                     ; preds = %50
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %52)
  br label %58

; <label>:58:                                     ; preds = %50, %45, %57
  %59 = load i8, i8* %40, align 8, !tbaa !21
  %60 = and i8 %59, 64
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %70, label %62

; <label>:62:                                     ; preds = %58
  %63 = getelementptr inbounds %union.Node, %union.Node* %39, i64 0, i32 0, i32 0, i32 0
  %64 = load %struct.GCObject*, %struct.GCObject** %63, align 8, !tbaa !21
  %65 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %64, i64 0, i32 2
  %66 = load i8, i8* %65, align 1, !tbaa !53
  %67 = and i8 %66, 24
  %68 = icmp eq i8 %67, 0
  br i1 %68, label %70, label %69

; <label>:69:                                     ; preds = %62
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %64)
  br label %70

; <label>:70:                                     ; preds = %62, %58, %44, %69
  %71 = getelementptr inbounds %union.Node, %union.Node* %39, i64 1
  %72 = icmp ult %union.Node* %71, %10
  br i1 %72, label %38, label %73

; <label>:73:                                     ; preds = %70, %34
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %75 = load i8, i8* %74, align 2, !tbaa !29
  %76 = icmp eq i8 %75, 1
  br i1 %76, label %77, label %87

; <label>:77:                                     ; preds = %73
  %78 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %79 = bitcast %struct.GCObject** %78 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !126
  %81 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %82 = bitcast %struct.GCObject** %81 to i64*
  store i64 %80, i64* %82, align 8, !tbaa !223
  %83 = bitcast %struct.GCObject** %78 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %83, align 8, !tbaa !126
  %84 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %85 = load i8, i8* %84, align 1, !tbaa !116
  %86 = and i8 %85, -33
  store i8 %86, i8* %84, align 1, !tbaa !116
  br label %87

; <label>:87:                                     ; preds = %77, %73
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @clearkey(%union.Node* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %union.Node, %union.Node* %0, i64 0, i32 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !21
  %4 = and i8 %3, 64
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %union.Node, %union.Node* %0, i64 0, i32 0, i32 4, i32 0
  %8 = load %struct.GCObject*, %struct.GCObject** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %8, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !53
  %11 = and i8 %10, 24
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %6
  store i8 5, i8* %2, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %7, align 8, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %6, %1, %13
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @iscleared(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  %3 = icmp eq %struct.GCObject* %1, null
  br i1 %3, label %17, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !205
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 4
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !53
  %11 = and i8 %10, 24
  br i1 %8, label %12, label %15

; <label>:12:                                     ; preds = %4
  %13 = icmp eq i8 %11, 0
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %12
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %1)
  br label %17

; <label>:15:                                     ; preds = %4
  %16 = zext i8 %11 to i32
  br label %17

; <label>:17:                                     ; preds = %14, %12, %2, %15
  %18 = phi i32 [ %16, %15 ], [ 0, %2 ], [ 0, %12 ], [ 0, %14 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_shrinkstack(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc i32 @stackinuse(%struct.lua_State* %0)
  %3 = sdiv i32 %2, 8
  %4 = add i32 %2, 10
  %5 = add i32 %4, %3
  %6 = icmp slt i32 %5, 1000000
  %7 = select i1 %6, i32 %5, i32 1000000
  %8 = icmp slt i32 %2, 999996
  br i1 %8, label %9, label %15

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %11 = load i32, i32* %10, align 4, !tbaa !37
  %12 = icmp slt i32 %7, %11
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %9
  %14 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %7, i32 0)
  br label %15

; <label>:15:                                     ; preds = %1, %9, %13
  tail call fastcc void @luaE_shrinkCI(%struct.lua_State* %0)
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @stackinuse(%struct.lua_State* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !79
  %6 = icmp eq %struct.CallInfo* %5, null
  br i1 %6, label %18, label %7

; <label>:7:                                      ; preds = %1
  br label %8

; <label>:8:                                      ; preds = %7, %8
  %9 = phi %struct.CallInfo* [ %16, %8 ], [ %5, %7 ]
  %10 = phi %union.StackValue* [ %14, %8 ], [ %3, %7 ]
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 1
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !49
  %13 = icmp ult %union.StackValue* %10, %12
  %14 = select i1 %13, %union.StackValue* %12, %union.StackValue* %10
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 2
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !79
  %17 = icmp eq %struct.CallInfo* %16, null
  br i1 %17, label %18, label %8

; <label>:18:                                     ; preds = %8, %1
  %19 = phi %union.StackValue* [ %3, %1 ], [ %14, %8 ]
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !34
  %23 = ptrtoint %union.StackValue* %19 to i64
  %24 = sub i64 %23, %22
  %25 = lshr exact i64 %24, 4
  %26 = trunc i64 %25 to i32
  %27 = add nsw i32 %26, 1
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaD_reallocstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !37
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !34
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 4
  %11 = sext i32 %1 to i64
  %12 = shl nsw i64 %11, 4
  %13 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %8, i64 %10, i64 %12)
  %14 = bitcast i8* %13 to %union.StackValue*
  %15 = icmp eq i8* %13, null
  br i1 %15, label %16, label %19, !prof !33

; <label>:16:                                     ; preds = %3
  %17 = icmp eq i32 %2, 0
  br i1 %17, label %34, label %18

; <label>:18:                                     ; preds = %16
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #17
  unreachable

; <label>:19:                                     ; preds = %3
  %20 = icmp slt i32 %5, %1
  br i1 %20, label %21, label %29

; <label>:21:                                     ; preds = %19
  %22 = sext i32 %5 to i64
  %23 = sext i32 %1 to i64
  br label %24

; <label>:24:                                     ; preds = %24, %21
  %25 = phi i64 [ %22, %21 ], [ %27, %24 ]
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %25, i32 0, i32 1
  store i8 0, i8* %26, align 8, !tbaa !21
  %27 = add nsw i64 %25, 1
  %28 = icmp eq i64 %27, %23
  br i1 %28, label %29, label %24

; <label>:29:                                     ; preds = %24, %19
  %30 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !34
  tail call fastcc void @correctstack(%struct.lua_State* %0, %union.StackValue* %30, %union.StackValue* %14)
  store i8* %13, i8** %7, align 8, !tbaa !34
  store i32 %1, i32* %4, align 4, !tbaa !37
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %11
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -5
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %32, %union.StackValue** %33, align 8, !tbaa !45
  br label %34

; <label>:34:                                     ; preds = %16, %29
  %35 = phi i32 [ 1, %29 ], [ 0, %16 ]
  ret i32 %35
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaE_shrinkCI(%struct.lua_State* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !35
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %5 = load i16, i16* %4, align 4, !tbaa !36
  %6 = zext i16 %5 to i32
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %8 = load i32, i32* %7, align 8, !tbaa !40
  %9 = sub i32 %8, %6
  store i32 %9, i32* %7, align 8, !tbaa !40
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 3
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !89
  %12 = icmp eq %struct.CallInfo* %11, null
  br i1 %12, label %30, label %13

; <label>:13:                                     ; preds = %1
  br label %14

; <label>:14:                                     ; preds = %13, %21
  %15 = phi %struct.CallInfo* [ %28, %21 ], [ %11, %13 ]
  %16 = phi %struct.CallInfo** [ %27, %21 ], [ %10, %13 ]
  %17 = phi %struct.CallInfo* [ %19, %21 ], [ %3, %13 ]
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 3
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !89
  %20 = icmp eq %struct.CallInfo* %19, null
  br i1 %20, label %30, label %21

; <label>:21:                                     ; preds = %14
  %22 = bitcast %struct.CallInfo** %16 to i8**
  %23 = load i8*, i8** %22, align 8, !tbaa !89
  tail call fastcc void @luaM_free_(%struct.lua_State* nonnull %0, i8* %23, i64 64)
  %24 = load i16, i16* %4, align 4, !tbaa !36
  %25 = add i16 %24, -1
  store i16 %25, i16* %4, align 4, !tbaa !36
  store %struct.CallInfo* %19, %struct.CallInfo** %16, align 8, !tbaa !89
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 2
  store %struct.CallInfo* %17, %struct.CallInfo** %26, align 8, !tbaa !78
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 3
  %28 = load %struct.CallInfo*, %struct.CallInfo** %27, align 8, !tbaa !89
  %29 = icmp eq %struct.CallInfo* %28, null
  br i1 %29, label %30, label %14

; <label>:30:                                     ; preds = %21, %14, %1
  %31 = load i16, i16* %4, align 4, !tbaa !36
  %32 = zext i16 %31 to i32
  %33 = load i32, i32* %7, align 8, !tbaa !40
  %34 = add i32 %33, %32
  store i32 %34, i32* %7, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaM_realloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %8 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !31
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !32
  %11 = tail call i8* %8(i8* %10, i8* %1, i64 %2, i64 %3) #7
  %12 = icmp eq i8* %11, null
  %13 = icmp ne i64 %3, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %20, !prof !33

; <label>:15:                                     ; preds = %4
  %16 = icmp ugt i64 %3, %2
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %15
  %18 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* %1, i64 %2, i64 %3)
  %19 = icmp eq i8* %18, null
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %17, %4
  %21 = phi i8* [ %18, %17 ], [ %11, %4 ]
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = sub i64 %3, %2
  %25 = add i64 %24, %23
  store i64 %25, i64* %22, align 8, !tbaa !11
  br label %26

; <label>:26:                                     ; preds = %15, %17, %20
  %27 = phi i8* [ %21, %20 ], [ null, %17 ], [ null, %15 ]
  ret i8* %27
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @correctstack(%struct.lua_State* nocapture, %union.StackValue*, %union.StackValue*) unnamed_addr #2 {
  %4 = icmp eq %union.StackValue* %1, %2
  br i1 %4, label %58, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !20
  %9 = ptrtoint %union.StackValue* %1 to i64
  %10 = sub i64 %8, %9
  %11 = ashr exact i64 %10, 4
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %11
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %14 = load %struct.UpVal*, %struct.UpVal** %13, align 8, !tbaa !21
  %15 = icmp eq %struct.UpVal* %14, null
  br i1 %15, label %28, label %16

; <label>:16:                                     ; preds = %5
  br label %17

; <label>:17:                                     ; preds = %16, %17
  %18 = phi %struct.UpVal* [ %26, %17 ], [ %14, %16 ]
  %19 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %18, i64 0, i32 3
  %20 = bitcast %struct.TValue** %19 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !50
  %22 = sub i64 %21, %9
  %23 = ashr exact i64 %22, 4
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %23, i32 0
  store %struct.TValue* %24, %struct.TValue** %19, align 8, !tbaa !50
  %25 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %18, i64 0, i32 4, i32 0, i32 0
  %26 = load %struct.UpVal*, %struct.UpVal** %25, align 8, !tbaa !21
  %27 = icmp eq %struct.UpVal* %26, null
  br i1 %27, label %28, label %17

; <label>:28:                                     ; preds = %17, %5
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %30 = load %struct.CallInfo*, %struct.CallInfo** %29, align 8, !tbaa !79
  %31 = icmp eq %struct.CallInfo* %30, null
  br i1 %31, label %58, label %32

; <label>:32:                                     ; preds = %28
  br label %33

; <label>:33:                                     ; preds = %32, %54
  %34 = phi %struct.CallInfo* [ %56, %54 ], [ %30, %32 ]
  %35 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 1
  %36 = bitcast %union.StackValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !49
  %38 = sub i64 %37, %9
  %39 = ashr exact i64 %38, 4
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %39
  store %union.StackValue* %40, %union.StackValue** %35, align 8, !tbaa !49
  %41 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 0
  %42 = bitcast %struct.CallInfo* %34 to i64*
  %43 = load i64, i64* %42, align 8, !tbaa !47
  %44 = sub i64 %43, %9
  %45 = ashr exact i64 %44, 4
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %45
  store %union.StackValue* %46, %union.StackValue** %41, align 8, !tbaa !47
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 7
  %48 = load i16, i16* %47, align 2, !tbaa !46
  %49 = and i16 %48, 2
  %50 = icmp eq i16 %49, 0
  br i1 %50, label %51, label %54

; <label>:51:                                     ; preds = %33
  %52 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 4, i32 0, i32 1
  %53 = bitcast i64* %52 to i32*
  store i32 1, i32* %53, align 8, !tbaa !21
  br label %54

; <label>:54:                                     ; preds = %33, %51
  %55 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 2
  %56 = load %struct.CallInfo*, %struct.CallInfo** %55, align 8, !tbaa !79
  %57 = icmp eq %struct.CallInfo* %56, null
  br i1 %57, label %58, label %33

; <label>:58:                                     ; preds = %54, %28, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.GCObject** @sweeplist(%struct.lua_State* nocapture readonly, %struct.GCObject**, i32, i32*) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 10
  %8 = load i8, i8* %7, align 4, !tbaa !15
  %9 = xor i8 %8, 24
  %10 = and i8 %8, 24
  %11 = load %struct.GCObject*, %struct.GCObject** %1, align 8, !tbaa !79
  %12 = icmp ne %struct.GCObject* %11, null
  %13 = icmp sgt i32 %2, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %39

; <label>:15:                                     ; preds = %4
  br label %16

; <label>:16:                                     ; preds = %15, %32
  %17 = phi %struct.GCObject* [ %35, %32 ], [ %11, %15 ]
  %18 = phi %struct.GCObject** [ %33, %32 ], [ %1, %15 ]
  %19 = phi i32 [ %34, %32 ], [ 0, %15 ]
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %17, i64 0, i32 2
  %21 = load i8, i8* %20, align 1, !tbaa !53
  %22 = and i8 %21, %9
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %16
  %25 = bitcast %struct.GCObject* %17 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !129
  %27 = bitcast %struct.GCObject** %18 to i64*
  store i64 %26, i64* %27, align 8, !tbaa !79
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %17)
  br label %32

; <label>:28:                                     ; preds = %16
  %29 = and i8 %21, -64
  %30 = or i8 %29, %10
  store i8 %30, i8* %20, align 1, !tbaa !53
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %17, i64 0, i32 0
  br label %32

; <label>:32:                                     ; preds = %28, %24
  %33 = phi %struct.GCObject** [ %18, %24 ], [ %31, %28 ]
  %34 = add nuw nsw i32 %19, 1
  %35 = load %struct.GCObject*, %struct.GCObject** %33, align 8, !tbaa !79
  %36 = icmp ne %struct.GCObject* %35, null
  %37 = icmp slt i32 %34, %2
  %38 = and i1 %37, %36
  br i1 %38, label %16, label %39

; <label>:39:                                     ; preds = %32, %4
  %40 = phi i32 [ 0, %4 ], [ %34, %32 ]
  %41 = phi %struct.GCObject** [ %1, %4 ], [ %33, %32 ]
  %42 = phi %struct.GCObject* [ %11, %4 ], [ %35, %32 ]
  %43 = icmp eq i32* %3, null
  br i1 %43, label %45, label %44

; <label>:44:                                     ; preds = %39
  store i32 %40, i32* %3, align 4, !tbaa !70
  br label %45

; <label>:45:                                     ; preds = %39, %44
  %46 = icmp eq %struct.GCObject* %42, null
  %47 = select i1 %46, %struct.GCObject** null, %struct.GCObject** %41
  ret %struct.GCObject** %47
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaS_resize(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 2
  %7 = load i32, i32* %6, align 4, !tbaa !198
  %8 = icmp sgt i32 %7, %1
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %5, i64 0, i32 0
  %11 = load %struct.TString**, %struct.TString*** %10, align 8, !tbaa !197
  tail call fastcc void @tablerehash(%struct.TString** %11, i32 %7, i32 %1)
  br label %12

; <label>:12:                                     ; preds = %9, %2
  %13 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %5, i64 0, i32 0
  %14 = bitcast %struct.stringtable* %5 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !197
  %16 = sext i32 %7 to i64
  %17 = shl nsw i64 %16, 3
  %18 = sext i32 %1 to i64
  %19 = shl nsw i64 %18, 3
  %20 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* nonnull %0, i8* %15, i64 %17, i64 %19)
  %21 = bitcast i8* %20 to %struct.TString**
  %22 = icmp eq i8* %20, null
  br i1 %22, label %23, label %26, !prof !33

; <label>:23:                                     ; preds = %12
  br i1 %8, label %24, label %29

; <label>:24:                                     ; preds = %23
  %25 = load %struct.TString**, %struct.TString*** %13, align 8, !tbaa !197
  tail call fastcc void @tablerehash(%struct.TString** %25, i32 %1, i32 %7)
  br label %29

; <label>:26:                                     ; preds = %12
  store i8* %20, i8** %14, align 8, !tbaa !197
  store i32 %1, i32* %6, align 4, !tbaa !198
  %27 = icmp slt i32 %7, %1
  br i1 %27, label %28, label %29

; <label>:28:                                     ; preds = %26
  tail call fastcc void @tablerehash(%struct.TString** %21, i32 %7, i32 %1)
  br label %29

; <label>:29:                                     ; preds = %26, %28, %23, %24
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @propagateall(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !217
  %4 = icmp eq %struct.GCObject* %3, null
  br i1 %4, label %12, label %5

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %5, %6
  %7 = phi i64 [ %9, %6 ], [ 0, %5 ]
  %8 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %0)
  %9 = add i64 %8, %7
  %10 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !217
  %11 = icmp eq %struct.GCObject* %10, null
  br i1 %11, label %12, label %6

; <label>:12:                                     ; preds = %6, %1
  %13 = phi i64 [ 0, %1 ], [ %9, %6 ]
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @remarkupvals(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 36
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !79
  %4 = icmp eq %struct.lua_State* %3, null
  br i1 %4, label %62, label %5

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %5, %57
  %7 = phi %struct.lua_State* [ %60, %57 ], [ %3, %5 ]
  %8 = phi i32 [ %59, %57 ], [ 0, %5 ]
  %9 = phi %struct.lua_State** [ %58, %57 ], [ %2, %5 ]
  %10 = add nsw i32 %8, 1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 2
  %12 = load i8, i8* %11, align 1, !tbaa !16
  %13 = and i8 %12, 56
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %6
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 12
  %17 = load %struct.UpVal*, %struct.UpVal** %16, align 8, !tbaa !42
  %18 = icmp eq %struct.UpVal* %17, null
  br i1 %18, label %21, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 14
  br label %57

; <label>:21:                                     ; preds = %15, %6
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 14
  %23 = bitcast %struct.lua_State** %22 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !38
  %25 = bitcast %struct.lua_State** %9 to i64*
  store i64 %24, i64* %25, align 8, !tbaa !79
  store %struct.lua_State* %7, %struct.lua_State** %22, align 8, !tbaa !38
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %7, i64 0, i32 12
  %27 = load %struct.UpVal*, %struct.UpVal** %26, align 8, !tbaa !21
  %28 = icmp eq %struct.UpVal* %27, null
  br i1 %28, label %57, label %29

; <label>:29:                                     ; preds = %21
  br label %30

; <label>:30:                                     ; preds = %29, %53
  %31 = phi %struct.UpVal* [ %55, %53 ], [ %27, %29 ]
  %32 = phi i32 [ %33, %53 ], [ %10, %29 ]
  %33 = add nsw i32 %32, 1
  %34 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %31, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !52
  %36 = and i8 %35, 24
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %53

; <label>:38:                                     ; preds = %30
  %39 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %31, i64 0, i32 3
  %40 = load %struct.TValue*, %struct.TValue** %39, align 8, !tbaa !50
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  %42 = load i8, i8* %41, align 8, !tbaa !22
  %43 = and i8 %42, 64
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %53, label %45

; <label>:45:                                     ; preds = %38
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 0, i32 0
  %47 = load %struct.GCObject*, %struct.GCObject** %46, align 8, !tbaa !21
  %48 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %47, i64 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !53
  %50 = and i8 %49, 24
  %51 = icmp eq i8 %50, 0
  br i1 %51, label %53, label %52

; <label>:52:                                     ; preds = %45
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %47)
  br label %53

; <label>:53:                                     ; preds = %45, %38, %30, %52
  %54 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %31, i64 0, i32 4, i32 0, i32 0
  %55 = load %struct.UpVal*, %struct.UpVal** %54, align 8, !tbaa !21
  %56 = icmp eq %struct.UpVal* %55, null
  br i1 %56, label %57, label %30

; <label>:57:                                     ; preds = %53, %21, %19
  %58 = phi %struct.lua_State** [ %20, %19 ], [ %9, %21 ], [ %9, %53 ]
  %59 = phi i32 [ %10, %19 ], [ %10, %21 ], [ %33, %53 ]
  %60 = load %struct.lua_State*, %struct.lua_State** %58, align 8, !tbaa !79
  %61 = icmp eq %struct.lua_State* %60, null
  br i1 %61, label %62, label %6

; <label>:62:                                     ; preds = %57, %1
  %63 = phi i32 [ 0, %1 ], [ %59, %57 ]
  ret i32 %63
}

; Function Attrs: nounwind uwtable
define internal fastcc void @convergeephemerons(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  br label %3

; <label>:3:                                      ; preds = %20, %1
  %4 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !220
  store %struct.GCObject* null, %struct.GCObject** %2, align 8, !tbaa !220
  %5 = icmp eq %struct.GCObject* %4, null
  br i1 %5, label %22, label %6

; <label>:6:                                      ; preds = %3
  br label %7

; <label>:7:                                      ; preds = %6, %17
  %8 = phi %struct.GCObject* [ %12, %17 ], [ %4, %6 ]
  %9 = phi i32 [ %18, %17 ], [ 0, %6 ]
  %10 = bitcast %struct.GCObject* %8 to %struct.Table*
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %8, i64 3, i32 0
  %12 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !21
  %13 = tail call fastcc i32 @traverseephemeron(%struct.global_State* %0, %struct.Table* %10)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %7
  %16 = tail call fastcc i64 @propagateall(%struct.global_State* %0)
  br label %17

; <label>:17:                                     ; preds = %7, %15
  %18 = phi i32 [ 1, %15 ], [ %9, %7 ]
  %19 = icmp eq %struct.GCObject* %12, null
  br i1 %19, label %20, label %7

; <label>:20:                                     ; preds = %17
  %21 = icmp eq i32 %18, 0
  br i1 %21, label %22, label %3

; <label>:22:                                     ; preds = %3, %20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @clearbyvalues(%struct.global_State*, %struct.GCObject* readonly, %struct.GCObject* readnone) unnamed_addr #0 {
  %4 = icmp eq %struct.GCObject* %1, %2
  br i1 %4, label %72, label %5

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %68
  %7 = phi %struct.GCObject* [ %70, %68 ], [ %1, %5 ]
  %8 = bitcast %struct.GCObject* %7 to %struct.Table*
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %10 = bitcast i8* %9 to %union.Node**
  %11 = load %union.Node*, %union.Node** %10, align 8, !tbaa !123
  %12 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 4
  %13 = load i8, i8* %12, align 1, !tbaa !124
  %14 = zext i8 %13 to i32
  %15 = shl i32 1, %14
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %11, i64 %16
  %18 = tail call fastcc i32 @luaH_realasize(%struct.Table* %8)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %42, label %20

; <label>:20:                                     ; preds = %6
  %21 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1
  %22 = bitcast %struct.GCObject* %21 to %struct.TValue**
  %23 = zext i32 %18 to i64
  br label %24

; <label>:24:                                     ; preds = %39, %20
  %25 = phi i64 [ 0, %20 ], [ %40, %39 ]
  %26 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !115
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 %25, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = and i8 %28, 64
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %24
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 %25, i32 0, i32 0
  %33 = load %struct.GCObject*, %struct.GCObject** %32, align 8, !tbaa !21
  br label %34

; <label>:34:                                     ; preds = %24, %31
  %35 = phi %struct.GCObject* [ %33, %31 ], [ null, %24 ]
  %36 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %35)
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %39, label %38

; <label>:38:                                     ; preds = %34
  store i8 16, i8* %27, align 8, !tbaa !22
  br label %39

; <label>:39:                                     ; preds = %34, %38
  %40 = add nuw nsw i64 %25, 1
  %41 = icmp eq i64 %40, %23
  br i1 %41, label %42, label %24

; <label>:42:                                     ; preds = %39, %6
  %43 = load %union.Node*, %union.Node** %10, align 8, !tbaa !123
  %44 = icmp ult %union.Node* %43, %17
  br i1 %44, label %45, label %68

; <label>:45:                                     ; preds = %42
  br label %46

; <label>:46:                                     ; preds = %45, %65
  %47 = phi %union.Node* [ %66, %65 ], [ %43, %45 ]
  %48 = getelementptr inbounds %union.Node, %union.Node* %47, i64 0, i32 0, i32 1
  %49 = load i8, i8* %48, align 8, !tbaa !21
  %50 = and i8 %49, 64
  %51 = icmp eq i8 %50, 0
  br i1 %51, label %55, label %52

; <label>:52:                                     ; preds = %46
  %53 = getelementptr inbounds %union.Node, %union.Node* %47, i64 0, i32 0, i32 0, i32 0
  %54 = load %struct.GCObject*, %struct.GCObject** %53, align 8, !tbaa !21
  br label %55

; <label>:55:                                     ; preds = %46, %52
  %56 = phi %struct.GCObject* [ %54, %52 ], [ null, %46 ]
  %57 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %56)
  %58 = icmp eq i32 %57, 0
  br i1 %58, label %60, label %59

; <label>:59:                                     ; preds = %55
  store i8 16, i8* %48, align 8, !tbaa !21
  br label %60

; <label>:60:                                     ; preds = %55, %59
  %61 = load i8, i8* %48, align 8, !tbaa !21
  %62 = and i8 %61, 15
  %63 = icmp eq i8 %62, 0
  br i1 %63, label %64, label %65

; <label>:64:                                     ; preds = %60
  tail call fastcc void @clearkey(%union.Node* nonnull %47)
  br label %65

; <label>:65:                                     ; preds = %60, %64
  %66 = getelementptr inbounds %union.Node, %union.Node* %47, i64 1
  %67 = icmp ult %union.Node* %66, %17
  br i1 %67, label %46, label %68

; <label>:68:                                     ; preds = %65, %42
  %69 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 3, i32 0
  %70 = load %struct.GCObject*, %struct.GCObject** %69, align 8, !tbaa !21
  %71 = icmp eq %struct.GCObject* %70, %2
  br i1 %71, label %72, label %6

; <label>:72:                                     ; preds = %68, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @clearbykeys(%struct.global_State*, %struct.GCObject* readonly) unnamed_addr #0 {
  %3 = icmp eq %struct.GCObject* %1, null
  br i1 %3, label %47, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %43
  %6 = phi %struct.GCObject* [ %45, %43 ], [ %1, %4 ]
  %7 = bitcast %struct.GCObject* %6 to %struct.Table*
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %9 = bitcast i8* %8 to %union.Node**
  %10 = load %union.Node*, %union.Node** %9, align 8, !tbaa !123
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %7, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !124
  %13 = zext i8 %12 to i32
  %14 = shl i32 1, %13
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds %union.Node, %union.Node* %10, i64 %15
  %17 = icmp eq i8 %12, 31
  br i1 %17, label %43, label %18

; <label>:18:                                     ; preds = %5
  br label %19

; <label>:19:                                     ; preds = %18, %40
  %20 = phi %union.Node* [ %41, %40 ], [ %10, %18 ]
  %21 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 2
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = and i8 %22, 64
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 4, i32 0
  %27 = load %struct.GCObject*, %struct.GCObject** %26, align 8, !tbaa !21
  br label %28

; <label>:28:                                     ; preds = %19, %25
  %29 = phi %struct.GCObject* [ %27, %25 ], [ null, %19 ]
  %30 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %29)
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %34, label %32

; <label>:32:                                     ; preds = %28
  %33 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 1
  store i8 16, i8* %33, align 8, !tbaa !21
  br label %34

; <label>:34:                                     ; preds = %28, %32
  %35 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !21
  %37 = and i8 %36, 15
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %39, label %40

; <label>:39:                                     ; preds = %34
  tail call fastcc void @clearkey(%union.Node* nonnull %20)
  br label %40

; <label>:40:                                     ; preds = %34, %39
  %41 = getelementptr inbounds %union.Node, %union.Node* %20, i64 1
  %42 = icmp ult %union.Node* %41, %16
  br i1 %42, label %19, label %43

; <label>:43:                                     ; preds = %40, %5
  %44 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 3, i32 0
  %45 = load %struct.GCObject*, %struct.GCObject** %44, align 8, !tbaa !21
  %46 = icmp eq %struct.GCObject* %45, null
  br i1 %46, label %47, label %5

; <label>:47:                                     ; preds = %43, %2
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaS_clearcache(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 39
  %3 = bitcast %struct.TString** %2 to i64*
  br label %4

; <label>:4:                                      ; preds = %20, %1
  %5 = phi i64 [ 0, %1 ], [ %21, %20 ]
  br label %6

; <label>:6:                                      ; preds = %17, %4
  %7 = phi i64 [ 0, %4 ], [ %18, %17 ]
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 42, i64 %5, i64 %7
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !79
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !227
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %6
  %15 = load i64, i64* %3, align 8, !tbaa !56
  %16 = bitcast %struct.TString** %8 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !79
  br label %17

; <label>:17:                                     ; preds = %6, %14
  %18 = add nuw nsw i64 %7, 1
  %19 = icmp eq i64 %18, 2
  br i1 %19, label %20, label %6

; <label>:20:                                     ; preds = %17
  %21 = add nuw nsw i64 %5, 1
  %22 = icmp eq i64 %21, 53
  br i1 %22, label %23, label %4

; <label>:23:                                     ; preds = %20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @sweep2old(%struct.lua_State*, %struct.GCObject** nocapture) unnamed_addr #0 {
  %3 = load %struct.GCObject*, %struct.GCObject** %1, align 8, !tbaa !79
  %4 = icmp eq %struct.GCObject* %3, null
  br i1 %4, label %25, label %5

; <label>:5:                                      ; preds = %2
  br label %6

; <label>:6:                                      ; preds = %5, %21
  %7 = phi %struct.GCObject* [ %23, %21 ], [ %3, %5 ]
  %8 = phi %struct.GCObject** [ %22, %21 ], [ %1, %5 ]
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !53
  %11 = and i8 %10, 24
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %6
  %14 = bitcast %struct.GCObject* %7 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !129
  %16 = bitcast %struct.GCObject** %8 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !79
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %7)
  br label %21

; <label>:17:                                     ; preds = %6
  %18 = and i8 %10, -8
  %19 = or i8 %18, 4
  store i8 %19, i8* %9, align 1, !tbaa !53
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  br label %21

; <label>:21:                                     ; preds = %17, %13
  %22 = phi %struct.GCObject** [ %8, %13 ], [ %20, %17 ]
  %23 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !79
  %24 = icmp eq %struct.GCObject* %23, null
  br i1 %24, label %25, label %6

; <label>:25:                                     ; preds = %21, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @finishgencycle(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  tail call fastcc void @correctgraylists(%struct.global_State* %1)
  tail call fastcc void @checkSizes(%struct.lua_State* %0, %struct.global_State* %1)
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 0, i8* %3, align 1, !tbaa !62
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %5 = load i8, i8* %4, align 2, !tbaa !63
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %2
  tail call fastcc void @callallpendingfinalizers(%struct.lua_State* %0)
  br label %8

; <label>:8:                                      ; preds = %2, %7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @correctgraylists(%struct.global_State*) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %3 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** nonnull %2)
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 25
  %5 = bitcast %struct.GCObject** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !218
  %7 = bitcast %struct.GCObject** %3 to i64*
  store i64 %6, i64* %7, align 8, !tbaa !79
  store %struct.GCObject* null, %struct.GCObject** %4, align 8, !tbaa !218
  %8 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %3)
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %10 = bitcast %struct.GCObject** %9 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !219
  %12 = bitcast %struct.GCObject** %8 to i64*
  store i64 %11, i64* %12, align 8, !tbaa !79
  store %struct.GCObject* null, %struct.GCObject** %9, align 8, !tbaa !219
  %13 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %8)
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  %15 = bitcast %struct.GCObject** %14 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !220
  %17 = bitcast %struct.GCObject** %13 to i64*
  store i64 %16, i64* %17, align 8, !tbaa !79
  store %struct.GCObject* null, %struct.GCObject** %14, align 8, !tbaa !220
  %18 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %13)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %struct.GCObject** @correctgraylist(%struct.GCObject**) unnamed_addr #2 {
  %2 = load %struct.GCObject*, %struct.GCObject** %0, align 8, !tbaa !79
  %3 = icmp eq %struct.GCObject* %2, null
  br i1 %3, label %55, label %4

; <label>:4:                                      ; preds = %1
  br label %5

; <label>:5:                                      ; preds = %4, %51
  %6 = phi %struct.GCObject* [ %52, %51 ], [ %2, %4 ]
  %7 = phi %struct.GCObject** [ %53, %51 ], [ %0, %4 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !205
  switch i8 %9, label %48 [
    i8 5, label %10
    i8 7, label %10
    i8 8, label %35
  ]

; <label>:10:                                     ; preds = %5, %5
  %11 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %6)
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 2
  %13 = load i8, i8* %12, align 1, !tbaa !53
  %14 = zext i8 %13 to i32
  %15 = and i32 %14, 7
  %16 = icmp eq i32 %15, 5
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %10
  %18 = or i8 %13, 32
  %19 = xor i8 %18, 3
  store i8 %19, i8* %12, align 1, !tbaa !53
  br label %48

; <label>:20:                                     ; preds = %10
  %21 = and i32 %14, 24
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %30

; <label>:23:                                     ; preds = %20
  %24 = icmp eq i32 %15, 6
  br i1 %24, label %25, label %27

; <label>:25:                                     ; preds = %23
  %26 = xor i8 %13, 2
  store i8 %26, i8* %12, align 1, !tbaa !53
  br label %27

; <label>:27:                                     ; preds = %25, %23
  %28 = load i8, i8* %12, align 1, !tbaa !53
  %29 = or i8 %28, 32
  store i8 %29, i8* %12, align 1, !tbaa !53
  br label %30

; <label>:30:                                     ; preds = %20, %27
  %31 = bitcast %struct.GCObject** %11 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !79
  %33 = bitcast %struct.GCObject** %7 to i64*
  store i64 %32, i64* %33, align 8, !tbaa !79
  %34 = inttoptr i64 %32 to %struct.GCObject*
  br label %51

; <label>:35:                                     ; preds = %5
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 2
  %37 = load i8, i8* %36, align 1, !tbaa !16
  %38 = and i8 %37, 24
  %39 = icmp eq i8 %38, 0
  %40 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 4, i32 1
  br i1 %39, label %46, label %41

; <label>:41:                                     ; preds = %35
  %42 = bitcast i8* %40 to i64*
  %43 = load i64, i64* %42, align 8, !tbaa !221
  %44 = bitcast %struct.GCObject** %7 to i64*
  store i64 %43, i64* %44, align 8, !tbaa !79
  %45 = inttoptr i64 %43 to %struct.GCObject*
  br label %51

; <label>:46:                                     ; preds = %35
  %47 = bitcast i8* %40 to %struct.GCObject**
  br label %48

; <label>:48:                                     ; preds = %5, %17, %46
  %49 = phi %struct.GCObject** [ %47, %46 ], [ %11, %17 ], [ %7, %5 ]
  %50 = load %struct.GCObject*, %struct.GCObject** %49, align 8, !tbaa !79
  br label %51

; <label>:51:                                     ; preds = %48, %41, %30
  %52 = phi %struct.GCObject* [ %50, %48 ], [ %45, %41 ], [ %34, %30 ]
  %53 = phi %struct.GCObject** [ %49, %48 ], [ %7, %41 ], [ %7, %30 ]
  %54 = icmp eq %struct.GCObject* %52, null
  br i1 %54, label %55, label %5

; <label>:55:                                     ; preds = %51, %1
  %56 = phi %struct.GCObject** [ %0, %1 ], [ %53, %51 ]
  ret %struct.GCObject** %56
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.GCObject** @sweeptolive(%struct.lua_State* nocapture readonly, %struct.GCObject**) unnamed_addr #0 {
  br label %3

; <label>:3:                                      ; preds = %3, %2
  %4 = phi %struct.GCObject** [ %1, %2 ], [ %5, %3 ]
  %5 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** %4, i32 1, i32* null)
  %6 = icmp eq %struct.GCObject** %5, %1
  br i1 %6, label %3, label %7

; <label>:7:                                      ; preds = %3
  ret %struct.GCObject** %5
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @entergen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 256)
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 1)
  %3 = tail call fastcc i64 @atomic(%struct.lua_State* %0)
  tail call fastcc void @atomic2gen(%struct.lua_State* %0, %struct.global_State* %1)
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @markold(%struct.global_State*, %struct.GCObject*, %struct.GCObject* readnone) unnamed_addr #0 {
  %4 = icmp eq %struct.GCObject* %1, %2
  br i1 %4, label %18, label %5

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %14
  %7 = phi %struct.GCObject* [ %16, %14 ], [ %1, %5 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !53
  %10 = and i8 %9, 39
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %6
  %13 = and i8 %9, -33
  store i8 %13, i8* %8, align 1, !tbaa !53
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %7)
  br label %14

; <label>:14:                                     ; preds = %6, %12
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !129
  %17 = icmp eq %struct.GCObject* %16, %2
  br i1 %17, label %18, label %6

; <label>:18:                                     ; preds = %14, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.GCObject** @sweepgen(%struct.lua_State*, %struct.global_State* nocapture readonly, %struct.GCObject**, %struct.GCObject* readnone) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 10
  %6 = load i8, i8* %5, align 4, !tbaa !15
  %7 = and i8 %6, 24
  %8 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !79
  %9 = icmp eq %struct.GCObject* %8, %3
  br i1 %9, label %42, label %10

; <label>:10:                                     ; preds = %4
  br label %11

; <label>:11:                                     ; preds = %10, %38
  %12 = phi %struct.GCObject* [ %40, %38 ], [ %8, %10 ]
  %13 = phi %struct.GCObject** [ %39, %38 ], [ %2, %10 ]
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 2
  %15 = load i8, i8* %14, align 1, !tbaa !53
  %16 = zext i8 %15 to i32
  %17 = and i32 %16, 24
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %11
  %20 = bitcast %struct.GCObject* %12 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !129
  %22 = bitcast %struct.GCObject** %13 to i64*
  store i64 %21, i64* %22, align 8, !tbaa !79
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %12)
  br label %38

; <label>:23:                                     ; preds = %11
  %24 = and i32 %16, 7
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %23
  %27 = and i8 %15, -57
  %28 = or i8 %27, %7
  store i8 %28, i8* %14, align 1, !tbaa !53
  br label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = load i8, i8* %14, align 1, !tbaa !53
  %31 = and i8 %30, -8
  %32 = and i8 %30, 7
  %33 = zext i8 %32 to i64
  %34 = getelementptr inbounds [7 x i8], [7 x i8]* @sweepgen.nextage, i64 0, i64 %33
  %35 = load i8, i8* %34, align 1, !tbaa !21
  %36 = or i8 %31, %35
  store i8 %36, i8* %14, align 1, !tbaa !53
  %37 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 0
  br label %38

; <label>:38:                                     ; preds = %29, %19
  %39 = phi %struct.GCObject** [ %13, %19 ], [ %37, %29 ]
  %40 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !79
  %41 = icmp eq %struct.GCObject* %40, %3
  br i1 %41, label %42, label %11

; <label>:42:                                     ; preds = %38, %4
  %43 = phi %struct.GCObject** [ %2, %4 ], [ %39, %38 ]
  ret %struct.GCObject** %43
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @findvararg(%struct.CallInfo* nocapture readonly, i32, %union.StackValue** nocapture) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !47
  %6 = bitcast %union.StackValue* %5 to %struct.LClosure**
  %7 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 5
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !94
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %26, label %13

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 4
  %15 = bitcast %union.anon.0* %14 to %struct.anon*
  %16 = getelementptr inbounds %struct.anon, %struct.anon* %15, i64 0, i32 2
  %17 = load i32, i32* %16, align 4, !tbaa !21
  %18 = icmp slt i32 %17, %1
  br i1 %18, label %26, label %19

; <label>:19:                                     ; preds = %13
  %20 = sext i32 %17 to i64
  %21 = sub nsw i64 0, %20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 %21
  %23 = add nsw i32 %1, -1
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 %24
  store %union.StackValue* %25, %union.StackValue** %2, align 8, !tbaa !79
  br label %26

; <label>:26:                                     ; preds = %3, %13, %19
  %27 = phi i8* [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.144, i64 0, i64 0), %19 ], [ null, %13 ], [ null, %3 ]
  ret i8* %27
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @currentpc(%struct.CallInfo* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 4
  %3 = bitcast %union.anon.0* %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !21
  %5 = bitcast %struct.CallInfo* %0 to %struct.LClosure***
  %6 = load %struct.LClosure**, %struct.LClosure*** %5, align 8, !tbaa !47
  %7 = load %struct.LClosure*, %struct.LClosure** %6, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 5
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = bitcast i32** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !134
  %13 = sub i64 %4, %12
  %14 = lshr exact i64 %13, 2
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, -1
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal fastcc void @funcinfo(%struct.lua_Debug* nocapture, %union.Closure* readonly) unnamed_addr #0 {
  %3 = icmp eq %union.Closure* %1, null
  br i1 %3, label %8, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %union.Closure, %union.Closure* %1, i64 0, i32 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !21
  %7 = icmp eq i8 %6, 54
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %4, %2
  %9 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 4
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.145, i64 0, i64 0), i8** %9, align 8, !tbaa !229
  %10 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 5
  store i64 4, i64* %10, align 8, !tbaa !230
  %11 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 7
  store i32 -1, i32* %11, align 4, !tbaa !179
  %12 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 8
  store i32 -1, i32* %12, align 8, !tbaa !231
  br label %47

; <label>:13:                                     ; preds = %4
  %14 = getelementptr inbounds %union.Closure, %union.Closure* %1, i64 0, i32 0, i32 5
  %15 = bitcast i32 (%struct.lua_State*)** %14 to %struct.Proto**
  %16 = load %struct.Proto*, %struct.Proto** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 22
  %18 = load %struct.TString*, %struct.TString** %17, align 8, !tbaa !104
  %19 = icmp eq %struct.TString* %18, null
  br i1 %19, label %34, label %20

; <label>:20:                                     ; preds = %13
  %21 = getelementptr inbounds %struct.TString, %struct.TString* %18, i64 1
  %22 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 4
  %23 = bitcast i8** %22 to %struct.TString**
  store %struct.TString* %21, %struct.TString** %23, align 8, !tbaa !229
  %24 = getelementptr inbounds %struct.TString, %struct.TString* %18, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !57
  %26 = icmp eq i8 %25, 20
  br i1 %26, label %27, label %31

; <label>:27:                                     ; preds = %20
  %28 = getelementptr inbounds %struct.TString, %struct.TString* %18, i64 0, i32 4
  %29 = load i8, i8* %28, align 1, !tbaa !232
  %30 = zext i8 %29 to i64
  br label %36

; <label>:31:                                     ; preds = %20
  %32 = getelementptr inbounds %struct.TString, %struct.TString* %18, i64 0, i32 6, i32 0
  %33 = load i64, i64* %32, align 8, !tbaa !21
  br label %36

; <label>:34:                                     ; preds = %13
  %35 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 4
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.147, i64 0, i64 0), i8** %35, align 8, !tbaa !229
  br label %36

; <label>:36:                                     ; preds = %27, %31, %34
  %37 = phi i64 [ 2, %34 ], [ %30, %27 ], [ %33, %31 ]
  %38 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 5
  store i64 %37, i64* %38, align 8, !tbaa !230
  %39 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 13
  %40 = load i32, i32* %39, align 4, !tbaa !101
  %41 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 7
  store i32 %40, i32* %41, align 4, !tbaa !179
  %42 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 14
  %43 = load i32, i32* %42, align 8, !tbaa !233
  %44 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 8
  store i32 %43, i32* %44, align 8, !tbaa !231
  %45 = icmp eq i32 %40, 0
  %46 = select i1 %45, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.148, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.149, i64 0, i64 0)
  br label %47

; <label>:47:                                     ; preds = %36, %8
  %48 = phi i8* [ %46, %36 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.146, i64 0, i64 0), %8 ]
  %49 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 3
  store i8* %48, i8** %49, align 8, !tbaa !178
  %50 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 15, i64 0
  %51 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 4
  %52 = load i8*, i8** %51, align 8, !tbaa !229
  %53 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %0, i64 0, i32 5
  %54 = load i64, i64* %53, align 8, !tbaa !230
  tail call fastcc void @luaO_chunkid(i8* nonnull %50, i8* %52, i64 %54)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @currentline(%struct.CallInfo* nocapture readonly) unnamed_addr #0 {
  %2 = bitcast %struct.CallInfo* %0 to %struct.LClosure***
  %3 = load %struct.LClosure**, %struct.LClosure*** %2, align 8, !tbaa !47
  %4 = load %struct.LClosure*, %struct.LClosure** %3, align 8, !tbaa !21
  %5 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4, i64 0, i32 5
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !21
  %7 = tail call fastcc i32 @currentpc(%struct.CallInfo* %0)
  %8 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %6, i32 %7)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @getfuncname(%struct.lua_State* nocapture readonly, %struct.CallInfo* readonly, i8** nocapture) unnamed_addr #0 {
  %4 = icmp eq %struct.CallInfo* %1, null
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %7 = load i16, i16* %6, align 2, !tbaa !46
  %8 = zext i16 %7 to i32
  %9 = and i32 %8, 64
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %12, label %11

; <label>:11:                                     ; preds = %5
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0), i8** %2, align 8, !tbaa !79
  br label %24

; <label>:12:                                     ; preds = %5
  %13 = and i32 %8, 16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %24

; <label>:15:                                     ; preds = %12
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %17 = load %struct.CallInfo*, %struct.CallInfo** %16, align 8, !tbaa !78
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %17, i64 0, i32 7
  %19 = load i16, i16* %18, align 2, !tbaa !46
  %20 = and i16 %19, 2
  %21 = icmp eq i16 %20, 0
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %15
  %23 = tail call fastcc i8* @funcnamefromcode(%struct.lua_State* %0, %struct.CallInfo* %17, i8** %2)
  br label %24

; <label>:24:                                     ; preds = %12, %15, %3, %22, %11
  %25 = phi i8* [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %11 ], [ %23, %22 ], [ null, %3 ], [ null, %15 ], [ null, %12 ]
  ret i8* %25
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaO_chunkid(i8* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = load i8, i8* %1, align 1, !tbaa !21
  switch i8 %4, label %20 [
    i8 61, label %5
    i8 64, label %11
  ]

; <label>:5:                                      ; preds = %3
  %6 = icmp ult i64 %2, 61
  %7 = getelementptr inbounds i8, i8* %1, i64 1
  br i1 %6, label %8, label %9

; <label>:8:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 %2, i32 1, i1 false)
  br label %39

; <label>:9:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 59, i32 1, i1 false)
  %10 = getelementptr inbounds i8, i8* %0, i64 59
  store i8 0, i8* %10, align 1, !tbaa !21
  br label %39

; <label>:11:                                     ; preds = %3
  %12 = icmp ult i64 %2, 61
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds i8, i8* %1, i64 1
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %14, i64 %2, i32 1, i1 false)
  br label %39

; <label>:15:                                     ; preds = %11
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %16 = getelementptr inbounds i8, i8* %0, i64 3
  %17 = getelementptr inbounds i8, i8* %1, i64 1
  %18 = getelementptr inbounds i8, i8* %17, i64 %2
  %19 = getelementptr inbounds i8, i8* %18, i64 -57
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %16, i8* nonnull %19, i64 57, i32 1, i1 false)
  br label %39

; <label>:20:                                     ; preds = %3
  %21 = tail call i8* @strchr(i8* nonnull %1, i32 10) #19
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.150, i64 0, i64 0), i64 9, i32 1, i1 false)
  %22 = getelementptr inbounds i8, i8* %0, i64 9
  %23 = icmp ult i64 %2, 45
  %24 = icmp eq i8* %21, null
  %25 = and i1 %23, %24
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %20
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %2, i32 1, i1 false)
  %27 = getelementptr inbounds i8, i8* %22, i64 %2
  br label %37

; <label>:28:                                     ; preds = %20
  %29 = ptrtoint i8* %21 to i64
  %30 = ptrtoint i8* %1 to i64
  %31 = sub i64 %29, %30
  %32 = select i1 %24, i64 %2, i64 %31
  %33 = icmp ult i64 %32, 45
  %34 = select i1 %33, i64 %32, i64 45
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %34, i32 1, i1 false)
  %35 = getelementptr inbounds i8, i8* %22, i64 %34
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %35, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %36 = getelementptr inbounds i8, i8* %35, i64 3
  br label %37

; <label>:37:                                     ; preds = %28, %26
  %38 = phi i8* [ %27, %26 ], [ %36, %28 ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %38, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.151, i64 0, i64 0), i64 3, i32 1, i1 false)
  br label %39

; <label>:39:                                     ; preds = %37, %15, %13, %8, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaG_getfuncline(%struct.Proto* nocapture readonly, i32) unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %5 = load i8*, i8** %4, align 8, !tbaa !211
  %6 = icmp eq i8* %5, null
  br i1 %6, label %30, label %7

; <label>:7:                                      ; preds = %2
  %8 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  %9 = call fastcc i32 @getbaseline(%struct.Proto* nonnull %0, i32 %1, i32* nonnull %3)
  %10 = load i32, i32* %3, align 4, !tbaa !70
  %11 = add nsw i32 %10, 1
  store i32 %11, i32* %3, align 4, !tbaa !70
  %12 = icmp slt i32 %10, %1
  br i1 %12, label %13, label %28

; <label>:13:                                     ; preds = %7
  %14 = load i8*, i8** %4, align 8, !tbaa !211
  %15 = load i32, i32* %3, align 4, !tbaa !70
  br label %16

; <label>:16:                                     ; preds = %13, %16
  %17 = phi i32 [ %15, %13 ], [ %25, %16 ]
  %18 = phi i32 [ %11, %13 ], [ %25, %16 ]
  %19 = phi i32 [ %9, %13 ], [ %24, %16 ]
  %20 = sext i32 %18 to i64
  %21 = getelementptr inbounds i8, i8* %14, i64 %20
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = sext i8 %22 to i32
  %24 = add nsw i32 %19, %23
  %25 = add nsw i32 %17, 1
  %26 = icmp slt i32 %17, %1
  br i1 %26, label %16, label %27

; <label>:27:                                     ; preds = %16
  store i32 %25, i32* %3, align 4, !tbaa !70
  br label %28

; <label>:28:                                     ; preds = %27, %7
  %29 = phi i32 [ %24, %27 ], [ %9, %7 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  br label %30

; <label>:30:                                     ; preds = %2, %28
  %31 = phi i32 [ %29, %28 ], [ -1, %2 ]
  ret i32 %31
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @getbaseline(%struct.Proto* nocapture readonly, i32, i32* nocapture) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %5 = load i32, i32* %4, align 8, !tbaa !213
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %13, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %9 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %8, align 8, !tbaa !212
  %10 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %9, i64 0, i32 0
  %11 = load i32, i32* %10, align 4, !tbaa !234
  %12 = icmp sgt i32 %11, %1
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %7, %3
  store i32 -1, i32* %2, align 4, !tbaa !70
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  br label %43

; <label>:15:                                     ; preds = %7
  %16 = add nsw i32 %5, -1
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %9, i64 %17, i32 0
  %19 = load i32, i32* %18, align 4, !tbaa !234
  %20 = icmp sgt i32 %19, %1
  br i1 %20, label %21, label %37

; <label>:21:                                     ; preds = %15
  %22 = icmp eq i32 %5, 2
  br i1 %22, label %37, label %23

; <label>:23:                                     ; preds = %21
  br label %24

; <label>:24:                                     ; preds = %23, %24
  %25 = phi i32 [ %34, %24 ], [ %16, %23 ]
  %26 = phi i32 [ %33, %24 ], [ 0, %23 ]
  %27 = add i32 %25, %26
  %28 = lshr i32 %27, 1
  %29 = zext i32 %28 to i64
  %30 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %9, i64 %29, i32 0
  %31 = load i32, i32* %30, align 4, !tbaa !234
  %32 = icmp sgt i32 %31, %1
  %33 = select i1 %32, i32 %26, i32 %28
  %34 = select i1 %32, i32 %28, i32 %25
  %35 = add i32 %34, -1
  %36 = icmp ult i32 %33, %35
  br i1 %36, label %24, label %37

; <label>:37:                                     ; preds = %24, %21, %15
  %38 = phi i32 [ %16, %15 ], [ 0, %21 ], [ %33, %24 ]
  %39 = zext i32 %38 to i64
  %40 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %9, i64 %39, i32 0
  %41 = load i32, i32* %40, align 4, !tbaa !234
  store i32 %41, i32* %2, align 4, !tbaa !70
  %42 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %9, i64 %39, i32 1
  br label %43

; <label>:43:                                     ; preds = %37, %13
  %44 = phi i32* [ %14, %13 ], [ %42, %37 ]
  %45 = load i32, i32* %44, align 4, !tbaa !70
  ret i32 %45
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @funcnamefromcode(%struct.lua_State* nocapture readonly, %struct.CallInfo* nocapture readonly, i8** nocapture) unnamed_addr #0 {
  %4 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %5 = load %struct.LClosure**, %struct.LClosure*** %4, align 8, !tbaa !47
  %6 = load %struct.LClosure*, %struct.LClosure** %5, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %6, i64 0, i32 5
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !21
  %9 = tail call fastcc i32 @currentpc(%struct.CallInfo* %1)
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !134
  %12 = sext i32 %9 to i64
  %13 = getelementptr inbounds i32, i32* %11, i64 %12
  %14 = load i32, i32* %13, align 4, !tbaa !70
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %16 = load i16, i16* %15, align 2, !tbaa !46
  %17 = and i16 %16, 4
  %18 = icmp eq i16 %17, 0
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8** %2, align 8, !tbaa !79
  br label %51

; <label>:20:                                     ; preds = %3
  %21 = and i32 %14, 127
  %22 = trunc i32 %14 to i7
  switch i7 %22, label %51 [
    i7 -59, label %23
    i7 -58, label %23
    i7 -51, label %27
    i7 18, label %42
    i7 9, label %42
    i7 10, label %42
    i7 11, label %42
    i7 12, label %42
    i7 13, label %28
    i7 14, label %28
    i7 15, label %28
    i7 16, label %28
    i7 19, label %29
    i7 20, label %29
    i7 21, label %29
    i7 22, label %29
    i7 23, label %29
    i7 24, label %29
    i7 25, label %29
    i7 26, label %31
    i7 27, label %31
    i7 28, label %31
    i7 29, label %31
    i7 30, label %31
    i7 31, label %31
    i7 32, label %31
    i7 33, label %31
    i7 34, label %31
    i7 35, label %31
    i7 38, label %33
    i7 39, label %33
    i7 40, label %33
    i7 41, label %33
    i7 42, label %33
    i7 43, label %33
    i7 44, label %33
    i7 45, label %33
    i7 46, label %33
    i7 47, label %33
    i7 48, label %33
    i7 49, label %33
    i7 50, label %35
    i7 51, label %36
    i7 53, label %37
    i7 54, label %38
    i7 58, label %39
    i7 59, label %40
    i7 60, label %40
    i7 63, label %40
    i7 -64, label %40
    i7 36, label %41
    i7 37, label %41
  ]

; <label>:23:                                     ; preds = %20, %20
  %24 = lshr i32 %14, 7
  %25 = and i32 %24, 255
  %26 = tail call fastcc i8* @getobjname(%struct.Proto* %8, i32 %9, i32 %25, i8** %2)
  br label %51

; <label>:27:                                     ; preds = %20
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), i8** %2, align 8, !tbaa !79
  br label %51

; <label>:28:                                     ; preds = %20, %20, %20, %20
  br label %42

; <label>:29:                                     ; preds = %20, %20, %20, %20, %20, %20, %20
  %30 = add nsw i32 %21, -13
  br label %42

; <label>:31:                                     ; preds = %20, %20, %20, %20, %20, %20, %20, %20, %20, %20
  %32 = add nsw i32 %21, -20
  br label %42

; <label>:33:                                     ; preds = %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20, %20
  %34 = add nsw i32 %21, -32
  br label %42

; <label>:35:                                     ; preds = %20
  br label %42

; <label>:36:                                     ; preds = %20
  br label %42

; <label>:37:                                     ; preds = %20
  br label %42

; <label>:38:                                     ; preds = %20
  br label %42

; <label>:39:                                     ; preds = %20
  br label %42

; <label>:40:                                     ; preds = %20, %20, %20, %20
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.155, i64 0, i64 0), i8** %2, align 8, !tbaa !79
  br label %51

; <label>:41:                                     ; preds = %20, %20
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.156, i64 0, i64 0), i8** %2, align 8, !tbaa !79
  br label %51

; <label>:42:                                     ; preds = %20, %20, %20, %20, %20, %39, %38, %37, %36, %35, %33, %31, %29, %28
  %43 = phi i32 [ 5, %39 ], [ 22, %38 ], [ 4, %37 ], [ 19, %36 ], [ 18, %35 ], [ %34, %33 ], [ %32, %31 ], [ %30, %29 ], [ 1, %28 ], [ 0, %20 ], [ 0, %20 ], [ 0, %20 ], [ 0, %20 ], [ 0, %20 ]
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %45 = load %struct.global_State*, %struct.global_State** %44, align 8, !tbaa !2
  %46 = zext i32 %43 to i64
  %47 = getelementptr inbounds %struct.global_State, %struct.global_State* %45, i64 0, i32 40, i64 %46
  %48 = bitcast %struct.TString** %47 to i8**
  %49 = load i8*, i8** %48, align 8, !tbaa !79
  %50 = getelementptr inbounds i8, i8* %49, i64 26
  store i8* %50, i8** %2, align 8, !tbaa !79
  br label %51

; <label>:51:                                     ; preds = %20, %42, %41, %40, %27, %23, %19
  %52 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.153, i64 0, i64 0), %19 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %41 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %40 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %42 ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), %27 ], [ %26, %23 ], [ null, %20 ]
  ret i8* %52
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @getobjname(%struct.Proto* nocapture readonly, i32, i32, i8** nocapture) unnamed_addr #0 {
  %5 = add nsw i32 %2, 1
  %6 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %0, i32 %5, i32 %1)
  store i8* %6, i8** %3, align 8, !tbaa !79
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %71

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  br label %14

; <label>:10:                                     ; preds = %25
  %11 = add nuw nsw i32 %27, 1
  %12 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* nonnull %0, i32 %11, i32 %17)
  store i8* %12, i8** %3, align 8, !tbaa !79
  %13 = icmp eq i8* %12, null
  br i1 %13, label %14, label %71

; <label>:14:                                     ; preds = %8, %10
  %15 = phi i32 [ %2, %8 ], [ %27, %10 ]
  %16 = phi i32 [ %1, %8 ], [ %17, %10 ]
  %17 = tail call fastcc i32 @findsetreg(%struct.Proto* %0, i32 %16, i32 %15)
  %18 = icmp eq i32 %17, -1
  br i1 %18, label %71, label %19

; <label>:19:                                     ; preds = %14
  %20 = load i32*, i32** %9, align 8, !tbaa !134
  %21 = sext i32 %17 to i64
  %22 = getelementptr inbounds i32, i32* %20, i64 %21
  %23 = load i32, i32* %22, align 4, !tbaa !70
  %24 = trunc i32 %23 to i7
  switch i7 %24, label %71 [
    i7 0, label %25
    i7 9, label %31
    i7 10, label %34
    i7 11, label %37
    i7 12, label %38
    i7 7, label %41
    i7 3, label %45
    i7 4, label %45
    i7 18, label %70
  ]

; <label>:25:                                     ; preds = %19
  %26 = lshr i32 %23, 16
  %27 = and i32 %26, 255
  %28 = lshr i32 %23, 7
  %29 = and i32 %28, 255
  %30 = icmp ult i32 %27, %29
  br i1 %30, label %10, label %71

; <label>:31:                                     ; preds = %19
  %32 = lshr i32 %23, 24
  tail call fastcc void @kname(%struct.Proto* nonnull %0, i32 %32, i8** nonnull %3)
  %33 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %23, i32 1)
  br label %71

; <label>:34:                                     ; preds = %19
  %35 = lshr i32 %23, 24
  tail call fastcc void @rname(%struct.Proto* nonnull %0, i32 %17, i32 %35, i8** nonnull %3)
  %36 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %23, i32 0)
  br label %71

; <label>:37:                                     ; preds = %19
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.157, i64 0, i64 0), i8** %3, align 8, !tbaa !79
  br label %71

; <label>:38:                                     ; preds = %19
  %39 = lshr i32 %23, 24
  tail call fastcc void @kname(%struct.Proto* nonnull %0, i32 %39, i8** nonnull %3)
  %40 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %17, i32 %23, i32 0)
  br label %71

; <label>:41:                                     ; preds = %19
  %42 = lshr i32 %23, 16
  %43 = and i32 %42, 255
  %44 = tail call fastcc i8* @upvalname(%struct.Proto* nonnull %0, i32 %43)
  store i8* %44, i8** %3, align 8, !tbaa !79
  br label %71

; <label>:45:                                     ; preds = %19, %19
  %46 = and i32 %23, 127
  %47 = icmp eq i32 %46, 3
  br i1 %47, label %48, label %50

; <label>:48:                                     ; preds = %45
  %49 = lshr i32 %23, 15
  br label %56

; <label>:50:                                     ; preds = %45
  %51 = add nsw i32 %17, 1
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds i32, i32* %20, i64 %52
  %54 = load i32, i32* %53, align 4, !tbaa !70
  %55 = lshr i32 %54, 7
  br label %56

; <label>:56:                                     ; preds = %50, %48
  %57 = phi i32 [ %49, %48 ], [ %55, %50 ]
  %58 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %59 = load %struct.TValue*, %struct.TValue** %58, align 8, !tbaa !209
  %60 = zext i32 %57 to i64
  %61 = getelementptr inbounds %struct.TValue, %struct.TValue* %59, i64 %60, i32 1
  %62 = load i8, i8* %61, align 8, !tbaa !22
  %63 = and i8 %62, 15
  %64 = icmp eq i8 %63, 4
  br i1 %64, label %65, label %71

; <label>:65:                                     ; preds = %56
  %66 = getelementptr inbounds %struct.TValue, %struct.TValue* %59, i64 %60, i32 0, i32 0
  %67 = bitcast %struct.GCObject** %66 to i8**
  %68 = load i8*, i8** %67, align 8, !tbaa !21
  %69 = getelementptr inbounds i8, i8* %68, i64 24
  store i8* %69, i8** %3, align 8, !tbaa !79
  br label %71

; <label>:70:                                     ; preds = %19
  tail call fastcc void @rkname(%struct.Proto* nonnull %0, i32 %17, i32 %23, i8** nonnull %3)
  br label %71

; <label>:71:                                     ; preds = %10, %19, %14, %25, %4, %65, %31, %34, %37, %38, %41, %70, %56
  %72 = phi i8* [ null, %56 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.160, i64 0, i64 0), %65 ], [ %33, %31 ], [ %36, %34 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %37 ], [ %40, %38 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %41 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %70 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i64 0, i64 0), %4 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i64 0, i64 0), %10 ], [ null, %19 ], [ null, %14 ], [ null, %25 ]
  ret i8* %72
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @findsetreg(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #3 {
  %4 = icmp sgt i32 %1, 0
  br i1 %4, label %5, label %55

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !134
  %8 = zext i32 %1 to i64
  br label %9

; <label>:9:                                      ; preds = %50, %5
  %10 = phi i64 [ 0, %5 ], [ %53, %50 ]
  %11 = phi i32 [ -1, %5 ], [ %52, %50 ]
  %12 = phi i32 [ 0, %5 ], [ %51, %50 ]
  %13 = getelementptr inbounds i32, i32* %7, i64 %10
  %14 = load i32, i32* %13, align 4, !tbaa !70
  %15 = lshr i32 %14, 7
  %16 = and i32 %15, 255
  %17 = trunc i32 %14 to i7
  switch i7 %17, label %33 [
    i7 6, label %18
    i7 -51, label %20
    i7 -59, label %23
    i7 -58, label %23
    i7 57, label %25
  ]

; <label>:18:                                     ; preds = %9
  %19 = icmp sgt i32 %16, %2
  br i1 %19, label %50, label %42

; <label>:20:                                     ; preds = %9
  %21 = add nuw nsw i32 %16, 2
  %22 = icmp sgt i32 %21, %2
  br i1 %22, label %50, label %47

; <label>:23:                                     ; preds = %9, %9
  %24 = icmp sgt i32 %16, %2
  br i1 %24, label %50, label %47

; <label>:25:                                     ; preds = %9
  %26 = trunc i64 %10 to i32
  %27 = add i32 %26, -16777214
  %28 = add i32 %27, %15
  %29 = icmp sle i32 %28, %1
  %30 = icmp sgt i32 %28, %12
  %31 = and i1 %29, %30
  %32 = select i1 %31, i32 %28, i32 %12
  br label %50

; <label>:33:                                     ; preds = %9
  %34 = and i32 %14, 127
  %35 = zext i32 %34 to i64
  %36 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %35
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = and i8 %37, 8
  %39 = icmp ne i8 %38, 0
  %40 = icmp eq i32 %16, %2
  %41 = and i1 %40, %39
  br i1 %41, label %47, label %50

; <label>:42:                                     ; preds = %18
  %43 = lshr i32 %14, 16
  %44 = and i32 %43, 255
  %45 = add nuw nsw i32 %16, %44
  %46 = icmp slt i32 %45, %2
  br i1 %46, label %50, label %47

; <label>:47:                                     ; preds = %42, %20, %23, %33
  %48 = trunc i64 %10 to i32
  %49 = tail call fastcc i32 @filterpc(i32 %48, i32 %12)
  br label %50

; <label>:50:                                     ; preds = %42, %20, %23, %25, %18, %33, %47
  %51 = phi i32 [ %12, %47 ], [ %12, %42 ], [ %12, %33 ], [ %12, %23 ], [ %12, %20 ], [ %32, %25 ], [ %12, %18 ]
  %52 = phi i32 [ %49, %47 ], [ %11, %42 ], [ %11, %33 ], [ %11, %23 ], [ %11, %20 ], [ %11, %25 ], [ %11, %18 ]
  %53 = add nuw nsw i64 %10, 1
  %54 = icmp eq i64 %53, %8
  br i1 %54, label %55, label %9

; <label>:55:                                     ; preds = %50, %3
  %56 = phi i32 [ -1, %3 ], [ %52, %50 ]
  ret i32 %56
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @kname(%struct.Proto* nocapture readonly, i32, i8** nocapture) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !209
  %6 = sext i32 %1 to i64
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 %6, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 4
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 %6, i32 0, i32 0
  %13 = bitcast %struct.GCObject** %12 to i8**
  %14 = load i8*, i8** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds i8, i8* %14, i64 24
  br label %16

; <label>:16:                                     ; preds = %3, %11
  %17 = phi i8* [ %15, %11 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %3 ]
  store i8* %17, i8** %2, align 8, !tbaa !79
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @gxf(%struct.Proto* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = lshr i32 %2, 16
  %7 = and i32 %6, 255
  %8 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %4
  %11 = tail call fastcc i8* @upvalname(%struct.Proto* %0, i32 %7)
  store i8* %11, i8** %5, align 8, !tbaa !79
  br label %15

; <label>:12:                                     ; preds = %4
  %13 = call fastcc i8* @getobjname(%struct.Proto* %0, i32 %1, i32 %7, i8** nonnull %5)
  %14 = load i8*, i8** %5, align 8, !tbaa !79
  br label %15

; <label>:15:                                     ; preds = %12, %10
  %16 = phi i8* [ %14, %12 ], [ %11, %10 ]
  %17 = icmp eq i8* %16, null
  br i1 %17, label %22, label %18

; <label>:18:                                     ; preds = %15
  %19 = tail call i32 @strcmp(i8* nonnull %16, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0)) #19
  %20 = icmp eq i32 %19, 0
  %21 = select i1 %20, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.161, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0)
  br label %22

; <label>:22:                                     ; preds = %15, %18
  %23 = phi i8* [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %15 ], [ %21, %18 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  ret i8* %23
}

; Function Attrs: nounwind uwtable
define internal fastcc void @rname(%struct.Proto* nocapture readonly, i32, i32, i8** nocapture) unnamed_addr #0 {
  %5 = tail call fastcc i8* @getobjname(%struct.Proto* %0, i32 %1, i32 %2, i8** %3)
  %6 = icmp eq i8* %5, null
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = load i8, i8* %5, align 1, !tbaa !21
  %9 = icmp eq i8 %8, 99
  br i1 %9, label %11, label %10

; <label>:10:                                     ; preds = %4, %7
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8** %3, align 8, !tbaa !79
  br label %11

; <label>:11:                                     ; preds = %10, %7
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i8* @upvalname(%struct.Proto* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %4 = load %struct.Upvaldesc*, %struct.Upvaldesc** %3, align 8, !tbaa !174
  %5 = sext i32 %1 to i64
  %6 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %4, i64 %5, i32 0
  %7 = load %struct.TString*, %struct.TString** %6, align 8, !tbaa !175
  %8 = icmp eq %struct.TString* %7, null
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 1
  %10 = bitcast %struct.TString* %9 to i8*
  %11 = select i1 %8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %10
  ret i8* %11
}

; Function Attrs: nounwind uwtable
define internal fastcc void @rkname(%struct.Proto* nocapture readonly, i32, i32, i8** nocapture) unnamed_addr #0 {
  %5 = lshr i32 %2, 24
  %6 = trunc i32 %2 to i16
  %7 = icmp slt i16 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %4
  tail call fastcc void @kname(%struct.Proto* %0, i32 %5, i8** %3)
  br label %10

; <label>:9:                                      ; preds = %4
  tail call fastcc void @rname(%struct.Proto* %0, i32 %1, i32 %5, i8** %3)
  br label %10

; <label>:10:                                     ; preds = %9, %8
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @filterpc(i32, i32) unnamed_addr #6 {
  %3 = icmp slt i32 %0, %1
  %4 = select i1 %3, i32 -1, i32 %0
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @nextline(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %5 = load i8*, i8** %4, align 8, !tbaa !211
  %6 = sext i32 %2 to i64
  %7 = getelementptr inbounds i8, i8* %5, i64 %6
  %8 = load i8, i8* %7, align 1, !tbaa !21
  %9 = icmp eq i8 %8, -128
  br i1 %9, label %13, label %10

; <label>:10:                                     ; preds = %3
  %11 = sext i8 %8 to i32
  %12 = add nsw i32 %11, %1
  br label %15

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %0, i32 %2)
  br label %15

; <label>:15:                                     ; preds = %13, %10
  %16 = phi i32 [ %12, %10 ], [ %14, %13 ]
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @callclosemth(%struct.lua_State*, %struct.TValue* nocapture readonly, %union.StackValue*, i32) unnamed_addr #0 {
  %5 = icmp eq i32 %3, 0
  br i1 %5, label %6, label %30, !prof !103

; <label>:6:                                      ; preds = %4
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 8
  %10 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* nonnull %9)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %6
  tail call void @callclose(%struct.lua_State* nonnull %0, i8* null)
  br label %43

; <label>:13:                                     ; preds = %6
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %43, label %18

; <label>:18:                                     ; preds = %13
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %20 = load %struct.CallInfo*, %struct.CallInfo** %19, align 8, !tbaa !35
  %21 = bitcast %struct.CallInfo* %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !47
  %23 = ptrtoint %union.StackValue* %2 to i64
  %24 = sub i64 %23, %22
  %25 = lshr exact i64 %24, 4
  %26 = trunc i64 %25 to i32
  %27 = tail call fastcc i8* @luaG_findlocal(%struct.lua_State* nonnull %0, %struct.CallInfo* %20, i32 %26, %union.StackValue** null)
  %28 = icmp eq i8* %27, null
  %29 = select i1 %28, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %27
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.162, i64 0, i64 0), i8* %29) #17
  unreachable

; <label>:30:                                     ; preds = %4
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %3, %union.StackValue* %2)
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0
  %32 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %31)
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %43, label %34

; <label>:34:                                     ; preds = %30
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %36 = bitcast %union.StackValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !34
  %38 = ptrtoint %union.StackValue* %2 to i64
  %39 = sub i64 %38, %37
  %40 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @callclose, i8* null, i64 %39, i64 0)
  %41 = icmp eq i32 %40, 0
  %42 = select i1 %41, i32 %3, i32 %40
  br label %43

; <label>:43:                                     ; preds = %30, %34, %12, %13
  %44 = phi i32 [ 0, %12 ], [ 0, %13 ], [ %42, %34 ], [ %3, %30 ]
  ret i32 %44
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @prepclosingmethod(%struct.lua_State* nocapture, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 24)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %32, label %11

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %6 to i64*
  %13 = bitcast %union.StackValue* %5 to i64*
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %13, align 8
  %15 = load i8, i8* %7, align 8, !tbaa !22
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 0, i32 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0
  %18 = bitcast %struct.TValue* %1 to i64*
  %19 = bitcast %struct.TValue* %17 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0
  %25 = bitcast %struct.TValue* %2 to i64*
  %26 = bitcast %struct.TValue* %24 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !22
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 3
  store %union.StackValue* %31, %union.StackValue** %4, align 8, !tbaa !20
  br label %32

; <label>:32:                                     ; preds = %3, %11
  %33 = phi i32 [ 1, %11 ], [ 0, %3 ]
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define internal void @callclose(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0)
  ret void
}

; Function Attrs: nounwind returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) local_unnamed_addr #12

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_execute(%struct.lua_State*, %struct.CallInfo*) #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca i64, align 8
  %15 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca i64, align 8
  %21 = alloca i64, align 8
  %22 = alloca double, align 8
  %23 = alloca double, align 8
  %24 = alloca double, align 8
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %27 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %29 = bitcast %union.anon.0* %28 to %struct.anon*
  %30 = bitcast %union.anon.0* %28 to i32**
  %31 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %32 = bitcast %union.StackValue** %31 to i64*
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %34 = bitcast %union.StackValue** %33 to i64*
  %35 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %36 = bitcast %union.StackValue** %35 to i64*
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %38 = bitcast %union.StackValue** %37 to i64*
  %39 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %40 = bitcast i64* %39 to i32*
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %42 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %43 = bitcast i64* %42 to i32*
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %46 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %47 = bitcast %union.StackValue** %46 to i64*
  %48 = bitcast %union.StackValue** %45 to i64*
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %50 = bitcast i64* %49 to i32*
  %51 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %52 = bitcast i64* %51 to i32*
  %53 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %54 = bitcast %union.StackValue** %53 to i64*
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %56 = bitcast %union.StackValue** %55 to i64*
  %57 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %58 = bitcast i64* %57 to i32*
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %60 = bitcast %union.StackValue** %59 to i64*
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %62 = bitcast %union.StackValue** %61 to i64*
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %64 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %65 = bitcast %union.StackValue** %64 to i64*
  %66 = bitcast %union.StackValue** %63 to i64*
  %67 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %68 = bitcast i64* %67 to i32*
  %69 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %71 = bitcast %union.StackValue** %70 to i64*
  %72 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %73 = bitcast %union.StackValue** %72 to i64*
  %74 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %75 = bitcast i64* %74 to i32*
  %76 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %77 = bitcast i64* %76 to i32*
  %78 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %79 = bitcast %union.StackValue** %78 to i64*
  %80 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %81 = bitcast %union.StackValue** %80 to i64*
  %82 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %83 = bitcast i64* %82 to i32*
  %84 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %85 = bitcast %union.StackValue** %84 to i64*
  %86 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %87 = bitcast %union.StackValue** %86 to i64*
  %88 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %89 = bitcast i64* %88 to i32*
  %90 = bitcast %struct.TValue* %3 to i64*
  %91 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %92 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %93 = bitcast %union.StackValue** %92 to i64*
  %94 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %95 = bitcast %union.StackValue** %94 to i64*
  %96 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %97 = bitcast i64* %96 to i32*
  %98 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %99 = bitcast %union.StackValue** %98 to i64*
  %100 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %101 = bitcast %union.StackValue** %100 to i64*
  %102 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %103 = bitcast i64* %102 to i32*
  %104 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %105 = bitcast %union.StackValue** %104 to i64*
  %106 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %107 = bitcast %union.StackValue** %106 to i64*
  %108 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %109 = bitcast i64* %108 to i32*
  %110 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %111 = bitcast %union.StackValue** %110 to i64*
  %112 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %113 = bitcast %union.StackValue** %112 to i64*
  %114 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %115 = bitcast i64* %114 to i32*
  %116 = bitcast %struct.TValue* %4 to i64*
  %117 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %118 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %119 = bitcast %union.StackValue** %118 to i64*
  %120 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %121 = bitcast %union.StackValue** %120 to i64*
  %122 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %123 = bitcast i64* %122 to i32*
  %124 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %125 = bitcast %union.StackValue** %124 to i64*
  %126 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %127 = bitcast %union.StackValue** %126 to i64*
  %128 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %129 = bitcast i64* %128 to i32*
  %130 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %131 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %132 = bitcast %union.StackValue** %131 to i64*
  %133 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %134 = bitcast %union.StackValue** %133 to i64*
  %135 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %136 = bitcast i64* %135 to i32*
  %137 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %138 = bitcast %union.StackValue** %137 to i64*
  %139 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %140 = bitcast %union.StackValue** %139 to i64*
  %141 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %142 = bitcast i64* %141 to i32*
  %143 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %144 = bitcast %union.StackValue** %143 to i64*
  %145 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %146 = bitcast %union.StackValue** %145 to i64*
  %147 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %148 = bitcast i64* %147 to i32*
  %149 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %150 = bitcast %union.StackValue** %149 to i64*
  %151 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %152 = bitcast %union.StackValue** %151 to i64*
  %153 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %154 = bitcast i64* %153 to i32*
  %155 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %156 = bitcast %union.StackValue** %155 to i64*
  %157 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %158 = bitcast %union.StackValue** %157 to i64*
  %159 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %160 = bitcast i64* %159 to i32*
  %161 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %162 = bitcast %union.StackValue** %161 to i64*
  %163 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %164 = bitcast %union.StackValue** %163 to i64*
  %165 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %166 = bitcast i64* %165 to i32*
  %167 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %168 = bitcast %union.StackValue** %167 to i64*
  %169 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %170 = bitcast %union.StackValue** %169 to i64*
  %171 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %172 = bitcast i64* %171 to i32*
  %173 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %174 = bitcast %union.StackValue** %173 to i64*
  %175 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %176 = bitcast %union.StackValue** %175 to i64*
  %177 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %178 = bitcast i64* %177 to i32*
  %179 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %180 = bitcast %union.StackValue** %179 to i64*
  %181 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %182 = bitcast %union.StackValue** %181 to i64*
  %183 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %184 = bitcast i64* %183 to i32*
  %185 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %186 = bitcast %union.StackValue** %185 to i64*
  %187 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %188 = bitcast %union.StackValue** %187 to i64*
  %189 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %190 = bitcast i64* %189 to i32*
  %191 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %192 = bitcast %union.StackValue** %191 to i64*
  %193 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %194 = bitcast %union.StackValue** %193 to i64*
  %195 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %196 = bitcast i64* %195 to i32*
  %197 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %198 = bitcast %union.StackValue** %197 to i64*
  %199 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %200 = bitcast %union.StackValue** %199 to i64*
  %201 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %202 = bitcast i64* %201 to i32*
  %203 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %204 = bitcast %union.StackValue** %203 to i64*
  %205 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %206 = bitcast %union.StackValue** %205 to i64*
  %207 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %208 = bitcast i64* %207 to i32*
  %209 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %210 = bitcast %union.StackValue** %209 to i64*
  %211 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %212 = bitcast %union.StackValue** %211 to i64*
  %213 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %214 = bitcast i64* %213 to i32*
  %215 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %216 = bitcast %union.StackValue** %215 to i64*
  %217 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %218 = bitcast %union.StackValue** %217 to i64*
  %219 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %220 = bitcast i64* %219 to i32*
  %221 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %222 = bitcast %union.StackValue** %221 to i64*
  %223 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %224 = bitcast %union.StackValue** %223 to i64*
  %225 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %226 = bitcast i64* %225 to i32*
  %227 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %228 = bitcast %union.StackValue** %227 to i64*
  %229 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %230 = bitcast %union.StackValue** %229 to i64*
  %231 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %232 = bitcast i64* %231 to i32*
  %233 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %234 = bitcast %union.StackValue** %233 to i64*
  %235 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %236 = bitcast %union.StackValue** %235 to i64*
  %237 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %238 = bitcast i64* %237 to i32*
  %239 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %240 = bitcast %union.StackValue** %239 to i64*
  %241 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %242 = bitcast %union.StackValue** %241 to i64*
  %243 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %244 = bitcast i64* %243 to i32*
  %245 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %246 = bitcast %union.StackValue** %245 to i64*
  %247 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %248 = bitcast %union.StackValue** %247 to i64*
  %249 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %250 = bitcast i64* %249 to i32*
  %251 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %252 = bitcast %union.StackValue** %251 to i64*
  %253 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %254 = bitcast %union.StackValue** %253 to i64*
  %255 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %256 = bitcast i64* %255 to i32*
  %257 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %258 = bitcast %union.StackValue** %257 to i64*
  %259 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %260 = bitcast %union.StackValue** %259 to i64*
  %261 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %262 = bitcast i64* %261 to i32*
  %263 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %264 = bitcast %union.StackValue** %263 to i64*
  %265 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %266 = bitcast %union.StackValue** %265 to i64*
  %267 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %268 = bitcast i64* %267 to i32*
  %269 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %270 = bitcast %union.StackValue** %269 to i64*
  %271 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %272 = bitcast %union.StackValue** %271 to i64*
  %273 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %274 = bitcast i64* %273 to i32*
  %275 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %276 = bitcast %union.StackValue** %275 to i64*
  %277 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %278 = bitcast %union.StackValue** %277 to i64*
  %279 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %280 = bitcast i64* %279 to i32*
  %281 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %282 = bitcast %union.StackValue** %281 to i64*
  %283 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %284 = bitcast %union.StackValue** %283 to i64*
  %285 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %286 = bitcast i64* %285 to i32*
  %287 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %288 = bitcast %union.StackValue** %287 to i64*
  %289 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %290 = bitcast %union.StackValue** %289 to i64*
  %291 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %292 = bitcast i64* %291 to i32*
  %293 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %294 = bitcast %union.StackValue** %293 to i64*
  %295 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %296 = bitcast %union.StackValue** %295 to i64*
  %297 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %298 = bitcast i64* %297 to i32*
  %299 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %300 = bitcast %union.StackValue** %299 to i64*
  %301 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %302 = bitcast %union.StackValue** %301 to i64*
  %303 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %304 = bitcast i64* %303 to i32*
  %305 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %306 = bitcast %union.StackValue** %305 to i64*
  %307 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %308 = bitcast %union.StackValue** %307 to i64*
  %309 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %310 = bitcast i64* %309 to i32*
  %311 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %312 = bitcast i64* %311 to i32*
  %313 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %314 = bitcast i64* %313 to i32*
  %315 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %316 = bitcast %union.StackValue** %315 to i64*
  %317 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %318 = bitcast %union.StackValue** %317 to i64*
  %319 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %320 = bitcast i64* %319 to i32*
  %321 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %322 = bitcast %union.StackValue** %321 to i64*
  %323 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %324 = bitcast %union.StackValue** %323 to i64*
  %325 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %326 = bitcast i64* %325 to i32*
  %327 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %328 = bitcast %union.StackValue** %327 to i64*
  %329 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %330 = bitcast %union.StackValue** %329 to i64*
  %331 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %332 = bitcast i64* %331 to i32*
  %333 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %334 = bitcast %union.StackValue** %333 to i64*
  %335 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %336 = bitcast %union.StackValue** %335 to i64*
  %337 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %338 = bitcast i64* %337 to i32*
  %339 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %340 = bitcast i64* %339 to i32*
  %341 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %342 = bitcast i64* %341 to i32*
  %343 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %344 = bitcast i64* %343 to i32*
  %345 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %346 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %347 = bitcast i64* %346 to i32*
  %348 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %349 = bitcast %union.StackValue** %348 to i64*
  %350 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %351 = bitcast %union.StackValue** %350 to i64*
  %352 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %353 = bitcast %union.StackValue** %352 to i64*
  %354 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %355 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %356 = bitcast i64* %355 to i32*
  %357 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %358 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %359 = bitcast i64* %358 to i32*
  %360 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %361 = bitcast %union.StackValue** %360 to i64*
  %362 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %363 = bitcast %union.StackValue** %362 to i64*
  %364 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %365 = bitcast i64* %364 to i32*
  %366 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %367 = bitcast %union.StackValue** %366 to i64*
  %368 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %369 = bitcast %union.StackValue** %368 to i64*
  %370 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %371 = bitcast i64* %370 to i32*
  %372 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %373 = bitcast %union.StackValue** %372 to i64*
  %374 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %375 = bitcast %union.StackValue** %374 to i64*
  %376 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %377 = bitcast i64* %376 to i32*
  %378 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %379 = bitcast %union.StackValue** %378 to i64*
  %380 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %381 = bitcast %union.StackValue** %380 to i64*
  %382 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %383 = bitcast i64* %382 to i32*
  %384 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %385 = bitcast %union.StackValue** %384 to i64*
  %386 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %387 = bitcast %union.StackValue** %386 to i64*
  %388 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %389 = bitcast i64* %388 to i32*
  %390 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %391 = bitcast %union.StackValue** %390 to i64*
  %392 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %393 = bitcast %union.StackValue** %392 to i64*
  %394 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %395 = bitcast i64* %394 to i32*
  %396 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %397 = bitcast i64* %396 to i32*
  %398 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %399 = bitcast i64* %398 to i32*
  %400 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %401 = bitcast i64* %400 to i32*
  %402 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %403 = bitcast i64* %402 to i32*
  %404 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %405 = bitcast i64* %404 to i32*
  %406 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %407 = bitcast i64* %406 to i32*
  %408 = bitcast double* %23 to i64*
  %409 = bitcast double* %24 to i64*
  %410 = bitcast double* %22 to i64*
  %411 = bitcast double* %23 to i64*
  %412 = bitcast double* %24 to i64*
  %413 = bitcast double* %22 to i64*
  %414 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %415 = bitcast i64* %414 to i32*
  %416 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %417 = bitcast i64* %416 to i32*
  %418 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %419 = bitcast %union.StackValue** %418 to i64*
  %420 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %421 = getelementptr inbounds %struct.anon, %struct.anon* %29, i64 0, i32 2
  br label %422

; <label>:422:                                    ; preds = %3574, %2
  %423 = load i32, i32* %25, align 8, !tbaa !23
  %424 = load %struct.LClosure**, %struct.LClosure*** %27, align 8, !tbaa !47
  %425 = load %struct.LClosure*, %struct.LClosure** %424, align 8, !tbaa !21
  %426 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 5
  %427 = load %struct.Proto*, %struct.Proto** %426, align 8, !tbaa !173
  %428 = getelementptr inbounds %struct.Proto, %struct.Proto* %427, i64 0, i32 15
  %429 = load %struct.TValue*, %struct.TValue** %428, align 8, !tbaa !209
  %430 = load i32*, i32** %30, align 8, !tbaa !21
  %431 = icmp eq i32 %423, 0
  br i1 %431, label %444, label %432

; <label>:432:                                    ; preds = %422
  %433 = getelementptr inbounds %struct.Proto, %struct.Proto* %427, i64 0, i32 4
  %434 = load i8, i8* %433, align 1, !tbaa !94
  %435 = icmp eq i8 %434, 0
  br i1 %435, label %436, label %441

; <label>:436:                                    ; preds = %432
  %437 = getelementptr inbounds %struct.Proto, %struct.Proto* %427, i64 0, i32 16
  %438 = load i32*, i32** %437, align 8, !tbaa !134
  %439 = icmp eq i32* %430, %438
  br i1 %439, label %440, label %442

; <label>:440:                                    ; preds = %436
  call fastcc void @luaD_hookcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1)
  br label %442

; <label>:441:                                    ; preds = %432
  store i32 1, i32* %415, align 8, !tbaa !21
  br label %444

; <label>:442:                                    ; preds = %440, %436
  store i32 1, i32* %417, align 8, !tbaa !21
  %443 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %430)
  br label %444

; <label>:444:                                    ; preds = %422, %441, %442
  %445 = phi i32 [ %443, %442 ], [ 0, %441 ], [ 0, %422 ]
  %446 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %447 = getelementptr inbounds %union.StackValue, %union.StackValue* %446, i64 1
  %448 = getelementptr inbounds i32, i32* %430, i64 1
  %449 = load i32, i32* %430, align 4, !tbaa !70
  %450 = lshr i32 %449, 7
  %451 = and i32 %450, 255
  %452 = zext i32 %451 to i64
  %453 = getelementptr inbounds %union.StackValue, %union.StackValue* %447, i64 %452
  %454 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 6, i64 0
  br label %4080

; <label>:455:                                    ; preds = %4080
  %456 = lshr i32 %4082, 16
  %457 = and i32 %456, 255
  %458 = zext i32 %457 to i64
  %459 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %458, i32 0
  %460 = bitcast %struct.TValue* %459 to i64*
  %461 = bitcast %union.StackValue* %4081 to i64*
  %462 = load i64, i64* %460, align 8
  store i64 %462, i64* %461, align 8
  %463 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %458, i32 0, i32 1
  %464 = load i8, i8* %463, align 8, !tbaa !22
  %465 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %464, i8* %465, align 8, !tbaa !22
  %466 = icmp eq i32 %4083, 0
  br i1 %466, label %471, label %467

; <label>:467:                                    ; preds = %455
  %468 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %469 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %470 = getelementptr inbounds %union.StackValue, %union.StackValue* %469, i64 1
  br label %471

; <label>:471:                                    ; preds = %455, %467
  %472 = phi i32 [ %468, %467 ], [ 0, %455 ]
  %473 = phi %union.StackValue* [ %470, %467 ], [ %4085, %455 ]
  %474 = getelementptr inbounds i32, i32* %4084, i64 1
  %475 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:476:                                    ; preds = %471, %500, %516, %532, %554, %572, %593, %617, %659, %705, %778, %833, %876, %948, %1044, %1122, %1188, %1221, %1274, %1315, %1354, %1395, %1434, %1472, %1510, %1550, %1610, %1668, %1728, %1786, %1834, %1882, %1941, %1999, %2057, %2115, %2173, %2221, %2269, %2328, %2368, %2408, %2448, %2496, %2544, %2592, %2638, %2676, %2725, %2773, %2807, %2841, %2871, %2888, %2910, %2924, %2935, %2951, %2981, %3043, %3105, %3137, %3183, %3235, %3287, %3339, %3391, %3433, %3484, %3505, %3735, %3855, %3923, %4006, %4033, %4048, %4062, %4074
  %477 = phi i32 [ %475, %471 ], [ %504, %500 ], [ %520, %516 ], [ %536, %532 ], [ %558, %554 ], [ %576, %572 ], [ %597, %593 ], [ %621, %617 ], [ %663, %659 ], [ %709, %705 ], [ %782, %778 ], [ %837, %833 ], [ %880, %876 ], [ %952, %948 ], [ %1048, %1044 ], [ %1126, %1122 ], [ %1192, %1188 ], [ %1225, %1221 ], [ %1278, %1274 ], [ %1319, %1315 ], [ %1358, %1354 ], [ %1399, %1395 ], [ %1438, %1434 ], [ %1476, %1472 ], [ %1514, %1510 ], [ %1554, %1550 ], [ %1614, %1610 ], [ %1672, %1668 ], [ %1732, %1728 ], [ %1790, %1786 ], [ %1838, %1834 ], [ %1886, %1882 ], [ %1945, %1941 ], [ %2003, %1999 ], [ %2061, %2057 ], [ %2119, %2115 ], [ %2177, %2173 ], [ %2225, %2221 ], [ %2273, %2269 ], [ %2332, %2328 ], [ %2372, %2368 ], [ %2412, %2408 ], [ %2452, %2448 ], [ %2500, %2496 ], [ %2548, %2544 ], [ %2596, %2592 ], [ %2642, %2638 ], [ %2680, %2676 ], [ %2729, %2725 ], [ %2777, %2773 ], [ %2811, %2807 ], [ %2845, %2841 ], [ %2875, %2871 ], [ %2892, %2888 ], [ %2914, %2910 ], [ %2928, %2924 ], [ %2939, %2935 ], [ %2955, %2951 ], [ %2985, %2981 ], [ %3047, %3043 ], [ %3109, %3105 ], [ %3141, %3137 ], [ %3187, %3183 ], [ %3239, %3235 ], [ %3291, %3287 ], [ %3343, %3339 ], [ %3395, %3391 ], [ %3437, %3433 ], [ %3488, %3484 ], [ %3509, %3505 ], [ %3739, %3735 ], [ %3859, %3855 ], [ %3927, %3923 ], [ %4010, %4006 ], [ %4037, %4033 ], [ %4052, %4048 ], [ %4067, %4062 ], [ %4078, %4074 ]
  %478 = phi %union.StackValue* [ %473, %471 ], [ %502, %500 ], [ %518, %516 ], [ %534, %532 ], [ %556, %554 ], [ %574, %572 ], [ %595, %593 ], [ %619, %617 ], [ %661, %659 ], [ %707, %705 ], [ %780, %778 ], [ %835, %833 ], [ %878, %876 ], [ %950, %948 ], [ %1046, %1044 ], [ %1124, %1122 ], [ %1190, %1188 ], [ %1223, %1221 ], [ %1276, %1274 ], [ %1317, %1315 ], [ %1356, %1354 ], [ %1397, %1395 ], [ %1436, %1434 ], [ %1474, %1472 ], [ %1512, %1510 ], [ %1552, %1550 ], [ %1612, %1610 ], [ %1670, %1668 ], [ %1730, %1728 ], [ %1788, %1786 ], [ %1836, %1834 ], [ %1884, %1882 ], [ %1943, %1941 ], [ %2001, %1999 ], [ %2059, %2057 ], [ %2117, %2115 ], [ %2175, %2173 ], [ %2223, %2221 ], [ %2271, %2269 ], [ %2330, %2328 ], [ %2370, %2368 ], [ %2410, %2408 ], [ %2450, %2448 ], [ %2498, %2496 ], [ %2546, %2544 ], [ %2594, %2592 ], [ %2640, %2638 ], [ %2678, %2676 ], [ %2727, %2725 ], [ %2775, %2773 ], [ %2809, %2807 ], [ %2843, %2841 ], [ %2873, %2871 ], [ %2890, %2888 ], [ %2912, %2910 ], [ %2926, %2924 ], [ %2937, %2935 ], [ %2953, %2951 ], [ %2983, %2981 ], [ %3045, %3043 ], [ %3107, %3105 ], [ %3139, %3137 ], [ %3185, %3183 ], [ %3237, %3235 ], [ %3289, %3287 ], [ %3341, %3339 ], [ %3393, %3391 ], [ %3435, %3433 ], [ %3486, %3484 ], [ %3507, %3505 ], [ %3737, %3735 ], [ %3857, %3855 ], [ %3925, %3923 ], [ %4008, %4006 ], [ %4035, %4033 ], [ %4050, %4048 ], [ %4065, %4062 ], [ %4076, %4074 ]
  %479 = phi i32 [ %472, %471 ], [ %501, %500 ], [ %517, %516 ], [ %533, %532 ], [ %555, %554 ], [ %573, %572 ], [ %594, %593 ], [ %618, %617 ], [ %660, %659 ], [ %706, %705 ], [ %779, %778 ], [ %834, %833 ], [ %877, %876 ], [ %949, %948 ], [ %1045, %1044 ], [ %1123, %1122 ], [ %1189, %1188 ], [ %1222, %1221 ], [ %1275, %1274 ], [ %1316, %1315 ], [ %1355, %1354 ], [ %1396, %1395 ], [ %1435, %1434 ], [ %1473, %1472 ], [ %1511, %1510 ], [ %1551, %1550 ], [ %1611, %1610 ], [ %1669, %1668 ], [ %1729, %1728 ], [ %1787, %1786 ], [ %1835, %1834 ], [ %1883, %1882 ], [ %1942, %1941 ], [ %2000, %1999 ], [ %2058, %2057 ], [ %2116, %2115 ], [ %2174, %2173 ], [ %2222, %2221 ], [ %2270, %2269 ], [ %2329, %2328 ], [ %2369, %2368 ], [ %2409, %2408 ], [ %2449, %2448 ], [ %2497, %2496 ], [ %2545, %2544 ], [ %2593, %2592 ], [ %2639, %2638 ], [ %2677, %2676 ], [ %2726, %2725 ], [ %2774, %2773 ], [ %2808, %2807 ], [ %2842, %2841 ], [ %2872, %2871 ], [ %2889, %2888 ], [ %2911, %2910 ], [ %2925, %2924 ], [ %2936, %2935 ], [ %2952, %2951 ], [ %2982, %2981 ], [ %3044, %3043 ], [ %3106, %3105 ], [ %3138, %3137 ], [ %3184, %3183 ], [ %3236, %3235 ], [ %3288, %3287 ], [ %3340, %3339 ], [ %3392, %3391 ], [ %3434, %3433 ], [ %3485, %3484 ], [ %3506, %3505 ], [ %3736, %3735 ], [ %3856, %3855 ], [ %3924, %3923 ], [ %4007, %4006 ], [ %4034, %4033 ], [ %4049, %4048 ], [ %4063, %4062 ], [ %4075, %4074 ]
  %480 = phi i32* [ %474, %471 ], [ %503, %500 ], [ %519, %516 ], [ %535, %532 ], [ %557, %554 ], [ %575, %572 ], [ %596, %593 ], [ %620, %617 ], [ %662, %659 ], [ %708, %705 ], [ %781, %778 ], [ %836, %833 ], [ %879, %876 ], [ %951, %948 ], [ %1047, %1044 ], [ %1125, %1122 ], [ %1191, %1188 ], [ %1224, %1221 ], [ %1277, %1274 ], [ %1318, %1315 ], [ %1357, %1354 ], [ %1398, %1395 ], [ %1437, %1434 ], [ %1475, %1472 ], [ %1513, %1510 ], [ %1553, %1550 ], [ %1613, %1610 ], [ %1671, %1668 ], [ %1731, %1728 ], [ %1789, %1786 ], [ %1837, %1834 ], [ %1885, %1882 ], [ %1944, %1941 ], [ %2002, %1999 ], [ %2060, %2057 ], [ %2118, %2115 ], [ %2176, %2173 ], [ %2224, %2221 ], [ %2272, %2269 ], [ %2331, %2328 ], [ %2371, %2368 ], [ %2411, %2408 ], [ %2451, %2448 ], [ %2499, %2496 ], [ %2547, %2544 ], [ %2595, %2592 ], [ %2641, %2638 ], [ %2679, %2676 ], [ %2728, %2725 ], [ %2776, %2773 ], [ %2810, %2807 ], [ %2844, %2841 ], [ %2874, %2871 ], [ %2891, %2888 ], [ %2913, %2910 ], [ %2927, %2924 ], [ %2938, %2935 ], [ %2954, %2951 ], [ %2984, %2981 ], [ %3046, %3043 ], [ %3108, %3105 ], [ %3140, %3137 ], [ %3186, %3183 ], [ %3238, %3235 ], [ %3290, %3287 ], [ %3342, %3339 ], [ %3394, %3391 ], [ %3436, %3433 ], [ %3487, %3484 ], [ %3508, %3505 ], [ %3738, %3735 ], [ %3858, %3855 ], [ %3926, %3923 ], [ %4009, %4006 ], [ %4036, %4033 ], [ %4051, %4048 ], [ %4066, %4062 ], [ %4077, %4074 ]
  %481 = lshr i32 %477, 7
  %482 = and i32 %481, 255
  %483 = zext i32 %482 to i64
  %484 = getelementptr inbounds %union.StackValue, %union.StackValue* %478, i64 %483
  br label %4080

; <label>:485:                                    ; preds = %4080
  %486 = lshr i32 %4082, 15
  %487 = zext i32 %486 to i64
  %488 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %487
  %489 = bitcast %struct.TValue* %488 to i64*
  %490 = bitcast %union.StackValue* %4081 to i64*
  %491 = load i64, i64* %489, align 8
  store i64 %491, i64* %490, align 8
  %492 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %487, i32 1
  %493 = load i8, i8* %492, align 8, !tbaa !22
  %494 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %493, i8* %494, align 8, !tbaa !22
  %495 = icmp eq i32 %4083, 0
  br i1 %495, label %500, label %496

; <label>:496:                                    ; preds = %485
  %497 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %498 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %499 = getelementptr inbounds %union.StackValue, %union.StackValue* %498, i64 1
  br label %500

; <label>:500:                                    ; preds = %485, %496
  %501 = phi i32 [ %497, %496 ], [ 0, %485 ]
  %502 = phi %union.StackValue* [ %499, %496 ], [ %4085, %485 ]
  %503 = getelementptr inbounds i32, i32* %4084, i64 1
  %504 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:505:                                    ; preds = %4080
  %506 = lshr i32 %4082, 15
  %507 = add nsw i32 %506, -65535
  %508 = sext i32 %507 to i64
  %509 = bitcast %union.StackValue* %4081 to i64*
  store i64 %508, i64* %509, align 8, !tbaa !21
  %510 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %510, align 8, !tbaa !22
  %511 = icmp eq i32 %4083, 0
  br i1 %511, label %516, label %512

; <label>:512:                                    ; preds = %505
  %513 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %514 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %515 = getelementptr inbounds %union.StackValue, %union.StackValue* %514, i64 1
  br label %516

; <label>:516:                                    ; preds = %505, %512
  %517 = phi i32 [ %513, %512 ], [ 0, %505 ]
  %518 = phi %union.StackValue* [ %515, %512 ], [ %4085, %505 ]
  %519 = getelementptr inbounds i32, i32* %4084, i64 1
  %520 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:521:                                    ; preds = %4080
  %522 = lshr i32 %4082, 15
  %523 = add nsw i32 %522, -65535
  %524 = sitofp i32 %523 to double
  %525 = bitcast %union.StackValue* %4081 to double*
  store double %524, double* %525, align 8, !tbaa !21
  %526 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %526, align 8, !tbaa !22
  %527 = icmp eq i32 %4083, 0
  br i1 %527, label %532, label %528

; <label>:528:                                    ; preds = %521
  %529 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %530 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %531 = getelementptr inbounds %union.StackValue, %union.StackValue* %530, i64 1
  br label %532

; <label>:532:                                    ; preds = %521, %528
  %533 = phi i32 [ %529, %528 ], [ 0, %521 ]
  %534 = phi %union.StackValue* [ %531, %528 ], [ %4085, %521 ]
  %535 = getelementptr inbounds i32, i32* %4084, i64 1
  %536 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:537:                                    ; preds = %4080
  %538 = load i32, i32* %4084, align 4, !tbaa !70
  %539 = lshr i32 %538, 7
  %540 = zext i32 %539 to i64
  %541 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %540
  %542 = getelementptr inbounds i32, i32* %4084, i64 1
  %543 = bitcast %struct.TValue* %541 to i64*
  %544 = bitcast %union.StackValue* %4081 to i64*
  %545 = load i64, i64* %543, align 8
  store i64 %545, i64* %544, align 8
  %546 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %540, i32 1
  %547 = load i8, i8* %546, align 8, !tbaa !22
  %548 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %547, i8* %548, align 8, !tbaa !22
  %549 = icmp eq i32 %4083, 0
  br i1 %549, label %554, label %550

; <label>:550:                                    ; preds = %537
  %551 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %542)
  %552 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %553 = getelementptr inbounds %union.StackValue, %union.StackValue* %552, i64 1
  br label %554

; <label>:554:                                    ; preds = %537, %550
  %555 = phi i32 [ %551, %550 ], [ 0, %537 ]
  %556 = phi %union.StackValue* [ %553, %550 ], [ %4085, %537 ]
  %557 = getelementptr inbounds i32, i32* %4084, i64 2
  %558 = load i32, i32* %542, align 4, !tbaa !70
  br label %476

; <label>:559:                                    ; preds = %4080
  %560 = lshr i32 %4082, 16
  %561 = and i32 %560, 255
  %562 = bitcast %union.StackValue* %4081 to i32*
  store i32 %561, i32* %562, align 8, !tbaa !21
  %563 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 1, i8* %563, align 8, !tbaa !22
  %564 = icmp ugt i32 %4082, 16777215
  %565 = getelementptr inbounds i32, i32* %4084, i64 1
  %566 = select i1 %564, i32* %565, i32* %4084
  %567 = icmp eq i32 %4083, 0
  br i1 %567, label %572, label %568

; <label>:568:                                    ; preds = %559
  %569 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %566)
  %570 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %571 = getelementptr inbounds %union.StackValue, %union.StackValue* %570, i64 1
  br label %572

; <label>:572:                                    ; preds = %559, %568
  %573 = phi i32 [ %569, %568 ], [ 0, %559 ]
  %574 = phi %union.StackValue* [ %571, %568 ], [ %4085, %559 ]
  %575 = getelementptr inbounds i32, i32* %566, i64 1
  %576 = load i32, i32* %566, align 4, !tbaa !70
  br label %476

; <label>:577:                                    ; preds = %4080
  %578 = lshr i32 %4082, 16
  %579 = and i32 %578, 255
  br label %580

; <label>:580:                                    ; preds = %580, %577
  %581 = phi i32 [ %579, %577 ], [ %585, %580 ]
  %582 = phi %union.StackValue* [ %4081, %577 ], [ %583, %580 ]
  %583 = getelementptr inbounds %union.StackValue, %union.StackValue* %582, i64 1
  %584 = getelementptr inbounds %union.StackValue, %union.StackValue* %582, i64 0, i32 0, i32 1
  store i8 0, i8* %584, align 8, !tbaa !21
  %585 = add nsw i32 %581, -1
  %586 = icmp eq i32 %581, 0
  br i1 %586, label %587, label %580

; <label>:587:                                    ; preds = %580
  %588 = icmp eq i32 %4083, 0
  br i1 %588, label %593, label %589

; <label>:589:                                    ; preds = %587
  %590 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %4084)
  %591 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %592 = getelementptr inbounds %union.StackValue, %union.StackValue* %591, i64 1
  br label %593

; <label>:593:                                    ; preds = %587, %589
  %594 = phi i32 [ %590, %589 ], [ 0, %587 ]
  %595 = phi %union.StackValue* [ %592, %589 ], [ %4085, %587 ]
  %596 = getelementptr inbounds i32, i32* %4084, i64 1
  %597 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:598:                                    ; preds = %4080
  %599 = lshr i32 %4082, 16
  %600 = and i32 %599, 255
  %601 = zext i32 %600 to i64
  %602 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 6, i64 %601
  %603 = load %struct.UpVal*, %struct.UpVal** %602, align 8, !tbaa !79
  %604 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %603, i64 0, i32 3
  %605 = load %struct.TValue*, %struct.TValue** %604, align 8, !tbaa !50
  %606 = bitcast %struct.TValue* %605 to i64*
  %607 = bitcast %union.StackValue* %4081 to i64*
  %608 = load i64, i64* %606, align 8
  store i64 %608, i64* %607, align 8
  %609 = getelementptr inbounds %struct.TValue, %struct.TValue* %605, i64 0, i32 1
  %610 = load i8, i8* %609, align 8, !tbaa !22
  %611 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %610, i8* %611, align 8, !tbaa !22
  %612 = icmp eq i32 %4083, 0
  br i1 %612, label %617, label %613

; <label>:613:                                    ; preds = %598
  %614 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %615 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %616 = getelementptr inbounds %union.StackValue, %union.StackValue* %615, i64 1
  br label %617

; <label>:617:                                    ; preds = %598, %613
  %618 = phi i32 [ %614, %613 ], [ 0, %598 ]
  %619 = phi %union.StackValue* [ %616, %613 ], [ %4085, %598 ]
  %620 = getelementptr inbounds i32, i32* %4084, i64 1
  %621 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:622:                                    ; preds = %4080
  %623 = lshr i32 %4082, 16
  %624 = and i32 %623, 255
  %625 = zext i32 %624 to i64
  %626 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 6, i64 %625
  %627 = load %struct.UpVal*, %struct.UpVal** %626, align 8, !tbaa !79
  %628 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %627, i64 0, i32 3
  %629 = load %struct.TValue*, %struct.TValue** %628, align 8, !tbaa !50
  %630 = bitcast %union.StackValue* %4081 to i64*
  %631 = bitcast %struct.TValue* %629 to i64*
  %632 = load i64, i64* %630, align 8
  store i64 %632, i64* %631, align 8
  %633 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %634 = load i8, i8* %633, align 8, !tbaa !22
  %635 = getelementptr inbounds %struct.TValue, %struct.TValue* %629, i64 0, i32 1
  store i8 %634, i8* %635, align 8, !tbaa !22
  %636 = load i8, i8* %633, align 8, !tbaa !21
  %637 = and i8 %636, 64
  %638 = icmp eq i8 %637, 0
  br i1 %638, label %653, label %639

; <label>:639:                                    ; preds = %622
  %640 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %627, i64 0, i32 2
  %641 = load i8, i8* %640, align 1, !tbaa !52
  %642 = and i8 %641, 32
  %643 = icmp eq i8 %642, 0
  br i1 %643, label %653, label %644

; <label>:644:                                    ; preds = %639
  %645 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 0, i32 0
  %646 = load %struct.GCObject*, %struct.GCObject** %645, align 8, !tbaa !21
  %647 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %646, i64 0, i32 2
  %648 = load i8, i8* %647, align 1, !tbaa !53
  %649 = and i8 %648, 24
  %650 = icmp eq i8 %649, 0
  br i1 %650, label %653, label %651

; <label>:651:                                    ; preds = %644
  %652 = bitcast %struct.UpVal* %627 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %652, %struct.GCObject* %646)
  br label %653

; <label>:653:                                    ; preds = %644, %639, %622, %651
  %654 = icmp eq i32 %4083, 0
  br i1 %654, label %659, label %655

; <label>:655:                                    ; preds = %653
  %656 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %657 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %658 = getelementptr inbounds %union.StackValue, %union.StackValue* %657, i64 1
  br label %659

; <label>:659:                                    ; preds = %653, %655
  %660 = phi i32 [ %656, %655 ], [ 0, %653 ]
  %661 = phi %union.StackValue* [ %658, %655 ], [ %4085, %653 ]
  %662 = getelementptr inbounds i32, i32* %4084, i64 1
  %663 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:664:                                    ; preds = %4080
  %665 = lshr i32 %4082, 16
  %666 = and i32 %665, 255
  %667 = zext i32 %666 to i64
  %668 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 6, i64 %667
  %669 = load %struct.UpVal*, %struct.UpVal** %668, align 8, !tbaa !79
  %670 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %669, i64 0, i32 3
  %671 = load %struct.TValue*, %struct.TValue** %670, align 8, !tbaa !50
  %672 = lshr i32 %4082, 24
  %673 = zext i32 %672 to i64
  %674 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %673
  %675 = getelementptr inbounds %struct.TValue, %struct.TValue* %671, i64 0, i32 1
  %676 = load i8, i8* %675, align 8, !tbaa !22
  %677 = icmp eq i8 %676, 69
  br i1 %677, label %678, label %694

; <label>:678:                                    ; preds = %664
  %679 = bitcast %struct.TValue* %674 to %struct.TString**
  %680 = load %struct.TString*, %struct.TString** %679, align 8, !tbaa !21
  %681 = bitcast %struct.TValue* %671 to %struct.Table**
  %682 = load %struct.Table*, %struct.Table** %681, align 8, !tbaa !21
  %683 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %682, %struct.TString* %680)
  %684 = getelementptr inbounds %struct.TValue, %struct.TValue* %683, i64 0, i32 1
  %685 = load i8, i8* %684, align 8, !tbaa !22
  %686 = and i8 %685, 15
  %687 = icmp eq i8 %686, 0
  br i1 %687, label %694, label %688

; <label>:688:                                    ; preds = %678
  %689 = bitcast %struct.TValue* %683 to i64*
  %690 = bitcast %union.StackValue* %4081 to i64*
  %691 = load i64, i64* %689, align 8
  store i64 %691, i64* %690, align 8
  %692 = load i8, i8* %684, align 8, !tbaa !22
  %693 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %692, i8* %693, align 8, !tbaa !22
  br label %698

; <label>:694:                                    ; preds = %664, %678
  %695 = phi %struct.TValue* [ %683, %678 ], [ null, %664 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %696 = load i64, i64* %79, align 8, !tbaa !49
  store i64 %696, i64* %81, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %671, %struct.TValue* %674, %union.StackValue* %4081, %struct.TValue* %695)
  %697 = load i32, i32* %83, align 8, !tbaa !21
  br label %698

; <label>:698:                                    ; preds = %694, %688
  %699 = phi i32 [ %4083, %688 ], [ %697, %694 ]
  %700 = icmp eq i32 %699, 0
  br i1 %700, label %705, label %701

; <label>:701:                                    ; preds = %698
  %702 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %703 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %704 = getelementptr inbounds %union.StackValue, %union.StackValue* %703, i64 1
  br label %705

; <label>:705:                                    ; preds = %698, %701
  %706 = phi i32 [ %702, %701 ], [ 0, %698 ]
  %707 = phi %union.StackValue* [ %704, %701 ], [ %4085, %698 ]
  %708 = getelementptr inbounds i32, i32* %4084, i64 1
  %709 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:710:                                    ; preds = %4080
  %711 = lshr i32 %4082, 16
  %712 = and i32 %711, 255
  %713 = zext i32 %712 to i64
  %714 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %713, i32 0
  %715 = lshr i32 %4082, 24
  %716 = zext i32 %715 to i64
  %717 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %716, i32 0
  %718 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %716, i32 0, i32 1
  %719 = load i8, i8* %718, align 8, !tbaa !22
  %720 = icmp eq i8 %719, 35
  br i1 %720, label %721, label %747

; <label>:721:                                    ; preds = %710
  %722 = bitcast %struct.TValue* %717 to i64*
  %723 = load i64, i64* %722, align 8, !tbaa !21
  %724 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %713, i32 0, i32 1
  %725 = load i8, i8* %724, align 8, !tbaa !22
  %726 = icmp eq i8 %725, 69
  br i1 %726, label %727, label %767

; <label>:727:                                    ; preds = %721
  %728 = add i64 %723, -1
  %729 = bitcast %struct.TValue* %714 to %struct.Table**
  %730 = load %struct.Table*, %struct.Table** %729, align 8, !tbaa !21
  %731 = getelementptr inbounds %struct.Table, %struct.Table* %730, i64 0, i32 5
  %732 = load i32, i32* %731, align 4, !tbaa !21
  %733 = zext i32 %732 to i64
  %734 = icmp ult i64 %728, %733
  br i1 %734, label %735, label %739

; <label>:735:                                    ; preds = %727
  %736 = getelementptr inbounds %struct.Table, %struct.Table* %730, i64 0, i32 6
  %737 = load %struct.TValue*, %struct.TValue** %736, align 8, !tbaa !21
  %738 = getelementptr inbounds %struct.TValue, %struct.TValue* %737, i64 %728
  br label %741

; <label>:739:                                    ; preds = %727
  %740 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %730, i64 %723)
  br label %741

; <label>:741:                                    ; preds = %735, %739
  %742 = phi %struct.TValue* [ %738, %735 ], [ %740, %739 ]
  %743 = getelementptr inbounds %struct.TValue, %struct.TValue* %742, i64 0, i32 1
  %744 = load i8, i8* %743, align 8, !tbaa !22
  %745 = and i8 %744, 15
  %746 = icmp eq i8 %745, 0
  br i1 %746, label %767, label %759

; <label>:747:                                    ; preds = %710
  %748 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %713, i32 0, i32 1
  %749 = load i8, i8* %748, align 8, !tbaa !22
  %750 = icmp eq i8 %749, 69
  br i1 %750, label %751, label %767

; <label>:751:                                    ; preds = %747
  %752 = bitcast %struct.TValue* %714 to %struct.Table**
  %753 = load %struct.Table*, %struct.Table** %752, align 8, !tbaa !21
  %754 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %753, %struct.TValue* nonnull %717)
  %755 = getelementptr inbounds %struct.TValue, %struct.TValue* %754, i64 0, i32 1
  %756 = load i8, i8* %755, align 8, !tbaa !22
  %757 = and i8 %756, 15
  %758 = icmp eq i8 %757, 0
  br i1 %758, label %767, label %759

; <label>:759:                                    ; preds = %741, %751
  %760 = phi %struct.TValue* [ %742, %741 ], [ %754, %751 ]
  %761 = bitcast %struct.TValue* %760 to i64*
  %762 = bitcast %union.StackValue* %4081 to i64*
  %763 = load i64, i64* %761, align 8
  store i64 %763, i64* %762, align 8
  %764 = getelementptr inbounds %struct.TValue, %struct.TValue* %760, i64 0, i32 1
  %765 = load i8, i8* %764, align 8, !tbaa !22
  %766 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %765, i8* %766, align 8, !tbaa !22
  br label %771

; <label>:767:                                    ; preds = %721, %747, %741, %751
  %768 = phi %struct.TValue* [ %742, %741 ], [ %754, %751 ], [ null, %747 ], [ null, %721 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %769 = load i64, i64* %85, align 8, !tbaa !49
  store i64 %769, i64* %87, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %714, %struct.TValue* nonnull %717, %union.StackValue* %4081, %struct.TValue* %768)
  %770 = load i32, i32* %89, align 8, !tbaa !21
  br label %771

; <label>:771:                                    ; preds = %767, %759
  %772 = phi i32 [ %4083, %759 ], [ %770, %767 ]
  %773 = icmp eq i32 %772, 0
  br i1 %773, label %778, label %774

; <label>:774:                                    ; preds = %771
  %775 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %776 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %777 = getelementptr inbounds %union.StackValue, %union.StackValue* %776, i64 1
  br label %778

; <label>:778:                                    ; preds = %771, %774
  %779 = phi i32 [ %775, %774 ], [ 0, %771 ]
  %780 = phi %union.StackValue* [ %777, %774 ], [ %4085, %771 ]
  %781 = getelementptr inbounds i32, i32* %4084, i64 1
  %782 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:783:                                    ; preds = %4080
  %784 = lshr i32 %4082, 16
  %785 = and i32 %784, 255
  %786 = zext i32 %785 to i64
  %787 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %786, i32 0
  %788 = lshr i32 %4082, 24
  %789 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %786, i32 0, i32 1
  %790 = load i8, i8* %789, align 8, !tbaa !22
  %791 = icmp eq i8 %790, 69
  br i1 %791, label %792, label %821

; <label>:792:                                    ; preds = %783
  %793 = zext i32 %788 to i64
  %794 = add nsw i64 %793, -1
  %795 = bitcast %struct.TValue* %787 to %struct.Table**
  %796 = load %struct.Table*, %struct.Table** %795, align 8, !tbaa !21
  %797 = getelementptr inbounds %struct.Table, %struct.Table* %796, i64 0, i32 5
  %798 = load i32, i32* %797, align 4, !tbaa !21
  %799 = zext i32 %798 to i64
  %800 = icmp ult i64 %794, %799
  br i1 %800, label %801, label %807

; <label>:801:                                    ; preds = %792
  %802 = getelementptr inbounds %struct.Table, %struct.Table* %796, i64 0, i32 6
  %803 = load %struct.TValue*, %struct.TValue** %802, align 8, !tbaa !21
  %804 = add nsw i32 %788, -1
  %805 = sext i32 %804 to i64
  %806 = getelementptr inbounds %struct.TValue, %struct.TValue* %803, i64 %805
  br label %809

; <label>:807:                                    ; preds = %792
  %808 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %796, i64 %793)
  br label %809

; <label>:809:                                    ; preds = %807, %801
  %810 = phi %struct.TValue* [ %806, %801 ], [ %808, %807 ]
  %811 = getelementptr inbounds %struct.TValue, %struct.TValue* %810, i64 0, i32 1
  %812 = load i8, i8* %811, align 8, !tbaa !22
  %813 = and i8 %812, 15
  %814 = icmp eq i8 %813, 0
  br i1 %814, label %821, label %815

; <label>:815:                                    ; preds = %809
  %816 = bitcast %struct.TValue* %810 to i64*
  %817 = bitcast %union.StackValue* %4081 to i64*
  %818 = load i64, i64* %816, align 8
  store i64 %818, i64* %817, align 8
  %819 = load i8, i8* %811, align 8, !tbaa !22
  %820 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %819, i8* %820, align 8, !tbaa !22
  br label %826

; <label>:821:                                    ; preds = %783, %809
  %822 = phi %struct.TValue* [ %810, %809 ], [ null, %783 ]
  %823 = zext i32 %788 to i64
  store i64 %823, i64* %90, align 8, !tbaa !21
  store i8 35, i8* %91, align 8, !tbaa !22
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %824 = load i64, i64* %93, align 8, !tbaa !49
  store i64 %824, i64* %95, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %787, %struct.TValue* nonnull %3, %union.StackValue* %4081, %struct.TValue* %822)
  %825 = load i32, i32* %97, align 8, !tbaa !21
  br label %826

; <label>:826:                                    ; preds = %821, %815
  %827 = phi i32 [ %4083, %815 ], [ %825, %821 ]
  %828 = icmp eq i32 %827, 0
  br i1 %828, label %833, label %829

; <label>:829:                                    ; preds = %826
  %830 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %831 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %832 = getelementptr inbounds %union.StackValue, %union.StackValue* %831, i64 1
  br label %833

; <label>:833:                                    ; preds = %826, %829
  %834 = phi i32 [ %830, %829 ], [ 0, %826 ]
  %835 = phi %union.StackValue* [ %832, %829 ], [ %4085, %826 ]
  %836 = getelementptr inbounds i32, i32* %4084, i64 1
  %837 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:838:                                    ; preds = %4080
  %839 = lshr i32 %4082, 16
  %840 = and i32 %839, 255
  %841 = zext i32 %840 to i64
  %842 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %841, i32 0
  %843 = lshr i32 %4082, 24
  %844 = zext i32 %843 to i64
  %845 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %844
  %846 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %841, i32 0, i32 1
  %847 = load i8, i8* %846, align 8, !tbaa !22
  %848 = icmp eq i8 %847, 69
  br i1 %848, label %849, label %865

; <label>:849:                                    ; preds = %838
  %850 = bitcast %struct.TValue* %845 to %struct.TString**
  %851 = load %struct.TString*, %struct.TString** %850, align 8, !tbaa !21
  %852 = bitcast %struct.TValue* %842 to %struct.Table**
  %853 = load %struct.Table*, %struct.Table** %852, align 8, !tbaa !21
  %854 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %853, %struct.TString* %851)
  %855 = getelementptr inbounds %struct.TValue, %struct.TValue* %854, i64 0, i32 1
  %856 = load i8, i8* %855, align 8, !tbaa !22
  %857 = and i8 %856, 15
  %858 = icmp eq i8 %857, 0
  br i1 %858, label %865, label %859

; <label>:859:                                    ; preds = %849
  %860 = bitcast %struct.TValue* %854 to i64*
  %861 = bitcast %union.StackValue* %4081 to i64*
  %862 = load i64, i64* %860, align 8
  store i64 %862, i64* %861, align 8
  %863 = load i8, i8* %855, align 8, !tbaa !22
  %864 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %863, i8* %864, align 8, !tbaa !22
  br label %869

; <label>:865:                                    ; preds = %838, %849
  %866 = phi %struct.TValue* [ %854, %849 ], [ null, %838 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %867 = load i64, i64* %99, align 8, !tbaa !49
  store i64 %867, i64* %101, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %842, %struct.TValue* %845, %union.StackValue* %4081, %struct.TValue* %866)
  %868 = load i32, i32* %103, align 8, !tbaa !21
  br label %869

; <label>:869:                                    ; preds = %865, %859
  %870 = phi i32 [ %4083, %859 ], [ %868, %865 ]
  %871 = icmp eq i32 %870, 0
  br i1 %871, label %876, label %872

; <label>:872:                                    ; preds = %869
  %873 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %874 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %875 = getelementptr inbounds %union.StackValue, %union.StackValue* %874, i64 1
  br label %876

; <label>:876:                                    ; preds = %869, %872
  %877 = phi i32 [ %873, %872 ], [ 0, %869 ]
  %878 = phi %union.StackValue* [ %875, %872 ], [ %4085, %869 ]
  %879 = getelementptr inbounds i32, i32* %4084, i64 1
  %880 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:881:                                    ; preds = %4080
  %882 = lshr i32 %4082, 7
  %883 = and i32 %882, 255
  %884 = zext i32 %883 to i64
  %885 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %425, i64 0, i32 6, i64 %884
  %886 = load %struct.UpVal*, %struct.UpVal** %885, align 8, !tbaa !79
  %887 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %886, i64 0, i32 3
  %888 = load %struct.TValue*, %struct.TValue** %887, align 8, !tbaa !50
  %889 = lshr i32 %4082, 16
  %890 = and i32 %889, 255
  %891 = zext i32 %890 to i64
  %892 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %891
  %893 = trunc i32 %4082 to i16
  %894 = icmp slt i16 %893, 0
  %895 = lshr i32 %4082, 24
  %896 = zext i32 %895 to i64
  %897 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %896
  %898 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %896, i32 0
  %899 = select i1 %894, %struct.TValue* %897, %struct.TValue* %898
  %900 = getelementptr inbounds %struct.TValue, %struct.TValue* %888, i64 0, i32 1
  %901 = load i8, i8* %900, align 8, !tbaa !22
  %902 = icmp eq i8 %901, 69
  br i1 %902, label %903, label %937

; <label>:903:                                    ; preds = %881
  %904 = bitcast %struct.TValue* %892 to %struct.TString**
  %905 = load %struct.TString*, %struct.TString** %904, align 8, !tbaa !21
  %906 = getelementptr inbounds %struct.TValue, %struct.TValue* %888, i64 0, i32 0, i32 0
  %907 = bitcast %struct.TValue* %888 to %struct.Table**
  %908 = load %struct.Table*, %struct.Table** %907, align 8, !tbaa !21
  %909 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %908, %struct.TString* %905)
  %910 = getelementptr inbounds %struct.TValue, %struct.TValue* %909, i64 0, i32 1
  %911 = load i8, i8* %910, align 8, !tbaa !22
  %912 = and i8 %911, 15
  %913 = icmp eq i8 %912, 0
  br i1 %913, label %937, label %914

; <label>:914:                                    ; preds = %903
  %915 = bitcast %struct.TValue* %899 to i64*
  %916 = bitcast %struct.TValue* %909 to i64*
  %917 = load i64, i64* %915, align 8
  store i64 %917, i64* %916, align 8
  %918 = getelementptr inbounds %struct.TValue, %struct.TValue* %899, i64 0, i32 1
  %919 = load i8, i8* %918, align 8, !tbaa !22
  store i8 %919, i8* %910, align 8, !tbaa !22
  %920 = load i8, i8* %918, align 8, !tbaa !22
  %921 = and i8 %920, 64
  %922 = icmp eq i8 %921, 0
  br i1 %922, label %941, label %923

; <label>:923:                                    ; preds = %914
  %924 = load %struct.GCObject*, %struct.GCObject** %906, align 8, !tbaa !21
  %925 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %924, i64 0, i32 2
  %926 = load i8, i8* %925, align 1, !tbaa !53
  %927 = and i8 %926, 32
  %928 = icmp eq i8 %927, 0
  br i1 %928, label %941, label %929

; <label>:929:                                    ; preds = %923
  %930 = getelementptr inbounds %struct.TValue, %struct.TValue* %899, i64 0, i32 0, i32 0
  %931 = load %struct.GCObject*, %struct.GCObject** %930, align 8, !tbaa !21
  %932 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %931, i64 0, i32 2
  %933 = load i8, i8* %932, align 1, !tbaa !53
  %934 = and i8 %933, 24
  %935 = icmp eq i8 %934, 0
  br i1 %935, label %941, label %936

; <label>:936:                                    ; preds = %929
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %924)
  br label %941

; <label>:937:                                    ; preds = %881, %903
  %938 = phi %struct.TValue* [ %909, %903 ], [ null, %881 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %939 = load i64, i64* %105, align 8, !tbaa !49
  store i64 %939, i64* %107, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %888, %struct.TValue* %892, %struct.TValue* %899, %struct.TValue* %938)
  %940 = load i32, i32* %109, align 8, !tbaa !21
  br label %941

; <label>:941:                                    ; preds = %929, %923, %914, %936, %937
  %942 = phi i32 [ %4083, %936 ], [ %4083, %929 ], [ %4083, %923 ], [ %4083, %914 ], [ %940, %937 ]
  %943 = icmp eq i32 %942, 0
  br i1 %943, label %948, label %944

; <label>:944:                                    ; preds = %941
  %945 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %946 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %947 = getelementptr inbounds %union.StackValue, %union.StackValue* %946, i64 1
  br label %948

; <label>:948:                                    ; preds = %941, %944
  %949 = phi i32 [ %945, %944 ], [ 0, %941 ]
  %950 = phi %union.StackValue* [ %947, %944 ], [ %4085, %941 ]
  %951 = getelementptr inbounds i32, i32* %4084, i64 1
  %952 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:953:                                    ; preds = %4080
  %954 = lshr i32 %4082, 16
  %955 = and i32 %954, 255
  %956 = zext i32 %955 to i64
  %957 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %956, i32 0
  %958 = trunc i32 %4082 to i16
  %959 = icmp slt i16 %958, 0
  %960 = lshr i32 %4082, 24
  %961 = zext i32 %960 to i64
  %962 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %961
  %963 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %961, i32 0
  %964 = select i1 %959, %struct.TValue* %962, %struct.TValue* %963
  %965 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %956, i32 0, i32 1
  %966 = load i8, i8* %965, align 8, !tbaa !22
  %967 = icmp eq i8 %966, 35
  br i1 %967, label %968, label %994

; <label>:968:                                    ; preds = %953
  %969 = bitcast %struct.TValue* %957 to i64*
  %970 = load i64, i64* %969, align 8, !tbaa !21
  %971 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %972 = load i8, i8* %971, align 8, !tbaa !21
  %973 = icmp eq i8 %972, 69
  br i1 %973, label %974, label %1032

; <label>:974:                                    ; preds = %968
  %975 = add i64 %970, -1
  %976 = bitcast %union.StackValue* %4081 to %struct.Table**
  %977 = load %struct.Table*, %struct.Table** %976, align 8, !tbaa !21
  %978 = getelementptr inbounds %struct.Table, %struct.Table* %977, i64 0, i32 5
  %979 = load i32, i32* %978, align 4, !tbaa !21
  %980 = zext i32 %979 to i64
  %981 = icmp ult i64 %975, %980
  br i1 %981, label %982, label %986

; <label>:982:                                    ; preds = %974
  %983 = getelementptr inbounds %struct.Table, %struct.Table* %977, i64 0, i32 6
  %984 = load %struct.TValue*, %struct.TValue** %983, align 8, !tbaa !21
  %985 = getelementptr inbounds %struct.TValue, %struct.TValue* %984, i64 %975
  br label %988

; <label>:986:                                    ; preds = %974
  %987 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %977, i64 %970)
  br label %988

; <label>:988:                                    ; preds = %982, %986
  %989 = phi %struct.TValue* [ %985, %982 ], [ %987, %986 ]
  %990 = getelementptr inbounds %struct.TValue, %struct.TValue* %989, i64 0, i32 1
  %991 = load i8, i8* %990, align 8, !tbaa !22
  %992 = and i8 %991, 15
  %993 = icmp eq i8 %992, 0
  br i1 %993, label %1032, label %1006

; <label>:994:                                    ; preds = %953
  %995 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %996 = load i8, i8* %995, align 8, !tbaa !21
  %997 = icmp eq i8 %996, 69
  br i1 %997, label %998, label %1032

; <label>:998:                                    ; preds = %994
  %999 = bitcast %union.StackValue* %4081 to %struct.Table**
  %1000 = load %struct.Table*, %struct.Table** %999, align 8, !tbaa !21
  %1001 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %1000, %struct.TValue* %957)
  %1002 = getelementptr inbounds %struct.TValue, %struct.TValue* %1001, i64 0, i32 1
  %1003 = load i8, i8* %1002, align 8, !tbaa !22
  %1004 = and i8 %1003, 15
  %1005 = icmp eq i8 %1004, 0
  br i1 %1005, label %1032, label %1006

; <label>:1006:                                   ; preds = %988, %998
  %1007 = phi %struct.TValue* [ %989, %988 ], [ %1001, %998 ]
  %1008 = bitcast %struct.TValue* %964 to i64*
  %1009 = bitcast %struct.TValue* %1007 to i64*
  %1010 = load i64, i64* %1008, align 8
  store i64 %1010, i64* %1009, align 8
  %1011 = getelementptr inbounds %struct.TValue, %struct.TValue* %964, i64 0, i32 1
  %1012 = load i8, i8* %1011, align 8, !tbaa !22
  %1013 = getelementptr inbounds %struct.TValue, %struct.TValue* %1007, i64 0, i32 1
  store i8 %1012, i8* %1013, align 8, !tbaa !22
  %1014 = load i8, i8* %1011, align 8, !tbaa !22
  %1015 = and i8 %1014, 64
  %1016 = icmp eq i8 %1015, 0
  br i1 %1016, label %1037, label %1017

; <label>:1017:                                   ; preds = %1006
  %1018 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 0, i32 0
  %1019 = load %struct.GCObject*, %struct.GCObject** %1018, align 8, !tbaa !21
  %1020 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1019, i64 0, i32 2
  %1021 = load i8, i8* %1020, align 1, !tbaa !53
  %1022 = and i8 %1021, 32
  %1023 = icmp eq i8 %1022, 0
  br i1 %1023, label %1037, label %1024

; <label>:1024:                                   ; preds = %1017
  %1025 = getelementptr inbounds %struct.TValue, %struct.TValue* %964, i64 0, i32 0, i32 0
  %1026 = load %struct.GCObject*, %struct.GCObject** %1025, align 8, !tbaa !21
  %1027 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1026, i64 0, i32 2
  %1028 = load i8, i8* %1027, align 1, !tbaa !53
  %1029 = and i8 %1028, 24
  %1030 = icmp eq i8 %1029, 0
  br i1 %1030, label %1037, label %1031

; <label>:1031:                                   ; preds = %1024
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %1019)
  br label %1037

; <label>:1032:                                   ; preds = %968, %994, %988, %998
  %1033 = phi %struct.TValue* [ %989, %988 ], [ %1001, %998 ], [ null, %994 ], [ null, %968 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1034 = load i64, i64* %111, align 8, !tbaa !49
  store i64 %1034, i64* %113, align 8, !tbaa !20
  %1035 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %1035, %struct.TValue* %957, %struct.TValue* %964, %struct.TValue* %1033)
  %1036 = load i32, i32* %115, align 8, !tbaa !21
  br label %1037

; <label>:1037:                                   ; preds = %1024, %1017, %1006, %1031, %1032
  %1038 = phi i32 [ %4083, %1031 ], [ %4083, %1024 ], [ %4083, %1017 ], [ %4083, %1006 ], [ %1036, %1032 ]
  %1039 = icmp eq i32 %1038, 0
  br i1 %1039, label %1044, label %1040

; <label>:1040:                                   ; preds = %1037
  %1041 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1042 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1043 = getelementptr inbounds %union.StackValue, %union.StackValue* %1042, i64 1
  br label %1044

; <label>:1044:                                   ; preds = %1037, %1040
  %1045 = phi i32 [ %1041, %1040 ], [ 0, %1037 ]
  %1046 = phi %union.StackValue* [ %1043, %1040 ], [ %4085, %1037 ]
  %1047 = getelementptr inbounds i32, i32* %4084, i64 1
  %1048 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1049:                                   ; preds = %4080
  %1050 = lshr i32 %4082, 16
  %1051 = and i32 %1050, 255
  %1052 = trunc i32 %4082 to i16
  %1053 = icmp slt i16 %1052, 0
  %1054 = lshr i32 %4082, 24
  %1055 = zext i32 %1054 to i64
  %1056 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1055
  %1057 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1055, i32 0
  %1058 = select i1 %1053, %struct.TValue* %1056, %struct.TValue* %1057
  %1059 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %1060 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %1061 = load i8, i8* %1060, align 8, !tbaa !21
  %1062 = icmp eq i8 %1061, 69
  br i1 %1062, label %1063, label %1110

; <label>:1063:                                   ; preds = %1049
  %1064 = zext i32 %1051 to i64
  %1065 = add nsw i64 %1064, -1
  %1066 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 0, i32 0
  %1067 = bitcast %union.StackValue* %4081 to %struct.Table**
  %1068 = load %struct.Table*, %struct.Table** %1067, align 8, !tbaa !21
  %1069 = getelementptr inbounds %struct.Table, %struct.Table* %1068, i64 0, i32 5
  %1070 = load i32, i32* %1069, align 4, !tbaa !21
  %1071 = zext i32 %1070 to i64
  %1072 = icmp ult i64 %1065, %1071
  br i1 %1072, label %1073, label %1079

; <label>:1073:                                   ; preds = %1063
  %1074 = getelementptr inbounds %struct.Table, %struct.Table* %1068, i64 0, i32 6
  %1075 = load %struct.TValue*, %struct.TValue** %1074, align 8, !tbaa !21
  %1076 = add nsw i32 %1051, -1
  %1077 = sext i32 %1076 to i64
  %1078 = getelementptr inbounds %struct.TValue, %struct.TValue* %1075, i64 %1077
  br label %1081

; <label>:1079:                                   ; preds = %1063
  %1080 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %1068, i64 %1064)
  br label %1081

; <label>:1081:                                   ; preds = %1079, %1073
  %1082 = phi %struct.TValue* [ %1078, %1073 ], [ %1080, %1079 ]
  %1083 = getelementptr inbounds %struct.TValue, %struct.TValue* %1082, i64 0, i32 1
  %1084 = load i8, i8* %1083, align 8, !tbaa !22
  %1085 = and i8 %1084, 15
  %1086 = icmp eq i8 %1085, 0
  br i1 %1086, label %1110, label %1087

; <label>:1087:                                   ; preds = %1081
  %1088 = bitcast %struct.TValue* %1058 to i64*
  %1089 = bitcast %struct.TValue* %1082 to i64*
  %1090 = load i64, i64* %1088, align 8
  store i64 %1090, i64* %1089, align 8
  %1091 = getelementptr inbounds %struct.TValue, %struct.TValue* %1058, i64 0, i32 1
  %1092 = load i8, i8* %1091, align 8, !tbaa !22
  store i8 %1092, i8* %1083, align 8, !tbaa !22
  %1093 = load i8, i8* %1091, align 8, !tbaa !22
  %1094 = and i8 %1093, 64
  %1095 = icmp eq i8 %1094, 0
  br i1 %1095, label %1115, label %1096

; <label>:1096:                                   ; preds = %1087
  %1097 = load %struct.GCObject*, %struct.GCObject** %1066, align 8, !tbaa !21
  %1098 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1097, i64 0, i32 2
  %1099 = load i8, i8* %1098, align 1, !tbaa !53
  %1100 = and i8 %1099, 32
  %1101 = icmp eq i8 %1100, 0
  br i1 %1101, label %1115, label %1102

; <label>:1102:                                   ; preds = %1096
  %1103 = getelementptr inbounds %struct.TValue, %struct.TValue* %1058, i64 0, i32 0, i32 0
  %1104 = load %struct.GCObject*, %struct.GCObject** %1103, align 8, !tbaa !21
  %1105 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1104, i64 0, i32 2
  %1106 = load i8, i8* %1105, align 1, !tbaa !53
  %1107 = and i8 %1106, 24
  %1108 = icmp eq i8 %1107, 0
  br i1 %1108, label %1115, label %1109

; <label>:1109:                                   ; preds = %1102
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %1097)
  br label %1115

; <label>:1110:                                   ; preds = %1049, %1081
  %1111 = phi %struct.TValue* [ %1082, %1081 ], [ null, %1049 ]
  %1112 = zext i32 %1051 to i64
  store i64 %1112, i64* %116, align 8, !tbaa !21
  store i8 35, i8* %117, align 8, !tbaa !22
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1113 = load i64, i64* %119, align 8, !tbaa !49
  store i64 %1113, i64* %121, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %1059, %struct.TValue* nonnull %4, %struct.TValue* %1058, %struct.TValue* %1111)
  %1114 = load i32, i32* %123, align 8, !tbaa !21
  br label %1115

; <label>:1115:                                   ; preds = %1102, %1096, %1087, %1109, %1110
  %1116 = phi i32 [ %4083, %1109 ], [ %4083, %1102 ], [ %4083, %1096 ], [ %4083, %1087 ], [ %1114, %1110 ]
  %1117 = icmp eq i32 %1116, 0
  br i1 %1117, label %1122, label %1118

; <label>:1118:                                   ; preds = %1115
  %1119 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1120 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1121 = getelementptr inbounds %union.StackValue, %union.StackValue* %1120, i64 1
  br label %1122

; <label>:1122:                                   ; preds = %1115, %1118
  %1123 = phi i32 [ %1119, %1118 ], [ 0, %1115 ]
  %1124 = phi %union.StackValue* [ %1121, %1118 ], [ %4085, %1115 ]
  %1125 = getelementptr inbounds i32, i32* %4084, i64 1
  %1126 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1127:                                   ; preds = %4080
  %1128 = lshr i32 %4082, 16
  %1129 = and i32 %1128, 255
  %1130 = zext i32 %1129 to i64
  %1131 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1130
  %1132 = trunc i32 %4082 to i16
  %1133 = icmp slt i16 %1132, 0
  %1134 = lshr i32 %4082, 24
  %1135 = zext i32 %1134 to i64
  %1136 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1135
  %1137 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1135, i32 0
  %1138 = select i1 %1133, %struct.TValue* %1136, %struct.TValue* %1137
  %1139 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %1140 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %1141 = load i8, i8* %1140, align 8, !tbaa !21
  %1142 = icmp eq i8 %1141, 69
  br i1 %1142, label %1143, label %1177

; <label>:1143:                                   ; preds = %1127
  %1144 = bitcast %struct.TValue* %1131 to %struct.TString**
  %1145 = load %struct.TString*, %struct.TString** %1144, align 8, !tbaa !21
  %1146 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 0, i32 0
  %1147 = bitcast %union.StackValue* %4081 to %struct.Table**
  %1148 = load %struct.Table*, %struct.Table** %1147, align 8, !tbaa !21
  %1149 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %1148, %struct.TString* %1145)
  %1150 = getelementptr inbounds %struct.TValue, %struct.TValue* %1149, i64 0, i32 1
  %1151 = load i8, i8* %1150, align 8, !tbaa !22
  %1152 = and i8 %1151, 15
  %1153 = icmp eq i8 %1152, 0
  br i1 %1153, label %1177, label %1154

; <label>:1154:                                   ; preds = %1143
  %1155 = bitcast %struct.TValue* %1138 to i64*
  %1156 = bitcast %struct.TValue* %1149 to i64*
  %1157 = load i64, i64* %1155, align 8
  store i64 %1157, i64* %1156, align 8
  %1158 = getelementptr inbounds %struct.TValue, %struct.TValue* %1138, i64 0, i32 1
  %1159 = load i8, i8* %1158, align 8, !tbaa !22
  store i8 %1159, i8* %1150, align 8, !tbaa !22
  %1160 = load i8, i8* %1158, align 8, !tbaa !22
  %1161 = and i8 %1160, 64
  %1162 = icmp eq i8 %1161, 0
  br i1 %1162, label %1181, label %1163

; <label>:1163:                                   ; preds = %1154
  %1164 = load %struct.GCObject*, %struct.GCObject** %1146, align 8, !tbaa !21
  %1165 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1164, i64 0, i32 2
  %1166 = load i8, i8* %1165, align 1, !tbaa !53
  %1167 = and i8 %1166, 32
  %1168 = icmp eq i8 %1167, 0
  br i1 %1168, label %1181, label %1169

; <label>:1169:                                   ; preds = %1163
  %1170 = getelementptr inbounds %struct.TValue, %struct.TValue* %1138, i64 0, i32 0, i32 0
  %1171 = load %struct.GCObject*, %struct.GCObject** %1170, align 8, !tbaa !21
  %1172 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1171, i64 0, i32 2
  %1173 = load i8, i8* %1172, align 1, !tbaa !53
  %1174 = and i8 %1173, 24
  %1175 = icmp eq i8 %1174, 0
  br i1 %1175, label %1181, label %1176

; <label>:1176:                                   ; preds = %1169
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %1164)
  br label %1181

; <label>:1177:                                   ; preds = %1127, %1143
  %1178 = phi %struct.TValue* [ %1149, %1143 ], [ null, %1127 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1179 = load i64, i64* %125, align 8, !tbaa !49
  store i64 %1179, i64* %127, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %1139, %struct.TValue* %1131, %struct.TValue* %1138, %struct.TValue* %1178)
  %1180 = load i32, i32* %129, align 8, !tbaa !21
  br label %1181

; <label>:1181:                                   ; preds = %1169, %1163, %1154, %1176, %1177
  %1182 = phi i32 [ %4083, %1176 ], [ %4083, %1169 ], [ %4083, %1163 ], [ %4083, %1154 ], [ %1180, %1177 ]
  %1183 = icmp eq i32 %1182, 0
  br i1 %1183, label %1188, label %1184

; <label>:1184:                                   ; preds = %1181
  %1185 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1186 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1187 = getelementptr inbounds %union.StackValue, %union.StackValue* %1186, i64 1
  br label %1188

; <label>:1188:                                   ; preds = %1181, %1184
  %1189 = phi i32 [ %1185, %1184 ], [ 0, %1181 ]
  %1190 = phi %union.StackValue* [ %1187, %1184 ], [ %4085, %1181 ]
  %1191 = getelementptr inbounds i32, i32* %4084, i64 1
  %1192 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1193:                                   ; preds = %4080
  %1194 = lshr i32 %4082, 16
  %1195 = and i32 %1194, 255
  %1196 = lshr i32 %4082, 24
  %1197 = load i64, i64* %32, align 8, !tbaa !49
  store i64 %1197, i64* %34, align 8, !tbaa !20
  %1198 = call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %1199 = bitcast %union.StackValue* %4081 to %struct.Table**
  store %struct.Table* %1198, %struct.Table** %1199, align 8, !tbaa !21
  %1200 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 69, i8* %1200, align 8, !tbaa !22
  %1201 = or i32 %1195, %1196
  %1202 = icmp eq i32 %1201, 0
  br i1 %1202, label %1206, label %1203

; <label>:1203:                                   ; preds = %1193
  %1204 = call fastcc i32 @luaO_fb2int(i32 %1195)
  %1205 = call fastcc i32 @luaO_fb2int(i32 %1196)
  call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %1198, i32 %1204, i32 %1205)
  br label %1206

; <label>:1206:                                   ; preds = %1193, %1203
  %1207 = load %struct.global_State*, %struct.global_State** %130, align 8, !tbaa !2
  %1208 = getelementptr inbounds %struct.global_State, %struct.global_State* %1207, i64 0, i32 3
  %1209 = load i64, i64* %1208, align 8, !tbaa !11
  %1210 = icmp sgt i64 %1209, 0
  br i1 %1210, label %1211, label %1214

; <label>:1211:                                   ; preds = %1206
  %1212 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1
  store %union.StackValue* %1212, %union.StackValue** %33, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  %1213 = load i32, i32* %359, align 8, !tbaa !21
  br label %1214

; <label>:1214:                                   ; preds = %1211, %1206
  %1215 = phi i32 [ %1213, %1211 ], [ %4083, %1206 ]
  %1216 = icmp eq i32 %1215, 0
  br i1 %1216, label %1221, label %1217

; <label>:1217:                                   ; preds = %1214
  %1218 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %1219 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1220 = getelementptr inbounds %union.StackValue, %union.StackValue* %1219, i64 1
  br label %1221

; <label>:1221:                                   ; preds = %1214, %1217
  %1222 = phi i32 [ %1218, %1217 ], [ 0, %1214 ]
  %1223 = phi %union.StackValue* [ %1220, %1217 ], [ %4085, %1214 ]
  %1224 = getelementptr inbounds i32, i32* %4084, i64 1
  %1225 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1226:                                   ; preds = %4080
  %1227 = lshr i32 %4082, 16
  %1228 = and i32 %1227, 255
  %1229 = zext i32 %1228 to i64
  %1230 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1229, i32 0
  %1231 = trunc i32 %4082 to i16
  %1232 = icmp slt i16 %1231, 0
  %1233 = lshr i32 %4082, 24
  %1234 = zext i32 %1233 to i64
  %1235 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1234
  %1236 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1234, i32 0
  %1237 = select i1 %1232, %struct.TValue* %1235, %struct.TValue* %1236
  %1238 = bitcast %struct.TValue* %1237 to %struct.TString**
  %1239 = load %struct.TString*, %struct.TString** %1238, align 8, !tbaa !21
  %1240 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0
  %1241 = bitcast %struct.TValue* %1230 to i64*
  %1242 = bitcast %struct.TValue* %1240 to i64*
  %1243 = load i64, i64* %1241, align 8
  store i64 %1243, i64* %1242, align 8
  %1244 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1229, i32 0, i32 1
  %1245 = load i8, i8* %1244, align 8, !tbaa !22
  %1246 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0, i32 1
  store i8 %1245, i8* %1246, align 8, !tbaa !22
  %1247 = load i8, i8* %1244, align 8, !tbaa !22
  %1248 = icmp eq i8 %1247, 69
  br i1 %1248, label %1249, label %1263

; <label>:1249:                                   ; preds = %1226
  %1250 = bitcast %struct.TValue* %1230 to %struct.Table**
  %1251 = load %struct.Table*, %struct.Table** %1250, align 8, !tbaa !21
  %1252 = call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %1251, %struct.TString* %1239)
  %1253 = getelementptr inbounds %struct.TValue, %struct.TValue* %1252, i64 0, i32 1
  %1254 = load i8, i8* %1253, align 8, !tbaa !22
  %1255 = and i8 %1254, 15
  %1256 = icmp eq i8 %1255, 0
  br i1 %1256, label %1263, label %1257

; <label>:1257:                                   ; preds = %1249
  %1258 = bitcast %struct.TValue* %1252 to i64*
  %1259 = bitcast %union.StackValue* %4081 to i64*
  %1260 = load i64, i64* %1258, align 8
  store i64 %1260, i64* %1259, align 8
  %1261 = load i8, i8* %1253, align 8, !tbaa !22
  %1262 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %1261, i8* %1262, align 8, !tbaa !22
  br label %1267

; <label>:1263:                                   ; preds = %1226, %1249
  %1264 = phi %struct.TValue* [ %1252, %1249 ], [ null, %1226 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1265 = load i64, i64* %132, align 8, !tbaa !49
  store i64 %1265, i64* %134, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %1230, %struct.TValue* %1237, %union.StackValue* nonnull %4081, %struct.TValue* %1264)
  %1266 = load i32, i32* %136, align 8, !tbaa !21
  br label %1267

; <label>:1267:                                   ; preds = %1263, %1257
  %1268 = phi i32 [ %4083, %1257 ], [ %1266, %1263 ]
  %1269 = icmp eq i32 %1268, 0
  br i1 %1269, label %1274, label %1270

; <label>:1270:                                   ; preds = %1267
  %1271 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1272 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1273 = getelementptr inbounds %union.StackValue, %union.StackValue* %1272, i64 1
  br label %1274

; <label>:1274:                                   ; preds = %1267, %1270
  %1275 = phi i32 [ %1271, %1270 ], [ 0, %1267 ]
  %1276 = phi %union.StackValue* [ %1273, %1270 ], [ %4085, %1267 ]
  %1277 = getelementptr inbounds i32, i32* %4084, i64 1
  %1278 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1279:                                   ; preds = %4080
  %1280 = lshr i32 %4082, 16
  %1281 = and i32 %1280, 255
  %1282 = zext i32 %1281 to i64
  %1283 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1282, i32 0
  %1284 = lshr i32 %4082, 24
  %1285 = add nsw i32 %1284, -127
  %1286 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1282, i32 0, i32 1
  %1287 = load i8, i8* %1286, align 8, !tbaa !22
  switch i8 %1287, label %1302 [
    i8 35, label %1288
    i8 19, label %1295
  ]

; <label>:1288:                                   ; preds = %1279
  %1289 = bitcast %struct.TValue* %1283 to i64*
  %1290 = load i64, i64* %1289, align 8, !tbaa !21
  %1291 = sext i32 %1285 to i64
  %1292 = add i64 %1290, %1291
  %1293 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1292, i64* %1293, align 8, !tbaa !21
  %1294 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1294, align 8, !tbaa !22
  br label %1308

; <label>:1295:                                   ; preds = %1279
  %1296 = bitcast %struct.TValue* %1283 to double*
  %1297 = load double, double* %1296, align 8, !tbaa !21
  %1298 = sitofp i32 %1285 to double
  %1299 = fadd double %1297, %1298
  %1300 = bitcast %union.StackValue* %4081 to double*
  store double %1299, double* %1300, align 8, !tbaa !21
  %1301 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1301, align 8, !tbaa !22
  br label %1308

; <label>:1302:                                   ; preds = %1279
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1303 = load i64, i64* %138, align 8, !tbaa !49
  store i64 %1303, i64* %140, align 8, !tbaa !20
  %1304 = sext i32 %1285 to i64
  %1305 = lshr i32 %4082, 15
  %1306 = and i32 %1305, 1
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1283, i64 %1304, i32 %1306, %union.StackValue* %4081, i32 6)
  %1307 = load i32, i32* %142, align 8, !tbaa !21
  br label %1308

; <label>:1308:                                   ; preds = %1295, %1302, %1288
  %1309 = phi i32 [ %4083, %1288 ], [ %4083, %1295 ], [ %1307, %1302 ]
  %1310 = icmp eq i32 %1309, 0
  br i1 %1310, label %1315, label %1311

; <label>:1311:                                   ; preds = %1308
  %1312 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1313 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1314 = getelementptr inbounds %union.StackValue, %union.StackValue* %1313, i64 1
  br label %1315

; <label>:1315:                                   ; preds = %1308, %1311
  %1316 = phi i32 [ %1312, %1311 ], [ 0, %1308 ]
  %1317 = phi %union.StackValue* [ %1314, %1311 ], [ %4085, %1308 ]
  %1318 = getelementptr inbounds i32, i32* %4084, i64 1
  %1319 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1320:                                   ; preds = %4080
  %1321 = lshr i32 %4082, 16
  %1322 = and i32 %1321, 255
  %1323 = zext i32 %1322 to i64
  %1324 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1323, i32 0
  %1325 = lshr i32 %4082, 24
  %1326 = add nsw i32 %1325, -127
  %1327 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1323, i32 0, i32 1
  %1328 = load i8, i8* %1327, align 8, !tbaa !22
  switch i8 %1328, label %1343 [
    i8 35, label %1329
    i8 19, label %1336
  ]

; <label>:1329:                                   ; preds = %1320
  %1330 = bitcast %struct.TValue* %1324 to i64*
  %1331 = load i64, i64* %1330, align 8, !tbaa !21
  %1332 = sext i32 %1326 to i64
  %1333 = sub i64 %1331, %1332
  %1334 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1333, i64* %1334, align 8, !tbaa !21
  %1335 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1335, align 8, !tbaa !22
  br label %1347

; <label>:1336:                                   ; preds = %1320
  %1337 = bitcast %struct.TValue* %1324 to double*
  %1338 = load double, double* %1337, align 8, !tbaa !21
  %1339 = sitofp i32 %1326 to double
  %1340 = fsub double %1338, %1339
  %1341 = bitcast %union.StackValue* %4081 to double*
  store double %1340, double* %1341, align 8, !tbaa !21
  %1342 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1342, align 8, !tbaa !22
  br label %1347

; <label>:1343:                                   ; preds = %1320
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1344 = load i64, i64* %144, align 8, !tbaa !49
  store i64 %1344, i64* %146, align 8, !tbaa !20
  %1345 = sext i32 %1326 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1324, i64 %1345, i32 0, %union.StackValue* %4081, i32 7)
  %1346 = load i32, i32* %148, align 8, !tbaa !21
  br label %1347

; <label>:1347:                                   ; preds = %1336, %1343, %1329
  %1348 = phi i32 [ %4083, %1329 ], [ %4083, %1336 ], [ %1346, %1343 ]
  %1349 = icmp eq i32 %1348, 0
  br i1 %1349, label %1354, label %1350

; <label>:1350:                                   ; preds = %1347
  %1351 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1352 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1353 = getelementptr inbounds %union.StackValue, %union.StackValue* %1352, i64 1
  br label %1354

; <label>:1354:                                   ; preds = %1347, %1350
  %1355 = phi i32 [ %1351, %1350 ], [ 0, %1347 ]
  %1356 = phi %union.StackValue* [ %1353, %1350 ], [ %4085, %1347 ]
  %1357 = getelementptr inbounds i32, i32* %4084, i64 1
  %1358 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1359:                                   ; preds = %4080
  %1360 = lshr i32 %4082, 16
  %1361 = and i32 %1360, 255
  %1362 = zext i32 %1361 to i64
  %1363 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1362, i32 0
  %1364 = lshr i32 %4082, 24
  %1365 = add nsw i32 %1364, -127
  %1366 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1362, i32 0, i32 1
  %1367 = load i8, i8* %1366, align 8, !tbaa !22
  switch i8 %1367, label %1382 [
    i8 35, label %1368
    i8 19, label %1375
  ]

; <label>:1368:                                   ; preds = %1359
  %1369 = bitcast %struct.TValue* %1363 to i64*
  %1370 = load i64, i64* %1369, align 8, !tbaa !21
  %1371 = sext i32 %1365 to i64
  %1372 = mul i64 %1370, %1371
  %1373 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1372, i64* %1373, align 8, !tbaa !21
  %1374 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1374, align 8, !tbaa !22
  br label %1388

; <label>:1375:                                   ; preds = %1359
  %1376 = bitcast %struct.TValue* %1363 to double*
  %1377 = load double, double* %1376, align 8, !tbaa !21
  %1378 = sitofp i32 %1365 to double
  %1379 = fmul double %1377, %1378
  %1380 = bitcast %union.StackValue* %4081 to double*
  store double %1379, double* %1380, align 8, !tbaa !21
  %1381 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1381, align 8, !tbaa !22
  br label %1388

; <label>:1382:                                   ; preds = %1359
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1383 = load i64, i64* %150, align 8, !tbaa !49
  store i64 %1383, i64* %152, align 8, !tbaa !20
  %1384 = sext i32 %1365 to i64
  %1385 = lshr i32 %4082, 15
  %1386 = and i32 %1385, 1
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1363, i64 %1384, i32 %1386, %union.StackValue* %4081, i32 8)
  %1387 = load i32, i32* %154, align 8, !tbaa !21
  br label %1388

; <label>:1388:                                   ; preds = %1375, %1382, %1368
  %1389 = phi i32 [ %4083, %1368 ], [ %4083, %1375 ], [ %1387, %1382 ]
  %1390 = icmp eq i32 %1389, 0
  br i1 %1390, label %1395, label %1391

; <label>:1391:                                   ; preds = %1388
  %1392 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1393 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1394 = getelementptr inbounds %union.StackValue, %union.StackValue* %1393, i64 1
  br label %1395

; <label>:1395:                                   ; preds = %1388, %1391
  %1396 = phi i32 [ %1392, %1391 ], [ 0, %1388 ]
  %1397 = phi %union.StackValue* [ %1394, %1391 ], [ %4085, %1388 ]
  %1398 = getelementptr inbounds i32, i32* %4084, i64 1
  %1399 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1400:                                   ; preds = %4080
  %1401 = lshr i32 %4082, 16
  %1402 = and i32 %1401, 255
  %1403 = zext i32 %1402 to i64
  %1404 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1403, i32 0
  %1405 = lshr i32 %4082, 24
  %1406 = add nsw i32 %1405, -127
  %1407 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1403, i32 0, i32 1
  %1408 = load i8, i8* %1407, align 8, !tbaa !22
  switch i8 %1408, label %1423 [
    i8 35, label %1409
    i8 19, label %1416
  ]

; <label>:1409:                                   ; preds = %1400
  %1410 = bitcast %struct.TValue* %1404 to i64*
  %1411 = load i64, i64* %1410, align 8, !tbaa !21
  %1412 = sext i32 %1406 to i64
  %1413 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1411, i64 %1412)
  %1414 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1413, i64* %1414, align 8, !tbaa !21
  %1415 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1415, align 8, !tbaa !22
  br label %1427

; <label>:1416:                                   ; preds = %1400
  %1417 = bitcast %struct.TValue* %1404 to double*
  %1418 = load double, double* %1417, align 8, !tbaa !21
  %1419 = sitofp i32 %1406 to double
  %1420 = call fastcc double @luaV_modf(double %1418, double %1419)
  %1421 = bitcast %union.StackValue* %4081 to double*
  store double %1420, double* %1421, align 8, !tbaa !21
  %1422 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1422, align 8, !tbaa !22
  br label %1427

; <label>:1423:                                   ; preds = %1400
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1424 = load i64, i64* %156, align 8, !tbaa !49
  store i64 %1424, i64* %158, align 8, !tbaa !20
  %1425 = sext i32 %1406 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1404, i64 %1425, i32 0, %union.StackValue* %4081, i32 9)
  %1426 = load i32, i32* %160, align 8, !tbaa !21
  br label %1427

; <label>:1427:                                   ; preds = %1416, %1423, %1409
  %1428 = phi i32 [ %4083, %1409 ], [ %4083, %1416 ], [ %1426, %1423 ]
  %1429 = icmp eq i32 %1428, 0
  br i1 %1429, label %1434, label %1430

; <label>:1430:                                   ; preds = %1427
  %1431 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1432 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1433 = getelementptr inbounds %union.StackValue, %union.StackValue* %1432, i64 1
  br label %1434

; <label>:1434:                                   ; preds = %1427, %1430
  %1435 = phi i32 [ %1431, %1430 ], [ 0, %1427 ]
  %1436 = phi %union.StackValue* [ %1433, %1430 ], [ %4085, %1427 ]
  %1437 = getelementptr inbounds i32, i32* %4084, i64 1
  %1438 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1439:                                   ; preds = %4080
  %1440 = lshr i32 %4082, 16
  %1441 = and i32 %1440, 255
  %1442 = zext i32 %1441 to i64
  %1443 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1442, i32 0
  %1444 = lshr i32 %4082, 24
  %1445 = add nsw i32 %1444, -127
  %1446 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1442, i32 0, i32 1
  %1447 = load i8, i8* %1446, align 8, !tbaa !22
  switch i8 %1447, label %1461 [
    i8 19, label %1448
    i8 35, label %1451
  ]

; <label>:1448:                                   ; preds = %1439
  %1449 = bitcast %struct.TValue* %1443 to double*
  %1450 = load double, double* %1449, align 8, !tbaa !21
  br label %1455

; <label>:1451:                                   ; preds = %1439
  %1452 = bitcast %struct.TValue* %1443 to i64*
  %1453 = load i64, i64* %1452, align 8, !tbaa !21
  %1454 = sitofp i64 %1453 to double
  br label %1455

; <label>:1455:                                   ; preds = %1448, %1451
  %1456 = phi double [ %1450, %1448 ], [ %1454, %1451 ]
  %1457 = sitofp i32 %1445 to double
  %1458 = call double @pow(double %1456, double %1457) #7
  %1459 = bitcast %union.StackValue* %4081 to double*
  store double %1458, double* %1459, align 8, !tbaa !21
  %1460 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1460, align 8, !tbaa !22
  br label %1465

; <label>:1461:                                   ; preds = %1439
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1462 = load i64, i64* %162, align 8, !tbaa !49
  store i64 %1462, i64* %164, align 8, !tbaa !20
  %1463 = sext i32 %1445 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1443, i64 %1463, i32 0, %union.StackValue* %4081, i32 10)
  %1464 = load i32, i32* %166, align 8, !tbaa !21
  br label %1465

; <label>:1465:                                   ; preds = %1461, %1455
  %1466 = phi i32 [ %4083, %1455 ], [ %1464, %1461 ]
  %1467 = icmp eq i32 %1466, 0
  br i1 %1467, label %1472, label %1468

; <label>:1468:                                   ; preds = %1465
  %1469 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1470 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1471 = getelementptr inbounds %union.StackValue, %union.StackValue* %1470, i64 1
  br label %1472

; <label>:1472:                                   ; preds = %1465, %1468
  %1473 = phi i32 [ %1469, %1468 ], [ 0, %1465 ]
  %1474 = phi %union.StackValue* [ %1471, %1468 ], [ %4085, %1465 ]
  %1475 = getelementptr inbounds i32, i32* %4084, i64 1
  %1476 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1477:                                   ; preds = %4080
  %1478 = lshr i32 %4082, 16
  %1479 = and i32 %1478, 255
  %1480 = zext i32 %1479 to i64
  %1481 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1480, i32 0
  %1482 = lshr i32 %4082, 24
  %1483 = add nsw i32 %1482, -127
  %1484 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1480, i32 0, i32 1
  %1485 = load i8, i8* %1484, align 8, !tbaa !22
  switch i8 %1485, label %1499 [
    i8 19, label %1486
    i8 35, label %1489
  ]

; <label>:1486:                                   ; preds = %1477
  %1487 = bitcast %struct.TValue* %1481 to double*
  %1488 = load double, double* %1487, align 8, !tbaa !21
  br label %1493

; <label>:1489:                                   ; preds = %1477
  %1490 = bitcast %struct.TValue* %1481 to i64*
  %1491 = load i64, i64* %1490, align 8, !tbaa !21
  %1492 = sitofp i64 %1491 to double
  br label %1493

; <label>:1493:                                   ; preds = %1486, %1489
  %1494 = phi double [ %1488, %1486 ], [ %1492, %1489 ]
  %1495 = sitofp i32 %1483 to double
  %1496 = fdiv double %1494, %1495
  %1497 = bitcast %union.StackValue* %4081 to double*
  store double %1496, double* %1497, align 8, !tbaa !21
  %1498 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1498, align 8, !tbaa !22
  br label %1503

; <label>:1499:                                   ; preds = %1477
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1500 = load i64, i64* %168, align 8, !tbaa !49
  store i64 %1500, i64* %170, align 8, !tbaa !20
  %1501 = sext i32 %1483 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1481, i64 %1501, i32 0, %union.StackValue* %4081, i32 11)
  %1502 = load i32, i32* %172, align 8, !tbaa !21
  br label %1503

; <label>:1503:                                   ; preds = %1499, %1493
  %1504 = phi i32 [ %4083, %1493 ], [ %1502, %1499 ]
  %1505 = icmp eq i32 %1504, 0
  br i1 %1505, label %1510, label %1506

; <label>:1506:                                   ; preds = %1503
  %1507 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1508 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1509 = getelementptr inbounds %union.StackValue, %union.StackValue* %1508, i64 1
  br label %1510

; <label>:1510:                                   ; preds = %1503, %1506
  %1511 = phi i32 [ %1507, %1506 ], [ 0, %1503 ]
  %1512 = phi %union.StackValue* [ %1509, %1506 ], [ %4085, %1503 ]
  %1513 = getelementptr inbounds i32, i32* %4084, i64 1
  %1514 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1515:                                   ; preds = %4080
  %1516 = lshr i32 %4082, 16
  %1517 = and i32 %1516, 255
  %1518 = zext i32 %1517 to i64
  %1519 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1518, i32 0
  %1520 = lshr i32 %4082, 24
  %1521 = add nsw i32 %1520, -127
  %1522 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1518, i32 0, i32 1
  %1523 = load i8, i8* %1522, align 8, !tbaa !22
  switch i8 %1523, label %1539 [
    i8 35, label %1524
    i8 19, label %1531
  ]

; <label>:1524:                                   ; preds = %1515
  %1525 = bitcast %struct.TValue* %1519 to i64*
  %1526 = load i64, i64* %1525, align 8, !tbaa !21
  %1527 = sext i32 %1521 to i64
  %1528 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1526, i64 %1527)
  %1529 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1528, i64* %1529, align 8, !tbaa !21
  %1530 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1530, align 8, !tbaa !22
  br label %1543

; <label>:1531:                                   ; preds = %1515
  %1532 = bitcast %struct.TValue* %1519 to double*
  %1533 = load double, double* %1532, align 8, !tbaa !21
  %1534 = sitofp i32 %1521 to double
  %1535 = fdiv double %1533, %1534
  %1536 = call double @llvm.floor.f64(double %1535)
  %1537 = bitcast %union.StackValue* %4081 to double*
  store double %1536, double* %1537, align 8, !tbaa !21
  %1538 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1538, align 8, !tbaa !22
  br label %1543

; <label>:1539:                                   ; preds = %1515
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1540 = load i64, i64* %174, align 8, !tbaa !49
  store i64 %1540, i64* %176, align 8, !tbaa !20
  %1541 = sext i32 %1521 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %1519, i64 %1541, i32 0, %union.StackValue* %4081, i32 12)
  %1542 = load i32, i32* %178, align 8, !tbaa !21
  br label %1543

; <label>:1543:                                   ; preds = %1531, %1539, %1524
  %1544 = phi i32 [ %4083, %1524 ], [ %4083, %1531 ], [ %1542, %1539 ]
  %1545 = icmp eq i32 %1544, 0
  br i1 %1545, label %1550, label %1546

; <label>:1546:                                   ; preds = %1543
  %1547 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1548 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1549 = getelementptr inbounds %union.StackValue, %union.StackValue* %1548, i64 1
  br label %1550

; <label>:1550:                                   ; preds = %1543, %1546
  %1551 = phi i32 [ %1547, %1546 ], [ 0, %1543 ]
  %1552 = phi %union.StackValue* [ %1549, %1546 ], [ %4085, %1543 ]
  %1553 = getelementptr inbounds i32, i32* %4084, i64 1
  %1554 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1555:                                   ; preds = %4080
  %1556 = lshr i32 %4082, 16
  %1557 = and i32 %1556, 255
  %1558 = zext i32 %1557 to i64
  %1559 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1558, i32 0
  %1560 = lshr i32 %4082, 24
  %1561 = zext i32 %1560 to i64
  %1562 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1561
  %1563 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1558, i32 0, i32 1
  %1564 = load i8, i8* %1563, align 8, !tbaa !22
  switch i8 %1564, label %1598 [
    i8 35, label %1565
    i8 19, label %1577
  ]

; <label>:1565:                                   ; preds = %1555
  %1566 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1561, i32 1
  %1567 = load i8, i8* %1566, align 8, !tbaa !22
  %1568 = icmp eq i8 %1567, 35
  %1569 = bitcast %struct.TValue* %1559 to i64*
  %1570 = load i64, i64* %1569, align 8, !tbaa !21
  br i1 %1568, label %1571, label %1580

; <label>:1571:                                   ; preds = %1565
  %1572 = bitcast %struct.TValue* %1562 to i64*
  %1573 = load i64, i64* %1572, align 8, !tbaa !21
  %1574 = add i64 %1573, %1570
  %1575 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1574, i64* %1575, align 8, !tbaa !21
  %1576 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1576, align 8, !tbaa !22
  br label %1603

; <label>:1577:                                   ; preds = %1555
  %1578 = bitcast %struct.TValue* %1559 to double*
  %1579 = load double, double* %1578, align 8, !tbaa !21
  br label %1582

; <label>:1580:                                   ; preds = %1565
  %1581 = sitofp i64 %1570 to double
  br label %1582

; <label>:1582:                                   ; preds = %1577, %1580
  %1583 = phi double [ %1579, %1577 ], [ %1581, %1580 ]
  %1584 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1561, i32 1
  %1585 = load i8, i8* %1584, align 8, !tbaa !22
  switch i8 %1585, label %1598 [
    i8 19, label %1586
    i8 35, label %1589
  ]

; <label>:1586:                                   ; preds = %1582
  %1587 = bitcast %struct.TValue* %1562 to double*
  %1588 = load double, double* %1587, align 8, !tbaa !21
  br label %1593

; <label>:1589:                                   ; preds = %1582
  %1590 = bitcast %struct.TValue* %1562 to i64*
  %1591 = load i64, i64* %1590, align 8, !tbaa !21
  %1592 = sitofp i64 %1591 to double
  br label %1593

; <label>:1593:                                   ; preds = %1586, %1589
  %1594 = phi double [ %1588, %1586 ], [ %1592, %1589 ]
  %1595 = fadd double %1583, %1594
  %1596 = bitcast %union.StackValue* %4081 to double*
  store double %1595, double* %1596, align 8, !tbaa !21
  %1597 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1597, align 8, !tbaa !22
  br label %1603

; <label>:1598:                                   ; preds = %1555, %1582
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1599 = load i64, i64* %180, align 8, !tbaa !49
  store i64 %1599, i64* %182, align 8, !tbaa !20
  %1600 = lshr i32 %4082, 15
  %1601 = and i32 %1600, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1559, %struct.TValue* %1562, %union.StackValue* %4081, i32 %1601, i32 6)
  %1602 = load i32, i32* %184, align 8, !tbaa !21
  br label %1603

; <label>:1603:                                   ; preds = %1593, %1598, %1571
  %1604 = phi i32 [ %4083, %1571 ], [ %4083, %1593 ], [ %1602, %1598 ]
  %1605 = icmp eq i32 %1604, 0
  br i1 %1605, label %1610, label %1606

; <label>:1606:                                   ; preds = %1603
  %1607 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1608 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1609 = getelementptr inbounds %union.StackValue, %union.StackValue* %1608, i64 1
  br label %1610

; <label>:1610:                                   ; preds = %1603, %1606
  %1611 = phi i32 [ %1607, %1606 ], [ 0, %1603 ]
  %1612 = phi %union.StackValue* [ %1609, %1606 ], [ %4085, %1603 ]
  %1613 = getelementptr inbounds i32, i32* %4084, i64 1
  %1614 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1615:                                   ; preds = %4080
  %1616 = lshr i32 %4082, 16
  %1617 = and i32 %1616, 255
  %1618 = zext i32 %1617 to i64
  %1619 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1618, i32 0
  %1620 = lshr i32 %4082, 24
  %1621 = zext i32 %1620 to i64
  %1622 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1621
  %1623 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1618, i32 0, i32 1
  %1624 = load i8, i8* %1623, align 8, !tbaa !22
  switch i8 %1624, label %1658 [
    i8 35, label %1625
    i8 19, label %1637
  ]

; <label>:1625:                                   ; preds = %1615
  %1626 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1621, i32 1
  %1627 = load i8, i8* %1626, align 8, !tbaa !22
  %1628 = icmp eq i8 %1627, 35
  %1629 = bitcast %struct.TValue* %1619 to i64*
  %1630 = load i64, i64* %1629, align 8, !tbaa !21
  br i1 %1628, label %1631, label %1640

; <label>:1631:                                   ; preds = %1625
  %1632 = bitcast %struct.TValue* %1622 to i64*
  %1633 = load i64, i64* %1632, align 8, !tbaa !21
  %1634 = sub i64 %1630, %1633
  %1635 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1634, i64* %1635, align 8, !tbaa !21
  %1636 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1636, align 8, !tbaa !22
  br label %1661

; <label>:1637:                                   ; preds = %1615
  %1638 = bitcast %struct.TValue* %1619 to double*
  %1639 = load double, double* %1638, align 8, !tbaa !21
  br label %1642

; <label>:1640:                                   ; preds = %1625
  %1641 = sitofp i64 %1630 to double
  br label %1642

; <label>:1642:                                   ; preds = %1637, %1640
  %1643 = phi double [ %1639, %1637 ], [ %1641, %1640 ]
  %1644 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1621, i32 1
  %1645 = load i8, i8* %1644, align 8, !tbaa !22
  switch i8 %1645, label %1658 [
    i8 19, label %1646
    i8 35, label %1649
  ]

; <label>:1646:                                   ; preds = %1642
  %1647 = bitcast %struct.TValue* %1622 to double*
  %1648 = load double, double* %1647, align 8, !tbaa !21
  br label %1653

; <label>:1649:                                   ; preds = %1642
  %1650 = bitcast %struct.TValue* %1622 to i64*
  %1651 = load i64, i64* %1650, align 8, !tbaa !21
  %1652 = sitofp i64 %1651 to double
  br label %1653

; <label>:1653:                                   ; preds = %1646, %1649
  %1654 = phi double [ %1648, %1646 ], [ %1652, %1649 ]
  %1655 = fsub double %1643, %1654
  %1656 = bitcast %union.StackValue* %4081 to double*
  store double %1655, double* %1656, align 8, !tbaa !21
  %1657 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1657, align 8, !tbaa !22
  br label %1661

; <label>:1658:                                   ; preds = %1615, %1642
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1659 = load i64, i64* %186, align 8, !tbaa !49
  store i64 %1659, i64* %188, align 8, !tbaa !20
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1619, %struct.TValue* %1622, %union.StackValue* %4081, i32 0, i32 7)
  %1660 = load i32, i32* %190, align 8, !tbaa !21
  br label %1661

; <label>:1661:                                   ; preds = %1653, %1658, %1631
  %1662 = phi i32 [ %4083, %1631 ], [ %4083, %1653 ], [ %1660, %1658 ]
  %1663 = icmp eq i32 %1662, 0
  br i1 %1663, label %1668, label %1664

; <label>:1664:                                   ; preds = %1661
  %1665 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1666 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1667 = getelementptr inbounds %union.StackValue, %union.StackValue* %1666, i64 1
  br label %1668

; <label>:1668:                                   ; preds = %1661, %1664
  %1669 = phi i32 [ %1665, %1664 ], [ 0, %1661 ]
  %1670 = phi %union.StackValue* [ %1667, %1664 ], [ %4085, %1661 ]
  %1671 = getelementptr inbounds i32, i32* %4084, i64 1
  %1672 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1673:                                   ; preds = %4080
  %1674 = lshr i32 %4082, 16
  %1675 = and i32 %1674, 255
  %1676 = zext i32 %1675 to i64
  %1677 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1676, i32 0
  %1678 = lshr i32 %4082, 24
  %1679 = zext i32 %1678 to i64
  %1680 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1679
  %1681 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1676, i32 0, i32 1
  %1682 = load i8, i8* %1681, align 8, !tbaa !22
  switch i8 %1682, label %1716 [
    i8 35, label %1683
    i8 19, label %1695
  ]

; <label>:1683:                                   ; preds = %1673
  %1684 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1679, i32 1
  %1685 = load i8, i8* %1684, align 8, !tbaa !22
  %1686 = icmp eq i8 %1685, 35
  %1687 = bitcast %struct.TValue* %1677 to i64*
  %1688 = load i64, i64* %1687, align 8, !tbaa !21
  br i1 %1686, label %1689, label %1698

; <label>:1689:                                   ; preds = %1683
  %1690 = bitcast %struct.TValue* %1680 to i64*
  %1691 = load i64, i64* %1690, align 8, !tbaa !21
  %1692 = mul i64 %1691, %1688
  %1693 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1692, i64* %1693, align 8, !tbaa !21
  %1694 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1694, align 8, !tbaa !22
  br label %1721

; <label>:1695:                                   ; preds = %1673
  %1696 = bitcast %struct.TValue* %1677 to double*
  %1697 = load double, double* %1696, align 8, !tbaa !21
  br label %1700

; <label>:1698:                                   ; preds = %1683
  %1699 = sitofp i64 %1688 to double
  br label %1700

; <label>:1700:                                   ; preds = %1695, %1698
  %1701 = phi double [ %1697, %1695 ], [ %1699, %1698 ]
  %1702 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1679, i32 1
  %1703 = load i8, i8* %1702, align 8, !tbaa !22
  switch i8 %1703, label %1716 [
    i8 19, label %1704
    i8 35, label %1707
  ]

; <label>:1704:                                   ; preds = %1700
  %1705 = bitcast %struct.TValue* %1680 to double*
  %1706 = load double, double* %1705, align 8, !tbaa !21
  br label %1711

; <label>:1707:                                   ; preds = %1700
  %1708 = bitcast %struct.TValue* %1680 to i64*
  %1709 = load i64, i64* %1708, align 8, !tbaa !21
  %1710 = sitofp i64 %1709 to double
  br label %1711

; <label>:1711:                                   ; preds = %1704, %1707
  %1712 = phi double [ %1706, %1704 ], [ %1710, %1707 ]
  %1713 = fmul double %1701, %1712
  %1714 = bitcast %union.StackValue* %4081 to double*
  store double %1713, double* %1714, align 8, !tbaa !21
  %1715 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1715, align 8, !tbaa !22
  br label %1721

; <label>:1716:                                   ; preds = %1673, %1700
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1717 = load i64, i64* %192, align 8, !tbaa !49
  store i64 %1717, i64* %194, align 8, !tbaa !20
  %1718 = lshr i32 %4082, 15
  %1719 = and i32 %1718, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1677, %struct.TValue* %1680, %union.StackValue* %4081, i32 %1719, i32 8)
  %1720 = load i32, i32* %196, align 8, !tbaa !21
  br label %1721

; <label>:1721:                                   ; preds = %1711, %1716, %1689
  %1722 = phi i32 [ %4083, %1689 ], [ %4083, %1711 ], [ %1720, %1716 ]
  %1723 = icmp eq i32 %1722, 0
  br i1 %1723, label %1728, label %1724

; <label>:1724:                                   ; preds = %1721
  %1725 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1726 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1727 = getelementptr inbounds %union.StackValue, %union.StackValue* %1726, i64 1
  br label %1728

; <label>:1728:                                   ; preds = %1721, %1724
  %1729 = phi i32 [ %1725, %1724 ], [ 0, %1721 ]
  %1730 = phi %union.StackValue* [ %1727, %1724 ], [ %4085, %1721 ]
  %1731 = getelementptr inbounds i32, i32* %4084, i64 1
  %1732 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1733:                                   ; preds = %4080
  %1734 = lshr i32 %4082, 16
  %1735 = and i32 %1734, 255
  %1736 = zext i32 %1735 to i64
  %1737 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1736, i32 0
  %1738 = lshr i32 %4082, 24
  %1739 = zext i32 %1738 to i64
  %1740 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1739
  %1741 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1736, i32 0, i32 1
  %1742 = load i8, i8* %1741, align 8, !tbaa !22
  switch i8 %1742, label %1776 [
    i8 35, label %1743
    i8 19, label %1755
  ]

; <label>:1743:                                   ; preds = %1733
  %1744 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1739, i32 1
  %1745 = load i8, i8* %1744, align 8, !tbaa !22
  %1746 = icmp eq i8 %1745, 35
  %1747 = bitcast %struct.TValue* %1737 to i64*
  %1748 = load i64, i64* %1747, align 8, !tbaa !21
  br i1 %1746, label %1749, label %1758

; <label>:1749:                                   ; preds = %1743
  %1750 = bitcast %struct.TValue* %1740 to i64*
  %1751 = load i64, i64* %1750, align 8, !tbaa !21
  %1752 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1748, i64 %1751)
  %1753 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1752, i64* %1753, align 8, !tbaa !21
  %1754 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1754, align 8, !tbaa !22
  br label %1779

; <label>:1755:                                   ; preds = %1733
  %1756 = bitcast %struct.TValue* %1737 to double*
  %1757 = load double, double* %1756, align 8, !tbaa !21
  br label %1760

; <label>:1758:                                   ; preds = %1743
  %1759 = sitofp i64 %1748 to double
  br label %1760

; <label>:1760:                                   ; preds = %1755, %1758
  %1761 = phi double [ %1757, %1755 ], [ %1759, %1758 ]
  %1762 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1739, i32 1
  %1763 = load i8, i8* %1762, align 8, !tbaa !22
  switch i8 %1763, label %1776 [
    i8 19, label %1764
    i8 35, label %1767
  ]

; <label>:1764:                                   ; preds = %1760
  %1765 = bitcast %struct.TValue* %1740 to double*
  %1766 = load double, double* %1765, align 8, !tbaa !21
  br label %1771

; <label>:1767:                                   ; preds = %1760
  %1768 = bitcast %struct.TValue* %1740 to i64*
  %1769 = load i64, i64* %1768, align 8, !tbaa !21
  %1770 = sitofp i64 %1769 to double
  br label %1771

; <label>:1771:                                   ; preds = %1764, %1767
  %1772 = phi double [ %1766, %1764 ], [ %1770, %1767 ]
  %1773 = call fastcc double @luaV_modf(double %1761, double %1772)
  %1774 = bitcast %union.StackValue* %4081 to double*
  store double %1773, double* %1774, align 8, !tbaa !21
  %1775 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1775, align 8, !tbaa !22
  br label %1779

; <label>:1776:                                   ; preds = %1733, %1760
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1777 = load i64, i64* %198, align 8, !tbaa !49
  store i64 %1777, i64* %200, align 8, !tbaa !20
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1737, %struct.TValue* %1740, %union.StackValue* %4081, i32 0, i32 9)
  %1778 = load i32, i32* %202, align 8, !tbaa !21
  br label %1779

; <label>:1779:                                   ; preds = %1771, %1776, %1749
  %1780 = phi i32 [ %4083, %1749 ], [ %4083, %1771 ], [ %1778, %1776 ]
  %1781 = icmp eq i32 %1780, 0
  br i1 %1781, label %1786, label %1782

; <label>:1782:                                   ; preds = %1779
  %1783 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1784 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1785 = getelementptr inbounds %union.StackValue, %union.StackValue* %1784, i64 1
  br label %1786

; <label>:1786:                                   ; preds = %1779, %1782
  %1787 = phi i32 [ %1783, %1782 ], [ 0, %1779 ]
  %1788 = phi %union.StackValue* [ %1785, %1782 ], [ %4085, %1779 ]
  %1789 = getelementptr inbounds i32, i32* %4084, i64 1
  %1790 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1791:                                   ; preds = %4080
  %1792 = lshr i32 %4082, 16
  %1793 = and i32 %1792, 255
  %1794 = zext i32 %1793 to i64
  %1795 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1794, i32 0
  %1796 = lshr i32 %4082, 24
  %1797 = zext i32 %1796 to i64
  %1798 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1797
  %1799 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1794, i32 0, i32 1
  %1800 = load i8, i8* %1799, align 8, !tbaa !22
  switch i8 %1800, label %1824 [
    i8 19, label %1801
    i8 35, label %1804
  ]

; <label>:1801:                                   ; preds = %1791
  %1802 = bitcast %struct.TValue* %1795 to double*
  %1803 = load double, double* %1802, align 8, !tbaa !21
  br label %1808

; <label>:1804:                                   ; preds = %1791
  %1805 = bitcast %struct.TValue* %1795 to i64*
  %1806 = load i64, i64* %1805, align 8, !tbaa !21
  %1807 = sitofp i64 %1806 to double
  br label %1808

; <label>:1808:                                   ; preds = %1801, %1804
  %1809 = phi double [ %1803, %1801 ], [ %1807, %1804 ]
  %1810 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1797, i32 1
  %1811 = load i8, i8* %1810, align 8, !tbaa !22
  switch i8 %1811, label %1824 [
    i8 19, label %1812
    i8 35, label %1815
  ]

; <label>:1812:                                   ; preds = %1808
  %1813 = bitcast %struct.TValue* %1798 to double*
  %1814 = load double, double* %1813, align 8, !tbaa !21
  br label %1819

; <label>:1815:                                   ; preds = %1808
  %1816 = bitcast %struct.TValue* %1798 to i64*
  %1817 = load i64, i64* %1816, align 8, !tbaa !21
  %1818 = sitofp i64 %1817 to double
  br label %1819

; <label>:1819:                                   ; preds = %1812, %1815
  %1820 = phi double [ %1814, %1812 ], [ %1818, %1815 ]
  %1821 = call double @pow(double %1809, double %1820) #7
  %1822 = bitcast %union.StackValue* %4081 to double*
  store double %1821, double* %1822, align 8, !tbaa !21
  %1823 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1823, align 8, !tbaa !22
  br label %1827

; <label>:1824:                                   ; preds = %1808, %1791
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1825 = load i64, i64* %204, align 8, !tbaa !49
  store i64 %1825, i64* %206, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1795, %struct.TValue* %1798, %union.StackValue* %4081, i32 10)
  %1826 = load i32, i32* %208, align 8, !tbaa !21
  br label %1827

; <label>:1827:                                   ; preds = %1824, %1819
  %1828 = phi i32 [ %4083, %1819 ], [ %1826, %1824 ]
  %1829 = icmp eq i32 %1828, 0
  br i1 %1829, label %1834, label %1830

; <label>:1830:                                   ; preds = %1827
  %1831 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1832 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1833 = getelementptr inbounds %union.StackValue, %union.StackValue* %1832, i64 1
  br label %1834

; <label>:1834:                                   ; preds = %1827, %1830
  %1835 = phi i32 [ %1831, %1830 ], [ 0, %1827 ]
  %1836 = phi %union.StackValue* [ %1833, %1830 ], [ %4085, %1827 ]
  %1837 = getelementptr inbounds i32, i32* %4084, i64 1
  %1838 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1839:                                   ; preds = %4080
  %1840 = lshr i32 %4082, 16
  %1841 = and i32 %1840, 255
  %1842 = zext i32 %1841 to i64
  %1843 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1842, i32 0
  %1844 = lshr i32 %4082, 24
  %1845 = zext i32 %1844 to i64
  %1846 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1845
  %1847 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1842, i32 0, i32 1
  %1848 = load i8, i8* %1847, align 8, !tbaa !22
  switch i8 %1848, label %1872 [
    i8 19, label %1849
    i8 35, label %1852
  ]

; <label>:1849:                                   ; preds = %1839
  %1850 = bitcast %struct.TValue* %1843 to double*
  %1851 = load double, double* %1850, align 8, !tbaa !21
  br label %1856

; <label>:1852:                                   ; preds = %1839
  %1853 = bitcast %struct.TValue* %1843 to i64*
  %1854 = load i64, i64* %1853, align 8, !tbaa !21
  %1855 = sitofp i64 %1854 to double
  br label %1856

; <label>:1856:                                   ; preds = %1849, %1852
  %1857 = phi double [ %1851, %1849 ], [ %1855, %1852 ]
  %1858 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1845, i32 1
  %1859 = load i8, i8* %1858, align 8, !tbaa !22
  switch i8 %1859, label %1872 [
    i8 19, label %1860
    i8 35, label %1863
  ]

; <label>:1860:                                   ; preds = %1856
  %1861 = bitcast %struct.TValue* %1846 to double*
  %1862 = load double, double* %1861, align 8, !tbaa !21
  br label %1867

; <label>:1863:                                   ; preds = %1856
  %1864 = bitcast %struct.TValue* %1846 to i64*
  %1865 = load i64, i64* %1864, align 8, !tbaa !21
  %1866 = sitofp i64 %1865 to double
  br label %1867

; <label>:1867:                                   ; preds = %1860, %1863
  %1868 = phi double [ %1862, %1860 ], [ %1866, %1863 ]
  %1869 = fdiv double %1857, %1868
  %1870 = bitcast %union.StackValue* %4081 to double*
  store double %1869, double* %1870, align 8, !tbaa !21
  %1871 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1871, align 8, !tbaa !22
  br label %1875

; <label>:1872:                                   ; preds = %1856, %1839
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1873 = load i64, i64* %210, align 8, !tbaa !49
  store i64 %1873, i64* %212, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1843, %struct.TValue* %1846, %union.StackValue* %4081, i32 11)
  %1874 = load i32, i32* %214, align 8, !tbaa !21
  br label %1875

; <label>:1875:                                   ; preds = %1872, %1867
  %1876 = phi i32 [ %4083, %1867 ], [ %1874, %1872 ]
  %1877 = icmp eq i32 %1876, 0
  br i1 %1877, label %1882, label %1878

; <label>:1878:                                   ; preds = %1875
  %1879 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1880 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1881 = getelementptr inbounds %union.StackValue, %union.StackValue* %1880, i64 1
  br label %1882

; <label>:1882:                                   ; preds = %1875, %1878
  %1883 = phi i32 [ %1879, %1878 ], [ 0, %1875 ]
  %1884 = phi %union.StackValue* [ %1881, %1878 ], [ %4085, %1875 ]
  %1885 = getelementptr inbounds i32, i32* %4084, i64 1
  %1886 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1887:                                   ; preds = %4080
  %1888 = lshr i32 %4082, 16
  %1889 = and i32 %1888, 255
  %1890 = zext i32 %1889 to i64
  %1891 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1890, i32 0
  %1892 = lshr i32 %4082, 24
  %1893 = zext i32 %1892 to i64
  %1894 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1893
  %1895 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1890, i32 0, i32 1
  %1896 = load i8, i8* %1895, align 8, !tbaa !22
  switch i8 %1896, label %1931 [
    i8 35, label %1897
    i8 19, label %1909
  ]

; <label>:1897:                                   ; preds = %1887
  %1898 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1893, i32 1
  %1899 = load i8, i8* %1898, align 8, !tbaa !22
  %1900 = icmp eq i8 %1899, 35
  %1901 = bitcast %struct.TValue* %1891 to i64*
  %1902 = load i64, i64* %1901, align 8, !tbaa !21
  br i1 %1900, label %1903, label %1912

; <label>:1903:                                   ; preds = %1897
  %1904 = bitcast %struct.TValue* %1894 to i64*
  %1905 = load i64, i64* %1904, align 8, !tbaa !21
  %1906 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1902, i64 %1905)
  %1907 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1906, i64* %1907, align 8, !tbaa !21
  %1908 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1908, align 8, !tbaa !22
  br label %1934

; <label>:1909:                                   ; preds = %1887
  %1910 = bitcast %struct.TValue* %1891 to double*
  %1911 = load double, double* %1910, align 8, !tbaa !21
  br label %1914

; <label>:1912:                                   ; preds = %1897
  %1913 = sitofp i64 %1902 to double
  br label %1914

; <label>:1914:                                   ; preds = %1909, %1912
  %1915 = phi double [ %1911, %1909 ], [ %1913, %1912 ]
  %1916 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %1893, i32 1
  %1917 = load i8, i8* %1916, align 8, !tbaa !22
  switch i8 %1917, label %1931 [
    i8 19, label %1918
    i8 35, label %1921
  ]

; <label>:1918:                                   ; preds = %1914
  %1919 = bitcast %struct.TValue* %1894 to double*
  %1920 = load double, double* %1919, align 8, !tbaa !21
  br label %1925

; <label>:1921:                                   ; preds = %1914
  %1922 = bitcast %struct.TValue* %1894 to i64*
  %1923 = load i64, i64* %1922, align 8, !tbaa !21
  %1924 = sitofp i64 %1923 to double
  br label %1925

; <label>:1925:                                   ; preds = %1918, %1921
  %1926 = phi double [ %1920, %1918 ], [ %1924, %1921 ]
  %1927 = fdiv double %1915, %1926
  %1928 = call double @llvm.floor.f64(double %1927)
  %1929 = bitcast %union.StackValue* %4081 to double*
  store double %1928, double* %1929, align 8, !tbaa !21
  %1930 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1930, align 8, !tbaa !22
  br label %1934

; <label>:1931:                                   ; preds = %1887, %1914
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1932 = load i64, i64* %216, align 8, !tbaa !49
  store i64 %1932, i64* %218, align 8, !tbaa !20
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1891, %struct.TValue* %1894, %union.StackValue* %4081, i32 0, i32 12)
  %1933 = load i32, i32* %220, align 8, !tbaa !21
  br label %1934

; <label>:1934:                                   ; preds = %1925, %1931, %1903
  %1935 = phi i32 [ %4083, %1903 ], [ %4083, %1925 ], [ %1933, %1931 ]
  %1936 = icmp eq i32 %1935, 0
  br i1 %1936, label %1941, label %1937

; <label>:1937:                                   ; preds = %1934
  %1938 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1939 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1940 = getelementptr inbounds %union.StackValue, %union.StackValue* %1939, i64 1
  br label %1941

; <label>:1941:                                   ; preds = %1934, %1937
  %1942 = phi i32 [ %1938, %1937 ], [ 0, %1934 ]
  %1943 = phi %union.StackValue* [ %1940, %1937 ], [ %4085, %1934 ]
  %1944 = getelementptr inbounds i32, i32* %4084, i64 1
  %1945 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:1946:                                   ; preds = %4080
  %1947 = lshr i32 %4082, 16
  %1948 = and i32 %1947, 255
  %1949 = zext i32 %1948 to i64
  %1950 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1949, i32 0
  %1951 = lshr i32 %4082, 24
  %1952 = zext i32 %1951 to i64
  %1953 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1952, i32 0
  %1954 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1949, i32 0, i32 1
  %1955 = load i8, i8* %1954, align 8, !tbaa !22
  switch i8 %1955, label %1989 [
    i8 35, label %1956
    i8 19, label %1968
  ]

; <label>:1956:                                   ; preds = %1946
  %1957 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1952, i32 0, i32 1
  %1958 = load i8, i8* %1957, align 8, !tbaa !22
  %1959 = icmp eq i8 %1958, 35
  %1960 = bitcast %struct.TValue* %1950 to i64*
  %1961 = load i64, i64* %1960, align 8, !tbaa !21
  br i1 %1959, label %1962, label %1971

; <label>:1962:                                   ; preds = %1956
  %1963 = bitcast %struct.TValue* %1953 to i64*
  %1964 = load i64, i64* %1963, align 8, !tbaa !21
  %1965 = add i64 %1964, %1961
  %1966 = bitcast %union.StackValue* %4081 to i64*
  store i64 %1965, i64* %1966, align 8, !tbaa !21
  %1967 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %1967, align 8, !tbaa !22
  br label %1992

; <label>:1968:                                   ; preds = %1946
  %1969 = bitcast %struct.TValue* %1950 to double*
  %1970 = load double, double* %1969, align 8, !tbaa !21
  br label %1973

; <label>:1971:                                   ; preds = %1956
  %1972 = sitofp i64 %1961 to double
  br label %1973

; <label>:1973:                                   ; preds = %1968, %1971
  %1974 = phi double [ %1970, %1968 ], [ %1972, %1971 ]
  %1975 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %1952, i32 0, i32 1
  %1976 = load i8, i8* %1975, align 8, !tbaa !22
  switch i8 %1976, label %1989 [
    i8 19, label %1977
    i8 35, label %1980
  ]

; <label>:1977:                                   ; preds = %1973
  %1978 = bitcast %struct.TValue* %1953 to double*
  %1979 = load double, double* %1978, align 8, !tbaa !21
  br label %1984

; <label>:1980:                                   ; preds = %1973
  %1981 = bitcast %struct.TValue* %1953 to i64*
  %1982 = load i64, i64* %1981, align 8, !tbaa !21
  %1983 = sitofp i64 %1982 to double
  br label %1984

; <label>:1984:                                   ; preds = %1977, %1980
  %1985 = phi double [ %1979, %1977 ], [ %1983, %1980 ]
  %1986 = fadd double %1974, %1985
  %1987 = bitcast %union.StackValue* %4081 to double*
  store double %1986, double* %1987, align 8, !tbaa !21
  %1988 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %1988, align 8, !tbaa !22
  br label %1992

; <label>:1989:                                   ; preds = %1946, %1973
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %1990 = load i64, i64* %222, align 8, !tbaa !49
  store i64 %1990, i64* %224, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1950, %struct.TValue* %1953, %union.StackValue* %4081, i32 6)
  %1991 = load i32, i32* %226, align 8, !tbaa !21
  br label %1992

; <label>:1992:                                   ; preds = %1984, %1989, %1962
  %1993 = phi i32 [ %4083, %1962 ], [ %4083, %1984 ], [ %1991, %1989 ]
  %1994 = icmp eq i32 %1993, 0
  br i1 %1994, label %1999, label %1995

; <label>:1995:                                   ; preds = %1992
  %1996 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %1997 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %1998 = getelementptr inbounds %union.StackValue, %union.StackValue* %1997, i64 1
  br label %1999

; <label>:1999:                                   ; preds = %1992, %1995
  %2000 = phi i32 [ %1996, %1995 ], [ 0, %1992 ]
  %2001 = phi %union.StackValue* [ %1998, %1995 ], [ %4085, %1992 ]
  %2002 = getelementptr inbounds i32, i32* %4084, i64 1
  %2003 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2004:                                   ; preds = %4080
  %2005 = lshr i32 %4082, 16
  %2006 = and i32 %2005, 255
  %2007 = zext i32 %2006 to i64
  %2008 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2007, i32 0
  %2009 = lshr i32 %4082, 24
  %2010 = zext i32 %2009 to i64
  %2011 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2010, i32 0
  %2012 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2007, i32 0, i32 1
  %2013 = load i8, i8* %2012, align 8, !tbaa !22
  switch i8 %2013, label %2047 [
    i8 35, label %2014
    i8 19, label %2026
  ]

; <label>:2014:                                   ; preds = %2004
  %2015 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2010, i32 0, i32 1
  %2016 = load i8, i8* %2015, align 8, !tbaa !22
  %2017 = icmp eq i8 %2016, 35
  %2018 = bitcast %struct.TValue* %2008 to i64*
  %2019 = load i64, i64* %2018, align 8, !tbaa !21
  br i1 %2017, label %2020, label %2029

; <label>:2020:                                   ; preds = %2014
  %2021 = bitcast %struct.TValue* %2011 to i64*
  %2022 = load i64, i64* %2021, align 8, !tbaa !21
  %2023 = sub i64 %2019, %2022
  %2024 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2023, i64* %2024, align 8, !tbaa !21
  %2025 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2025, align 8, !tbaa !22
  br label %2050

; <label>:2026:                                   ; preds = %2004
  %2027 = bitcast %struct.TValue* %2008 to double*
  %2028 = load double, double* %2027, align 8, !tbaa !21
  br label %2031

; <label>:2029:                                   ; preds = %2014
  %2030 = sitofp i64 %2019 to double
  br label %2031

; <label>:2031:                                   ; preds = %2026, %2029
  %2032 = phi double [ %2028, %2026 ], [ %2030, %2029 ]
  %2033 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2010, i32 0, i32 1
  %2034 = load i8, i8* %2033, align 8, !tbaa !22
  switch i8 %2034, label %2047 [
    i8 19, label %2035
    i8 35, label %2038
  ]

; <label>:2035:                                   ; preds = %2031
  %2036 = bitcast %struct.TValue* %2011 to double*
  %2037 = load double, double* %2036, align 8, !tbaa !21
  br label %2042

; <label>:2038:                                   ; preds = %2031
  %2039 = bitcast %struct.TValue* %2011 to i64*
  %2040 = load i64, i64* %2039, align 8, !tbaa !21
  %2041 = sitofp i64 %2040 to double
  br label %2042

; <label>:2042:                                   ; preds = %2035, %2038
  %2043 = phi double [ %2037, %2035 ], [ %2041, %2038 ]
  %2044 = fsub double %2032, %2043
  %2045 = bitcast %union.StackValue* %4081 to double*
  store double %2044, double* %2045, align 8, !tbaa !21
  %2046 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2046, align 8, !tbaa !22
  br label %2050

; <label>:2047:                                   ; preds = %2004, %2031
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2048 = load i64, i64* %228, align 8, !tbaa !49
  store i64 %2048, i64* %230, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2008, %struct.TValue* %2011, %union.StackValue* %4081, i32 7)
  %2049 = load i32, i32* %232, align 8, !tbaa !21
  br label %2050

; <label>:2050:                                   ; preds = %2042, %2047, %2020
  %2051 = phi i32 [ %4083, %2020 ], [ %4083, %2042 ], [ %2049, %2047 ]
  %2052 = icmp eq i32 %2051, 0
  br i1 %2052, label %2057, label %2053

; <label>:2053:                                   ; preds = %2050
  %2054 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2055 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2056 = getelementptr inbounds %union.StackValue, %union.StackValue* %2055, i64 1
  br label %2057

; <label>:2057:                                   ; preds = %2050, %2053
  %2058 = phi i32 [ %2054, %2053 ], [ 0, %2050 ]
  %2059 = phi %union.StackValue* [ %2056, %2053 ], [ %4085, %2050 ]
  %2060 = getelementptr inbounds i32, i32* %4084, i64 1
  %2061 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2062:                                   ; preds = %4080
  %2063 = lshr i32 %4082, 16
  %2064 = and i32 %2063, 255
  %2065 = zext i32 %2064 to i64
  %2066 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2065, i32 0
  %2067 = lshr i32 %4082, 24
  %2068 = zext i32 %2067 to i64
  %2069 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2068, i32 0
  %2070 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2065, i32 0, i32 1
  %2071 = load i8, i8* %2070, align 8, !tbaa !22
  switch i8 %2071, label %2105 [
    i8 35, label %2072
    i8 19, label %2084
  ]

; <label>:2072:                                   ; preds = %2062
  %2073 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2068, i32 0, i32 1
  %2074 = load i8, i8* %2073, align 8, !tbaa !22
  %2075 = icmp eq i8 %2074, 35
  %2076 = bitcast %struct.TValue* %2066 to i64*
  %2077 = load i64, i64* %2076, align 8, !tbaa !21
  br i1 %2075, label %2078, label %2087

; <label>:2078:                                   ; preds = %2072
  %2079 = bitcast %struct.TValue* %2069 to i64*
  %2080 = load i64, i64* %2079, align 8, !tbaa !21
  %2081 = mul i64 %2080, %2077
  %2082 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2081, i64* %2082, align 8, !tbaa !21
  %2083 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2083, align 8, !tbaa !22
  br label %2108

; <label>:2084:                                   ; preds = %2062
  %2085 = bitcast %struct.TValue* %2066 to double*
  %2086 = load double, double* %2085, align 8, !tbaa !21
  br label %2089

; <label>:2087:                                   ; preds = %2072
  %2088 = sitofp i64 %2077 to double
  br label %2089

; <label>:2089:                                   ; preds = %2084, %2087
  %2090 = phi double [ %2086, %2084 ], [ %2088, %2087 ]
  %2091 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2068, i32 0, i32 1
  %2092 = load i8, i8* %2091, align 8, !tbaa !22
  switch i8 %2092, label %2105 [
    i8 19, label %2093
    i8 35, label %2096
  ]

; <label>:2093:                                   ; preds = %2089
  %2094 = bitcast %struct.TValue* %2069 to double*
  %2095 = load double, double* %2094, align 8, !tbaa !21
  br label %2100

; <label>:2096:                                   ; preds = %2089
  %2097 = bitcast %struct.TValue* %2069 to i64*
  %2098 = load i64, i64* %2097, align 8, !tbaa !21
  %2099 = sitofp i64 %2098 to double
  br label %2100

; <label>:2100:                                   ; preds = %2093, %2096
  %2101 = phi double [ %2095, %2093 ], [ %2099, %2096 ]
  %2102 = fmul double %2090, %2101
  %2103 = bitcast %union.StackValue* %4081 to double*
  store double %2102, double* %2103, align 8, !tbaa !21
  %2104 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2104, align 8, !tbaa !22
  br label %2108

; <label>:2105:                                   ; preds = %2062, %2089
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2106 = load i64, i64* %234, align 8, !tbaa !49
  store i64 %2106, i64* %236, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2066, %struct.TValue* %2069, %union.StackValue* %4081, i32 8)
  %2107 = load i32, i32* %238, align 8, !tbaa !21
  br label %2108

; <label>:2108:                                   ; preds = %2100, %2105, %2078
  %2109 = phi i32 [ %4083, %2078 ], [ %4083, %2100 ], [ %2107, %2105 ]
  %2110 = icmp eq i32 %2109, 0
  br i1 %2110, label %2115, label %2111

; <label>:2111:                                   ; preds = %2108
  %2112 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2113 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2114 = getelementptr inbounds %union.StackValue, %union.StackValue* %2113, i64 1
  br label %2115

; <label>:2115:                                   ; preds = %2108, %2111
  %2116 = phi i32 [ %2112, %2111 ], [ 0, %2108 ]
  %2117 = phi %union.StackValue* [ %2114, %2111 ], [ %4085, %2108 ]
  %2118 = getelementptr inbounds i32, i32* %4084, i64 1
  %2119 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2120:                                   ; preds = %4080
  %2121 = lshr i32 %4082, 16
  %2122 = and i32 %2121, 255
  %2123 = zext i32 %2122 to i64
  %2124 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2123, i32 0
  %2125 = lshr i32 %4082, 24
  %2126 = zext i32 %2125 to i64
  %2127 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2126, i32 0
  %2128 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2123, i32 0, i32 1
  %2129 = load i8, i8* %2128, align 8, !tbaa !22
  switch i8 %2129, label %2163 [
    i8 35, label %2130
    i8 19, label %2142
  ]

; <label>:2130:                                   ; preds = %2120
  %2131 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2126, i32 0, i32 1
  %2132 = load i8, i8* %2131, align 8, !tbaa !22
  %2133 = icmp eq i8 %2132, 35
  %2134 = bitcast %struct.TValue* %2124 to i64*
  %2135 = load i64, i64* %2134, align 8, !tbaa !21
  br i1 %2133, label %2136, label %2145

; <label>:2136:                                   ; preds = %2130
  %2137 = bitcast %struct.TValue* %2127 to i64*
  %2138 = load i64, i64* %2137, align 8, !tbaa !21
  %2139 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %2135, i64 %2138)
  %2140 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2139, i64* %2140, align 8, !tbaa !21
  %2141 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2141, align 8, !tbaa !22
  br label %2166

; <label>:2142:                                   ; preds = %2120
  %2143 = bitcast %struct.TValue* %2124 to double*
  %2144 = load double, double* %2143, align 8, !tbaa !21
  br label %2147

; <label>:2145:                                   ; preds = %2130
  %2146 = sitofp i64 %2135 to double
  br label %2147

; <label>:2147:                                   ; preds = %2142, %2145
  %2148 = phi double [ %2144, %2142 ], [ %2146, %2145 ]
  %2149 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2126, i32 0, i32 1
  %2150 = load i8, i8* %2149, align 8, !tbaa !22
  switch i8 %2150, label %2163 [
    i8 19, label %2151
    i8 35, label %2154
  ]

; <label>:2151:                                   ; preds = %2147
  %2152 = bitcast %struct.TValue* %2127 to double*
  %2153 = load double, double* %2152, align 8, !tbaa !21
  br label %2158

; <label>:2154:                                   ; preds = %2147
  %2155 = bitcast %struct.TValue* %2127 to i64*
  %2156 = load i64, i64* %2155, align 8, !tbaa !21
  %2157 = sitofp i64 %2156 to double
  br label %2158

; <label>:2158:                                   ; preds = %2151, %2154
  %2159 = phi double [ %2153, %2151 ], [ %2157, %2154 ]
  %2160 = call fastcc double @luaV_modf(double %2148, double %2159)
  %2161 = bitcast %union.StackValue* %4081 to double*
  store double %2160, double* %2161, align 8, !tbaa !21
  %2162 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2162, align 8, !tbaa !22
  br label %2166

; <label>:2163:                                   ; preds = %2120, %2147
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2164 = load i64, i64* %240, align 8, !tbaa !49
  store i64 %2164, i64* %242, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2124, %struct.TValue* %2127, %union.StackValue* %4081, i32 9)
  %2165 = load i32, i32* %244, align 8, !tbaa !21
  br label %2166

; <label>:2166:                                   ; preds = %2158, %2163, %2136
  %2167 = phi i32 [ %4083, %2136 ], [ %4083, %2158 ], [ %2165, %2163 ]
  %2168 = icmp eq i32 %2167, 0
  br i1 %2168, label %2173, label %2169

; <label>:2169:                                   ; preds = %2166
  %2170 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2171 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2172 = getelementptr inbounds %union.StackValue, %union.StackValue* %2171, i64 1
  br label %2173

; <label>:2173:                                   ; preds = %2166, %2169
  %2174 = phi i32 [ %2170, %2169 ], [ 0, %2166 ]
  %2175 = phi %union.StackValue* [ %2172, %2169 ], [ %4085, %2166 ]
  %2176 = getelementptr inbounds i32, i32* %4084, i64 1
  %2177 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2178:                                   ; preds = %4080
  %2179 = lshr i32 %4082, 16
  %2180 = and i32 %2179, 255
  %2181 = zext i32 %2180 to i64
  %2182 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2181, i32 0
  %2183 = lshr i32 %4082, 24
  %2184 = zext i32 %2183 to i64
  %2185 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2184, i32 0
  %2186 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2181, i32 0, i32 1
  %2187 = load i8, i8* %2186, align 8, !tbaa !22
  switch i8 %2187, label %2211 [
    i8 19, label %2188
    i8 35, label %2191
  ]

; <label>:2188:                                   ; preds = %2178
  %2189 = bitcast %struct.TValue* %2182 to double*
  %2190 = load double, double* %2189, align 8, !tbaa !21
  br label %2195

; <label>:2191:                                   ; preds = %2178
  %2192 = bitcast %struct.TValue* %2182 to i64*
  %2193 = load i64, i64* %2192, align 8, !tbaa !21
  %2194 = sitofp i64 %2193 to double
  br label %2195

; <label>:2195:                                   ; preds = %2188, %2191
  %2196 = phi double [ %2190, %2188 ], [ %2194, %2191 ]
  %2197 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2184, i32 0, i32 1
  %2198 = load i8, i8* %2197, align 8, !tbaa !22
  switch i8 %2198, label %2211 [
    i8 19, label %2199
    i8 35, label %2202
  ]

; <label>:2199:                                   ; preds = %2195
  %2200 = bitcast %struct.TValue* %2185 to double*
  %2201 = load double, double* %2200, align 8, !tbaa !21
  br label %2206

; <label>:2202:                                   ; preds = %2195
  %2203 = bitcast %struct.TValue* %2185 to i64*
  %2204 = load i64, i64* %2203, align 8, !tbaa !21
  %2205 = sitofp i64 %2204 to double
  br label %2206

; <label>:2206:                                   ; preds = %2199, %2202
  %2207 = phi double [ %2201, %2199 ], [ %2205, %2202 ]
  %2208 = call double @pow(double %2196, double %2207) #7
  %2209 = bitcast %union.StackValue* %4081 to double*
  store double %2208, double* %2209, align 8, !tbaa !21
  %2210 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2210, align 8, !tbaa !22
  br label %2214

; <label>:2211:                                   ; preds = %2195, %2178
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2212 = load i64, i64* %246, align 8, !tbaa !49
  store i64 %2212, i64* %248, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2182, %struct.TValue* %2185, %union.StackValue* %4081, i32 10)
  %2213 = load i32, i32* %250, align 8, !tbaa !21
  br label %2214

; <label>:2214:                                   ; preds = %2211, %2206
  %2215 = phi i32 [ %4083, %2206 ], [ %2213, %2211 ]
  %2216 = icmp eq i32 %2215, 0
  br i1 %2216, label %2221, label %2217

; <label>:2217:                                   ; preds = %2214
  %2218 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2219 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2220 = getelementptr inbounds %union.StackValue, %union.StackValue* %2219, i64 1
  br label %2221

; <label>:2221:                                   ; preds = %2214, %2217
  %2222 = phi i32 [ %2218, %2217 ], [ 0, %2214 ]
  %2223 = phi %union.StackValue* [ %2220, %2217 ], [ %4085, %2214 ]
  %2224 = getelementptr inbounds i32, i32* %4084, i64 1
  %2225 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2226:                                   ; preds = %4080
  %2227 = lshr i32 %4082, 16
  %2228 = and i32 %2227, 255
  %2229 = zext i32 %2228 to i64
  %2230 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2229, i32 0
  %2231 = lshr i32 %4082, 24
  %2232 = zext i32 %2231 to i64
  %2233 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2232, i32 0
  %2234 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2229, i32 0, i32 1
  %2235 = load i8, i8* %2234, align 8, !tbaa !22
  switch i8 %2235, label %2259 [
    i8 19, label %2236
    i8 35, label %2239
  ]

; <label>:2236:                                   ; preds = %2226
  %2237 = bitcast %struct.TValue* %2230 to double*
  %2238 = load double, double* %2237, align 8, !tbaa !21
  br label %2243

; <label>:2239:                                   ; preds = %2226
  %2240 = bitcast %struct.TValue* %2230 to i64*
  %2241 = load i64, i64* %2240, align 8, !tbaa !21
  %2242 = sitofp i64 %2241 to double
  br label %2243

; <label>:2243:                                   ; preds = %2236, %2239
  %2244 = phi double [ %2238, %2236 ], [ %2242, %2239 ]
  %2245 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2232, i32 0, i32 1
  %2246 = load i8, i8* %2245, align 8, !tbaa !22
  switch i8 %2246, label %2259 [
    i8 19, label %2247
    i8 35, label %2250
  ]

; <label>:2247:                                   ; preds = %2243
  %2248 = bitcast %struct.TValue* %2233 to double*
  %2249 = load double, double* %2248, align 8, !tbaa !21
  br label %2254

; <label>:2250:                                   ; preds = %2243
  %2251 = bitcast %struct.TValue* %2233 to i64*
  %2252 = load i64, i64* %2251, align 8, !tbaa !21
  %2253 = sitofp i64 %2252 to double
  br label %2254

; <label>:2254:                                   ; preds = %2247, %2250
  %2255 = phi double [ %2249, %2247 ], [ %2253, %2250 ]
  %2256 = fdiv double %2244, %2255
  %2257 = bitcast %union.StackValue* %4081 to double*
  store double %2256, double* %2257, align 8, !tbaa !21
  %2258 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2258, align 8, !tbaa !22
  br label %2262

; <label>:2259:                                   ; preds = %2243, %2226
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2260 = load i64, i64* %252, align 8, !tbaa !49
  store i64 %2260, i64* %254, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2230, %struct.TValue* %2233, %union.StackValue* %4081, i32 11)
  %2261 = load i32, i32* %256, align 8, !tbaa !21
  br label %2262

; <label>:2262:                                   ; preds = %2259, %2254
  %2263 = phi i32 [ %4083, %2254 ], [ %2261, %2259 ]
  %2264 = icmp eq i32 %2263, 0
  br i1 %2264, label %2269, label %2265

; <label>:2265:                                   ; preds = %2262
  %2266 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2267 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2268 = getelementptr inbounds %union.StackValue, %union.StackValue* %2267, i64 1
  br label %2269

; <label>:2269:                                   ; preds = %2262, %2265
  %2270 = phi i32 [ %2266, %2265 ], [ 0, %2262 ]
  %2271 = phi %union.StackValue* [ %2268, %2265 ], [ %4085, %2262 ]
  %2272 = getelementptr inbounds i32, i32* %4084, i64 1
  %2273 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2274:                                   ; preds = %4080
  %2275 = lshr i32 %4082, 16
  %2276 = and i32 %2275, 255
  %2277 = zext i32 %2276 to i64
  %2278 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2277, i32 0
  %2279 = lshr i32 %4082, 24
  %2280 = zext i32 %2279 to i64
  %2281 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2280, i32 0
  %2282 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2277, i32 0, i32 1
  %2283 = load i8, i8* %2282, align 8, !tbaa !22
  switch i8 %2283, label %2318 [
    i8 35, label %2284
    i8 19, label %2296
  ]

; <label>:2284:                                   ; preds = %2274
  %2285 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2280, i32 0, i32 1
  %2286 = load i8, i8* %2285, align 8, !tbaa !22
  %2287 = icmp eq i8 %2286, 35
  %2288 = bitcast %struct.TValue* %2278 to i64*
  %2289 = load i64, i64* %2288, align 8, !tbaa !21
  br i1 %2287, label %2290, label %2299

; <label>:2290:                                   ; preds = %2284
  %2291 = bitcast %struct.TValue* %2281 to i64*
  %2292 = load i64, i64* %2291, align 8, !tbaa !21
  %2293 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %2289, i64 %2292)
  %2294 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2293, i64* %2294, align 8, !tbaa !21
  %2295 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2295, align 8, !tbaa !22
  br label %2321

; <label>:2296:                                   ; preds = %2274
  %2297 = bitcast %struct.TValue* %2278 to double*
  %2298 = load double, double* %2297, align 8, !tbaa !21
  br label %2301

; <label>:2299:                                   ; preds = %2284
  %2300 = sitofp i64 %2289 to double
  br label %2301

; <label>:2301:                                   ; preds = %2296, %2299
  %2302 = phi double [ %2298, %2296 ], [ %2300, %2299 ]
  %2303 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2280, i32 0, i32 1
  %2304 = load i8, i8* %2303, align 8, !tbaa !22
  switch i8 %2304, label %2318 [
    i8 19, label %2305
    i8 35, label %2308
  ]

; <label>:2305:                                   ; preds = %2301
  %2306 = bitcast %struct.TValue* %2281 to double*
  %2307 = load double, double* %2306, align 8, !tbaa !21
  br label %2312

; <label>:2308:                                   ; preds = %2301
  %2309 = bitcast %struct.TValue* %2281 to i64*
  %2310 = load i64, i64* %2309, align 8, !tbaa !21
  %2311 = sitofp i64 %2310 to double
  br label %2312

; <label>:2312:                                   ; preds = %2305, %2308
  %2313 = phi double [ %2307, %2305 ], [ %2311, %2308 ]
  %2314 = fdiv double %2302, %2313
  %2315 = call double @llvm.floor.f64(double %2314)
  %2316 = bitcast %union.StackValue* %4081 to double*
  store double %2315, double* %2316, align 8, !tbaa !21
  %2317 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2317, align 8, !tbaa !22
  br label %2321

; <label>:2318:                                   ; preds = %2274, %2301
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2319 = load i64, i64* %258, align 8, !tbaa !49
  store i64 %2319, i64* %260, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2278, %struct.TValue* %2281, %union.StackValue* %4081, i32 12)
  %2320 = load i32, i32* %262, align 8, !tbaa !21
  br label %2321

; <label>:2321:                                   ; preds = %2312, %2318, %2290
  %2322 = phi i32 [ %4083, %2290 ], [ %4083, %2312 ], [ %2320, %2318 ]
  %2323 = icmp eq i32 %2322, 0
  br i1 %2323, label %2328, label %2324

; <label>:2324:                                   ; preds = %2321
  %2325 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2326 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2327 = getelementptr inbounds %union.StackValue, %union.StackValue* %2326, i64 1
  br label %2328

; <label>:2328:                                   ; preds = %2321, %2324
  %2329 = phi i32 [ %2325, %2324 ], [ 0, %2321 ]
  %2330 = phi %union.StackValue* [ %2327, %2324 ], [ %4085, %2321 ]
  %2331 = getelementptr inbounds i32, i32* %4084, i64 1
  %2332 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2333:                                   ; preds = %4080
  %2334 = lshr i32 %4082, 16
  %2335 = and i32 %2334, 255
  %2336 = zext i32 %2335 to i64
  %2337 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2336, i32 0
  %2338 = lshr i32 %4082, 24
  %2339 = zext i32 %2338 to i64
  %2340 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %2339, i32 0
  %2341 = bitcast %union.Value* %2340 to i64*
  %2342 = load i64, i64* %2341, align 8, !tbaa !21
  %2343 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2336, i32 0, i32 1
  %2344 = load i8, i8* %2343, align 8, !tbaa !22
  %2345 = icmp eq i8 %2344, 35
  br i1 %2345, label %2346, label %2349

; <label>:2346:                                   ; preds = %2333
  %2347 = bitcast %struct.TValue* %2337 to i64*
  %2348 = load i64, i64* %2347, align 8, !tbaa !21
  store i64 %2348, i64* %5, align 8, !tbaa !109
  br label %2352

; <label>:2349:                                   ; preds = %2333
  %2350 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2337, i64* nonnull %5, i32 0)
  %2351 = icmp eq i32 %2350, 0
  br i1 %2351, label %2357, label %2352

; <label>:2352:                                   ; preds = %2349, %2346
  %2353 = load i64, i64* %5, align 8, !tbaa !109
  %2354 = and i64 %2353, %2342
  %2355 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2354, i64* %2355, align 8, !tbaa !21
  %2356 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2356, align 8, !tbaa !22
  br label %2361

; <label>:2357:                                   ; preds = %2349
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2358 = load i64, i64* %361, align 8, !tbaa !49
  store i64 %2358, i64* %363, align 8, !tbaa !20
  %2359 = and i32 %4082, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2337, i64 %2342, i32 %2359, %union.StackValue* %4081, i32 13)
  %2360 = load i32, i32* %365, align 8, !tbaa !21
  br label %2361

; <label>:2361:                                   ; preds = %2357, %2352
  %2362 = phi i32 [ %4083, %2352 ], [ %2360, %2357 ]
  %2363 = icmp eq i32 %2362, 0
  br i1 %2363, label %2368, label %2364

; <label>:2364:                                   ; preds = %2361
  %2365 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2366 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2367 = getelementptr inbounds %union.StackValue, %union.StackValue* %2366, i64 1
  br label %2368

; <label>:2368:                                   ; preds = %2361, %2364
  %2369 = phi i32 [ %2365, %2364 ], [ 0, %2361 ]
  %2370 = phi %union.StackValue* [ %2367, %2364 ], [ %4085, %2361 ]
  %2371 = getelementptr inbounds i32, i32* %4084, i64 1
  %2372 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2373:                                   ; preds = %4080
  %2374 = lshr i32 %4082, 16
  %2375 = and i32 %2374, 255
  %2376 = zext i32 %2375 to i64
  %2377 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2376, i32 0
  %2378 = lshr i32 %4082, 24
  %2379 = zext i32 %2378 to i64
  %2380 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %2379, i32 0
  %2381 = bitcast %union.Value* %2380 to i64*
  %2382 = load i64, i64* %2381, align 8, !tbaa !21
  %2383 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2376, i32 0, i32 1
  %2384 = load i8, i8* %2383, align 8, !tbaa !22
  %2385 = icmp eq i8 %2384, 35
  br i1 %2385, label %2386, label %2389

; <label>:2386:                                   ; preds = %2373
  %2387 = bitcast %struct.TValue* %2377 to i64*
  %2388 = load i64, i64* %2387, align 8, !tbaa !21
  store i64 %2388, i64* %6, align 8, !tbaa !109
  br label %2392

; <label>:2389:                                   ; preds = %2373
  %2390 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2377, i64* nonnull %6, i32 0)
  %2391 = icmp eq i32 %2390, 0
  br i1 %2391, label %2397, label %2392

; <label>:2392:                                   ; preds = %2389, %2386
  %2393 = load i64, i64* %6, align 8, !tbaa !109
  %2394 = or i64 %2393, %2382
  %2395 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2394, i64* %2395, align 8, !tbaa !21
  %2396 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2396, align 8, !tbaa !22
  br label %2401

; <label>:2397:                                   ; preds = %2389
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2398 = load i64, i64* %367, align 8, !tbaa !49
  store i64 %2398, i64* %369, align 8, !tbaa !20
  %2399 = and i32 %4082, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2377, i64 %2382, i32 %2399, %union.StackValue* %4081, i32 14)
  %2400 = load i32, i32* %371, align 8, !tbaa !21
  br label %2401

; <label>:2401:                                   ; preds = %2397, %2392
  %2402 = phi i32 [ %4083, %2392 ], [ %2400, %2397 ]
  %2403 = icmp eq i32 %2402, 0
  br i1 %2403, label %2408, label %2404

; <label>:2404:                                   ; preds = %2401
  %2405 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2406 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2407 = getelementptr inbounds %union.StackValue, %union.StackValue* %2406, i64 1
  br label %2408

; <label>:2408:                                   ; preds = %2401, %2404
  %2409 = phi i32 [ %2405, %2404 ], [ 0, %2401 ]
  %2410 = phi %union.StackValue* [ %2407, %2404 ], [ %4085, %2401 ]
  %2411 = getelementptr inbounds i32, i32* %4084, i64 1
  %2412 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2413:                                   ; preds = %4080
  %2414 = lshr i32 %4082, 16
  %2415 = and i32 %2414, 255
  %2416 = zext i32 %2415 to i64
  %2417 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2416, i32 0
  %2418 = lshr i32 %4082, 24
  %2419 = zext i32 %2418 to i64
  %2420 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %2419, i32 0
  %2421 = bitcast %union.Value* %2420 to i64*
  %2422 = load i64, i64* %2421, align 8, !tbaa !21
  %2423 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2416, i32 0, i32 1
  %2424 = load i8, i8* %2423, align 8, !tbaa !22
  %2425 = icmp eq i8 %2424, 35
  br i1 %2425, label %2426, label %2429

; <label>:2426:                                   ; preds = %2413
  %2427 = bitcast %struct.TValue* %2417 to i64*
  %2428 = load i64, i64* %2427, align 8, !tbaa !21
  store i64 %2428, i64* %7, align 8, !tbaa !109
  br label %2432

; <label>:2429:                                   ; preds = %2413
  %2430 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2417, i64* nonnull %7, i32 0)
  %2431 = icmp eq i32 %2430, 0
  br i1 %2431, label %2437, label %2432

; <label>:2432:                                   ; preds = %2429, %2426
  %2433 = load i64, i64* %7, align 8, !tbaa !109
  %2434 = xor i64 %2433, %2422
  %2435 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2434, i64* %2435, align 8, !tbaa !21
  %2436 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2436, align 8, !tbaa !22
  br label %2441

; <label>:2437:                                   ; preds = %2429
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2438 = load i64, i64* %373, align 8, !tbaa !49
  store i64 %2438, i64* %375, align 8, !tbaa !20
  %2439 = and i32 %4082, 32768
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2417, i64 %2422, i32 %2439, %union.StackValue* %4081, i32 15)
  %2440 = load i32, i32* %377, align 8, !tbaa !21
  br label %2441

; <label>:2441:                                   ; preds = %2437, %2432
  %2442 = phi i32 [ %4083, %2432 ], [ %2440, %2437 ]
  %2443 = icmp eq i32 %2442, 0
  br i1 %2443, label %2448, label %2444

; <label>:2444:                                   ; preds = %2441
  %2445 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2446 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2447 = getelementptr inbounds %union.StackValue, %union.StackValue* %2446, i64 1
  br label %2448

; <label>:2448:                                   ; preds = %2441, %2444
  %2449 = phi i32 [ %2445, %2444 ], [ 0, %2441 ]
  %2450 = phi %union.StackValue* [ %2447, %2444 ], [ %4085, %2441 ]
  %2451 = getelementptr inbounds i32, i32* %4084, i64 1
  %2452 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2453:                                   ; preds = %4080
  %2454 = lshr i32 %4082, 16
  %2455 = and i32 %2454, 255
  %2456 = zext i32 %2455 to i64
  %2457 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2456, i32 0
  %2458 = lshr i32 %4082, 24
  %2459 = zext i32 %2458 to i64
  %2460 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2459, i32 0
  %2461 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2456, i32 0, i32 1
  %2462 = load i8, i8* %2461, align 8, !tbaa !22
  %2463 = icmp eq i8 %2462, 35
  br i1 %2463, label %2464, label %2467

; <label>:2464:                                   ; preds = %2453
  %2465 = bitcast %struct.TValue* %2457 to i64*
  %2466 = load i64, i64* %2465, align 8, !tbaa !21
  store i64 %2466, i64* %8, align 8, !tbaa !109
  br label %2470

; <label>:2467:                                   ; preds = %2453
  %2468 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2457, i64* nonnull %8, i32 0)
  %2469 = icmp eq i32 %2468, 0
  br i1 %2469, label %2486, label %2470

; <label>:2470:                                   ; preds = %2467, %2464
  %2471 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2459, i32 0, i32 1
  %2472 = load i8, i8* %2471, align 8, !tbaa !22
  %2473 = icmp eq i8 %2472, 35
  br i1 %2473, label %2474, label %2477

; <label>:2474:                                   ; preds = %2470
  %2475 = bitcast %struct.TValue* %2460 to i64*
  %2476 = load i64, i64* %2475, align 8, !tbaa !21
  store i64 %2476, i64* %9, align 8, !tbaa !109
  br label %2480

; <label>:2477:                                   ; preds = %2470
  %2478 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2460, i64* nonnull %9, i32 0)
  %2479 = icmp eq i32 %2478, 0
  br i1 %2479, label %2486, label %2480

; <label>:2480:                                   ; preds = %2477, %2474
  %2481 = load i64, i64* %8, align 8, !tbaa !109
  %2482 = load i64, i64* %9, align 8, !tbaa !109
  %2483 = and i64 %2482, %2481
  %2484 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2483, i64* %2484, align 8, !tbaa !21
  %2485 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2485, align 8, !tbaa !22
  br label %2489

; <label>:2486:                                   ; preds = %2477, %2467
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2487 = load i64, i64* %264, align 8, !tbaa !49
  store i64 %2487, i64* %266, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2457, %struct.TValue* %2460, %union.StackValue* %4081, i32 13)
  %2488 = load i32, i32* %268, align 8, !tbaa !21
  br label %2489

; <label>:2489:                                   ; preds = %2486, %2480
  %2490 = phi i32 [ %4083, %2480 ], [ %2488, %2486 ]
  %2491 = icmp eq i32 %2490, 0
  br i1 %2491, label %2496, label %2492

; <label>:2492:                                   ; preds = %2489
  %2493 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2494 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2495 = getelementptr inbounds %union.StackValue, %union.StackValue* %2494, i64 1
  br label %2496

; <label>:2496:                                   ; preds = %2489, %2492
  %2497 = phi i32 [ %2493, %2492 ], [ 0, %2489 ]
  %2498 = phi %union.StackValue* [ %2495, %2492 ], [ %4085, %2489 ]
  %2499 = getelementptr inbounds i32, i32* %4084, i64 1
  %2500 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2501:                                   ; preds = %4080
  %2502 = lshr i32 %4082, 16
  %2503 = and i32 %2502, 255
  %2504 = zext i32 %2503 to i64
  %2505 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2504, i32 0
  %2506 = lshr i32 %4082, 24
  %2507 = zext i32 %2506 to i64
  %2508 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2507, i32 0
  %2509 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2504, i32 0, i32 1
  %2510 = load i8, i8* %2509, align 8, !tbaa !22
  %2511 = icmp eq i8 %2510, 35
  br i1 %2511, label %2512, label %2515

; <label>:2512:                                   ; preds = %2501
  %2513 = bitcast %struct.TValue* %2505 to i64*
  %2514 = load i64, i64* %2513, align 8, !tbaa !21
  store i64 %2514, i64* %10, align 8, !tbaa !109
  br label %2518

; <label>:2515:                                   ; preds = %2501
  %2516 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2505, i64* nonnull %10, i32 0)
  %2517 = icmp eq i32 %2516, 0
  br i1 %2517, label %2534, label %2518

; <label>:2518:                                   ; preds = %2515, %2512
  %2519 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2507, i32 0, i32 1
  %2520 = load i8, i8* %2519, align 8, !tbaa !22
  %2521 = icmp eq i8 %2520, 35
  br i1 %2521, label %2522, label %2525

; <label>:2522:                                   ; preds = %2518
  %2523 = bitcast %struct.TValue* %2508 to i64*
  %2524 = load i64, i64* %2523, align 8, !tbaa !21
  store i64 %2524, i64* %11, align 8, !tbaa !109
  br label %2528

; <label>:2525:                                   ; preds = %2518
  %2526 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2508, i64* nonnull %11, i32 0)
  %2527 = icmp eq i32 %2526, 0
  br i1 %2527, label %2534, label %2528

; <label>:2528:                                   ; preds = %2525, %2522
  %2529 = load i64, i64* %10, align 8, !tbaa !109
  %2530 = load i64, i64* %11, align 8, !tbaa !109
  %2531 = or i64 %2530, %2529
  %2532 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2531, i64* %2532, align 8, !tbaa !21
  %2533 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2533, align 8, !tbaa !22
  br label %2537

; <label>:2534:                                   ; preds = %2525, %2515
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2535 = load i64, i64* %270, align 8, !tbaa !49
  store i64 %2535, i64* %272, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2505, %struct.TValue* %2508, %union.StackValue* %4081, i32 14)
  %2536 = load i32, i32* %274, align 8, !tbaa !21
  br label %2537

; <label>:2537:                                   ; preds = %2534, %2528
  %2538 = phi i32 [ %4083, %2528 ], [ %2536, %2534 ]
  %2539 = icmp eq i32 %2538, 0
  br i1 %2539, label %2544, label %2540

; <label>:2540:                                   ; preds = %2537
  %2541 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2542 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2543 = getelementptr inbounds %union.StackValue, %union.StackValue* %2542, i64 1
  br label %2544

; <label>:2544:                                   ; preds = %2537, %2540
  %2545 = phi i32 [ %2541, %2540 ], [ 0, %2537 ]
  %2546 = phi %union.StackValue* [ %2543, %2540 ], [ %4085, %2537 ]
  %2547 = getelementptr inbounds i32, i32* %4084, i64 1
  %2548 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2549:                                   ; preds = %4080
  %2550 = lshr i32 %4082, 16
  %2551 = and i32 %2550, 255
  %2552 = zext i32 %2551 to i64
  %2553 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2552, i32 0
  %2554 = lshr i32 %4082, 24
  %2555 = zext i32 %2554 to i64
  %2556 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2555, i32 0
  %2557 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2552, i32 0, i32 1
  %2558 = load i8, i8* %2557, align 8, !tbaa !22
  %2559 = icmp eq i8 %2558, 35
  br i1 %2559, label %2560, label %2563

; <label>:2560:                                   ; preds = %2549
  %2561 = bitcast %struct.TValue* %2553 to i64*
  %2562 = load i64, i64* %2561, align 8, !tbaa !21
  store i64 %2562, i64* %12, align 8, !tbaa !109
  br label %2566

; <label>:2563:                                   ; preds = %2549
  %2564 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2553, i64* nonnull %12, i32 0)
  %2565 = icmp eq i32 %2564, 0
  br i1 %2565, label %2582, label %2566

; <label>:2566:                                   ; preds = %2563, %2560
  %2567 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2555, i32 0, i32 1
  %2568 = load i8, i8* %2567, align 8, !tbaa !22
  %2569 = icmp eq i8 %2568, 35
  br i1 %2569, label %2570, label %2573

; <label>:2570:                                   ; preds = %2566
  %2571 = bitcast %struct.TValue* %2556 to i64*
  %2572 = load i64, i64* %2571, align 8, !tbaa !21
  store i64 %2572, i64* %13, align 8, !tbaa !109
  br label %2576

; <label>:2573:                                   ; preds = %2566
  %2574 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2556, i64* nonnull %13, i32 0)
  %2575 = icmp eq i32 %2574, 0
  br i1 %2575, label %2582, label %2576

; <label>:2576:                                   ; preds = %2573, %2570
  %2577 = load i64, i64* %12, align 8, !tbaa !109
  %2578 = load i64, i64* %13, align 8, !tbaa !109
  %2579 = xor i64 %2578, %2577
  %2580 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2579, i64* %2580, align 8, !tbaa !21
  %2581 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2581, align 8, !tbaa !22
  br label %2585

; <label>:2582:                                   ; preds = %2573, %2563
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2583 = load i64, i64* %276, align 8, !tbaa !49
  store i64 %2583, i64* %278, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2553, %struct.TValue* %2556, %union.StackValue* %4081, i32 15)
  %2584 = load i32, i32* %280, align 8, !tbaa !21
  br label %2585

; <label>:2585:                                   ; preds = %2582, %2576
  %2586 = phi i32 [ %4083, %2576 ], [ %2584, %2582 ]
  %2587 = icmp eq i32 %2586, 0
  br i1 %2587, label %2592, label %2588

; <label>:2588:                                   ; preds = %2585
  %2589 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2590 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2591 = getelementptr inbounds %union.StackValue, %union.StackValue* %2590, i64 1
  br label %2592

; <label>:2592:                                   ; preds = %2585, %2588
  %2593 = phi i32 [ %2589, %2588 ], [ 0, %2585 ]
  %2594 = phi %union.StackValue* [ %2591, %2588 ], [ %4085, %2585 ]
  %2595 = getelementptr inbounds i32, i32* %4084, i64 1
  %2596 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2597:                                   ; preds = %4080
  %2598 = lshr i32 %4082, 16
  %2599 = and i32 %2598, 255
  %2600 = zext i32 %2599 to i64
  %2601 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2600, i32 0
  %2602 = lshr i32 %4082, 24
  %2603 = add nsw i32 %2602, -127
  %2604 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2600, i32 0, i32 1
  %2605 = load i8, i8* %2604, align 8, !tbaa !22
  %2606 = icmp eq i8 %2605, 35
  br i1 %2606, label %2607, label %2610

; <label>:2607:                                   ; preds = %2597
  %2608 = bitcast %struct.TValue* %2601 to i64*
  %2609 = load i64, i64* %2608, align 8, !tbaa !21
  store i64 %2609, i64* %14, align 8, !tbaa !109
  br label %2613

; <label>:2610:                                   ; preds = %2597
  %2611 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2601, i64* nonnull %14, i32 0)
  %2612 = icmp eq i32 %2611, 0
  br i1 %2612, label %2620, label %2613

; <label>:2613:                                   ; preds = %2610, %2607
  %2614 = load i64, i64* %14, align 8, !tbaa !109
  %2615 = sub nsw i32 127, %2602
  %2616 = sext i32 %2615 to i64
  %2617 = call fastcc i64 @luaV_shiftl(i64 %2614, i64 %2616)
  %2618 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2617, i64* %2618, align 8, !tbaa !21
  %2619 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2619, align 8, !tbaa !22
  br label %2631

; <label>:2620:                                   ; preds = %2610
  %2621 = trunc i32 %4082 to i16
  %2622 = icmp slt i16 %2621, 0
  %2623 = sub nsw i32 127, %2602
  %2624 = lshr i32 %4082, 15
  %2625 = and i32 %2624, 1
  %2626 = sub nsw i32 17, %2625
  %2627 = select i1 %2622, i32 %2623, i32 %2603
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2628 = load i64, i64* %379, align 8, !tbaa !49
  store i64 %2628, i64* %381, align 8, !tbaa !20
  %2629 = sext i32 %2627 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2601, i64 %2629, i32 0, %union.StackValue* %4081, i32 %2626)
  %2630 = load i32, i32* %383, align 8, !tbaa !21
  br label %2631

; <label>:2631:                                   ; preds = %2620, %2613
  %2632 = phi i32 [ %4083, %2613 ], [ %2630, %2620 ]
  %2633 = icmp eq i32 %2632, 0
  br i1 %2633, label %2638, label %2634

; <label>:2634:                                   ; preds = %2631
  %2635 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2636 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2637 = getelementptr inbounds %union.StackValue, %union.StackValue* %2636, i64 1
  br label %2638

; <label>:2638:                                   ; preds = %2631, %2634
  %2639 = phi i32 [ %2635, %2634 ], [ 0, %2631 ]
  %2640 = phi %union.StackValue* [ %2637, %2634 ], [ %4085, %2631 ]
  %2641 = getelementptr inbounds i32, i32* %4084, i64 1
  %2642 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2643:                                   ; preds = %4080
  %2644 = lshr i32 %4082, 16
  %2645 = and i32 %2644, 255
  %2646 = zext i32 %2645 to i64
  %2647 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2646, i32 0
  %2648 = lshr i32 %4082, 24
  %2649 = add nsw i32 %2648, -127
  %2650 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2646, i32 0, i32 1
  %2651 = load i8, i8* %2650, align 8, !tbaa !22
  %2652 = icmp eq i8 %2651, 35
  br i1 %2652, label %2653, label %2656

; <label>:2653:                                   ; preds = %2643
  %2654 = bitcast %struct.TValue* %2647 to i64*
  %2655 = load i64, i64* %2654, align 8, !tbaa !21
  store i64 %2655, i64* %15, align 8, !tbaa !109
  br label %2659

; <label>:2656:                                   ; preds = %2643
  %2657 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2647, i64* nonnull %15, i32 0)
  %2658 = icmp eq i32 %2657, 0
  br i1 %2658, label %2665, label %2659

; <label>:2659:                                   ; preds = %2656, %2653
  %2660 = sext i32 %2649 to i64
  %2661 = load i64, i64* %15, align 8, !tbaa !109
  %2662 = call fastcc i64 @luaV_shiftl(i64 %2660, i64 %2661)
  %2663 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2662, i64* %2663, align 8, !tbaa !21
  %2664 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2664, align 8, !tbaa !22
  br label %2669

; <label>:2665:                                   ; preds = %2656
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2666 = load i64, i64* %385, align 8, !tbaa !49
  store i64 %2666, i64* %387, align 8, !tbaa !20
  %2667 = sext i32 %2649 to i64
  call fastcc void @luaT_trybiniTM(%struct.lua_State* %0, %struct.TValue* %2647, i64 %2667, i32 1, %union.StackValue* %4081, i32 16)
  %2668 = load i32, i32* %389, align 8, !tbaa !21
  br label %2669

; <label>:2669:                                   ; preds = %2665, %2659
  %2670 = phi i32 [ %4083, %2659 ], [ %2668, %2665 ]
  %2671 = icmp eq i32 %2670, 0
  br i1 %2671, label %2676, label %2672

; <label>:2672:                                   ; preds = %2669
  %2673 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2674 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2675 = getelementptr inbounds %union.StackValue, %union.StackValue* %2674, i64 1
  br label %2676

; <label>:2676:                                   ; preds = %2669, %2672
  %2677 = phi i32 [ %2673, %2672 ], [ 0, %2669 ]
  %2678 = phi %union.StackValue* [ %2675, %2672 ], [ %4085, %2669 ]
  %2679 = getelementptr inbounds i32, i32* %4084, i64 1
  %2680 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2681:                                   ; preds = %4080
  %2682 = lshr i32 %4082, 16
  %2683 = and i32 %2682, 255
  %2684 = zext i32 %2683 to i64
  %2685 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2684, i32 0
  %2686 = lshr i32 %4082, 24
  %2687 = zext i32 %2686 to i64
  %2688 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2687, i32 0
  %2689 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2684, i32 0, i32 1
  %2690 = load i8, i8* %2689, align 8, !tbaa !22
  %2691 = icmp eq i8 %2690, 35
  br i1 %2691, label %2692, label %2695

; <label>:2692:                                   ; preds = %2681
  %2693 = bitcast %struct.TValue* %2685 to i64*
  %2694 = load i64, i64* %2693, align 8, !tbaa !21
  store i64 %2694, i64* %16, align 8, !tbaa !109
  br label %2698

; <label>:2695:                                   ; preds = %2681
  %2696 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2685, i64* nonnull %16, i32 0)
  %2697 = icmp eq i32 %2696, 0
  br i1 %2697, label %2715, label %2698

; <label>:2698:                                   ; preds = %2695, %2692
  %2699 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2687, i32 0, i32 1
  %2700 = load i8, i8* %2699, align 8, !tbaa !22
  %2701 = icmp eq i8 %2700, 35
  br i1 %2701, label %2702, label %2705

; <label>:2702:                                   ; preds = %2698
  %2703 = bitcast %struct.TValue* %2688 to i64*
  %2704 = load i64, i64* %2703, align 8, !tbaa !21
  store i64 %2704, i64* %17, align 8, !tbaa !109
  br label %2708

; <label>:2705:                                   ; preds = %2698
  %2706 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2688, i64* nonnull %17, i32 0)
  %2707 = icmp eq i32 %2706, 0
  br i1 %2707, label %2715, label %2708

; <label>:2708:                                   ; preds = %2705, %2702
  %2709 = load i64, i64* %16, align 8, !tbaa !109
  %2710 = load i64, i64* %17, align 8, !tbaa !109
  %2711 = sub nsw i64 0, %2710
  %2712 = call fastcc i64 @luaV_shiftl(i64 %2709, i64 %2711)
  %2713 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2712, i64* %2713, align 8, !tbaa !21
  %2714 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2714, align 8, !tbaa !22
  br label %2718

; <label>:2715:                                   ; preds = %2705, %2695
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2716 = load i64, i64* %288, align 8, !tbaa !49
  store i64 %2716, i64* %290, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2685, %struct.TValue* %2688, %union.StackValue* %4081, i32 17)
  %2717 = load i32, i32* %292, align 8, !tbaa !21
  br label %2718

; <label>:2718:                                   ; preds = %2715, %2708
  %2719 = phi i32 [ %4083, %2708 ], [ %2717, %2715 ]
  %2720 = icmp eq i32 %2719, 0
  br i1 %2720, label %2725, label %2721

; <label>:2721:                                   ; preds = %2718
  %2722 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2723 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2724 = getelementptr inbounds %union.StackValue, %union.StackValue* %2723, i64 1
  br label %2725

; <label>:2725:                                   ; preds = %2718, %2721
  %2726 = phi i32 [ %2722, %2721 ], [ 0, %2718 ]
  %2727 = phi %union.StackValue* [ %2724, %2721 ], [ %4085, %2718 ]
  %2728 = getelementptr inbounds i32, i32* %4084, i64 1
  %2729 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2730:                                   ; preds = %4080
  %2731 = lshr i32 %4082, 16
  %2732 = and i32 %2731, 255
  %2733 = zext i32 %2732 to i64
  %2734 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2733, i32 0
  %2735 = lshr i32 %4082, 24
  %2736 = zext i32 %2735 to i64
  %2737 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2736, i32 0
  %2738 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2733, i32 0, i32 1
  %2739 = load i8, i8* %2738, align 8, !tbaa !22
  %2740 = icmp eq i8 %2739, 35
  br i1 %2740, label %2741, label %2744

; <label>:2741:                                   ; preds = %2730
  %2742 = bitcast %struct.TValue* %2734 to i64*
  %2743 = load i64, i64* %2742, align 8, !tbaa !21
  store i64 %2743, i64* %18, align 8, !tbaa !109
  br label %2747

; <label>:2744:                                   ; preds = %2730
  %2745 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2734, i64* nonnull %18, i32 0)
  %2746 = icmp eq i32 %2745, 0
  br i1 %2746, label %2763, label %2747

; <label>:2747:                                   ; preds = %2744, %2741
  %2748 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2736, i32 0, i32 1
  %2749 = load i8, i8* %2748, align 8, !tbaa !22
  %2750 = icmp eq i8 %2749, 35
  br i1 %2750, label %2751, label %2754

; <label>:2751:                                   ; preds = %2747
  %2752 = bitcast %struct.TValue* %2737 to i64*
  %2753 = load i64, i64* %2752, align 8, !tbaa !21
  store i64 %2753, i64* %19, align 8, !tbaa !109
  br label %2757

; <label>:2754:                                   ; preds = %2747
  %2755 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2737, i64* nonnull %19, i32 0)
  %2756 = icmp eq i32 %2755, 0
  br i1 %2756, label %2763, label %2757

; <label>:2757:                                   ; preds = %2754, %2751
  %2758 = load i64, i64* %18, align 8, !tbaa !109
  %2759 = load i64, i64* %19, align 8, !tbaa !109
  %2760 = call fastcc i64 @luaV_shiftl(i64 %2758, i64 %2759)
  %2761 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2760, i64* %2761, align 8, !tbaa !21
  %2762 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2762, align 8, !tbaa !22
  br label %2766

; <label>:2763:                                   ; preds = %2754, %2744
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2764 = load i64, i64* %282, align 8, !tbaa !49
  store i64 %2764, i64* %284, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2734, %struct.TValue* %2737, %union.StackValue* %4081, i32 16)
  %2765 = load i32, i32* %286, align 8, !tbaa !21
  br label %2766

; <label>:2766:                                   ; preds = %2763, %2757
  %2767 = phi i32 [ %4083, %2757 ], [ %2765, %2763 ]
  %2768 = icmp eq i32 %2767, 0
  br i1 %2768, label %2773, label %2769

; <label>:2769:                                   ; preds = %2766
  %2770 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2771 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2772 = getelementptr inbounds %union.StackValue, %union.StackValue* %2771, i64 1
  br label %2773

; <label>:2773:                                   ; preds = %2766, %2769
  %2774 = phi i32 [ %2770, %2769 ], [ 0, %2766 ]
  %2775 = phi %union.StackValue* [ %2772, %2769 ], [ %4085, %2766 ]
  %2776 = getelementptr inbounds i32, i32* %4084, i64 1
  %2777 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2778:                                   ; preds = %4080
  %2779 = lshr i32 %4082, 16
  %2780 = and i32 %2779, 255
  %2781 = zext i32 %2780 to i64
  %2782 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2781, i32 0
  %2783 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2781, i32 0, i32 1
  %2784 = load i8, i8* %2783, align 8, !tbaa !22
  switch i8 %2784, label %2797 [
    i8 35, label %2785
    i8 19, label %2791
  ]

; <label>:2785:                                   ; preds = %2778
  %2786 = bitcast %struct.TValue* %2782 to i64*
  %2787 = load i64, i64* %2786, align 8, !tbaa !21
  %2788 = sub i64 0, %2787
  %2789 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2788, i64* %2789, align 8, !tbaa !21
  %2790 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2790, align 8, !tbaa !22
  br label %2800

; <label>:2791:                                   ; preds = %2778
  %2792 = bitcast %struct.TValue* %2782 to double*
  %2793 = load double, double* %2792, align 8, !tbaa !21
  %2794 = fsub double -0.000000e+00, %2793
  %2795 = bitcast %union.StackValue* %4081 to double*
  store double %2794, double* %2795, align 8, !tbaa !21
  %2796 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 19, i8* %2796, align 8, !tbaa !22
  br label %2800

; <label>:2797:                                   ; preds = %2778
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2798 = load i64, i64* %294, align 8, !tbaa !49
  store i64 %2798, i64* %296, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2782, %struct.TValue* %2782, %union.StackValue* %4081, i32 18)
  %2799 = load i32, i32* %298, align 8, !tbaa !21
  br label %2800

; <label>:2800:                                   ; preds = %2791, %2797, %2785
  %2801 = phi i32 [ %4083, %2785 ], [ %4083, %2791 ], [ %2799, %2797 ]
  %2802 = icmp eq i32 %2801, 0
  br i1 %2802, label %2807, label %2803

; <label>:2803:                                   ; preds = %2800
  %2804 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2805 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2806 = getelementptr inbounds %union.StackValue, %union.StackValue* %2805, i64 1
  br label %2807

; <label>:2807:                                   ; preds = %2800, %2803
  %2808 = phi i32 [ %2804, %2803 ], [ 0, %2800 ]
  %2809 = phi %union.StackValue* [ %2806, %2803 ], [ %4085, %2800 ]
  %2810 = getelementptr inbounds i32, i32* %4084, i64 1
  %2811 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2812:                                   ; preds = %4080
  %2813 = lshr i32 %4082, 16
  %2814 = and i32 %2813, 255
  %2815 = zext i32 %2814 to i64
  %2816 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2815, i32 0
  %2817 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2815, i32 0, i32 1
  %2818 = load i8, i8* %2817, align 8, !tbaa !22
  %2819 = icmp eq i8 %2818, 35
  br i1 %2819, label %2820, label %2823

; <label>:2820:                                   ; preds = %2812
  %2821 = bitcast %struct.TValue* %2816 to i64*
  %2822 = load i64, i64* %2821, align 8, !tbaa !21
  store i64 %2822, i64* %20, align 8, !tbaa !109
  br label %2826

; <label>:2823:                                   ; preds = %2812
  %2824 = call fastcc i32 @luaV_tointegerns(%struct.TValue* %2816, i64* nonnull %20, i32 0)
  %2825 = icmp eq i32 %2824, 0
  br i1 %2825, label %2831, label %2826

; <label>:2826:                                   ; preds = %2823, %2820
  %2827 = load i64, i64* %20, align 8, !tbaa !109
  %2828 = xor i64 %2827, -1
  %2829 = bitcast %union.StackValue* %4081 to i64*
  store i64 %2828, i64* %2829, align 8, !tbaa !21
  %2830 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 35, i8* %2830, align 8, !tbaa !22
  br label %2834

; <label>:2831:                                   ; preds = %2823
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2832 = load i64, i64* %391, align 8, !tbaa !49
  store i64 %2832, i64* %393, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2816, %struct.TValue* %2816, %union.StackValue* %4081, i32 19)
  %2833 = load i32, i32* %395, align 8, !tbaa !21
  br label %2834

; <label>:2834:                                   ; preds = %2831, %2826
  %2835 = phi i32 [ %4083, %2826 ], [ %2833, %2831 ]
  %2836 = icmp eq i32 %2835, 0
  br i1 %2836, label %2841, label %2837

; <label>:2837:                                   ; preds = %2834
  %2838 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2839 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2840 = getelementptr inbounds %union.StackValue, %union.StackValue* %2839, i64 1
  br label %2841

; <label>:2841:                                   ; preds = %2834, %2837
  %2842 = phi i32 [ %2838, %2837 ], [ 0, %2834 ]
  %2843 = phi %union.StackValue* [ %2840, %2837 ], [ %4085, %2834 ]
  %2844 = getelementptr inbounds i32, i32* %4084, i64 1
  %2845 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2846:                                   ; preds = %4080
  %2847 = lshr i32 %4082, 16
  %2848 = and i32 %2847, 255
  %2849 = zext i32 %2848 to i64
  %2850 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2849, i32 0, i32 1
  %2851 = load i8, i8* %2850, align 8, !tbaa !22
  %2852 = and i8 %2851, 15
  %2853 = icmp eq i8 %2852, 0
  br i1 %2853, label %2861, label %2854

; <label>:2854:                                   ; preds = %2846
  %2855 = icmp eq i8 %2851, 1
  br i1 %2855, label %2856, label %2861

; <label>:2856:                                   ; preds = %2854
  %2857 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2849, i32 0, i32 0
  %2858 = bitcast %union.Value* %2857 to i32*
  %2859 = load i32, i32* %2858, align 8, !tbaa !21
  %2860 = icmp eq i32 %2859, 0
  br label %2861

; <label>:2861:                                   ; preds = %2854, %2856, %2846
  %2862 = phi i1 [ true, %2846 ], [ false, %2854 ], [ %2860, %2856 ]
  %2863 = zext i1 %2862 to i32
  %2864 = bitcast %union.StackValue* %4081 to i32*
  store i32 %2863, i32* %2864, align 8, !tbaa !21
  %2865 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 1, i8* %2865, align 8, !tbaa !22
  %2866 = icmp eq i32 %4083, 0
  br i1 %2866, label %2871, label %2867

; <label>:2867:                                   ; preds = %2861
  %2868 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2869 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2870 = getelementptr inbounds %union.StackValue, %union.StackValue* %2869, i64 1
  br label %2871

; <label>:2871:                                   ; preds = %2861, %2867
  %2872 = phi i32 [ %2868, %2867 ], [ 0, %2861 ]
  %2873 = phi %union.StackValue* [ %2870, %2867 ], [ %4085, %2861 ]
  %2874 = getelementptr inbounds i32, i32* %4084, i64 1
  %2875 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2876:                                   ; preds = %4080
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2877 = load i64, i64* %36, align 8, !tbaa !49
  store i64 %2877, i64* %38, align 8, !tbaa !20
  %2878 = lshr i32 %4082, 16
  %2879 = and i32 %2878, 255
  %2880 = zext i32 %2879 to i64
  %2881 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2880, i32 0
  call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %4081, %struct.TValue* %2881)
  %2882 = load i32, i32* %40, align 8, !tbaa !21
  %2883 = icmp eq i32 %2882, 0
  br i1 %2883, label %2888, label %2884

; <label>:2884:                                   ; preds = %2876
  %2885 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %2886 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2887 = getelementptr inbounds %union.StackValue, %union.StackValue* %2886, i64 1
  br label %2888

; <label>:2888:                                   ; preds = %2876, %2884
  %2889 = phi i32 [ %2885, %2884 ], [ 0, %2876 ]
  %2890 = phi %union.StackValue* [ %2887, %2884 ], [ %4085, %2876 ]
  %2891 = getelementptr inbounds i32, i32* %4084, i64 1
  %2892 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2893:                                   ; preds = %4080
  %2894 = lshr i32 %4082, 16
  %2895 = and i32 %2894, 255
  %2896 = zext i32 %2895 to i64
  %2897 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %2896
  store %union.StackValue* %2897, %union.StackValue** %41, align 8, !tbaa !20
  store i32* %4084, i32** %30, align 8, !tbaa !21
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %2895)
  %2898 = load %struct.global_State*, %struct.global_State** %44, align 8, !tbaa !2
  %2899 = getelementptr inbounds %struct.global_State, %struct.global_State* %2898, i64 0, i32 3
  %2900 = load i64, i64* %2899, align 8, !tbaa !11
  %2901 = icmp sgt i64 %2900, 0
  br i1 %2901, label %2902, label %2903

; <label>:2902:                                   ; preds = %2893
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %2903

; <label>:2903:                                   ; preds = %2902, %2893
  %2904 = load i32, i32* %43, align 8, !tbaa !21
  %2905 = icmp eq i32 %2904, 0
  br i1 %2905, label %2910, label %2906

; <label>:2906:                                   ; preds = %2903
  %2907 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %2908 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2909 = getelementptr inbounds %union.StackValue, %union.StackValue* %2908, i64 1
  br label %2910

; <label>:2910:                                   ; preds = %2903, %2906
  %2911 = phi i32 [ %2907, %2906 ], [ 0, %2903 ]
  %2912 = phi %union.StackValue* [ %2909, %2906 ], [ %4085, %2903 ]
  %2913 = getelementptr inbounds i32, i32* %4084, i64 1
  %2914 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2915:                                   ; preds = %4080
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2916 = load i64, i64* %47, align 8, !tbaa !49
  store i64 %2916, i64* %48, align 8, !tbaa !20
  %2917 = call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4081, i32 0)
  %2918 = load i32, i32* %50, align 8, !tbaa !21
  %2919 = icmp eq i32 %2918, 0
  br i1 %2919, label %2924, label %2920

; <label>:2920:                                   ; preds = %2915
  %2921 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %2922 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2923 = getelementptr inbounds %union.StackValue, %union.StackValue* %2922, i64 1
  br label %2924

; <label>:2924:                                   ; preds = %2915, %2920
  %2925 = phi i32 [ %2921, %2920 ], [ 0, %2915 ]
  %2926 = phi %union.StackValue* [ %2923, %2920 ], [ %4085, %2915 ]
  %2927 = getelementptr inbounds i32, i32* %4084, i64 1
  %2928 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2929:                                   ; preds = %4080
  store i32* %4084, i32** %30, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* %4081)
  %2930 = icmp eq i32 %4083, 0
  br i1 %2930, label %2935, label %2931

; <label>:2931:                                   ; preds = %2929
  %2932 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %2933 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2934 = getelementptr inbounds %union.StackValue, %union.StackValue* %2933, i64 1
  br label %2935

; <label>:2935:                                   ; preds = %2929, %2931
  %2936 = phi i32 [ %2932, %2931 ], [ 0, %2929 ]
  %2937 = phi %union.StackValue* [ %2934, %2931 ], [ %4085, %2929 ]
  %2938 = getelementptr inbounds i32, i32* %4084, i64 1
  %2939 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:2940:                                   ; preds = %4080
  %2941 = lshr i32 %4082, 7
  %2942 = add nsw i32 %2941, -16777215
  %2943 = sext i32 %2942 to i64
  %2944 = getelementptr inbounds i32, i32* %4084, i64 %2943
  %2945 = load i32, i32* %52, align 8, !tbaa !21
  %2946 = icmp eq i32 %2945, 0
  br i1 %2946, label %2951, label %2947

; <label>:2947:                                   ; preds = %2940
  %2948 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2944)
  %2949 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2950 = getelementptr inbounds %union.StackValue, %union.StackValue* %2949, i64 1
  br label %2951

; <label>:2951:                                   ; preds = %2940, %2947
  %2952 = phi i32 [ %2948, %2947 ], [ 0, %2940 ]
  %2953 = phi %union.StackValue* [ %2950, %2947 ], [ %4085, %2940 ]
  %2954 = getelementptr inbounds i32, i32* %2944, i64 1
  %2955 = load i32, i32* %2944, align 4, !tbaa !70
  br label %476

; <label>:2956:                                   ; preds = %4080
  %2957 = lshr i32 %4082, 16
  %2958 = and i32 %2957, 255
  %2959 = zext i32 %2958 to i64
  %2960 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2959, i32 0
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %2961 = load i64, i64* %54, align 8, !tbaa !49
  store i64 %2961, i64* %56, align 8, !tbaa !20
  %2962 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %2963 = call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %2962, %struct.TValue* %2960)
  %2964 = load i32, i32* %58, align 8, !tbaa !21
  %2965 = lshr i32 %4082, 15
  %2966 = and i32 %2965, 1
  %2967 = icmp eq i32 %2963, %2966
  br i1 %2967, label %2968, label %2973

; <label>:2968:                                   ; preds = %2956
  %2969 = load i32, i32* %4084, align 4, !tbaa !70
  %2970 = lshr i32 %2969, 7
  %2971 = add nsw i32 %2970, -16777214
  %2972 = sext i32 %2971 to i64
  br label %2973

; <label>:2973:                                   ; preds = %2956, %2968
  %2974 = phi i64 [ %2972, %2968 ], [ 1, %2956 ]
  %2975 = getelementptr inbounds i32, i32* %4084, i64 %2974
  %2976 = icmp eq i32 %2964, 0
  br i1 %2976, label %2981, label %2977

; <label>:2977:                                   ; preds = %2973
  %2978 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %2975)
  %2979 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %2980 = getelementptr inbounds %union.StackValue, %union.StackValue* %2979, i64 1
  br label %2981

; <label>:2981:                                   ; preds = %2973, %2977
  %2982 = phi i32 [ %2978, %2977 ], [ 0, %2973 ]
  %2983 = phi %union.StackValue* [ %2980, %2977 ], [ %4085, %2973 ]
  %2984 = getelementptr inbounds i32, i32* %2975, i64 1
  %2985 = load i32, i32* %2975, align 4, !tbaa !70
  br label %476

; <label>:2986:                                   ; preds = %4080
  %2987 = lshr i32 %4082, 16
  %2988 = and i32 %2987, 255
  %2989 = zext i32 %2988 to i64
  %2990 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2989, i32 0
  %2991 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %2992 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %2993 = load i8, i8* %2992, align 8, !tbaa !21
  %2994 = icmp eq i8 %2993, 35
  br i1 %2994, label %2995, label %3006

; <label>:2995:                                   ; preds = %2986
  %2996 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2989, i32 0, i32 1
  %2997 = load i8, i8* %2996, align 8, !tbaa !22
  %2998 = icmp eq i8 %2997, 35
  br i1 %2998, label %2999, label %3009

; <label>:2999:                                   ; preds = %2995
  %3000 = bitcast %union.StackValue* %4081 to i64*
  %3001 = load i64, i64* %3000, align 8, !tbaa !21
  %3002 = bitcast %struct.TValue* %2990 to i64*
  %3003 = load i64, i64* %3002, align 8, !tbaa !21
  %3004 = icmp slt i64 %3001, %3003
  %3005 = zext i1 %3004 to i32
  br label %3020

; <label>:3006:                                   ; preds = %2986
  %3007 = and i8 %2993, 15
  %3008 = icmp eq i8 %3007, 3
  br i1 %3008, label %3009, label %3016

; <label>:3009:                                   ; preds = %2995, %3006
  %3010 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %2989, i32 0, i32 1
  %3011 = load i8, i8* %3010, align 8, !tbaa !22
  %3012 = and i8 %3011, 15
  %3013 = icmp eq i8 %3012, 3
  br i1 %3013, label %3014, label %3016

; <label>:3014:                                   ; preds = %3009
  %3015 = call fastcc i32 @LTnum(%struct.TValue* %2991, %struct.TValue* nonnull %2990)
  br label %3020

; <label>:3016:                                   ; preds = %3009, %3006
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3017 = load i64, i64* %300, align 8, !tbaa !49
  store i64 %3017, i64* %302, align 8, !tbaa !20
  %3018 = call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* %2991, %struct.TValue* %2990)
  %3019 = load i32, i32* %304, align 8, !tbaa !21
  br label %3020

; <label>:3020:                                   ; preds = %3014, %3016, %2999
  %3021 = phi i32 [ %3005, %2999 ], [ %3015, %3014 ], [ %3018, %3016 ]
  %3022 = phi i32 [ %4083, %2999 ], [ %4083, %3014 ], [ %3019, %3016 ]
  %3023 = lshr i32 %4082, 15
  %3024 = and i32 %3023, 1
  %3025 = icmp eq i32 %3021, %3024
  br i1 %3025, label %3028, label %3026

; <label>:3026:                                   ; preds = %3020
  %3027 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3035

; <label>:3028:                                   ; preds = %3020
  %3029 = load i32, i32* %4084, align 4, !tbaa !70
  %3030 = lshr i32 %3029, 7
  %3031 = add nsw i32 %3030, -16777214
  %3032 = sext i32 %3031 to i64
  %3033 = getelementptr inbounds i32, i32* %4084, i64 %3032
  %3034 = load i32, i32* %397, align 8, !tbaa !21
  br label %3035

; <label>:3035:                                   ; preds = %3028, %3026
  %3036 = phi i32 [ %3022, %3026 ], [ %3034, %3028 ]
  %3037 = phi i32* [ %3027, %3026 ], [ %3033, %3028 ]
  %3038 = icmp eq i32 %3036, 0
  br i1 %3038, label %3043, label %3039

; <label>:3039:                                   ; preds = %3035
  %3040 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3037)
  %3041 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3042 = getelementptr inbounds %union.StackValue, %union.StackValue* %3041, i64 1
  br label %3043

; <label>:3043:                                   ; preds = %3035, %3039
  %3044 = phi i32 [ %3040, %3039 ], [ 0, %3035 ]
  %3045 = phi %union.StackValue* [ %3042, %3039 ], [ %4085, %3035 ]
  %3046 = getelementptr inbounds i32, i32* %3037, i64 1
  %3047 = load i32, i32* %3037, align 4, !tbaa !70
  br label %476

; <label>:3048:                                   ; preds = %4080
  %3049 = lshr i32 %4082, 16
  %3050 = and i32 %3049, 255
  %3051 = zext i32 %3050 to i64
  %3052 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %3051, i32 0
  %3053 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3054 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3055 = load i8, i8* %3054, align 8, !tbaa !21
  %3056 = icmp eq i8 %3055, 35
  br i1 %3056, label %3057, label %3068

; <label>:3057:                                   ; preds = %3048
  %3058 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %3051, i32 0, i32 1
  %3059 = load i8, i8* %3058, align 8, !tbaa !22
  %3060 = icmp eq i8 %3059, 35
  br i1 %3060, label %3061, label %3071

; <label>:3061:                                   ; preds = %3057
  %3062 = bitcast %union.StackValue* %4081 to i64*
  %3063 = load i64, i64* %3062, align 8, !tbaa !21
  %3064 = bitcast %struct.TValue* %3052 to i64*
  %3065 = load i64, i64* %3064, align 8, !tbaa !21
  %3066 = icmp sle i64 %3063, %3065
  %3067 = zext i1 %3066 to i32
  br label %3082

; <label>:3068:                                   ; preds = %3048
  %3069 = and i8 %3055, 15
  %3070 = icmp eq i8 %3069, 3
  br i1 %3070, label %3071, label %3078

; <label>:3071:                                   ; preds = %3057, %3068
  %3072 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %3051, i32 0, i32 1
  %3073 = load i8, i8* %3072, align 8, !tbaa !22
  %3074 = and i8 %3073, 15
  %3075 = icmp eq i8 %3074, 3
  br i1 %3075, label %3076, label %3078

; <label>:3076:                                   ; preds = %3071
  %3077 = call fastcc i32 @LEnum(%struct.TValue* %3053, %struct.TValue* nonnull %3052)
  br label %3082

; <label>:3078:                                   ; preds = %3071, %3068
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3079 = load i64, i64* %306, align 8, !tbaa !49
  store i64 %3079, i64* %308, align 8, !tbaa !20
  %3080 = call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* %3053, %struct.TValue* %3052)
  %3081 = load i32, i32* %310, align 8, !tbaa !21
  br label %3082

; <label>:3082:                                   ; preds = %3076, %3078, %3061
  %3083 = phi i32 [ %3067, %3061 ], [ %3077, %3076 ], [ %3080, %3078 ]
  %3084 = phi i32 [ %4083, %3061 ], [ %4083, %3076 ], [ %3081, %3078 ]
  %3085 = lshr i32 %4082, 15
  %3086 = and i32 %3085, 1
  %3087 = icmp eq i32 %3083, %3086
  br i1 %3087, label %3090, label %3088

; <label>:3088:                                   ; preds = %3082
  %3089 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3097

; <label>:3090:                                   ; preds = %3082
  %3091 = load i32, i32* %4084, align 4, !tbaa !70
  %3092 = lshr i32 %3091, 7
  %3093 = add nsw i32 %3092, -16777214
  %3094 = sext i32 %3093 to i64
  %3095 = getelementptr inbounds i32, i32* %4084, i64 %3094
  %3096 = load i32, i32* %399, align 8, !tbaa !21
  br label %3097

; <label>:3097:                                   ; preds = %3090, %3088
  %3098 = phi i32 [ %3084, %3088 ], [ %3096, %3090 ]
  %3099 = phi i32* [ %3089, %3088 ], [ %3095, %3090 ]
  %3100 = icmp eq i32 %3098, 0
  br i1 %3100, label %3105, label %3101

; <label>:3101:                                   ; preds = %3097
  %3102 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3099)
  %3103 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3104 = getelementptr inbounds %union.StackValue, %union.StackValue* %3103, i64 1
  br label %3105

; <label>:3105:                                   ; preds = %3097, %3101
  %3106 = phi i32 [ %3102, %3101 ], [ 0, %3097 ]
  %3107 = phi %union.StackValue* [ %3104, %3101 ], [ %4085, %3097 ]
  %3108 = getelementptr inbounds i32, i32* %3099, i64 1
  %3109 = load i32, i32* %3099, align 4, !tbaa !70
  br label %476

; <label>:3110:                                   ; preds = %4080
  %3111 = lshr i32 %4082, 16
  %3112 = and i32 %3111, 255
  %3113 = zext i32 %3112 to i64
  %3114 = getelementptr inbounds %struct.TValue, %struct.TValue* %429, i64 %3113
  %3115 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3116 = call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %3115, %struct.TValue* %3114)
  %3117 = lshr i32 %4082, 15
  %3118 = and i32 %3117, 1
  %3119 = icmp eq i32 %3116, %3118
  br i1 %3119, label %3122, label %3120

; <label>:3120:                                   ; preds = %3110
  %3121 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3129

; <label>:3122:                                   ; preds = %3110
  %3123 = load i32, i32* %4084, align 4, !tbaa !70
  %3124 = lshr i32 %3123, 7
  %3125 = add nsw i32 %3124, -16777214
  %3126 = sext i32 %3125 to i64
  %3127 = getelementptr inbounds i32, i32* %4084, i64 %3126
  %3128 = load i32, i32* %312, align 8, !tbaa !21
  br label %3129

; <label>:3129:                                   ; preds = %3122, %3120
  %3130 = phi i32 [ %4083, %3120 ], [ %3128, %3122 ]
  %3131 = phi i32* [ %3121, %3120 ], [ %3127, %3122 ]
  %3132 = icmp eq i32 %3130, 0
  br i1 %3132, label %3137, label %3133

; <label>:3133:                                   ; preds = %3129
  %3134 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3131)
  %3135 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3136 = getelementptr inbounds %union.StackValue, %union.StackValue* %3135, i64 1
  br label %3137

; <label>:3137:                                   ; preds = %3129, %3133
  %3138 = phi i32 [ %3134, %3133 ], [ 0, %3129 ]
  %3139 = phi %union.StackValue* [ %3136, %3133 ], [ %4085, %3129 ]
  %3140 = getelementptr inbounds i32, i32* %3131, i64 1
  %3141 = load i32, i32* %3131, align 4, !tbaa !70
  br label %476

; <label>:3142:                                   ; preds = %4080
  %3143 = lshr i32 %4082, 16
  %3144 = and i32 %3143, 255
  %3145 = add nsw i32 %3144, -127
  %3146 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3147 = load i8, i8* %3146, align 8, !tbaa !21
  switch i8 %3147, label %3148 [
    i8 35, label %3151
    i8 19, label %3156
  ]

; <label>:3148:                                   ; preds = %3142
  %3149 = trunc i32 %4082 to i16
  %3150 = icmp slt i16 %3149, 0
  br i1 %3150, label %3166, label %3168

; <label>:3151:                                   ; preds = %3142
  %3152 = bitcast %union.StackValue* %4081 to i64*
  %3153 = load i64, i64* %3152, align 8, !tbaa !21
  %3154 = sext i32 %3145 to i64
  %3155 = icmp eq i64 %3153, %3154
  br label %3161

; <label>:3156:                                   ; preds = %3142
  %3157 = bitcast %union.StackValue* %4081 to double*
  %3158 = load double, double* %3157, align 8, !tbaa !21
  %3159 = sitofp i32 %3145 to double
  %3160 = fcmp oeq double %3158, %3159
  br label %3161

; <label>:3161:                                   ; preds = %3156, %3151
  %3162 = phi i1 [ %3155, %3151 ], [ %3160, %3156 ]
  %3163 = trunc i32 %4082 to i16
  %3164 = icmp slt i16 %3163, 0
  %3165 = xor i1 %3164, %3162
  br i1 %3165, label %3166, label %3168

; <label>:3166:                                   ; preds = %3148, %3161
  %3167 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3175

; <label>:3168:                                   ; preds = %3148, %3161
  %3169 = load i32, i32* %4084, align 4, !tbaa !70
  %3170 = lshr i32 %3169, 7
  %3171 = add nsw i32 %3170, -16777214
  %3172 = sext i32 %3171 to i64
  %3173 = getelementptr inbounds i32, i32* %4084, i64 %3172
  %3174 = load i32, i32* %314, align 8, !tbaa !21
  br label %3175

; <label>:3175:                                   ; preds = %3168, %3166
  %3176 = phi i32 [ %4083, %3166 ], [ %3174, %3168 ]
  %3177 = phi i32* [ %3167, %3166 ], [ %3173, %3168 ]
  %3178 = icmp eq i32 %3176, 0
  br i1 %3178, label %3183, label %3179

; <label>:3179:                                   ; preds = %3175
  %3180 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3177)
  %3181 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3182 = getelementptr inbounds %union.StackValue, %union.StackValue* %3181, i64 1
  br label %3183

; <label>:3183:                                   ; preds = %3175, %3179
  %3184 = phi i32 [ %3180, %3179 ], [ 0, %3175 ]
  %3185 = phi %union.StackValue* [ %3182, %3179 ], [ %4085, %3175 ]
  %3186 = getelementptr inbounds i32, i32* %3177, i64 1
  %3187 = load i32, i32* %3177, align 4, !tbaa !70
  br label %476

; <label>:3188:                                   ; preds = %4080
  %3189 = lshr i32 %4082, 16
  %3190 = and i32 %3189, 255
  %3191 = add nsw i32 %3190, -127
  %3192 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3193 = load i8, i8* %3192, align 8, !tbaa !21
  switch i8 %3193, label %3206 [
    i8 35, label %3194
    i8 19, label %3200
  ]

; <label>:3194:                                   ; preds = %3188
  %3195 = bitcast %union.StackValue* %4081 to i64*
  %3196 = load i64, i64* %3195, align 8, !tbaa !21
  %3197 = sext i32 %3191 to i64
  %3198 = icmp slt i64 %3196, %3197
  %3199 = zext i1 %3198 to i32
  br label %3212

; <label>:3200:                                   ; preds = %3188
  %3201 = bitcast %union.StackValue* %4081 to double*
  %3202 = load double, double* %3201, align 8, !tbaa !21
  %3203 = sitofp i32 %3191 to double
  %3204 = fcmp olt double %3202, %3203
  %3205 = zext i1 %3204 to i32
  br label %3212

; <label>:3206:                                   ; preds = %3188
  %3207 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3208 = lshr i32 %4082, 24
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3209 = load i64, i64* %316, align 8, !tbaa !49
  store i64 %3209, i64* %318, align 8, !tbaa !20
  %3210 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %3207, i32 %3191, i32 0, i32 %3208, i32 20)
  %3211 = load i32, i32* %320, align 8, !tbaa !21
  br label %3212

; <label>:3212:                                   ; preds = %3200, %3206, %3194
  %3213 = phi i32 [ %3199, %3194 ], [ %3205, %3200 ], [ %3210, %3206 ]
  %3214 = phi i32 [ %4083, %3194 ], [ %4083, %3200 ], [ %3211, %3206 ]
  %3215 = lshr i32 %4082, 15
  %3216 = and i32 %3215, 1
  %3217 = icmp eq i32 %3213, %3216
  br i1 %3217, label %3220, label %3218

; <label>:3218:                                   ; preds = %3212
  %3219 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3227

; <label>:3220:                                   ; preds = %3212
  %3221 = load i32, i32* %4084, align 4, !tbaa !70
  %3222 = lshr i32 %3221, 7
  %3223 = add nsw i32 %3222, -16777214
  %3224 = sext i32 %3223 to i64
  %3225 = getelementptr inbounds i32, i32* %4084, i64 %3224
  %3226 = load i32, i32* %401, align 8, !tbaa !21
  br label %3227

; <label>:3227:                                   ; preds = %3220, %3218
  %3228 = phi i32 [ %3214, %3218 ], [ %3226, %3220 ]
  %3229 = phi i32* [ %3219, %3218 ], [ %3225, %3220 ]
  %3230 = icmp eq i32 %3228, 0
  br i1 %3230, label %3235, label %3231

; <label>:3231:                                   ; preds = %3227
  %3232 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3229)
  %3233 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3234 = getelementptr inbounds %union.StackValue, %union.StackValue* %3233, i64 1
  br label %3235

; <label>:3235:                                   ; preds = %3227, %3231
  %3236 = phi i32 [ %3232, %3231 ], [ 0, %3227 ]
  %3237 = phi %union.StackValue* [ %3234, %3231 ], [ %4085, %3227 ]
  %3238 = getelementptr inbounds i32, i32* %3229, i64 1
  %3239 = load i32, i32* %3229, align 4, !tbaa !70
  br label %476

; <label>:3240:                                   ; preds = %4080
  %3241 = lshr i32 %4082, 16
  %3242 = and i32 %3241, 255
  %3243 = add nsw i32 %3242, -127
  %3244 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3245 = load i8, i8* %3244, align 8, !tbaa !21
  switch i8 %3245, label %3258 [
    i8 35, label %3246
    i8 19, label %3252
  ]

; <label>:3246:                                   ; preds = %3240
  %3247 = bitcast %union.StackValue* %4081 to i64*
  %3248 = load i64, i64* %3247, align 8, !tbaa !21
  %3249 = sext i32 %3243 to i64
  %3250 = icmp sle i64 %3248, %3249
  %3251 = zext i1 %3250 to i32
  br label %3264

; <label>:3252:                                   ; preds = %3240
  %3253 = bitcast %union.StackValue* %4081 to double*
  %3254 = load double, double* %3253, align 8, !tbaa !21
  %3255 = sitofp i32 %3243 to double
  %3256 = fcmp ole double %3254, %3255
  %3257 = zext i1 %3256 to i32
  br label %3264

; <label>:3258:                                   ; preds = %3240
  %3259 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3260 = lshr i32 %4082, 24
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3261 = load i64, i64* %322, align 8, !tbaa !49
  store i64 %3261, i64* %324, align 8, !tbaa !20
  %3262 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %3259, i32 %3243, i32 0, i32 %3260, i32 21)
  %3263 = load i32, i32* %326, align 8, !tbaa !21
  br label %3264

; <label>:3264:                                   ; preds = %3252, %3258, %3246
  %3265 = phi i32 [ %3251, %3246 ], [ %3257, %3252 ], [ %3262, %3258 ]
  %3266 = phi i32 [ %4083, %3246 ], [ %4083, %3252 ], [ %3263, %3258 ]
  %3267 = lshr i32 %4082, 15
  %3268 = and i32 %3267, 1
  %3269 = icmp eq i32 %3265, %3268
  br i1 %3269, label %3272, label %3270

; <label>:3270:                                   ; preds = %3264
  %3271 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3279

; <label>:3272:                                   ; preds = %3264
  %3273 = load i32, i32* %4084, align 4, !tbaa !70
  %3274 = lshr i32 %3273, 7
  %3275 = add nsw i32 %3274, -16777214
  %3276 = sext i32 %3275 to i64
  %3277 = getelementptr inbounds i32, i32* %4084, i64 %3276
  %3278 = load i32, i32* %403, align 8, !tbaa !21
  br label %3279

; <label>:3279:                                   ; preds = %3272, %3270
  %3280 = phi i32 [ %3266, %3270 ], [ %3278, %3272 ]
  %3281 = phi i32* [ %3271, %3270 ], [ %3277, %3272 ]
  %3282 = icmp eq i32 %3280, 0
  br i1 %3282, label %3287, label %3283

; <label>:3283:                                   ; preds = %3279
  %3284 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3281)
  %3285 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3286 = getelementptr inbounds %union.StackValue, %union.StackValue* %3285, i64 1
  br label %3287

; <label>:3287:                                   ; preds = %3279, %3283
  %3288 = phi i32 [ %3284, %3283 ], [ 0, %3279 ]
  %3289 = phi %union.StackValue* [ %3286, %3283 ], [ %4085, %3279 ]
  %3290 = getelementptr inbounds i32, i32* %3281, i64 1
  %3291 = load i32, i32* %3281, align 4, !tbaa !70
  br label %476

; <label>:3292:                                   ; preds = %4080
  %3293 = lshr i32 %4082, 16
  %3294 = and i32 %3293, 255
  %3295 = add nsw i32 %3294, -127
  %3296 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3297 = load i8, i8* %3296, align 8, !tbaa !21
  switch i8 %3297, label %3310 [
    i8 35, label %3298
    i8 19, label %3304
  ]

; <label>:3298:                                   ; preds = %3292
  %3299 = bitcast %union.StackValue* %4081 to i64*
  %3300 = load i64, i64* %3299, align 8, !tbaa !21
  %3301 = sext i32 %3295 to i64
  %3302 = icmp sgt i64 %3300, %3301
  %3303 = zext i1 %3302 to i32
  br label %3316

; <label>:3304:                                   ; preds = %3292
  %3305 = bitcast %union.StackValue* %4081 to double*
  %3306 = load double, double* %3305, align 8, !tbaa !21
  %3307 = sitofp i32 %3295 to double
  %3308 = fcmp ogt double %3306, %3307
  %3309 = zext i1 %3308 to i32
  br label %3316

; <label>:3310:                                   ; preds = %3292
  %3311 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3312 = lshr i32 %4082, 24
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3313 = load i64, i64* %328, align 8, !tbaa !49
  store i64 %3313, i64* %330, align 8, !tbaa !20
  %3314 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %3311, i32 %3295, i32 1, i32 %3312, i32 20)
  %3315 = load i32, i32* %332, align 8, !tbaa !21
  br label %3316

; <label>:3316:                                   ; preds = %3304, %3310, %3298
  %3317 = phi i32 [ %3303, %3298 ], [ %3309, %3304 ], [ %3314, %3310 ]
  %3318 = phi i32 [ %4083, %3298 ], [ %4083, %3304 ], [ %3315, %3310 ]
  %3319 = lshr i32 %4082, 15
  %3320 = and i32 %3319, 1
  %3321 = icmp eq i32 %3317, %3320
  br i1 %3321, label %3324, label %3322

; <label>:3322:                                   ; preds = %3316
  %3323 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3331

; <label>:3324:                                   ; preds = %3316
  %3325 = load i32, i32* %4084, align 4, !tbaa !70
  %3326 = lshr i32 %3325, 7
  %3327 = add nsw i32 %3326, -16777214
  %3328 = sext i32 %3327 to i64
  %3329 = getelementptr inbounds i32, i32* %4084, i64 %3328
  %3330 = load i32, i32* %405, align 8, !tbaa !21
  br label %3331

; <label>:3331:                                   ; preds = %3324, %3322
  %3332 = phi i32 [ %3318, %3322 ], [ %3330, %3324 ]
  %3333 = phi i32* [ %3323, %3322 ], [ %3329, %3324 ]
  %3334 = icmp eq i32 %3332, 0
  br i1 %3334, label %3339, label %3335

; <label>:3335:                                   ; preds = %3331
  %3336 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3333)
  %3337 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3338 = getelementptr inbounds %union.StackValue, %union.StackValue* %3337, i64 1
  br label %3339

; <label>:3339:                                   ; preds = %3331, %3335
  %3340 = phi i32 [ %3336, %3335 ], [ 0, %3331 ]
  %3341 = phi %union.StackValue* [ %3338, %3335 ], [ %4085, %3331 ]
  %3342 = getelementptr inbounds i32, i32* %3333, i64 1
  %3343 = load i32, i32* %3333, align 4, !tbaa !70
  br label %476

; <label>:3344:                                   ; preds = %4080
  %3345 = lshr i32 %4082, 16
  %3346 = and i32 %3345, 255
  %3347 = add nsw i32 %3346, -127
  %3348 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3349 = load i8, i8* %3348, align 8, !tbaa !21
  switch i8 %3349, label %3362 [
    i8 35, label %3350
    i8 19, label %3356
  ]

; <label>:3350:                                   ; preds = %3344
  %3351 = bitcast %union.StackValue* %4081 to i64*
  %3352 = load i64, i64* %3351, align 8, !tbaa !21
  %3353 = sext i32 %3347 to i64
  %3354 = icmp sge i64 %3352, %3353
  %3355 = zext i1 %3354 to i32
  br label %3368

; <label>:3356:                                   ; preds = %3344
  %3357 = bitcast %union.StackValue* %4081 to double*
  %3358 = load double, double* %3357, align 8, !tbaa !21
  %3359 = sitofp i32 %3347 to double
  %3360 = fcmp oge double %3358, %3359
  %3361 = zext i1 %3360 to i32
  br label %3368

; <label>:3362:                                   ; preds = %3344
  %3363 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3364 = lshr i32 %4082, 24
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3365 = load i64, i64* %334, align 8, !tbaa !49
  store i64 %3365, i64* %336, align 8, !tbaa !20
  %3366 = call fastcc i32 @luaT_callorderiTM(%struct.lua_State* %0, %struct.TValue* %3363, i32 %3347, i32 1, i32 %3364, i32 21)
  %3367 = load i32, i32* %338, align 8, !tbaa !21
  br label %3368

; <label>:3368:                                   ; preds = %3356, %3362, %3350
  %3369 = phi i32 [ %3355, %3350 ], [ %3361, %3356 ], [ %3366, %3362 ]
  %3370 = phi i32 [ %4083, %3350 ], [ %4083, %3356 ], [ %3367, %3362 ]
  %3371 = lshr i32 %4082, 15
  %3372 = and i32 %3371, 1
  %3373 = icmp eq i32 %3369, %3372
  br i1 %3373, label %3376, label %3374

; <label>:3374:                                   ; preds = %3368
  %3375 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3383

; <label>:3376:                                   ; preds = %3368
  %3377 = load i32, i32* %4084, align 4, !tbaa !70
  %3378 = lshr i32 %3377, 7
  %3379 = add nsw i32 %3378, -16777214
  %3380 = sext i32 %3379 to i64
  %3381 = getelementptr inbounds i32, i32* %4084, i64 %3380
  %3382 = load i32, i32* %407, align 8, !tbaa !21
  br label %3383

; <label>:3383:                                   ; preds = %3376, %3374
  %3384 = phi i32 [ %3370, %3374 ], [ %3382, %3376 ]
  %3385 = phi i32* [ %3375, %3374 ], [ %3381, %3376 ]
  %3386 = icmp eq i32 %3384, 0
  br i1 %3386, label %3391, label %3387

; <label>:3387:                                   ; preds = %3383
  %3388 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3385)
  %3389 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3390 = getelementptr inbounds %union.StackValue, %union.StackValue* %3389, i64 1
  br label %3391

; <label>:3391:                                   ; preds = %3383, %3387
  %3392 = phi i32 [ %3388, %3387 ], [ 0, %3383 ]
  %3393 = phi %union.StackValue* [ %3390, %3387 ], [ %4085, %3383 ]
  %3394 = getelementptr inbounds i32, i32* %3385, i64 1
  %3395 = load i32, i32* %3385, align 4, !tbaa !70
  br label %476

; <label>:3396:                                   ; preds = %4080
  %3397 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3398 = load i8, i8* %3397, align 8, !tbaa !21
  %3399 = and i8 %3398, 15
  %3400 = icmp eq i8 %3399, 0
  br i1 %3400, label %3401, label %3404

; <label>:3401:                                   ; preds = %3396
  %3402 = trunc i32 %4082 to i16
  %3403 = icmp slt i16 %3402, 0
  br i1 %3403, label %3416, label %3418

; <label>:3404:                                   ; preds = %3396
  %3405 = icmp eq i8 %3398, 1
  br i1 %3405, label %3409, label %3406

; <label>:3406:                                   ; preds = %3404
  %3407 = trunc i32 %4082 to i16
  %3408 = icmp sgt i16 %3407, -1
  br i1 %3408, label %3416, label %3418

; <label>:3409:                                   ; preds = %3404
  %3410 = bitcast %union.StackValue* %4081 to i32*
  %3411 = load i32, i32* %3410, align 8, !tbaa !21
  %3412 = icmp ne i32 %3411, 0
  %3413 = trunc i32 %4082 to i16
  %3414 = icmp slt i16 %3413, 0
  %3415 = xor i1 %3414, %3412
  br i1 %3415, label %3416, label %3418

; <label>:3416:                                   ; preds = %3406, %3401, %3409
  %3417 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3425

; <label>:3418:                                   ; preds = %3406, %3401, %3409
  %3419 = load i32, i32* %4084, align 4, !tbaa !70
  %3420 = lshr i32 %3419, 7
  %3421 = add nsw i32 %3420, -16777214
  %3422 = sext i32 %3421 to i64
  %3423 = getelementptr inbounds i32, i32* %4084, i64 %3422
  %3424 = load i32, i32* %340, align 8, !tbaa !21
  br label %3425

; <label>:3425:                                   ; preds = %3418, %3416
  %3426 = phi i32 [ %4083, %3416 ], [ %3424, %3418 ]
  %3427 = phi i32* [ %3417, %3416 ], [ %3423, %3418 ]
  %3428 = icmp eq i32 %3426, 0
  br i1 %3428, label %3433, label %3429

; <label>:3429:                                   ; preds = %3425
  %3430 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3427)
  %3431 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3432 = getelementptr inbounds %union.StackValue, %union.StackValue* %3431, i64 1
  br label %3433

; <label>:3433:                                   ; preds = %3425, %3429
  %3434 = phi i32 [ %3430, %3429 ], [ 0, %3425 ]
  %3435 = phi %union.StackValue* [ %3432, %3429 ], [ %4085, %3425 ]
  %3436 = getelementptr inbounds i32, i32* %3427, i64 1
  %3437 = load i32, i32* %3427, align 4, !tbaa !70
  br label %476

; <label>:3438:                                   ; preds = %4080
  %3439 = lshr i32 %4082, 16
  %3440 = and i32 %3439, 255
  %3441 = zext i32 %3440 to i64
  %3442 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %3441, i32 0
  %3443 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 %3441, i32 0, i32 1
  %3444 = load i8, i8* %3443, align 8, !tbaa !22
  %3445 = and i8 %3444, 15
  %3446 = icmp eq i8 %3445, 0
  br i1 %3446, label %3447, label %3450

; <label>:3447:                                   ; preds = %3438
  %3448 = trunc i32 %4082 to i16
  %3449 = icmp sgt i16 %3448, -1
  br i1 %3449, label %3464, label %3462

; <label>:3450:                                   ; preds = %3438
  %3451 = icmp eq i8 %3444, 1
  br i1 %3451, label %3455, label %3452

; <label>:3452:                                   ; preds = %3450
  %3453 = trunc i32 %4082 to i16
  %3454 = icmp slt i16 %3453, 0
  br i1 %3454, label %3464, label %3462

; <label>:3455:                                   ; preds = %3450
  %3456 = bitcast %struct.TValue* %3442 to i32*
  %3457 = load i32, i32* %3456, align 8, !tbaa !21
  %3458 = icmp eq i32 %3457, 0
  %3459 = trunc i32 %4082 to i16
  %3460 = icmp slt i16 %3459, 0
  %3461 = xor i1 %3460, %3458
  br i1 %3461, label %3464, label %3462

; <label>:3462:                                   ; preds = %3447, %3452, %3455
  %3463 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3476

; <label>:3464:                                   ; preds = %3447, %3452, %3455
  %3465 = bitcast %struct.TValue* %3442 to i64*
  %3466 = bitcast %union.StackValue* %4081 to i64*
  %3467 = load i64, i64* %3465, align 8
  store i64 %3467, i64* %3466, align 8
  %3468 = load i8, i8* %3443, align 8, !tbaa !22
  %3469 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  store i8 %3468, i8* %3469, align 8, !tbaa !22
  %3470 = load i32, i32* %4084, align 4, !tbaa !70
  %3471 = lshr i32 %3470, 7
  %3472 = add nsw i32 %3471, -16777214
  %3473 = sext i32 %3472 to i64
  %3474 = getelementptr inbounds i32, i32* %4084, i64 %3473
  %3475 = load i32, i32* %342, align 8, !tbaa !21
  br label %3476

; <label>:3476:                                   ; preds = %3464, %3462
  %3477 = phi i32 [ %4083, %3462 ], [ %3475, %3464 ]
  %3478 = phi i32* [ %3463, %3462 ], [ %3474, %3464 ]
  %3479 = icmp eq i32 %3477, 0
  br i1 %3479, label %3484, label %3480

; <label>:3480:                                   ; preds = %3476
  %3481 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3478)
  %3482 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3483 = getelementptr inbounds %union.StackValue, %union.StackValue* %3482, i64 1
  br label %3484

; <label>:3484:                                   ; preds = %3476, %3480
  %3485 = phi i32 [ %3481, %3480 ], [ 0, %3476 ]
  %3486 = phi %union.StackValue* [ %3483, %3480 ], [ %4085, %3476 ]
  %3487 = getelementptr inbounds i32, i32* %3478, i64 1
  %3488 = load i32, i32* %3478, align 4, !tbaa !70
  br label %476

; <label>:3489:                                   ; preds = %4080
  %3490 = lshr i32 %4082, 16
  %3491 = and i32 %3490, 255
  %3492 = lshr i32 %4082, 24
  %3493 = add nsw i32 %3492, -1
  %3494 = icmp eq i32 %3491, 0
  br i1 %3494, label %3498, label %3495

; <label>:3495:                                   ; preds = %3489
  %3496 = zext i32 %3491 to i64
  %3497 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %3496
  store %union.StackValue* %3497, %union.StackValue** %345, align 8, !tbaa !20
  br label %3498

; <label>:3498:                                   ; preds = %3489, %3495
  store i32* %4084, i32** %30, align 8, !tbaa !21
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* %4081, i32 %3493)
  %3499 = load i32, i32* %344, align 8, !tbaa !21
  %3500 = icmp eq i32 %3499, 0
  br i1 %3500, label %3505, label %3501

; <label>:3501:                                   ; preds = %3498
  %3502 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %3503 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3504 = getelementptr inbounds %union.StackValue, %union.StackValue* %3503, i64 1
  br label %3505

; <label>:3505:                                   ; preds = %3498, %3501
  %3506 = phi i32 [ %3502, %3501 ], [ 0, %3498 ]
  %3507 = phi %union.StackValue* [ %3504, %3501 ], [ %4085, %3498 ]
  %3508 = getelementptr inbounds i32, i32* %4084, i64 1
  %3509 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:3510:                                   ; preds = %4080
  %3511 = lshr i32 %4082, 16
  %3512 = and i32 %3511, 255
  %3513 = icmp eq i32 %3512, 0
  br i1 %3513, label %3517, label %3514

; <label>:3514:                                   ; preds = %3510
  %3515 = zext i32 %3512 to i64
  %3516 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %3515
  store %union.StackValue* %3516, %union.StackValue** %420, align 8, !tbaa !20
  br label %3523

; <label>:3517:                                   ; preds = %3510
  %3518 = load i64, i64* %419, align 8, !tbaa !20
  %3519 = ptrtoint %union.StackValue* %4081 to i64
  %3520 = sub i64 %3518, %3519
  %3521 = lshr exact i64 %3520, 4
  %3522 = trunc i64 %3521 to i32
  br label %3523

; <label>:3523:                                   ; preds = %3517, %3514
  %3524 = phi i32 [ %3512, %3514 ], [ %3522, %3517 ]
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3525 = trunc i32 %4082 to i16
  %3526 = icmp slt i16 %3525, 0
  br i1 %3526, label %3527, label %3536

; <label>:3527:                                   ; preds = %3523
  %3528 = lshr i32 %4082, 24
  %3529 = icmp eq i32 %3528, 0
  br i1 %3529, label %3533, label %3530

; <label>:3530:                                   ; preds = %3527
  %3531 = load i32, i32* %421, align 4, !tbaa !21
  %3532 = add nsw i32 %3531, %3528
  br label %3533

; <label>:3533:                                   ; preds = %3527, %3530
  %3534 = phi i32 [ %3532, %3530 ], [ 0, %3527 ]
  %3535 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4085, i32 -1)
  br label %3536

; <label>:3536:                                   ; preds = %3533, %3523
  %3537 = phi i32 [ %3534, %3533 ], [ 0, %3523 ]
  %3538 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3539 = load i8, i8* %3538, align 8, !tbaa !21
  %3540 = and i8 %3539, 15
  %3541 = icmp eq i8 %3540, 6
  br i1 %3541, label %3545, label %3542

; <label>:3542:                                   ; preds = %3536
  call fastcc void @luaD_tryfuncTM(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4081)
  %3543 = add nsw i32 %3524, 1
  %3544 = load i8, i8* %3538, align 8, !tbaa !21
  br label %3545

; <label>:3545:                                   ; preds = %3542, %3536
  %3546 = phi i8 [ %3544, %3542 ], [ %3539, %3536 ]
  %3547 = phi i32 [ %3543, %3542 ], [ %3524, %3536 ]
  %3548 = icmp eq i8 %3546, 86
  br i1 %3548, label %3574, label %3549

; <label>:3549:                                   ; preds = %3545
  call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4081, i32 -1)
  %3550 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %3551 = bitcast i64* %3550 to i32*
  %3552 = load i32, i32* %3551, align 8, !tbaa !21
  %3553 = icmp eq i32 %3552, 0
  br i1 %3553, label %3561, label %3554

; <label>:3554:                                   ; preds = %3549
  %3555 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3556 = getelementptr inbounds %union.StackValue, %union.StackValue* %3555, i64 1
  %3557 = lshr i32 %4082, 7
  %3558 = and i32 %3557, 255
  %3559 = zext i32 %3558 to i64
  %3560 = getelementptr inbounds %union.StackValue, %union.StackValue* %3556, i64 %3559
  br label %3561

; <label>:3561:                                   ; preds = %3549, %3554
  %3562 = phi %union.StackValue* [ %3560, %3554 ], [ %4081, %3549 ]
  %3563 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3564 = sext i32 %3537 to i64
  %3565 = sub nsw i64 0, %3564
  %3566 = getelementptr inbounds %union.StackValue, %union.StackValue* %3563, i64 %3565
  store %union.StackValue* %3566, %union.StackValue** %26, align 8, !tbaa !47
  %3567 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3568 = bitcast %union.StackValue** %3567 to i64*
  %3569 = load i64, i64* %3568, align 8, !tbaa !20
  %3570 = ptrtoint %union.StackValue* %3562 to i64
  %3571 = sub i64 %3569, %3570
  %3572 = lshr exact i64 %3571, 4
  %3573 = trunc i64 %3572 to i32
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3573)
  br label %4079

; <label>:3574:                                   ; preds = %3545
  %3575 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3576 = sext i32 %3537 to i64
  %3577 = sub nsw i64 0, %3576
  %3578 = getelementptr inbounds %union.StackValue, %union.StackValue* %3575, i64 %3577
  store %union.StackValue* %3578, %union.StackValue** %26, align 8, !tbaa !47
  call fastcc void @luaD_pretailcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, %union.StackValue* nonnull %4081, i32 %3547)
  br label %422

; <label>:3579:                                   ; preds = %4080
  %3580 = bitcast %union.anon.0* %28 to %struct.anon*
  %3581 = bitcast %union.anon.0* %28 to i32**
  %3582 = lshr i32 %4082, 16
  %3583 = and i32 %3582, 255
  %3584 = add nsw i32 %3583, -1
  %3585 = icmp eq i32 %3583, 0
  br i1 %3585, label %3586, label %3594

; <label>:3586:                                   ; preds = %3579
  %3587 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3588 = bitcast %union.StackValue** %3587 to i64*
  %3589 = load i64, i64* %3588, align 8, !tbaa !20
  %3590 = ptrtoint %union.StackValue* %4081 to i64
  %3591 = sub i64 %3589, %3590
  %3592 = lshr exact i64 %3591, 4
  %3593 = trunc i64 %3592 to i32
  br label %3598

; <label>:3594:                                   ; preds = %3579
  %3595 = sext i32 %3584 to i64
  %3596 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %3595
  %3597 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %3596, %union.StackValue** %3597, align 8, !tbaa !20
  br label %3598

; <label>:3598:                                   ; preds = %3594, %3586
  %3599 = phi i32 [ %3593, %3586 ], [ %3584, %3594 ]
  store i32* %4084, i32** %3581, align 8, !tbaa !21
  %3600 = trunc i32 %4082 to i16
  %3601 = icmp slt i16 %3600, 0
  br i1 %3601, label %3602, label %3615

; <label>:3602:                                   ; preds = %3598
  %3603 = lshr i32 %4082, 24
  %3604 = icmp eq i32 %3603, 0
  br i1 %3604, label %3613, label %3605

; <label>:3605:                                   ; preds = %3602
  %3606 = getelementptr inbounds %struct.anon, %struct.anon* %3580, i64 0, i32 2
  %3607 = load i32, i32* %3606, align 4, !tbaa !21
  %3608 = add nsw i32 %3607, %3603
  %3609 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3610 = sext i32 %3608 to i64
  %3611 = sub nsw i64 0, %3610
  %3612 = getelementptr inbounds %union.StackValue, %union.StackValue* %3609, i64 %3611
  store %union.StackValue* %3612, %union.StackValue** %26, align 8, !tbaa !47
  br label %3613

; <label>:3613:                                   ; preds = %3602, %3605
  %3614 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4085, i32 0)
  br label %3615

; <label>:3615:                                   ; preds = %3613, %3598
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3599)
  br label %4079

; <label>:3616:                                   ; preds = %4080
  %3617 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %3618 = load i32, i32* %3617, align 8, !tbaa !23
  %3619 = icmp eq i32 %3618, 0
  br i1 %3619, label %3623, label %3620

; <label>:3620:                                   ; preds = %3616
  %3621 = bitcast %union.anon.0* %28 to i32**
  %3622 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %4081, %union.StackValue** %3622, align 8, !tbaa !20
  store i32* %4084, i32** %3621, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 0)
  br label %4079

; <label>:3623:                                   ; preds = %3616
  %3624 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3625 = load i16, i16* %3624, align 4, !tbaa !48
  %3626 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3627 = bitcast %struct.CallInfo** %3626 to i64*
  %3628 = load i64, i64* %3627, align 8, !tbaa !78
  %3629 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3630 = bitcast %struct.CallInfo** %3629 to i64*
  store i64 %3628, i64* %3630, align 8, !tbaa !35
  %3631 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 -1
  %3632 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %3631, %union.StackValue** %3632, align 8, !tbaa !20
  %3633 = icmp sgt i16 %3625, 0
  br i1 %3633, label %3634, label %4079

; <label>:3634:                                   ; preds = %3623
  %3635 = sext i16 %3625 to i32
  br label %3636

; <label>:3636:                                   ; preds = %3634, %3636
  %3637 = phi i32 [ %3635, %3634 ], [ %3638, %3636 ]
  %3638 = add nsw i32 %3637, -1
  %3639 = load %union.StackValue*, %union.StackValue** %3632, align 8, !tbaa !20
  %3640 = getelementptr inbounds %union.StackValue, %union.StackValue* %3639, i64 1
  store %union.StackValue* %3640, %union.StackValue** %3632, align 8, !tbaa !20
  %3641 = getelementptr inbounds %union.StackValue, %union.StackValue* %3639, i64 0, i32 0, i32 1
  store i8 0, i8* %3641, align 8, !tbaa !21
  %3642 = icmp sgt i32 %3637, 1
  br i1 %3642, label %3636, label %4079

; <label>:3643:                                   ; preds = %4080
  %3644 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %3645 = load i32, i32* %3644, align 8, !tbaa !23
  %3646 = icmp eq i32 %3645, 0
  br i1 %3646, label %3651, label %3647

; <label>:3647:                                   ; preds = %3643
  %3648 = bitcast %union.anon.0* %28 to i32**
  %3649 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1
  %3650 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %3649, %union.StackValue** %3650, align 8, !tbaa !20
  store i32* %4084, i32** %3648, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 1)
  br label %4079

; <label>:3651:                                   ; preds = %3643
  %3652 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3653 = load i16, i16* %3652, align 4, !tbaa !48
  %3654 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3655 = bitcast %struct.CallInfo** %3654 to i64*
  %3656 = load i64, i64* %3655, align 8, !tbaa !78
  %3657 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3658 = bitcast %struct.CallInfo** %3657 to i64*
  store i64 %3656, i64* %3658, align 8, !tbaa !35
  %3659 = icmp eq i16 %3653, 0
  %3660 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 -1
  br i1 %3659, label %3661, label %3663

; <label>:3661:                                   ; preds = %3651
  %3662 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %3660, %union.StackValue** %3662, align 8, !tbaa !20
  br label %4079

; <label>:3663:                                   ; preds = %3651
  %3664 = bitcast %union.StackValue* %4081 to i64*
  %3665 = bitcast %union.StackValue* %3660 to i64*
  %3666 = load i64, i64* %3664, align 8
  store i64 %3666, i64* %3665, align 8
  %3667 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3668 = load i8, i8* %3667, align 8, !tbaa !22
  %3669 = getelementptr inbounds %union.StackValue, %union.StackValue* %4085, i64 -1, i32 0, i32 1
  store i8 %3668, i8* %3669, align 8, !tbaa !22
  %3670 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %4085, %union.StackValue** %3670, align 8, !tbaa !20
  %3671 = icmp sgt i16 %3653, 1
  br i1 %3671, label %3672, label %4079

; <label>:3672:                                   ; preds = %3663
  %3673 = sext i16 %3653 to i32
  br label %3674

; <label>:3674:                                   ; preds = %3672, %3674
  %3675 = phi i32 [ %3673, %3672 ], [ %3676, %3674 ]
  %3676 = add nsw i32 %3675, -1
  %3677 = load %union.StackValue*, %union.StackValue** %3670, align 8, !tbaa !20
  %3678 = getelementptr inbounds %union.StackValue, %union.StackValue* %3677, i64 1
  store %union.StackValue* %3678, %union.StackValue** %3670, align 8, !tbaa !20
  %3679 = getelementptr inbounds %union.StackValue, %union.StackValue* %3677, i64 0, i32 0, i32 1
  store i8 0, i8* %3679, align 8, !tbaa !21
  %3680 = icmp sgt i32 %3675, 2
  br i1 %3680, label %3674, label %4079

; <label>:3681:                                   ; preds = %4080
  %3682 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 2, i32 0
  %3683 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 2, i32 0, i32 1
  %3684 = load i8, i8* %3683, align 8, !tbaa !21
  %3685 = icmp eq i8 %3684, 35
  br i1 %3685, label %3686, label %3705

; <label>:3686:                                   ; preds = %3681
  %3687 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0, i32 0
  %3688 = bitcast %union.Value* %3687 to i64*
  %3689 = load i64, i64* %3688, align 8, !tbaa !21
  %3690 = icmp eq i64 %3689, 0
  br i1 %3690, label %3727, label %3691

; <label>:3691:                                   ; preds = %3686
  %3692 = bitcast %struct.TValue* %3682 to i64*
  %3693 = load i64, i64* %3692, align 8, !tbaa !21
  %3694 = bitcast %union.StackValue* %4081 to i64*
  %3695 = load i64, i64* %3694, align 8, !tbaa !21
  %3696 = add i64 %3689, -1
  store i64 %3696, i64* %3688, align 8, !tbaa !21
  %3697 = add i64 %3695, %3693
  store i64 %3697, i64* %3694, align 8, !tbaa !21
  %3698 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0
  %3699 = bitcast %struct.TValue* %3698 to i64*
  store i64 %3697, i64* %3699, align 8, !tbaa !21
  %3700 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0, i32 1
  store i8 35, i8* %3700, align 8, !tbaa !22
  %3701 = lshr i32 %4082, 15
  %3702 = zext i32 %3701 to i64
  %3703 = sub nsw i64 0, %3702
  %3704 = getelementptr inbounds i32, i32* %4084, i64 %3703
  br label %3727

; <label>:3705:                                   ; preds = %3681
  %3706 = bitcast %struct.TValue* %3682 to double*
  %3707 = load double, double* %3706, align 8, !tbaa !21
  %3708 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0, i32 0
  %3709 = bitcast %union.Value* %3708 to double*
  %3710 = load double, double* %3709, align 8, !tbaa !21
  %3711 = bitcast %union.StackValue* %4081 to double*
  %3712 = load double, double* %3711, align 8, !tbaa !21
  %3713 = fadd double %3707, %3712
  %3714 = fcmp ogt double %3707, 0.000000e+00
  br i1 %3714, label %3715, label %3717

; <label>:3715:                                   ; preds = %3705
  %3716 = fcmp ugt double %3713, %3710
  br i1 %3716, label %3727, label %3719

; <label>:3717:                                   ; preds = %3705
  %3718 = fcmp ugt double %3710, %3713
  br i1 %3718, label %3727, label %3719

; <label>:3719:                                   ; preds = %3715, %3717
  store double %3713, double* %3711, align 8, !tbaa !21
  %3720 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0
  %3721 = bitcast %struct.TValue* %3720 to double*
  store double %3713, double* %3721, align 8, !tbaa !21
  %3722 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0, i32 1
  store i8 19, i8* %3722, align 8, !tbaa !22
  %3723 = lshr i32 %4082, 15
  %3724 = zext i32 %3723 to i64
  %3725 = sub nsw i64 0, %3724
  %3726 = getelementptr inbounds i32, i32* %4084, i64 %3725
  br label %3727

; <label>:3727:                                   ; preds = %3686, %3715, %3717, %3719, %3691
  %3728 = phi i32* [ %3704, %3691 ], [ %4084, %3686 ], [ %3726, %3719 ], [ %4084, %3715 ], [ %4084, %3717 ]
  %3729 = load i32, i32* %347, align 8, !tbaa !21
  %3730 = icmp eq i32 %3729, 0
  br i1 %3730, label %3735, label %3731

; <label>:3731:                                   ; preds = %3727
  %3732 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3728)
  %3733 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3734 = getelementptr inbounds %union.StackValue, %union.StackValue* %3733, i64 1
  br label %3735

; <label>:3735:                                   ; preds = %3727, %3731
  %3736 = phi i32 [ %3732, %3731 ], [ 0, %3727 ]
  %3737 = phi %union.StackValue* [ %3734, %3731 ], [ %4085, %3727 ]
  %3738 = getelementptr inbounds i32, i32* %3728, i64 1
  %3739 = load i32, i32* %3728, align 4, !tbaa !70
  br label %476

; <label>:3740:                                   ; preds = %4080
  %3741 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0
  %3742 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0
  %3743 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 2, i32 0
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %3744 = load i64, i64* %60, align 8, !tbaa !49
  store i64 %3744, i64* %62, align 8, !tbaa !20
  %3745 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 1
  %3746 = load i8, i8* %3745, align 8, !tbaa !22
  %3747 = icmp eq i8 %3746, 35
  br i1 %3747, label %3748, label %3786

; <label>:3748:                                   ; preds = %3740
  %3749 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 2, i32 0, i32 1
  %3750 = load i8, i8* %3749, align 8, !tbaa !22
  %3751 = icmp eq i8 %3750, 35
  br i1 %3751, label %3752, label %3786

; <label>:3752:                                   ; preds = %3748
  %3753 = bitcast %union.StackValue* %4081 to i64*
  %3754 = load i64, i64* %3753, align 8, !tbaa !21
  %3755 = bitcast %struct.TValue* %3743 to i64*
  %3756 = load i64, i64* %3755, align 8, !tbaa !21
  %3757 = icmp eq i64 %3756, 0
  br i1 %3757, label %3758, label %3759

; <label>:3758:                                   ; preds = %3752
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #17
  unreachable

; <label>:3759:                                   ; preds = %3752
  %3760 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0
  %3761 = bitcast %struct.TValue* %3760 to i64*
  store i64 %3754, i64* %3761, align 8, !tbaa !21
  %3762 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0, i32 1
  store i8 35, i8* %3762, align 8, !tbaa !22
  %3763 = call fastcc i32 @forlimit(%struct.lua_State* nonnull %0, i64 %3754, %struct.TValue* nonnull %3742, i64* nonnull %21, i64 %3756)
  %3764 = icmp eq i32 %3763, 0
  br i1 %3764, label %3770, label %3765

; <label>:3765:                                   ; preds = %3759
  %3766 = lshr i32 %4082, 15
  %3767 = add nuw nsw i32 %3766, 1
  %3768 = zext i32 %3767 to i64
  %3769 = getelementptr inbounds i32, i32* %4084, i64 %3768
  br label %3848

; <label>:3770:                                   ; preds = %3759
  %3771 = icmp sgt i64 %3756, 0
  %3772 = load i64, i64* %21, align 8, !tbaa !109
  br i1 %3771, label %3773, label %3778

; <label>:3773:                                   ; preds = %3770
  %3774 = sub i64 %3772, %3754
  %3775 = icmp eq i64 %3756, 1
  br i1 %3775, label %3782, label %3776

; <label>:3776:                                   ; preds = %3773
  %3777 = udiv i64 %3774, %3756
  br label %3782

; <label>:3778:                                   ; preds = %3770
  %3779 = sub i64 %3754, %3772
  %3780 = sub i64 0, %3756
  %3781 = udiv i64 %3779, %3780
  br label %3782

; <label>:3782:                                   ; preds = %3773, %3776, %3778
  %3783 = phi i64 [ %3777, %3776 ], [ %3774, %3773 ], [ %3781, %3778 ]
  %3784 = bitcast %struct.TValue* %3742 to i64*
  store i64 %3783, i64* %3784, align 8, !tbaa !21
  %3785 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0, i32 1
  store i8 35, i8* %3785, align 8, !tbaa !22
  br label %3848

; <label>:3786:                                   ; preds = %3748, %3740
  %3787 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1, i32 0, i32 1
  %3788 = load i8, i8* %3787, align 8, !tbaa !22
  %3789 = icmp eq i8 %3788, 19
  br i1 %3789, label %3790, label %3793

; <label>:3790:                                   ; preds = %3786
  %3791 = bitcast %struct.TValue* %3742 to i64*
  %3792 = load i64, i64* %3791, align 8, !tbaa !21
  store i64 %3792, i64* %408, align 8, !tbaa !107
  br label %3797

; <label>:3793:                                   ; preds = %3786
  %3794 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3742, double* nonnull %23)
  %3795 = icmp eq i32 %3794, 0
  br i1 %3795, label %3796, label %3797, !prof !33

; <label>:3796:                                   ; preds = %3793
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3742, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #17
  unreachable

; <label>:3797:                                   ; preds = %3790, %3793
  %3798 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 2, i32 0, i32 1
  %3799 = load i8, i8* %3798, align 8, !tbaa !22
  %3800 = icmp eq i8 %3799, 19
  br i1 %3800, label %3801, label %3804

; <label>:3801:                                   ; preds = %3797
  %3802 = bitcast %struct.TValue* %3743 to i64*
  %3803 = load i64, i64* %3802, align 8, !tbaa !21
  store i64 %3803, i64* %409, align 8, !tbaa !107
  br label %3808

; <label>:3804:                                   ; preds = %3797
  %3805 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3743, double* nonnull %24)
  %3806 = icmp eq i32 %3805, 0
  br i1 %3806, label %3807, label %3808, !prof !33

; <label>:3807:                                   ; preds = %3804
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3743, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i64 0, i64 0)) #17
  unreachable

; <label>:3808:                                   ; preds = %3801, %3804
  %3809 = load i8, i8* %3745, align 8, !tbaa !22
  %3810 = icmp eq i8 %3809, 19
  br i1 %3810, label %3811, label %3814

; <label>:3811:                                   ; preds = %3808
  %3812 = bitcast %union.StackValue* %4081 to i64*
  %3813 = load i64, i64* %3812, align 8, !tbaa !21
  store i64 %3813, i64* %410, align 8, !tbaa !107
  br label %3818

; <label>:3814:                                   ; preds = %3808
  %3815 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3741, double* nonnull %22)
  %3816 = icmp eq i32 %3815, 0
  br i1 %3816, label %3817, label %3818, !prof !33

; <label>:3817:                                   ; preds = %3814
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3741, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.167, i64 0, i64 0)) #17
  unreachable

; <label>:3818:                                   ; preds = %3811, %3814
  %3819 = load double, double* %24, align 8, !tbaa !107
  %3820 = fcmp oeq double %3819, 0.000000e+00
  br i1 %3820, label %3821, label %3822

; <label>:3821:                                   ; preds = %3818
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #17
  unreachable

; <label>:3822:                                   ; preds = %3818
  %3823 = fcmp ogt double %3819, 0.000000e+00
  br i1 %3823, label %3824, label %3828

; <label>:3824:                                   ; preds = %3822
  %3825 = load double, double* %23, align 8, !tbaa !107
  %3826 = load double, double* %22, align 8, !tbaa !107
  %3827 = fcmp olt double %3825, %3826
  br i1 %3827, label %3832, label %3837

; <label>:3828:                                   ; preds = %3822
  %3829 = load double, double* %22, align 8, !tbaa !107
  %3830 = load double, double* %23, align 8, !tbaa !107
  %3831 = fcmp olt double %3829, %3830
  br i1 %3831, label %3832, label %3837

; <label>:3832:                                   ; preds = %3828, %3824
  %3833 = lshr i32 %4082, 15
  %3834 = add nuw nsw i32 %3833, 1
  %3835 = zext i32 %3834 to i64
  %3836 = getelementptr inbounds i32, i32* %4084, i64 %3835
  br label %3848

; <label>:3837:                                   ; preds = %3828, %3824
  %3838 = load i64, i64* %411, align 8, !tbaa !107
  %3839 = bitcast %struct.TValue* %3742 to i64*
  store i64 %3838, i64* %3839, align 8, !tbaa !21
  store i8 19, i8* %3787, align 8, !tbaa !22
  %3840 = load i64, i64* %412, align 8, !tbaa !107
  %3841 = bitcast %struct.TValue* %3743 to i64*
  store i64 %3840, i64* %3841, align 8, !tbaa !21
  store i8 19, i8* %3798, align 8, !tbaa !22
  %3842 = load i64, i64* %413, align 8, !tbaa !107
  %3843 = bitcast %union.StackValue* %4081 to i64*
  store i64 %3842, i64* %3843, align 8, !tbaa !21
  store i8 19, i8* %3745, align 8, !tbaa !22
  %3844 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0
  %3845 = load i64, i64* %413, align 8, !tbaa !107
  %3846 = bitcast %struct.TValue* %3844 to i64*
  store i64 %3845, i64* %3846, align 8, !tbaa !21
  %3847 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0, i32 1
  store i8 19, i8* %3847, align 8, !tbaa !22
  br label %3848

; <label>:3848:                                   ; preds = %3832, %3837, %3765, %3782
  %3849 = phi i32* [ %3769, %3765 ], [ %4084, %3782 ], [ %3836, %3832 ], [ %4084, %3837 ]
  %3850 = icmp eq i32 %4083, 0
  br i1 %3850, label %3855, label %3851

; <label>:3851:                                   ; preds = %3848
  %3852 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %3849)
  %3853 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3854 = getelementptr inbounds %union.StackValue, %union.StackValue* %3853, i64 1
  br label %3855

; <label>:3855:                                   ; preds = %3848, %3851
  %3856 = phi i32 [ %3852, %3851 ], [ 0, %3848 ]
  %3857 = phi %union.StackValue* [ %3854, %3851 ], [ %4085, %3848 ]
  %3858 = getelementptr inbounds i32, i32* %3849, i64 1
  %3859 = load i32, i32* %3849, align 4, !tbaa !70
  br label %476

; <label>:3860:                                   ; preds = %4080
  %3861 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3, i32 0, i32 1
  %3862 = load i8, i8* %3861, align 8, !tbaa !21
  %3863 = and i8 %3862, 15
  %3864 = icmp eq i8 %3863, 0
  br i1 %3864, label %3867, label %3865

; <label>:3865:                                   ; preds = %3860
  %3866 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 3
  store i32* %4084, i32** %30, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* nonnull %3866)
  br label %3867

; <label>:3867:                                   ; preds = %3865, %3860
  %3868 = lshr i32 %4082, 15
  %3869 = zext i32 %3868 to i64
  %3870 = getelementptr inbounds i32, i32* %4084, i64 %3869
  %3871 = getelementptr inbounds i32, i32* %3870, i64 1
  %3872 = load i32, i32* %3870, align 4, !tbaa !70
  br label %3873

; <label>:3873:                                   ; preds = %4080, %3867
  %3874 = phi i32 [ %4082, %4080 ], [ %3872, %3867 ]
  %3875 = phi i32* [ %4084, %4080 ], [ %3871, %3867 ]
  %3876 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 4
  %3877 = bitcast %union.StackValue* %3876 to i8*
  %3878 = bitcast %union.StackValue* %4081 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %3877, i8* %3878, i64 48, i32 8, i1 false)
  store i32* %3875, i32** %30, align 8, !tbaa !21
  %3879 = load i64, i64* %65, align 8, !tbaa !49
  store i64 %3879, i64* %66, align 8, !tbaa !20
  %3880 = lshr i32 %3874, 24
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* nonnull %3876, i32 %3880)
  %3881 = load i32, i32* %68, align 8, !tbaa !21
  %3882 = icmp eq i32 %3881, 0
  br i1 %3882, label %3890, label %3883

; <label>:3883:                                   ; preds = %3873
  %3884 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3885 = getelementptr inbounds %union.StackValue, %union.StackValue* %3884, i64 1
  %3886 = lshr i32 %3874, 7
  %3887 = and i32 %3886, 255
  %3888 = zext i32 %3887 to i64
  %3889 = getelementptr inbounds %union.StackValue, %union.StackValue* %3885, i64 %3888
  br label %3890

; <label>:3890:                                   ; preds = %3873, %3883
  %3891 = phi %union.StackValue* [ %3889, %3883 ], [ %4081, %3873 ]
  %3892 = phi %union.StackValue* [ %3885, %3883 ], [ %4085, %3873 ]
  %3893 = getelementptr inbounds i32, i32* %3875, i64 1
  %3894 = load i32, i32* %3875, align 4, !tbaa !70
  %3895 = getelementptr inbounds %union.StackValue, %union.StackValue* %3891, i64 2
  br label %3896

; <label>:3896:                                   ; preds = %4080, %3890
  %3897 = phi %union.StackValue* [ %4081, %4080 ], [ %3895, %3890 ]
  %3898 = phi i32 [ %4082, %4080 ], [ %3894, %3890 ]
  %3899 = phi i32 [ %4083, %4080 ], [ %3881, %3890 ]
  %3900 = phi i32* [ %4084, %4080 ], [ %3893, %3890 ]
  %3901 = phi %union.StackValue* [ %4085, %4080 ], [ %3892, %3890 ]
  %3902 = getelementptr inbounds %union.StackValue, %union.StackValue* %3897, i64 2, i32 0, i32 1
  %3903 = load i8, i8* %3902, align 8, !tbaa !21
  %3904 = and i8 %3903, 15
  %3905 = icmp eq i8 %3904, 0
  br i1 %3905, label %3916, label %3906

; <label>:3906:                                   ; preds = %3896
  %3907 = getelementptr inbounds %union.StackValue, %union.StackValue* %3897, i64 2, i32 0, i32 0
  %3908 = bitcast %union.Value* %3907 to i64*
  %3909 = bitcast %union.StackValue* %3897 to i64*
  %3910 = load i64, i64* %3908, align 8
  store i64 %3910, i64* %3909, align 8
  %3911 = getelementptr inbounds %union.StackValue, %union.StackValue* %3897, i64 0, i32 0, i32 1
  store i8 %3903, i8* %3911, align 8, !tbaa !22
  %3912 = lshr i32 %3898, 15
  %3913 = zext i32 %3912 to i64
  %3914 = sub nsw i64 0, %3913
  %3915 = getelementptr inbounds i32, i32* %3900, i64 %3914
  br label %3916

; <label>:3916:                                   ; preds = %3906, %3896
  %3917 = phi i32* [ %3900, %3896 ], [ %3915, %3906 ]
  %3918 = icmp eq i32 %3899, 0
  br i1 %3918, label %3923, label %3919

; <label>:3919:                                   ; preds = %3916
  %3920 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3917)
  %3921 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %3922 = getelementptr inbounds %union.StackValue, %union.StackValue* %3921, i64 1
  br label %3923

; <label>:3923:                                   ; preds = %3916, %3919
  %3924 = phi i32 [ %3920, %3919 ], [ 0, %3916 ]
  %3925 = phi %union.StackValue* [ %3922, %3919 ], [ %3901, %3916 ]
  %3926 = getelementptr inbounds i32, i32* %3917, i64 1
  %3927 = load i32, i32* %3917, align 4, !tbaa !70
  br label %476

; <label>:3928:                                   ; preds = %4080
  %3929 = lshr i32 %4082, 16
  %3930 = and i32 %3929, 255
  %3931 = lshr i32 %4082, 24
  %3932 = icmp eq i32 %3930, 0
  br i1 %3932, label %3933, label %3940

; <label>:3933:                                   ; preds = %3928
  %3934 = load i64, i64* %349, align 8, !tbaa !20
  %3935 = ptrtoint %union.StackValue* %4081 to i64
  %3936 = sub i64 %3934, %3935
  %3937 = lshr exact i64 %3936, 4
  %3938 = trunc i64 %3937 to i32
  %3939 = add nsw i32 %3938, -1
  br label %3942

; <label>:3940:                                   ; preds = %3928
  %3941 = load i64, i64* %351, align 8, !tbaa !49
  store i64 %3941, i64* %353, align 8, !tbaa !20
  br label %3942

; <label>:3942:                                   ; preds = %3940, %3933
  %3943 = phi i32 [ %3939, %3933 ], [ %3930, %3940 ]
  %3944 = icmp eq i32 %3931, 0
  br i1 %3944, label %3945, label %3949

; <label>:3945:                                   ; preds = %3942
  %3946 = load i32, i32* %4084, align 4, !tbaa !70
  %3947 = lshr i32 %3946, 7
  %3948 = getelementptr inbounds i32, i32* %4084, i64 1
  br label %3949

; <label>:3949:                                   ; preds = %3945, %3942
  %3950 = phi i32 [ %3947, %3945 ], [ %3931, %3942 ]
  %3951 = phi i32* [ %3948, %3945 ], [ %4084, %3942 ]
  %3952 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 0, i32 0, i32 0, i32 0
  %3953 = load %struct.GCObject*, %struct.GCObject** %3952, align 8, !tbaa !21
  %3954 = bitcast %struct.GCObject* %3953 to %struct.Table*
  %3955 = mul nuw nsw i32 %3950, 50
  %3956 = add i32 %3943, -50
  %3957 = add i32 %3956, %3955
  %3958 = call fastcc i32 @luaH_realasize(%struct.Table* %3954)
  %3959 = icmp ugt i32 %3957, %3958
  br i1 %3959, label %3960, label %3961

; <label>:3960:                                   ; preds = %3949
  call fastcc void @luaH_resizearray(%struct.lua_State* nonnull %0, %struct.Table* %3954, i32 %3957)
  br label %3961

; <label>:3961:                                   ; preds = %3960, %3949
  %3962 = icmp sgt i32 %3943, 0
  br i1 %3962, label %3963, label %4000

; <label>:3963:                                   ; preds = %3961
  %3964 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3953, i64 1
  %3965 = bitcast %struct.GCObject* %3964 to %struct.TValue**
  %3966 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3953, i64 0, i32 2
  %3967 = sext i32 %3943 to i64
  br label %3968

; <label>:3968:                                   ; preds = %3963, %3997
  %3969 = phi i64 [ %3967, %3963 ], [ %3998, %3997 ]
  %3970 = phi i32 [ %3957, %3963 ], [ %3973, %3997 ]
  %3971 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %3969, i32 0
  %3972 = load %struct.TValue*, %struct.TValue** %3965, align 8, !tbaa !115
  %3973 = add i32 %3970, -1
  %3974 = zext i32 %3973 to i64
  %3975 = getelementptr inbounds %struct.TValue, %struct.TValue* %3972, i64 %3974
  %3976 = bitcast %struct.TValue* %3971 to i64*
  %3977 = bitcast %struct.TValue* %3975 to i64*
  %3978 = load i64, i64* %3976, align 8
  store i64 %3978, i64* %3977, align 8
  %3979 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 %3969, i32 0, i32 1
  %3980 = load i8, i8* %3979, align 8, !tbaa !22
  %3981 = getelementptr inbounds %struct.TValue, %struct.TValue* %3972, i64 %3974, i32 1
  store i8 %3980, i8* %3981, align 8, !tbaa !22
  %3982 = load i8, i8* %3979, align 8, !tbaa !22
  %3983 = and i8 %3982, 64
  %3984 = icmp eq i8 %3983, 0
  br i1 %3984, label %3997, label %3985

; <label>:3985:                                   ; preds = %3968
  %3986 = load i8, i8* %3966, align 1, !tbaa !21
  %3987 = and i8 %3986, 32
  %3988 = icmp eq i8 %3987, 0
  br i1 %3988, label %3997, label %3989

; <label>:3989:                                   ; preds = %3985
  %3990 = getelementptr inbounds %struct.TValue, %struct.TValue* %3971, i64 0, i32 0, i32 0
  %3991 = load %struct.GCObject*, %struct.GCObject** %3990, align 8, !tbaa !21
  %3992 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3991, i64 0, i32 2
  %3993 = load i8, i8* %3992, align 1, !tbaa !53
  %3994 = and i8 %3993, 24
  %3995 = icmp eq i8 %3994, 0
  br i1 %3995, label %3997, label %3996

; <label>:3996:                                   ; preds = %3989
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %3953)
  br label %3997

; <label>:3997:                                   ; preds = %3989, %3985, %3968, %3996
  %3998 = add nsw i64 %3969, -1
  %3999 = icmp sgt i64 %3969, 1
  br i1 %3999, label %3968, label %4000

; <label>:4000:                                   ; preds = %3997, %3961
  %4001 = icmp eq i32 %4083, 0
  br i1 %4001, label %4006, label %4002

; <label>:4002:                                   ; preds = %4000
  %4003 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3951)
  %4004 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %4005 = getelementptr inbounds %union.StackValue, %union.StackValue* %4004, i64 1
  br label %4006

; <label>:4006:                                   ; preds = %4000, %4002
  %4007 = phi i32 [ %4003, %4002 ], [ 0, %4000 ]
  %4008 = phi %union.StackValue* [ %4005, %4002 ], [ %4085, %4000 ]
  %4009 = getelementptr inbounds i32, i32* %3951, i64 1
  %4010 = load i32, i32* %3951, align 4, !tbaa !70
  br label %476

; <label>:4011:                                   ; preds = %4080
  %4012 = load %struct.Proto*, %struct.Proto** %426, align 8, !tbaa !173
  %4013 = getelementptr inbounds %struct.Proto, %struct.Proto* %4012, i64 0, i32 17
  %4014 = load %struct.Proto**, %struct.Proto*** %4013, align 8, !tbaa !207
  %4015 = lshr i32 %4082, 15
  %4016 = zext i32 %4015 to i64
  %4017 = getelementptr inbounds %struct.Proto*, %struct.Proto** %4014, i64 %4016
  %4018 = load %struct.Proto*, %struct.Proto** %4017, align 8, !tbaa !79
  store i32* %4084, i32** %30, align 8, !tbaa !21
  call fastcc void @pushclosure(%struct.lua_State* %0, %struct.Proto* %4018, %struct.UpVal** nonnull %454, %union.StackValue* %4085, %union.StackValue* %4081)
  %4019 = load %struct.global_State*, %struct.global_State** %69, align 8, !tbaa !2
  %4020 = getelementptr inbounds %struct.global_State, %struct.global_State* %4019, i64 0, i32 3
  %4021 = load i64, i64* %4020, align 8, !tbaa !11
  %4022 = icmp sgt i64 %4021, 0
  br i1 %4022, label %4023, label %4026

; <label>:4023:                                   ; preds = %4011
  %4024 = getelementptr inbounds %union.StackValue, %union.StackValue* %4081, i64 1
  store %union.StackValue* %4024, %union.StackValue** %354, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  %4025 = load i32, i32* %356, align 8, !tbaa !21
  br label %4026

; <label>:4026:                                   ; preds = %4023, %4011
  %4027 = phi i32 [ %4025, %4023 ], [ %4083, %4011 ]
  %4028 = icmp eq i32 %4027, 0
  br i1 %4028, label %4033, label %4029

; <label>:4029:                                   ; preds = %4026
  %4030 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %4031 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %4032 = getelementptr inbounds %union.StackValue, %union.StackValue* %4031, i64 1
  br label %4033

; <label>:4033:                                   ; preds = %4026, %4029
  %4034 = phi i32 [ %4030, %4029 ], [ 0, %4026 ]
  %4035 = phi %union.StackValue* [ %4032, %4029 ], [ %4085, %4026 ]
  %4036 = getelementptr inbounds i32, i32* %4084, i64 1
  %4037 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:4038:                                   ; preds = %4080
  %4039 = lshr i32 %4082, 24
  %4040 = add nsw i32 %4039, -1
  store i32* %4084, i32** %30, align 8, !tbaa !21
  %4041 = load i64, i64* %71, align 8, !tbaa !49
  store i64 %4041, i64* %73, align 8, !tbaa !20
  call fastcc void @luaT_getvarargs(%struct.lua_State* %0, %struct.CallInfo* %1, %union.StackValue* %4081, i32 %4040)
  %4042 = load i32, i32* %75, align 8, !tbaa !21
  %4043 = icmp eq i32 %4042, 0
  br i1 %4043, label %4048, label %4044

; <label>:4044:                                   ; preds = %4038
  %4045 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4084)
  %4046 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %4047 = getelementptr inbounds %union.StackValue, %union.StackValue* %4046, i64 1
  br label %4048

; <label>:4048:                                   ; preds = %4038, %4044
  %4049 = phi i32 [ %4045, %4044 ], [ 0, %4038 ]
  %4050 = phi %union.StackValue* [ %4047, %4044 ], [ %4085, %4038 ]
  %4051 = getelementptr inbounds i32, i32* %4084, i64 1
  %4052 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:4053:                                   ; preds = %4080
  %4054 = lshr i32 %4082, 7
  %4055 = and i32 %4054, 255
  %4056 = load %struct.Proto*, %struct.Proto** %426, align 8, !tbaa !173
  call fastcc void @luaT_adjustvarargs(%struct.lua_State* %0, i32 %4055, %struct.CallInfo* %1, %struct.Proto* %4056)
  %4057 = load i32, i32* %77, align 8, !tbaa !21
  %4058 = icmp eq i32 %4057, 0
  br i1 %4058, label %4062, label %4059

; <label>:4059:                                   ; preds = %4053
  call fastcc void @luaD_hookcall(%struct.lua_State* %0, %struct.CallInfo* nonnull %1)
  %4060 = getelementptr inbounds i32, i32* %4084, i64 1
  store i32* %4060, i32** %357, align 8, !tbaa !77
  %4061 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  br label %4062

; <label>:4062:                                   ; preds = %4053, %4059
  %4063 = phi i32 [ %4061, %4059 ], [ 0, %4053 ]
  %4064 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %4065 = getelementptr inbounds %union.StackValue, %union.StackValue* %4064, i64 1
  %4066 = getelementptr inbounds i32, i32* %4084, i64 1
  %4067 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:4068:                                   ; preds = %4080
  %4069 = icmp eq i32 %4083, 0
  br i1 %4069, label %4074, label %4070

; <label>:4070:                                   ; preds = %4068
  %4071 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4084)
  %4072 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !47
  %4073 = getelementptr inbounds %union.StackValue, %union.StackValue* %4072, i64 1
  br label %4074

; <label>:4074:                                   ; preds = %4068, %4070
  %4075 = phi i32 [ %4071, %4070 ], [ 0, %4068 ]
  %4076 = phi %union.StackValue* [ %4073, %4070 ], [ %4085, %4068 ]
  %4077 = getelementptr inbounds i32, i32* %4084, i64 1
  %4078 = load i32, i32* %4084, align 4, !tbaa !70
  br label %476

; <label>:4079:                                   ; preds = %3674, %3636, %3663, %3623, %3647, %3661, %3620, %3615, %3561
  ret void

; <label>:4080:                                   ; preds = %476, %444
  %4081 = phi %union.StackValue* [ %453, %444 ], [ %484, %476 ]
  %4082 = phi i32 [ %449, %444 ], [ %477, %476 ]
  %4083 = phi i32 [ %445, %444 ], [ %479, %476 ]
  %4084 = phi i32* [ %448, %444 ], [ %480, %476 ]
  %4085 = phi %union.StackValue* [ %447, %444 ], [ %478, %476 ]
  %4086 = and i32 %4082, 127
  %4087 = zext i32 %4086 to i64
  %4088 = getelementptr inbounds [84 x i8*], [84 x i8*]* @luaV_execute.disptab, i64 0, i64 %4087
  %4089 = load i8*, i8** %4088, align 8, !tbaa !79
  indirectbr i8* %4089, [label %455, label %505, label %521, label %485, label %537, label %559, label %577, label %598, label %622, label %664, label %710, label %783, label %838, label %881, label %953, label %1049, label %1127, label %1193, label %1226, label %1279, label %1320, label %1359, label %1400, label %1439, label %1477, label %1515, label %1555, label %1615, label %1673, label %1733, label %1791, label %1839, label %1887, label %2333, label %2373, label %2413, label %2597, label %2643, label %1946, label %2004, label %2062, label %2120, label %2178, label %2226, label %2274, label %2453, label %2501, label %2549, label %2730, label %2681, label %2778, label %2812, label %2846, label %2876, label %2893, label %2915, label %2929, label %2940, label %2956, label %2986, label %3048, label %3110, label %3142, label %3188, label %3240, label %3292, label %3344, label %3396, label %3438, label %3489, label %3510, label %3579, label %3616, label %3643, label %3681, label %3740, label %3860, label %3873, label %3896, label %3928, label %4011, label %4038, label %4053, label %4068]
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_poscall(%struct.lua_State*, %struct.CallInfo* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %5 = load i32, i32* %4, align 8, !tbaa !23
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = sext i32 %2 to i64
  %11 = sub nsw i64 0, %10
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %11
  %13 = tail call fastcc %union.StackValue* @rethook(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, %union.StackValue* %12, i32 %2)
  store %union.StackValue* %13, %union.StackValue** %8, align 8, !tbaa !20
  br label %14

; <label>:14:                                     ; preds = %3, %7
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %16 = bitcast %struct.CallInfo** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !78
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = bitcast %struct.CallInfo** %18 to i64*
  store i64 %17, i64* %19, align 8, !tbaa !35
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !47
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %23 = load i16, i16* %22, align 4, !tbaa !48
  %24 = sext i16 %23 to i32
  tail call fastcc void @moveresults(%struct.lua_State* nonnull %0, %union.StackValue* %21, i32 %2, i32 %24)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_hookcall(%struct.lua_State*, %struct.CallInfo* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %4 = load i32, i32* %3, align 8, !tbaa !23
  %5 = and i32 %4, 1
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %32, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !46
  %10 = lshr i16 %9, 2
  %11 = and i16 %10, 4
  %12 = zext i16 %11 to i32
  %13 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %14 = load %struct.LClosure**, %struct.LClosure*** %13, align 8, !tbaa !47
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %19 = bitcast %union.StackValue** %18 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !49
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to i64*
  store i64 %20, i64* %22, align 8, !tbaa !20
  %23 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %24 = bitcast %union.anon.0* %23 to i32**
  %25 = load i32*, i32** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds i32, i32* %25, i64 1
  store i32* %26, i32** %24, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 3
  %28 = load i8, i8* %27, align 2, !tbaa !95
  %29 = zext i8 %28 to i32
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 %12, i32 -1, i32 1, i32 %29)
  %30 = load i32*, i32** %24, align 8, !tbaa !21
  %31 = getelementptr inbounds i32, i32* %30, i64 -1
  store i32* %31, i32** %24, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %2, %7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaG_traceexec(%struct.lua_State*, i32*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !35
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %6 = load i32, i32* %5, align 8, !tbaa !23
  %7 = and i32 %6, 12
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %11 = bitcast i64* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !21
  br label %102

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds i32, i32* %1, i64 1
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4
  %15 = bitcast %union.anon.0* %14 to i32**
  store i32* %13, i32** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  %17 = load i32, i32* %16, align 4, !tbaa !26
  %18 = add nsw i32 %17, -1
  store i32 %18, i32* %16, align 4, !tbaa !26
  %19 = icmp eq i32 %18, 0
  %20 = and i32 %6, 8
  %21 = icmp ne i32 %20, 0
  %22 = and i1 %21, %19
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %12
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %25 = load i32, i32* %24, align 8, !tbaa !24
  store i32 %25, i32* %16, align 4, !tbaa !26
  br label %29

; <label>:26:                                     ; preds = %12
  %27 = and i32 %6, 4
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %102, label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %31 = load i16, i16* %30, align 2, !tbaa !46
  %32 = and i16 %31, 32
  %33 = icmp eq i16 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %29
  %35 = and i16 %31, -33
  store i16 %35, i16* %30, align 2, !tbaa !46
  br label %102

; <label>:36:                                     ; preds = %29
  %37 = load i32*, i32** %15, align 8, !tbaa !21
  %38 = getelementptr inbounds i32, i32* %37, i64 -1
  %39 = load i32, i32* %38, align 4, !tbaa !70
  %40 = and i32 %39, 127
  %41 = zext i32 %40 to i64
  %42 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %41
  %43 = load i8, i8* %42, align 1, !tbaa !21
  %44 = and i8 %43, 32
  %45 = icmp ne i8 %44, 0
  %46 = and i32 %39, 16711680
  %47 = icmp eq i32 %46, 0
  %48 = and i1 %47, %45
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %36
  %50 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %51 = bitcast %union.StackValue** %50 to i64*
  %52 = load i64, i64* %51, align 8, !tbaa !49
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %54 = bitcast %union.StackValue** %53 to i64*
  store i64 %52, i64* %54, align 8, !tbaa !20
  br label %55

; <label>:55:                                     ; preds = %36, %49
  br i1 %22, label %56, label %57

; <label>:56:                                     ; preds = %55
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 3, i32 -1, i32 0, i32 0)
  br label %57

; <label>:57:                                     ; preds = %56, %55
  %58 = and i32 %6, 4
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %91, label %60

; <label>:60:                                     ; preds = %57
  %61 = bitcast %struct.CallInfo* %4 to %struct.LClosure***
  %62 = load %struct.LClosure**, %struct.LClosure*** %61, align 8, !tbaa !47
  %63 = load %struct.LClosure*, %struct.LClosure** %62, align 8, !tbaa !21
  %64 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %63, i64 0, i32 5
  %65 = load %struct.Proto*, %struct.Proto** %64, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.Proto, %struct.Proto* %65, i64 0, i32 16
  %67 = bitcast i32** %66 to i64*
  %68 = load i64, i64* %67, align 8, !tbaa !134
  %69 = ptrtoint i32* %13 to i64
  %70 = sub i64 %69, %68
  %71 = lshr exact i64 %70, 2
  %72 = trunc i64 %71 to i32
  %73 = add nsw i32 %72, -1
  %74 = icmp eq i32 %73, 0
  br i1 %74, label %87, label %75

; <label>:75:                                     ; preds = %60
  %76 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %77 = load i32*, i32** %76, align 8, !tbaa !77
  %78 = icmp ugt i32* %13, %77
  br i1 %78, label %79, label %87

; <label>:79:                                     ; preds = %75
  %80 = ptrtoint i32* %77 to i64
  %81 = sub i64 %80, %68
  %82 = lshr exact i64 %81, 2
  %83 = trunc i64 %82 to i32
  %84 = add nsw i32 %83, -1
  %85 = tail call fastcc i32 @changedline(%struct.Proto* %65, i32 %84, i32 %73)
  %86 = icmp eq i32 %85, 0
  br i1 %86, label %89, label %87

; <label>:87:                                     ; preds = %79, %75, %60
  %88 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %65, i32 %73)
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 2, i32 %88, i32 0, i32 0)
  br label %89

; <label>:89:                                     ; preds = %79, %87
  %90 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  store i32* %13, i32** %90, align 8, !tbaa !77
  br label %91

; <label>:91:                                     ; preds = %57, %89
  %92 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %93 = load i8, i8* %92, align 2, !tbaa !43
  %94 = icmp eq i8 %93, 1
  br i1 %94, label %95, label %102

; <label>:95:                                     ; preds = %91
  br i1 %22, label %96, label %97

; <label>:96:                                     ; preds = %95
  store i32 1, i32* %16, align 4, !tbaa !26
  br label %97

; <label>:97:                                     ; preds = %96, %95
  %98 = load i32*, i32** %15, align 8, !tbaa !21
  %99 = getelementptr inbounds i32, i32* %98, i64 -1
  store i32* %99, i32** %15, align 8, !tbaa !21
  %100 = load i16, i16* %30, align 2, !tbaa !46
  %101 = or i16 %100, 32
  store i16 %101, i16* %30, align 2, !tbaa !46
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #17
  unreachable

; <label>:102:                                    ; preds = %91, %26, %34, %9
  %103 = phi i32 [ 1, %34 ], [ 0, %9 ], [ 1, %26 ], [ 1, %91 ]
  ret i32 %103
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @luaO_fb2int(i32) unnamed_addr #6 {
  %2 = icmp slt i32 %0, 8
  br i1 %2, label %9, label %3

; <label>:3:                                      ; preds = %1
  %4 = and i32 %0, 7
  %5 = or i32 %4, 8
  %6 = lshr i32 %0, 3
  %7 = add nsw i32 %6, -1
  %8 = shl i32 %5, %7
  br label %9

; <label>:9:                                      ; preds = %1, %3
  %10 = phi i32 [ %8, %3 ], [ %0, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TValue* @luaH_getstr(%struct.Table* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !57
  %6 = icmp eq i8 %5, 20
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %2
  %8 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* nonnull %1)
  br label %15

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %1, %struct.TString** %11, align 8, !tbaa !21
  %12 = or i8 %5, 64
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %12, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  br label %15

; <label>:15:                                     ; preds = %9, %7
  %16 = phi %struct.TValue* [ %8, %7 ], [ %14, %9 ]
  ret %struct.TValue* %16
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_trybiniTM(%struct.lua_State*, %struct.TValue*, i64, i32, %union.StackValue*, i32) unnamed_addr #0 {
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast %struct.TValue* %7 to i64*
  store i64 %2, i64* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 35, i8* %10, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* nonnull %7, %union.StackValue* %4, i32 %3, i32 %5)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @luaV_mod(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %9, !prof !33

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %17

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.168, i64 0, i64 0)) #17
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = srem i64 %1, %2
  %11 = icmp ne i64 %10, 0
  %12 = xor i64 %10, %2
  %13 = icmp slt i64 %12, 0
  %14 = and i1 %11, %13
  %15 = select i1 %14, i64 %2, i64 0
  %16 = add nsw i64 %15, %10
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i64 [ 0, %6 ], [ %16, %9 ]
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc double @luaV_modf(double, double) unnamed_addr #0 {
  %3 = tail call double @fmod(double %0, double %1) #7
  %4 = fcmp ogt double %3, 0.000000e+00
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = fcmp olt double %1, 0.000000e+00
  br i1 %6, label %11, label %13

; <label>:7:                                      ; preds = %2
  %8 = fcmp olt double %3, 0.000000e+00
  %9 = fcmp ogt double %1, 0.000000e+00
  %10 = and i1 %9, %8
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %7, %5
  %12 = fadd double %3, %1
  br label %13

; <label>:13:                                     ; preds = %11, %7, %5
  %14 = phi double [ %12, %11 ], [ %3, %5 ], [ %3, %7 ]
  ret double %14
}

; Function Attrs: nounwind
declare double @pow(double, double) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i64 @luaV_idiv(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %11, !prof !33

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.169, i64 0, i64 0)) #17
  unreachable

; <label>:9:                                      ; preds = %6
  %10 = sub i64 0, %1
  br label %20

; <label>:11:                                     ; preds = %3
  %12 = sdiv i64 %1, %2
  %13 = srem i64 %1, %2
  %14 = xor i64 %2, %1
  %15 = icmp slt i64 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %11
  %17 = icmp ne i64 %13, 0
  %18 = sext i1 %17 to i64
  %19 = add nsw i64 %12, %18
  ret i64 %19

; <label>:20:                                     ; preds = %11, %9
  %21 = phi i64 [ %10, %9 ], [ %12, %11 ]
  ret i64 %21
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.floor.f64(double) #13

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_trybinassocTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32, i32) unnamed_addr #0 {
  %7 = icmp eq i32 %4, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2, %struct.TValue* %1, %union.StackValue* %3, i32 %5)
  br label %10

; <label>:9:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %5)
  br label %10

; <label>:10:                                     ; preds = %9, %8
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_trybinTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %4)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %23

; <label>:8:                                      ; preds = %5
  switch i32 %4, label %22 [
    i32 22, label %9
    i32 13, label %10
    i32 14, label %10
    i32 15, label %10
    i32 16, label %10
    i32 17, label %10
    i32 19, label %10
  ]

; <label>:9:                                      ; preds = %8
  tail call fastcc void @luaG_concaterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2) #17
  unreachable

; <label>:10:                                     ; preds = %8, %8, %8, %8, %8, %8
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = and i8 %12, 15
  %14 = icmp eq i8 %13, 3
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %10
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 3
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %15
  tail call fastcc void @luaG_tointerror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2) #17
  unreachable

; <label>:21:                                     ; preds = %15, %10
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.170, i64 0, i64 0)) #17
  unreachable

; <label>:22:                                     ; preds = %8
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.171, i64 0, i64 0)) #17
  unreachable

; <label>:23:                                     ; preds = %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_tointegerns(%struct.TValue* nocapture readonly, i64* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %13 [
    i8 19, label %6
    i8 35, label %10
  ]

; <label>:6:                                      ; preds = %3
  %7 = bitcast %struct.TValue* %0 to double*
  %8 = load double, double* %7, align 8, !tbaa !21
  %9 = tail call fastcc i32 @luaV_flttointeger(double %8, i64* %1, i32 %2)
  br label %13

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %0 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %1, align 8, !tbaa !109
  br label %13

; <label>:13:                                     ; preds = %3, %10, %6
  %14 = phi i32 [ %9, %6 ], [ 1, %10 ], [ 0, %3 ]
  ret i32 %14
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i64 @luaV_shiftl(i64, i64) unnamed_addr #6 {
  %3 = icmp slt i64 %1, 0
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %2
  %5 = icmp slt i64 %1, -63
  %6 = sub nsw i64 0, %1
  %7 = lshr i64 %0, %6
  %8 = select i1 %5, i64 0, i64 %7
  ret i64 %8

; <label>:9:                                      ; preds = %2
  %10 = icmp sgt i64 %1, 63
  %11 = shl i64 %0, %1
  %12 = select i1 %10, i64 0, i64 %11
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LTnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %17

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp slt i64 %8, %14
  %16 = zext i1 %15 to i32
  br label %36

; <label>:17:                                     ; preds = %6
  %18 = bitcast %struct.TValue* %1 to double*
  %19 = load double, double* %18, align 8, !tbaa !21
  %20 = tail call fastcc i32 @LTintfloat(i64 %8, double %19)
  br label %36

; <label>:21:                                     ; preds = %2
  %22 = bitcast %struct.TValue* %0 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = icmp eq i8 %25, 19
  br i1 %26, label %27, label %32

; <label>:27:                                     ; preds = %21
  %28 = bitcast %struct.TValue* %1 to double*
  %29 = load double, double* %28, align 8, !tbaa !21
  %30 = fcmp olt double %23, %29
  %31 = zext i1 %30 to i32
  br label %36

; <label>:32:                                     ; preds = %21
  %33 = bitcast %struct.TValue* %1 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !21
  %35 = tail call fastcc i32 @LTfloatint(double %23, i64 %34)
  br label %36

; <label>:36:                                     ; preds = %27, %32, %12, %17
  %37 = phi i32 [ %16, %12 ], [ %20, %17 ], [ %31, %27 ], [ %35, %32 ]
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @lessthanothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %20

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17)
  %19 = lshr i32 %18, 31
  br label %22

; <label>:20:                                     ; preds = %8, %3
  %21 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 20)
  br label %22

; <label>:22:                                     ; preds = %20, %13
  %23 = phi i32 [ %19, %13 ], [ %21, %20 ]
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LEnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %17

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp sle i64 %8, %14
  %16 = zext i1 %15 to i32
  br label %36

; <label>:17:                                     ; preds = %6
  %18 = bitcast %struct.TValue* %1 to double*
  %19 = load double, double* %18, align 8, !tbaa !21
  %20 = tail call fastcc i32 @LEintfloat(i64 %8, double %19)
  br label %36

; <label>:21:                                     ; preds = %2
  %22 = bitcast %struct.TValue* %0 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = icmp eq i8 %25, 19
  br i1 %26, label %27, label %32

; <label>:27:                                     ; preds = %21
  %28 = bitcast %struct.TValue* %1 to double*
  %29 = load double, double* %28, align 8, !tbaa !21
  %30 = fcmp ole double %23, %29
  %31 = zext i1 %30 to i32
  br label %36

; <label>:32:                                     ; preds = %21
  %33 = bitcast %struct.TValue* %1 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !21
  %35 = tail call fastcc i32 @LEfloatint(double %23, i64 %34)
  br label %36

; <label>:36:                                     ; preds = %27, %32, %12, %17
  %37 = phi i32 [ %16, %12 ], [ %20, %17 ], [ %31, %27 ], [ %35, %32 ]
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @lessequalothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %21

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17)
  %19 = icmp slt i32 %18, 1
  %20 = zext i1 %19 to i32
  br label %23

; <label>:21:                                     ; preds = %8, %3
  %22 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 21)
  br label %23

; <label>:23:                                     ; preds = %21, %13
  %24 = phi i32 [ %20, %13 ], [ %22, %21 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaT_callorderiTM(%struct.lua_State*, %struct.TValue*, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = icmp eq i32 %4, 0
  br i1 %9, label %13, label %10

; <label>:10:                                     ; preds = %6
  %11 = sitofp i32 %2 to double
  %12 = bitcast %struct.TValue* %7 to double*
  store double %11, double* %12, align 8, !tbaa !21
  br label %16

; <label>:13:                                     ; preds = %6
  %14 = sext i32 %2 to i64
  %15 = bitcast %struct.TValue* %7 to i64*
  store i64 %14, i64* %15, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %13, %10
  %17 = phi i8 [ 35, %13 ], [ 19, %10 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = icmp eq i32 %3, 0
  %20 = select i1 %19, %struct.TValue* %7, %struct.TValue* %1
  %21 = select i1 %19, %struct.TValue* %1, %struct.TValue* %7
  %22 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* %21, %struct.TValue* %20, i32 %5)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_tryfuncTM(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %4 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %3, i32 23)
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 6
  br i1 %8, label %10, label %9, !prof !103

; <label>:9:                                      ; preds = %2
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i64 0, i64 0)) #17
  unreachable

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = icmp ugt %union.StackValue* %12, %1
  br i1 %13, label %14, label %26

; <label>:14:                                     ; preds = %10
  br label %15

; <label>:15:                                     ; preds = %14, %15
  %16 = phi %union.StackValue* [ %24, %15 ], [ %12, %14 ]
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1, i32 0
  %18 = bitcast %struct.TValue* %17 to i64*
  %19 = bitcast %union.StackValue* %16 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1, i32 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 0, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1
  %25 = icmp ugt %union.StackValue* %24, %1
  br i1 %25, label %15, label %26

; <label>:26:                                     ; preds = %15, %10
  %27 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %11, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %4 to i64*
  %30 = bitcast %union.StackValue* %1 to i64*
  %31 = load i64, i64* %29, align 8
  store i64 %31, i64* %30, align 8
  %32 = load i8, i8* %5, align 8, !tbaa !22
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 %32, i8* %33, align 8, !tbaa !22
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_pretailcall(%struct.lua_State*, %struct.CallInfo* nocapture, %union.StackValue* nocapture readonly, i32) unnamed_addr #0 {
  %5 = bitcast %union.StackValue* %2 to %struct.LClosure**
  %6 = load %struct.LClosure*, %struct.LClosure** %5, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %6, i64 0, i32 5
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 5
  %10 = load i8, i8* %9, align 4, !tbaa !133
  %11 = zext i8 %10 to i32
  %12 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 3
  %13 = load i8, i8* %12, align 2, !tbaa !95
  %14 = zext i8 %13 to i32
  %15 = icmp sgt i32 %3, 0
  br i1 %15, label %16, label %32

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %18 = zext i32 %3 to i64
  br label %19

; <label>:19:                                     ; preds = %19, %16
  %20 = phi i64 [ 0, %16 ], [ %30, %19 ]
  %21 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !47
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 %20, i32 0
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %20, i32 0
  %24 = bitcast %struct.TValue* %23 to i64*
  %25 = bitcast %struct.TValue* %22 to i64*
  %26 = load i64, i64* %24, align 8
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 %20, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 %20, i32 0, i32 1
  store i8 %28, i8* %29, align 8, !tbaa !22
  %30 = add nuw nsw i64 %20, 1
  %31 = icmp eq i64 %30, %18
  br i1 %31, label %32, label %19

; <label>:32:                                     ; preds = %19, %4
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %34 = bitcast %union.StackValue** %33 to i64*
  %35 = load i64, i64* %34, align 8, !tbaa !45
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %37 = bitcast %union.StackValue** %36 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !20
  %39 = sub i64 %35, %38
  %40 = ashr exact i64 %39, 4
  %41 = zext i8 %10 to i64
  %42 = icmp sgt i64 %40, %41
  br i1 %42, label %51, label %43

; <label>:43:                                     ; preds = %32
  %44 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %11, i32 1)
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %46 = load %struct.global_State*, %struct.global_State** %45, align 8, !tbaa !2
  %47 = getelementptr inbounds %struct.global_State, %struct.global_State* %46, i64 0, i32 3
  %48 = load i64, i64* %47, align 8, !tbaa !11
  %49 = icmp sgt i64 %48, 0
  br i1 %49, label %50, label %51

; <label>:50:                                     ; preds = %43
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %51

; <label>:51:                                     ; preds = %32, %43, %50
  %52 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %53 = load %union.StackValue*, %union.StackValue** %52, align 8, !tbaa !47
  %54 = icmp slt i32 %14, %3
  br i1 %54, label %65, label %55

; <label>:55:                                     ; preds = %51
  %56 = sext i32 %3 to i64
  %57 = zext i8 %13 to i64
  br label %58

; <label>:58:                                     ; preds = %58, %55
  %59 = phi i64 [ %61, %58 ], [ %56, %55 ]
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 %59, i32 0, i32 1
  store i8 0, i8* %60, align 8, !tbaa !21
  %61 = add nsw i64 %59, 1
  %62 = icmp slt i64 %59, %57
  br i1 %62, label %58, label %63

; <label>:63:                                     ; preds = %58
  %64 = trunc i64 %61 to i32
  br label %65

; <label>:65:                                     ; preds = %63, %51
  %66 = phi i32 [ %3, %51 ], [ %64, %63 ]
  %67 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 1
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %67, i64 %41
  %69 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  store %union.StackValue* %68, %union.StackValue** %69, align 8, !tbaa !49
  %70 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 16
  %71 = bitcast i32** %70 to i64*
  %72 = load i64, i64* %71, align 8, !tbaa !134
  %73 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %74 = bitcast %union.anon.0* %73 to i64*
  store i64 %72, i64* %74, align 8, !tbaa !21
  %75 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %76 = load i16, i16* %75, align 2, !tbaa !46
  %77 = or i16 %76, 16
  store i16 %77, i16* %75, align 2, !tbaa !46
  %78 = sext i32 %66 to i64
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 %78
  store %union.StackValue* %79, %union.StackValue** %36, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @forlimit(%struct.lua_State*, i64, %struct.TValue*, i64* nocapture, i64) unnamed_addr #0 {
  %6 = alloca double, align 8
  %7 = icmp slt i64 %4, 0
  %8 = lshr i64 %4, 63
  %9 = trunc i64 %8 to i32
  %10 = add nuw nsw i32 %9, 1
  %11 = tail call fastcc i32 @luaV_tointeger(%struct.TValue* %2, i64* %3, i32 %10)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %38

; <label>:13:                                     ; preds = %5
  %14 = bitcast double* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %14) #7
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = icmp eq i8 %16, 19
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %13
  %19 = bitcast %struct.TValue* %2 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !21
  %21 = bitcast double* %6 to i64*
  store i64 %20, i64* %21, align 8, !tbaa !107
  %22 = bitcast i64 %20 to double
  br label %29

; <label>:23:                                     ; preds = %13
  %24 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %2, double* nonnull %6)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %23
  tail call fastcc void @luaG_forerror(%struct.lua_State* %0, %struct.TValue* nonnull %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #17
  unreachable

; <label>:27:                                     ; preds = %23
  %28 = load double, double* %6, align 8, !tbaa !107
  br label %29

; <label>:29:                                     ; preds = %27, %18
  %30 = phi double [ %28, %27 ], [ %22, %18 ]
  %31 = fcmp ogt double %30, 0.000000e+00
  br i1 %31, label %32, label %33

; <label>:32:                                     ; preds = %29
  br i1 %7, label %37, label %35

; <label>:33:                                     ; preds = %29
  %34 = icmp sgt i64 %4, 0
  br i1 %34, label %37, label %35

; <label>:35:                                     ; preds = %33, %32
  %36 = phi i64 [ 9223372036854775807, %32 ], [ -9223372036854775808, %33 ]
  store i64 %36, i64* %3, align 8, !tbaa !109
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %14) #7
  br label %38

; <label>:37:                                     ; preds = %33, %32
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %14) #7
  br label %45

; <label>:38:                                     ; preds = %35, %5
  %39 = icmp sgt i64 %4, 0
  %40 = load i64, i64* %3, align 8, !tbaa !109
  %41 = icmp slt i64 %40, %1
  %42 = icmp sgt i64 %40, %1
  %43 = select i1 %39, i1 %41, i1 %42
  %44 = zext i1 %43 to i32
  br label %45

; <label>:45:                                     ; preds = %37, %38
  %46 = phi i32 [ %44, %38 ], [ 1, %37 ]
  ret i32 %46
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_forerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1)
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.179, i64 0, i64 0), i8* %2, i8* %4) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaH_resizearray(%struct.lua_State*, %struct.Table*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %5 = load %union.Node*, %union.Node** %4, align 8, !tbaa !117
  %6 = icmp eq %union.Node* %5, null
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %9 = load i8, i8* %8, align 1, !tbaa !124
  %10 = zext i8 %9 to i32
  %11 = shl i32 1, %10
  br label %12

; <label>:12:                                     ; preds = %3, %7
  %13 = phi i32 [ %11, %7 ], [ 0, %3 ]
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* nonnull %1, i32 %2, i32 %13)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushclosure(%struct.lua_State*, %struct.Proto*, %struct.UpVal** nocapture readonly, %union.StackValue*, %union.StackValue* nocapture) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  %7 = load i32, i32* %6, align 8, !tbaa !166
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %9 = load %struct.Upvaldesc*, %struct.Upvaldesc** %8, align 8, !tbaa !174
  %10 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %7)
  %11 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %10, i64 0, i32 5
  store %struct.Proto* %1, %struct.Proto** %11, align 8, !tbaa !173
  %12 = bitcast %struct.LClosure* %10 to %struct.GCObject*
  %13 = bitcast %union.StackValue* %4 to %struct.LClosure**
  store %struct.LClosure* %10, %struct.LClosure** %13, align 8, !tbaa !21
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 0, i32 0, i32 1
  store i8 86, i8* %14, align 8, !tbaa !22
  %15 = icmp sgt i32 %7, 0
  br i1 %15, label %16, label %53

; <label>:16:                                     ; preds = %5
  %17 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %10, i64 0, i32 2
  %18 = zext i32 %7 to i64
  br label %19

; <label>:19:                                     ; preds = %50, %16
  %20 = phi i64 [ 0, %16 ], [ %51, %50 ]
  %21 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %9, i64 %20, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !236
  %23 = icmp eq i8 %22, 0
  %24 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %9, i64 %20, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !237
  %26 = zext i8 %25 to i64
  br i1 %23, label %31, label %27

; <label>:27:                                     ; preds = %19
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 %26
  %29 = tail call fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State* %0, %union.StackValue* %28)
  %30 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %10, i64 0, i32 6, i64 %20
  store %struct.UpVal* %29, %struct.UpVal** %30, align 8, !tbaa !79
  br label %37

; <label>:31:                                     ; preds = %19
  %32 = getelementptr inbounds %struct.UpVal*, %struct.UpVal** %2, i64 %26
  %33 = bitcast %struct.UpVal** %32 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !79
  %35 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %10, i64 0, i32 6, i64 %20
  %36 = bitcast %struct.UpVal** %35 to i64*
  store i64 %34, i64* %36, align 8, !tbaa !79
  br label %37

; <label>:37:                                     ; preds = %31, %27
  %38 = load i8, i8* %17, align 1, !tbaa !177
  %39 = and i8 %38, 32
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %50, label %41

; <label>:41:                                     ; preds = %37
  %42 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %10, i64 0, i32 6, i64 %20
  %43 = load %struct.UpVal*, %struct.UpVal** %42, align 8, !tbaa !79
  %44 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %43, i64 0, i32 2
  %45 = load i8, i8* %44, align 1, !tbaa !52
  %46 = and i8 %45, 24
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %50, label %48

; <label>:48:                                     ; preds = %41
  %49 = bitcast %struct.UpVal* %43 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* nonnull %12, %struct.GCObject* %49)
  br label %50

; <label>:50:                                     ; preds = %41, %37, %48
  %51 = add nuw nsw i64 %20, 1
  %52 = icmp eq i64 %51, %18
  br i1 %52, label %53, label %19

; <label>:53:                                     ; preds = %50, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_getvarargs(%struct.lua_State*, %struct.CallInfo* nocapture readonly, %union.StackValue*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %6 = bitcast %union.anon.0* %5 to %struct.anon*
  %7 = getelementptr inbounds %struct.anon, %struct.anon* %6, i64 0, i32 2
  %8 = load i32, i32* %7, align 4, !tbaa !21
  %9 = icmp slt i32 %3, 0
  br i1 %9, label %10, label %42

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %12 = bitcast %union.StackValue** %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !45
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !20
  %17 = sub i64 %13, %16
  %18 = ashr exact i64 %17, 4
  %19 = sext i32 %8 to i64
  %20 = icmp sgt i64 %18, %19
  br i1 %20, label %39, label %21

; <label>:21:                                     ; preds = %10
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %23 = bitcast %union.StackValue** %22 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !34
  %25 = ptrtoint %union.StackValue* %2 to i64
  %26 = sub i64 %25, %24
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %28 = load %struct.global_State*, %struct.global_State** %27, align 8, !tbaa !2
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %28, i64 0, i32 3
  %30 = load i64, i64* %29, align 8, !tbaa !11
  %31 = icmp sgt i64 %30, 0
  br i1 %31, label %32, label %33

; <label>:32:                                     ; preds = %21
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %33

; <label>:33:                                     ; preds = %32, %21
  %34 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %8, i32 1)
  %35 = bitcast %union.StackValue** %22 to i8**
  %36 = load i8*, i8** %35, align 8, !tbaa !34
  %37 = getelementptr inbounds i8, i8* %36, i64 %26
  %38 = bitcast i8* %37 to %union.StackValue*
  br label %39

; <label>:39:                                     ; preds = %10, %33
  %40 = phi %union.StackValue* [ %38, %33 ], [ %2, %10 ]
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 %19
  store %union.StackValue* %41, %union.StackValue** %14, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %39, %4
  %43 = phi i32 [ %8, %39 ], [ %3, %4 ]
  %44 = phi %union.StackValue* [ %40, %39 ], [ %2, %4 ]
  %45 = icmp sgt i32 %43, 0
  %46 = icmp sgt i32 %8, 0
  %47 = and i1 %45, %46
  br i1 %47, label %48, label %72

; <label>:48:                                     ; preds = %42
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %50 = sext i32 %8 to i64
  %51 = sub nsw i64 0, %50
  %52 = sext i32 %8 to i64
  %53 = sext i32 %43 to i64
  br label %54

; <label>:54:                                     ; preds = %48, %54
  %55 = phi i64 [ 0, %48 ], [ %66, %54 ]
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 %55, i32 0
  %57 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !47
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 %51
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 %55
  %60 = bitcast %union.StackValue* %59 to i64*
  %61 = bitcast %struct.TValue* %56 to i64*
  %62 = load i64, i64* %60, align 8
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 0, i32 0, i32 1
  %64 = load i8, i8* %63, align 8, !tbaa !22
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 %55, i32 0, i32 1
  store i8 %64, i8* %65, align 8, !tbaa !22
  %66 = add nuw nsw i64 %55, 1
  %67 = icmp slt i64 %66, %53
  %68 = icmp slt i64 %66, %52
  %69 = and i1 %67, %68
  br i1 %69, label %54, label %70

; <label>:70:                                     ; preds = %54
  %71 = trunc i64 %66 to i32
  br label %72

; <label>:72:                                     ; preds = %70, %42
  %73 = phi i32 [ 0, %42 ], [ %71, %70 ]
  %74 = icmp slt i32 %73, %43
  br i1 %74, label %75, label %83

; <label>:75:                                     ; preds = %72
  %76 = zext i32 %73 to i64
  br label %77

; <label>:77:                                     ; preds = %77, %75
  %78 = phi i64 [ %76, %75 ], [ %80, %77 ]
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 %78, i32 0, i32 1
  store i8 0, i8* %79, align 8, !tbaa !21
  %80 = add nuw nsw i64 %78, 1
  %81 = trunc i64 %80 to i32
  %82 = icmp eq i32 %43, %81
  br i1 %82, label %83, label %77

; <label>:83:                                     ; preds = %77, %72
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_adjustvarargs(%struct.lua_State*, i32, %struct.CallInfo* nocapture, %struct.Proto* nocapture readonly) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %2, i64 0, i32 0
  %9 = bitcast %struct.CallInfo* %2 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !47
  %11 = sub i64 %7, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = xor i32 %1, -1
  %15 = add i32 %14, %13
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %2, i64 0, i32 4
  %17 = bitcast %union.anon.0* %16 to %struct.anon*
  %18 = getelementptr inbounds %struct.anon, %struct.anon* %17, i64 0, i32 2
  store i32 %15, i32* %18, align 4, !tbaa !21
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %20 = bitcast %union.StackValue** %19 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !45
  %22 = load i64, i64* %6, align 8, !tbaa !20
  %23 = sub i64 %21, %22
  %24 = ashr exact i64 %23, 4
  %25 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 5
  %26 = load i8, i8* %25, align 4, !tbaa !133
  %27 = zext i8 %26 to i32
  %28 = add nuw nsw i32 %27, 1
  %29 = zext i32 %28 to i64
  %30 = icmp sgt i64 %24, %29
  br i1 %30, label %39, label %31

; <label>:31:                                     ; preds = %4
  %32 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %28, i32 1)
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %34 = load %struct.global_State*, %struct.global_State** %33, align 8, !tbaa !2
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %34, i64 0, i32 3
  %36 = load i64, i64* %35, align 8, !tbaa !11
  %37 = icmp sgt i64 %36, 0
  br i1 %37, label %38, label %39

; <label>:38:                                     ; preds = %31
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0)
  br label %39

; <label>:39:                                     ; preds = %4, %31, %38
  %40 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %5, align 8, !tbaa !20
  %42 = bitcast %struct.CallInfo* %2 to %struct.TValue**
  %43 = load %struct.TValue*, %struct.TValue** %42, align 8, !tbaa !47
  %44 = bitcast %struct.TValue* %43 to i64*
  %45 = bitcast %union.StackValue* %40 to i64*
  %46 = load i64, i64* %44, align 8
  store i64 %46, i64* %45, align 8
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !22
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 0, i32 0, i32 1
  store i8 %48, i8* %49, align 8, !tbaa !22
  %50 = icmp slt i32 %1, 1
  br i1 %50, label %70, label %51

; <label>:51:                                     ; preds = %39
  %52 = add i32 %1, 1
  %53 = zext i32 %52 to i64
  br label %54

; <label>:54:                                     ; preds = %54, %51
  %55 = phi i64 [ %68, %54 ], [ 1, %51 ]
  %56 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 1
  store %union.StackValue* %57, %union.StackValue** %5, align 8, !tbaa !20
  %58 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !47
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 %55, i32 0
  %60 = bitcast %struct.TValue* %59 to i64*
  %61 = bitcast %union.StackValue* %56 to i64*
  %62 = load i64, i64* %60, align 8
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 %55, i32 0, i32 1
  %64 = load i8, i8* %63, align 8, !tbaa !22
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 0, i32 0, i32 1
  store i8 %64, i8* %65, align 8, !tbaa !22
  %66 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !47
  %67 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 %55, i32 0, i32 1
  store i8 0, i8* %67, align 8, !tbaa !21
  %68 = add nuw nsw i64 %55, 1
  %69 = icmp eq i64 %68, %53
  br i1 %69, label %70, label %54

; <label>:70:                                     ; preds = %54, %39
  %71 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !47
  %72 = shl i64 %11, 28
  %73 = ashr exact i64 %72, 32
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %71, i64 %73
  store %union.StackValue* %74, %union.StackValue** %8, align 8, !tbaa !47
  %75 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %2, i64 0, i32 1
  %76 = load %union.StackValue*, %union.StackValue** %75, align 8, !tbaa !49
  %77 = getelementptr inbounds %union.StackValue, %union.StackValue* %76, i64 %73
  store %union.StackValue* %77, %union.StackValue** %75, align 8, !tbaa !49
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_hook(%struct.lua_State*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.lua_Debug, align 8
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %8 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %7, align 8, !tbaa !25
  %9 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %8, null
  br i1 %9, label %69, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !41
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %69, label %14

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !35
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !34
  %23 = sub i64 %19, %22
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 1
  %25 = bitcast %union.StackValue** %24 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !49
  %27 = sub i64 %26, %22
  %28 = bitcast %struct.lua_Debug* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %28) #7
  %29 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 0
  store i32 %1, i32* %29, align 8, !tbaa !238
  %30 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 6
  store i32 %2, i32* %30, align 8, !tbaa !90
  %31 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 16
  store %struct.CallInfo* %16, %struct.CallInfo** %31, align 8, !tbaa !80
  %32 = icmp eq i32 %4, 0
  br i1 %32, label %40, label %33

; <label>:33:                                     ; preds = %14
  %34 = trunc i32 %3 to i16
  %35 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 5
  %36 = bitcast %union.anon.2* %35 to %struct.anon.3*
  %37 = bitcast %union.anon.2* %35 to i16*
  store i16 %34, i16* %37, align 8, !tbaa !21
  %38 = trunc i32 %4 to i16
  %39 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %36, i64 0, i32 1
  store i16 %38, i16* %39, align 2, !tbaa !21
  br label %40

; <label>:40:                                     ; preds = %14, %33
  %41 = phi i16 [ 132, %33 ], [ 4, %14 ]
  %42 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %43 = bitcast %union.StackValue** %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !45
  %45 = load i64, i64* %18, align 8, !tbaa !20
  %46 = sub i64 %44, %45
  %47 = icmp slt i64 %46, 336
  br i1 %47, label %48, label %50

; <label>:48:                                     ; preds = %40
  %49 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1)
  br label %50

; <label>:50:                                     ; preds = %40, %48
  %51 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 20
  %53 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !49
  %54 = icmp ugt %union.StackValue* %52, %53
  br i1 %54, label %55, label %56

; <label>:55:                                     ; preds = %50
  store %union.StackValue* %52, %union.StackValue** %24, align 8, !tbaa !49
  br label %56

; <label>:56:                                     ; preds = %55, %50
  store i8 0, i8* %11, align 1, !tbaa !41
  %57 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 7
  %58 = load i16, i16* %57, align 2, !tbaa !46
  %59 = or i16 %58, %41
  store i16 %59, i16* %57, align 2, !tbaa !46
  call void %8(%struct.lua_State* nonnull %0, %struct.lua_Debug* nonnull %6) #7
  store i8 1, i8* %11, align 1, !tbaa !41
  %60 = bitcast %union.StackValue** %20 to i8**
  %61 = load i8*, i8** %60, align 8, !tbaa !34
  %62 = getelementptr inbounds i8, i8* %61, i64 %27
  %63 = bitcast %union.StackValue** %24 to i8**
  store i8* %62, i8** %63, align 8, !tbaa !49
  %64 = getelementptr inbounds i8, i8* %61, i64 %23
  %65 = bitcast %union.StackValue** %17 to i8**
  store i8* %64, i8** %65, align 8, !tbaa !20
  %66 = load i16, i16* %57, align 2, !tbaa !46
  %67 = xor i16 %41, -1
  %68 = and i16 %66, %67
  store i16 %68, i16* %57, align 2, !tbaa !46
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %28) #7
  br label %69

; <label>:69:                                     ; preds = %10, %5, %56
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @changedline(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #0 {
  %4 = icmp slt i32 %1, %2
  br i1 %4, label %5, label %25

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %7 = load i8*, i8** %6, align 8, !tbaa !211
  %8 = sext i32 %1 to i64
  %9 = sext i32 %2 to i64
  br label %13

; <label>:10:                                     ; preds = %13
  %11 = add nsw i32 %15, 1
  %12 = icmp slt i64 %16, %9
  br i1 %12, label %13, label %25

; <label>:13:                                     ; preds = %5, %10
  %14 = phi i64 [ %8, %5 ], [ %16, %10 ]
  %15 = phi i32 [ %1, %5 ], [ %11, %10 ]
  %16 = add nsw i64 %14, 1
  %17 = getelementptr inbounds i8, i8* %7, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %10, label %20

; <label>:20:                                     ; preds = %13
  %21 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %0, i32 %15)
  %22 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %0, i32 %2)
  %23 = icmp ne i32 %21, %22
  %24 = zext i1 %23 to i32
  br label %25

; <label>:25:                                     ; preds = %10, %3, %20
  %26 = phi i32 [ %24, %20 ], [ 0, %3 ], [ 0, %10 ]
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TValue* @getgeneric(%struct.Table* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = tail call fastcc %union.Node* @mainpositionTV(%struct.Table* %0, %struct.TValue* %1)
  %4 = tail call fastcc i32 @equalkey(%struct.TValue* %1, %union.Node* %3)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  br label %10

; <label>:7:                                      ; preds = %15, %2
  %8 = phi %union.Node* [ %3, %2 ], [ %17, %15 ]
  %9 = bitcast %union.Node* %8 to %struct.TValue*
  br label %20

; <label>:10:                                     ; preds = %6, %15
  %11 = phi %union.Node* [ %17, %15 ], [ %3, %6 ]
  %12 = getelementptr inbounds %union.Node, %union.Node* %11, i64 0, i32 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !21
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %20, label %15

; <label>:15:                                     ; preds = %10
  %16 = sext i32 %13 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %11, i64 %16
  %18 = tail call fastcc i32 @equalkey(%struct.TValue* %1, %union.Node* %17)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %10, label %7

; <label>:20:                                     ; preds = %10, %7
  %21 = phi %struct.TValue* [ %9, %7 ], [ @absentkey, %10 ]
  ret %struct.TValue* %21
}

; Function Attrs: nounwind uwtable
define internal fastcc %union.Node* @mainpositionTV(%struct.Table* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = zext i8 %4 to i32
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0
  %7 = tail call fastcc %union.Node* @mainposition(%struct.Table* %0, i32 %5, %union.Value* %6)
  ret %union.Node* %7
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @equalkey(%struct.TValue* nocapture readonly, %union.Node* nocapture readonly) unnamed_addr #14 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 2
  %6 = load i8, i8* %5, align 1, !tbaa !21
  %7 = icmp eq i8 %4, %6
  br i1 %7, label %8, label %64

; <label>:8:                                      ; preds = %2
  %9 = trunc i8 %4 to i6
  switch i6 %9, label %57 [
    i6 0, label %64
    i6 -29, label %10
    i6 19, label %18
    i6 1, label %26
    i6 2, label %34
    i6 -26, label %42
    i6 -28, label %50
  ]

; <label>:10:                                     ; preds = %8
  %11 = bitcast %struct.TValue* %0 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4
  %14 = bitcast %union.Value* %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !21
  %16 = icmp eq i64 %12, %15
  %17 = zext i1 %16 to i32
  br label %64

; <label>:18:                                     ; preds = %8
  %19 = bitcast %struct.TValue* %0 to double*
  %20 = load double, double* %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4
  %22 = bitcast %union.Value* %21 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = fcmp oeq double %20, %23
  %25 = zext i1 %24 to i32
  br label %64

; <label>:26:                                     ; preds = %8
  %27 = bitcast %struct.TValue* %0 to i32*
  %28 = load i32, i32* %27, align 8, !tbaa !21
  %29 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4
  %30 = bitcast %union.Value* %29 to i32*
  %31 = load i32, i32* %30, align 8, !tbaa !21
  %32 = icmp eq i32 %28, %31
  %33 = zext i1 %32 to i32
  br label %64

; <label>:34:                                     ; preds = %8
  %35 = bitcast %struct.TValue* %0 to i8**
  %36 = load i8*, i8** %35, align 8, !tbaa !21
  %37 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4
  %38 = bitcast %union.Value* %37 to i8**
  %39 = load i8*, i8** %38, align 8, !tbaa !21
  %40 = icmp eq i8* %36, %39
  %41 = zext i1 %40 to i32
  br label %64

; <label>:42:                                     ; preds = %8
  %43 = bitcast %struct.TValue* %0 to i32 (%struct.lua_State*)**
  %44 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %43, align 8, !tbaa !21
  %45 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4
  %46 = bitcast %union.Value* %45 to i32 (%struct.lua_State*)**
  %47 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %46, align 8, !tbaa !21
  %48 = icmp eq i32 (%struct.lua_State*)* %44, %47
  %49 = zext i1 %48 to i32
  br label %64

; <label>:50:                                     ; preds = %8
  %51 = bitcast %struct.TValue* %0 to %struct.TString**
  %52 = load %struct.TString*, %struct.TString** %51, align 8, !tbaa !21
  %53 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4, i32 0
  %54 = bitcast %struct.GCObject** %53 to %struct.TString**
  %55 = load %struct.TString*, %struct.TString** %54, align 8, !tbaa !21
  %56 = tail call fastcc i32 @luaS_eqlngstr(%struct.TString* %52, %struct.TString* %55)
  br label %64

; <label>:57:                                     ; preds = %8
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 0, i32 0
  %59 = load %struct.GCObject*, %struct.GCObject** %58, align 8, !tbaa !21
  %60 = getelementptr inbounds %union.Node, %union.Node* %1, i64 0, i32 0, i32 4, i32 0
  %61 = load %struct.GCObject*, %struct.GCObject** %60, align 8, !tbaa !21
  %62 = icmp eq %struct.GCObject* %59, %61
  %63 = zext i1 %62 to i32
  br label %64

; <label>:64:                                     ; preds = %8, %2, %57, %50, %42, %34, %26, %18, %10
  %65 = phi i32 [ %63, %57 ], [ %56, %50 ], [ %49, %42 ], [ %41, %34 ], [ %33, %26 ], [ %25, %18 ], [ %17, %10 ], [ 0, %2 ], [ 1, %8 ]
  ret i32 %65
}

; Function Attrs: nounwind uwtable
define internal fastcc %union.Node* @mainposition(%struct.Table* nocapture readonly, i32, %union.Value* nocapture readonly) unnamed_addr #0 {
  %4 = trunc i32 %1 to i6
  switch i6 %4, label %106 [
    i6 -29, label %5
    i6 19, label %19
    i6 20, label %34
    i6 -28, label %49
    i6 1, label %63
    i6 2, label %76
    i6 -26, label %91
  ]

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %7 = load %union.Node*, %union.Node** %6, align 8, !tbaa !123
  %8 = bitcast %union.Value* %2 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !124
  %12 = zext i8 %11 to i32
  %13 = shl i32 1, %12
  %14 = add nsw i32 %13, -1
  %15 = trunc i64 %9 to i32
  %16 = and i32 %14, %15
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds %union.Node, %union.Node* %7, i64 %17
  br label %121

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %21 = load %union.Node*, %union.Node** %20, align 8, !tbaa !123
  %22 = bitcast %union.Value* %2 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = tail call fastcc i32 @l_hashfloat(double %23)
  %25 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %26 = load i8, i8* %25, align 1, !tbaa !124
  %27 = zext i8 %26 to i32
  %28 = shl i32 1, %27
  %29 = add nsw i32 %28, -1
  %30 = or i32 %29, 1
  %31 = srem i32 %24, %30
  %32 = sext i32 %31 to i64
  %33 = getelementptr inbounds %union.Node, %union.Node* %21, i64 %32
  br label %121

; <label>:34:                                     ; preds = %3
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %36 = load %union.Node*, %union.Node** %35, align 8, !tbaa !123
  %37 = bitcast %union.Value* %2 to %struct.TString**
  %38 = load %struct.TString*, %struct.TString** %37, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TString, %struct.TString* %38, i64 0, i32 5
  %40 = load i32, i32* %39, align 4, !tbaa !21
  %41 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %42 = load i8, i8* %41, align 1, !tbaa !124
  %43 = zext i8 %42 to i32
  %44 = shl i32 1, %43
  %45 = add nsw i32 %44, -1
  %46 = and i32 %45, %40
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds %union.Node, %union.Node* %36, i64 %47
  br label %121

; <label>:49:                                     ; preds = %3
  %50 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %51 = load %union.Node*, %union.Node** %50, align 8, !tbaa !123
  %52 = bitcast %union.Value* %2 to %struct.TString**
  %53 = load %struct.TString*, %struct.TString** %52, align 8, !tbaa !21
  %54 = tail call fastcc i32 @luaS_hashlongstr(%struct.TString* %53)
  %55 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %56 = load i8, i8* %55, align 1, !tbaa !124
  %57 = zext i8 %56 to i32
  %58 = shl i32 1, %57
  %59 = add nsw i32 %58, -1
  %60 = and i32 %59, %54
  %61 = sext i32 %60 to i64
  %62 = getelementptr inbounds %union.Node, %union.Node* %51, i64 %61
  br label %121

; <label>:63:                                     ; preds = %3
  %64 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %65 = load %union.Node*, %union.Node** %64, align 8, !tbaa !123
  %66 = bitcast %union.Value* %2 to i32*
  %67 = load i32, i32* %66, align 8, !tbaa !21
  %68 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %69 = load i8, i8* %68, align 1, !tbaa !124
  %70 = zext i8 %69 to i32
  %71 = shl i32 1, %70
  %72 = add nsw i32 %71, -1
  %73 = and i32 %72, %67
  %74 = sext i32 %73 to i64
  %75 = getelementptr inbounds %union.Node, %union.Node* %65, i64 %74
  br label %121

; <label>:76:                                     ; preds = %3
  %77 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %78 = load %union.Node*, %union.Node** %77, align 8, !tbaa !123
  %79 = bitcast %union.Value* %2 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !21
  %81 = trunc i64 %80 to i32
  %82 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %83 = load i8, i8* %82, align 1, !tbaa !124
  %84 = zext i8 %83 to i32
  %85 = shl i32 1, %84
  %86 = add nsw i32 %85, -1
  %87 = or i32 %86, 1
  %88 = urem i32 %81, %87
  %89 = zext i32 %88 to i64
  %90 = getelementptr inbounds %union.Node, %union.Node* %78, i64 %89
  br label %121

; <label>:91:                                     ; preds = %3
  %92 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %93 = load %union.Node*, %union.Node** %92, align 8, !tbaa !123
  %94 = bitcast %union.Value* %2 to i64*
  %95 = load i64, i64* %94, align 8, !tbaa !21
  %96 = trunc i64 %95 to i32
  %97 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %98 = load i8, i8* %97, align 1, !tbaa !124
  %99 = zext i8 %98 to i32
  %100 = shl i32 1, %99
  %101 = add nsw i32 %100, -1
  %102 = or i32 %101, 1
  %103 = urem i32 %96, %102
  %104 = zext i32 %103 to i64
  %105 = getelementptr inbounds %union.Node, %union.Node* %93, i64 %104
  br label %121

; <label>:106:                                    ; preds = %3
  %107 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %108 = load %union.Node*, %union.Node** %107, align 8, !tbaa !123
  %109 = bitcast %union.Value* %2 to i64*
  %110 = load i64, i64* %109, align 8, !tbaa !21
  %111 = trunc i64 %110 to i32
  %112 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %113 = load i8, i8* %112, align 1, !tbaa !124
  %114 = zext i8 %113 to i32
  %115 = shl i32 1, %114
  %116 = add nsw i32 %115, -1
  %117 = or i32 %116, 1
  %118 = urem i32 %111, %117
  %119 = zext i32 %118 to i64
  %120 = getelementptr inbounds %union.Node, %union.Node* %108, i64 %119
  br label %121

; <label>:121:                                    ; preds = %106, %91, %76, %63, %49, %34, %19, %5
  %122 = phi %union.Node* [ %120, %106 ], [ %105, %91 ], [ %90, %76 ], [ %75, %63 ], [ %62, %49 ], [ %48, %34 ], [ %33, %19 ], [ %18, %5 ]
  ret %union.Node* %122
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @l_hashfloat(double) unnamed_addr #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call double @frexp(double %0, i32* nonnull %2) #7
  %5 = fmul double %4, 0x41E0000000000000
  %6 = fcmp oge double %5, 0xC3E0000000000000
  %7 = fcmp olt double %5, 0x43E0000000000000
  %8 = and i1 %6, %7
  br i1 %8, label %9, label %16

; <label>:9:                                      ; preds = %1
  %10 = fptosi double %5 to i64
  %11 = load i32, i32* %2, align 4, !tbaa !70
  %12 = trunc i64 %10 to i32
  %13 = add i32 %11, %12
  %14 = ashr i32 %13, 31
  %15 = xor i32 %14, %13
  br label %16

; <label>:16:                                     ; preds = %1, %9
  %17 = phi i32 [ %15, %9 ], [ 0, %1 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 %17
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @luaS_hashlongstr(%struct.TString* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 3
  %3 = load i8, i8* %2, align 2, !tbaa !199
  %4 = icmp eq i8 %3, 0
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %7 = bitcast %struct.TString* %6 to i8*
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %9 = load i64, i64* %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 5
  %11 = load i32, i32* %10, align 4, !tbaa !200
  %12 = tail call fastcc i32 @luaS_hash(i8* nonnull %7, i64 %9, i32 %11)
  store i32 %12, i32* %10, align 4, !tbaa !200
  store i8 1, i8* %2, align 2, !tbaa !199
  br label %13

; <label>:13:                                     ; preds = %5, %1
  %14 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !200
  ret i32 %15
}

; Function Attrs: nounwind
declare double @frexp(double, i32* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @luaS_eqlngstr(%struct.TString* readonly, %struct.TString* readonly) unnamed_addr #14 {
  %3 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %4 = load i64, i64* %3, align 8, !tbaa !21
  %5 = icmp eq %struct.TString* %0, %1
  br i1 %5, label %18, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 6, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = icmp eq i64 %4, %8
  br i1 %9, label %10, label %18

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %12 = bitcast %struct.TString* %11 to i8*
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %14 = bitcast %struct.TString* %13 to i8*
  %15 = tail call i32 @memcmp(i8* nonnull %12, i8* nonnull %14, i64 %4) #19
  %16 = icmp eq i32 %15, 0
  %17 = zext i1 %16 to i32
  br label %18

; <label>:18:                                     ; preds = %6, %10, %2
  %19 = phi i32 [ 1, %2 ], [ 0, %6 ], [ %17, %10 ]
  ret i32 %19
}

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: nounwind
declare double @fmod(double, double) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @callbinTM(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 %4)
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %5
  %12 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %2, i32 %4)
  br label %13

; <label>:13:                                     ; preds = %11, %5
  %14 = phi %struct.TValue* [ %12, %11 ], [ %6, %5 ]
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = and i8 %16, 15
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %13
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %14, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3)
  br label %20

; <label>:20:                                     ; preds = %13, %19
  %21 = phi i32 [ 1, %19 ], [ 0, %13 ]
  ret i32 %21
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_concaterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.172, i64 0, i64 0)) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_tointerror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 35
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %3
  %10 = bitcast %struct.TValue* %1 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  store i64 %11, i64* %4, align 8, !tbaa !109
  br label %16

; <label>:12:                                     ; preds = %3
  %13 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %1, i64* nonnull %4, i32 0)
  %14 = icmp eq i32 %13, 0
  %15 = select i1 %14, %struct.TValue* %1, %struct.TValue* %2
  br label %16

; <label>:16:                                     ; preds = %12, %9
  %17 = phi %struct.TValue* [ %2, %9 ], [ %15, %12 ]
  %18 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %17)
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.175, i64 0, i64 0), i8* %18) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_opinterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i8*) unnamed_addr #5 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 3
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* %3) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_callTMres(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !34
  %9 = ptrtoint %union.StackValue* %4 to i64
  %10 = sub i64 %9, %8
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = bitcast %union.StackValue* %12 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0
  %20 = bitcast %struct.TValue* %2 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0
  %27 = bitcast %struct.TValue* %3 to i64*
  %28 = bitcast %struct.TValue* %26 to i64*
  %29 = load i64, i64* %27, align 8
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 3
  store %union.StackValue* %34, %union.StackValue** %11, align 8, !tbaa !20
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %36 = load %struct.CallInfo*, %struct.CallInfo** %35, align 8, !tbaa !35
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %36, i64 0, i32 7
  %38 = load i16, i16* %37, align 2, !tbaa !46
  %39 = and i16 %38, 6
  %40 = icmp eq i16 %39, 0
  br i1 %40, label %41, label %42

; <label>:41:                                     ; preds = %5
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1)
  br label %43

; <label>:42:                                     ; preds = %5
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1)
  br label %43

; <label>:43:                                     ; preds = %42, %41
  %44 = bitcast %union.StackValue** %6 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !34
  %46 = getelementptr inbounds i8, i8* %45, i64 %10
  %47 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  store %union.StackValue* %48, %union.StackValue** %11, align 8, !tbaa !20
  %49 = bitcast %union.StackValue* %48 to i64*
  %50 = bitcast i8* %46 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1, i32 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  %54 = getelementptr inbounds i8, i8* %46, i64 8
  store i8 %53, i8* %54, align 8, !tbaa !22
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_typeerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1)
  %5 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %1)
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.173, i64 0, i64 0), i8* %2, i8* %4, i8* %5) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaT_objtypename(%struct.lua_State*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 69
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %1 to %struct.Table**
  %8 = load %struct.Table*, %struct.Table** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 9
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = icmp eq %struct.Table* %10, null
  br i1 %11, label %33, label %21

; <label>:12:                                     ; preds = %2
  %13 = and i8 %4, 15
  %14 = icmp eq i8 %13, 7
  br i1 %14, label %15, label %33

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %1 to %struct.Udata**
  %17 = load %struct.Udata*, %struct.Udata** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.Udata, %struct.Udata* %17, i64 0, i32 5
  %19 = load %struct.Table*, %struct.Table** %18, align 8, !tbaa !21
  %20 = icmp eq %struct.Table* %19, null
  br i1 %20, label %33, label %21

; <label>:21:                                     ; preds = %6, %15
  %22 = phi %struct.Table* [ %10, %6 ], [ %19, %15 ]
  %23 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0))
  %24 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %22, %struct.TString* %23)
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 4
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %21
  %30 = bitcast %struct.TValue* %24 to i8**
  %31 = load i8*, i8** %30, align 8, !tbaa !21
  %32 = getelementptr inbounds i8, i8* %31, i64 24
  br label %40

; <label>:33:                                     ; preds = %21, %6, %15, %12
  %34 = load i8, i8* %3, align 8, !tbaa !22
  %35 = and i8 %34, 15
  %36 = add nuw nsw i8 %35, 1
  %37 = zext i8 %36 to i64
  %38 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %37
  %39 = load i8*, i8** %38, align 8, !tbaa !79
  br label %40

; <label>:40:                                     ; preds = %29, %33
  %41 = phi i8* [ %39, %33 ], [ %32, %29 ]
  ret i8* %41
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @varinfo(%struct.lua_State*, %struct.TValue*) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  store i8* null, i8** %3, align 8, !tbaa !79
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !35
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %8 = load i16, i16* %7, align 2, !tbaa !46
  %9 = and i16 %8, 2
  %10 = icmp eq i16 %9, 0
  br i1 %10, label %11, label %36

; <label>:11:                                     ; preds = %2
  %12 = call fastcc i8* @getupvalname(%struct.CallInfo* %6, %struct.TValue* %1, i8** nonnull %3)
  %13 = icmp eq i8* %12, null
  br i1 %13, label %14, label %32

; <label>:14:                                     ; preds = %11
  %15 = tail call fastcc i32 @isinstack(%struct.CallInfo* %6, %struct.TValue* %1)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %36, label %17

; <label>:17:                                     ; preds = %14
  %18 = bitcast %struct.CallInfo* %6 to %struct.LClosure***
  %19 = load %struct.LClosure**, %struct.LClosure*** %18, align 8, !tbaa !47
  %20 = load %struct.LClosure*, %struct.LClosure** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %20, i64 0, i32 5
  %22 = load %struct.Proto*, %struct.Proto** %21, align 8, !tbaa !21
  %23 = tail call fastcc i32 @currentpc(%struct.CallInfo* %6)
  %24 = getelementptr inbounds %struct.LClosure*, %struct.LClosure** %19, i64 2
  %25 = ptrtoint %struct.TValue* %1 to i64
  %26 = ptrtoint %struct.LClosure** %24 to i64
  %27 = sub i64 %25, %26
  %28 = lshr exact i64 %27, 4
  %29 = trunc i64 %28 to i32
  %30 = call fastcc i8* @getobjname(%struct.Proto* %22, i32 %23, i32 %29, i8** nonnull %3)
  %31 = icmp eq i8* %30, null
  br i1 %31, label %36, label %32

; <label>:32:                                     ; preds = %11, %17
  %33 = phi i8* [ %30, %17 ], [ %12, %11 ]
  %34 = load i8*, i8** %3, align 8, !tbaa !79
  %35 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.174, i64 0, i64 0), i8* nonnull %33, i8* %34)
  br label %36

; <label>:36:                                     ; preds = %14, %2, %17, %32
  %37 = phi i8* [ %35, %32 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %17 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %2 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %14 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %37
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @getupvalname(%struct.CallInfo* nocapture readonly, %struct.TValue* readnone, i8** nocapture) unnamed_addr #2 {
  %4 = bitcast %struct.CallInfo* %0 to %struct.LClosure***
  %5 = load %struct.LClosure**, %struct.LClosure*** %4, align 8, !tbaa !47
  %6 = load %struct.LClosure*, %struct.LClosure** %5, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %6, i64 0, i32 3
  %8 = load i8, i8* %7, align 2, !tbaa !138
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %28, label %10

; <label>:10:                                     ; preds = %3
  br label %11

; <label>:11:                                     ; preds = %10, %23
  %12 = phi i64 [ %24, %23 ], [ 0, %10 ]
  %13 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %6, i64 0, i32 6, i64 %12
  %14 = load %struct.UpVal*, %struct.UpVal** %13, align 8, !tbaa !79
  %15 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 3
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !50
  %17 = icmp eq %struct.TValue* %16, %1
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %11
  %19 = trunc i64 %12 to i32
  %20 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %6, i64 0, i32 5
  %21 = load %struct.Proto*, %struct.Proto** %20, align 8, !tbaa !173
  %22 = tail call fastcc i8* @upvalname(%struct.Proto* %21, i32 %19)
  store i8* %22, i8** %2, align 8, !tbaa !79
  br label %28

; <label>:23:                                     ; preds = %11
  %24 = add nuw nsw i64 %12, 1
  %25 = load i8, i8* %7, align 2, !tbaa !138
  %26 = zext i8 %25 to i64
  %27 = icmp ult i64 %24, %26
  br i1 %27, label %11, label %28

; <label>:28:                                     ; preds = %23, %3, %18
  %29 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %18 ], [ null, %3 ], [ null, %23 ]
  ret i8* %29
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @isinstack(%struct.CallInfo* nocapture readonly, %struct.TValue*) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 0
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !47
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 1
  %6 = ptrtoint %struct.TValue* %1 to i64
  %7 = ptrtoint %union.StackValue* %5 to i64
  %8 = sub i64 %6, %7
  %9 = icmp sgt i64 %8, -16
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %0, i64 0, i32 1
  %12 = bitcast %union.StackValue** %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !49
  %14 = sub i64 %13, %7
  %15 = icmp slt i64 %8, %14
  %16 = zext i1 %15 to i32
  ret i32 %16

; <label>:17:                                     ; preds = %2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i8* @luaO_pushfstring(%struct.lua_State*, i8*, ...) unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5)
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaV_flttointeger(double, i64* nocapture, i32) unnamed_addr #0 {
  %4 = tail call double @llvm.floor.f64(double %0)
  %5 = fcmp une double %4, %0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i32 %2, 0
  br i1 %7, label %19, label %8

; <label>:8:                                      ; preds = %6
  %9 = icmp sgt i32 %2, 1
  %10 = fadd double %4, 1.000000e+00
  %11 = select i1 %9, double %10, double %4
  br label %12

; <label>:12:                                     ; preds = %8, %3
  %13 = phi double [ %4, %3 ], [ %11, %8 ]
  %14 = fcmp oge double %13, 0xC3E0000000000000
  %15 = fcmp olt double %13, 0x43E0000000000000
  %16 = and i1 %14, %15
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %12
  %18 = fptosi double %13 to i64
  store i64 %18, i64* %1, align 8, !tbaa !109
  br label %19

; <label>:19:                                     ; preds = %12, %17, %6
  %20 = phi i32 [ 0, %6 ], [ 0, %12 ], [ 1, %17 ]
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LTintfloat(i64, double) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = add i64 %0, 9007199254740992
  %5 = icmp ult i64 %4, 18014398509481985
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = sitofp i64 %0 to double
  %8 = fcmp olt double %7, %1
  br label %17

; <label>:9:                                      ; preds = %2
  %10 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = call fastcc i32 @luaV_flttointeger(double %1, i64* nonnull %3, i32 2)
  %12 = icmp eq i32 %11, 0
  %13 = load i64, i64* %3, align 8
  %14 = icmp sgt i64 %13, %0
  %15 = fcmp ogt double %1, 0.000000e+00
  %16 = select i1 %12, i1 %15, i1 %14
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i1 [ %8, %6 ], [ %16, %9 ]
  %19 = zext i1 %18 to i32
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LTfloatint(double, i64) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = add i64 %1, 9007199254740992
  %5 = icmp ult i64 %4, 18014398509481985
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = sitofp i64 %1 to double
  %8 = fcmp ogt double %7, %0
  br label %17

; <label>:9:                                      ; preds = %2
  %10 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = call fastcc i32 @luaV_flttointeger(double %0, i64* nonnull %3, i32 1)
  %12 = icmp eq i32 %11, 0
  %13 = load i64, i64* %3, align 8
  %14 = icmp slt i64 %13, %1
  %15 = fcmp olt double %0, 0.000000e+00
  %16 = select i1 %12, i1 %15, i1 %14
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i1 [ %8, %6 ], [ %16, %9 ]
  %19 = zext i1 %18 to i32
  ret i32 %19
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @l_strcmp(%struct.TString* nocapture readonly, %struct.TString* nocapture readonly) unnamed_addr #14 {
  %3 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %4 = bitcast %struct.TString* %3 to i8*
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !57
  %7 = icmp eq i8 %6, 20
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !232
  %11 = zext i8 %10 to i64
  br label %15

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %14 = load i64, i64* %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %8
  %16 = phi i64 [ %11, %8 ], [ %14, %12 ]
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !57
  %21 = icmp eq i8 %20, 20
  br i1 %21, label %22, label %26

; <label>:22:                                     ; preds = %15
  %23 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 4
  %24 = load i8, i8* %23, align 1, !tbaa !232
  %25 = zext i8 %24 to i64
  br label %29

; <label>:26:                                     ; preds = %15
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 6, i32 0
  %28 = load i64, i64* %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %26, %22
  %30 = phi i64 [ %25, %22 ], [ %28, %26 ]
  %31 = tail call i32 @strcoll(i8* nonnull %4, i8* nonnull %18) #19
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %54

; <label>:33:                                     ; preds = %29
  br label %34

; <label>:34:                                     ; preds = %33, %46
  %35 = phi i64 [ %51, %46 ], [ %30, %33 ]
  %36 = phi i8* [ %50, %46 ], [ %18, %33 ]
  %37 = phi i64 [ %49, %46 ], [ %16, %33 ]
  %38 = phi i8* [ %48, %46 ], [ %4, %33 ]
  %39 = tail call i64 @strlen(i8* %38) #19
  %40 = icmp eq i64 %39, %35
  %41 = icmp eq i64 %39, %37
  br i1 %40, label %42, label %45

; <label>:42:                                     ; preds = %34
  %43 = xor i1 %41, true
  %44 = zext i1 %43 to i32
  br label %54

; <label>:45:                                     ; preds = %34
  br i1 %41, label %54, label %46

; <label>:46:                                     ; preds = %45
  %47 = add i64 %39, 1
  %48 = getelementptr inbounds i8, i8* %38, i64 %47
  %49 = sub i64 %37, %47
  %50 = getelementptr inbounds i8, i8* %36, i64 %47
  %51 = sub i64 %35, %47
  %52 = tail call i32 @strcoll(i8* %48, i8* %50) #19
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %34, label %54

; <label>:54:                                     ; preds = %46, %45, %29, %42
  %55 = phi i32 [ %44, %42 ], [ %31, %29 ], [ %52, %46 ], [ -1, %45 ]
  ret i32 %55
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaT_callorderTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %6, i32 %3)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %25, label %9

; <label>:9:                                      ; preds = %4
  %10 = bitcast %union.StackValue** %5 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %23, label %16

; <label>:16:                                     ; preds = %9
  %17 = icmp eq i8 %13, 1
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %16
  %19 = bitcast %struct.TValue* %11 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = icmp ne i32 %20, 0
  %22 = zext i1 %21 to i32
  br label %23

; <label>:23:                                     ; preds = %16, %18, %9
  %24 = phi i32 [ 0, %9 ], [ 1, %16 ], [ %22, %18 ]
  ret i32 %24

; <label>:25:                                     ; preds = %4
  tail call fastcc void @luaG_ordererror(%struct.lua_State* nonnull %0, %struct.TValue* %1, %struct.TValue* %2) #17
  unreachable
}

; Function Attrs: nounwind readonly
declare i32 @strcoll(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaG_ordererror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1)
  %5 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %2)
  %6 = tail call i32 @strcmp(i8* %4, i8* %5) #19
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.176, i64 0, i64 0), i8* %4) #17
  unreachable

; <label>:9:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.177, i64 0, i64 0), i8* %4, i8* %5) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LEintfloat(i64, double) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = add i64 %0, 9007199254740992
  %5 = icmp ult i64 %4, 18014398509481985
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = sitofp i64 %0 to double
  %8 = fcmp ole double %7, %1
  br label %17

; <label>:9:                                      ; preds = %2
  %10 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = call fastcc i32 @luaV_flttointeger(double %1, i64* nonnull %3, i32 1)
  %12 = icmp eq i32 %11, 0
  %13 = load i64, i64* %3, align 8
  %14 = icmp sge i64 %13, %0
  %15 = fcmp ogt double %1, 0.000000e+00
  %16 = select i1 %12, i1 %15, i1 %14
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i1 [ %8, %6 ], [ %16, %9 ]
  %19 = zext i1 %18 to i32
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LEfloatint(double, i64) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = add i64 %1, 9007199254740992
  %5 = icmp ult i64 %4, 18014398509481985
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = sitofp i64 %1 to double
  %8 = fcmp oge double %7, %0
  br label %17

; <label>:9:                                      ; preds = %2
  %10 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = call fastcc i32 @luaV_flttointeger(double %0, i64* nonnull %3, i32 2)
  %12 = icmp eq i32 %11, 0
  %13 = load i64, i64* %3, align 8
  %14 = icmp sle i64 %13, %1
  %15 = fcmp olt double %0, 0.000000e+00
  %16 = select i1 %12, i1 %15, i1 %14
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i1 [ %8, %6 ], [ %16, %9 ]
  %19 = zext i1 %18 to i32
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 3
  %4 = add nsw i32 %3, 32
  %5 = sext i32 %4 to i64
  %6 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 22, i64 %5)
  %7 = bitcast %struct.GCObject* %6 to %struct.LClosure*
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %9 = bitcast i8* %8 to %struct.Proto**
  store %struct.Proto* null, %struct.Proto** %9, align 8, !tbaa !173
  %10 = trunc i32 %1 to i8
  %11 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %7, i64 0, i32 3
  store i8 %10, i8* %11, align 2, !tbaa !138
  %12 = icmp eq i32 %1, 0
  br i1 %12, label %23, label %13

; <label>:13:                                     ; preds = %2
  %14 = sext i32 %1 to i64
  %15 = getelementptr %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %16 = add i32 %1, -1
  %17 = zext i32 %16 to i64
  %18 = sub nsw i64 %14, %17
  %19 = shl nsw i64 %18, 3
  %20 = getelementptr i8, i8* %15, i64 %19
  %21 = zext i32 %1 to i64
  %22 = shl nuw nsw i64 %21, 3
  call void @llvm.memset.p0i8.i64(i8* %20, i8 0, i64 %22, i32 8, i1 false)
  br label %23

; <label>:23:                                     ; preds = %13, %2
  ret %struct.LClosure* %7
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %4 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !79
  %5 = icmp eq %struct.UpVal* %4, null
  br i1 %5, label %30, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %8

; <label>:8:                                      ; preds = %6, %26
  %9 = phi %struct.UpVal* [ %4, %6 ], [ %28, %26 ]
  %10 = phi %struct.UpVal** [ %3, %6 ], [ %27, %26 ]
  %11 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 3
  %12 = bitcast %struct.TValue** %11 to %union.StackValue**
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !50
  %14 = icmp ult %union.StackValue* %13, %1
  br i1 %14, label %30, label %15

; <label>:15:                                     ; preds = %8
  %16 = icmp eq %union.StackValue* %13, %1
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %15
  %18 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !52
  %20 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 10
  %22 = load i8, i8* %21, align 4, !tbaa !15
  %23 = xor i8 %22, 24
  %24 = and i8 %23, %19
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %33, label %26

; <label>:26:                                     ; preds = %17, %15
  %27 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 4, i32 0, i32 0
  %28 = load %struct.UpVal*, %struct.UpVal** %27, align 8, !tbaa !79
  %29 = icmp eq %struct.UpVal* %28, null
  br i1 %29, label %30, label %8

; <label>:30:                                     ; preds = %26, %8, %2
  %31 = phi %struct.UpVal** [ %3, %2 ], [ %10, %8 ], [ %27, %26 ]
  %32 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 9, %union.StackValue* %1, %struct.UpVal** nonnull %31)
  br label %33

; <label>:33:                                     ; preds = %17, %30
  %34 = phi %struct.UpVal* [ %32, %30 ], [ %9, %17 ]
  ret %struct.UpVal* %34
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State*, i32, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = and i32 %1, 15
  %7 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %2, i32 %6)
  %8 = bitcast i8* %7 to %struct.GCObject*
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %10 = load i8, i8* %9, align 4, !tbaa !15
  %11 = and i8 %10, 24
  %12 = getelementptr inbounds i8, i8* %7, i64 9
  store i8 %11, i8* %12, align 1, !tbaa !53
  %13 = trunc i32 %1 to i8
  %14 = getelementptr inbounds i8, i8* %7, i64 8
  store i8 %13, i8* %14, align 8, !tbaa !205
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  %16 = bitcast %struct.GCObject** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !18
  %18 = bitcast i8* %7 to i64*
  store i64 %17, i64* %18, align 8, !tbaa !129
  %19 = bitcast %struct.GCObject** %15 to i8**
  store i8* %7, i8** %19, align 8, !tbaa !18
  ret %struct.GCObject* %8
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.UpVal* @newupval(%struct.lua_State*, i32, %union.StackValue*, %struct.UpVal**) unnamed_addr #0 {
  %5 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 %1, i64 40)
  %6 = bitcast %struct.GCObject* %5 to %struct.UpVal*
  %7 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !79
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1
  %10 = bitcast %struct.GCObject* %9 to %struct.TValue**
  store %struct.TValue* %8, %struct.TValue** %10, align 8, !tbaa !50
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %5, i64 1, i32 1
  %12 = bitcast i8* %11 to %struct.UpVal**
  store %struct.UpVal* %7, %struct.UpVal** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds i8, i8* %11, i64 8
  %14 = bitcast i8* %13 to %struct.UpVal***
  store %struct.UpVal** %3, %struct.UpVal*** %14, align 8, !tbaa !21
  %15 = icmp eq %struct.UpVal* %7, null
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %7, i64 0, i32 4, i32 0, i32 1
  %18 = bitcast %struct.UpVal*** %17 to i8**
  store i8* %11, i8** %18, align 8, !tbaa !21
  br label %19

; <label>:19:                                     ; preds = %4, %16
  %20 = bitcast %struct.UpVal** %3 to %struct.GCObject**
  store %struct.GCObject* %5, %struct.GCObject** %20, align 8, !tbaa !79
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 14
  %22 = load %struct.lua_State*, %struct.lua_State** %21, align 8, !tbaa !38
  %23 = icmp eq %struct.lua_State* %22, %0
  br i1 %23, label %24, label %31

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 36
  %28 = bitcast %struct.lua_State** %27 to i64*
  %29 = load i64, i64* %28, align 8, !tbaa !228
  %30 = bitcast %struct.lua_State** %21 to i64*
  store i64 %29, i64* %30, align 8, !tbaa !38
  store %struct.lua_State* %0, %struct.lua_State** %27, align 8, !tbaa !228
  br label %31

; <label>:31:                                     ; preds = %19, %24
  ret %struct.UpVal* %6
}

; Function Attrs: nounwind uwtable
define internal fastcc %union.StackValue* @rethook(%struct.lua_State*, %struct.CallInfo* nocapture, %union.StackValue*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !34
  %11 = sub i64 %7, %10
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %13 = load i16, i16* %12, align 2, !tbaa !46
  %14 = and i16 %13, 6
  %15 = icmp eq i16 %14, 0
  br i1 %15, label %16, label %42

; <label>:16:                                     ; preds = %4
  %17 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %18 = load %struct.LClosure**, %struct.LClosure*** %17, align 8, !tbaa !47
  %19 = load %struct.LClosure*, %struct.LClosure** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %19, i64 0, i32 5
  %21 = load %struct.Proto*, %struct.Proto** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.Proto, %struct.Proto* %21, i64 0, i32 4
  %23 = load i8, i8* %22, align 1, !tbaa !94
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %35, label %25

; <label>:25:                                     ; preds = %16
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %27 = bitcast %union.anon.0* %26 to %struct.anon*
  %28 = getelementptr inbounds %struct.anon, %struct.anon* %27, i64 0, i32 2
  %29 = load i32, i32* %28, align 4, !tbaa !21
  %30 = getelementptr inbounds %struct.Proto, %struct.Proto* %21, i64 0, i32 3
  %31 = load i8, i8* %30, align 2, !tbaa !95
  %32 = zext i8 %31 to i32
  %33 = add i32 %29, 1
  %34 = add i32 %33, %32
  br label %35

; <label>:35:                                     ; preds = %16, %25
  %36 = phi i32 [ %34, %25 ], [ 0, %16 ]
  %37 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %38 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %39 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !49
  %40 = icmp ult %union.StackValue* %37, %39
  br i1 %40, label %41, label %42

; <label>:41:                                     ; preds = %35
  store %union.StackValue* %39, %union.StackValue** %5, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %35, %41, %4
  %43 = phi i32 [ 0, %4 ], [ %36, %41 ], [ %36, %35 ]
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %45 = load i32, i32* %44, align 8, !tbaa !23
  %46 = and i32 %45, 2
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %62, label %48

; <label>:48:                                     ; preds = %42
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %50 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !47
  %51 = sext i32 %43 to i64
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %50, i64 %51
  store %union.StackValue* %52, %union.StackValue** %49, align 8, !tbaa !47
  %53 = ptrtoint %union.StackValue* %2 to i64
  %54 = ptrtoint %union.StackValue* %52 to i64
  %55 = sub i64 %53, %54
  %56 = lshr exact i64 %55, 4
  %57 = trunc i64 %56 to i32
  %58 = and i32 %57, 65535
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 1, i32 -1, i32 %58, i32 %3)
  %59 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !47
  %60 = sub nsw i64 0, %51
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 %60
  store %union.StackValue* %61, %union.StackValue** %49, align 8, !tbaa !47
  br label %62

; <label>:62:                                     ; preds = %42, %48
  %63 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %64 = load %struct.CallInfo*, %struct.CallInfo** %63, align 8, !tbaa !78
  %65 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %64, i64 0, i32 7
  %66 = load i16, i16* %65, align 2, !tbaa !46
  %67 = and i16 %66, 2
  %68 = icmp eq i16 %67, 0
  br i1 %68, label %69, label %75

; <label>:69:                                     ; preds = %62
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %64, i64 0, i32 4
  %71 = bitcast %union.anon.0* %70 to i64*
  %72 = load i64, i64* %71, align 8, !tbaa !21
  %73 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %74 = bitcast i32** %73 to i64*
  store i64 %72, i64* %74, align 8, !tbaa !77
  br label %75

; <label>:75:                                     ; preds = %62, %69
  %76 = bitcast %union.StackValue** %8 to i8**
  %77 = load i8*, i8** %76, align 8, !tbaa !34
  %78 = getelementptr inbounds i8, i8* %77, i64 %11
  %79 = bitcast i8* %78 to %union.StackValue*
  ret %union.StackValue* %79
}

; Function Attrs: nounwind uwtable
define internal fastcc void @moveresults(%struct.lua_State*, %union.StackValue*, i32, i32) unnamed_addr #0 {
  switch i32 %3, label %25 [
    i32 0, label %5
    i32 1, label %7
    i32 -1, label %41
  ]

; <label>:5:                                      ; preds = %4
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %1, %union.StackValue** %6, align 8, !tbaa !20
  br label %85

; <label>:7:                                      ; preds = %4
  %8 = icmp eq i32 %2, 0
  br i1 %8, label %20, label %9

; <label>:9:                                      ; preds = %7
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = sext i32 %2 to i64
  %13 = sub nsw i64 0, %12
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %13, i32 0
  %15 = bitcast %struct.TValue* %14 to i64*
  %16 = bitcast %union.StackValue* %1 to i64*
  %17 = load i64, i64* %15, align 8
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %13, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  br label %20

; <label>:20:                                     ; preds = %7, %9
  %21 = phi i8 [ %19, %9 ], [ 0, %7 ]
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 %21, i8* %22, align 8, !tbaa !21
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %23, %union.StackValue** %24, align 8, !tbaa !20
  br label %85

; <label>:25:                                     ; preds = %4
  %26 = icmp slt i32 %3, -1
  br i1 %26, label %27, label %41

; <label>:27:                                     ; preds = %25
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %29 = bitcast %union.StackValue** %28 to i64*
  %30 = load i64, i64* %29, align 8, !tbaa !34
  %31 = ptrtoint %union.StackValue* %1 to i64
  %32 = sub i64 %31, %30
  %33 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %1, i32 0)
  %34 = bitcast %union.StackValue** %28 to i8**
  %35 = load i8*, i8** %34, align 8, !tbaa !34
  %36 = getelementptr inbounds i8, i8* %35, i64 %32
  %37 = bitcast i8* %36 to %union.StackValue*
  %38 = sub i32 -3, %3
  %39 = icmp eq i32 %38, -1
  %40 = select i1 %39, i32 %2, i32 %38
  br label %41

; <label>:41:                                     ; preds = %4, %25, %27
  %42 = phi i32 [ %40, %27 ], [ %3, %25 ], [ %2, %4 ]
  %43 = phi %union.StackValue* [ %37, %27 ], [ %1, %25 ], [ %1, %4 ]
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %45 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %46 = sext i32 %2 to i64
  %47 = sub nsw i64 0, %46
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 %47
  %49 = icmp sgt i32 %2, 0
  %50 = icmp sgt i32 %42, 0
  %51 = and i1 %49, %50
  br i1 %51, label %52, label %71

; <label>:52:                                     ; preds = %41
  %53 = sext i32 %42 to i64
  %54 = sext i32 %2 to i64
  br label %55

; <label>:55:                                     ; preds = %52, %55
  %56 = phi i64 [ 0, %52 ], [ %65, %55 ]
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 %56, i32 0
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 %56
  %59 = bitcast %union.StackValue* %58 to i64*
  %60 = bitcast %struct.TValue* %57 to i64*
  %61 = load i64, i64* %59, align 8
  store i64 %61, i64* %60, align 8
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 0, i32 0, i32 1
  %63 = load i8, i8* %62, align 8, !tbaa !22
  %64 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 %56, i32 0, i32 1
  store i8 %63, i8* %64, align 8, !tbaa !22
  %65 = add nuw nsw i64 %56, 1
  %66 = icmp slt i64 %65, %54
  %67 = icmp slt i64 %65, %53
  %68 = and i1 %66, %67
  br i1 %68, label %55, label %69

; <label>:69:                                     ; preds = %55
  %70 = trunc i64 %65 to i32
  br label %71

; <label>:71:                                     ; preds = %69, %41
  %72 = phi i32 [ 0, %41 ], [ %70, %69 ]
  %73 = icmp slt i32 %72, %42
  br i1 %73, label %74, label %82

; <label>:74:                                     ; preds = %71
  %75 = zext i32 %72 to i64
  br label %76

; <label>:76:                                     ; preds = %76, %74
  %77 = phi i64 [ %75, %74 ], [ %79, %76 ]
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 %77, i32 0, i32 1
  store i8 0, i8* %78, align 8, !tbaa !21
  %79 = add nuw nsw i64 %77, 1
  %80 = trunc i64 %79 to i32
  %81 = icmp eq i32 %42, %80
  br i1 %81, label %82, label %76

; <label>:82:                                     ; preds = %76, %71
  %83 = sext i32 %42 to i64
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 %83
  store %union.StackValue* %84, %union.StackValue** %44, align 8, !tbaa !20
  br label %85

; <label>:85:                                     ; preds = %82, %20, %5
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.CallInfo* @findpcall(%struct.lua_State* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !79
  %4 = icmp eq %struct.CallInfo* %3, null
  br i1 %4, label %16, label %5

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %5, %12
  %7 = phi %struct.CallInfo* [ %14, %12 ], [ %3, %5 ]
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !46
  %10 = and i16 %9, 8
  %11 = icmp eq i16 %10, 0
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 2
  %14 = load %struct.CallInfo*, %struct.CallInfo** %13, align 8, !tbaa !79
  %15 = icmp eq %struct.CallInfo* %14, null
  br i1 %15, label %16, label %6

; <label>:16:                                     ; preds = %6, %12, %1
  %17 = phi %struct.CallInfo* [ null, %1 ], [ null, %12 ], [ %7, %6 ]
  ret %struct.CallInfo* %17
}

; Function Attrs: nounwind uwtable
define internal fastcc void @finishCcall(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !35
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %6 = load i16, i16* %5, align 2, !tbaa !46
  %7 = and i16 %6, 8
  %8 = icmp eq i16 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %2
  %10 = and i16 %6, -9
  store i16 %10, i16* %5, align 2, !tbaa !46
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 %12, i64* %13, align 8, !tbaa !44
  br label %14

; <label>:14:                                     ; preds = %2, %9
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 6
  %16 = load i16, i16* %15, align 4, !tbaa !48
  %17 = icmp slt i16 %16, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %14
  %19 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !49
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %23 = icmp ult %union.StackValue* %20, %22
  br i1 %23, label %24, label %25

; <label>:24:                                     ; preds = %18
  store %union.StackValue* %22, %union.StackValue** %19, align 8, !tbaa !49
  br label %25

; <label>:25:                                     ; preds = %24, %18, %14
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 0
  %27 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %27(%struct.lua_State* nonnull %0, i32 %1, i64 %29) #7
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %4, i32 %30)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaV_finishOp(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !35
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !47
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 4
  %8 = bitcast %union.anon.0* %7 to i32**
  %9 = load i32*, i32** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds i32, i32* %9, i64 -1
  %11 = load i32, i32* %10, align 4, !tbaa !70
  %12 = trunc i32 %11 to i7
  switch i7 %12, label %74 [
    i7 19, label %13
    i7 20, label %13
    i7 21, label %13
    i7 24, label %13
    i7 25, label %13
    i7 22, label %13
    i7 23, label %13
    i7 38, label %13
    i7 39, label %13
    i7 40, label %13
    i7 43, label %13
    i7 44, label %13
    i7 33, label %13
    i7 34, label %13
    i7 35, label %13
    i7 45, label %13
    i7 46, label %13
    i7 47, label %13
    i7 36, label %13
    i7 48, label %13
    i7 49, label %13
    i7 41, label %13
    i7 42, label %13
    i7 50, label %13
    i7 51, label %13
    i7 53, label %13
    i7 9, label %13
    i7 10, label %13
    i7 11, label %13
    i7 12, label %13
    i7 18, label %13
    i7 59, label %27
    i7 60, label %27
    i7 63, label %27
    i7 -64, label %27
    i7 -63, label %27
    i7 -62, label %27
    i7 58, label %27
    i7 54, label %51
  ]

; <label>:13:                                     ; preds = %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1, %1
  %14 = lshr i32 %11, 7
  %15 = and i32 %14, 255
  %16 = zext i32 %15 to i64
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %16
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1
  store %union.StackValue* %20, %union.StackValue** %18, align 8, !tbaa !20
  %21 = bitcast %union.StackValue* %20 to i64*
  %22 = bitcast %union.StackValue* %17 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 0, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  br label %74

; <label>:27:                                     ; preds = %1, %1, %1, %1, %1, %1, %1
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %29 = load %union.StackValue*, %union.StackValue** %28, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !21
  %32 = and i8 %31, 15
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %42, label %34

; <label>:34:                                     ; preds = %27
  %35 = icmp eq i8 %31, 1
  br i1 %35, label %36, label %42

; <label>:36:                                     ; preds = %34
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 0
  %38 = bitcast %union.Value* %37 to i32*
  %39 = load i32, i32* %38, align 8, !tbaa !21
  %40 = icmp ne i32 %39, 0
  %41 = zext i1 %40 to i32
  br label %42

; <label>:42:                                     ; preds = %34, %36, %27
  %43 = phi i32 [ 0, %27 ], [ 1, %34 ], [ %41, %36 ]
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1
  store %union.StackValue* %44, %union.StackValue** %28, align 8, !tbaa !20
  %45 = lshr i32 %11, 15
  %46 = and i32 %45, 1
  %47 = icmp eq i32 %43, %46
  br i1 %47, label %74, label %48

; <label>:48:                                     ; preds = %42
  %49 = load i32*, i32** %8, align 8, !tbaa !21
  %50 = getelementptr inbounds i32, i32* %49, i64 1
  store i32* %50, i32** %8, align 8, !tbaa !21
  br label %74

; <label>:51:                                     ; preds = %1
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %53 = load %union.StackValue*, %union.StackValue** %52, align 8, !tbaa !20
  %54 = lshr i32 %11, 7
  %55 = and i32 %54, 255
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 -2
  %57 = zext i32 %55 to i64
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %57
  %59 = ptrtoint %union.StackValue* %56 to i64
  %60 = ptrtoint %union.StackValue* %58 to i64
  %61 = sub i64 %59, %60
  %62 = lshr exact i64 %61, 4
  %63 = trunc i64 %62 to i32
  %64 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 -3, i32 0
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 -1, i32 0
  %66 = bitcast %struct.TValue* %65 to i64*
  %67 = bitcast %struct.TValue* %64 to i64*
  %68 = load i64, i64* %66, align 8
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 -1, i32 0, i32 1
  %70 = load i8, i8* %69, align 8, !tbaa !22
  %71 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 -3, i32 0, i32 1
  store i8 %70, i8* %71, align 8, !tbaa !22
  %72 = icmp sgt i32 %63, 1
  br i1 %72, label %73, label %74

; <label>:73:                                     ; preds = %51
  store %union.StackValue* %56, %union.StackValue** %52, align 8, !tbaa !20
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %0, i32 %63)
  br label %74

; <label>:74:                                     ; preds = %51, %73, %48, %42, %1, %13
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaG_addinfo(%struct.lua_State*, i8*, %struct.TString*, i32) unnamed_addr #0 {
  %5 = alloca [60 x i8], align 16
  %6 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 60, i8* nonnull %6) #7
  %7 = icmp eq %struct.TString* %2, null
  br i1 %7, label %23, label %8

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 1
  %10 = bitcast %struct.TString* %9 to i8*
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !57
  %13 = icmp eq i8 %12, 20
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %8
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 4
  %16 = load i8, i8* %15, align 1, !tbaa !232
  %17 = zext i8 %16 to i64
  br label %21

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 6, i32 0
  %20 = load i64, i64* %19, align 8, !tbaa !21
  br label %21

; <label>:21:                                     ; preds = %18, %14
  %22 = phi i64 [ %17, %14 ], [ %20, %18 ]
  call fastcc void @luaO_chunkid(i8* nonnull %6, i8* nonnull %10, i64 %22)
  br label %25

; <label>:23:                                     ; preds = %4
  store i8 63, i8* %6, align 16, !tbaa !21
  %24 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 1
  store i8 0, i8* %24, align 1, !tbaa !21
  br label %25

; <label>:25:                                     ; preds = %23, %21
  %26 = call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.180, i64 0, i64 0), i8* nonnull %6, i32 %3, i8* %1)
  call void @llvm.lifetime.end.p0i8(i64 60, i8* nonnull %6) #7
  ret i8* %26
}

; Function Attrs: noreturn nounwind
declare void @longjmp(%struct.__jmp_buf_tag*, i32) local_unnamed_addr #15

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #15

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaO_rawarith(%struct.lua_State*, i32, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture) unnamed_addr #0 {
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  switch i32 %1, label %64 [
    i32 7, label %8
    i32 8, label %8
    i32 9, label %8
    i32 10, label %8
    i32 11, label %8
    i32 13, label %8
    i32 5, label %38
    i32 4, label %38
  ]

; <label>:8:                                      ; preds = %5, %5, %5, %5, %5, %5
  %9 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = bitcast i64* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = icmp eq i8 %12, 35
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %8
  %15 = bitcast %struct.TValue* %2 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !21
  store i64 %16, i64* %6, align 8, !tbaa !109
  br label %20

; <label>:17:                                     ; preds = %8
  %18 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2, i64* nonnull %6, i32 0)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %36, label %20

; <label>:20:                                     ; preds = %17, %14
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = icmp eq i8 %22, 35
  br i1 %23, label %24, label %27

; <label>:24:                                     ; preds = %20
  %25 = bitcast %struct.TValue* %3 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !21
  store i64 %26, i64* %7, align 8, !tbaa !109
  br label %30

; <label>:27:                                     ; preds = %20
  %28 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %3, i64* nonnull %7, i32 0)
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %36, label %30

; <label>:30:                                     ; preds = %27, %24
  %31 = load i64, i64* %6, align 8, !tbaa !109
  %32 = load i64, i64* %7, align 8, !tbaa !109
  %33 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %31, i64 %32)
  %34 = bitcast %struct.TValue* %4 to i64*
  store i64 %33, i64* %34, align 8, !tbaa !21
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %35, align 8, !tbaa !22
  br label %36

; <label>:36:                                     ; preds = %17, %27, %30
  %37 = phi i32 [ 1, %30 ], [ 0, %27 ], [ 0, %17 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  br label %100

; <label>:38:                                     ; preds = %5, %5
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %40 = load i8, i8* %39, align 8, !tbaa !22
  switch i8 %40, label %100 [
    i8 19, label %41
    i8 35, label %44
  ]

; <label>:41:                                     ; preds = %38
  %42 = bitcast %struct.TValue* %2 to double*
  %43 = load double, double* %42, align 8, !tbaa !21
  br label %48

; <label>:44:                                     ; preds = %38
  %45 = bitcast %struct.TValue* %2 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !21
  %47 = sitofp i64 %46 to double
  br label %48

; <label>:48:                                     ; preds = %41, %44
  %49 = phi double [ %43, %41 ], [ %47, %44 ]
  %50 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %51 = load i8, i8* %50, align 8, !tbaa !22
  switch i8 %51, label %100 [
    i8 19, label %52
    i8 35, label %55
  ]

; <label>:52:                                     ; preds = %48
  %53 = bitcast %struct.TValue* %3 to double*
  %54 = load double, double* %53, align 8, !tbaa !21
  br label %59

; <label>:55:                                     ; preds = %48
  %56 = bitcast %struct.TValue* %3 to i64*
  %57 = load i64, i64* %56, align 8, !tbaa !21
  %58 = sitofp i64 %57 to double
  br label %59

; <label>:59:                                     ; preds = %52, %55
  %60 = phi double [ %54, %52 ], [ %58, %55 ]
  %61 = tail call fastcc double @numarith(i32 %1, double %49, double %60)
  %62 = bitcast %struct.TValue* %4 to double*
  store double %61, double* %62, align 8, !tbaa !21
  %63 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %63, align 8, !tbaa !22
  br label %100

; <label>:64:                                     ; preds = %5
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %66 = load i8, i8* %65, align 8, !tbaa !22
  switch i8 %66, label %100 [
    i8 35, label %67
    i8 19, label %79
  ]

; <label>:67:                                     ; preds = %64
  %68 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %69 = load i8, i8* %68, align 8, !tbaa !22
  %70 = icmp eq i8 %69, 35
  %71 = bitcast %struct.TValue* %2 to i64*
  %72 = load i64, i64* %71, align 8, !tbaa !21
  br i1 %70, label %73, label %82

; <label>:73:                                     ; preds = %67
  %74 = bitcast %struct.TValue* %3 to i64*
  %75 = load i64, i64* %74, align 8, !tbaa !21
  %76 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %72, i64 %75)
  %77 = bitcast %struct.TValue* %4 to i64*
  store i64 %76, i64* %77, align 8, !tbaa !21
  %78 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %78, align 8, !tbaa !22
  br label %100

; <label>:79:                                     ; preds = %64
  %80 = bitcast %struct.TValue* %2 to double*
  %81 = load double, double* %80, align 8, !tbaa !21
  br label %84

; <label>:82:                                     ; preds = %67
  %83 = sitofp i64 %72 to double
  br label %84

; <label>:84:                                     ; preds = %79, %82
  %85 = phi double [ %81, %79 ], [ %83, %82 ]
  %86 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %87 = load i8, i8* %86, align 8, !tbaa !22
  switch i8 %87, label %100 [
    i8 19, label %88
    i8 35, label %91
  ]

; <label>:88:                                     ; preds = %84
  %89 = bitcast %struct.TValue* %3 to double*
  %90 = load double, double* %89, align 8, !tbaa !21
  br label %95

; <label>:91:                                     ; preds = %84
  %92 = bitcast %struct.TValue* %3 to i64*
  %93 = load i64, i64* %92, align 8, !tbaa !21
  %94 = sitofp i64 %93 to double
  br label %95

; <label>:95:                                     ; preds = %88, %91
  %96 = phi double [ %90, %88 ], [ %94, %91 ]
  %97 = tail call fastcc double @numarith(i32 %1, double %85, double %96)
  %98 = bitcast %struct.TValue* %4 to double*
  store double %97, double* %98, align 8, !tbaa !21
  %99 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %99, align 8, !tbaa !22
  br label %100

; <label>:100:                                    ; preds = %64, %73, %95, %84, %59, %48, %38, %36
  %101 = phi i32 [ %37, %36 ], [ 1, %59 ], [ 0, %48 ], [ 0, %38 ], [ 1, %73 ], [ 1, %95 ], [ 0, %84 ], [ 0, %64 ]
  ret i32 %101
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @intarith(%struct.lua_State*, i32, i64, i64) unnamed_addr #0 {
  switch i32 %1, label %30 [
    i32 0, label %5
    i32 1, label %7
    i32 2, label %9
    i32 3, label %11
    i32 6, label %13
    i32 7, label %15
    i32 8, label %17
    i32 9, label %19
    i32 10, label %21
    i32 11, label %23
    i32 12, label %26
    i32 13, label %28
  ]

; <label>:5:                                      ; preds = %4
  %6 = add i64 %3, %2
  br label %30

; <label>:7:                                      ; preds = %4
  %8 = sub i64 %2, %3
  br label %30

; <label>:9:                                      ; preds = %4
  %10 = mul i64 %3, %2
  br label %30

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %2, i64 %3)
  br label %30

; <label>:13:                                     ; preds = %4
  %14 = tail call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %2, i64 %3)
  br label %30

; <label>:15:                                     ; preds = %4
  %16 = and i64 %3, %2
  br label %30

; <label>:17:                                     ; preds = %4
  %18 = or i64 %3, %2
  br label %30

; <label>:19:                                     ; preds = %4
  %20 = xor i64 %3, %2
  br label %30

; <label>:21:                                     ; preds = %4
  %22 = tail call fastcc i64 @luaV_shiftl(i64 %2, i64 %3)
  br label %30

; <label>:23:                                     ; preds = %4
  %24 = sub nsw i64 0, %3
  %25 = tail call fastcc i64 @luaV_shiftl(i64 %2, i64 %24)
  br label %30

; <label>:26:                                     ; preds = %4
  %27 = sub i64 0, %2
  br label %30

; <label>:28:                                     ; preds = %4
  %29 = xor i64 %2, -1
  br label %30

; <label>:30:                                     ; preds = %4, %28, %26, %23, %21, %19, %17, %15, %13, %11, %9, %7, %5
  %31 = phi i64 [ %29, %28 ], [ %27, %26 ], [ %25, %23 ], [ %22, %21 ], [ %20, %19 ], [ %18, %17 ], [ %16, %15 ], [ %14, %13 ], [ %12, %11 ], [ %10, %9 ], [ %8, %7 ], [ %6, %5 ], [ 0, %4 ]
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define internal fastcc double @numarith(i32, double, double) unnamed_addr #0 {
  switch i32 %0, label %21 [
    i32 0, label %4
    i32 1, label %6
    i32 2, label %8
    i32 5, label %10
    i32 4, label %12
    i32 6, label %14
    i32 12, label %17
    i32 3, label %19
  ]

; <label>:4:                                      ; preds = %3
  %5 = fadd double %1, %2
  br label %21

; <label>:6:                                      ; preds = %3
  %7 = fsub double %1, %2
  br label %21

; <label>:8:                                      ; preds = %3
  %9 = fmul double %1, %2
  br label %21

; <label>:10:                                     ; preds = %3
  %11 = fdiv double %1, %2
  br label %21

; <label>:12:                                     ; preds = %3
  %13 = tail call double @pow(double %1, double %2) #7
  br label %21

; <label>:14:                                     ; preds = %3
  %15 = fdiv double %1, %2
  %16 = tail call double @llvm.floor.f64(double %15)
  br label %21

; <label>:17:                                     ; preds = %3
  %18 = fsub double -0.000000e+00, %1
  br label %21

; <label>:19:                                     ; preds = %3
  %20 = tail call fastcc double @luaV_modf(double %1, double %2)
  br label %21

; <label>:21:                                     ; preds = %3, %19, %17, %14, %12, %10, %8, %6, %4
  %22 = phi double [ %20, %19 ], [ %18, %17 ], [ %16, %14 ], [ %13, %12 ], [ %11, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ 0.000000e+00, %3 ]
  ret double %22
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @l_str2int(i8*, i64* nocapture) unnamed_addr #2 {
  %3 = alloca i8*, align 8
  br label %4

; <label>:4:                                      ; preds = %4, %2
  %5 = phi i8* [ %0, %2 ], [ %13, %4 ]
  store i8* %5, i8** %3, align 8, !tbaa !79
  %6 = load i8, i8* %5, align 1, !tbaa !21
  %7 = zext i8 %6 to i64
  %8 = add nuw nsw i64 %7, 1
  %9 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %8
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = and i8 %10, 8
  %12 = icmp eq i8 %11, 0
  %13 = getelementptr inbounds i8, i8* %5, i64 1
  br i1 %12, label %14, label %4

; <label>:14:                                     ; preds = %4
  %15 = call fastcc i32 @isneg(i8** nonnull %3)
  %16 = load i8*, i8** %3, align 8, !tbaa !79
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 48
  br i1 %18, label %19, label %49

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds i8, i8* %16, i64 1
  %21 = load i8, i8* %20, align 1, !tbaa !21
  switch i8 %21, label %49 [
    i8 120, label %22
    i8 88, label %22
  ]

; <label>:22:                                     ; preds = %19, %19
  %23 = getelementptr inbounds i8, i8* %16, i64 2
  store i8* %23, i8** %3, align 8, !tbaa !79
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = zext i8 %24 to i64
  %26 = add nuw nsw i64 %25, 1
  %27 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %26
  %28 = load i8, i8* %27, align 1, !tbaa !21
  %29 = and i8 %28, 16
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %80, label %31

; <label>:31:                                     ; preds = %22
  br label %32

; <label>:32:                                     ; preds = %31, %32
  %33 = phi i8 [ %42, %32 ], [ %24, %31 ]
  %34 = phi i64 [ %40, %32 ], [ 0, %31 ]
  %35 = phi i8* [ %41, %32 ], [ %23, %31 ]
  %36 = shl i64 %34, 4
  %37 = sext i8 %33 to i32
  %38 = tail call fastcc i32 @luaO_hexavalue(i32 %37)
  %39 = sext i32 %38 to i64
  %40 = add i64 %36, %39
  %41 = getelementptr inbounds i8, i8* %35, i64 1
  store i8* %41, i8** %3, align 8, !tbaa !79
  %42 = load i8, i8* %41, align 1, !tbaa !21
  %43 = zext i8 %42 to i64
  %44 = add nuw nsw i64 %43, 1
  %45 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %44
  %46 = load i8, i8* %45, align 1, !tbaa !21
  %47 = and i8 %46, 16
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %80, label %32

; <label>:49:                                     ; preds = %19, %14
  %50 = load i8*, i8** %3, align 8, !tbaa !79
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = zext i8 %51 to i64
  %53 = add nsw i64 %52, -48
  %54 = icmp ult i64 %53, 10
  br i1 %54, label %55, label %80

; <label>:55:                                     ; preds = %49
  %56 = add nsw i32 %15, 7
  %57 = load i8*, i8** %3, align 8, !tbaa !79
  br label %58

; <label>:58:                                     ; preds = %55, %70
  %59 = phi i8* [ %57, %55 ], [ %74, %70 ]
  %60 = phi i8 [ %51, %55 ], [ %75, %70 ]
  %61 = phi i8* [ %50, %55 ], [ %74, %70 ]
  %62 = phi i64 [ 0, %55 ], [ %73, %70 ]
  %63 = sext i8 %60 to i32
  %64 = add nsw i32 %63, -48
  %65 = icmp ugt i64 %62, 922337203685477579
  br i1 %65, label %66, label %70

; <label>:66:                                     ; preds = %58
  %67 = icmp ne i64 %62, 922337203685477580
  %68 = icmp sgt i32 %64, %56
  %69 = or i1 %67, %68
  br i1 %69, label %113, label %70

; <label>:70:                                     ; preds = %58, %66
  %71 = mul i64 %62, 10
  %72 = sext i32 %64 to i64
  %73 = add i64 %71, %72
  %74 = getelementptr inbounds i8, i8* %61, i64 1
  %75 = load i8, i8* %74, align 1, !tbaa !21
  %76 = zext i8 %75 to i64
  %77 = add nsw i64 %76, -48
  %78 = icmp ult i64 %77, 10
  br i1 %78, label %58, label %79

; <label>:79:                                     ; preds = %70
  store i8* %74, i8** %3, align 8, !tbaa !79
  br label %80

; <label>:80:                                     ; preds = %32, %22, %49, %79
  %81 = phi i32 [ 0, %79 ], [ 1, %49 ], [ 1, %22 ], [ 0, %32 ]
  %82 = phi i64 [ %73, %79 ], [ 0, %49 ], [ 0, %22 ], [ %40, %32 ]
  %83 = load i8*, i8** %3, align 8, !tbaa !79
  %84 = load i8, i8* %83, align 1, !tbaa !21
  %85 = zext i8 %84 to i64
  %86 = add nuw nsw i64 %85, 1
  %87 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %86
  %88 = load i8, i8* %87, align 1, !tbaa !21
  %89 = and i8 %88, 8
  %90 = icmp eq i8 %89, 0
  br i1 %90, label %103, label %91

; <label>:91:                                     ; preds = %80
  br label %92

; <label>:92:                                     ; preds = %91, %92
  %93 = phi i8* [ %94, %92 ], [ %83, %91 ]
  %94 = getelementptr inbounds i8, i8* %93, i64 1
  %95 = load i8, i8* %94, align 1, !tbaa !21
  %96 = zext i8 %95 to i64
  %97 = add nuw nsw i64 %96, 1
  %98 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %97
  %99 = load i8, i8* %98, align 1, !tbaa !21
  %100 = and i8 %99, 8
  %101 = icmp eq i8 %100, 0
  br i1 %101, label %102, label %92

; <label>:102:                                    ; preds = %92
  store i8* %94, i8** %3, align 8, !tbaa !79
  br label %103

; <label>:103:                                    ; preds = %102, %80
  %104 = phi i8* [ %94, %102 ], [ %83, %80 ]
  %105 = phi i8 [ %95, %102 ], [ %84, %80 ]
  %106 = icmp eq i32 %81, 0
  %107 = icmp eq i8 %105, 0
  %108 = and i1 %106, %107
  br i1 %108, label %109, label %114

; <label>:109:                                    ; preds = %103
  %110 = icmp eq i32 %15, 0
  %111 = sub i64 0, %82
  %112 = select i1 %110, i64 %82, i64 %111
  store i64 %112, i64* %1, align 8, !tbaa !109
  br label %114

; <label>:113:                                    ; preds = %66
  store i8* %59, i8** %3, align 8, !tbaa !79
  br label %114

; <label>:114:                                    ; preds = %113, %103, %109
  %115 = phi i8* [ %104, %109 ], [ null, %103 ], [ null, %113 ]
  ret i8* %115
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @l_str2d(i8*, double* nocapture) unnamed_addr #0 {
  %3 = alloca [201 x i8], align 16
  %4 = tail call i8* @strpbrk(i8* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.188, i64 0, i64 0)) #19
  %5 = icmp eq i8* %4, null
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %2
  %7 = load i8, i8* %4, align 1, !tbaa !21
  %8 = or i8 %7, 32
  %9 = icmp eq i8 %8, 110
  br i1 %9, label %38, label %10

; <label>:10:                                     ; preds = %2, %6
  %11 = tail call fastcc i8* @l_str2dloc(i8* %0, double* %1)
  %12 = icmp eq i8* %11, null
  br i1 %12, label %13, label %38

; <label>:13:                                     ; preds = %10
  %14 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 201, i8* nonnull %14) #7
  %15 = tail call i8* @strchr(i8* %0, i32 46) #19
  %16 = tail call i64 @strlen(i8* %0) #19
  %17 = icmp ugt i64 %16, 200
  %18 = icmp eq i8* %15, null
  %19 = or i1 %18, %17
  br i1 %19, label %37, label %20

; <label>:20:                                     ; preds = %13
  %21 = call i8* @strcpy(i8* nonnull %14, i8* %0) #7
  %22 = call %struct.lconv* @localeconv() #7
  %23 = getelementptr inbounds %struct.lconv, %struct.lconv* %22, i64 0, i32 0
  %24 = load i8*, i8** %23, align 8, !tbaa !239
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = ptrtoint i8* %15 to i64
  %27 = ptrtoint i8* %0 to i64
  %28 = sub i64 %26, %27
  %29 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 %28
  store i8 %25, i8* %29, align 1, !tbaa !21
  %30 = call fastcc i8* @l_str2dloc(i8* nonnull %14, double* %1)
  %31 = icmp eq i8* %30, null
  %32 = ptrtoint i8* %30 to i64
  %33 = ptrtoint [201 x i8]* %3 to i64
  %34 = sub i64 %32, %33
  %35 = getelementptr inbounds i8, i8* %0, i64 %34
  %36 = select i1 %31, i8* null, i8* %35
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %14) #7
  br label %38

; <label>:37:                                     ; preds = %13
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %14) #7
  br label %38

; <label>:38:                                     ; preds = %10, %20, %37, %6
  %39 = phi i8* [ null, %37 ], [ null, %6 ], [ %11, %10 ], [ %36, %20 ]
  ret i8* %39
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @isneg(i8** nocapture) unnamed_addr #2 {
  %2 = load i8*, i8** %0, align 8, !tbaa !79
  %3 = load i8, i8* %2, align 1, !tbaa !21
  switch i8 %3, label %8 [
    i8 45, label %5
    i8 43, label %4
  ]

; <label>:4:                                      ; preds = %1
  br label %5

; <label>:5:                                      ; preds = %1, %4
  %6 = phi i32 [ 0, %4 ], [ 1, %1 ]
  %7 = getelementptr inbounds i8, i8* %2, i64 1
  store i8* %7, i8** %0, align 8, !tbaa !79
  br label %8

; <label>:8:                                      ; preds = %5, %1
  %9 = phi i32 [ 0, %1 ], [ %6, %5 ]
  ret i32 %9
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @luaO_hexavalue(i32) unnamed_addr #6 {
  %2 = add nsw i32 %0, 1
  %3 = sext i32 %2 to i64
  %4 = add nsw i64 %3, -49
  %5 = icmp ult i64 %4, 10
  %6 = add nsw i32 %0, -48
  %7 = or i32 %0, 32
  %8 = add nsw i32 %7, -87
  %9 = select i1 %5, i32 %6, i32 %8
  ret i32 %9
}

; Function Attrs: nounwind readonly
declare i8* @strpbrk(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc i8* @l_str2dloc(i8*, double* nocapture) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call double @strtod(i8* %0, i8** nonnull %3) #7
  store double %5, double* %1, align 8, !tbaa !107
  %6 = load i8*, i8** %3, align 8, !tbaa !79
  %7 = icmp eq i8* %6, %0
  br i1 %7, label %34, label %8

; <label>:8:                                      ; preds = %2
  %9 = load i8*, i8** %3, align 8, !tbaa !79
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = zext i8 %10 to i64
  %12 = add nuw nsw i64 %11, 1
  %13 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %12
  %14 = load i8, i8* %13, align 1, !tbaa !21
  %15 = and i8 %14, 8
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %29, label %17

; <label>:17:                                     ; preds = %8
  br label %18

; <label>:18:                                     ; preds = %17, %18
  %19 = phi i8* [ %20, %18 ], [ %9, %17 ]
  %20 = getelementptr inbounds i8, i8* %19, i64 1
  %21 = load i8, i8* %20, align 1, !tbaa !21
  %22 = zext i8 %21 to i64
  %23 = add nuw nsw i64 %22, 1
  %24 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %23
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = and i8 %25, 8
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %18

; <label>:28:                                     ; preds = %18
  store i8* %20, i8** %3, align 8, !tbaa !79
  br label %29

; <label>:29:                                     ; preds = %28, %8
  %30 = phi i8* [ %20, %28 ], [ %9, %8 ]
  %31 = phi i8 [ %21, %28 ], [ %10, %8 ]
  %32 = icmp eq i8 %31, 0
  %33 = select i1 %32, i8* %30, i8* null
  br label %34

; <label>:34:                                     ; preds = %2, %29
  %35 = phi i8* [ %33, %29 ], [ null, %2 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %35
}

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind
declare %struct.lconv* @localeconv() local_unnamed_addr #9

; Function Attrs: nounwind
declare double @strtod(i8* readonly, i8** nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i64 @tostringbuff(%struct.TValue* nocapture readonly, i8* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %11

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %8) #7
  %10 = sext i32 %9 to i64
  br label %29

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %0 to double*
  %13 = load double, double* %12, align 8, !tbaa !21
  %14 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %13) #7
  %15 = sext i32 %14 to i64
  %16 = tail call i64 @strspn(i8* %1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.191, i64 0, i64 0)) #19
  %17 = getelementptr inbounds i8, i8* %1, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %29

; <label>:20:                                     ; preds = %11
  %21 = tail call %struct.lconv* @localeconv() #7
  %22 = getelementptr inbounds %struct.lconv, %struct.lconv* %21, i64 0, i32 0
  %23 = load i8*, i8** %22, align 8, !tbaa !239
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = add nsw i64 %15, 1
  %26 = getelementptr inbounds i8, i8* %1, i64 %15
  store i8 %24, i8* %26, align 1, !tbaa !21
  %27 = add nsw i64 %15, 2
  %28 = getelementptr inbounds i8, i8* %1, i64 %25
  store i8 48, i8* %28, align 1, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %11, %20, %6
  %30 = phi i64 [ %10, %6 ], [ %27, %20 ], [ %15, %11 ]
  ret i64 %30
}

; Function Attrs: nounwind
declare i32 @snprintf(i8* nocapture, i64, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: nounwind readonly
declare i64 @strspn(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @ispow2realasize(%struct.Table* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !116
  %4 = icmp slt i8 %3, 0
  br i1 %4, label %12, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %7 = load i32, i32* %6, align 4, !tbaa !114
  %8 = add i32 %7, -1
  %9 = and i32 %8, %7
  %10 = icmp eq i32 %9, 0
  %11 = zext i1 %10 to i32
  br label %12

; <label>:12:                                     ; preds = %5, %1
  %13 = phi i32 [ 1, %1 ], [ %11, %5 ]
  ret i32 %13
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @binsearch(%struct.TValue* nocapture readonly, i32, i32) unnamed_addr #3 {
  %4 = sub i32 %2, %1
  %5 = icmp ugt i32 %4, 1
  br i1 %5, label %6, label %22

; <label>:6:                                      ; preds = %3
  br label %7

; <label>:7:                                      ; preds = %6, %7
  %8 = phi i32 [ %19, %7 ], [ %1, %6 ]
  %9 = phi i32 [ %18, %7 ], [ %2, %6 ]
  %10 = add i32 %8, %9
  %11 = lshr i32 %10, 1
  %12 = add nsw i32 %11, -1
  %13 = zext i32 %12 to i64
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 %13, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  %18 = select i1 %17, i32 %11, i32 %9
  %19 = select i1 %17, i32 %8, i32 %11
  %20 = sub i32 %18, %19
  %21 = icmp ugt i32 %20, 1
  br i1 %21, label %7, label %22

; <label>:22:                                     ; preds = %7, %3
  %23 = phi i32 [ %1, %3 ], [ %19, %7 ]
  ret i32 %23
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i64 @hash_search(%struct.Table* nocapture, i64) unnamed_addr #2 {
  %3 = icmp eq i64 %1, 0
  %4 = zext i1 %3 to i64
  %5 = add i64 %4, %1
  br label %6

; <label>:6:                                      ; preds = %9, %2
  %7 = phi i64 [ %5, %2 ], [ %10, %9 ]
  %8 = icmp ult i64 %7, 4611686018427387904
  br i1 %8, label %9, label %16

; <label>:9:                                      ; preds = %6
  %10 = shl i64 %7, 1
  %11 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %10)
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %22, label %6

; <label>:16:                                     ; preds = %6
  %17 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 9223372036854775807)
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %41

; <label>:22:                                     ; preds = %9, %16
  %23 = phi i64 [ 9223372036854775807, %16 ], [ %10, %9 ]
  %24 = sub i64 %23, %7
  %25 = icmp ugt i64 %24, 1
  br i1 %25, label %26, label %41

; <label>:26:                                     ; preds = %22
  br label %27

; <label>:27:                                     ; preds = %26, %27
  %28 = phi i64 [ %38, %27 ], [ %7, %26 ]
  %29 = phi i64 [ %37, %27 ], [ %23, %26 ]
  %30 = add i64 %28, %29
  %31 = lshr i64 %30, 1
  %32 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %31)
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = and i8 %34, 15
  %36 = icmp eq i8 %35, 0
  %37 = select i1 %36, i64 %31, i64 %29
  %38 = select i1 %36, i64 %28, i64 %31
  %39 = sub i64 %37, %38
  %40 = icmp ugt i64 %39, 1
  br i1 %40, label %27, label %41

; <label>:41:                                     ; preds = %27, %22, %16
  %42 = phi i64 [ 9223372036854775807, %16 ], [ %7, %22 ], [ %38, %27 ]
  ret i64 %42
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @internshrstr(%struct.lua_State*, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 6
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 9
  %8 = load i32, i32* %7, align 8, !tbaa !59
  %9 = tail call fastcc i32 @luaS_hash(i8* %1, i64 %2, i32 %8)
  %10 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %6, i64 0, i32 0
  %11 = load %struct.TString**, %struct.TString*** %10, align 8, !tbaa !197
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 6, i32 2
  %13 = load i32, i32* %12, align 4, !tbaa !198
  %14 = add nsw i32 %13, -1
  %15 = and i32 %14, %9
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %struct.TString*, %struct.TString** %11, i64 %16
  %18 = load %struct.TString*, %struct.TString** %17, align 8, !tbaa !21
  %19 = icmp eq %struct.TString* %18, null
  br i1 %19, label %47, label %20

; <label>:20:                                     ; preds = %3
  br label %21

; <label>:21:                                     ; preds = %20, %42
  %22 = phi %struct.TString* [ %45, %42 ], [ %18, %20 ]
  %23 = getelementptr inbounds %struct.TString, %struct.TString* %22, i64 0, i32 4
  %24 = load i8, i8* %23, align 1, !tbaa !232
  %25 = zext i8 %24 to i64
  %26 = icmp eq i64 %25, %2
  br i1 %26, label %27, label %42

; <label>:27:                                     ; preds = %21
  %28 = getelementptr inbounds %struct.TString, %struct.TString* %22, i64 1
  %29 = bitcast %struct.TString* %28 to i8*
  %30 = tail call i32 @memcmp(i8* %1, i8* nonnull %29, i64 %2) #19
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %42

; <label>:32:                                     ; preds = %27
  %33 = getelementptr inbounds %struct.TString, %struct.TString* %22, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !227
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %36 = load i8, i8* %35, align 4, !tbaa !15
  %37 = xor i8 %36, 24
  %38 = and i8 %37, %34
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %70, label %40

; <label>:40:                                     ; preds = %32
  %41 = xor i8 %34, 24
  store i8 %41, i8* %33, align 1, !tbaa !227
  br label %70

; <label>:42:                                     ; preds = %21, %27
  %43 = getelementptr inbounds %struct.TString, %struct.TString* %22, i64 0, i32 6
  %44 = bitcast %union.anon* %43 to %struct.TString**
  %45 = load %struct.TString*, %struct.TString** %44, align 8, !tbaa !21
  %46 = icmp eq %struct.TString* %45, null
  br i1 %46, label %47, label %21

; <label>:47:                                     ; preds = %42, %3
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 6, i32 1
  %49 = load i32, i32* %48, align 8, !tbaa !214
  %50 = icmp slt i32 %49, %13
  br i1 %50, label %58, label %51

; <label>:51:                                     ; preds = %47
  tail call fastcc void @growstrtab(%struct.lua_State* %0, %struct.stringtable* nonnull %6)
  %52 = load %struct.TString**, %struct.TString*** %10, align 8, !tbaa !197
  %53 = load i32, i32* %12, align 4, !tbaa !198
  %54 = add nsw i32 %53, -1
  %55 = and i32 %54, %9
  %56 = sext i32 %55 to i64
  %57 = getelementptr inbounds %struct.TString*, %struct.TString** %52, i64 %56
  br label %58

; <label>:58:                                     ; preds = %47, %51
  %59 = phi %struct.TString** [ %57, %51 ], [ %17, %47 ]
  %60 = tail call fastcc %struct.TString* @createstrobj(%struct.lua_State* %0, i64 %2, i32 20, i32 %9)
  %61 = getelementptr inbounds %struct.TString, %struct.TString* %60, i64 1
  %62 = bitcast %struct.TString* %61 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %62, i8* %1, i64 %2, i32 1, i1 false)
  %63 = trunc i64 %2 to i8
  %64 = getelementptr inbounds %struct.TString, %struct.TString* %60, i64 0, i32 4
  store i8 %63, i8* %64, align 1, !tbaa !232
  %65 = bitcast %struct.TString** %59 to i64*
  %66 = load i64, i64* %65, align 8, !tbaa !79
  %67 = getelementptr inbounds %struct.TString, %struct.TString* %60, i64 0, i32 6, i32 0
  store i64 %66, i64* %67, align 8, !tbaa !21
  store %struct.TString* %60, %struct.TString** %59, align 8, !tbaa !79
  %68 = load i32, i32* %48, align 8, !tbaa !214
  %69 = add nsw i32 %68, 1
  store i32 %69, i32* %48, align 8, !tbaa !214
  br label %70

; <label>:70:                                     ; preds = %40, %32, %58
  %71 = phi %struct.TString* [ %60, %58 ], [ %22, %32 ], [ %22, %40 ]
  ret %struct.TString* %71
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaM_toobig(%struct.lua_State*) unnamed_addr #5 {
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.192, i64 0, i64 0)) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State*, i64) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 9
  %6 = load i32, i32* %5, align 8, !tbaa !59
  %7 = tail call fastcc %struct.TString* @createstrobj(%struct.lua_State* %0, i64 %1, i32 36, i32 %6)
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 6, i32 0
  store i64 %1, i64* %8, align 8, !tbaa !21
  ret %struct.TString* %7
}

; Function Attrs: nounwind uwtable
define internal fastcc void @growstrtab(%struct.lua_State*, %struct.stringtable* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %1, i64 0, i32 1
  %4 = load i32, i32* %3, align 8, !tbaa !214
  %5 = icmp eq i32 %4, 2147483647
  br i1 %5, label %6, label %10, !prof !33

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaC_fullgc(%struct.lua_State* %0, i32 1)
  %7 = load i32, i32* %3, align 8, !tbaa !214
  %8 = icmp eq i32 %7, 2147483647
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %6
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #17
  unreachable

; <label>:10:                                     ; preds = %6, %2
  %11 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %1, i64 0, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !198
  %13 = icmp slt i32 %12, 1073741824
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %10
  %15 = shl nsw i32 %12, 1
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %15)
  br label %16

; <label>:16:                                     ; preds = %14, %10
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @createstrobj(%struct.lua_State*, i64, i32, i32) unnamed_addr #0 {
  %5 = add i64 %1, 25
  %6 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 %2, i64 %5)
  %7 = bitcast %struct.GCObject* %6 to %struct.TString*
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 5
  store i32 %3, i32* %8, align 4, !tbaa !200
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %7, i64 0, i32 3
  store i8 0, i8* %9, align 2, !tbaa !199
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %11 = getelementptr inbounds i8, i8* %10, i64 %1
  store i8 0, i8* %11, align 1, !tbaa !21
  ret %struct.TString* %7
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addstr2buff(%struct.BuffFS*, i8*, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 401
  br i1 %4, label %5, label %11

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i8* @getbuff(%struct.BuffFS* %0, i64 %2)
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %6, i8* %1, i64 %2, i32 1, i1 false)
  %7 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %8 = load i32, i32* %7, align 4, !tbaa !118
  %9 = trunc i64 %2 to i32
  %10 = add i32 %8, %9
  store i32 %10, i32* %7, align 4, !tbaa !118
  br label %12

; <label>:11:                                     ; preds = %3
  tail call fastcc void @clearbuff(%struct.BuffFS* %0)
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* %1, i64 %2)
  br label %12

; <label>:12:                                     ; preds = %11, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addnum2buff(%struct.BuffFS*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = tail call fastcc i8* @getbuff(%struct.BuffFS* %0, i64 50)
  %4 = tail call fastcc i64 @tostringbuff(%struct.TValue* %1, i8* nonnull %3)
  %5 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %6 = load i32, i32* %5, align 4, !tbaa !118
  %7 = trunc i64 %4 to i32
  %8 = add i32 %6, %7
  store i32 %8, i32* %5, align 4, !tbaa !118
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc nonnull i8* @getbuff(%struct.BuffFS*, i64) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !118
  %5 = sext i32 %4 to i64
  %6 = sub nsw i64 400, %5
  %7 = icmp ult i64 %6, %1
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %2
  tail call fastcc void @clearbuff(%struct.BuffFS* nonnull %0)
  br label %9

; <label>:9:                                      ; preds = %8, %2
  %10 = load i32, i32* %3, align 4, !tbaa !118
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 %11
  ret i8* %12
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @luaO_utf8esc(i8* nocapture, i64) unnamed_addr #2 {
  %3 = icmp ult i64 %1, 128
  br i1 %3, label %28, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i64 [ %12, %5 ], [ 1, %4 ]
  %7 = phi i64 [ %15, %5 ], [ %1, %4 ]
  %8 = phi i32 [ %16, %5 ], [ 63, %4 ]
  %9 = trunc i64 %7 to i8
  %10 = and i8 %9, 63
  %11 = or i8 %10, -128
  %12 = add nuw i64 %6, 1
  %13 = sub nsw i64 8, %6
  %14 = getelementptr inbounds i8, i8* %0, i64 %13
  store i8 %11, i8* %14, align 1, !tbaa !21
  %15 = lshr i64 %7, 6
  %16 = lshr i32 %8, 1
  %17 = zext i32 %16 to i64
  %18 = icmp ugt i64 %15, %17
  br i1 %18, label %5, label %19

; <label>:19:                                     ; preds = %5
  %20 = trunc i64 %12 to i32
  %21 = and i32 %8, 254
  %22 = xor i32 %21, 254
  %23 = zext i32 %22 to i64
  %24 = or i64 %15, %23
  %25 = shl i64 %6, 32
  %26 = sub i64 30064771072, %25
  %27 = ashr exact i64 %26, 32
  br label %28

; <label>:28:                                     ; preds = %2, %19
  %29 = phi i64 [ %27, %19 ], [ 7, %2 ]
  %30 = phi i64 [ %24, %19 ], [ %1, %2 ]
  %31 = phi i32 [ %20, %19 ], [ 1, %2 ]
  %32 = trunc i64 %30 to i8
  %33 = getelementptr inbounds i8, i8* %0, i64 %29
  store i8 %32, i8* %33, align 1, !tbaa !21
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define internal fastcc void @clearbuff(%struct.BuffFS*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 0
  %3 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !118
  %5 = sext i32 %4 to i64
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* nonnull %2, i64 %5)
  store i32 0, i32* %3, align 4, !tbaa !118
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushstr(%struct.BuffFS* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !121
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2)
  %10 = bitcast %struct.TValue* %8 to %struct.TString**
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !57
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %6, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 1
  %18 = load i32, i32* %17, align 8, !tbaa !120
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* %17, align 8, !tbaa !120
  %20 = icmp sgt i32 %18, 0
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %3
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 3
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 10
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !45
  %25 = icmp ugt %union.StackValue* %22, %24
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %21
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %5, i32 %19)
  store i32 1, i32* %17, align 8, !tbaa !120
  br label %27

; <label>:27:                                     ; preds = %26, %21, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setnodevector(%struct.lua_State*, %struct.Table* nocapture, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  store %union.Node* @dummynode_, %union.Node** %6, align 8, !tbaa !123
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  store i8 0, i8* %7, align 1, !tbaa !124
  br label %35

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc i32 @luaO_ceillog2(i32 %2)
  %10 = icmp sgt i32 %9, 30
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %8
  %12 = shl i32 1, %9
  %13 = icmp ugt i32 %9, 30
  br i1 %13, label %14, label %15

; <label>:14:                                     ; preds = %11, %8
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.199, i64 0, i64 0)) #17
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = zext i32 %12 to i64
  %17 = mul nuw nsw i64 %16, 24
  %18 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %17, i32 0)
  %19 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %20 = bitcast %union.Node** %19 to i8**
  store i8* %18, i8** %20, align 8, !tbaa !123
  %21 = sext i32 %12 to i64
  br label %22

; <label>:22:                                     ; preds = %15, %22
  %23 = phi i64 [ 0, %15 ], [ %28, %22 ]
  %24 = load %union.Node*, %union.Node** %19, align 8, !tbaa !123
  %25 = getelementptr inbounds %union.Node, %union.Node* %24, i64 %23, i32 0, i32 3
  store i32 0, i32* %25, align 4, !tbaa !21
  %26 = getelementptr inbounds %union.Node, %union.Node* %24, i64 %23, i32 0, i32 2
  store i8 0, i8* %26, align 1, !tbaa !21
  %27 = getelementptr inbounds %union.Node, %union.Node* %24, i64 %23, i32 0, i32 1
  store i8 16, i8* %27, align 8, !tbaa !21
  %28 = add nuw nsw i64 %23, 1
  %29 = icmp slt i64 %28, %21
  br i1 %29, label %22, label %30

; <label>:30:                                     ; preds = %22
  %31 = trunc i32 %9 to i8
  %32 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  store i8 %31, i8* %32, align 1, !tbaa !124
  %33 = load %union.Node*, %union.Node** %19, align 8, !tbaa !123
  %34 = getelementptr inbounds %union.Node, %union.Node* %33, i64 %16
  br label %35

; <label>:35:                                     ; preds = %30, %5
  %36 = phi %union.Node* [ %34, %30 ], [ null, %5 ]
  %37 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  store %union.Node* %36, %union.Node** %37, align 8, !tbaa !117
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @luaO_ceillog2(i32) unnamed_addr #6 {
  %2 = add i32 %0, -1
  %3 = icmp ugt i32 %2, 255
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i32 [ %8, %5 ], [ 0, %4 ]
  %7 = phi i32 [ %9, %5 ], [ %2, %4 ]
  %8 = add nuw nsw i32 %6, 8
  %9 = lshr i32 %7, 8
  %10 = icmp ugt i32 %7, 65535
  br i1 %10, label %5, label %11

; <label>:11:                                     ; preds = %5, %1
  %12 = phi i32 [ %2, %1 ], [ %9, %5 ]
  %13 = phi i32 [ 0, %1 ], [ %8, %5 ]
  %14 = zext i32 %12 to i64
  %15 = getelementptr inbounds [256 x i8], [256 x i8]* @luaO_ceillog2.log_2, i64 0, i64 %14
  %16 = load i8, i8* %15, align 1, !tbaa !21
  %17 = zext i8 %16 to i32
  %18 = add nuw nsw i32 %13, %17
  ret i32 %18
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @setlimittosize(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = tail call fastcc i32 @luaH_realasize(%struct.Table* %0)
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  store i32 %2, i32* %3, align 4, !tbaa !114
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %5 = load i8, i8* %4, align 1, !tbaa !116
  %6 = and i8 %5, 127
  store i8 %6, i8* %4, align 1, !tbaa !116
  ret i32 %2
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @exchangehashpart(%struct.Table* nocapture, %struct.Table* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %4 = load i8, i8* %3, align 1, !tbaa !124
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %6 = bitcast %union.Node** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !123
  %8 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 8
  %9 = bitcast %union.Node** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !117
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !124
  store i8 %12, i8* %3, align 1, !tbaa !124
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %14 = bitcast %union.Node** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !123
  store i64 %15, i64* %6, align 8, !tbaa !123
  %16 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %17 = bitcast %union.Node** %16 to i64*
  %18 = load i64, i64* %17, align 8, !tbaa !117
  store i64 %18, i64* %9, align 8, !tbaa !117
  store i8 %4, i8* %11, align 1, !tbaa !124
  store i64 %7, i64* %14, align 8, !tbaa !123
  store i64 %10, i64* %17, align 8, !tbaa !117
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @reinsert(%struct.lua_State*, %struct.Table* nocapture readonly, %struct.Table*) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !124
  %7 = icmp eq i8 %6, 31
  br i1 %7, label %39, label %8

; <label>:8:                                      ; preds = %3
  %9 = zext i8 %6 to i32
  %10 = shl i32 1, %9
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %12 = bitcast %struct.TValue* %4 to i8*
  %13 = bitcast %struct.TValue* %4 to i64*
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %15 = sext i32 %10 to i64
  br label %16

; <label>:16:                                     ; preds = %8, %36
  %17 = phi i64 [ 0, %8 ], [ %37, %36 ]
  %18 = load %union.Node*, %union.Node** %11, align 8, !tbaa !123
  %19 = getelementptr inbounds %union.Node, %union.Node* %18, i64 %17, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !21
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %36, label %23

; <label>:23:                                     ; preds = %16
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %12) #7
  %24 = getelementptr inbounds %union.Node, %union.Node* %18, i64 %17, i32 0, i32 4
  %25 = bitcast %union.Value* %24 to i64*
  %26 = load i64, i64* %25, align 8
  store i64 %26, i64* %13, align 8
  %27 = getelementptr inbounds %union.Node, %union.Node* %18, i64 %17, i32 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !21
  store i8 %28, i8* %14, align 8, !tbaa !22
  %29 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %2, %struct.TValue* nonnull %4)
  %30 = getelementptr inbounds %union.Node, %union.Node* %18, i64 %17, i32 0, i32 0
  %31 = bitcast %union.Value* %30 to i64*
  %32 = bitcast %struct.TValue* %29 to i64*
  %33 = load i64, i64* %31, align 8
  store i64 %33, i64* %32, align 8
  %34 = load i8, i8* %19, align 8, !tbaa !22
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %29, i64 0, i32 1
  store i8 %34, i8* %35, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %12) #7
  br label %36

; <label>:36:                                     ; preds = %23, %16
  %37 = add nuw nsw i64 %17, 1
  %38 = icmp slt i64 %37, %15
  br i1 %38, label %16, label %39

; <label>:39:                                     ; preds = %36, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TValue* @luaH_newkey(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = alloca i64, align 8
  %6 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %12, !prof !33

; <label>:11:                                     ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.201, i64 0, i64 0)) #17
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = icmp eq i8 %8, 19
  br i1 %13, label %14, label %29

; <label>:14:                                     ; preds = %12
  %15 = bitcast %struct.TValue* %2 to double*
  %16 = load double, double* %15, align 8, !tbaa !21
  %17 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %17) #7
  %18 = call fastcc i32 @luaV_flttointeger(double %16, i64* nonnull %5, i32 0)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %24, label %20

; <label>:20:                                     ; preds = %14
  %21 = load i64, i64* %5, align 8, !tbaa !109
  %22 = bitcast %struct.TValue* %4 to i64*
  store i64 %21, i64* %22, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %23, align 8, !tbaa !22
  br label %27

; <label>:24:                                     ; preds = %14
  %25 = fcmp uno double %16, 0.000000e+00
  br i1 %25, label %26, label %27, !prof !33

; <label>:26:                                     ; preds = %24
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.202, i64 0, i64 0)) #17
  unreachable

; <label>:27:                                     ; preds = %24, %20
  %28 = phi %struct.TValue* [ %4, %20 ], [ %2, %24 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %17) #7
  br label %29

; <label>:29:                                     ; preds = %12, %27
  %30 = phi %struct.TValue* [ %28, %27 ], [ %2, %12 ]
  %31 = call fastcc %union.Node* @mainpositionTV(%struct.Table* %1, %struct.TValue* nonnull %30)
  %32 = getelementptr inbounds %union.Node, %union.Node* %31, i64 0, i32 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !21
  %34 = and i8 %33, 15
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %40

; <label>:36:                                     ; preds = %29
  %37 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %38 = load %union.Node*, %union.Node** %37, align 8, !tbaa !117
  %39 = icmp eq %union.Node* %38, null
  br i1 %39, label %40, label %100

; <label>:40:                                     ; preds = %36, %29
  %41 = tail call fastcc %union.Node* @getfreepos(%struct.Table* %1)
  %42 = icmp eq %union.Node* %41, null
  br i1 %42, label %98, label %43

; <label>:43:                                     ; preds = %40
  %44 = getelementptr inbounds %union.Node, %union.Node* %31, i64 0, i32 0, i32 2
  %45 = load i8, i8* %44, align 1, !tbaa !21
  %46 = zext i8 %45 to i32
  %47 = getelementptr inbounds %union.Node, %union.Node* %31, i64 0, i32 0, i32 4
  %48 = tail call fastcc %union.Node* @mainposition(%struct.Table* %1, i32 %46, %union.Value* nonnull %47)
  %49 = icmp eq %union.Node* %48, %31
  br i1 %49, label %79, label %50

; <label>:50:                                     ; preds = %43
  br label %51

; <label>:51:                                     ; preds = %50, %51
  %52 = phi %union.Node* [ %56, %51 ], [ %48, %50 ]
  %53 = getelementptr inbounds %union.Node, %union.Node* %52, i64 0, i32 0, i32 3
  %54 = load i32, i32* %53, align 4, !tbaa !21
  %55 = sext i32 %54 to i64
  %56 = getelementptr inbounds %union.Node, %union.Node* %52, i64 %55
  %57 = icmp eq %union.Node* %56, %31
  br i1 %57, label %58, label %51

; <label>:58:                                     ; preds = %51
  %59 = getelementptr inbounds %union.Node, %union.Node* %52, i64 0, i32 0, i32 3
  %60 = ptrtoint %union.Node* %41 to i64
  %61 = ptrtoint %union.Node* %52 to i64
  %62 = sub i64 %60, %61
  %63 = sdiv exact i64 %62, 24
  %64 = trunc i64 %63 to i32
  store i32 %64, i32* %59, align 4, !tbaa !21
  %65 = bitcast %union.Node* %41 to i8*
  %66 = bitcast %union.Node* %31 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 24, i32 8, i1 false), !tbaa.struct !241
  %67 = getelementptr inbounds %union.Node, %union.Node* %31, i64 0, i32 0, i32 3
  %68 = load i32, i32* %67, align 4, !tbaa !21
  %69 = icmp eq i32 %68, 0
  br i1 %69, label %78, label %70

; <label>:70:                                     ; preds = %58
  %71 = ptrtoint %union.Node* %31 to i64
  %72 = sub i64 %71, %60
  %73 = sdiv exact i64 %72, 24
  %74 = trunc i64 %73 to i32
  %75 = getelementptr inbounds %union.Node, %union.Node* %41, i64 0, i32 0, i32 3
  %76 = load i32, i32* %75, align 4, !tbaa !21
  %77 = add nsw i32 %76, %74
  store i32 %77, i32* %75, align 4, !tbaa !21
  store i32 0, i32* %67, align 4, !tbaa !21
  br label %78

; <label>:78:                                     ; preds = %58, %70
  store i8 16, i8* %32, align 8, !tbaa !21
  br label %100

; <label>:79:                                     ; preds = %43
  %80 = getelementptr inbounds %union.Node, %union.Node* %31, i64 0, i32 0, i32 3
  %81 = load i32, i32* %80, align 4, !tbaa !21
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %92, label %83

; <label>:83:                                     ; preds = %79
  %84 = sext i32 %81 to i64
  %85 = getelementptr inbounds %union.Node, %union.Node* %31, i64 %84
  %86 = ptrtoint %union.Node* %85 to i64
  %87 = ptrtoint %union.Node* %41 to i64
  %88 = sub i64 %86, %87
  %89 = sdiv exact i64 %88, 24
  %90 = trunc i64 %89 to i32
  %91 = getelementptr inbounds %union.Node, %union.Node* %41, i64 0, i32 0, i32 3
  store i32 %90, i32* %91, align 4, !tbaa !21
  br label %92

; <label>:92:                                     ; preds = %79, %83
  %93 = ptrtoint %union.Node* %41 to i64
  %94 = ptrtoint %union.Node* %31 to i64
  %95 = sub i64 %93, %94
  %96 = sdiv exact i64 %95, 24
  %97 = trunc i64 %96 to i32
  store i32 %97, i32* %80, align 4, !tbaa !21
  br label %100

; <label>:98:                                     ; preds = %40
  call fastcc void @rehash(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %30)
  %99 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %30)
  br label %128

; <label>:100:                                    ; preds = %78, %92, %36
  %101 = phi %union.Node* [ %31, %36 ], [ %41, %92 ], [ %31, %78 ]
  %102 = getelementptr inbounds %union.Node, %union.Node* %101, i64 0, i32 0, i32 4
  %103 = bitcast %struct.TValue* %30 to i64*
  %104 = bitcast %union.Value* %102 to i64*
  %105 = load i64, i64* %103, align 8
  store i64 %105, i64* %104, align 8
  %106 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %107 = load i8, i8* %106, align 8, !tbaa !22
  %108 = getelementptr inbounds %union.Node, %union.Node* %101, i64 0, i32 0, i32 2
  store i8 %107, i8* %108, align 1, !tbaa !21
  %109 = load i8, i8* %106, align 8, !tbaa !22
  %110 = and i8 %109, 64
  %111 = icmp eq i8 %110, 0
  br i1 %111, label %126, label %112

; <label>:112:                                    ; preds = %100
  %113 = bitcast %struct.Table* %1 to %struct.GCObject*
  %114 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %115 = load i8, i8* %114, align 1, !tbaa !21
  %116 = and i8 %115, 32
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %126, label %118

; <label>:118:                                    ; preds = %112
  %119 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 0, i32 0
  %120 = load %struct.GCObject*, %struct.GCObject** %119, align 8, !tbaa !21
  %121 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %120, i64 0, i32 2
  %122 = load i8, i8* %121, align 1, !tbaa !53
  %123 = and i8 %122, 24
  %124 = icmp eq i8 %123, 0
  br i1 %124, label %126, label %125

; <label>:125:                                    ; preds = %118
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %113)
  br label %126

; <label>:126:                                    ; preds = %118, %112, %100, %125
  %127 = bitcast %union.Node* %101 to %struct.TValue*
  br label %128

; <label>:128:                                    ; preds = %98, %126
  %129 = phi %struct.TValue* [ %127, %126 ], [ %99, %98 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  ret %struct.TValue* %129
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaT_callTM(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %1 to i64*
  %9 = bitcast %union.StackValue* %7 to i64*
  %10 = load i64, i64* %8, align 8
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0, i32 1
  store i8 %12, i8* %13, align 8, !tbaa !22
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1, i32 0
  %15 = bitcast %struct.TValue* %2 to i64*
  %16 = bitcast %struct.TValue* %14 to i64*
  %17 = load i64, i64* %15, align 8
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1, i32 0, i32 1
  store i8 %19, i8* %20, align 8, !tbaa !22
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 2, i32 0
  %22 = bitcast %struct.TValue* %3 to i64*
  %23 = bitcast %struct.TValue* %21 to i64*
  %24 = load i64, i64* %22, align 8
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 2, i32 0, i32 1
  store i8 %26, i8* %27, align 8, !tbaa !22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 3, i32 0
  %29 = bitcast %struct.TValue* %4 to i64*
  %30 = bitcast %struct.TValue* %28 to i64*
  %31 = load i64, i64* %29, align 8
  store i64 %31, i64* %30, align 8
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 3, i32 0, i32 1
  store i8 %33, i8* %34, align 8, !tbaa !22
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 4
  store %union.StackValue* %35, %union.StackValue** %6, align 8, !tbaa !20
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %37 = load %struct.CallInfo*, %struct.CallInfo** %36, align 8, !tbaa !35
  %38 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %37, i64 0, i32 7
  %39 = load i16, i16* %38, align 2, !tbaa !46
  %40 = and i16 %39, 6
  %41 = icmp eq i16 %40, 0
  br i1 %41, label %42, label %43

; <label>:42:                                     ; preds = %5
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %7, i32 0)
  br label %44

; <label>:43:                                     ; preds = %5
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %7, i32 0)
  br label %44

; <label>:44:                                     ; preds = %43, %42
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %union.Node* @getfreepos(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 8
  %3 = load %union.Node*, %union.Node** %2, align 8, !tbaa !117
  %4 = icmp eq %union.Node* %3, null
  br i1 %4, label %23, label %5

; <label>:5:                                      ; preds = %1
  %6 = load %union.Node*, %union.Node** %2, align 8, !tbaa !117
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %8 = load %union.Node*, %union.Node** %7, align 8, !tbaa !123
  %9 = icmp ugt %union.Node* %6, %8
  br i1 %9, label %10, label %23

; <label>:10:                                     ; preds = %5
  br label %15

; <label>:11:                                     ; preds = %15
  %12 = load %union.Node*, %union.Node** %2, align 8, !tbaa !117
  %13 = load %union.Node*, %union.Node** %7, align 8, !tbaa !123
  %14 = icmp ugt %union.Node* %12, %13
  br i1 %14, label %15, label %23

; <label>:15:                                     ; preds = %10, %11
  %16 = phi %union.Node* [ %12, %11 ], [ %6, %10 ]
  %17 = getelementptr inbounds %union.Node, %union.Node* %16, i64 -1
  store %union.Node* %17, %union.Node** %2, align 8, !tbaa !117
  %18 = getelementptr inbounds %union.Node, %union.Node* %16, i64 -1, i32 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %11

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %union.Node, %union.Node* %16, i64 -1
  br label %23

; <label>:23:                                     ; preds = %11, %5, %21, %1
  %24 = phi %union.Node* [ null, %1 ], [ %22, %21 ], [ null, %5 ], [ null, %11 ]
  ret %union.Node* %24
}

; Function Attrs: nounwind uwtable
define internal fastcc void @rehash(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = alloca [32 x i32], align 16
  %6 = bitcast [32 x i32]* %5 to i8*
  %7 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  call void @llvm.lifetime.start.p0i8(i64 128, i8* nonnull %6) #7
  call void @llvm.memset.p0i8.i64(i8* nonnull %6, i8 0, i64 128, i32 16, i1 false)
  %8 = tail call fastcc i32 @setlimittosize(%struct.Table* %1)
  %9 = getelementptr inbounds [32 x i32], [32 x i32]* %5, i64 0, i64 0
  %10 = call fastcc i32 @numusearray(%struct.Table* %1, i32* nonnull %9)
  store i32 %10, i32* %4, align 4, !tbaa !70
  %11 = call fastcc i32 @numusehash(%struct.Table* %1, i32* nonnull %9, i32* nonnull %4)
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = icmp eq i8 %13, 35
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %3
  %16 = bitcast %struct.TValue* %2 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !21
  %18 = call fastcc i32 @countint(i64 %17, i32* nonnull %9)
  %19 = load i32, i32* %4, align 4, !tbaa !70
  %20 = add i32 %19, %18
  store i32 %20, i32* %4, align 4, !tbaa !70
  br label %21

; <label>:21:                                     ; preds = %15, %3
  %22 = call fastcc i32 @computesizes(i32* nonnull %9, i32* nonnull %4)
  %23 = load i32, i32* %4, align 4, !tbaa !70
  %24 = add i32 %10, 1
  %25 = add i32 %24, %11
  %26 = sub i32 %25, %23
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %1, i32 %22, i32 %26)
  call void @llvm.lifetime.end.p0i8(i64 128, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @numusearray(%struct.Table* nocapture readonly, i32* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %4 = load i32, i32* %3, align 4, !tbaa !114
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  br label %6

; <label>:6:                                      ; preds = %2, %32
  %7 = phi i64 [ 0, %2 ], [ %39, %32 ]
  %8 = phi i32 [ 1, %2 ], [ %33, %32 ]
  %9 = phi i32 [ 0, %2 ], [ %38, %32 ]
  %10 = phi i32 [ 1, %2 ], [ %40, %32 ]
  %11 = icmp ugt i32 %10, %4
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %6
  %13 = icmp ugt i32 %8, %4
  br i1 %13, label %42, label %14

; <label>:14:                                     ; preds = %12, %6
  %15 = phi i32 [ %4, %12 ], [ %10, %6 ]
  %16 = icmp ugt i32 %8, %15
  br i1 %16, label %32, label %17

; <label>:17:                                     ; preds = %14
  %18 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !115
  br label %19

; <label>:19:                                     ; preds = %17, %19
  %20 = phi i32 [ 0, %17 ], [ %29, %19 ]
  %21 = phi i32 [ %8, %17 ], [ %30, %19 ]
  %22 = add i32 %21, -1
  %23 = zext i32 %22 to i64
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 %23, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = and i8 %25, 15
  %27 = icmp ne i8 %26, 0
  %28 = zext i1 %27 to i32
  %29 = add i32 %20, %28
  %30 = add i32 %21, 1
  %31 = icmp ugt i32 %30, %15
  br i1 %31, label %32, label %19

; <label>:32:                                     ; preds = %19, %14
  %33 = phi i32 [ %8, %14 ], [ %30, %19 ]
  %34 = phi i32 [ 0, %14 ], [ %29, %19 ]
  %35 = getelementptr inbounds i32, i32* %1, i64 %7
  %36 = load i32, i32* %35, align 4, !tbaa !70
  %37 = add i32 %36, %34
  store i32 %37, i32* %35, align 4, !tbaa !70
  %38 = add i32 %34, %9
  %39 = add nuw nsw i64 %7, 1
  %40 = shl i32 %10, 1
  %41 = icmp ult i64 %39, 32
  br i1 %41, label %6, label %42

; <label>:42:                                     ; preds = %12, %32
  %43 = phi i32 [ %9, %12 ], [ %38, %32 ]
  ret i32 %43
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @numusehash(%struct.Table* nocapture readonly, i32* nocapture, i32* nocapture) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %5 = load i8, i8* %4, align 1, !tbaa !124
  %6 = zext i8 %5 to i32
  %7 = shl i32 1, %6
  %8 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %9 = sext i32 %7 to i64
  br label %10

; <label>:10:                                     ; preds = %3, %33
  %11 = phi i64 [ %9, %3 ], [ %14, %33 ]
  %12 = phi i32 [ 0, %3 ], [ %35, %33 ]
  %13 = phi i32 [ 0, %3 ], [ %34, %33 ]
  %14 = add nsw i64 %11, -1
  %15 = load %union.Node*, %union.Node** %8, align 8, !tbaa !123
  %16 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %14, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !21
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %33, label %20

; <label>:20:                                     ; preds = %10
  %21 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %14, i32 0, i32 2
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = icmp eq i8 %22, 35
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %20
  %25 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %14, i32 0, i32 4
  %26 = bitcast %union.Value* %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !21
  %28 = tail call fastcc i32 @countint(i64 %27, i32* %1)
  %29 = add nsw i32 %28, %13
  br label %30

; <label>:30:                                     ; preds = %24, %20
  %31 = phi i32 [ %29, %24 ], [ %13, %20 ]
  %32 = add nsw i32 %12, 1
  br label %33

; <label>:33:                                     ; preds = %30, %10
  %34 = phi i32 [ %13, %10 ], [ %31, %30 ]
  %35 = phi i32 [ %12, %10 ], [ %32, %30 ]
  %36 = trunc i64 %14 to i32
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %38, label %10

; <label>:38:                                     ; preds = %33
  %39 = load i32, i32* %2, align 4, !tbaa !70
  %40 = add i32 %39, %34
  store i32 %40, i32* %2, align 4, !tbaa !70
  ret i32 %35
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @countint(i64, i32* nocapture) unnamed_addr #2 {
  %3 = tail call fastcc i32 @arrayindex(i64 %0)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %11, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i32 @luaO_ceillog2(i32 %3)
  %7 = sext i32 %6 to i64
  %8 = getelementptr inbounds i32, i32* %1, i64 %7
  %9 = load i32, i32* %8, align 4, !tbaa !70
  %10 = add i32 %9, 1
  store i32 %10, i32* %8, align 4, !tbaa !70
  br label %11

; <label>:11:                                     ; preds = %2, %5
  %12 = phi i32 [ 1, %5 ], [ 0, %2 ]
  ret i32 %12
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @computesizes(i32* nocapture readonly, i32* nocapture) unnamed_addr #2 {
  %3 = load i32, i32* %1, align 4, !tbaa !70
  br label %4

; <label>:4:                                      ; preds = %2, %12
  %5 = phi i64 [ 0, %2 ], [ %19, %12 ]
  %6 = phi i32 [ 0, %2 ], [ %18, %12 ]
  %7 = phi i32 [ 0, %2 ], [ %17, %12 ]
  %8 = phi i32 [ 0, %2 ], [ %15, %12 ]
  %9 = phi i32 [ 1, %2 ], [ %20, %12 ]
  %10 = lshr i32 %9, 1
  %11 = icmp ugt i32 %3, %10
  br i1 %11, label %12, label %22

; <label>:12:                                     ; preds = %4
  %13 = getelementptr inbounds i32, i32* %0, i64 %5
  %14 = load i32, i32* %13, align 4, !tbaa !70
  %15 = add i32 %14, %8
  %16 = icmp ugt i32 %15, %10
  %17 = select i1 %16, i32 %15, i32 %7
  %18 = select i1 %16, i32 %9, i32 %6
  %19 = add nuw nsw i64 %5, 1
  %20 = shl i32 %9, 1
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %4

; <label>:22:                                     ; preds = %12, %4
  %23 = phi i32 [ %17, %12 ], [ %7, %4 ]
  %24 = phi i32 [ %18, %12 ], [ %6, %4 ]
  store i32 %23, i32* %1, align 4, !tbaa !70
  ret i32 %24
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @arrayindex(i64) unnamed_addr #6 {
  %2 = add i64 %0, -1
  %3 = icmp ult i64 %2, 2147483648
  %4 = trunc i64 %0 to i32
  %5 = select i1 %3, i32 %4, i32 0
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State*) unnamed_addr #0 {
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %0)
  %2 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 64, i32 0)
  %3 = bitcast i8* %2 to %struct.CallInfo*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !35
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 3
  %7 = bitcast %struct.CallInfo** %6 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !89
  %8 = bitcast %struct.CallInfo** %4 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !35
  %10 = getelementptr inbounds i8, i8* %2, i64 16
  %11 = bitcast i8* %10 to i64*
  store i64 %9, i64* %11, align 8, !tbaa !78
  %12 = getelementptr inbounds i8, i8* %2, i64 24
  %13 = bitcast i8* %12 to %struct.CallInfo**
  store %struct.CallInfo* null, %struct.CallInfo** %13, align 8, !tbaa !89
  %14 = getelementptr inbounds i8, i8* %2, i64 40
  %15 = bitcast i8* %14 to i32*
  store i32 0, i32* %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %17 = load i16, i16* %16, align 4, !tbaa !36
  %18 = add i16 %17, 1
  store i16 %18, i16* %16, align 4, !tbaa !36
  ret %struct.CallInfo* %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaE_enterCcall(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !40
  %4 = and i32 %3, 65528
  %5 = add i32 %3, 1
  store i32 %5, i32* %2, align 8, !tbaa !40
  %6 = icmp ugt i32 %4, 2199
  br i1 %6, label %7, label %18

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0)
  %8 = load i32, i32* %2, align 8, !tbaa !40
  %9 = and i32 %8, 65535
  %10 = icmp ugt i32 %9, 2199
  br i1 %10, label %11, label %18

; <label>:11:                                     ; preds = %7
  %12 = icmp ult i32 %9, 2213
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = add i32 %8, 14
  store i32 %14, i32* %2, align 8, !tbaa !40
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0)) #17
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = icmp ugt i32 %9, 2474
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #17
  unreachable

; <label>:18:                                     ; preds = %7, %15, %1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @f_parser(%struct.lua_State*, i8*) #0 {
  %3 = bitcast i8* %1 to %struct.Zio**
  %4 = load %struct.Zio*, %struct.Zio** %3, align 8, !tbaa !144
  %5 = getelementptr inbounds %struct.Zio, %struct.Zio* %4, i64 0, i32 0
  %6 = load i64, i64* %5, align 8, !tbaa !242
  %7 = add i64 %6, -1
  store i64 %7, i64* %5, align 8, !tbaa !242
  %8 = icmp eq i64 %6, 0
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.Zio, %struct.Zio* %4, i64 0, i32 1
  %11 = load i8*, i8** %10, align 8, !tbaa !243
  %12 = getelementptr inbounds i8, i8* %11, i64 1
  store i8* %12, i8** %10, align 8, !tbaa !243
  %13 = load i8, i8* %11, align 1, !tbaa !21
  %14 = zext i8 %13 to i32
  br label %17

; <label>:15:                                     ; preds = %2
  %16 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %4)
  br label %17

; <label>:17:                                     ; preds = %15, %9
  %18 = phi i32 [ %14, %9 ], [ %16, %15 ]
  %19 = icmp eq i32 %18, 27
  %20 = getelementptr inbounds i8, i8* %1, i64 80
  %21 = bitcast i8* %20 to i8**
  %22 = load i8*, i8** %21, align 8, !tbaa !151
  br i1 %19, label %23, label %29

; <label>:23:                                     ; preds = %17
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %22, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.203, i64 0, i64 0))
  %24 = load %struct.Zio*, %struct.Zio** %3, align 8, !tbaa !144
  %25 = getelementptr inbounds i8, i8* %1, i64 88
  %26 = bitcast i8* %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !150
  %28 = tail call fastcc %struct.LClosure* @luaU_undump(%struct.lua_State* %0, %struct.Zio* %24, i8* %27)
  br label %39

; <label>:29:                                     ; preds = %17
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %22, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.204, i64 0, i64 0))
  %30 = load %struct.Zio*, %struct.Zio** %3, align 8, !tbaa !144
  %31 = getelementptr inbounds i8, i8* %1, i64 8
  %32 = bitcast i8* %31 to %struct.Mbuffer*
  %33 = getelementptr inbounds i8, i8* %1, i64 32
  %34 = bitcast i8* %33 to %struct.Dyndata*
  %35 = getelementptr inbounds i8, i8* %1, i64 88
  %36 = bitcast i8* %35 to i8**
  %37 = load i8*, i8** %36, align 8, !tbaa !150
  %38 = tail call fastcc %struct.LClosure* @luaY_parser(%struct.lua_State* %0, %struct.Zio* %30, %struct.Mbuffer* nonnull %32, %struct.Dyndata* nonnull %34, i8* %37, i32 %18)
  br label %39

; <label>:39:                                     ; preds = %29, %23
  %40 = phi %struct.LClosure* [ %28, %23 ], [ %38, %29 ]
  tail call fastcc void @luaF_initupvals(%struct.lua_State* %0, %struct.LClosure* %40)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaM_saferealloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %2, i64 %3)
  %6 = icmp eq i8* %5, null
  %7 = icmp ne i64 %3, 0
  %8 = and i1 %7, %6
  br i1 %8, label %9, label %10, !prof !33

; <label>:9:                                      ; preds = %4
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #17
  unreachable

; <label>:10:                                     ; preds = %4
  ret i8* %5
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaZ_fill(%struct.Zio* nocapture) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 4
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !140
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 2
  %7 = load i8* (%struct.lua_State*, i8*, i64*)*, i8* (%struct.lua_State*, i8*, i64*)** %6, align 8, !tbaa !142
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 3
  %9 = load i8*, i8** %8, align 8, !tbaa !143
  %10 = call i8* %7(%struct.lua_State* %5, i8* %9, i64* nonnull %2) #7
  %11 = icmp eq i8* %10, null
  %12 = load i64, i64* %2, align 8
  %13 = icmp eq i64 %12, 0
  %14 = or i1 %11, %13
  br i1 %14, label %22, label %15

; <label>:15:                                     ; preds = %1
  %16 = add i64 %12, -1
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 0
  store i64 %16, i64* %17, align 8, !tbaa !242
  %18 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 1
  %19 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %19, i8** %18, align 8, !tbaa !243
  %20 = load i8, i8* %10, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %22

; <label>:22:                                     ; preds = %1, %15
  %23 = phi i32 [ %21, %15 ], [ -1, %1 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkmode(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = icmp eq i8* %1, null
  br i1 %4, label %12, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i8, i8* %2, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  %8 = tail call i8* @strchr(i8* nonnull %1, i32 %7) #19
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %5
  %11 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.205, i64 0, i64 0), i8* nonnull %2, i8* nonnull %1)
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 3) #17
  unreachable

; <label>:12:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.LClosure* @luaU_undump(%struct.lua_State*, %struct.Zio*, i8*) unnamed_addr #0 {
  %4 = alloca %struct.LoadState, align 8
  %5 = bitcast %struct.LoadState* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = load i8, i8* %2, align 1, !tbaa !21
  switch i8 %6, label %9 [
    i8 64, label %7
    i8 61, label %7
    i8 27, label %10
  ]

; <label>:7:                                      ; preds = %3, %3
  %8 = getelementptr inbounds i8, i8* %2, i64 1
  br label %10

; <label>:9:                                      ; preds = %3
  br label %10

; <label>:10:                                     ; preds = %3, %9, %7
  %11 = phi i8* [ %2, %9 ], [ %8, %7 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.206, i64 0, i64 0), %3 ]
  %12 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %4, i64 0, i32 2
  store i8* %11, i8** %12, align 8, !tbaa !244
  %13 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %4, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %13, align 8, !tbaa !246
  %14 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %4, i64 0, i32 1
  store %struct.Zio* %1, %struct.Zio** %14, align 8, !tbaa !247
  call fastcc void @checkHeader(%struct.LoadState* nonnull %4)
  %15 = call fastcc zeroext i8 @LoadByte(%struct.LoadState* nonnull %4)
  %16 = zext i8 %15 to i32
  %17 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %16)
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = bitcast %union.StackValue** %18 to %struct.TValue**
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !20
  %21 = bitcast %struct.TValue* %20 to %struct.LClosure**
  store %struct.LClosure* %17, %struct.LClosure** %21, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  store i8 86, i8* %22, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0)
  %23 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %0)
  %24 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %17, i64 0, i32 5
  store %struct.Proto* %23, %struct.Proto** %24, align 8, !tbaa !173
  call fastcc void @LoadFunction(%struct.LoadState* nonnull %4, %struct.Proto* %23, %struct.TString* null)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret %struct.LClosure* %17
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.LClosure* @luaY_parser(%struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Dyndata*, i8*, i32) unnamed_addr #0 {
  %7 = alloca %struct.LexState, align 8
  %8 = alloca %struct.FuncState, align 8
  %9 = bitcast %struct.LexState* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %9) #7
  %10 = bitcast %struct.FuncState* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %10) #7
  %11 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 1)
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to %struct.TValue**
  %14 = load %struct.TValue*, %struct.TValue** %13, align 8, !tbaa !20
  %15 = bitcast %struct.TValue* %14 to %struct.LClosure**
  store %struct.LClosure* %11, %struct.LClosure** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 86, i8* %16, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0)
  %17 = tail call fastcc %struct.Table* @luaH_new(%struct.lua_State* %0)
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %7, i64 0, i32 9
  store %struct.Table* %17, %struct.Table** %18, align 8, !tbaa !248
  %19 = load %struct.TValue*, %struct.TValue** %13, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %19 to %struct.Table**
  store %struct.Table* %17, %struct.Table** %20, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 69, i8* %21, align 8, !tbaa !22
  tail call fastcc void @luaD_inctop(%struct.lua_State* %0)
  %22 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %0)
  %23 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %11, i64 0, i32 5
  store %struct.Proto* %22, %struct.Proto** %23, align 8, !tbaa !173
  %24 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %8, i64 0, i32 0
  store %struct.Proto* %22, %struct.Proto** %24, align 8, !tbaa !251
  %25 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %4)
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %22, i64 0, i32 22
  store %struct.TString* %25, %struct.TString** %26, align 8, !tbaa !104
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %22, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !226
  %29 = and i8 %28, 32
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %39, label %31

; <label>:31:                                     ; preds = %6
  %32 = getelementptr inbounds %struct.TString, %struct.TString* %25, i64 0, i32 2
  %33 = load i8, i8* %32, align 1, !tbaa !227
  %34 = and i8 %33, 24
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %39, label %36

; <label>:36:                                     ; preds = %31
  %37 = bitcast %struct.Proto* %22 to %struct.GCObject*
  %38 = bitcast %struct.TString* %25 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %37, %struct.GCObject* %38)
  br label %39

; <label>:39:                                     ; preds = %31, %6, %36
  %40 = getelementptr inbounds %struct.LexState, %struct.LexState* %7, i64 0, i32 8
  store %struct.Mbuffer* %2, %struct.Mbuffer** %40, align 8, !tbaa !253
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %7, i64 0, i32 10
  store %struct.Dyndata* %3, %struct.Dyndata** %41, align 8, !tbaa !254
  %42 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %3, i64 0, i32 2, i32 1
  store i32 0, i32* %42, align 8, !tbaa !255
  %43 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %3, i64 0, i32 1, i32 1
  store i32 0, i32* %43, align 8, !tbaa !256
  %44 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %3, i64 0, i32 0, i32 1
  store i32 0, i32* %44, align 8, !tbaa !257
  %45 = load %struct.Proto*, %struct.Proto** %24, align 8, !tbaa !251
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %45, i64 0, i32 22
  %47 = load %struct.TString*, %struct.TString** %46, align 8, !tbaa !104
  call fastcc void @luaX_setinput(%struct.lua_State* nonnull %0, %struct.LexState* nonnull %7, %struct.Zio* %1, %struct.TString* %47, i32 %5)
  call fastcc void @mainfunc(%struct.LexState* nonnull %7, %struct.FuncState* nonnull %8)
  %48 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 -1
  store %union.StackValue* %49, %union.StackValue** %12, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %9) #7
  ret %struct.LClosure* %11
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaF_initupvals(%struct.lua_State*, %struct.LClosure* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 3
  %4 = load i8, i8* %3, align 2, !tbaa !138
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %32, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 2
  %8 = bitcast %struct.LClosure* %1 to %struct.GCObject*
  br label %9

; <label>:9:                                      ; preds = %6, %27
  %10 = phi i64 [ 0, %6 ], [ %28, %27 ]
  %11 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 9, i64 40)
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %11, i64 1, i32 1
  %13 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %11, i64 1
  %14 = bitcast %struct.GCObject* %13 to i8**
  store i8* %12, i8** %14, align 8, !tbaa !50
  %15 = getelementptr inbounds i8, i8* %12, i64 8
  store i8 0, i8* %15, align 8, !tbaa !22
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %1, i64 0, i32 6, i64 %10
  %17 = bitcast %struct.UpVal** %16 to %struct.GCObject**
  store %struct.GCObject* %11, %struct.GCObject** %17, align 8, !tbaa !79
  %18 = load i8, i8* %7, align 1, !tbaa !177
  %19 = and i8 %18, 32
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %27, label %21

; <label>:21:                                     ; preds = %9
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %11, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !53
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %21
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* nonnull %8, %struct.GCObject* nonnull %11)
  br label %27

; <label>:27:                                     ; preds = %21, %9, %26
  %28 = add nuw nsw i64 %10, 1
  %29 = load i8, i8* %3, align 2, !tbaa !138
  %30 = zext i8 %29 to i64
  %31 = icmp ult i64 %28, %30
  br i1 %31, label %9, label %32

; <label>:32:                                     ; preds = %27, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkHeader(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  tail call fastcc void @checkliteral(%struct.LoadState* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 1), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.207, i64 0, i64 0))
  %2 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %3 = icmp eq i32 %2, 504
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.208, i64 0, i64 0)) #17
  unreachable

; <label>:5:                                      ; preds = %1
  %6 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.209, i64 0, i64 0)) #17
  unreachable

; <label>:9:                                      ; preds = %5
  tail call fastcc void @checkliteral(%struct.LoadState* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.211, i64 0, i64 0))
  tail call fastcc void @fchecksize(%struct.LoadState* %0, i64 4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.212, i64 0, i64 0))
  tail call fastcc void @fchecksize(%struct.LoadState* %0, i64 8, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.213, i64 0, i64 0))
  tail call fastcc void @fchecksize(%struct.LoadState* %0, i64 8, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.214, i64 0, i64 0))
  %10 = tail call fastcc i64 @LoadInteger(%struct.LoadState* %0)
  %11 = icmp eq i64 %10, 22136
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.215, i64 0, i64 0)) #17
  unreachable

; <label>:13:                                     ; preds = %9
  %14 = tail call fastcc double @LoadNumber(%struct.LoadState* %0)
  %15 = fcmp une double %14, 3.705000e+02
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %13
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.216, i64 0, i64 0)) #17
  unreachable

; <label>:17:                                     ; preds = %13
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc zeroext i8 @LoadByte(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %3 = load %struct.Zio*, %struct.Zio** %2, align 8, !tbaa !247
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 0
  %5 = load i64, i64* %4, align 8, !tbaa !242
  %6 = add i64 %5, -1
  store i64 %6, i64* %4, align 8, !tbaa !242
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !243
  %11 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %11, i8** %9, align 8, !tbaa !243
  %12 = load i8, i8* %10, align 1, !tbaa !21
  %13 = zext i8 %12 to i32
  br label %18

; <label>:14:                                     ; preds = %1
  %15 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %3)
  %16 = icmp eq i32 %15, -1
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  tail call fastcc void @error(%struct.LoadState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #17
  unreachable

; <label>:18:                                     ; preds = %8, %14
  %19 = phi i32 [ %13, %8 ], [ %15, %14 ]
  %20 = trunc i32 %19 to i8
  ret i8 %20
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaD_inctop(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !45
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = sub i64 %4, %7
  %9 = icmp slt i64 %8, 32
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %1
  %11 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 1, i32 1)
  br label %12

; <label>:12:                                     ; preds = %1, %10
  %13 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.Proto* @luaF_newproto(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.GCObject* @luaC_newobj(%struct.lua_State* %0, i32 10, i64 128)
  %3 = bitcast %struct.GCObject* %2 to %struct.Proto*
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 3, i32 1
  %5 = bitcast i8* %4 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %5, align 8, !tbaa !209
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 7
  store i32 0, i32* %6, align 4, !tbaa !210
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2
  %8 = bitcast %struct.GCObject* %7 to i32*
  store i32 0, i32* %8, align 8, !tbaa !208
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 4
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1, i32 1
  %11 = bitcast i8* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !206
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 5, i32 1
  %13 = bitcast i8* %12 to i8**
  store i8* null, i8** %13, align 8, !tbaa !211
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 9
  %15 = bitcast %struct.GCObject* %9 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %15, i8 0, i64 16, i32 8, i1 false)
  store i32 0, i32* %14, align 4, !tbaa !102
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 6
  %17 = bitcast %struct.GCObject* %16 to %struct.AbsLineInfo**
  store %struct.AbsLineInfo* null, %struct.AbsLineInfo** %17, align 8, !tbaa !212
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 2, i32 1
  %19 = bitcast i8* %18 to i32*
  store i32 0, i32* %19, align 8, !tbaa !213
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 5
  %21 = bitcast %struct.GCObject* %20 to %struct.Upvaldesc**
  store %struct.Upvaldesc* null, %struct.Upvaldesc** %21, align 8, !tbaa !174
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 1
  %23 = bitcast %struct.GCObject* %22 to i32*
  store i32 0, i32* %23, align 8, !tbaa !166
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 3
  store i8 0, i8* %24, align 2, !tbaa !95
  %25 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 4
  store i8 0, i8* %25, align 1, !tbaa !94
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 5
  store i8 0, i8* %26, align 4, !tbaa !133
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 6, i32 1
  %28 = bitcast i8* %27 to %struct.LocVar**
  store %struct.LocVar* null, %struct.LocVar** %28, align 8, !tbaa !84
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 11
  store i32 0, i32* %29, align 4, !tbaa !82
  %30 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 13
  store i32 0, i32* %30, align 4, !tbaa !101
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 3
  %32 = bitcast %struct.GCObject* %31 to i32*
  store i32 0, i32* %32, align 8, !tbaa !233
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 7
  %34 = bitcast %struct.GCObject* %33 to %struct.TString**
  store %struct.TString* null, %struct.TString** %34, align 8, !tbaa !104
  ret %struct.Proto* %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadFunction(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture, %struct.TString*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0)
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 22
  %6 = icmp eq %struct.TString* %4, null
  %7 = select i1 %6, %struct.TString* %2, %struct.TString* %4
  store %struct.TString* %7, %struct.TString** %5, align 8, !tbaa !104
  %8 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 13
  store i32 %8, i32* %9, align 4, !tbaa !101
  %10 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 14
  store i32 %10, i32* %11, align 8, !tbaa !233
  %12 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 3
  store i8 %12, i8* %13, align 2, !tbaa !95
  %14 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %15 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 4
  store i8 %14, i8* %15, align 1, !tbaa !94
  %16 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 5
  store i8 %16, i8* %17, align 4, !tbaa !133
  tail call fastcc void @LoadCode(%struct.LoadState* %0, %struct.Proto* %1)
  tail call fastcc void @LoadConstants(%struct.LoadState* %0, %struct.Proto* %1)
  tail call fastcc void @LoadUpvalues(%struct.LoadState* %0, %struct.Proto* %1)
  tail call fastcc void @LoadProtos(%struct.LoadState* %0, %struct.Proto* %1)
  tail call fastcc void @LoadDebug(%struct.LoadState* %0, %struct.Proto* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkliteral(%struct.LoadState* nocapture readonly, i8* nocapture readonly, i8*) unnamed_addr #0 {
  %4 = alloca [12 x i8], align 1
  %5 = getelementptr inbounds [12 x i8], [12 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 12, i8* nonnull %5) #7
  %6 = tail call i64 @strlen(i8* %1) #19
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %5, i64 %6)
  %7 = call i32 @memcmp(i8* %1, i8* nonnull %5, i64 %6) #19
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %3
  tail call fastcc void @error(%struct.LoadState* %0, i8* %2) #17
  unreachable

; <label>:10:                                     ; preds = %3
  call void @llvm.lifetime.end.p0i8(i64 12, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @LoadInt(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647)
  %3 = trunc i64 %2 to i32
  ret i32 %3
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @error(%struct.LoadState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !246
  %5 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 2
  %6 = load i8*, i8** %5, align 8, !tbaa !244
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.219, i64 0, i64 0), i8* %6, i8* %1)
  %8 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !246
  tail call fastcc void @luaD_throw(%struct.lua_State* %8, i32 3) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fchecksize(%struct.LoadState* nocapture readonly, i64, i8*) unnamed_addr #0 {
  %4 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %5 = zext i8 %4 to i64
  %6 = icmp eq i64 %5, %1
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !246
  %10 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.220, i64 0, i64 0), i8* %2)
  tail call fastcc void @error(%struct.LoadState* %0, i8* %10) #17
  unreachable

; <label>:11:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @LoadInteger(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %3, i64 8)
  %4 = load i64, i64* %2, align 8, !tbaa !109
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc double @LoadNumber(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca double, align 8
  %3 = bitcast double* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %3, i64 8)
  %4 = load double, double* %2, align 8, !tbaa !107
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret double %4
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadBlock(%struct.LoadState* nocapture readonly, i8* nocapture, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !247
  %6 = tail call fastcc i64 @luaZ_read(%struct.Zio* %5, i8* %1, i64 %2)
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %3
  tail call fastcc void @error(%struct.LoadState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #17
  unreachable

; <label>:9:                                      ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @luaZ_read(%struct.Zio* nocapture, i8* nocapture, i64) unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %34, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 0
  %7 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 1
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 1
  br label %9

; <label>:9:                                      ; preds = %5, %22
  %10 = phi i64 [ %2, %5 ], [ %32, %22 ]
  %11 = phi i8* [ %1, %5 ], [ %31, %22 ]
  %12 = load i64, i64* %6, align 8, !tbaa !242
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %14, label %22

; <label>:14:                                     ; preds = %9
  %15 = tail call fastcc i32 @luaZ_fill(%struct.Zio* nonnull %0)
  %16 = icmp eq i32 %15, -1
  br i1 %16, label %34, label %17

; <label>:17:                                     ; preds = %14
  %18 = load i64, i64* %6, align 8, !tbaa !242
  %19 = add i64 %18, 1
  store i64 %19, i64* %6, align 8, !tbaa !242
  %20 = load i8*, i8** %8, align 8, !tbaa !243
  %21 = getelementptr inbounds i8, i8* %20, i64 -1
  store i8* %21, i8** %8, align 8, !tbaa !243
  br label %22

; <label>:22:                                     ; preds = %9, %17
  %23 = load i64, i64* %6, align 8, !tbaa !242
  %24 = icmp ugt i64 %10, %23
  %25 = select i1 %24, i64 %23, i64 %10
  %26 = load i8*, i8** %7, align 8, !tbaa !243
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %26, i64 %25, i32 1, i1 false)
  %27 = load i64, i64* %6, align 8, !tbaa !242
  %28 = sub i64 %27, %25
  store i64 %28, i64* %6, align 8, !tbaa !242
  %29 = load i8*, i8** %7, align 8, !tbaa !243
  %30 = getelementptr inbounds i8, i8* %29, i64 %25
  store i8* %30, i8** %7, align 8, !tbaa !243
  %31 = getelementptr inbounds i8, i8* %11, i64 %25
  %32 = sub i64 %10, %25
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %34, label %9

; <label>:34:                                     ; preds = %22, %14, %3
  %35 = phi i64 [ 0, %3 ], [ %10, %14 ], [ 0, %22 ]
  ret i64 %35
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @LoadUnsigned(%struct.LoadState* nocapture readonly, i64) unnamed_addr #0 {
  %3 = lshr i64 %1, 7
  br label %4

; <label>:4:                                      ; preds = %9, %2
  %5 = phi i64 [ 0, %2 ], [ %13, %9 ]
  %6 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %7 = icmp ult i64 %5, %3
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %4
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0)) #17
  unreachable

; <label>:9:                                      ; preds = %4
  %10 = shl i64 %5, 7
  %11 = and i8 %6, 127
  %12 = zext i8 %11 to i64
  %13 = or i64 %10, %12
  %14 = icmp sgt i8 %6, -1
  br i1 %14, label %4, label %15

; <label>:15:                                     ; preds = %9
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @LoadStringN(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca [40 x i8], align 16
  %3 = tail call fastcc i64 @LoadSize(%struct.LoadState* %0)
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %19, label %5

; <label>:5:                                      ; preds = %1
  %6 = add i64 %3, -1
  %7 = icmp ult i64 %6, 41
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %5
  %9 = getelementptr inbounds [40 x i8], [40 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %9) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %9, i64 %6)
  %10 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !246
  %12 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* nonnull %9, i64 %6)
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %9) #7
  br label %19

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !246
  %16 = tail call fastcc %struct.TString* @luaS_createlngstrobj(%struct.lua_State* %15, i64 %6)
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %18, i64 %6)
  br label %19

; <label>:19:                                     ; preds = %1, %13, %8
  %20 = phi %struct.TString* [ %12, %8 ], [ %16, %13 ], [ null, %1 ]
  ret %struct.TString* %20
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadCode(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %6 = sext i32 %3 to i64
  %7 = shl nsw i64 %6, 2
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %5, i64 %7, i32 0)
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 16
  %10 = bitcast i32** %9 to i8**
  store i8* %8, i8** %10, align 8, !tbaa !134
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 8
  store i32 %3, i32* %11, align 8, !tbaa !206
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %8, i64 %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadConstants(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %6 = sext i32 %3 to i64
  %7 = shl nsw i64 %6, 4
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %5, i64 %7, i32 0)
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 15
  %10 = bitcast %struct.TValue** %9 to i8**
  store i8* %8, i8** %10, align 8, !tbaa !209
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 7
  store i32 %3, i32* %11, align 4, !tbaa !210
  %12 = icmp sgt i32 %3, 0
  br i1 %12, label %13, label %52

; <label>:13:                                     ; preds = %2
  %14 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !209
  %15 = zext i32 %3 to i64
  br label %16

; <label>:16:                                     ; preds = %16, %13
  %17 = phi i64 [ 0, %13 ], [ %19, %16 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 %17, i32 1
  store i8 0, i8* %18, align 8, !tbaa !22
  %19 = add nuw nsw i64 %17, 1
  %20 = icmp eq i64 %19, %15
  br i1 %20, label %21, label %16

; <label>:21:                                     ; preds = %16
  %22 = icmp sgt i32 %3, 0
  br i1 %22, label %23, label %52

; <label>:23:                                     ; preds = %21
  %24 = zext i32 %3 to i64
  br label %25

; <label>:25:                                     ; preds = %49, %23
  %26 = phi i64 [ 0, %23 ], [ %50, %49 ]
  %27 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !209
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 %26
  %29 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  switch i8 %29, label %49 [
    i8 0, label %46
    i8 1, label %30
    i8 19, label %34
    i8 35, label %37
    i8 20, label %40
    i8 36, label %40
  ]

; <label>:30:                                     ; preds = %25
  %31 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %32 = zext i8 %31 to i32
  %33 = bitcast %struct.TValue* %28 to i32*
  store i32 %32, i32* %33, align 8, !tbaa !21
  br label %46

; <label>:34:                                     ; preds = %25
  %35 = tail call fastcc double @LoadNumber(%struct.LoadState* %0)
  %36 = bitcast %struct.TValue* %28 to double*
  store double %35, double* %36, align 8, !tbaa !21
  br label %46

; <label>:37:                                     ; preds = %25
  %38 = tail call fastcc i64 @LoadInteger(%struct.LoadState* %0)
  %39 = bitcast %struct.TValue* %28 to i64*
  store i64 %38, i64* %39, align 8, !tbaa !21
  br label %46

; <label>:40:                                     ; preds = %25, %25
  %41 = tail call fastcc %struct.TString* @LoadString(%struct.LoadState* %0)
  %42 = bitcast %struct.TValue* %28 to %struct.TString**
  store %struct.TString* %41, %struct.TString** %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.TString, %struct.TString* %41, i64 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !57
  %45 = or i8 %44, 64
  br label %46

; <label>:46:                                     ; preds = %25, %30, %34, %37, %40
  %47 = phi i8 [ %45, %40 ], [ 35, %37 ], [ 19, %34 ], [ 1, %30 ], [ %29, %25 ]
  %48 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 %26, i32 1
  store i8 %47, i8* %48, align 8, !tbaa !22
  br label %49

; <label>:49:                                     ; preds = %46, %25
  %50 = add nuw nsw i64 %26, 1
  %51 = icmp eq i64 %50, %24
  br i1 %51, label %52, label %25

; <label>:52:                                     ; preds = %49, %2, %21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadUpvalues(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %6 = sext i32 %3 to i64
  %7 = shl nsw i64 %6, 4
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %5, i64 %7, i32 0)
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %10 = bitcast %struct.Upvaldesc** %9 to i8**
  store i8* %8, i8** %10, align 8, !tbaa !174
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  store i32 %3, i32* %11, align 8, !tbaa !166
  %12 = icmp sgt i32 %3, 0
  br i1 %12, label %13, label %35

; <label>:13:                                     ; preds = %2
  %14 = load %struct.Upvaldesc*, %struct.Upvaldesc** %9, align 8, !tbaa !174
  %15 = zext i32 %3 to i64
  br label %16

; <label>:16:                                     ; preds = %16, %13
  %17 = phi i64 [ 0, %13 ], [ %19, %16 ]
  %18 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %14, i64 %17, i32 0
  store %struct.TString* null, %struct.TString** %18, align 8, !tbaa !175
  %19 = add nuw nsw i64 %17, 1
  %20 = icmp eq i64 %19, %15
  br i1 %20, label %21, label %16

; <label>:21:                                     ; preds = %16
  %22 = icmp sgt i32 %3, 0
  br i1 %22, label %23, label %35

; <label>:23:                                     ; preds = %21
  %24 = zext i32 %3 to i64
  br label %25

; <label>:25:                                     ; preds = %25, %23
  %26 = phi i64 [ 0, %23 ], [ %33, %25 ]
  %27 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %28 = load %struct.Upvaldesc*, %struct.Upvaldesc** %9, align 8, !tbaa !174
  %29 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %28, i64 %26, i32 1
  store i8 %27, i8* %29, align 8, !tbaa !236
  %30 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0)
  %31 = load %struct.Upvaldesc*, %struct.Upvaldesc** %9, align 8, !tbaa !174
  %32 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %31, i64 %26, i32 2
  store i8 %30, i8* %32, align 1, !tbaa !237
  %33 = add nuw nsw i64 %26, 1
  %34 = icmp eq i64 %33, %24
  br i1 %34, label %35, label %25

; <label>:35:                                     ; preds = %25, %2, %21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadProtos(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %6 = sext i32 %3 to i64
  %7 = shl nsw i64 %6, 3
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %5, i64 %7, i32 0)
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 17
  %10 = bitcast %struct.Proto*** %9 to i8**
  store i8* %8, i8** %10, align 8, !tbaa !207
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 10
  store i32 %3, i32* %11, align 8, !tbaa !208
  %12 = icmp sgt i32 %3, 0
  br i1 %12, label %13, label %38

; <label>:13:                                     ; preds = %2
  %14 = zext i32 %3 to i64
  br label %15

; <label>:15:                                     ; preds = %15, %13
  %16 = phi i64 [ 0, %13 ], [ %19, %15 ]
  %17 = load %struct.Proto**, %struct.Proto*** %9, align 8, !tbaa !207
  %18 = getelementptr inbounds %struct.Proto*, %struct.Proto** %17, i64 %16
  store %struct.Proto* null, %struct.Proto** %18, align 8, !tbaa !79
  %19 = add nuw nsw i64 %16, 1
  %20 = icmp eq i64 %19, %14
  br i1 %20, label %21, label %15

; <label>:21:                                     ; preds = %15
  %22 = icmp sgt i32 %3, 0
  br i1 %22, label %23, label %38

; <label>:23:                                     ; preds = %21
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 22
  %25 = zext i32 %3 to i64
  br label %26

; <label>:26:                                     ; preds = %26, %23
  %27 = phi i64 [ 0, %23 ], [ %36, %26 ]
  %28 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %29 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %28)
  %30 = load %struct.Proto**, %struct.Proto*** %9, align 8, !tbaa !207
  %31 = getelementptr inbounds %struct.Proto*, %struct.Proto** %30, i64 %27
  store %struct.Proto* %29, %struct.Proto** %31, align 8, !tbaa !79
  %32 = load %struct.Proto**, %struct.Proto*** %9, align 8, !tbaa !207
  %33 = getelementptr inbounds %struct.Proto*, %struct.Proto** %32, i64 %27
  %34 = load %struct.Proto*, %struct.Proto** %33, align 8, !tbaa !79
  %35 = load %struct.TString*, %struct.TString** %24, align 8, !tbaa !104
  tail call fastcc void @LoadFunction(%struct.LoadState* %0, %struct.Proto* %34, %struct.TString* %35)
  %36 = add nuw nsw i64 %27, 1
  %37 = icmp eq i64 %36, %25
  br i1 %37, label %38, label %26

; <label>:38:                                     ; preds = %26, %2, %21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @LoadDebug(%struct.LoadState* nocapture readonly, %struct.Proto* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %6 = sext i32 %3 to i64
  %7 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %5, i64 %6, i32 0)
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  store i8* %7, i8** %8, align 8, !tbaa !211
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  store i32 %3, i32* %9, align 4, !tbaa !102
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %7, i64 %6)
  %10 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %11 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %12 = sext i32 %10 to i64
  %13 = shl nsw i64 %12, 3
  %14 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %11, i64 %13, i32 0)
  %15 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %16 = bitcast %struct.AbsLineInfo** %15 to i8**
  store i8* %14, i8** %16, align 8, !tbaa !212
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  store i32 %10, i32* %17, align 8, !tbaa !213
  %18 = icmp sgt i32 %10, 0
  %19 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  br i1 %18, label %20, label %33

; <label>:20:                                     ; preds = %2
  %21 = zext i32 %10 to i64
  br label %22

; <label>:22:                                     ; preds = %22, %20
  %23 = phi i64 [ 0, %20 ], [ %30, %22 ]
  %24 = phi i32 [ %19, %20 ], [ %31, %22 ]
  %25 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %15, align 8, !tbaa !212
  %26 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %25, i64 %23, i32 0
  store i32 %24, i32* %26, align 4, !tbaa !234
  %27 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %28 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %15, align 8, !tbaa !212
  %29 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %28, i64 %23, i32 1
  store i32 %27, i32* %29, align 4, !tbaa !258
  %30 = add nuw nsw i64 %23, 1
  %31 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %32 = icmp eq i64 %30, %21
  br i1 %32, label %33, label %22

; <label>:33:                                     ; preds = %22, %2
  %34 = phi i32 [ %19, %2 ], [ %31, %22 ]
  %35 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !246
  %36 = sext i32 %34 to i64
  %37 = shl nsw i64 %36, 4
  %38 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %35, i64 %37, i32 0)
  %39 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 21
  %40 = bitcast %struct.LocVar** %39 to i8**
  store i8* %38, i8** %40, align 8, !tbaa !84
  %41 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 11
  store i32 %34, i32* %41, align 4, !tbaa !82
  %42 = icmp sgt i32 %34, 0
  br i1 %42, label %43, label %68

; <label>:43:                                     ; preds = %33
  %44 = load %struct.LocVar*, %struct.LocVar** %39, align 8, !tbaa !84
  %45 = zext i32 %34 to i64
  br label %46

; <label>:46:                                     ; preds = %46, %43
  %47 = phi i64 [ 0, %43 ], [ %49, %46 ]
  %48 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %44, i64 %47, i32 0
  store %struct.TString* null, %struct.TString** %48, align 8, !tbaa !88
  %49 = add nuw nsw i64 %47, 1
  %50 = icmp eq i64 %49, %45
  br i1 %50, label %51, label %46

; <label>:51:                                     ; preds = %46
  %52 = icmp sgt i32 %34, 0
  br i1 %52, label %53, label %68

; <label>:53:                                     ; preds = %51
  %54 = zext i32 %34 to i64
  br label %55

; <label>:55:                                     ; preds = %55, %53
  %56 = phi i64 [ 0, %53 ], [ %66, %55 ]
  %57 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0)
  %58 = load %struct.LocVar*, %struct.LocVar** %39, align 8, !tbaa !84
  %59 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %58, i64 %56, i32 0
  store %struct.TString* %57, %struct.TString** %59, align 8, !tbaa !88
  %60 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %61 = load %struct.LocVar*, %struct.LocVar** %39, align 8, !tbaa !84
  %62 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %61, i64 %56, i32 1
  store i32 %60, i32* %62, align 8, !tbaa !85
  %63 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %64 = load %struct.LocVar*, %struct.LocVar** %39, align 8, !tbaa !84
  %65 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %64, i64 %56, i32 2
  store i32 %63, i32* %65, align 4, !tbaa !87
  %66 = add nuw nsw i64 %56, 1
  %67 = icmp eq i64 %66, %54
  br i1 %67, label %68, label %55

; <label>:68:                                     ; preds = %55, %33, %51
  %69 = tail call fastcc i32 @LoadInt(%struct.LoadState* %0)
  %70 = icmp sgt i32 %69, 0
  br i1 %70, label %71, label %81

; <label>:71:                                     ; preds = %68
  %72 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %73 = zext i32 %69 to i64
  br label %74

; <label>:74:                                     ; preds = %74, %71
  %75 = phi i64 [ 0, %71 ], [ %79, %74 ]
  %76 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0)
  %77 = load %struct.Upvaldesc*, %struct.Upvaldesc** %72, align 8, !tbaa !174
  %78 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %77, i64 %75, i32 0
  store %struct.TString* %76, %struct.TString** %78, align 8, !tbaa !175
  %79 = add nuw nsw i64 %75, 1
  %80 = icmp eq i64 %79, %73
  br i1 %80, label %81, label %74

; <label>:81:                                     ; preds = %74, %68
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @LoadSize(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 -1)
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @LoadString(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0)
  %3 = icmp eq %struct.TString* %2, null
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.221, i64 0, i64 0)) #17
  unreachable

; <label>:5:                                      ; preds = %1
  ret %struct.TString* %2
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaX_setinput(%struct.lua_State*, %struct.LexState* nocapture, %struct.Zio*, %struct.TString*, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 3, i32 0
  store i32 0, i32* %6, align 8, !tbaa !259
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 6
  store %struct.lua_State* %0, %struct.lua_State** %7, align 8, !tbaa !260
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 0
  store i32 %4, i32* %8, align 8, !tbaa !261
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 4, i32 0
  store i32 289, i32* %9, align 8, !tbaa !262
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 7
  store %struct.Zio* %2, %struct.Zio** %10, align 8, !tbaa !263
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 5
  store %struct.FuncState* null, %struct.FuncState** %11, align 8, !tbaa !264
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 1
  store i32 1, i32* %12, align 4, !tbaa !265
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 2
  store i32 1, i32* %13, align 8, !tbaa !266
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 11
  store %struct.TString* %3, %struct.TString** %14, align 8, !tbaa !267
  %15 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4)
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 12
  store %struct.TString* %15, %struct.TString** %16, align 8, !tbaa !268
  %17 = load %struct.lua_State*, %struct.lua_State** %7, align 8, !tbaa !260
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %1, i64 0, i32 8
  %19 = load %struct.Mbuffer*, %struct.Mbuffer** %18, align 8, !tbaa !253
  %20 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %19, i64 0, i32 0
  %21 = load i8*, i8** %20, align 8, !tbaa !269
  %22 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %19, i64 0, i32 2
  %23 = load i64, i64* %22, align 8, !tbaa !270
  %24 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %17, i8* %21, i64 %23, i64 32)
  %25 = load %struct.Mbuffer*, %struct.Mbuffer** %18, align 8, !tbaa !253
  %26 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %25, i64 0, i32 0
  store i8* %24, i8** %26, align 8, !tbaa !269
  %27 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %25, i64 0, i32 2
  store i64 32, i64* %27, align 8, !tbaa !270
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @mainfunc(%struct.LexState*, %struct.FuncState*) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  call fastcc void @open_func(%struct.LexState* %0, %struct.FuncState* %1, %struct.BlockCnt* nonnull %3)
  call fastcc void @setvararg(%struct.FuncState* %1, i32 0)
  call fastcc void @init_exp(%struct.expdesc* nonnull %4, i32 8, i32 0)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 12
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !268
  %9 = call fastcc i32 @newupvalue(%struct.FuncState* %1, %struct.TString* %8, %struct.expdesc* nonnull %4)
  call fastcc void @luaX_next(%struct.LexState* %0)
  call fastcc void @statlist(%struct.LexState* %0)
  call fastcc void @check(%struct.LexState* %0, i32 289)
  call fastcc void @close_func(%struct.LexState* %0)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @open_func(%struct.LexState*, %struct.FuncState*, %struct.BlockCnt*) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = bitcast %struct.FuncState** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !264
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 1
  %10 = bitcast %struct.FuncState** %9 to i64*
  store i64 %8, i64* %10, align 8, !tbaa !271
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 2
  store %struct.LexState* %0, %struct.LexState** %11, align 8, !tbaa !272
  store %struct.FuncState* %1, %struct.FuncState** %6, align 8, !tbaa !264
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 4
  store i32 0, i32* %12, align 8, !tbaa !273
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 13
  %14 = load i32, i32* %13, align 4, !tbaa !101
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 6
  store i32 %14, i32* %15, align 8, !tbaa !274
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 5
  store i32 0, i32* %16, align 4, !tbaa !275
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 7
  store i32 0, i32* %17, align 4, !tbaa !276
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 9
  store i32 0, i32* %18, align 4, !tbaa !277
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 8
  store i32 0, i32* %19, align 8, !tbaa !278
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 12
  %21 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %22 = bitcast i16* %20 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %22, i8 0, i64 7, i32 8, i1 false)
  %23 = load %struct.Dyndata*, %struct.Dyndata** %21, align 8, !tbaa !254
  %24 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 0, i32 1
  %25 = load i32, i32* %24, align 8, !tbaa !257
  %26 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 10
  store i32 %25, i32* %26, align 8, !tbaa !279
  %27 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 2, i32 1
  %28 = load i32, i32* %27, align 8, !tbaa !255
  %29 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 11
  store i32 %28, i32* %29, align 4, !tbaa !280
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %1, i64 0, i32 3
  store %struct.BlockCnt* null, %struct.BlockCnt** %30, align 8, !tbaa !281
  %31 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %32 = bitcast %struct.TString** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !267
  %34 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 22
  %35 = bitcast %struct.TString** %34 to i64*
  store i64 %33, i64* %35, align 8, !tbaa !104
  %36 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 5
  store i8 2, i8* %36, align 4, !tbaa !133
  tail call fastcc void @enterblock(%struct.FuncState* %1, %struct.BlockCnt* %2, i8 zeroext 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setvararg(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 4
  store i8 1, i8* %5, align 1, !tbaa !94
  %6 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 82, i32 %1, i32 0, i32 0, i32 0)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @init_exp(%struct.expdesc* nocapture, i32, i32) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  store i32 -1, i32* %4, align 8, !tbaa !282
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  store i32 -1, i32* %5, align 4, !tbaa !284
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  store i32 %1, i32* %6, align 8, !tbaa !285
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  store i32 %2, i32* %8, align 8, !tbaa !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @newupvalue(%struct.FuncState* nocapture, %struct.TString*, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 6
  %7 = load i32, i32* %6, align 8, !tbaa !166
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %9 = load i8, i8* %8, align 1, !tbaa !286
  %10 = zext i8 %9 to i32
  %11 = add nuw nsw i32 %10, 1
  tail call fastcc void @checklimit(%struct.FuncState* %0, i32 %11, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0))
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %13 = load %struct.LexState*, %struct.LexState** %12, align 8, !tbaa !272
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %13, i64 0, i32 6
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !260
  %16 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 18
  %17 = bitcast %struct.Upvaldesc** %16 to i8**
  %18 = load i8*, i8** %17, align 8, !tbaa !174
  %19 = load i8, i8* %8, align 1, !tbaa !286
  %20 = zext i8 %19 to i32
  %21 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %15, i8* %18, i32 %20, i32* nonnull %6, i32 16, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0))
  store i8* %21, i8** %17, align 8, !tbaa !174
  %22 = load i32, i32* %6, align 8, !tbaa !166
  %23 = icmp slt i32 %7, %22
  br i1 %23, label %24, label %34

; <label>:24:                                     ; preds = %3
  %25 = load %struct.Upvaldesc*, %struct.Upvaldesc** %16, align 8, !tbaa !174
  %26 = load i32, i32* %6, align 8, !tbaa !166
  %27 = sext i32 %7 to i64
  %28 = sext i32 %26 to i64
  br label %29

; <label>:29:                                     ; preds = %24, %29
  %30 = phi i64 [ %27, %24 ], [ %31, %29 ]
  %31 = add nsw i64 %30, 1
  %32 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %25, i64 %30, i32 0
  store %struct.TString* null, %struct.TString** %32, align 8, !tbaa !175
  %33 = icmp slt i64 %31, %28
  br i1 %33, label %29, label %34

; <label>:34:                                     ; preds = %29, %3
  %35 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %36 = load i32, i32* %35, align 8, !tbaa !285
  %37 = icmp eq i32 %36, 8
  %38 = zext i1 %37 to i8
  %39 = load %struct.Upvaldesc*, %struct.Upvaldesc** %16, align 8, !tbaa !174
  %40 = load i8, i8* %8, align 1, !tbaa !286
  %41 = zext i8 %40 to i64
  %42 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %39, i64 %41, i32 1
  store i8 %38, i8* %42, align 8, !tbaa !236
  %43 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %44 = bitcast %union.anon.8* %43 to i32*
  %45 = load i32, i32* %44, align 8, !tbaa !21
  %46 = trunc i32 %45 to i8
  %47 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %39, i64 %41, i32 2
  store i8 %46, i8* %47, align 1, !tbaa !237
  %48 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %39, i64 %41, i32 0
  store %struct.TString* %1, %struct.TString** %48, align 8, !tbaa !175
  %49 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 2
  %50 = load i8, i8* %49, align 1, !tbaa !226
  %51 = and i8 %50, 32
  %52 = icmp eq i8 %51, 0
  br i1 %52, label %64, label %53

; <label>:53:                                     ; preds = %34
  %54 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %55 = load i8, i8* %54, align 1, !tbaa !227
  %56 = and i8 %55, 24
  %57 = icmp eq i8 %56, 0
  br i1 %57, label %64, label %58

; <label>:58:                                     ; preds = %53
  %59 = load %struct.LexState*, %struct.LexState** %12, align 8, !tbaa !272
  %60 = getelementptr inbounds %struct.LexState, %struct.LexState* %59, i64 0, i32 6
  %61 = load %struct.lua_State*, %struct.lua_State** %60, align 8, !tbaa !260
  %62 = bitcast %struct.Proto* %5 to %struct.GCObject*
  %63 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %61, %struct.GCObject* %62, %struct.GCObject* %63)
  br label %64

; <label>:64:                                     ; preds = %53, %34, %58
  %65 = load i8, i8* %8, align 1, !tbaa !286
  %66 = add i8 %65, 1
  store i8 %66, i8* %8, align 1, !tbaa !286
  %67 = zext i8 %65 to i32
  ret i32 %67
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaX_next(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %3 = load i32, i32* %2, align 4, !tbaa !265
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %3, i32* %4, align 8, !tbaa !266
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %6 = getelementptr inbounds %struct.Token, %struct.Token* %5, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !262
  %8 = icmp eq i32 %7, 289
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %11 = bitcast %struct.Token* %10 to i8*
  %12 = bitcast %struct.Token* %5 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %11, i8* nonnull %12, i64 16, i32 8, i1 false), !tbaa.struct !287
  store i32 289, i32* %6, align 8, !tbaa !262
  br label %17

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %15 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %14)
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 %15, i32* %16, align 8, !tbaa !259
  br label %17

; <label>:17:                                     ; preds = %13, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @statlist(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %3 = tail call fastcc i32 @block_follow(%struct.LexState* %0, i32 1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %12

; <label>:5:                                      ; preds = %1
  br label %9

; <label>:6:                                      ; preds = %9
  %7 = tail call fastcc i32 @block_follow(%struct.LexState* nonnull %0, i32 1)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %5, %6
  %10 = load i32, i32* %2, align 8, !tbaa !259
  %11 = icmp eq i32 %10, 274
  tail call fastcc void @statement(%struct.LexState* %0)
  br i1 %11, label %12, label %6

; <label>:12:                                     ; preds = %6, %9, %1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @check(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #17
  unreachable

; <label>:7:                                      ; preds = %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @close_func(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !260
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 13
  %9 = load i8, i8* %8, align 2, !tbaa !288
  %10 = zext i8 %9 to i32
  tail call fastcc void @luaK_ret(%struct.FuncState* %5, i32 %10, i32 0)
  tail call fastcc void @leaveblock(%struct.FuncState* %5)
  tail call fastcc void @luaK_finish(%struct.FuncState* %5)
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %12 = bitcast i32** %11 to i8**
  %13 = load i8*, i8** %12, align 8, !tbaa !134
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 8
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 4
  %16 = load i32, i32* %15, align 8, !tbaa !273
  %17 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %13, i32* nonnull %14, i32 %16, i32 4)
  store i8* %17, i8** %12, align 8, !tbaa !134
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 19
  %19 = load i8*, i8** %18, align 8, !tbaa !211
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 9
  %21 = load i32, i32* %15, align 8, !tbaa !273
  %22 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %19, i32* nonnull %20, i32 %21, i32 1)
  store i8* %22, i8** %18, align 8, !tbaa !211
  %23 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 20
  %24 = bitcast %struct.AbsLineInfo** %23 to i8**
  %25 = load i8*, i8** %24, align 8, !tbaa !212
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 12
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 9
  %28 = load i32, i32* %27, align 4, !tbaa !277
  %29 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %25, i32* nonnull %26, i32 %28, i32 8)
  store i8* %29, i8** %24, align 8, !tbaa !212
  %30 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 15
  %31 = bitcast %struct.TValue** %30 to i8**
  %32 = load i8*, i8** %31, align 8, !tbaa !209
  %33 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 7
  %34 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 7
  %35 = load i32, i32* %34, align 4, !tbaa !276
  %36 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %32, i32* nonnull %33, i32 %35, i32 16)
  store i8* %36, i8** %31, align 8, !tbaa !209
  %37 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 17
  %38 = bitcast %struct.Proto*** %37 to i8**
  %39 = load i8*, i8** %38, align 8, !tbaa !207
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 10
  %41 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 8
  %42 = load i32, i32* %41, align 8, !tbaa !278
  %43 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %39, i32* nonnull %40, i32 %42, i32 8)
  store i8* %43, i8** %38, align 8, !tbaa !207
  %44 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 21
  %45 = bitcast %struct.LocVar** %44 to i8**
  %46 = load i8*, i8** %45, align 8, !tbaa !84
  %47 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 11
  %48 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 12
  %49 = load i16, i16* %48, align 8, !tbaa !289
  %50 = sext i16 %49 to i32
  %51 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %46, i32* nonnull %47, i32 %50, i32 16)
  store i8* %51, i8** %45, align 8, !tbaa !84
  %52 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 18
  %53 = bitcast %struct.Upvaldesc** %52 to i8**
  %54 = load i8*, i8** %53, align 8, !tbaa !174
  %55 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 6
  %56 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 14
  %57 = load i8, i8* %56, align 1, !tbaa !286
  %58 = zext i8 %57 to i32
  %59 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %54, i32* nonnull %55, i32 %58, i32 16)
  store i8* %59, i8** %53, align 8, !tbaa !174
  %60 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 1
  %61 = bitcast %struct.FuncState** %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !271
  %63 = bitcast %struct.FuncState** %4 to i64*
  store i64 %62, i64* %63, align 8, !tbaa !264
  %64 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %3, i64 0, i32 7
  %65 = load %struct.global_State*, %struct.global_State** %64, align 8, !tbaa !2
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 3
  %67 = load i64, i64* %66, align 8, !tbaa !11
  %68 = icmp sgt i64 %67, 0
  br i1 %68, label %69, label %70

; <label>:69:                                     ; preds = %1
  tail call fastcc void @luaC_step(%struct.lua_State* %3)
  br label %70

; <label>:70:                                     ; preds = %69, %1
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @enterblock(%struct.FuncState* nocapture, %struct.BlockCnt*, i8 zeroext) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 5
  store i8 %2, i8* %4, align 2, !tbaa !290
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !288
  %7 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 3
  store i8 %6, i8* %7, align 8, !tbaa !292
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %9 = load %struct.LexState*, %struct.LexState** %8, align 8, !tbaa !272
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %9, i64 0, i32 10
  %11 = load %struct.Dyndata*, %struct.Dyndata** %10, align 8, !tbaa !254
  %12 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %11, i64 0, i32 2, i32 1
  %13 = load i32, i32* %12, align 8, !tbaa !255
  %14 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 1
  store i32 %13, i32* %14, align 8, !tbaa !293
  %15 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %11, i64 0, i32 1, i32 1
  %16 = load i32, i32* %15, align 8, !tbaa !256
  %17 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 2
  store i32 %16, i32* %17, align 4, !tbaa !294
  %18 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 4
  store i8 0, i8* %18, align 1, !tbaa !295
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  %20 = load %struct.BlockCnt*, %struct.BlockCnt** %19, align 8, !tbaa !281
  %21 = icmp eq %struct.BlockCnt* %20, null
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %3
  %23 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %20, i64 0, i32 6
  %24 = load i8, i8* %23, align 1, !tbaa !296
  %25 = icmp ne i8 %24, 0
  %26 = zext i1 %25 to i8
  br label %27

; <label>:27:                                     ; preds = %3, %22
  %28 = phi i8 [ 0, %3 ], [ %26, %22 ]
  %29 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 6
  store i8 %28, i8* %29, align 1, !tbaa !296
  %30 = bitcast %struct.BlockCnt** %19 to i64*
  %31 = load i64, i64* %30, align 8, !tbaa !281
  %32 = bitcast %struct.BlockCnt* %1 to i64*
  store i64 %31, i64* %32, align 8, !tbaa !297
  store %struct.BlockCnt* %1, %struct.BlockCnt** %19, align 8, !tbaa !281
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_codeABCk(%struct.FuncState* nocapture, i32, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = shl i32 %2, 7
  %8 = or i32 %7, %1
  %9 = shl i32 %3, 16
  %10 = or i32 %8, %9
  %11 = shl i32 %4, 24
  %12 = or i32 %10, %11
  %13 = shl i32 %5, 15
  %14 = or i32 %12, %13
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14)
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_code(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %6 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !272
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %6, i64 0, i32 6
  %8 = load %struct.lua_State*, %struct.lua_State** %7, align 8, !tbaa !260
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %10 = bitcast i32** %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !134
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %13 = load i32, i32* %12, align 8, !tbaa !273
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 8
  %15 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %8, i8* %11, i32 %13, i32* nonnull %14, i32 4, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0))
  %16 = bitcast i8* %15 to i32*
  store i8* %15, i8** %10, align 8, !tbaa !134
  %17 = load i32, i32* %12, align 8, !tbaa !273
  %18 = add nsw i32 %17, 1
  store i32 %18, i32* %12, align 8, !tbaa !273
  %19 = sext i32 %17 to i64
  %20 = getelementptr inbounds i32, i32* %16, i64 %19
  store i32 %1, i32* %20, align 4, !tbaa !70
  %21 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 2
  %23 = load i32, i32* %22, align 8, !tbaa !266
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %4, i32 %23)
  %24 = load i32, i32* %12, align 8, !tbaa !273
  %25 = add nsw i32 %24, -1
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaM_growaux_(%struct.lua_State*, i8*, i32, i32* nocapture, i32, i32, i8*) unnamed_addr #0 {
  %8 = load i32, i32* %3, align 4, !tbaa !70
  %9 = icmp sgt i32 %8, %2
  br i1 %9, label %31, label %10

; <label>:10:                                     ; preds = %7
  %11 = sdiv i32 %5, 2
  %12 = icmp slt i32 %8, %11
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %10
  %14 = icmp slt i32 %8, %5
  br i1 %14, label %20, label %15, !prof !103

; <label>:15:                                     ; preds = %13
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.223, i64 0, i64 0), i8* %6, i32 %5) #17
  unreachable

; <label>:16:                                     ; preds = %10
  %17 = shl nsw i32 %8, 1
  %18 = icmp sgt i32 %17, 4
  %19 = select i1 %18, i32 %17, i32 4
  br label %20

; <label>:20:                                     ; preds = %13, %16
  %21 = phi i32 [ %19, %16 ], [ %5, %13 ]
  %22 = sext i32 %8 to i64
  %23 = sext i32 %4 to i64
  %24 = mul nsw i64 %22, %23
  %25 = sext i32 %21 to i64
  %26 = mul nsw i64 %25, %23
  %27 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %24, i64 %26)
  %28 = icmp eq i8* %27, null
  br i1 %28, label %29, label %30, !prof !33

; <label>:29:                                     ; preds = %20
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #17
  unreachable

; <label>:30:                                     ; preds = %20
  store i32 %21, i32* %3, align 4, !tbaa !70
  br label %31

; <label>:31:                                     ; preds = %7, %30
  %32 = phi i8* [ %27, %30 ], [ %1, %7 ]
  ret i8* %32
}

; Function Attrs: nounwind uwtable
define internal fastcc void @savelineinfo(%struct.FuncState* nocapture, %struct.Proto* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %5 = load i32, i32* %4, align 8, !tbaa !274
  %6 = sub nsw i32 %2, %5
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %8 = load i32, i32* %7, align 8, !tbaa !273
  %9 = add nsw i32 %8, -1
  %10 = icmp sgt i32 %6, -1
  %11 = sub i32 0, %6
  %12 = select i1 %10, i32 %6, i32 %11
  %13 = icmp sgt i32 %12, 127
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  %16 = load i8, i8* %15, align 1, !tbaa !298
  %17 = add i8 %16, 1
  store i8 %17, i8* %15, align 1, !tbaa !298
  %18 = icmp ugt i8 %16, 120
  br i1 %18, label %19, label %39

; <label>:19:                                     ; preds = %14, %3
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %21 = load %struct.LexState*, %struct.LexState** %20, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 6
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !260
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %25 = bitcast %struct.AbsLineInfo** %24 to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !212
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %28 = load i32, i32* %27, align 4, !tbaa !277
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  %30 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %23, i8* %26, i32 %28, i32* nonnull %29, i32 8, i32 2147483647, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i64 0, i64 0))
  %31 = bitcast i8* %30 to %struct.AbsLineInfo*
  store i8* %30, i8** %25, align 8, !tbaa !212
  %32 = load i32, i32* %27, align 4, !tbaa !277
  %33 = sext i32 %32 to i64
  %34 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %31, i64 %33, i32 0
  store i32 %9, i32* %34, align 4, !tbaa !234
  %35 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %24, align 8, !tbaa !212
  %36 = add nsw i32 %32, 1
  store i32 %36, i32* %27, align 4, !tbaa !277
  %37 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %35, i64 %33, i32 1
  store i32 %2, i32* %37, align 4, !tbaa !258
  %38 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  store i8 0, i8* %38, align 1, !tbaa !298
  br label %39

; <label>:39:                                     ; preds = %19, %14
  %40 = phi i32 [ -128, %19 ], [ %6, %14 ]
  %41 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %42 = load %struct.LexState*, %struct.LexState** %41, align 8, !tbaa !272
  %43 = getelementptr inbounds %struct.LexState, %struct.LexState* %42, i64 0, i32 6
  %44 = load %struct.lua_State*, %struct.lua_State** %43, align 8, !tbaa !260
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  %46 = load i8*, i8** %45, align 8, !tbaa !211
  %47 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  %48 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %44, i8* %46, i32 %9, i32* nonnull %47, i32 1, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0))
  store i8* %48, i8** %45, align 8, !tbaa !211
  %49 = trunc i32 %40 to i8
  %50 = sext i32 %9 to i64
  %51 = getelementptr inbounds i8, i8* %48, i64 %50
  store i8 %49, i8* %51, align 1, !tbaa !21
  store i32 %2, i32* %4, align 8, !tbaa !274
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checklimit(%struct.FuncState* nocapture readonly, i32, i32, i8*) unnamed_addr #0 {
  %5 = icmp sgt i32 %1, %2
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call fastcc void @errorlimit(%struct.FuncState* %0, i32 %2, i8* %3) #17
  unreachable

; <label>:7:                                      ; preds = %4
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @errorlimit(%struct.FuncState* nocapture readonly, i32, i8*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !260
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 13
  %11 = load i32, i32* %10, align 4, !tbaa !101
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %3
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.227, i64 0, i64 0), i32 %11)
  br label %15

; <label>:15:                                     ; preds = %3, %13
  %16 = phi i8* [ %14, %13 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.226, i64 0, i64 0), %3 ]
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.228, i64 0, i64 0), i8* %2, i32 %1, i8* %16)
  %18 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %18, i8* %17) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaX_syntaxerror(%struct.LexState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  tail call fastcc void @lexerror(%struct.LexState* %0, i8* %1, i32 %4) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @lexerror(%struct.LexState* nocapture readonly, i8*, i32) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %7 = load %struct.TString*, %struct.TString** %6, align 8, !tbaa !267
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  %10 = tail call fastcc i8* @luaG_addinfo(%struct.lua_State* %5, i8* %1, %struct.TString* %7, i32 %9)
  %11 = icmp eq i32 %2, 0
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %3
  %13 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  %14 = tail call fastcc i8* @txtToken(%struct.LexState* nonnull %0, i32 %2)
  %15 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.229, i64 0, i64 0), i8* %10, i8* %14)
  br label %16

; <label>:16:                                     ; preds = %3, %12
  %17 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  tail call fastcc void @luaD_throw(%struct.lua_State* %17, i32 3) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @txtToken(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = add i32 %1, -290
  %4 = icmp ult i32 %3, 4
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %2
  tail call fastcc void @save(%struct.LexState* %0, i32 0)
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !260
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %9 = load %struct.Mbuffer*, %struct.Mbuffer** %8, align 8, !tbaa !253
  %10 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %9, i64 0, i32 0
  %11 = load i8*, i8** %10, align 8, !tbaa !269
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %11)
  br label %15

; <label>:13:                                     ; preds = %2
  %14 = tail call fastcc i8* @luaX_token2str(%struct.LexState* %0, i32 %1)
  br label %15

; <label>:15:                                     ; preds = %13, %5
  %16 = phi i8* [ %12, %5 ], [ %14, %13 ]
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal fastcc void @save(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %4 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %5 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 1
  %6 = load i64, i64* %5, align 8, !tbaa !299
  %7 = add i64 %6, 1
  %8 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 2
  %9 = load i64, i64* %8, align 8, !tbaa !270
  %10 = icmp ugt i64 %7, %9
  br i1 %10, label %11, label %21

; <label>:11:                                     ; preds = %2
  %12 = icmp ugt i64 %9, 4611686018427387902
  br i1 %12, label %13, label %14

; <label>:13:                                     ; preds = %11
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.231, i64 0, i64 0), i32 0) #17
  unreachable

; <label>:14:                                     ; preds = %11
  %15 = shl i64 %9, 1
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %17 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !260
  %18 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %19 = load i8*, i8** %18, align 8, !tbaa !269
  %20 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %17, i8* %19, i64 %9, i64 %15)
  store i8* %20, i8** %18, align 8, !tbaa !269
  store i64 %15, i64* %8, align 8, !tbaa !270
  br label %21

; <label>:21:                                     ; preds = %14, %2
  %22 = trunc i32 %1 to i8
  %23 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %24 = load i8*, i8** %23, align 8, !tbaa !269
  %25 = load i64, i64* %5, align 8, !tbaa !299
  %26 = add i64 %25, 1
  store i64 %26, i64* %5, align 8, !tbaa !299
  %27 = getelementptr inbounds i8, i8* %24, i64 %25
  store i8 %22, i8* %27, align 1, !tbaa !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaX_token2str(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = icmp slt i32 %1, 257
  br i1 %3, label %4, label %15

; <label>:4:                                      ; preds = %2
  %5 = add nsw i32 %1, 1
  %6 = sext i32 %5 to i64
  %7 = add nsw i64 %6, -33
  %8 = icmp ult i64 %7, 95
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !260
  br i1 %8, label %11, label %13

; <label>:11:                                     ; preds = %4
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.232, i64 0, i64 0), i32 %1)
  br label %25

; <label>:13:                                     ; preds = %4
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.233, i64 0, i64 0), i32 %1)
  br label %25

; <label>:15:                                     ; preds = %2
  %16 = add nsw i32 %1, -257
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %17
  %19 = load i8*, i8** %18, align 8, !tbaa !79
  %20 = icmp slt i32 %1, 289
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !260
  %24 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %23, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %19)
  br label %25

; <label>:25:                                     ; preds = %21, %15, %13, %11
  %26 = phi i8* [ %12, %11 ], [ %14, %13 ], [ %24, %21 ], [ %19, %15 ]
  ret i8* %26
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @llex(%struct.LexState*, %union.SemInfo*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %4 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %5 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 1
  store i64 0, i64* %5, align 8, !tbaa !299
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  br label %9

; <label>:9:                                      ; preds = %70, %2
  %10 = load i32, i32* %6, align 8, !tbaa !261
  switch i32 %10, label %258 [
    i32 10, label %11
    i32 13, label %11
    i32 32, label %12
    i32 12, label %12
    i32 9, label %12
    i32 11, label %12
    i32 45, label %28
    i32 91, label %91
    i32 61, label %98
    i32 60, label %118
    i32 62, label %141
    i32 47, label %164
    i32 126, label %184
    i32 58, label %204
    i32 34, label %224
    i32 39, label %224
    i32 46, label %225
    i32 48, label %256
    i32 49, label %256
    i32 50, label %256
    i32 51, label %256
    i32 52, label %256
    i32 53, label %256
    i32 54, label %256
    i32 55, label %256
    i32 56, label %256
    i32 57, label %256
    i32 -1, label %324
  ]

; <label>:11:                                     ; preds = %9, %9
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0)
  br label %70

; <label>:12:                                     ; preds = %9, %9, %9, %9
  %13 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !242
  %16 = add i64 %15, -1
  store i64 %16, i64* %14, align 8, !tbaa !242
  %17 = icmp eq i64 %15, 0
  br i1 %17, label %24, label %18

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 1
  %20 = load i8*, i8** %19, align 8, !tbaa !243
  %21 = getelementptr inbounds i8, i8* %20, i64 1
  store i8* %21, i8** %19, align 8, !tbaa !243
  %22 = load i8, i8* %20, align 1, !tbaa !21
  %23 = zext i8 %22 to i32
  br label %26

; <label>:24:                                     ; preds = %12
  %25 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %13)
  br label %26

; <label>:26:                                     ; preds = %24, %18
  %27 = phi i32 [ %23, %18 ], [ %25, %24 ]
  store i32 %27, i32* %6, align 8, !tbaa !261
  br label %70

; <label>:28:                                     ; preds = %9
  %29 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %30 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !242
  %32 = add i64 %31, -1
  store i64 %32, i64* %30, align 8, !tbaa !242
  %33 = icmp eq i64 %31, 0
  br i1 %33, label %40, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 1
  %36 = load i8*, i8** %35, align 8, !tbaa !243
  %37 = getelementptr inbounds i8, i8* %36, i64 1
  store i8* %37, i8** %35, align 8, !tbaa !243
  %38 = load i8, i8* %36, align 1, !tbaa !21
  %39 = zext i8 %38 to i32
  br label %42

; <label>:40:                                     ; preds = %28
  %41 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %29)
  br label %42

; <label>:42:                                     ; preds = %40, %34
  %43 = phi i32 [ %39, %34 ], [ %41, %40 ]
  store i32 %43, i32* %6, align 8, !tbaa !261
  %44 = icmp eq i32 %43, 45
  br i1 %44, label %45, label %324

; <label>:45:                                     ; preds = %42
  %46 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %47 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 0
  %48 = load i64, i64* %47, align 8, !tbaa !242
  %49 = add i64 %48, -1
  store i64 %49, i64* %47, align 8, !tbaa !242
  %50 = icmp eq i64 %48, 0
  br i1 %50, label %57, label %51

; <label>:51:                                     ; preds = %45
  %52 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 1
  %53 = load i8*, i8** %52, align 8, !tbaa !243
  %54 = getelementptr inbounds i8, i8* %53, i64 1
  store i8* %54, i8** %52, align 8, !tbaa !243
  %55 = load i8, i8* %53, align 1, !tbaa !21
  %56 = zext i8 %55 to i32
  br label %59

; <label>:57:                                     ; preds = %45
  %58 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %46)
  br label %59

; <label>:59:                                     ; preds = %57, %51
  %60 = phi i32 [ %56, %51 ], [ %58, %57 ]
  store i32 %60, i32* %6, align 8, !tbaa !261
  %61 = icmp eq i32 %60, 91
  br i1 %61, label %62, label %71

; <label>:62:                                     ; preds = %59
  %63 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0)
  %64 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %65 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %64, i64 0, i32 1
  store i64 0, i64* %65, align 8, !tbaa !299
  %66 = icmp ugt i64 %63, 1
  br i1 %66, label %67, label %71

; <label>:67:                                     ; preds = %62
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* null, i64 %63)
  %68 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %69 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %68, i64 0, i32 1
  store i64 0, i64* %69, align 8, !tbaa !299
  br label %70

; <label>:70:                                     ; preds = %73, %73, %73, %67, %26, %11
  br label %9

; <label>:71:                                     ; preds = %62, %59
  %72 = load i32, i32* %6, align 8, !tbaa !261
  br label %73

; <label>:73:                                     ; preds = %89, %71
  %74 = phi i32 [ %90, %89 ], [ %72, %71 ]
  switch i32 %74, label %75 [
    i32 10, label %70
    i32 13, label %70
    i32 -1, label %70
  ]

; <label>:75:                                     ; preds = %73
  %76 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %77 = getelementptr inbounds %struct.Zio, %struct.Zio* %76, i64 0, i32 0
  %78 = load i64, i64* %77, align 8, !tbaa !242
  %79 = add i64 %78, -1
  store i64 %79, i64* %77, align 8, !tbaa !242
  %80 = icmp eq i64 %78, 0
  br i1 %80, label %87, label %81

; <label>:81:                                     ; preds = %75
  %82 = getelementptr inbounds %struct.Zio, %struct.Zio* %76, i64 0, i32 1
  %83 = load i8*, i8** %82, align 8, !tbaa !243
  %84 = getelementptr inbounds i8, i8* %83, i64 1
  store i8* %84, i8** %82, align 8, !tbaa !243
  %85 = load i8, i8* %83, align 1, !tbaa !21
  %86 = zext i8 %85 to i32
  br label %89

; <label>:87:                                     ; preds = %75
  %88 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %76)
  br label %89

; <label>:89:                                     ; preds = %87, %81
  %90 = phi i32 [ %86, %81 ], [ %88, %87 ]
  store i32 %90, i32* %6, align 8, !tbaa !261
  br label %73

; <label>:91:                                     ; preds = %9
  %92 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0)
  %93 = icmp ugt i64 %92, 1
  br i1 %93, label %94, label %95

; <label>:94:                                     ; preds = %91
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* %1, i64 %92)
  br label %324

; <label>:95:                                     ; preds = %91
  %96 = icmp eq i64 %92, 0
  br i1 %96, label %97, label %324

; <label>:97:                                     ; preds = %95
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.234, i64 0, i64 0), i32 293) #17
  unreachable

; <label>:98:                                     ; preds = %9
  %99 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %100 = load %struct.Zio*, %struct.Zio** %99, align 8, !tbaa !263
  %101 = getelementptr inbounds %struct.Zio, %struct.Zio* %100, i64 0, i32 0
  %102 = load i64, i64* %101, align 8, !tbaa !242
  %103 = add i64 %102, -1
  store i64 %103, i64* %101, align 8, !tbaa !242
  %104 = icmp eq i64 %102, 0
  br i1 %104, label %111, label %105

; <label>:105:                                    ; preds = %98
  %106 = getelementptr inbounds %struct.Zio, %struct.Zio* %100, i64 0, i32 1
  %107 = load i8*, i8** %106, align 8, !tbaa !243
  %108 = getelementptr inbounds i8, i8* %107, i64 1
  store i8* %108, i8** %106, align 8, !tbaa !243
  %109 = load i8, i8* %107, align 1, !tbaa !21
  %110 = zext i8 %109 to i32
  br label %113

; <label>:111:                                    ; preds = %98
  %112 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %100)
  br label %113

; <label>:113:                                    ; preds = %111, %105
  %114 = phi i32 [ %110, %105 ], [ %112, %111 ]
  store i32 %114, i32* %6, align 8, !tbaa !261
  %115 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61)
  %116 = icmp eq i32 %115, 0
  %117 = select i1 %116, i32 61, i32 282
  br label %324

; <label>:118:                                    ; preds = %9
  %119 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %120 = load %struct.Zio*, %struct.Zio** %119, align 8, !tbaa !263
  %121 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 0
  %122 = load i64, i64* %121, align 8, !tbaa !242
  %123 = add i64 %122, -1
  store i64 %123, i64* %121, align 8, !tbaa !242
  %124 = icmp eq i64 %122, 0
  br i1 %124, label %131, label %125

; <label>:125:                                    ; preds = %118
  %126 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 1
  %127 = load i8*, i8** %126, align 8, !tbaa !243
  %128 = getelementptr inbounds i8, i8* %127, i64 1
  store i8* %128, i8** %126, align 8, !tbaa !243
  %129 = load i8, i8* %127, align 1, !tbaa !21
  %130 = zext i8 %129 to i32
  br label %133

; <label>:131:                                    ; preds = %118
  %132 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %120)
  br label %133

; <label>:133:                                    ; preds = %131, %125
  %134 = phi i32 [ %130, %125 ], [ %132, %131 ]
  store i32 %134, i32* %6, align 8, !tbaa !261
  %135 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61)
  %136 = icmp eq i32 %135, 0
  br i1 %136, label %137, label %324

; <label>:137:                                    ; preds = %133
  %138 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 60)
  %139 = icmp eq i32 %138, 0
  %140 = select i1 %139, i32 60, i32 286
  br label %324

; <label>:141:                                    ; preds = %9
  %142 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %143 = load %struct.Zio*, %struct.Zio** %142, align 8, !tbaa !263
  %144 = getelementptr inbounds %struct.Zio, %struct.Zio* %143, i64 0, i32 0
  %145 = load i64, i64* %144, align 8, !tbaa !242
  %146 = add i64 %145, -1
  store i64 %146, i64* %144, align 8, !tbaa !242
  %147 = icmp eq i64 %145, 0
  br i1 %147, label %154, label %148

; <label>:148:                                    ; preds = %141
  %149 = getelementptr inbounds %struct.Zio, %struct.Zio* %143, i64 0, i32 1
  %150 = load i8*, i8** %149, align 8, !tbaa !243
  %151 = getelementptr inbounds i8, i8* %150, i64 1
  store i8* %151, i8** %149, align 8, !tbaa !243
  %152 = load i8, i8* %150, align 1, !tbaa !21
  %153 = zext i8 %152 to i32
  br label %156

; <label>:154:                                    ; preds = %141
  %155 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %143)
  br label %156

; <label>:156:                                    ; preds = %154, %148
  %157 = phi i32 [ %153, %148 ], [ %155, %154 ]
  store i32 %157, i32* %6, align 8, !tbaa !261
  %158 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61)
  %159 = icmp eq i32 %158, 0
  br i1 %159, label %160, label %324

; <label>:160:                                    ; preds = %156
  %161 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 62)
  %162 = icmp eq i32 %161, 0
  %163 = select i1 %162, i32 62, i32 287
  br label %324

; <label>:164:                                    ; preds = %9
  %165 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %166 = load %struct.Zio*, %struct.Zio** %165, align 8, !tbaa !263
  %167 = getelementptr inbounds %struct.Zio, %struct.Zio* %166, i64 0, i32 0
  %168 = load i64, i64* %167, align 8, !tbaa !242
  %169 = add i64 %168, -1
  store i64 %169, i64* %167, align 8, !tbaa !242
  %170 = icmp eq i64 %168, 0
  br i1 %170, label %177, label %171

; <label>:171:                                    ; preds = %164
  %172 = getelementptr inbounds %struct.Zio, %struct.Zio* %166, i64 0, i32 1
  %173 = load i8*, i8** %172, align 8, !tbaa !243
  %174 = getelementptr inbounds i8, i8* %173, i64 1
  store i8* %174, i8** %172, align 8, !tbaa !243
  %175 = load i8, i8* %173, align 1, !tbaa !21
  %176 = zext i8 %175 to i32
  br label %179

; <label>:177:                                    ; preds = %164
  %178 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %166)
  br label %179

; <label>:179:                                    ; preds = %177, %171
  %180 = phi i32 [ %176, %171 ], [ %178, %177 ]
  store i32 %180, i32* %6, align 8, !tbaa !261
  %181 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 47)
  %182 = icmp eq i32 %181, 0
  %183 = select i1 %182, i32 47, i32 279
  br label %324

; <label>:184:                                    ; preds = %9
  %185 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %186 = load %struct.Zio*, %struct.Zio** %185, align 8, !tbaa !263
  %187 = getelementptr inbounds %struct.Zio, %struct.Zio* %186, i64 0, i32 0
  %188 = load i64, i64* %187, align 8, !tbaa !242
  %189 = add i64 %188, -1
  store i64 %189, i64* %187, align 8, !tbaa !242
  %190 = icmp eq i64 %188, 0
  br i1 %190, label %197, label %191

; <label>:191:                                    ; preds = %184
  %192 = getelementptr inbounds %struct.Zio, %struct.Zio* %186, i64 0, i32 1
  %193 = load i8*, i8** %192, align 8, !tbaa !243
  %194 = getelementptr inbounds i8, i8* %193, i64 1
  store i8* %194, i8** %192, align 8, !tbaa !243
  %195 = load i8, i8* %193, align 1, !tbaa !21
  %196 = zext i8 %195 to i32
  br label %199

; <label>:197:                                    ; preds = %184
  %198 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %186)
  br label %199

; <label>:199:                                    ; preds = %197, %191
  %200 = phi i32 [ %196, %191 ], [ %198, %197 ]
  store i32 %200, i32* %6, align 8, !tbaa !261
  %201 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61)
  %202 = icmp eq i32 %201, 0
  %203 = select i1 %202, i32 126, i32 285
  br label %324

; <label>:204:                                    ; preds = %9
  %205 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %206 = load %struct.Zio*, %struct.Zio** %205, align 8, !tbaa !263
  %207 = getelementptr inbounds %struct.Zio, %struct.Zio* %206, i64 0, i32 0
  %208 = load i64, i64* %207, align 8, !tbaa !242
  %209 = add i64 %208, -1
  store i64 %209, i64* %207, align 8, !tbaa !242
  %210 = icmp eq i64 %208, 0
  br i1 %210, label %217, label %211

; <label>:211:                                    ; preds = %204
  %212 = getelementptr inbounds %struct.Zio, %struct.Zio* %206, i64 0, i32 1
  %213 = load i8*, i8** %212, align 8, !tbaa !243
  %214 = getelementptr inbounds i8, i8* %213, i64 1
  store i8* %214, i8** %212, align 8, !tbaa !243
  %215 = load i8, i8* %213, align 1, !tbaa !21
  %216 = zext i8 %215 to i32
  br label %219

; <label>:217:                                    ; preds = %204
  %218 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %206)
  br label %219

; <label>:219:                                    ; preds = %217, %211
  %220 = phi i32 [ %216, %211 ], [ %218, %217 ]
  store i32 %220, i32* %6, align 8, !tbaa !261
  %221 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 58)
  %222 = icmp eq i32 %221, 0
  %223 = select i1 %222, i32 58, i32 288
  br label %324

; <label>:224:                                    ; preds = %9, %9
  tail call fastcc void @read_string(%struct.LexState* nonnull %0, i32 %10, %union.SemInfo* %1)
  br label %324

; <label>:225:                                    ; preds = %9
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %10)
  %226 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %227 = load %struct.Zio*, %struct.Zio** %226, align 8, !tbaa !263
  %228 = getelementptr inbounds %struct.Zio, %struct.Zio* %227, i64 0, i32 0
  %229 = load i64, i64* %228, align 8, !tbaa !242
  %230 = add i64 %229, -1
  store i64 %230, i64* %228, align 8, !tbaa !242
  %231 = icmp eq i64 %229, 0
  br i1 %231, label %238, label %232

; <label>:232:                                    ; preds = %225
  %233 = getelementptr inbounds %struct.Zio, %struct.Zio* %227, i64 0, i32 1
  %234 = load i8*, i8** %233, align 8, !tbaa !243
  %235 = getelementptr inbounds i8, i8* %234, i64 1
  store i8* %235, i8** %233, align 8, !tbaa !243
  %236 = load i8, i8* %234, align 1, !tbaa !21
  %237 = zext i8 %236 to i32
  br label %240

; <label>:238:                                    ; preds = %225
  %239 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %227)
  br label %240

; <label>:240:                                    ; preds = %238, %232
  %241 = phi i32 [ %237, %232 ], [ %239, %238 ]
  store i32 %241, i32* %6, align 8, !tbaa !261
  %242 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46)
  %243 = icmp eq i32 %242, 0
  br i1 %243, label %248, label %244

; <label>:244:                                    ; preds = %240
  %245 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46)
  %246 = icmp eq i32 %245, 0
  %247 = select i1 %246, i32 280, i32 281
  br label %324

; <label>:248:                                    ; preds = %240
  %249 = load i32, i32* %6, align 8, !tbaa !261
  %250 = add nsw i32 %249, 1
  %251 = sext i32 %250 to i64
  %252 = add nsw i64 %251, -49
  %253 = icmp ult i64 %252, 10
  br i1 %253, label %254, label %324

; <label>:254:                                    ; preds = %248
  %255 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1)
  br label %324

; <label>:256:                                    ; preds = %9, %9, %9, %9, %9, %9, %9, %9, %9, %9
  %257 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1)
  br label %324

; <label>:258:                                    ; preds = %9
  %259 = add nsw i32 %10, 1
  %260 = sext i32 %259 to i64
  %261 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %260
  %262 = load i8, i8* %261, align 1, !tbaa !21
  %263 = and i8 %262, 1
  %264 = icmp eq i8 %263, 0
  %265 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  br i1 %264, label %308, label %266

; <label>:266:                                    ; preds = %258
  br label %267

; <label>:267:                                    ; preds = %266, %282
  %268 = load i32, i32* %6, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %268)
  %269 = load %struct.Zio*, %struct.Zio** %265, align 8, !tbaa !263
  %270 = getelementptr inbounds %struct.Zio, %struct.Zio* %269, i64 0, i32 0
  %271 = load i64, i64* %270, align 8, !tbaa !242
  %272 = add i64 %271, -1
  store i64 %272, i64* %270, align 8, !tbaa !242
  %273 = icmp eq i64 %271, 0
  br i1 %273, label %280, label %274

; <label>:274:                                    ; preds = %267
  %275 = getelementptr inbounds %struct.Zio, %struct.Zio* %269, i64 0, i32 1
  %276 = load i8*, i8** %275, align 8, !tbaa !243
  %277 = getelementptr inbounds i8, i8* %276, i64 1
  store i8* %277, i8** %275, align 8, !tbaa !243
  %278 = load i8, i8* %276, align 1, !tbaa !21
  %279 = zext i8 %278 to i32
  br label %282

; <label>:280:                                    ; preds = %267
  %281 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %269)
  br label %282

; <label>:282:                                    ; preds = %280, %274
  %283 = phi i32 [ %279, %274 ], [ %281, %280 ]
  store i32 %283, i32* %6, align 8, !tbaa !261
  %284 = add nsw i32 %283, 1
  %285 = sext i32 %284 to i64
  %286 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %285
  %287 = load i8, i8* %286, align 1, !tbaa !21
  %288 = and i8 %287, 3
  %289 = icmp eq i8 %288, 0
  br i1 %289, label %290, label %267

; <label>:290:                                    ; preds = %282
  %291 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !253
  %292 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %291, i64 0, i32 0
  %293 = load i8*, i8** %292, align 8, !tbaa !269
  %294 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %291, i64 0, i32 1
  %295 = load i64, i64* %294, align 8, !tbaa !299
  %296 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %293, i64 %295)
  %297 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %296, %struct.TString** %297, align 8, !tbaa !21
  %298 = getelementptr inbounds %struct.TString, %struct.TString* %296, i64 0, i32 1
  %299 = load i8, i8* %298, align 8, !tbaa !57
  %300 = icmp eq i8 %299, 20
  br i1 %300, label %301, label %324

; <label>:301:                                    ; preds = %290
  %302 = getelementptr inbounds %struct.TString, %struct.TString* %296, i64 0, i32 3
  %303 = load i8, i8* %302, align 2, !tbaa !199
  %304 = icmp eq i8 %303, 0
  br i1 %304, label %324, label %305

; <label>:305:                                    ; preds = %301
  %306 = zext i8 %303 to i32
  %307 = or i32 %306, 256
  br label %324

; <label>:308:                                    ; preds = %258
  %309 = load %struct.Zio*, %struct.Zio** %265, align 8, !tbaa !263
  %310 = getelementptr inbounds %struct.Zio, %struct.Zio* %309, i64 0, i32 0
  %311 = load i64, i64* %310, align 8, !tbaa !242
  %312 = add i64 %311, -1
  store i64 %312, i64* %310, align 8, !tbaa !242
  %313 = icmp eq i64 %311, 0
  br i1 %313, label %320, label %314

; <label>:314:                                    ; preds = %308
  %315 = getelementptr inbounds %struct.Zio, %struct.Zio* %309, i64 0, i32 1
  %316 = load i8*, i8** %315, align 8, !tbaa !243
  %317 = getelementptr inbounds i8, i8* %316, i64 1
  store i8* %317, i8** %315, align 8, !tbaa !243
  %318 = load i8, i8* %316, align 1, !tbaa !21
  %319 = zext i8 %318 to i32
  br label %322

; <label>:320:                                    ; preds = %308
  %321 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %309)
  br label %322

; <label>:322:                                    ; preds = %320, %314
  %323 = phi i32 [ %319, %314 ], [ %321, %320 ]
  store i32 %323, i32* %6, align 8, !tbaa !261
  br label %324

; <label>:324:                                    ; preds = %9, %42, %305, %301, %290, %248, %244, %219, %199, %179, %160, %156, %137, %133, %113, %94, %95, %322, %256, %254, %224
  %325 = phi i32 [ %10, %322 ], [ %257, %256 ], [ %255, %254 ], [ 293, %224 ], [ 293, %94 ], [ 91, %95 ], [ %117, %113 ], [ 284, %133 ], [ %140, %137 ], [ 283, %156 ], [ %163, %160 ], [ %183, %179 ], [ %203, %199 ], [ %223, %219 ], [ %247, %244 ], [ 46, %248 ], [ %307, %305 ], [ 292, %301 ], [ 292, %290 ], [ 289, %9 ], [ 45, %42 ]
  ret i32 %325
}

; Function Attrs: nounwind uwtable
define internal fastcc void @inclinenumber(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !261
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5)
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !261
  switch i32 %19, label %38 [
    i32 10, label %20
    i32 13, label %20
  ]

; <label>:20:                                     ; preds = %18, %18
  %21 = icmp eq i32 %19, %3
  br i1 %21, label %38, label %22

; <label>:22:                                     ; preds = %20
  %23 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %24 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 0
  %25 = load i64, i64* %24, align 8, !tbaa !242
  %26 = add i64 %25, -1
  store i64 %26, i64* %24, align 8, !tbaa !242
  %27 = icmp eq i64 %25, 0
  br i1 %27, label %34, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 1
  %30 = load i8*, i8** %29, align 8, !tbaa !243
  %31 = getelementptr inbounds i8, i8* %30, i64 1
  store i8* %31, i8** %29, align 8, !tbaa !243
  %32 = load i8, i8* %30, align 1, !tbaa !21
  %33 = zext i8 %32 to i32
  br label %36

; <label>:34:                                     ; preds = %22
  %35 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %23)
  br label %36

; <label>:36:                                     ; preds = %34, %28
  %37 = phi i32 [ %33, %28 ], [ %35, %34 ]
  store i32 %37, i32* %2, align 8, !tbaa !261
  br label %38

; <label>:38:                                     ; preds = %18, %20, %36
  %39 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %40 = load i32, i32* %39, align 4, !tbaa !265
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* %39, align 4, !tbaa !265
  %42 = icmp eq i32 %41, 2147483647
  br i1 %42, label %43, label %44

; <label>:43:                                     ; preds = %38
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.235, i64 0, i64 0), i32 0) #17
  unreachable

; <label>:44:                                     ; preds = %38
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @skip_sep(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %3)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5)
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !261
  %20 = icmp eq i32 %19, 61
  br i1 %20, label %21, label %41

; <label>:21:                                     ; preds = %18
  br label %22

; <label>:22:                                     ; preds = %21, %37
  %23 = phi i64 [ %39, %37 ], [ 0, %21 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 61)
  %24 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %25 = getelementptr inbounds %struct.Zio, %struct.Zio* %24, i64 0, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !242
  %27 = add i64 %26, -1
  store i64 %27, i64* %25, align 8, !tbaa !242
  %28 = icmp eq i64 %26, 0
  br i1 %28, label %35, label %29

; <label>:29:                                     ; preds = %22
  %30 = getelementptr inbounds %struct.Zio, %struct.Zio* %24, i64 0, i32 1
  %31 = load i8*, i8** %30, align 8, !tbaa !243
  %32 = getelementptr inbounds i8, i8* %31, i64 1
  store i8* %32, i8** %30, align 8, !tbaa !243
  %33 = load i8, i8* %31, align 1, !tbaa !21
  %34 = zext i8 %33 to i32
  br label %37

; <label>:35:                                     ; preds = %22
  %36 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %24)
  br label %37

; <label>:37:                                     ; preds = %35, %29
  %38 = phi i32 [ %34, %29 ], [ %36, %35 ]
  store i32 %38, i32* %2, align 8, !tbaa !261
  %39 = add i64 %23, 1
  %40 = icmp eq i32 %38, 61
  br i1 %40, label %22, label %41

; <label>:41:                                     ; preds = %37, %18
  %42 = phi i32 [ %19, %18 ], [ %38, %37 ]
  %43 = phi i64 [ 0, %18 ], [ %39, %37 ]
  %44 = icmp eq i32 %42, %3
  %45 = add i64 %43, 2
  %46 = icmp eq i64 %43, 0
  %47 = zext i1 %46 to i64
  %48 = select i1 %44, i64 %45, i64 %47
  ret i64 %48
}

; Function Attrs: nounwind uwtable
define internal fastcc void @read_long_string(%struct.LexState* nocapture, %union.SemInfo*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %5 = load i32, i32* %4, align 4, !tbaa !265
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %7)
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %9 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %10 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !242
  %12 = add i64 %11, -1
  store i64 %12, i64* %10, align 8, !tbaa !242
  %13 = icmp eq i64 %11, 0
  br i1 %13, label %20, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !243
  %17 = getelementptr inbounds i8, i8* %16, i64 1
  store i8* %17, i8** %15, align 8, !tbaa !243
  %18 = load i8, i8* %16, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  br label %22

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %9)
  br label %22

; <label>:22:                                     ; preds = %20, %14
  %23 = phi i32 [ %19, %14 ], [ %21, %20 ]
  store i32 %23, i32* %6, align 8, !tbaa !261
  switch i32 %23, label %25 [
    i32 10, label %24
    i32 13, label %24
  ]

; <label>:24:                                     ; preds = %22, %22
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0)
  br label %25

; <label>:25:                                     ; preds = %22, %24
  %26 = icmp eq %union.SemInfo* %1, null
  %27 = icmp eq %union.SemInfo* %1, null
  %28 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  br label %29

; <label>:29:                                     ; preds = %59, %25
  %30 = load i32, i32* %6, align 8, !tbaa !261
  switch i32 %30, label %63 [
    i32 -1, label %31
    i32 93, label %37
    i32 10, label %58
    i32 13, label %58
  ]

; <label>:31:                                     ; preds = %29
  %32 = icmp eq %union.SemInfo* %1, null
  %33 = select i1 %32, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.236, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i64 0, i64 0)
  %34 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %35 = load %struct.lua_State*, %struct.lua_State** %34, align 8, !tbaa !260
  %36 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %35, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.237, i64 0, i64 0), i8* %33, i32 %5)
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %36, i32 289) #17
  unreachable

; <label>:37:                                     ; preds = %29
  %38 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0)
  %39 = icmp eq i64 %38, %2
  br i1 %39, label %40, label %59

; <label>:40:                                     ; preds = %37
  %41 = load i32, i32* %6, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %41)
  %42 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %43 = getelementptr inbounds %struct.Zio, %struct.Zio* %42, i64 0, i32 0
  %44 = load i64, i64* %43, align 8, !tbaa !242
  %45 = add i64 %44, -1
  store i64 %45, i64* %43, align 8, !tbaa !242
  %46 = icmp eq i64 %44, 0
  br i1 %46, label %53, label %47

; <label>:47:                                     ; preds = %40
  %48 = getelementptr inbounds %struct.Zio, %struct.Zio* %42, i64 0, i32 1
  %49 = load i8*, i8** %48, align 8, !tbaa !243
  %50 = getelementptr inbounds i8, i8* %49, i64 1
  store i8* %50, i8** %48, align 8, !tbaa !243
  %51 = load i8, i8* %49, align 1, !tbaa !21
  %52 = zext i8 %51 to i32
  br label %55

; <label>:53:                                     ; preds = %40
  %54 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %42)
  br label %55

; <label>:55:                                     ; preds = %53, %47
  %56 = phi i32 [ %52, %47 ], [ %54, %53 ]
  store i32 %56, i32* %6, align 8, !tbaa !261
  %57 = icmp eq %union.SemInfo* %1, null
  br i1 %57, label %108, label %96

; <label>:58:                                     ; preds = %29, %29
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 10)
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0)
  br i1 %27, label %60, label %59

; <label>:59:                                     ; preds = %58, %78, %94, %60, %37
  br label %29

; <label>:60:                                     ; preds = %58
  %61 = load %struct.Mbuffer*, %struct.Mbuffer** %28, align 8, !tbaa !253
  %62 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %61, i64 0, i32 1
  store i64 0, i64* %62, align 8, !tbaa !299
  br label %59

; <label>:63:                                     ; preds = %29
  br i1 %26, label %80, label %64

; <label>:64:                                     ; preds = %63
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %30)
  %65 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %66 = getelementptr inbounds %struct.Zio, %struct.Zio* %65, i64 0, i32 0
  %67 = load i64, i64* %66, align 8, !tbaa !242
  %68 = add i64 %67, -1
  store i64 %68, i64* %66, align 8, !tbaa !242
  %69 = icmp eq i64 %67, 0
  br i1 %69, label %76, label %70

; <label>:70:                                     ; preds = %64
  %71 = getelementptr inbounds %struct.Zio, %struct.Zio* %65, i64 0, i32 1
  %72 = load i8*, i8** %71, align 8, !tbaa !243
  %73 = getelementptr inbounds i8, i8* %72, i64 1
  store i8* %73, i8** %71, align 8, !tbaa !243
  %74 = load i8, i8* %72, align 1, !tbaa !21
  %75 = zext i8 %74 to i32
  br label %78

; <label>:76:                                     ; preds = %64
  %77 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %65)
  br label %78

; <label>:78:                                     ; preds = %76, %70
  %79 = phi i32 [ %75, %70 ], [ %77, %76 ]
  store i32 %79, i32* %6, align 8, !tbaa !261
  br label %59

; <label>:80:                                     ; preds = %63
  %81 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !263
  %82 = getelementptr inbounds %struct.Zio, %struct.Zio* %81, i64 0, i32 0
  %83 = load i64, i64* %82, align 8, !tbaa !242
  %84 = add i64 %83, -1
  store i64 %84, i64* %82, align 8, !tbaa !242
  %85 = icmp eq i64 %83, 0
  br i1 %85, label %92, label %86

; <label>:86:                                     ; preds = %80
  %87 = getelementptr inbounds %struct.Zio, %struct.Zio* %81, i64 0, i32 1
  %88 = load i8*, i8** %87, align 8, !tbaa !243
  %89 = getelementptr inbounds i8, i8* %88, i64 1
  store i8* %89, i8** %87, align 8, !tbaa !243
  %90 = load i8, i8* %88, align 1, !tbaa !21
  %91 = zext i8 %90 to i32
  br label %94

; <label>:92:                                     ; preds = %80
  %93 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %81)
  br label %94

; <label>:94:                                     ; preds = %92, %86
  %95 = phi i32 [ %91, %86 ], [ %93, %92 ]
  store i32 %95, i32* %6, align 8, !tbaa !261
  br label %59

; <label>:96:                                     ; preds = %55
  %97 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %98 = load %struct.Mbuffer*, %struct.Mbuffer** %97, align 8, !tbaa !253
  %99 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %98, i64 0, i32 0
  %100 = load i8*, i8** %99, align 8, !tbaa !269
  %101 = getelementptr inbounds i8, i8* %100, i64 %2
  %102 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %98, i64 0, i32 1
  %103 = load i64, i64* %102, align 8, !tbaa !299
  %104 = shl i64 %2, 1
  %105 = sub i64 %103, %104
  %106 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %101, i64 %105)
  %107 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %106, %struct.TString** %107, align 8, !tbaa !21
  br label %108

; <label>:108:                                    ; preds = %55, %96
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @check_next1(%struct.LexState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !261
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %6, label %23

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !242
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !242
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %6
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !243
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !243
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %6
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8)
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %3, align 8, !tbaa !261
  br label %23

; <label>:23:                                     ; preds = %2, %21
  %24 = phi i32 [ 1, %21 ], [ 0, %2 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal fastcc void @read_string(%struct.LexState* nocapture, i32, %union.SemInfo* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %5)
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %7 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 0
  %9 = load i64, i64* %8, align 8, !tbaa !242
  %10 = add i64 %9, -1
  store i64 %10, i64* %8, align 8, !tbaa !242
  %11 = icmp eq i64 %9, 0
  br i1 %11, label %18, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 1
  %14 = load i8*, i8** %13, align 8, !tbaa !243
  %15 = getelementptr inbounds i8, i8* %14, i64 1
  store i8* %15, i8** %13, align 8, !tbaa !243
  %16 = load i8, i8* %14, align 1, !tbaa !21
  %17 = zext i8 %16 to i32
  br label %20

; <label>:18:                                     ; preds = %3
  %19 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %7)
  br label %20

; <label>:20:                                     ; preds = %18, %12
  %21 = phi i32 [ %17, %12 ], [ %19, %18 ]
  store i32 %21, i32* %4, align 8, !tbaa !261
  %22 = icmp eq i32 %21, %1
  br i1 %22, label %161, label %23

; <label>:23:                                     ; preds = %20
  %24 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  br label %26

; <label>:26:                                     ; preds = %23, %158
  %27 = phi i32 [ %21, %23 ], [ %159, %158 ]
  switch i32 %27, label %142 [
    i32 -1, label %28
    i32 10, label %29
    i32 13, label %29
    i32 92, label %30
  ]

; <label>:28:                                     ; preds = %26
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 289) #17
  unreachable

; <label>:29:                                     ; preds = %26, %26
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 293) #17
  unreachable

; <label>:30:                                     ; preds = %26
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %27)
  %31 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %32 = getelementptr inbounds %struct.Zio, %struct.Zio* %31, i64 0, i32 0
  %33 = load i64, i64* %32, align 8, !tbaa !242
  %34 = add i64 %33, -1
  store i64 %34, i64* %32, align 8, !tbaa !242
  %35 = icmp eq i64 %33, 0
  br i1 %35, label %42, label %36

; <label>:36:                                     ; preds = %30
  %37 = getelementptr inbounds %struct.Zio, %struct.Zio* %31, i64 0, i32 1
  %38 = load i8*, i8** %37, align 8, !tbaa !243
  %39 = getelementptr inbounds i8, i8* %38, i64 1
  store i8* %39, i8** %37, align 8, !tbaa !243
  %40 = load i8, i8* %38, align 1, !tbaa !21
  %41 = zext i8 %40 to i32
  br label %44

; <label>:42:                                     ; preds = %30
  %43 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %31)
  br label %44

; <label>:44:                                     ; preds = %42, %36
  %45 = phi i32 [ %41, %36 ], [ %43, %42 ]
  store i32 %45, i32* %4, align 8, !tbaa !261
  switch i32 %45, label %111 [
    i32 97, label %119
    i32 98, label %46
    i32 102, label %47
    i32 110, label %48
    i32 114, label %49
    i32 116, label %50
    i32 118, label %51
    i32 120, label %52
    i32 117, label %54
    i32 10, label %55
    i32 13, label %55
    i32 92, label %56
    i32 34, label %56
    i32 39, label %56
    i32 -1, label %158
    i32 122, label %57
  ]

; <label>:46:                                     ; preds = %44
  br label %119

; <label>:47:                                     ; preds = %44
  br label %119

; <label>:48:                                     ; preds = %44
  br label %119

; <label>:49:                                     ; preds = %44
  br label %119

; <label>:50:                                     ; preds = %44
  br label %119

; <label>:51:                                     ; preds = %44
  br label %119

; <label>:52:                                     ; preds = %44
  %53 = tail call fastcc i32 @readhexaesc(%struct.LexState* nonnull %0)
  br label %119

; <label>:54:                                     ; preds = %44
  tail call fastcc void @utf8esc(%struct.LexState* nonnull %0)
  br label %158

; <label>:55:                                     ; preds = %44, %44
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0)
  br label %136

; <label>:56:                                     ; preds = %44, %44, %44
  br label %119

; <label>:57:                                     ; preds = %44
  %58 = load %struct.Mbuffer*, %struct.Mbuffer** %25, align 8, !tbaa !253
  %59 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %58, i64 0, i32 1
  %60 = load i64, i64* %59, align 8, !tbaa !299
  %61 = add i64 %60, -1
  store i64 %61, i64* %59, align 8, !tbaa !299
  %62 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %63 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !242
  %65 = add i64 %64, -1
  store i64 %65, i64* %63, align 8, !tbaa !242
  %66 = icmp eq i64 %64, 0
  br i1 %66, label %73, label %67

; <label>:67:                                     ; preds = %57
  %68 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 1
  %69 = load i8*, i8** %68, align 8, !tbaa !243
  %70 = getelementptr inbounds i8, i8* %69, i64 1
  store i8* %70, i8** %68, align 8, !tbaa !243
  %71 = load i8, i8* %69, align 1, !tbaa !21
  %72 = zext i8 %71 to i32
  br label %75

; <label>:73:                                     ; preds = %57
  %74 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %62)
  br label %75

; <label>:75:                                     ; preds = %73, %67
  %76 = phi i32 [ %72, %67 ], [ %74, %73 ]
  store i32 %76, i32* %4, align 8, !tbaa !261
  %77 = add nsw i32 %76, 1
  %78 = sext i32 %77 to i64
  %79 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %78
  %80 = load i8, i8* %79, align 1, !tbaa !21
  %81 = and i8 %80, 8
  %82 = icmp eq i8 %81, 0
  br i1 %82, label %158, label %83

; <label>:83:                                     ; preds = %75
  br label %84

; <label>:84:                                     ; preds = %83, %103
  %85 = phi i32 [ %104, %103 ], [ %76, %83 ]
  switch i32 %85, label %87 [
    i32 10, label %86
    i32 13, label %86
  ]

; <label>:86:                                     ; preds = %84, %84
  tail call fastcc void @inclinenumber(%struct.LexState* %0)
  br label %103

; <label>:87:                                     ; preds = %84
  %88 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %89 = getelementptr inbounds %struct.Zio, %struct.Zio* %88, i64 0, i32 0
  %90 = load i64, i64* %89, align 8, !tbaa !242
  %91 = add i64 %90, -1
  store i64 %91, i64* %89, align 8, !tbaa !242
  %92 = icmp eq i64 %90, 0
  br i1 %92, label %99, label %93

; <label>:93:                                     ; preds = %87
  %94 = getelementptr inbounds %struct.Zio, %struct.Zio* %88, i64 0, i32 1
  %95 = load i8*, i8** %94, align 8, !tbaa !243
  %96 = getelementptr inbounds i8, i8* %95, i64 1
  store i8* %96, i8** %94, align 8, !tbaa !243
  %97 = load i8, i8* %95, align 1, !tbaa !21
  %98 = zext i8 %97 to i32
  br label %101

; <label>:99:                                     ; preds = %87
  %100 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %88)
  br label %101

; <label>:101:                                    ; preds = %99, %93
  %102 = phi i32 [ %98, %93 ], [ %100, %99 ]
  store i32 %102, i32* %4, align 8, !tbaa !261
  br label %103

; <label>:103:                                    ; preds = %101, %86
  %104 = load i32, i32* %4, align 8, !tbaa !261
  %105 = add nsw i32 %104, 1
  %106 = sext i32 %105 to i64
  %107 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %106
  %108 = load i8, i8* %107, align 1, !tbaa !21
  %109 = and i8 %108, 8
  %110 = icmp eq i8 %109, 0
  br i1 %110, label %158, label %84

; <label>:111:                                    ; preds = %44
  %112 = add nsw i32 %45, 1
  %113 = sext i32 %112 to i64
  %114 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %113
  %115 = load i8, i8* %114, align 1, !tbaa !21
  %116 = and i8 %115, 2
  %117 = zext i8 %116 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %117, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.239, i64 0, i64 0))
  %118 = tail call fastcc i32 @readdecesc(%struct.LexState* nonnull %0)
  br label %136

; <label>:119:                                    ; preds = %44, %56, %52, %51, %50, %49, %48, %47, %46
  %120 = phi i32 [ %45, %56 ], [ %53, %52 ], [ 11, %51 ], [ 9, %50 ], [ 13, %49 ], [ 10, %48 ], [ 12, %47 ], [ 8, %46 ], [ 7, %44 ]
  %121 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %122 = getelementptr inbounds %struct.Zio, %struct.Zio* %121, i64 0, i32 0
  %123 = load i64, i64* %122, align 8, !tbaa !242
  %124 = add i64 %123, -1
  store i64 %124, i64* %122, align 8, !tbaa !242
  %125 = icmp eq i64 %123, 0
  br i1 %125, label %132, label %126

; <label>:126:                                    ; preds = %119
  %127 = getelementptr inbounds %struct.Zio, %struct.Zio* %121, i64 0, i32 1
  %128 = load i8*, i8** %127, align 8, !tbaa !243
  %129 = getelementptr inbounds i8, i8* %128, i64 1
  store i8* %129, i8** %127, align 8, !tbaa !243
  %130 = load i8, i8* %128, align 1, !tbaa !21
  %131 = zext i8 %130 to i32
  br label %134

; <label>:132:                                    ; preds = %119
  %133 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %121)
  br label %134

; <label>:134:                                    ; preds = %132, %126
  %135 = phi i32 [ %131, %126 ], [ %133, %132 ]
  store i32 %135, i32* %4, align 8, !tbaa !261
  br label %136

; <label>:136:                                    ; preds = %134, %111, %55
  %137 = phi i32 [ %118, %111 ], [ %120, %134 ], [ 10, %55 ]
  %138 = load %struct.Mbuffer*, %struct.Mbuffer** %24, align 8, !tbaa !253
  %139 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %138, i64 0, i32 1
  %140 = load i64, i64* %139, align 8, !tbaa !299
  %141 = add i64 %140, -1
  store i64 %141, i64* %139, align 8, !tbaa !299
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %137)
  br label %158

; <label>:142:                                    ; preds = %26
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %27)
  %143 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %144 = getelementptr inbounds %struct.Zio, %struct.Zio* %143, i64 0, i32 0
  %145 = load i64, i64* %144, align 8, !tbaa !242
  %146 = add i64 %145, -1
  store i64 %146, i64* %144, align 8, !tbaa !242
  %147 = icmp eq i64 %145, 0
  br i1 %147, label %154, label %148

; <label>:148:                                    ; preds = %142
  %149 = getelementptr inbounds %struct.Zio, %struct.Zio* %143, i64 0, i32 1
  %150 = load i8*, i8** %149, align 8, !tbaa !243
  %151 = getelementptr inbounds i8, i8* %150, i64 1
  store i8* %151, i8** %149, align 8, !tbaa !243
  %152 = load i8, i8* %150, align 1, !tbaa !21
  %153 = zext i8 %152 to i32
  br label %156

; <label>:154:                                    ; preds = %142
  %155 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %143)
  br label %156

; <label>:156:                                    ; preds = %154, %148
  %157 = phi i32 [ %153, %148 ], [ %155, %154 ]
  store i32 %157, i32* %4, align 8, !tbaa !261
  br label %158

; <label>:158:                                    ; preds = %103, %75, %54, %136, %44, %156
  %159 = load i32, i32* %4, align 8, !tbaa !261
  %160 = icmp eq i32 %159, %1
  br i1 %160, label %161, label %26

; <label>:161:                                    ; preds = %158, %20
  %162 = phi i32 [ %21, %20 ], [ %159, %158 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %162)
  %163 = load %struct.Zio*, %struct.Zio** %6, align 8, !tbaa !263
  %164 = getelementptr inbounds %struct.Zio, %struct.Zio* %163, i64 0, i32 0
  %165 = load i64, i64* %164, align 8, !tbaa !242
  %166 = add i64 %165, -1
  store i64 %166, i64* %164, align 8, !tbaa !242
  %167 = icmp eq i64 %165, 0
  br i1 %167, label %174, label %168

; <label>:168:                                    ; preds = %161
  %169 = getelementptr inbounds %struct.Zio, %struct.Zio* %163, i64 0, i32 1
  %170 = load i8*, i8** %169, align 8, !tbaa !243
  %171 = getelementptr inbounds i8, i8* %170, i64 1
  store i8* %171, i8** %169, align 8, !tbaa !243
  %172 = load i8, i8* %170, align 1, !tbaa !21
  %173 = zext i8 %172 to i32
  br label %176

; <label>:174:                                    ; preds = %161
  %175 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %163)
  br label %176

; <label>:176:                                    ; preds = %174, %168
  %177 = phi i32 [ %173, %168 ], [ %175, %174 ]
  store i32 %177, i32* %4, align 8, !tbaa !261
  %178 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %179 = load %struct.Mbuffer*, %struct.Mbuffer** %178, align 8, !tbaa !253
  %180 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %179, i64 0, i32 0
  %181 = load i8*, i8** %180, align 8, !tbaa !269
  %182 = getelementptr inbounds i8, i8* %181, i64 1
  %183 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %179, i64 0, i32 1
  %184 = load i64, i64* %183, align 8, !tbaa !299
  %185 = add i64 %184, -2
  %186 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* nonnull %182, i64 %185)
  %187 = bitcast %union.SemInfo* %2 to %struct.TString**
  store %struct.TString* %186, %struct.TString** %187, align 8, !tbaa !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_numeral(%struct.LexState* nocapture, %union.SemInfo* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %6)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !242
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !242
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !243
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !243
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %2
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8)
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %5, align 8, !tbaa !261
  %23 = icmp eq i32 %6, 48
  br i1 %23, label %24, label %28

; <label>:24:                                     ; preds = %21
  %25 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.246, i64 0, i64 0))
  %26 = icmp eq i32 %25, 0
  %27 = select i1 %26, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.247, i64 0, i64 0)
  br label %28

; <label>:28:                                     ; preds = %24, %21
  %29 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), %21 ], [ %27, %24 ]
  br label %30

; <label>:30:                                     ; preds = %73, %28
  %31 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* %29)
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %35, label %33

; <label>:33:                                     ; preds = %30
  %34 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0))
  br label %35

; <label>:35:                                     ; preds = %30, %33
  %36 = load i32, i32* %5, align 8, !tbaa !261
  %37 = add nsw i32 %36, 1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %38
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = and i8 %40, 16
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %57, label %43

; <label>:43:                                     ; preds = %35
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36)
  %44 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %45 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 0
  %46 = load i64, i64* %45, align 8, !tbaa !242
  %47 = add i64 %46, -1
  store i64 %47, i64* %45, align 8, !tbaa !242
  %48 = icmp eq i64 %46, 0
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %43
  %50 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 1
  %51 = load i8*, i8** %50, align 8, !tbaa !243
  %52 = getelementptr inbounds i8, i8* %51, i64 1
  store i8* %52, i8** %50, align 8, !tbaa !243
  %53 = load i8, i8* %51, align 1, !tbaa !21
  %54 = zext i8 %53 to i32
  br label %73

; <label>:55:                                     ; preds = %43
  %56 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %44)
  br label %73

; <label>:57:                                     ; preds = %35
  %58 = icmp eq i32 %36, 46
  br i1 %58, label %59, label %75

; <label>:59:                                     ; preds = %57
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36)
  %60 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %61 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 0
  %62 = load i64, i64* %61, align 8, !tbaa !242
  %63 = add i64 %62, -1
  store i64 %63, i64* %61, align 8, !tbaa !242
  %64 = icmp eq i64 %62, 0
  br i1 %64, label %71, label %65

; <label>:65:                                     ; preds = %59
  %66 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 1
  %67 = load i8*, i8** %66, align 8, !tbaa !243
  %68 = getelementptr inbounds i8, i8* %67, i64 1
  store i8* %68, i8** %66, align 8, !tbaa !243
  %69 = load i8, i8* %67, align 1, !tbaa !21
  %70 = zext i8 %69 to i32
  br label %73

; <label>:71:                                     ; preds = %59
  %72 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %60)
  br label %73

; <label>:73:                                     ; preds = %65, %71, %49, %55
  %74 = phi i32 [ %54, %49 ], [ %56, %55 ], [ %70, %65 ], [ %72, %71 ]
  store i32 %74, i32* %5, align 8, !tbaa !261
  br label %30

; <label>:75:                                     ; preds = %57
  %76 = and i8 %40, 3
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %94, label %78

; <label>:78:                                     ; preds = %75
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36)
  %79 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !263
  %80 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 0
  %81 = load i64, i64* %80, align 8, !tbaa !242
  %82 = add i64 %81, -1
  store i64 %82, i64* %80, align 8, !tbaa !242
  %83 = icmp eq i64 %81, 0
  br i1 %83, label %90, label %84

; <label>:84:                                     ; preds = %78
  %85 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 1
  %86 = load i8*, i8** %85, align 8, !tbaa !243
  %87 = getelementptr inbounds i8, i8* %86, i64 1
  store i8* %87, i8** %85, align 8, !tbaa !243
  %88 = load i8, i8* %86, align 1, !tbaa !21
  %89 = zext i8 %88 to i32
  br label %92

; <label>:90:                                     ; preds = %78
  %91 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %79)
  br label %92

; <label>:92:                                     ; preds = %90, %84
  %93 = phi i32 [ %89, %84 ], [ %91, %90 ]
  store i32 %93, i32* %5, align 8, !tbaa !261
  br label %94

; <label>:94:                                     ; preds = %75, %92
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 0)
  %95 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %96 = load %struct.Mbuffer*, %struct.Mbuffer** %95, align 8, !tbaa !253
  %97 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %96, i64 0, i32 0
  %98 = load i8*, i8** %97, align 8, !tbaa !269
  %99 = call fastcc i64 @luaO_str2num(i8* %98, %struct.TValue* nonnull %3)
  %100 = icmp eq i64 %99, 0
  br i1 %100, label %101, label %102

; <label>:101:                                    ; preds = %94
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.249, i64 0, i64 0), i32 290) #17
  unreachable

; <label>:102:                                    ; preds = %94
  %103 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !22
  %105 = icmp eq i8 %104, 35
  %106 = bitcast %struct.TValue* %3 to i64*
  %107 = load i64, i64* %106, align 8, !tbaa !21
  %108 = bitcast %union.SemInfo* %1 to i64*
  store i64 %107, i64* %108, align 8, !tbaa !21
  %109 = select i1 %105, i32 291, i32 290
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %109
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @luaX_newstring(%struct.LexState* nocapture readonly, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  %6 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2)
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %7, align 8, !tbaa !20
  %10 = bitcast %union.StackValue* %8 to %struct.TString**
  store %struct.TString* %6, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %6, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !57
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 9
  %16 = load %struct.Table*, %struct.Table** %15, align 8, !tbaa !248
  %17 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0
  %19 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %5, %struct.Table* %16, %struct.TValue* nonnull %18)
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %32

; <label>:24:                                     ; preds = %3
  %25 = bitcast %struct.TValue* %19 to i32*
  store i32 1, i32* %25, align 8, !tbaa !21
  store i8 1, i8* %20, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %36

; <label>:31:                                     ; preds = %24
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %5)
  br label %36

; <label>:32:                                     ; preds = %3
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 1, i32 0, i32 0
  %34 = bitcast %struct.GCObject** %33 to %struct.TString**
  %35 = load %struct.TString*, %struct.TString** %34, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %24, %31, %32
  %37 = phi %struct.TString* [ %6, %31 ], [ %6, %24 ], [ %35, %32 ]
  %38 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -1
  store %union.StackValue* %39, %union.StackValue** %7, align 8, !tbaa !20
  ret %struct.TString* %37
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @readhexaesc(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = tail call fastcc i32 @gethexa(%struct.LexState* %0)
  %3 = shl i32 %2, 4
  %4 = tail call fastcc i32 @gethexa(%struct.LexState* %0)
  %5 = add nsw i32 %3, %4
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %7 = load %struct.Mbuffer*, %struct.Mbuffer** %6, align 8, !tbaa !253
  %8 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %7, i64 0, i32 1
  %9 = load i64, i64* %8, align 8, !tbaa !299
  %10 = add i64 %9, -2
  store i64 %10, i64* %8, align 8, !tbaa !299
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal fastcc void @utf8esc(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = alloca [8 x i8], align 1
  %3 = getelementptr inbounds [8 x i8], [8 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = tail call fastcc i64 @readutf8esc(%struct.LexState* %0)
  %5 = call fastcc i32 @luaO_utf8esc(i8* nonnull %3, i64 %4)
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %17

; <label>:7:                                      ; preds = %1
  %8 = sext i32 %5 to i64
  br label %9

; <label>:9:                                      ; preds = %7, %9
  %10 = phi i64 [ %8, %7 ], [ %15, %9 ]
  %11 = sub nsw i64 8, %10
  %12 = getelementptr inbounds [8 x i8], [8 x i8]* %2, i64 0, i64 %11
  %13 = load i8, i8* %12, align 1, !tbaa !21
  %14 = sext i8 %13 to i32
  tail call fastcc void @save(%struct.LexState* %0, i32 %14)
  %15 = add nsw i64 %10, -1
  %16 = icmp sgt i64 %10, 1
  br i1 %16, label %9, label %17

; <label>:17:                                     ; preds = %9, %1
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @esccheck(%struct.LexState* nocapture, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %27

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !261
  %8 = icmp eq i32 %7, -1
  br i1 %8, label %26, label %9

; <label>:9:                                      ; preds = %5
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %7)
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %11 = load %struct.Zio*, %struct.Zio** %10, align 8, !tbaa !263
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !242
  %14 = add i64 %13, -1
  store i64 %14, i64* %12, align 8, !tbaa !242
  %15 = icmp eq i64 %13, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %9
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 1
  %18 = load i8*, i8** %17, align 8, !tbaa !243
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  store i8* %19, i8** %17, align 8, !tbaa !243
  %20 = load i8, i8* %18, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %11)
  br label %24

; <label>:24:                                     ; preds = %22, %16
  %25 = phi i32 [ %21, %16 ], [ %23, %22 ]
  store i32 %25, i32* %6, align 8, !tbaa !261
  br label %26

; <label>:26:                                     ; preds = %5, %24
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %2, i32 293) #17
  unreachable

; <label>:27:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @readdecesc(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  br label %4

; <label>:4:                                      ; preds = %1, %29
  %5 = phi i32 [ 0, %1 ], [ %15, %29 ]
  %6 = phi i32 [ 0, %1 ], [ %31, %29 ]
  %7 = load i32, i32* %2, align 8, !tbaa !261
  %8 = add nsw i32 %7, 1
  %9 = sext i32 %8 to i64
  %10 = add nsw i64 %9, -49
  %11 = icmp ult i64 %10, 10
  br i1 %11, label %12, label %33

; <label>:12:                                     ; preds = %4
  %13 = mul nsw i32 %5, 10
  %14 = add i32 %13, -48
  %15 = add i32 %14, %7
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %7)
  %16 = load %struct.Zio*, %struct.Zio** %3, align 8, !tbaa !263
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %16, i64 0, i32 0
  %18 = load i64, i64* %17, align 8, !tbaa !242
  %19 = add i64 %18, -1
  store i64 %19, i64* %17, align 8, !tbaa !242
  %20 = icmp eq i64 %18, 0
  br i1 %20, label %27, label %21

; <label>:21:                                     ; preds = %12
  %22 = getelementptr inbounds %struct.Zio, %struct.Zio* %16, i64 0, i32 1
  %23 = load i8*, i8** %22, align 8, !tbaa !243
  %24 = getelementptr inbounds i8, i8* %23, i64 1
  store i8* %24, i8** %22, align 8, !tbaa !243
  %25 = load i8, i8* %23, align 1, !tbaa !21
  %26 = zext i8 %25 to i32
  br label %29

; <label>:27:                                     ; preds = %12
  %28 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %16)
  br label %29

; <label>:29:                                     ; preds = %27, %21
  %30 = phi i32 [ %26, %21 ], [ %28, %27 ]
  store i32 %30, i32* %2, align 8, !tbaa !261
  %31 = add nuw nsw i32 %6, 1
  %32 = icmp ult i32 %31, 3
  br i1 %32, label %4, label %33

; <label>:33:                                     ; preds = %29, %4
  %34 = phi i32 [ 3, %29 ], [ %6, %4 ]
  %35 = phi i32 [ %15, %29 ], [ %5, %4 ]
  %36 = icmp slt i32 %35, 256
  %37 = zext i1 %36 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %37, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.244, i64 0, i64 0))
  %38 = zext i32 %34 to i64
  %39 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %40 = load %struct.Mbuffer*, %struct.Mbuffer** %39, align 8, !tbaa !253
  %41 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %40, i64 0, i32 1
  %42 = load i64, i64* %41, align 8, !tbaa !299
  %43 = sub i64 %42, %38
  store i64 %43, i64* %41, align 8, !tbaa !299
  ret i32 %35
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @gethexa(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %3)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5)
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !261
  %20 = add nsw i32 %19, 1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %21
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = and i8 %23, 16
  %25 = zext i8 %24 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %25, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.240, i64 0, i64 0))
  %26 = load i32, i32* %2, align 8, !tbaa !261
  %27 = tail call fastcc i32 @luaO_hexavalue(i32 %26)
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @readutf8esc(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* %0, i32 %3)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !242
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !242
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !243
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !243
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5)
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !261
  %20 = icmp eq i32 %19, 123
  %21 = zext i1 %20 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %21, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.241, i64 0, i64 0))
  %22 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0)
  %23 = sext i32 %22 to i64
  br label %24

; <label>:24:                                     ; preds = %49, %18
  %25 = phi i64 [ %23, %18 ], [ %57, %49 ]
  %26 = phi i32 [ 4, %18 ], [ %50, %49 ]
  %27 = load i32, i32* %2, align 8, !tbaa !261
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %27)
  %28 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %29 = getelementptr inbounds %struct.Zio, %struct.Zio* %28, i64 0, i32 0
  %30 = load i64, i64* %29, align 8, !tbaa !242
  %31 = add i64 %30, -1
  store i64 %31, i64* %29, align 8, !tbaa !242
  %32 = icmp eq i64 %30, 0
  br i1 %32, label %39, label %33

; <label>:33:                                     ; preds = %24
  %34 = getelementptr inbounds %struct.Zio, %struct.Zio* %28, i64 0, i32 1
  %35 = load i8*, i8** %34, align 8, !tbaa !243
  %36 = getelementptr inbounds i8, i8* %35, i64 1
  store i8* %36, i8** %34, align 8, !tbaa !243
  %37 = load i8, i8* %35, align 1, !tbaa !21
  %38 = zext i8 %37 to i32
  br label %41

; <label>:39:                                     ; preds = %24
  %40 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %28)
  br label %41

; <label>:41:                                     ; preds = %39, %33
  %42 = phi i32 [ %38, %33 ], [ %40, %39 ]
  store i32 %42, i32* %2, align 8, !tbaa !261
  %43 = add nsw i32 %42, 1
  %44 = sext i32 %43 to i64
  %45 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %44
  %46 = load i8, i8* %45, align 1, !tbaa !21
  %47 = and i8 %46, 16
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %58, label %49

; <label>:49:                                     ; preds = %41
  %50 = add nuw nsw i32 %26, 1
  %51 = icmp ult i64 %25, 134217728
  %52 = zext i1 %51 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %52, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.242, i64 0, i64 0))
  %53 = shl i64 %25, 4
  %54 = load i32, i32* %2, align 8, !tbaa !261
  %55 = tail call fastcc i32 @luaO_hexavalue(i32 %54)
  %56 = sext i32 %55 to i64
  %57 = add i64 %53, %56
  br label %24

; <label>:58:                                     ; preds = %41
  %59 = icmp eq i32 %42, 125
  %60 = zext i1 %59 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %60, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.243, i64 0, i64 0))
  %61 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !263
  %62 = getelementptr inbounds %struct.Zio, %struct.Zio* %61, i64 0, i32 0
  %63 = load i64, i64* %62, align 8, !tbaa !242
  %64 = add i64 %63, -1
  store i64 %64, i64* %62, align 8, !tbaa !242
  %65 = icmp eq i64 %63, 0
  br i1 %65, label %72, label %66

; <label>:66:                                     ; preds = %58
  %67 = getelementptr inbounds %struct.Zio, %struct.Zio* %61, i64 0, i32 1
  %68 = load i8*, i8** %67, align 8, !tbaa !243
  %69 = getelementptr inbounds i8, i8* %68, i64 1
  store i8* %69, i8** %67, align 8, !tbaa !243
  %70 = load i8, i8* %68, align 1, !tbaa !21
  %71 = zext i8 %70 to i32
  br label %74

; <label>:72:                                     ; preds = %58
  %73 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %61)
  br label %74

; <label>:74:                                     ; preds = %72, %66
  %75 = phi i32 [ %71, %66 ], [ %73, %72 ]
  store i32 %75, i32* %2, align 8, !tbaa !261
  %76 = zext i32 %26 to i64
  %77 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %78 = load %struct.Mbuffer*, %struct.Mbuffer** %77, align 8, !tbaa !253
  %79 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %78, i64 0, i32 1
  %80 = load i64, i64* %79, align 8, !tbaa !299
  %81 = sub i64 %80, %76
  store i64 %81, i64* %79, align 8, !tbaa !299
  ret i64 %25
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @check_next2(%struct.LexState* nocapture, i8* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !261
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %13, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds i8, i8* %1, i64 1
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %4, %11
  br i1 %12, label %13, label %30

; <label>:13:                                     ; preds = %8, %2
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %4)
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %15 = load %struct.Zio*, %struct.Zio** %14, align 8, !tbaa !263
  %16 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !242
  %18 = add i64 %17, -1
  store i64 %18, i64* %16, align 8, !tbaa !242
  %19 = icmp eq i64 %17, 0
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %13
  %21 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 1
  %22 = load i8*, i8** %21, align 8, !tbaa !243
  %23 = getelementptr inbounds i8, i8* %22, i64 1
  store i8* %23, i8** %21, align 8, !tbaa !243
  %24 = load i8, i8* %22, align 1, !tbaa !21
  %25 = zext i8 %24 to i32
  br label %28

; <label>:26:                                     ; preds = %13
  %27 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %15)
  br label %28

; <label>:28:                                     ; preds = %26, %20
  %29 = phi i32 [ %25, %20 ], [ %27, %26 ]
  store i32 %29, i32* %3, align 8, !tbaa !261
  br label %30

; <label>:30:                                     ; preds = %8, %28
  %31 = phi i32 [ 1, %28 ], [ 0, %8 ]
  ret i32 %31
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @block_follow(%struct.LexState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  switch i32 %4, label %6 [
    i32 260, label %7
    i32 261, label %7
    i32 262, label %7
    i32 289, label %7
    i32 277, label %5
  ]

; <label>:5:                                      ; preds = %2
  br label %7

; <label>:6:                                      ; preds = %2
  br label %7

; <label>:7:                                      ; preds = %2, %2, %2, %2, %6, %5
  %8 = phi i32 [ 0, %6 ], [ %1, %5 ], [ 1, %2 ], [ 1, %2 ], [ 1, %2 ], [ 1, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc void @statement(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %3 = load i32, i32* %2, align 4, !tbaa !265
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %5)
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !259
  switch i32 %7, label %25 [
    i32 59, label %8
    i32 267, label %9
    i32 278, label %10
    i32 259, label %11
    i32 264, label %12
    i32 273, label %13
    i32 265, label %14
    i32 269, label %15
    i32 288, label %20
    i32 274, label %22
    i32 258, label %23
    i32 266, label %24
  ]

; <label>:8:                                      ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %26

; <label>:9:                                      ; preds = %1
  tail call fastcc void @ifstat(%struct.LexState* nonnull %0, i32 %3)
  br label %26

; <label>:10:                                     ; preds = %1
  tail call fastcc void @whilestat(%struct.LexState* nonnull %0, i32 %3)
  br label %26

; <label>:11:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  tail call fastcc void @block(%struct.LexState* nonnull %0)
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 259, i32 %3)
  br label %26

; <label>:12:                                     ; preds = %1
  tail call fastcc void @forstat(%struct.LexState* nonnull %0, i32 %3)
  br label %26

; <label>:13:                                     ; preds = %1
  tail call fastcc void @repeatstat(%struct.LexState* nonnull %0, i32 %3)
  br label %26

; <label>:14:                                     ; preds = %1
  tail call fastcc void @funcstat(%struct.LexState* nonnull %0, i32 %3)
  br label %26

; <label>:15:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %16 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 265)
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %19, label %18

; <label>:18:                                     ; preds = %15
  tail call fastcc void @localfunc(%struct.LexState* nonnull %0)
  br label %26

; <label>:19:                                     ; preds = %15
  tail call fastcc void @localstat(%struct.LexState* nonnull %0)
  br label %26

; <label>:20:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %21 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0)
  tail call fastcc void @labelstat(%struct.LexState* nonnull %0, %struct.TString* %21, i32 %3)
  br label %26

; <label>:22:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  tail call fastcc void @retstat(%struct.LexState* nonnull %0)
  br label %26

; <label>:23:                                     ; preds = %1
  tail call fastcc void @breakstat(%struct.LexState* nonnull %0)
  br label %26

; <label>:24:                                     ; preds = %1
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  tail call fastcc void @gotostat(%struct.LexState* nonnull %0)
  br label %26

; <label>:25:                                     ; preds = %1
  tail call fastcc void @exprstat(%struct.LexState* nonnull %0)
  br label %26

; <label>:26:                                     ; preds = %18, %19, %25, %24, %23, %22, %20, %14, %13, %12, %11, %10, %9, %8
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %28 = load %struct.FuncState*, %struct.FuncState** %27, align 8, !tbaa !264
  %29 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %28, i64 0, i32 13
  %30 = load i8, i8* %29, align 2, !tbaa !288
  %31 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %28, i64 0, i32 15
  store i8 %30, i8* %31, align 4, !tbaa !300
  %32 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %32, i64 0, i32 19
  %34 = load i32, i32* %33, align 8, !tbaa !40
  %35 = add i32 %34, -1
  store i32 %35, i32* %33, align 8, !tbaa !40
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @ifstat(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %6) #7
  store i32 -1, i32* %3, align 4, !tbaa !70
  call fastcc void @test_then_block(%struct.LexState* %0, i32* nonnull %3)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !259
  %9 = icmp eq i32 %8, 261
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %2
  br label %11

; <label>:11:                                     ; preds = %10, %11
  call fastcc void @test_then_block(%struct.LexState* nonnull %0, i32* nonnull %3)
  %12 = load i32, i32* %7, align 8, !tbaa !259
  %13 = icmp eq i32 %12, 261
  br i1 %13, label %11, label %14

; <label>:14:                                     ; preds = %11, %2
  %15 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 260)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %18, label %17

; <label>:17:                                     ; preds = %14
  tail call fastcc void @block(%struct.LexState* nonnull %0)
  br label %18

; <label>:18:                                     ; preds = %14, %17
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 267, i32 %1)
  %19 = load i32, i32* %3, align 4, !tbaa !70
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %5, i32 %19)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @whilestat(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  %7 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %5)
  %8 = tail call fastcc i32 @cond(%struct.LexState* %0)
  call fastcc void @enterblock(%struct.FuncState* %5, %struct.BlockCnt* nonnull %3, i8 zeroext 1)
  call fastcc void @checknext(%struct.LexState* %0, i32 259)
  call fastcc void @block(%struct.LexState* %0)
  %9 = call fastcc i32 @luaK_jump(%struct.FuncState* %5)
  call fastcc void @luaK_patchlist(%struct.FuncState* %5, i32 %9, i32 %7)
  call fastcc void @check_match(%struct.LexState* %0, i32 262, i32 278, i32 %1)
  call fastcc void @leaveblock(%struct.FuncState* %5)
  call fastcc void @luaK_patchtohere(%struct.FuncState* %5, i32 %8)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @block(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.BlockCnt, align 8
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = bitcast %struct.BlockCnt* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  call fastcc void @enterblock(%struct.FuncState* %4, %struct.BlockCnt* nonnull %2, i8 zeroext 0)
  call fastcc void @statlist(%struct.LexState* %0)
  call fastcc void @leaveblock(%struct.FuncState* %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @check_match(%struct.LexState*, i32, i32, i32) unnamed_addr #0 {
  %5 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 %1)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %18, !prof !33

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  %10 = icmp eq i32 %9, %3
  br i1 %10, label %11, label %12

; <label>:11:                                     ; preds = %7
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #17
  unreachable

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !260
  %15 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %1)
  %16 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %2)
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %14, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.266, i64 0, i64 0), i8* %15, i8* %16, i32 %3)
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* %17) #17
  unreachable

; <label>:18:                                     ; preds = %4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @forstat(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  call fastcc void @enterblock(%struct.FuncState* %5, %struct.BlockCnt* nonnull %3, i8 zeroext 1)
  call fastcc void @luaX_next(%struct.LexState* %0)
  %7 = call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !259
  switch i32 %9, label %12 [
    i32 61, label %10
    i32 44, label %11
    i32 268, label %11
  ]

; <label>:10:                                     ; preds = %2
  call fastcc void @fornum(%struct.LexState* nonnull %0, %struct.TString* %7, i32 %1)
  br label %13

; <label>:11:                                     ; preds = %2, %2
  call fastcc void @forlist(%struct.LexState* nonnull %0, %struct.TString* %7)
  br label %13

; <label>:12:                                     ; preds = %2
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.268, i64 0, i64 0)) #17
  unreachable

; <label>:13:                                     ; preds = %11, %10
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 264, i32 %1)
  call fastcc void @leaveblock(%struct.FuncState* %5)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @repeatstat(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.BlockCnt, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %6)
  %8 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = bitcast %struct.BlockCnt* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %9) #7
  call fastcc void @enterblock(%struct.FuncState* %6, %struct.BlockCnt* nonnull %3, i8 zeroext 1)
  call fastcc void @enterblock(%struct.FuncState* %6, %struct.BlockCnt* nonnull %4, i8 zeroext 0)
  call fastcc void @luaX_next(%struct.LexState* %0)
  call fastcc void @statlist(%struct.LexState* %0)
  call fastcc void @check_match(%struct.LexState* %0, i32 277, i32 273, i32 %1)
  %10 = call fastcc i32 @cond(%struct.LexState* %0)
  call fastcc void @leaveblock(%struct.FuncState* %6)
  %11 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %4, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !295
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %21, label %14

; <label>:14:                                     ; preds = %2
  %15 = call fastcc i32 @luaK_jump(%struct.FuncState* %6)
  call fastcc void @luaK_patchtohere(%struct.FuncState* %6, i32 %10)
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %4, i64 0, i32 3
  %17 = load i8, i8* %16, align 8, !tbaa !292
  %18 = zext i8 %17 to i32
  %19 = call fastcc i32 @luaK_codeABCk(%struct.FuncState* %6, i32 55, i32 %18, i32 0, i32 0, i32 0)
  %20 = call fastcc i32 @luaK_jump(%struct.FuncState* %6)
  call fastcc void @luaK_patchtohere(%struct.FuncState* %6, i32 %15)
  br label %21

; <label>:21:                                     ; preds = %2, %14
  %22 = phi i32 [ %20, %14 ], [ %10, %2 ]
  call fastcc void @luaK_patchlist(%struct.FuncState* %6, i32 %22, i32 %7)
  call fastcc void @leaveblock(%struct.FuncState* %6)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @funcstat(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  %7 = call fastcc i32 @funcname(%struct.LexState* %0, %struct.expdesc* nonnull %3)
  call fastcc void @body(%struct.LexState* %0, %struct.expdesc* nonnull %4, i32 %7, i32 %1)
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  call fastcc void @luaK_storevar(%struct.FuncState* %9, %struct.expdesc* nonnull %3, %struct.expdesc* nonnull %4)
  %10 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  tail call fastcc void @luaK_fixline(%struct.FuncState* %10, i32 %1)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @testnext(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %7

; <label>:7:                                      ; preds = %2, %6
  %8 = phi i32 [ 1, %6 ], [ 0, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc void @localfunc(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %6)
  tail call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 1)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !265
  call fastcc void @body(%struct.LexState* %0, %struct.expdesc* nonnull %2, i32 0, i32 %8)
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 4
  %10 = load i32, i32* %9, align 8, !tbaa !273
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %12 = bitcast %union.anon.8* %11 to i32*
  %13 = load i32, i32* %12, align 8, !tbaa !21
  %14 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %5, i32 %13)
  %15 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %14, i64 0, i32 1
  store i32 %10, i32* %15, align 8, !tbaa !85
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @localstat(%struct.LexState*) unnamed_addr #0 {
  %2 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 42)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call fastcc void @tocloselocalstat(%struct.LexState* %0)
  br label %6

; <label>:5:                                      ; preds = %1
  tail call fastcc void @commonlocalstat(%struct.LexState* %0)
  br label %6

; <label>:6:                                      ; preds = %5, %4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @labelstat(%struct.LexState*, %struct.TString*, i32) unnamed_addr #0 {
  tail call fastcc void @checknext(%struct.LexState* %0, i32 288)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %5

; <label>:5:                                      ; preds = %7, %3
  %6 = load i32, i32* %4, align 8, !tbaa !259
  switch i32 %6, label %8 [
    i32 288, label %7
    i32 59, label %7
  ]

; <label>:7:                                      ; preds = %5, %5
  tail call fastcc void @statement(%struct.LexState* nonnull %0)
  br label %5

; <label>:8:                                      ; preds = %5
  tail call fastcc void @checkrepeated(%struct.LexState* nonnull %0, %struct.TString* %1)
  %9 = tail call fastcc i32 @block_follow(%struct.LexState* nonnull %0, i32 0)
  %10 = tail call fastcc i32 @createlabel(%struct.LexState* nonnull %0, %struct.TString* %1, i32 %2, i32 %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.TString* @str_checkname(%struct.LexState*) unnamed_addr #0 {
  tail call fastcc void @check(%struct.LexState* %0, i32 292)
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %3 = bitcast %union.SemInfo* %2 to %struct.TString**
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !21
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  ret %struct.TString* %4
}

; Function Attrs: nounwind uwtable
define internal fastcc void @retstat(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 13
  %7 = load i8, i8* %6, align 2, !tbaa !288
  %8 = zext i8 %7 to i32
  %9 = tail call fastcc i32 @block_follow(%struct.LexState* %0, i32 1)
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %50

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %13 = load i32, i32* %12, align 8, !tbaa !259
  %14 = icmp eq i32 %13, 59
  br i1 %14, label %50, label %15

; <label>:15:                                     ; preds = %11
  %16 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %2)
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %18 = load i32, i32* %17, align 8, !tbaa !285
  %19 = and i32 %18, -2
  %20 = icmp eq i32 %19, 16
  br i1 %20, label %21, label %45

; <label>:21:                                     ; preds = %15
  call fastcc void @luaK_setreturns(%struct.FuncState* %4, %struct.expdesc* nonnull %2, i32 -1)
  %22 = load i32, i32* %17, align 8, !tbaa !285
  %23 = icmp eq i32 %22, 16
  %24 = icmp eq i32 %16, 1
  %25 = and i1 %24, %23
  br i1 %25, label %26, label %50

; <label>:26:                                     ; preds = %21
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 3
  %28 = load %struct.BlockCnt*, %struct.BlockCnt** %27, align 8, !tbaa !281
  %29 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %28, i64 0, i32 6
  %30 = load i8, i8* %29, align 1, !tbaa !296
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %50

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %34 = load %struct.Proto*, %struct.Proto** %33, align 8, !tbaa !251
  %35 = getelementptr inbounds %struct.Proto, %struct.Proto* %34, i64 0, i32 16
  %36 = load i32*, i32** %35, align 8, !tbaa !134
  %37 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %38 = bitcast %union.anon.8* %37 to i32*
  %39 = load i32, i32* %38, align 8, !tbaa !21
  %40 = sext i32 %39 to i64
  %41 = getelementptr inbounds i32, i32* %36, i64 %40
  %42 = load i32, i32* %41, align 4, !tbaa !70
  %43 = and i32 %42, -128
  %44 = or i32 %43, 70
  store i32 %44, i32* %41, align 4, !tbaa !70
  br label %50

; <label>:45:                                     ; preds = %15
  %46 = icmp eq i32 %16, 1
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %45
  %48 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %4, %struct.expdesc* nonnull %2)
  br label %50

; <label>:49:                                     ; preds = %45
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %4, %struct.expdesc* nonnull %2)
  br label %50

; <label>:50:                                     ; preds = %21, %32, %26, %11, %1, %49, %47
  %51 = phi i32 [ 1, %47 ], [ %16, %49 ], [ 0, %1 ], [ 0, %11 ], [ -1, %26 ], [ -1, %32 ], [ -1, %21 ]
  %52 = phi i32 [ %48, %47 ], [ %8, %49 ], [ %8, %1 ], [ %8, %11 ], [ %8, %26 ], [ %8, %32 ], [ %8, %21 ]
  call fastcc void @luaK_ret(%struct.FuncState* %4, i32 %52, i32 %51)
  %53 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 59)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @breakstat(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %3 = load i32, i32* %2, align 4, !tbaa !265
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !260
  %6 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %8 = load %struct.FuncState*, %struct.FuncState** %7, align 8, !tbaa !264
  %9 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %8)
  tail call fastcc void @newgotoentry(%struct.LexState* %0, %struct.TString* %6, i32 %3, i32 %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @gotostat(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %3 = load %struct.FuncState*, %struct.FuncState** %2, align 8, !tbaa !264
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %5 = load i32, i32* %4, align 4, !tbaa !265
  %6 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  %7 = tail call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* %0, %struct.TString* %6)
  %8 = icmp eq %struct.Labeldesc* %7, null
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %1
  %10 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %3)
  tail call fastcc void @newgotoentry(%struct.LexState* nonnull %0, %struct.TString* %6, i32 %5, i32 %10)
  br label %24

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %3, i64 0, i32 13
  %13 = load i8, i8* %12, align 2, !tbaa !288
  %14 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %7, i64 0, i32 3
  %15 = load i8, i8* %14, align 8, !tbaa !301
  %16 = icmp ugt i8 %13, %15
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %11
  %18 = zext i8 %15 to i32
  %19 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* nonnull %3, i32 55, i32 %18, i32 0, i32 0, i32 0)
  br label %20

; <label>:20:                                     ; preds = %17, %11
  %21 = tail call fastcc i32 @luaK_jump(%struct.FuncState* nonnull %3)
  %22 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %7, i64 0, i32 1
  %23 = load i32, i32* %22, align 8, !tbaa !303
  tail call fastcc void @luaK_patchlist(%struct.FuncState* nonnull %3, i32 %21, i32 %23)
  br label %24

; <label>:24:                                     ; preds = %20, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @exprstat(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.LHS_assign, align 8
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = bitcast %struct.LHS_assign* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* %0, %struct.expdesc* nonnull %6)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !259
  switch i32 %8, label %11 [
    i32 61, label %9
    i32 44, label %9
  ]

; <label>:9:                                      ; preds = %1, %1
  %10 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 0
  store %struct.LHS_assign* null, %struct.LHS_assign** %10, align 8, !tbaa !304
  call fastcc void @restassign(%struct.LexState* nonnull %0, %struct.LHS_assign* nonnull %2, i32 1)
  br label %29

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %13 = load %struct.Proto*, %struct.Proto** %12, align 8, !tbaa !251
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %13, i64 0, i32 16
  %15 = load i32*, i32** %14, align 8, !tbaa !134
  %16 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %2, i64 0, i32 1, i32 1
  %17 = bitcast %union.anon.8* %16 to i32*
  %18 = load i32, i32* %17, align 8, !tbaa !21
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i32, i32* %15, i64 %19
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %6, i64 0, i32 0
  %22 = load i32, i32* %21, align 8, !tbaa !306
  %23 = icmp eq i32 %22, 16
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %11
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #17
  unreachable

; <label>:25:                                     ; preds = %11
  %26 = load i32, i32* %20, align 4, !tbaa !70
  %27 = and i32 %26, 16777215
  %28 = or i32 %27, 16777216
  store i32 %28, i32* %20, align 4, !tbaa !70
  br label %29

; <label>:29:                                     ; preds = %25, %9
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @test_then_block(%struct.LexState*, i32* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.TString*, align 8
  %5 = alloca i32, align 4
  %6 = alloca %struct.expdesc, align 8
  %7 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  %10 = bitcast %struct.TString** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %10) #7
  store %struct.TString* null, %struct.TString** %4, align 8, !tbaa !79
  %11 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %11) #7
  store i32 -1, i32* %5, align 4, !tbaa !70
  %12 = bitcast %struct.expdesc* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %12) #7
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %6)
  call fastcc void @checknext(%struct.LexState* %0, i32 275)
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %14 = load i32, i32* %13, align 4, !tbaa !265
  %15 = call fastcc i32 @issinglejump(%struct.LexState* %0, %struct.TString** nonnull %4, i32* nonnull %5)
  %16 = icmp eq i32 %15, 0
  %17 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  br i1 %16, label %36, label %18

; <label>:18:                                     ; preds = %2
  call fastcc void @luaK_goiffalse(%struct.FuncState* %17, %struct.expdesc* nonnull %6)
  call fastcc void @enterblock(%struct.FuncState* %9, %struct.BlockCnt* nonnull %3, i8 zeroext 0)
  %19 = load %struct.TString*, %struct.TString** %4, align 8, !tbaa !79
  %20 = icmp eq %struct.TString* %19, null
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %6, i64 0, i32 2
  %22 = load i32, i32* %21, align 8, !tbaa !282
  br i1 %20, label %24, label %23

; <label>:23:                                     ; preds = %18
  call fastcc void @newgotoentry(%struct.LexState* nonnull %0, %struct.TString* nonnull %19, i32 %14, i32 %22)
  br label %26

; <label>:24:                                     ; preds = %18
  %25 = load i32, i32* %5, align 4, !tbaa !70
  call fastcc void @luaK_patchlist(%struct.FuncState* %9, i32 %22, i32 %25)
  br label %26

; <label>:26:                                     ; preds = %24, %23
  br label %27

; <label>:27:                                     ; preds = %26, %27
  %28 = call fastcc i32 @testnext(%struct.LexState* %0, i32 59)
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %30, label %27

; <label>:30:                                     ; preds = %27
  %31 = call fastcc i32 @block_follow(%struct.LexState* %0, i32 0)
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %34, label %33

; <label>:33:                                     ; preds = %30
  call fastcc void @leaveblock(%struct.FuncState* %9)
  br label %48

; <label>:34:                                     ; preds = %30
  %35 = call fastcc i32 @luaK_jump(%struct.FuncState* %9)
  br label %39

; <label>:36:                                     ; preds = %2
  call fastcc void @luaK_goiftrue(%struct.FuncState* %17, %struct.expdesc* nonnull %6)
  call fastcc void @enterblock(%struct.FuncState* %9, %struct.BlockCnt* nonnull %3, i8 zeroext 0)
  %37 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %6, i64 0, i32 3
  %38 = load i32, i32* %37, align 4, !tbaa !284
  br label %39

; <label>:39:                                     ; preds = %36, %34
  %40 = phi i32 [ %35, %34 ], [ %38, %36 ]
  call fastcc void @statlist(%struct.LexState* %0)
  call fastcc void @leaveblock(%struct.FuncState* %9)
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %42 = load i32, i32* %41, align 8, !tbaa !259
  %43 = and i32 %42, -2
  %44 = icmp eq i32 %43, 260
  br i1 %44, label %45, label %47

; <label>:45:                                     ; preds = %39
  %46 = call fastcc i32 @luaK_jump(%struct.FuncState* %9)
  call fastcc void @luaK_concat(%struct.FuncState* %9, i32* %1, i32 %46)
  br label %47

; <label>:47:                                     ; preds = %39, %45
  call fastcc void @luaK_patchtohere(%struct.FuncState* %9, i32 %40)
  br label %48

; <label>:48:                                     ; preds = %47, %33
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_patchtohere(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %0)
  tail call fastcc void @luaK_patchlist(%struct.FuncState* %0, i32 %1, i32 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @expr(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = tail call fastcc i32 @subexpr(%struct.LexState* %0, %struct.expdesc* %1, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checknext(%struct.LexState*, i32) unnamed_addr #0 {
  tail call fastcc void @check(%struct.LexState* %0, i32 %1)
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @issinglejump(%struct.LexState*, %struct.TString** nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 258)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %8 = load %struct.lua_State*, %struct.lua_State** %7, align 8, !tbaa !260
  %9 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5)
  store %struct.TString* %9, %struct.TString** %1, align 8, !tbaa !79
  br label %36

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %12 = load i32, i32* %11, align 8, !tbaa !259
  %13 = icmp eq i32 %12, 266
  br i1 %13, label %14, label %36

; <label>:14:                                     ; preds = %10
  %15 = tail call fastcc i32 @luaX_lookahead(%struct.LexState* nonnull %0)
  %16 = icmp eq i32 %15, 292
  br i1 %16, label %17, label %36

; <label>:17:                                     ; preds = %14
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %19 = bitcast %union.SemInfo* %18 to %struct.TString**
  %20 = load %struct.TString*, %struct.TString** %19, align 8, !tbaa !21
  %21 = tail call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nonnull %0, %struct.TString* %20)
  %22 = icmp eq %struct.Labeldesc* %21, null
  br i1 %22, label %34, label %23

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %25 = load %struct.FuncState*, %struct.FuncState** %24, align 8, !tbaa !264
  %26 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %25, i64 0, i32 13
  %27 = load i8, i8* %26, align 2, !tbaa !288
  %28 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %21, i64 0, i32 3
  %29 = load i8, i8* %28, align 8, !tbaa !301
  %30 = icmp ugt i8 %27, %29
  br i1 %30, label %36, label %31

; <label>:31:                                     ; preds = %23
  %32 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %21, i64 0, i32 1
  %33 = load i32, i32* %32, align 8, !tbaa !303
  store i32 %33, i32* %2, align 4, !tbaa !70
  br label %35

; <label>:34:                                     ; preds = %17
  store %struct.TString* %20, %struct.TString** %1, align 8, !tbaa !79
  br label %35

; <label>:35:                                     ; preds = %34, %31
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %36

; <label>:36:                                     ; preds = %35, %23, %10, %14, %6
  %37 = phi i32 [ 1, %6 ], [ 0, %14 ], [ 0, %10 ], [ 1, %35 ], [ 0, %23 ]
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_goiffalse(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  switch i32 %4, label %9 [
    i32 14, label %5
    i32 1, label %11
    i32 3, label %11
  ]

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  br label %11

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 1)
  br label %11

; <label>:11:                                     ; preds = %2, %2, %9, %5
  %12 = phi i32 [ %10, %9 ], [ %8, %5 ], [ -1, %2 ], [ -1, %2 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %12)
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !284
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %15)
  store i32 -1, i32* %14, align 4, !tbaa !284
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @newgotoentry(%struct.LexState* nocapture readonly, %struct.TString*, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 1
  %8 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %7, %struct.TString* %1, i32 %2, i32 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_patchlist(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #0 {
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %1, i32 %2, i32 255, i32 %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @leaveblock(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  %3 = load %struct.BlockCnt*, %struct.BlockCnt** %2, align 8, !tbaa !281
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  %7 = load i8, i8* %6, align 2, !tbaa !290
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !260
  %12 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5)
  %13 = tail call fastcc i32 @createlabel(%struct.LexState* %5, %struct.TString* %12, i32 0, i32 0)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %28

; <label>:15:                                     ; preds = %9, %1
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 0
  %17 = load %struct.BlockCnt*, %struct.BlockCnt** %16, align 8, !tbaa !297
  %18 = icmp eq %struct.BlockCnt* %17, null
  br i1 %18, label %28, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  %21 = load i8, i8* %20, align 1, !tbaa !295
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %28, label %23

; <label>:23:                                     ; preds = %19
  %24 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %25 = load i8, i8* %24, align 8, !tbaa !292
  %26 = zext i8 %25 to i32
  %27 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* nonnull %0, i32 55, i32 %26, i32 0, i32 0, i32 0)
  br label %28

; <label>:28:                                     ; preds = %9, %19, %15, %23
  %29 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 0
  %30 = bitcast %struct.BlockCnt* %3 to i64*
  %31 = load i64, i64* %30, align 8, !tbaa !297
  %32 = bitcast %struct.BlockCnt** %2 to i64*
  store i64 %31, i64* %32, align 8, !tbaa !281
  %33 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %34 = load i8, i8* %33, align 8, !tbaa !292
  %35 = zext i8 %34 to i32
  tail call fastcc void @removevars(%struct.FuncState* nonnull %0, i32 %35)
  %36 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %37 = load i8, i8* %36, align 2, !tbaa !288
  %38 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %37, i8* %38, align 4, !tbaa !300
  %39 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  %40 = load i32, i32* %39, align 8, !tbaa !293
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 10
  %42 = load %struct.Dyndata*, %struct.Dyndata** %41, align 8, !tbaa !254
  %43 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 2, i32 1
  store i32 %40, i32* %43, align 8, !tbaa !255
  %44 = load %struct.BlockCnt*, %struct.BlockCnt** %29, align 8, !tbaa !297
  %45 = icmp eq %struct.BlockCnt* %44, null
  br i1 %45, label %47, label %46

; <label>:46:                                     ; preds = %28
  tail call fastcc void @movegotosout(%struct.FuncState* nonnull %0, %struct.BlockCnt* nonnull %3)
  br label %58

; <label>:47:                                     ; preds = %28
  %48 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  %49 = load i32, i32* %48, align 4, !tbaa !294
  %50 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 1
  %51 = load i32, i32* %50, align 8, !tbaa !256
  %52 = icmp slt i32 %49, %51
  br i1 %52, label %53, label %58

; <label>:53:                                     ; preds = %47
  %54 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 0
  %55 = load %struct.Labeldesc*, %struct.Labeldesc** %54, align 8, !tbaa !307
  %56 = sext i32 %49 to i64
  %57 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %55, i64 %56
  tail call fastcc void @undefgoto(%struct.LexState* nonnull %5, %struct.Labeldesc* %57) #17
  unreachable

; <label>:58:                                     ; preds = %47, %46
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_jump(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = tail call fastcc i32 @codesJ(%struct.FuncState* %0)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_goiftrue(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  switch i32 %4, label %9 [
    i32 14, label %5
    i32 4, label %11
    i32 5, label %11
    i32 6, label %11
    i32 2, label %11
  ]

; <label>:5:                                      ; preds = %2
  tail call fastcc void @negatecondition(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  br label %11

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 0)
  br label %11

; <label>:11:                                     ; preds = %2, %2, %2, %2, %9, %5
  %12 = phi i32 [ %10, %9 ], [ %8, %5 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %12)
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %15 = load i32, i32* %14, align 8, !tbaa !282
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %15)
  store i32 -1, i32* %14, align 8, !tbaa !282
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_concat(%struct.FuncState* nocapture readonly, i32* nocapture, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, -1
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i32, i32* %1, align 4, !tbaa !70
  %7 = icmp eq i32 %6, -1
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  br label %10

; <label>:9:                                      ; preds = %5
  store i32 %2, i32* %1, align 4, !tbaa !70
  br label %15

; <label>:10:                                     ; preds = %8, %10
  %11 = phi i32 [ %12, %10 ], [ %6, %8 ]
  %12 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %11)
  %13 = icmp eq i32 %12, -1
  br i1 %13, label %14, label %10

; <label>:14:                                     ; preds = %10
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %11, i32 %2)
  br label %15

; <label>:15:                                     ; preds = %9, %14, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @subexpr(%struct.LexState*, %struct.expdesc*, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %6 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !260
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %6)
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !259
  %9 = tail call fastcc i32 @getunopr(i32 %8)
  %10 = icmp eq i32 %9, 4
  br i1 %10, label %17, label %11

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %13 = load i32, i32* %12, align 4, !tbaa !265
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %14 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 12)
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %16 = load %struct.FuncState*, %struct.FuncState** %15, align 8, !tbaa !264
  tail call fastcc void @luaK_prefix(%struct.FuncState* %16, i32 %9, %struct.expdesc* %1, i32 %13)
  br label %18

; <label>:17:                                     ; preds = %3
  tail call fastcc void @simpleexp(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %18

; <label>:18:                                     ; preds = %17, %11
  %19 = load i32, i32* %7, align 8, !tbaa !259
  %20 = tail call fastcc i32 @getbinopr(i32 %19)
  %21 = icmp eq i32 %20, 21
  br i1 %21, label %42, label %22

; <label>:22:                                     ; preds = %18
  %23 = bitcast %struct.expdesc* %4 to i8*
  %24 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  br label %26

; <label>:26:                                     ; preds = %22, %33
  %27 = phi i32 [ %20, %22 ], [ %39, %33 ]
  %28 = zext i32 %27 to i64
  %29 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %28, i32 0
  %30 = load i8, i8* %29, align 2, !tbaa !308
  %31 = zext i8 %30 to i32
  %32 = icmp sgt i32 %31, %2
  br i1 %32, label %33, label %42

; <label>:33:                                     ; preds = %26
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %23) #7
  %34 = load i32, i32* %24, align 4, !tbaa !265
  call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %35 = load %struct.FuncState*, %struct.FuncState** %25, align 8, !tbaa !264
  call fastcc void @luaK_infix(%struct.FuncState* %35, i32 %27, %struct.expdesc* %1)
  %36 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %28, i32 1
  %37 = load i8, i8* %36, align 1, !tbaa !310
  %38 = zext i8 %37 to i32
  %39 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4, i32 %38)
  %40 = load %struct.FuncState*, %struct.FuncState** %25, align 8, !tbaa !264
  call fastcc void @luaK_posfix(%struct.FuncState* %40, i32 %27, %struct.expdesc* %1, %struct.expdesc* nonnull %4, i32 %34)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %23) #7
  %41 = icmp eq i32 %39, 21
  br i1 %41, label %42, label %26

; <label>:42:                                     ; preds = %26, %33, %18
  %43 = phi i32 [ 21, %18 ], [ 21, %33 ], [ %27, %26 ]
  %44 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !260
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %44, i64 0, i32 19
  %46 = load i32, i32* %45, align 8, !tbaa !40
  %47 = add i32 %46, -1
  store i32 %47, i32* %45, align 8, !tbaa !40
  ret i32 %43
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @getunopr(i32) unnamed_addr #6 {
  switch i32 %0, label %5 [
    i32 271, label %6
    i32 45, label %2
    i32 126, label %3
    i32 35, label %4
  ]

; <label>:2:                                      ; preds = %1
  br label %6

; <label>:3:                                      ; preds = %1
  br label %6

; <label>:4:                                      ; preds = %1
  br label %6

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %1, %5, %4, %3, %2
  %7 = phi i32 [ 4, %5 ], [ 3, %4 ], [ 1, %3 ], [ 0, %2 ], [ 2, %1 ]
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_prefix(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  switch i32 %1, label %12 [
    i32 0, label %5
    i32 1, label %5
    i32 3, label %9
    i32 2, label %11
  ]

; <label>:5:                                      ; preds = %4, %4
  %6 = add i32 %1, 12
  %7 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 %6, %struct.expdesc* %2, %struct.expdesc* nonnull @luaK_prefix.ef)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %5, %4
  %10 = add i32 %1, 50
  tail call fastcc void @codeunexpval(%struct.FuncState* %0, i32 %10, %struct.expdesc* %2, i32 %3)
  br label %12

; <label>:11:                                     ; preds = %4
  tail call fastcc void @codenot(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %12

; <label>:12:                                     ; preds = %5, %4, %11, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @simpleexp(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  switch i32 %4, label %37 [
    i32 290, label %5
    i32 291, label %10
    i32 293, label %15
    i32 270, label %19
    i32 276, label %20
    i32 263, label %21
    i32 281, label %22
    i32 123, label %33
    i32 265, label %34
  ]

; <label>:5:                                      ; preds = %2
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 5, i32 0)
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1, i32 0
  %7 = bitcast double* %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %8, i64* %9, align 8, !tbaa !21
  br label %38

; <label>:10:                                     ; preds = %2
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 6, i32 0)
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %12 = bitcast %union.SemInfo* %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %13, i64* %14, align 8, !tbaa !21
  br label %38

; <label>:15:                                     ; preds = %2
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %17 = bitcast %union.SemInfo* %16 to %struct.TString**
  %18 = load %struct.TString*, %struct.TString** %17, align 8, !tbaa !21
  tail call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* %1, %struct.TString* %18)
  br label %38

; <label>:19:                                     ; preds = %2
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 1, i32 0)
  br label %38

; <label>:20:                                     ; preds = %2
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 2, i32 0)
  br label %38

; <label>:21:                                     ; preds = %2
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 3, i32 0)
  br label %38

; <label>:22:                                     ; preds = %2
  %23 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %24 = load %struct.FuncState*, %struct.FuncState** %23, align 8, !tbaa !264
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %24, i64 0, i32 0
  %26 = load %struct.Proto*, %struct.Proto** %25, align 8, !tbaa !251
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 4
  %28 = load i8, i8* %27, align 1, !tbaa !94
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %30, label %31

; <label>:30:                                     ; preds = %22
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.253, i64 0, i64 0)) #17
  unreachable

; <label>:31:                                     ; preds = %22
  %32 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %24, i32 81, i32 0, i32 0, i32 1, i32 0)
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 17, i32 %32)
  br label %38

; <label>:33:                                     ; preds = %2
  tail call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %39

; <label>:34:                                     ; preds = %2
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %35 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %36 = load i32, i32* %35, align 4, !tbaa !265
  tail call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0, i32 %36)
  br label %39

; <label>:37:                                     ; preds = %2
  tail call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %39

; <label>:38:                                     ; preds = %31, %21, %20, %19, %15, %10, %5
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %39

; <label>:39:                                     ; preds = %38, %37, %34, %33
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @getbinopr(i32) unnamed_addr #6 {
  switch i32 %0, label %22 [
    i32 43, label %23
    i32 45, label %2
    i32 42, label %3
    i32 37, label %4
    i32 94, label %5
    i32 47, label %6
    i32 279, label %7
    i32 38, label %8
    i32 124, label %9
    i32 126, label %10
    i32 286, label %11
    i32 287, label %12
    i32 280, label %13
    i32 285, label %14
    i32 282, label %15
    i32 60, label %16
    i32 284, label %17
    i32 62, label %18
    i32 283, label %19
    i32 257, label %20
    i32 272, label %21
  ]

; <label>:2:                                      ; preds = %1
  br label %23

; <label>:3:                                      ; preds = %1
  br label %23

; <label>:4:                                      ; preds = %1
  br label %23

; <label>:5:                                      ; preds = %1
  br label %23

; <label>:6:                                      ; preds = %1
  br label %23

; <label>:7:                                      ; preds = %1
  br label %23

; <label>:8:                                      ; preds = %1
  br label %23

; <label>:9:                                      ; preds = %1
  br label %23

; <label>:10:                                     ; preds = %1
  br label %23

; <label>:11:                                     ; preds = %1
  br label %23

; <label>:12:                                     ; preds = %1
  br label %23

; <label>:13:                                     ; preds = %1
  br label %23

; <label>:14:                                     ; preds = %1
  br label %23

; <label>:15:                                     ; preds = %1
  br label %23

; <label>:16:                                     ; preds = %1
  br label %23

; <label>:17:                                     ; preds = %1
  br label %23

; <label>:18:                                     ; preds = %1
  br label %23

; <label>:19:                                     ; preds = %1
  br label %23

; <label>:20:                                     ; preds = %1
  br label %23

; <label>:21:                                     ; preds = %1
  br label %23

; <label>:22:                                     ; preds = %1
  br label %23

; <label>:23:                                     ; preds = %1, %22, %21, %20, %19, %18, %17, %16, %15, %14, %13, %12, %11, %10, %9, %8, %7, %6, %5, %4, %3, %2
  %24 = phi i32 [ 21, %22 ], [ 20, %21 ], [ 19, %20 ], [ 18, %19 ], [ 17, %18 ], [ 15, %17 ], [ 14, %16 ], [ 13, %15 ], [ 16, %14 ], [ 12, %13 ], [ 11, %12 ], [ 10, %11 ], [ 9, %10 ], [ 8, %9 ], [ 7, %8 ], [ 6, %7 ], [ 5, %6 ], [ 4, %5 ], [ 3, %4 ], [ 2, %3 ], [ 1, %2 ], [ 0, %1 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_infix(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = alloca i32, align 4
  switch i32 %1, label %27 [
    i32 19, label %6
    i32 20, label %7
    i32 12, label %8
    i32 0, label %9
    i32 1, label %9
    i32 2, label %9
    i32 5, label %9
    i32 6, label %9
    i32 3, label %9
    i32 4, label %9
    i32 7, label %9
    i32 8, label %9
    i32 9, label %9
    i32 10, label %9
    i32 11, label %9
    i32 13, label %14
    i32 16, label %14
    i32 14, label %19
    i32 15, label %19
    i32 17, label %19
    i32 18, label %19
  ]

; <label>:6:                                      ; preds = %3
  tail call fastcc void @luaK_goiftrue(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %27

; <label>:7:                                      ; preds = %3
  tail call fastcc void @luaK_goiffalse(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %27

; <label>:8:                                      ; preds = %3
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %27

; <label>:9:                                      ; preds = %3, %3, %3, %3, %3, %3, %3, %3, %3, %3, %3, %3
  %10 = tail call fastcc i32 @tonumeral(%struct.expdesc* %2, %struct.TValue* null)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %27

; <label>:12:                                     ; preds = %9
  %13 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %27

; <label>:14:                                     ; preds = %3, %3
  %15 = tail call fastcc i32 @tonumeral(%struct.expdesc* %2, %struct.TValue* null)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %27

; <label>:17:                                     ; preds = %14
  %18 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %27

; <label>:19:                                     ; preds = %3, %3, %3, %3
  %20 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %21 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %21) #7
  %22 = call fastcc i32 @isSCnumber(%struct.expdesc* %2, i64* nonnull %4, i32* nonnull %5)
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %19
  %25 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %26

; <label>:26:                                     ; preds = %19, %24
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %21) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %27

; <label>:27:                                     ; preds = %9, %14, %3, %17, %12, %26, %8, %7, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_posfix(%struct.FuncState* nocapture, i32, %struct.expdesc*, %struct.expdesc*, i32) unnamed_addr #0 {
  switch i32 %1, label %50 [
    i32 19, label %6
    i32 20, label %12
    i32 12, label %18
    i32 0, label %19
    i32 2, label %19
    i32 1, label %24
    i32 5, label %24
    i32 6, label %24
    i32 3, label %24
    i32 4, label %24
    i32 7, label %29
    i32 8, label %29
    i32 9, label %29
    i32 10, label %33
    i32 11, label %41
    i32 13, label %45
    i32 16, label %45
    i32 14, label %46
    i32 15, label %46
    i32 17, label %48
    i32 18, label %48
  ]

; <label>:6:                                      ; preds = %5
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %3)
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !284
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %7, i32 %9)
  %10 = bitcast %struct.expdesc* %2 to i8*
  %11 = bitcast %struct.expdesc* %3 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 24, i32 8, i1 false), !tbaa.struct !311
  br label %50

; <label>:12:                                     ; preds = %5
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %3)
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 2
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %15 = load i32, i32* %14, align 8, !tbaa !282
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %15)
  %16 = bitcast %struct.expdesc* %2 to i8*
  %17 = bitcast %struct.expdesc* %3 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %17, i64 24, i32 8, i1 false), !tbaa.struct !311
  br label %50

; <label>:18:                                     ; preds = %5
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* %3)
  tail call fastcc void @codeconcat(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %50

; <label>:19:                                     ; preds = %5, %5
  %20 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3)
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %50

; <label>:22:                                     ; preds = %19
  %23 = add i32 %1, 38
  tail call fastcc void @codecommutative(%struct.FuncState* %0, i32 %23, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %50

; <label>:24:                                     ; preds = %5, %5, %5, %5, %5
  %25 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3)
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %27, label %50

; <label>:27:                                     ; preds = %24
  %28 = add i32 %1, 38
  tail call fastcc void @codearith(%struct.FuncState* %0, i32 %28, %struct.expdesc* %2, %struct.expdesc* %3, i32 0, i32 %4)
  br label %50

; <label>:29:                                     ; preds = %5, %5, %5
  %30 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3)
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %50

; <label>:32:                                     ; preds = %29
  tail call fastcc void @codebitwise(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %50

; <label>:33:                                     ; preds = %5
  %34 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 10, %struct.expdesc* %2, %struct.expdesc* %3)
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %50

; <label>:36:                                     ; preds = %33
  %37 = tail call fastcc i32 @isSCint(%struct.expdesc* %2)
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %40, label %39

; <label>:39:                                     ; preds = %36
  tail call fastcc void @swapexps(%struct.expdesc* %2, %struct.expdesc* %3)
  tail call fastcc void @codebini(%struct.FuncState* %0, i32 37, %struct.expdesc* %2, %struct.expdesc* %3, i32 1, i32 %4)
  br label %50

; <label>:40:                                     ; preds = %36
  tail call fastcc void @codeshift(%struct.FuncState* %0, i32 48, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %50

; <label>:41:                                     ; preds = %5
  %42 = tail call fastcc i32 @constfolding(%struct.FuncState* %0, i32 11, %struct.expdesc* %2, %struct.expdesc* %3)
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %44, label %50

; <label>:44:                                     ; preds = %41
  tail call fastcc void @codeshift(%struct.FuncState* %0, i32 49, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %50

; <label>:45:                                     ; preds = %5, %5
  tail call fastcc void @codeeq(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3)
  br label %50

; <label>:46:                                     ; preds = %5, %5
  %47 = add i32 %1, 45
  tail call fastcc void @codeorder(%struct.FuncState* %0, i32 %47, %struct.expdesc* %2, %struct.expdesc* %3)
  br label %50

; <label>:48:                                     ; preds = %5, %5
  %49 = add i32 %1, 42
  tail call fastcc void @swapexps(%struct.expdesc* %2, %struct.expdesc* %3)
  tail call fastcc void @codeorder(%struct.FuncState* %0, i32 %49, %struct.expdesc* %2, %struct.expdesc* %3)
  br label %50

; <label>:50:                                     ; preds = %19, %24, %29, %33, %41, %5, %44, %40, %39, %32, %27, %22, %48, %46, %45, %18, %12, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @constfolding(%struct.FuncState* nocapture readonly, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast %struct.TValue* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %9) #7
  %10 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = call fastcc i32 @tonumeral(%struct.expdesc* %2, %struct.TValue* nonnull %5)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %41, label %13

; <label>:13:                                     ; preds = %4
  %14 = call fastcc i32 @tonumeral(%struct.expdesc* %3, %struct.TValue* nonnull %6)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %41, label %16

; <label>:16:                                     ; preds = %13
  %17 = call fastcc i32 @validop(i32 %1, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %41, label %19

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %21 = load %struct.LexState*, %struct.LexState** %20, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 6
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !260
  %24 = call fastcc i32 @luaO_rawarith(%struct.lua_State* %23, i32 %1, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6, %struct.TValue* nonnull %7)
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = icmp eq i8 %26, 35
  br i1 %27, label %28, label %33

; <label>:28:                                     ; preds = %19
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 6, i32* %29, align 8, !tbaa !285
  %30 = bitcast %struct.TValue* %7 to i64*
  %31 = load i64, i64* %30, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  store i64 %31, i64* %32, align 8, !tbaa !21
  br label %41

; <label>:33:                                     ; preds = %19
  %34 = bitcast %struct.TValue* %7 to double*
  %35 = load double, double* %34, align 8, !tbaa !21
  %36 = fcmp ueq double %35, 0.000000e+00
  br i1 %36, label %41, label %37

; <label>:37:                                     ; preds = %33
  %38 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 5, i32* %38, align 8, !tbaa !285
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %40 = bitcast %union.anon.8* %39 to double*
  store double %35, double* %40, align 8, !tbaa !21
  br label %41

; <label>:41:                                     ; preds = %28, %37, %33, %4, %13, %16
  %42 = phi i32 [ 0, %16 ], [ 0, %13 ], [ 0, %4 ], [ 0, %33 ], [ 1, %37 ], [ 1, %28 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeunexpval(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %5 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  %6 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %1, i32 0, i32 %5, i32 0, i32 0)
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  store i32 %6, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 15, i32* %9, align 8, !tbaa !285
  tail call fastcc void @luaK_fixline(%struct.FuncState* %0, i32 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codenot(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  switch i32 %4, label %13 [
    i32 1, label %5
    i32 3, label %5
    i32 4, label %6
    i32 5, label %6
    i32 6, label %6
    i32 2, label %6
    i32 14, label %7
    i32 15, label %8
    i32 7, label %8
  ]

; <label>:5:                                      ; preds = %2, %2
  store i32 2, i32* %3, align 8, !tbaa !285
  br label %13

; <label>:6:                                      ; preds = %2, %2, %2, %2
  store i32 3, i32* %3, align 8, !tbaa !285
  br label %13

; <label>:7:                                      ; preds = %2
  tail call fastcc void @negatecondition(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %13

; <label>:8:                                      ; preds = %2, %2
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %10 = bitcast %union.anon.8* %9 to i32*
  %11 = load i32, i32* %10, align 8, !tbaa !21
  %12 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 52, i32 0, i32 %11, i32 0, i32 0)
  store i32 %12, i32* %10, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %13

; <label>:13:                                     ; preds = %2, %8, %7, %6, %5
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !284
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %17 = load i32, i32* %16, align 8, !tbaa !282
  store i32 %17, i32* %14, align 4, !tbaa !284
  store i32 %15, i32* %16, align 8, !tbaa !282
  tail call fastcc void @removevalues(%struct.FuncState* %0, i32 %17)
  %18 = load i32, i32* %16, align 8, !tbaa !282
  tail call fastcc void @removevalues(%struct.FuncState* %0, i32 %18)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @tonumeral(%struct.expdesc* nocapture readonly, %struct.TValue*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 8, !tbaa !282
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !284
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %8, label %25

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !285
  switch i32 %10, label %25 [
    i32 6, label %11
    i32 5, label %18
  ]

; <label>:11:                                     ; preds = %8
  %12 = icmp eq %struct.TValue* %1, null
  br i1 %12, label %25, label %13

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %1 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 35, i8* %17, align 8, !tbaa !22
  br label %25

; <label>:18:                                     ; preds = %8
  %19 = icmp eq %struct.TValue* %1, null
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %18
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %22 = load i64, i64* %21, align 8, !tbaa !21
  %23 = bitcast %struct.TValue* %1 to i64*
  store i64 %22, i64* %23, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 19, i8* %24, align 8, !tbaa !22
  br label %25

; <label>:25:                                     ; preds = %8, %20, %18, %13, %11, %2
  %26 = phi i32 [ 0, %2 ], [ 1, %11 ], [ 1, %13 ], [ 1, %18 ], [ 1, %20 ], [ 0, %8 ]
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @validop(i32, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = alloca i64, align 8
  switch i32 %0, label %42 [
    i32 7, label %5
    i32 8, label %5
    i32 9, label %5
    i32 10, label %5
    i32 11, label %5
    i32 13, label %5
    i32 5, label %28
    i32 6, label %28
    i32 3, label %28
  ]

; <label>:5:                                      ; preds = %3, %3, %3, %3, %3, %3
  %6 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 35
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %5
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %4, align 8, !tbaa !109
  br label %16

; <label>:13:                                     ; preds = %5
  %14 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %1, i64* nonnull %4, i32 0)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %26, label %16

; <label>:16:                                     ; preds = %13, %10
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = icmp eq i8 %18, 35
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %16
  %21 = bitcast %struct.TValue* %2 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !21
  store i64 %22, i64* %4, align 8, !tbaa !109
  br label %26

; <label>:23:                                     ; preds = %16
  %24 = call fastcc i32 @luaV_tointegerns(%struct.TValue* nonnull %2, i64* nonnull %4, i32 0)
  %25 = icmp ne i32 %24, 0
  br label %26

; <label>:26:                                     ; preds = %20, %23, %13
  %27 = phi i1 [ false, %13 ], [ true, %20 ], [ %25, %23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  br label %42

; <label>:28:                                     ; preds = %3, %3, %3
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = icmp eq i8 %30, 35
  br i1 %31, label %32, label %36

; <label>:32:                                     ; preds = %28
  %33 = bitcast %struct.TValue* %2 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !21
  %35 = sitofp i64 %34 to double
  br label %39

; <label>:36:                                     ; preds = %28
  %37 = bitcast %struct.TValue* %2 to double*
  %38 = load double, double* %37, align 8, !tbaa !21
  br label %39

; <label>:39:                                     ; preds = %36, %32
  %40 = phi double [ %35, %32 ], [ %38, %36 ]
  %41 = fcmp une double %40, 0.000000e+00
  br label %42

; <label>:42:                                     ; preds = %3, %39, %26
  %43 = phi i1 [ %41, %39 ], [ %27, %26 ], [ true, %3 ]
  %44 = zext i1 %43 to i32
  ret i32 %44
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_exp2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !282
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !284
  %11 = icmp eq i32 %8, %10
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  br i1 %11, label %27, label %15

; <label>:15:                                     ; preds = %6
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %17 = load i8, i8* %16, align 2, !tbaa !288
  %18 = zext i8 %17 to i32
  %19 = icmp slt i32 %14, %18
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %15
  tail call fastcc void @exp2reg(%struct.FuncState* nonnull %0, %struct.expdesc* nonnull %1, i32 %14)
  br label %24

; <label>:21:                                     ; preds = %15, %2
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  %22 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %23 = bitcast %union.anon.8* %22 to i32*
  br label %24

; <label>:24:                                     ; preds = %20, %21
  %25 = phi i32* [ %23, %21 ], [ %13, %20 ]
  %26 = load i32, i32* %25, align 8, !tbaa !21
  br label %27

; <label>:27:                                     ; preds = %24, %6
  %28 = phi i32 [ %14, %6 ], [ %26, %24 ]
  ret i32 %28
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @freeexp(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %6, label %10

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %9)
  br label %10

; <label>:10:                                     ; preds = %6, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_fixline(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %0)
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %4, i32 %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_dischargevars(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  switch i32 %4, label %64 [
    i32 8, label %5
    i32 9, label %6
    i32 11, label %11
    i32 12, label %22
    i32 13, label %35
    i32 10, label %48
    i32 17, label %63
    i32 16, label %63
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 7, i32 0, i32 %9, i32 0, i32 0)
  store i32 %10, i32* %8, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to %struct.anon.9*
  %14 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %13, i64 0, i32 1
  %15 = load i8, i8* %14, align 2, !tbaa !21
  %16 = zext i8 %15 to i32
  %17 = bitcast %union.anon.8* %12 to i16*
  %18 = load i16, i16* %17, align 8, !tbaa !21
  %19 = sext i16 %18 to i32
  %20 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 9, i32 0, i32 %16, i32 %19, i32 0)
  %21 = bitcast %union.anon.8* %12 to i32*
  store i32 %20, i32* %21, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:22:                                     ; preds = %2
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to %struct.anon.9*
  %25 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 2, !tbaa !21
  %27 = zext i8 %26 to i32
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %27)
  %28 = load i8, i8* %25, align 2, !tbaa !21
  %29 = zext i8 %28 to i32
  %30 = bitcast %union.anon.8* %23 to i16*
  %31 = load i16, i16* %30, align 8, !tbaa !21
  %32 = sext i16 %31 to i32
  %33 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 11, i32 0, i32 %29, i32 %32, i32 0)
  %34 = bitcast %union.anon.8* %23 to i32*
  store i32 %33, i32* %34, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:35:                                     ; preds = %2
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to %struct.anon.9*
  %38 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %37, i64 0, i32 1
  %39 = load i8, i8* %38, align 2, !tbaa !21
  %40 = zext i8 %39 to i32
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %40)
  %41 = load i8, i8* %38, align 2, !tbaa !21
  %42 = zext i8 %41 to i32
  %43 = bitcast %union.anon.8* %36 to i16*
  %44 = load i16, i16* %43, align 8, !tbaa !21
  %45 = sext i16 %44 to i32
  %46 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 12, i32 0, i32 %42, i32 %45, i32 0)
  %47 = bitcast %union.anon.8* %36 to i32*
  store i32 %46, i32* %47, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:48:                                     ; preds = %2
  %49 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %50 = bitcast %union.anon.8* %49 to %struct.anon.9*
  %51 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %50, i64 0, i32 1
  %52 = load i8, i8* %51, align 2, !tbaa !21
  %53 = zext i8 %52 to i32
  %54 = bitcast %union.anon.8* %49 to i16*
  %55 = load i16, i16* %54, align 8, !tbaa !21
  %56 = sext i16 %55 to i32
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %53, i32 %56)
  %57 = load i8, i8* %51, align 2, !tbaa !21
  %58 = zext i8 %57 to i32
  %59 = load i16, i16* %54, align 8, !tbaa !21
  %60 = sext i16 %59 to i32
  %61 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 10, i32 0, i32 %58, i32 %60, i32 0)
  %62 = bitcast %union.anon.8* %49 to i32*
  store i32 %61, i32* %62, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %64

; <label>:63:                                     ; preds = %2, %2
  tail call fastcc void @luaK_setoneret(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %64

; <label>:64:                                     ; preds = %2, %63, %48, %35, %22, %11, %6, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @exp2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %2)
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  %6 = icmp eq i32 %5, 14
  br i1 %6, label %7, label %12

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %10 = bitcast %union.anon.8* %9 to i32*
  %11 = load i32, i32* %10, align 8, !tbaa !21
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %8, i32 %11)
  br label %12

; <label>:12:                                     ; preds = %7, %3
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %14 = load i32, i32* %13, align 8, !tbaa !282
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %16 = load i32, i32* %15, align 4, !tbaa !284
  %17 = icmp eq i32 %14, %16
  br i1 %17, label %39, label %18

; <label>:18:                                     ; preds = %12
  %19 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %14)
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %18
  %22 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %16)
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %33, label %24

; <label>:24:                                     ; preds = %21, %18
  %25 = load i32, i32* %4, align 8, !tbaa !285
  %26 = icmp eq i32 %25, 14
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  %28 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %0)
  br label %29

; <label>:29:                                     ; preds = %24, %27
  %30 = phi i32 [ %28, %27 ], [ -1, %24 ]
  %31 = tail call fastcc i32 @code_loadbool(%struct.FuncState* %0, i32 %2, i32 0, i32 1)
  %32 = tail call fastcc i32 @code_loadbool(%struct.FuncState* %0, i32 %2, i32 1, i32 0)
  tail call fastcc void @luaK_patchtohere(%struct.FuncState* %0, i32 %30)
  br label %33

; <label>:33:                                     ; preds = %21, %29
  %34 = phi i32 [ %32, %29 ], [ -1, %21 ]
  %35 = phi i32 [ %31, %29 ], [ -1, %21 ]
  %36 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %0)
  %37 = load i32, i32* %15, align 4, !tbaa !284
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %37, i32 %36, i32 %2, i32 %35)
  %38 = load i32, i32* %13, align 8, !tbaa !282
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %38, i32 %36, i32 %2, i32 %34)
  br label %39

; <label>:39:                                     ; preds = %12, %33
  store i32 -1, i32* %13, align 8, !tbaa !282
  store i32 -1, i32* %15, align 4, !tbaa !284
  %40 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %41 = bitcast %union.anon.8* %40 to i32*
  store i32 %2, i32* %41, align 8, !tbaa !21
  store i32 7, i32* %4, align 8, !tbaa !285
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_exp2nextreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %1)
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %0, i32 1)
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !300
  %5 = zext i8 %4 to i32
  %6 = add nsw i32 %5, -1
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %6)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @freereg(%struct.FuncState* nocapture, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %4 = load i8, i8* %3, align 2, !tbaa !288
  %5 = zext i8 %4 to i32
  %6 = icmp sgt i32 %5, %1
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %9 = load i8, i8* %8, align 4, !tbaa !300
  %10 = add i8 %9, -1
  store i8 %10, i8* %8, align 4, !tbaa !300
  br label %11

; <label>:11:                                     ; preds = %2, %7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @freeregs(%struct.FuncState* nocapture, i32, i32) unnamed_addr #2 {
  %4 = icmp sgt i32 %1, %2
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %3
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %1)
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %2)
  br label %7

; <label>:6:                                      ; preds = %3
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %2)
  tail call fastcc void @freereg(%struct.FuncState* %0, i32 %1)
  br label %7

; <label>:7:                                      ; preds = %6, %5
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @luaK_setoneret(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  switch i32 %4, label %31 [
    i32 16, label %5
    i32 17, label %18
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !285
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %9 = load i32*, i32** %8, align 8, !tbaa !134
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, i32* %9, i64 %13
  %15 = load i32, i32* %14, align 4, !tbaa !70
  %16 = lshr i32 %15, 7
  %17 = and i32 %16, 255
  store i32 %17, i32* %11, align 8, !tbaa !21
  br label %31

; <label>:18:                                     ; preds = %2
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %20 = load %struct.Proto*, %struct.Proto** %19, align 8, !tbaa !251
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %20, i64 0, i32 16
  %22 = load i32*, i32** %21, align 8, !tbaa !134
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = load i32, i32* %24, align 8, !tbaa !21
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds i32, i32* %22, i64 %26
  %28 = load i32, i32* %27, align 4, !tbaa !70
  %29 = and i32 %28, 16777215
  %30 = or i32 %29, 33554432
  store i32 %30, i32* %27, align 4, !tbaa !70
  store i32 15, i32* %3, align 8, !tbaa !285
  br label %31

; <label>:31:                                     ; preds = %2, %18, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @discharge2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1)
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  switch i32 %5, label %47 [
    i32 1, label %6
    i32 3, label %7
    i32 2, label %7
    i32 4, label %11
    i32 5, label %15
    i32 6, label %19
    i32 15, label %22
    i32 7, label %37
  ]

; <label>:6:                                      ; preds = %3
  tail call fastcc void @luaK_nil(%struct.FuncState* %0, i32 %2, i32 1)
  br label %44

; <label>:7:                                      ; preds = %3, %3
  %8 = icmp eq i32 %5, 2
  %9 = zext i1 %8 to i32
  %10 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 5, i32 %2, i32 %9, i32 0, i32 0)
  br label %44

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %2, i32 %14)
  br label %44

; <label>:15:                                     ; preds = %3
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %17 = bitcast %union.anon.8* %16 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  tail call fastcc void @luaK_float(%struct.FuncState* %0, i32 %2, double %18)
  br label %44

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %21 = load i64, i64* %20, align 8, !tbaa !21
  tail call fastcc void @luaK_int(%struct.FuncState* %0, i32 %2, i64 %21)
  br label %44

; <label>:22:                                     ; preds = %3
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %24 = load %struct.Proto*, %struct.Proto** %23, align 8, !tbaa !251
  %25 = getelementptr inbounds %struct.Proto, %struct.Proto* %24, i64 0, i32 16
  %26 = load i32*, i32** %25, align 8, !tbaa !134
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %28 = bitcast %union.anon.8* %27 to i32*
  %29 = load i32, i32* %28, align 8, !tbaa !21
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds i32, i32* %26, i64 %30
  %32 = load i32, i32* %31, align 4, !tbaa !70
  %33 = and i32 %32, -32641
  %34 = shl i32 %2, 7
  %35 = and i32 %34, 32640
  %36 = or i32 %33, %35
  store i32 %36, i32* %31, align 4, !tbaa !70
  br label %44

; <label>:37:                                     ; preds = %3
  %38 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %39 = bitcast %union.anon.8* %38 to i32*
  %40 = load i32, i32* %39, align 8, !tbaa !21
  %41 = icmp eq i32 %40, %2
  br i1 %41, label %44, label %42

; <label>:42:                                     ; preds = %37
  %43 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 0, i32 %2, i32 %40, i32 0, i32 0)
  br label %44

; <label>:44:                                     ; preds = %37, %42, %22, %19, %15, %11, %7, %6
  %45 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %46 = bitcast %union.anon.8* %45 to i32*
  store i32 %2, i32* %46, align 8, !tbaa !21
  store i32 7, i32* %4, align 8, !tbaa !285
  br label %47

; <label>:47:                                     ; preds = %3, %44
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @need_value(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %14, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %11
  %6 = phi i32 [ %12, %11 ], [ %1, %4 ]
  %7 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %6)
  %8 = load i32, i32* %7, align 4, !tbaa !70
  %9 = and i32 %8, 127
  %10 = icmp eq i32 %9, 68
  br i1 %10, label %11, label %14

; <label>:11:                                     ; preds = %5
  %12 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %6)
  %13 = icmp eq i32 %12, -1
  br i1 %13, label %14, label %5

; <label>:14:                                     ; preds = %5, %11, %2
  %15 = phi i32 [ 0, %2 ], [ 0, %11 ], [ 1, %5 ]
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @code_loadbool(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %0)
  %6 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 5, i32 %1, i32 %2, i32 %3, i32 0)
  ret i32 %6
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @luaK_getlabel(%struct.FuncState* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %3 = load i32, i32* %2, align 8, !tbaa !273
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %3, i32* %4, align 4, !tbaa !275
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @patchlistaux(%struct.FuncState* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = icmp eq i32 %1, -1
  br i1 %6, label %17, label %7

; <label>:7:                                      ; preds = %5
  br label %8

; <label>:8:                                      ; preds = %7, %15
  %9 = phi i32 [ %10, %15 ], [ %1, %7 ]
  %10 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %9)
  %11 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %9, i32 %3)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %14, label %13

; <label>:13:                                     ; preds = %8
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %9, i32 %2)
  br label %15

; <label>:14:                                     ; preds = %8
  tail call fastcc void @fixjump(%struct.FuncState* %0, i32 %9, i32 %4)
  br label %15

; <label>:15:                                     ; preds = %14, %13
  %16 = icmp eq i32 %10, -1
  br i1 %16, label %17, label %8

; <label>:17:                                     ; preds = %15, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_nil(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = add nsw i32 %2, %1
  %5 = add i32 %4, 255
  %6 = tail call fastcc i32* @previousinstruction(%struct.FuncState* %0)
  %7 = load i32, i32* %6, align 4, !tbaa !70
  %8 = and i32 %7, 127
  %9 = icmp eq i32 %8, 6
  br i1 %9, label %10, label %37

; <label>:10:                                     ; preds = %3
  %11 = lshr i32 %7, 7
  %12 = and i32 %11, 255
  %13 = lshr i32 %7, 16
  %14 = and i32 %13, 255
  %15 = add nuw nsw i32 %12, %14
  %16 = icmp sgt i32 %12, %1
  %17 = add nuw nsw i32 %15, 1
  %18 = icmp slt i32 %17, %1
  %19 = or i1 %16, %18
  br i1 %19, label %20, label %24

; <label>:20:                                     ; preds = %10
  %21 = icmp slt i32 %12, %1
  %22 = icmp sgt i32 %12, %4
  %23 = or i1 %21, %22
  br i1 %23, label %37, label %24

; <label>:24:                                     ; preds = %10, %20
  %25 = icmp slt i32 %12, %1
  %26 = select i1 %25, i32 %12, i32 %1
  %27 = icmp slt i32 %15, %4
  %28 = select i1 %27, i32 %5, i32 %15
  %29 = and i32 %7, -16744321
  %30 = shl i32 %26, 7
  %31 = and i32 %30, 32640
  %32 = or i32 %31, %29
  %33 = sub i32 %28, %26
  %34 = shl i32 %33, 16
  %35 = and i32 %34, 16711680
  %36 = or i32 %32, %35
  store i32 %36, i32* %6, align 4, !tbaa !70
  br label %40

; <label>:37:                                     ; preds = %20, %3
  %38 = add nsw i32 %2, -1
  %39 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 6, i32 %1, i32 %38, i32 0, i32 0)
  br label %40

; <label>:40:                                     ; preds = %24, %37
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_codek(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = icmp slt i32 %2, 131072
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i32 @luaK_codeABx(%struct.FuncState* %0, i32 3, i32 %1, i32 %2)
  br label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc i32 @luaK_codeABx(%struct.FuncState* %0, i32 4, i32 %1, i32 0)
  tail call fastcc void @codeextraarg(%struct.FuncState* %0, i32 %2)
  br label %9

; <label>:9:                                      ; preds = %7, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_float(%struct.FuncState* nocapture, i32, double) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call fastcc i32 @floatI(double %2, i64* nonnull %4)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %3
  %9 = load i64, i64* %4, align 8, !tbaa !109
  %10 = trunc i64 %9 to i32
  tail call fastcc void @luaK_codeAsBx(%struct.FuncState* %0, i32 2, i32 %1, i32 %10)
  br label %13

; <label>:11:                                     ; preds = %3
  %12 = tail call fastcc i32 @luaK_numberK(%struct.FuncState* %0, double %2)
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %1, i32 %12)
  br label %13

; <label>:13:                                     ; preds = %11, %8
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_int(%struct.FuncState* nocapture, i32, i64) unnamed_addr #0 {
  %4 = tail call fastcc i32 @fitsBx(i64 %2)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %3
  %7 = trunc i64 %2 to i32
  tail call fastcc void @luaK_codeAsBx(%struct.FuncState* %0, i32 1, i32 %1, i32 %7)
  br label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc i32 @luaK_intK(%struct.FuncState* %0, i64 %2)
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %1, i32 %9)
  br label %10

; <label>:10:                                     ; preds = %8, %6
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32* @previousinstruction(%struct.FuncState* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %3 = load i32, i32* %2, align 8, !tbaa !273
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  %5 = load i32, i32* %4, align 4, !tbaa !275
  %6 = icmp sgt i32 %3, %5
  br i1 %6, label %7, label %15

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !134
  %12 = add nsw i32 %3, -1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, i32* %11, i64 %13
  br label %15

; <label>:15:                                     ; preds = %1, %7
  %16 = phi i32* [ %14, %7 ], [ @previousinstruction.invalidinstruction, %1 ]
  ret i32* %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_codeABx(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = shl i32 %2, 7
  %6 = or i32 %5, %1
  %7 = shl i32 %3, 15
  %8 = or i32 %6, %7
  %9 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %8)
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeextraarg(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 7
  %4 = or i32 %3, 83
  %5 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @floatI(double, i64* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @luaV_flttointeger(double %0, i64* %1, i32 0)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %2
  %6 = load i64, i64* %1, align 8, !tbaa !109
  %7 = tail call fastcc i32 @fitsBx(i64 %6)
  %8 = icmp ne i32 %7, 0
  %9 = zext i1 %8 to i32
  br label %10

; <label>:10:                                     ; preds = %2, %5
  %11 = phi i32 [ 0, %2 ], [ %9, %5 ]
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_codeAsBx(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = shl i32 %2, 7
  %6 = or i32 %5, %1
  %7 = shl i32 %3, 15
  %8 = add i32 %7, 2147450880
  %9 = or i32 %6, %8
  %10 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_numberK(%struct.FuncState* nocapture, double) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to double*
  store double %1, double* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 19, i8* %6, align 8, !tbaa !22
  %7 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %7
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @fitsBx(i64) unnamed_addr #6 {
  %2 = add i64 %0, 65535
  %3 = icmp ult i64 %2, 131072
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @addk(%struct.FuncState* nocapture, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !260
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !248
  %12 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %7, %struct.Table* %11, %struct.TValue* %1)
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = icmp eq i8 %14, 35
  br i1 %15, label %16, label %39

; <label>:16:                                     ; preds = %3
  %17 = bitcast %struct.TValue* %12 to i64*
  %18 = load i64, i64* %17, align 8, !tbaa !21
  %19 = trunc i64 %18 to i32
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %21 = load i32, i32* %20, align 4, !tbaa !276
  %22 = icmp sgt i32 %21, %19
  br i1 %22, label %23, label %39

; <label>:23:                                     ; preds = %16
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !209
  %26 = shl i64 %18, 32
  %27 = ashr exact i64 %26, 32
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 %27, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = xor i8 %31, %29
  %33 = and i8 %32, 63
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %35, label %39

; <label>:35:                                     ; preds = %23
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 %27
  %37 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %36, %struct.TValue* nonnull %2)
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %39, label %92

; <label>:39:                                     ; preds = %35, %16, %23, %3
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 7
  %41 = load i32, i32* %40, align 4, !tbaa !210
  %42 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %43 = load i32, i32* %42, align 4, !tbaa !276
  %44 = sext i32 %43 to i64
  %45 = bitcast %struct.TValue* %12 to i64*
  store i64 %44, i64* %45, align 8, !tbaa !21
  store i8 35, i8* %13, align 8, !tbaa !22
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %47 = bitcast %struct.TValue** %46 to i8**
  %48 = load i8*, i8** %47, align 8, !tbaa !209
  %49 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %7, i8* %48, i32 %43, i32* nonnull %40, i32 16, i32 33554431, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.250, i64 0, i64 0))
  store i8* %49, i8** %47, align 8, !tbaa !209
  %50 = load i32, i32* %40, align 4, !tbaa !210
  %51 = icmp slt i32 %41, %50
  %52 = bitcast i8* %49 to %struct.TValue*
  br i1 %51, label %53, label %64

; <label>:53:                                     ; preds = %39
  %54 = load i32, i32* %40, align 4, !tbaa !210
  %55 = load %struct.TValue*, %struct.TValue** %46, align 8, !tbaa !209
  %56 = sext i32 %41 to i64
  %57 = sext i32 %54 to i64
  br label %58

; <label>:58:                                     ; preds = %53, %58
  %59 = phi i64 [ %56, %53 ], [ %61, %58 ]
  %60 = phi %struct.TValue* [ %52, %53 ], [ %55, %58 ]
  %61 = add nsw i64 %59, 1
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %60, i64 %59, i32 1
  store i8 0, i8* %62, align 8, !tbaa !22
  %63 = icmp slt i64 %61, %57
  br i1 %63, label %58, label %64

; <label>:64:                                     ; preds = %58, %39
  %65 = phi %struct.TValue* [ %52, %39 ], [ %55, %58 ]
  %66 = getelementptr inbounds %struct.TValue, %struct.TValue* %65, i64 %44
  %67 = bitcast %struct.TValue* %2 to i64*
  %68 = bitcast %struct.TValue* %66 to i64*
  %69 = load i64, i64* %67, align 8
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  %72 = getelementptr inbounds %struct.TValue, %struct.TValue* %65, i64 %44, i32 1
  store i8 %71, i8* %72, align 8, !tbaa !22
  %73 = load i32, i32* %42, align 4, !tbaa !276
  %74 = add nsw i32 %73, 1
  store i32 %74, i32* %42, align 4, !tbaa !276
  %75 = load i8, i8* %70, align 8, !tbaa !22
  %76 = and i8 %75, 64
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %92, label %78

; <label>:78:                                     ; preds = %64
  %79 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 2
  %80 = load i8, i8* %79, align 1, !tbaa !226
  %81 = and i8 %80, 32
  %82 = icmp eq i8 %81, 0
  br i1 %82, label %92, label %83

; <label>:83:                                     ; preds = %78
  %84 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %85 = load %struct.GCObject*, %struct.GCObject** %84, align 8, !tbaa !21
  %86 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %85, i64 0, i32 2
  %87 = load i8, i8* %86, align 1, !tbaa !53
  %88 = and i8 %87, 24
  %89 = icmp eq i8 %88, 0
  br i1 %89, label %92, label %90

; <label>:90:                                     ; preds = %83
  %91 = bitcast %struct.Proto* %9 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %7, %struct.GCObject* %91, %struct.GCObject* %85)
  br label %92

; <label>:92:                                     ; preds = %90, %64, %78, %83, %35
  %93 = phi i32 [ %19, %35 ], [ %43, %83 ], [ %43, %78 ], [ %43, %64 ], [ %43, %90 ]
  ret i32 %93
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_intK(%struct.FuncState* nocapture, i64) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = inttoptr i64 %1 to i8*
  %8 = bitcast %struct.TValue* %3 to i8**
  store i8* %7, i8** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 2, i8* %9, align 8, !tbaa !22
  %10 = bitcast %struct.TValue* %4 to i64*
  store i64 %1, i64* %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %11, align 8, !tbaa !22
  %12 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %12
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32* @getjumpcontrol(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %6 = load i32*, i32** %5, align 8, !tbaa !134
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i32, i32* %6, i64 %7
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds i32, i32* %8, i64 -1
  %12 = load i32, i32* %11, align 4, !tbaa !70
  %13 = and i32 %12, 127
  %14 = zext i32 %13 to i64
  %15 = add nsw i64 %14, -58
  %16 = icmp ult i64 %15, 11
  br i1 %16, label %18, label %17

; <label>:17:                                     ; preds = %10, %2
  br label %18

; <label>:18:                                     ; preds = %10, %17
  %19 = phi i32* [ %8, %17 ], [ %11, %10 ]
  ret i32* %19
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @getjump(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %6 = load i32*, i32** %5, align 8, !tbaa !134
  %7 = sext i32 %1 to i64
  %8 = getelementptr inbounds i32, i32* %6, i64 %7
  %9 = load i32, i32* %8, align 4, !tbaa !70
  %10 = lshr i32 %9, 7
  %11 = add nsw i32 %10, -16777215
  %12 = icmp eq i32 %11, -1
  %13 = add nsw i32 %1, 1
  %14 = add nsw i32 %13, %11
  %15 = select i1 %12, i32 -1, i32 %14
  ret i32 %15
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @patchtestreg(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #2 {
  %4 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %1)
  %5 = load i32, i32* %4, align 4, !tbaa !70
  %6 = and i32 %5, 127
  %7 = icmp eq i32 %6, 68
  br i1 %7, label %8, label %27

; <label>:8:                                      ; preds = %3
  %9 = icmp eq i32 %2, 255
  br i1 %9, label %19, label %10

; <label>:10:                                     ; preds = %8
  %11 = lshr i32 %5, 16
  %12 = and i32 %11, 255
  %13 = icmp eq i32 %12, %2
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %10
  %15 = and i32 %5, -32641
  %16 = shl i32 %2, 7
  %17 = and i32 %16, 32640
  %18 = or i32 %15, %17
  br label %25

; <label>:19:                                     ; preds = %10, %8
  %20 = lshr i32 %5, 9
  %21 = and i32 %20, 32640
  %22 = and i32 %5, 32768
  %23 = or i32 %22, %21
  %24 = or i32 %23, 67
  br label %25

; <label>:25:                                     ; preds = %19, %14
  %26 = phi i32 [ %24, %19 ], [ %18, %14 ]
  store i32 %26, i32* %4, align 4, !tbaa !70
  br label %27

; <label>:27:                                     ; preds = %3, %25
  %28 = phi i32 [ 1, %25 ], [ 0, %3 ]
  ret i32 %28
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fixjump(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !134
  %8 = sext i32 %1 to i64
  %9 = getelementptr inbounds i32, i32* %7, i64 %8
  %10 = xor i32 %1, -1
  %11 = add i32 %10, %2
  %12 = add i32 %11, 16777215
  %13 = icmp ult i32 %12, 33554432
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %16 = load %struct.LexState*, %struct.LexState** %15, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %16, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #17
  unreachable

; <label>:17:                                     ; preds = %3
  %18 = load i32, i32* %9, align 4, !tbaa !70
  %19 = and i32 %18, 127
  %20 = shl i32 %11, 7
  %21 = add i32 %20, 2147483520
  %22 = or i32 %19, %21
  store i32 %22, i32* %9, align 4, !tbaa !70
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_reserveregs(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @luaK_checkstack(%struct.FuncState* %0, i32 %1)
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !300
  %5 = trunc i32 %1 to i8
  %6 = add i8 %4, %5
  store i8 %6, i8* %3, align 4, !tbaa !300
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_checkstack(%struct.FuncState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !300
  %5 = zext i8 %4 to i32
  %6 = add nsw i32 %5, %1
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !251
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 5
  %10 = load i8, i8* %9, align 4, !tbaa !133
  %11 = zext i8 %10 to i32
  %12 = icmp sgt i32 %6, %11
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %2
  %14 = icmp sgt i32 %6, 254
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %13
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %17 = load %struct.LexState*, %struct.LexState** %16, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %17, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.252, i64 0, i64 0)) #17
  unreachable

; <label>:18:                                     ; preds = %13
  %19 = trunc i32 %6 to i8
  store i8 %19, i8* %9, align 4, !tbaa !133
  br label %20

; <label>:20:                                     ; preds = %18, %2
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @removelastlineinfo(%struct.FuncState* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %3 = load %struct.Proto*, %struct.Proto** %2, align 8, !tbaa !251
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = add nsw i32 %5, -1
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 19
  %8 = load i8*, i8** %7, align 8, !tbaa !211
  %9 = sext i32 %6 to i64
  %10 = getelementptr inbounds i8, i8* %8, i64 %9
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = icmp eq i8 %11, -128
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %1
  %14 = sext i8 %11 to i32
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %16 = load i32, i32* %15, align 8, !tbaa !274
  %17 = sub nsw i32 %16, %14
  store i32 %17, i32* %15, align 8, !tbaa !274
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  %19 = load i8, i8* %18, align 1, !tbaa !298
  %20 = add i8 %19, -1
  store i8 %20, i8* %18, align 1, !tbaa !298
  br label %26

; <label>:21:                                     ; preds = %1
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %23 = load i32, i32* %22, align 4, !tbaa !277
  %24 = add nsw i32 %23, -1
  store i32 %24, i32* %22, align 4, !tbaa !277
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  store i8 121, i8* %25, align 1, !tbaa !298
  br label %26

; <label>:26:                                     ; preds = %21, %13
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @negatecondition(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %4 = bitcast %union.anon.8* %3 to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !21
  %6 = tail call fastcc i32* @getjumpcontrol(%struct.FuncState* %0, i32 %5)
  %7 = load i32, i32* %6, align 4, !tbaa !70
  %8 = xor i32 %7, 32768
  store i32 %8, i32* %6, align 4, !tbaa !70
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @discharge2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %0, i32 1)
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %8 = load i8, i8* %7, align 4, !tbaa !300
  %9 = zext i8 %8 to i32
  %10 = add nsw i32 %9, -1
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 %10)
  br label %11

; <label>:11:                                     ; preds = %2, %6
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @removevalues(%struct.FuncState* nocapture readonly, i32) unnamed_addr #2 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %10, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i32 [ %8, %5 ], [ %1, %4 ]
  %7 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %6, i32 255)
  %8 = tail call fastcc i32 @getjump(%struct.FuncState* %0, i32 %6)
  %9 = icmp eq i32 %8, -1
  br i1 %9, label %10, label %5

; <label>:10:                                     ; preds = %5, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codestring(%struct.LexState* nocapture readonly, %struct.expdesc* nocapture, %struct.TString*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = tail call fastcc i32 @luaK_stringK(%struct.FuncState* %5, %struct.TString* %2)
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 4, i32 %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @constructor(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.ConsControl, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !265
  %8 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %5, i32 17, i32 0, i32 0, i32 0, i32 0)
  %9 = bitcast %struct.ConsControl* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* nonnull %9) #7
  %10 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 4
  store i32 0, i32* %10, align 8, !tbaa !313
  %11 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 2
  store i32 0, i32* %11, align 8, !tbaa !315
  %12 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 3
  store i32 0, i32* %12, align 4, !tbaa !316
  %13 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 1
  store %struct.expdesc* %1, %struct.expdesc** %13, align 8, !tbaa !317
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 15, i32 %8)
  %14 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0
  call fastcc void @init_exp(%struct.expdesc* nonnull %14, i32 0, i32 0)
  %15 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %15, %struct.expdesc* %1)
  tail call fastcc void @checknext(%struct.LexState* %0, i32 123)
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %17 = load i32, i32* %16, align 8, !tbaa !259
  %18 = icmp eq i32 %17, 125
  br i1 %18, label %29, label %19

; <label>:19:                                     ; preds = %2
  br label %23

; <label>:20:                                     ; preds = %23, %26
  %21 = load i32, i32* %16, align 8, !tbaa !259
  %22 = icmp eq i32 %21, 125
  br i1 %22, label %29, label %23

; <label>:23:                                     ; preds = %19, %20
  call fastcc void @closelistfield(%struct.FuncState* %5, %struct.ConsControl* nonnull %3)
  call fastcc void @field(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3)
  %24 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 44)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %20

; <label>:26:                                     ; preds = %23
  %27 = call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 59)
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %29, label %20

; <label>:29:                                     ; preds = %20, %26, %2
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 125, i32 123, i32 %7)
  call fastcc void @lastlistfield(%struct.FuncState* %5, %struct.ConsControl* nonnull %3)
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %31 = load %struct.Proto*, %struct.Proto** %30, align 8, !tbaa !251
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 16
  %33 = load i32*, i32** %32, align 8, !tbaa !134
  %34 = sext i32 %8 to i64
  %35 = getelementptr inbounds i32, i32* %33, i64 %34
  %36 = load i32, i32* %35, align 4, !tbaa !70
  %37 = and i32 %36, -16711681
  %38 = load i32, i32* %12, align 4, !tbaa !316
  %39 = call fastcc i32 @luaO_int2fb(i32 %38)
  %40 = shl i32 %39, 16
  %41 = and i32 %40, 16711680
  %42 = or i32 %41, %37
  store i32 %42, i32* %35, align 4, !tbaa !70
  %43 = and i32 %42, 16777215
  %44 = load i32, i32* %11, align 8, !tbaa !315
  %45 = call fastcc i32 @luaO_int2fb(i32 %44)
  %46 = shl i32 %45, 24
  %47 = or i32 %43, %46
  store i32 %47, i32* %35, align 4, !tbaa !70
  call void @llvm.lifetime.end.p0i8(i64 48, i8* nonnull %9) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @body(%struct.LexState*, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.FuncState, align 8
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.FuncState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %7) #7
  %8 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = tail call fastcc %struct.Proto* @addprototype(%struct.LexState* %0)
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  store %struct.Proto* %9, %struct.Proto** %10, align 8, !tbaa !251
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 13
  store i32 %3, i32* %11, align 4, !tbaa !101
  call fastcc void @open_func(%struct.LexState* %0, %struct.FuncState* nonnull %5, %struct.BlockCnt* nonnull %6)
  call fastcc void @checknext(%struct.LexState* %0, i32 40)
  %12 = icmp eq i32 %2, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %4
  %14 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.256, i64 0, i64 0), i64 4)
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %14)
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 1)
  br label %15

; <label>:15:                                     ; preds = %4, %13
  call fastcc void @parlist(%struct.LexState* %0)
  call fastcc void @checknext(%struct.LexState* %0, i32 41)
  call fastcc void @statlist(%struct.LexState* %0)
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %17 = load i32, i32* %16, align 4, !tbaa !265
  %18 = load %struct.Proto*, %struct.Proto** %10, align 8, !tbaa !251
  %19 = getelementptr inbounds %struct.Proto, %struct.Proto* %18, i64 0, i32 14
  store i32 %17, i32* %19, align 8, !tbaa !233
  call fastcc void @check_match(%struct.LexState* %0, i32 262, i32 265, i32 %3)
  call fastcc void @codeclosure(%struct.LexState* %0, %struct.expdesc* %1)
  call fastcc void @close_func(%struct.LexState* %0)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @suffixedexp(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %8 = load i32, i32* %7, align 4, !tbaa !265
  tail call fastcc void @primaryexp(%struct.LexState* %0, %struct.expdesc* %1)
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %10 = bitcast %struct.expdesc* %3 to i8*
  %11 = bitcast %struct.expdesc* %4 to i8*
  br label %12

; <label>:12:                                     ; preds = %18, %2
  %13 = load i32, i32* %9, align 8, !tbaa !259
  switch i32 %13, label %19 [
    i32 46, label %14
    i32 91, label %15
    i32 58, label %16
    i32 40, label %17
    i32 293, label %17
    i32 123, label %17
  ]

; <label>:14:                                     ; preds = %12
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %18

; <label>:15:                                     ; preds = %12
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %10) #7
  call fastcc void @luaK_exp2anyregup(%struct.FuncState* %6, %struct.expdesc* %1)
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3)
  call fastcc void @luaK_indexed(%struct.FuncState* %6, %struct.expdesc* %1, %struct.expdesc* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %10) #7
  br label %18

; <label>:16:                                     ; preds = %12
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  call fastcc void @codename(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4)
  call fastcc void @luaK_self(%struct.FuncState* %6, %struct.expdesc* %1, %struct.expdesc* nonnull %4)
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 %8)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  br label %18

; <label>:17:                                     ; preds = %12, %12, %12
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* %1)
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 %8)
  br label %18

; <label>:18:                                     ; preds = %17, %16, %15, %14
  br label %12

; <label>:19:                                     ; preds = %12
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_stringK(%struct.FuncState* nocapture, %struct.TString*) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %1, %struct.TString** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !57
  %8 = or i8 %7, 64
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %8, i8* %9, align 8, !tbaa !22
  %10 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal fastcc void @closelistfield(%struct.FuncState* nocapture, %struct.ConsControl* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !318
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %19, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* %7)
  store i32 0, i32* %3, align 8, !tbaa !318
  %8 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 4
  %9 = load i32, i32* %8, align 8, !tbaa !313
  %10 = icmp eq i32 %9, 50
  br i1 %10, label %11, label %19

; <label>:11:                                     ; preds = %6
  %12 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %13 = load %struct.expdesc*, %struct.expdesc** %12, align 8, !tbaa !317
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %13, i64 0, i32 1
  %15 = bitcast %union.anon.8* %14 to i32*
  %16 = load i32, i32* %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 3
  %18 = load i32, i32* %17, align 4, !tbaa !316
  tail call fastcc void @luaK_setlist(%struct.FuncState* %0, i32 %16, i32 %18, i32 %9)
  store i32 0, i32* %8, align 8, !tbaa !313
  br label %19

; <label>:19:                                     ; preds = %2, %11, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @field(%struct.LexState*, %struct.ConsControl*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  switch i32 %4, label %11 [
    i32 292, label %5
    i32 91, label %10
  ]

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i32 @luaX_lookahead(%struct.LexState* nonnull %0)
  %7 = icmp eq i32 %6, 61
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  tail call fastcc void @listfield(%struct.LexState* nonnull %0, %struct.ConsControl* %1)
  br label %12

; <label>:9:                                      ; preds = %5
  tail call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* %1)
  br label %12

; <label>:10:                                     ; preds = %2
  tail call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* %1)
  br label %12

; <label>:11:                                     ; preds = %2
  tail call fastcc void @listfield(%struct.LexState* nonnull %0, %struct.ConsControl* %1)
  br label %12

; <label>:12:                                     ; preds = %8, %9, %11, %10
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lastlistfield(%struct.FuncState* nocapture, %struct.ConsControl* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 4
  %4 = load i32, i32* %3, align 8, !tbaa !313
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %30, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0
  %8 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !318
  switch i32 %9, label %20 [
    i32 16, label %10
    i32 17, label %10
    i32 0, label %21
  ]

; <label>:10:                                     ; preds = %6, %6
  tail call fastcc void @luaK_setreturns(%struct.FuncState* %0, %struct.expdesc* %7, i32 -1)
  %11 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %12 = load %struct.expdesc*, %struct.expdesc** %11, align 8, !tbaa !317
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %12, i64 0, i32 1
  %14 = bitcast %union.anon.8* %13 to i32*
  %15 = load i32, i32* %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 3
  %17 = load i32, i32* %16, align 4, !tbaa !316
  tail call fastcc void @luaK_setlist(%struct.FuncState* %0, i32 %15, i32 %17, i32 -1)
  %18 = load i32, i32* %16, align 4, !tbaa !316
  %19 = add nsw i32 %18, -1
  store i32 %19, i32* %16, align 4, !tbaa !316
  br label %30

; <label>:20:                                     ; preds = %6
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* %7)
  br label %21

; <label>:21:                                     ; preds = %6, %20
  %22 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %23 = load %struct.expdesc*, %struct.expdesc** %22, align 8, !tbaa !317
  %24 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %23, i64 0, i32 1
  %25 = bitcast %union.anon.8* %24 to i32*
  %26 = load i32, i32* %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 3
  %28 = load i32, i32* %27, align 4, !tbaa !316
  %29 = load i32, i32* %3, align 8, !tbaa !313
  tail call fastcc void @luaK_setlist(%struct.FuncState* %0, i32 %26, i32 %28, i32 %29)
  br label %30

; <label>:30:                                     ; preds = %2, %21, %10
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @luaO_int2fb(i32) unnamed_addr #6 {
  %2 = icmp ult i32 %0, 8
  br i1 %2, label %32, label %3

; <label>:3:                                      ; preds = %1
  %4 = icmp ugt i32 %0, 127
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %6
  %7 = phi i32 [ %11, %6 ], [ 0, %5 ]
  %8 = phi i32 [ %10, %6 ], [ %0, %5 ]
  %9 = add i32 %8, 15
  %10 = lshr i32 %9, 4
  %11 = add nuw nsw i32 %7, 4
  %12 = icmp ugt i32 %9, 2047
  br i1 %12, label %6, label %13

; <label>:13:                                     ; preds = %6, %3
  %14 = phi i32 [ %0, %3 ], [ %10, %6 ]
  %15 = phi i32 [ 0, %3 ], [ %11, %6 ]
  %16 = icmp ugt i32 %14, 15
  br i1 %16, label %17, label %25

; <label>:17:                                     ; preds = %13
  br label %18

; <label>:18:                                     ; preds = %17, %18
  %19 = phi i32 [ %23, %18 ], [ %15, %17 ]
  %20 = phi i32 [ %22, %18 ], [ %14, %17 ]
  %21 = add i32 %20, 1
  %22 = lshr i32 %21, 1
  %23 = add nuw nsw i32 %19, 1
  %24 = icmp ugt i32 %21, 31
  br i1 %24, label %18, label %25

; <label>:25:                                     ; preds = %18, %13
  %26 = phi i32 [ %14, %13 ], [ %22, %18 ]
  %27 = phi i32 [ %15, %13 ], [ %23, %18 ]
  %28 = shl i32 %27, 3
  %29 = add i32 %28, 8
  %30 = add nsw i32 %26, -8
  %31 = or i32 %29, %30
  br label %32

; <label>:32:                                     ; preds = %1, %25
  %33 = phi i32 [ %31, %25 ], [ %0, %1 ]
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_setlist(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = add nsw i32 %2, -1
  %6 = sdiv i32 %5, 50
  %7 = add nsw i32 %6, 1
  %8 = icmp eq i32 %3, -1
  %9 = select i1 %8, i32 0, i32 %3
  %10 = icmp slt i32 %2, 12751
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 79, i32 %1, i32 %9, i32 %7, i32 0)
  br label %20

; <label>:13:                                     ; preds = %4
  %14 = icmp slt i32 %2, 1677721551
  br i1 %14, label %15, label %17

; <label>:15:                                     ; preds = %13
  %16 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 79, i32 %1, i32 %9, i32 0, i32 0)
  tail call fastcc void @codeextraarg(%struct.FuncState* %0, i32 %7)
  br label %20

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %19 = load %struct.LexState*, %struct.LexState** %18, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %19, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.254, i64 0, i64 0)) #17
  unreachable

; <label>:20:                                     ; preds = %15, %11
  %21 = trunc i32 %1 to i8
  %22 = add i8 %21, 1
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %22, i8* %23, align 4, !tbaa !300
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaX_lookahead(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %3 = tail call fastcc i32 @llex(%struct.LexState* %0, %union.SemInfo* nonnull %2)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 0
  store i32 %3, i32* %4, align 8, !tbaa !262
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @listfield(%struct.LexState*, %struct.ConsControl*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 0
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %3)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 3
  %7 = load i32, i32* %6, align 4, !tbaa !316
  tail call fastcc void @checklimit(%struct.FuncState* %5, i32 %7, i32 2147483647, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.255, i64 0, i64 0))
  %8 = load i32, i32* %6, align 4, !tbaa !316
  %9 = add nsw i32 %8, 1
  store i32 %9, i32* %6, align 4, !tbaa !316
  %10 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 4
  %11 = load i32, i32* %10, align 8, !tbaa !313
  %12 = add nsw i32 %11, 1
  store i32 %12, i32* %10, align 8, !tbaa !313
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @recfield(%struct.LexState*, %struct.ConsControl* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !264
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 15
  %9 = load i8, i8* %8, align 4, !tbaa !300
  %10 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %10) #7
  %11 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  %12 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %12) #7
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !259
  %15 = icmp eq i32 %14, 292
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 2
  %18 = load i32, i32* %17, align 8, !tbaa !315
  tail call fastcc void @checklimit(%struct.FuncState* %7, i32 %18, i32 2147483647, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.255, i64 0, i64 0))
  call fastcc void @codename(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4)
  br label %20

; <label>:19:                                     ; preds = %2
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4)
  br label %20

; <label>:20:                                     ; preds = %19, %16
  %21 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 2
  %22 = load i32, i32* %21, align 8, !tbaa !315
  %23 = add nsw i32 %22, 1
  store i32 %23, i32* %21, align 8, !tbaa !315
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61)
  %24 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %25 = bitcast %struct.expdesc** %24 to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !317
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %10, i8* %26, i64 24, i32 8, i1 false), !tbaa.struct !311
  call fastcc void @luaK_indexed(%struct.FuncState* %7, %struct.expdesc* nonnull %3, %struct.expdesc* nonnull %4)
  call fastcc void @expr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5)
  call fastcc void @luaK_storevar(%struct.FuncState* %7, %struct.expdesc* nonnull %3, %struct.expdesc* nonnull %5)
  store i8 %9, i8* %8, align 4, !tbaa !300
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %10) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codename(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  tail call fastcc void @codestring(%struct.LexState* %0, %struct.expdesc* %1, %struct.TString* %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @yindex(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  tail call fastcc void @luaK_exp2val(%struct.FuncState* %4, %struct.expdesc* %1)
  tail call fastcc void @checknext(%struct.LexState* %0, i32 93)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_indexed(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  %6 = icmp eq i32 %5, 9
  br i1 %6, label %7, label %12

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc i32 @isKstr(%struct.FuncState* %0, %struct.expdesc* %2)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %7
  %11 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %12

; <label>:12:                                     ; preds = %7, %10, %3
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %14 = bitcast %union.anon.8* %13 to i32*
  %15 = load i32, i32* %14, align 8, !tbaa !21
  %16 = trunc i32 %15 to i8
  %17 = bitcast %union.anon.8* %13 to %struct.anon.9*
  %18 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %17, i64 0, i32 1
  store i8 %16, i8* %18, align 2, !tbaa !21
  %19 = load i32, i32* %4, align 8, !tbaa !285
  %20 = icmp eq i32 %19, 9
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %12
  %22 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %23 = bitcast %union.anon.8* %22 to i32*
  %24 = load i32, i32* %23, align 8, !tbaa !21
  %25 = trunc i32 %24 to i16
  br label %44

; <label>:26:                                     ; preds = %12
  %27 = tail call fastcc i32 @isKstr(%struct.FuncState* %0, %struct.expdesc* %2)
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %34, label %29

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %31 = bitcast %union.anon.8* %30 to i32*
  %32 = load i32, i32* %31, align 8, !tbaa !21
  %33 = trunc i32 %32 to i16
  br label %44

; <label>:34:                                     ; preds = %26
  %35 = tail call fastcc i32 @isCint(%struct.expdesc* %2)
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %41, label %37

; <label>:37:                                     ; preds = %34
  %38 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  %39 = load i64, i64* %38, align 8, !tbaa !21
  %40 = trunc i64 %39 to i16
  br label %44

; <label>:41:                                     ; preds = %34
  %42 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  %43 = trunc i32 %42 to i16
  br label %44

; <label>:44:                                     ; preds = %29, %41, %37, %21
  %45 = phi i16 [ %33, %29 ], [ %43, %41 ], [ %40, %37 ], [ %25, %21 ]
  %46 = phi i32 [ 13, %29 ], [ 10, %41 ], [ 12, %37 ], [ 11, %21 ]
  %47 = bitcast %union.anon.8* %13 to i16*
  store i16 %45, i16* %47, align 8, !tbaa !21
  store i32 %46, i32* %4, align 8, !tbaa !285
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_storevar(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  switch i32 %5, label %52 [
    i32 8, label %6
    i32 9, label %10
    i32 11, label %16
    i32 12, label %25
    i32 13, label %34
    i32 10, label %43
  ]

; <label>:6:                                      ; preds = %3
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* %2, i32 %9)
  br label %53

; <label>:10:                                     ; preds = %3
  %11 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  %15 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 8, i32 %11, i32 %14, i32 0, i32 0)
  br label %52

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to %struct.anon.9*
  %19 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 2, !tbaa !21
  %21 = zext i8 %20 to i32
  %22 = bitcast %union.anon.8* %17 to i16*
  %23 = load i16, i16* %22, align 8, !tbaa !21
  %24 = sext i16 %23 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 13, i32 %21, i32 %24, %struct.expdesc* %2)
  br label %52

; <label>:25:                                     ; preds = %3
  %26 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %27 = bitcast %union.anon.8* %26 to %struct.anon.9*
  %28 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %27, i64 0, i32 1
  %29 = load i8, i8* %28, align 2, !tbaa !21
  %30 = zext i8 %29 to i32
  %31 = bitcast %union.anon.8* %26 to i16*
  %32 = load i16, i16* %31, align 8, !tbaa !21
  %33 = sext i16 %32 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 15, i32 %30, i32 %33, %struct.expdesc* %2)
  br label %52

; <label>:34:                                     ; preds = %3
  %35 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %36 = bitcast %union.anon.8* %35 to %struct.anon.9*
  %37 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %36, i64 0, i32 1
  %38 = load i8, i8* %37, align 2, !tbaa !21
  %39 = zext i8 %38 to i32
  %40 = bitcast %union.anon.8* %35 to i16*
  %41 = load i16, i16* %40, align 8, !tbaa !21
  %42 = sext i16 %41 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 16, i32 %39, i32 %42, %struct.expdesc* %2)
  br label %52

; <label>:43:                                     ; preds = %3
  %44 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %45 = bitcast %union.anon.8* %44 to %struct.anon.9*
  %46 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %45, i64 0, i32 1
  %47 = load i8, i8* %46, align 2, !tbaa !21
  %48 = zext i8 %47 to i32
  %49 = bitcast %union.anon.8* %44 to i16*
  %50 = load i16, i16* %49, align 8, !tbaa !21
  %51 = sext i16 %50 to i32
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 14, i32 %48, i32 %51, %struct.expdesc* %2)
  br label %52

; <label>:52:                                     ; preds = %3, %43, %34, %25, %16, %10
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  br label %53

; <label>:53:                                     ; preds = %52, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_exp2val(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %4 = load i32, i32* %3, align 8, !tbaa !282
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !284
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %2
  %9 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %11

; <label>:10:                                     ; preds = %2
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %11

; <label>:11:                                     ; preds = %10, %8
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @isKstr(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  %5 = icmp eq i32 %4, 4
  br i1 %5, label %6, label %27

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !282
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !284
  %11 = icmp eq i32 %8, %10
  br i1 %11, label %12, label %27

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %14 = bitcast %union.anon.8* %13 to i32*
  %15 = load i32, i32* %14, align 8, !tbaa !21
  %16 = icmp slt i32 %15, 256
  br i1 %16, label %17, label %27

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %19 = load %struct.Proto*, %struct.Proto** %18, align 8, !tbaa !251
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %19, i64 0, i32 15
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !209
  %22 = sext i32 %15 to i64
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 %22, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = icmp eq i8 %24, 84
  %26 = zext i1 %25 to i32
  br label %27

; <label>:27:                                     ; preds = %6, %17, %12, %2
  %28 = phi i32 [ 0, %12 ], [ 0, %6 ], [ 0, %2 ], [ %26, %17 ]
  ret i32 %28
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @isCint(%struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %2 = tail call fastcc i32 @luaK_isKint(%struct.expdesc* %0)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %9, label %4

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %6 = load i64, i64* %5, align 8, !tbaa !21
  %7 = icmp ult i64 %6, 256
  %8 = zext i1 %7 to i32
  br label %9

; <label>:9:                                      ; preds = %1, %4
  %10 = phi i32 [ 0, %1 ], [ %8, %4 ]
  ret i32 %10
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @luaK_isKint(%struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !285
  %4 = icmp eq i32 %3, 6
  br i1 %4, label %5, label %12

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %7 = load i32, i32* %6, align 8, !tbaa !282
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %9 = load i32, i32* %8, align 4, !tbaa !284
  %10 = icmp eq i32 %7, %9
  %11 = zext i1 %10 to i32
  br label %12

; <label>:12:                                     ; preds = %5, %1
  %13 = phi i32 [ 0, %1 ], [ %11, %5 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeABRK(%struct.FuncState* nocapture, i32, i32, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %6 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %4)
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %1, i32 %2, i32 %3, i32 %9, i32 %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_exp2RK(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* %1)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1)
  br label %7

; <label>:7:                                      ; preds = %2, %5
  %8 = phi i32 [ 0, %5 ], [ 1, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @luaK_exp2K(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %4 = load i32, i32* %3, align 8, !tbaa !282
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %6 = load i32, i32* %5, align 4, !tbaa !284
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %8, label %36

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !285
  switch i32 %10, label %36 [
    i32 2, label %11
    i32 3, label %13
    i32 1, label %15
    i32 6, label %17
    i32 5, label %21
    i32 4, label %26
  ]

; <label>:11:                                     ; preds = %8
  %12 = tail call fastcc i32 @boolK(%struct.FuncState* %0, i32 1)
  br label %30

; <label>:13:                                     ; preds = %8
  %14 = tail call fastcc i32 @boolK(%struct.FuncState* %0, i32 0)
  br label %30

; <label>:15:                                     ; preds = %8
  %16 = tail call fastcc i32 @nilK(%struct.FuncState* %0)
  br label %30

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = tail call fastcc i32 @luaK_intK(%struct.FuncState* %0, i64 %19)
  br label %30

; <label>:21:                                     ; preds = %8
  %22 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %23 = bitcast %union.anon.8* %22 to double*
  %24 = load double, double* %23, align 8, !tbaa !21
  %25 = tail call fastcc i32 @luaK_numberK(%struct.FuncState* %0, double %24)
  br label %30

; <label>:26:                                     ; preds = %8
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %28 = bitcast %union.anon.8* %27 to i32*
  %29 = load i32, i32* %28, align 8, !tbaa !21
  br label %30

; <label>:30:                                     ; preds = %26, %21, %17, %15, %13, %11
  %31 = phi i32 [ %29, %26 ], [ %25, %21 ], [ %20, %17 ], [ %16, %15 ], [ %14, %13 ], [ %12, %11 ]
  %32 = icmp slt i32 %31, 256
  br i1 %32, label %33, label %36

; <label>:33:                                     ; preds = %30
  store i32 4, i32* %9, align 8, !tbaa !285
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %35 = bitcast %union.anon.8* %34 to i32*
  store i32 %31, i32* %35, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %8, %33, %2, %30
  %37 = phi i32 [ 0, %30 ], [ 0, %2 ], [ 0, %8 ], [ 1, %33 ]
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @boolK(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to i32*
  store i32 %1, i32* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 1, i8* %6, align 8, !tbaa !22
  %7 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @nilK(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = alloca %struct.TValue, align 8
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 0, i8* %6, align 8, !tbaa !22
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %8 = load %struct.LexState*, %struct.LexState** %7, align 8, !tbaa !272
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %8, i64 0, i32 9
  %10 = bitcast %struct.Table** %9 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !248
  %12 = bitcast %struct.TValue* %2 to i64*
  store i64 %11, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  store i8 69, i8* %13, align 8, !tbaa !22
  %14 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %2, %struct.TValue* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_setreturns(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !134
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i32, i32* %7, i64 %11
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !285
  switch i32 %14, label %32 [
    i32 16, label %15
    i32 17, label %21
  ]

; <label>:15:                                     ; preds = %3
  %16 = load i32, i32* %12, align 4, !tbaa !70
  %17 = and i32 %16, 16777215
  %18 = shl i32 %2, 24
  %19 = add i32 %18, 16777216
  %20 = or i32 %17, %19
  store i32 %20, i32* %12, align 4, !tbaa !70
  br label %32

; <label>:21:                                     ; preds = %3
  %22 = load i32, i32* %12, align 4, !tbaa !70
  %23 = and i32 %22, 16744575
  %24 = shl i32 %2, 24
  %25 = add i32 %24, 16777216
  %26 = or i32 %23, %25
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %28 = load i8, i8* %27, align 4, !tbaa !300
  %29 = zext i8 %28 to i32
  %30 = shl nuw nsw i32 %29, 7
  %31 = or i32 %30, %26
  store i32 %31, i32* %12, align 4, !tbaa !70
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* nonnull %0, i32 1)
  br label %32

; <label>:32:                                     ; preds = %3, %21, %15
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.Proto* @addprototype(%struct.LexState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !260
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !251
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 8
  %9 = load i32, i32* %8, align 8, !tbaa !278
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 10
  %11 = load i32, i32* %10, align 8, !tbaa !208
  %12 = icmp slt i32 %9, %11
  br i1 %12, label %30, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 17
  %15 = bitcast %struct.Proto*** %14 to i8**
  %16 = load i8*, i8** %15, align 8, !tbaa !207
  %17 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %3, i8* %16, i32 %9, i32* nonnull %10, i32 8, i32 131071, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.257, i64 0, i64 0))
  store i8* %17, i8** %15, align 8, !tbaa !207
  %18 = load i32, i32* %10, align 8, !tbaa !208
  %19 = icmp slt i32 %11, %18
  br i1 %19, label %20, label %30

; <label>:20:                                     ; preds = %13
  %21 = load i32, i32* %10, align 8, !tbaa !208
  %22 = sext i32 %11 to i64
  %23 = sext i32 %21 to i64
  br label %24

; <label>:24:                                     ; preds = %20, %24
  %25 = phi i64 [ %22, %20 ], [ %27, %24 ]
  %26 = load %struct.Proto**, %struct.Proto*** %14, align 8, !tbaa !207
  %27 = add nsw i64 %25, 1
  %28 = getelementptr inbounds %struct.Proto*, %struct.Proto** %26, i64 %25
  store %struct.Proto* null, %struct.Proto** %28, align 8, !tbaa !79
  %29 = icmp slt i64 %27, %23
  br i1 %29, label %24, label %30

; <label>:30:                                     ; preds = %24, %13, %1
  %31 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %3)
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 17
  %33 = load %struct.Proto**, %struct.Proto*** %32, align 8, !tbaa !207
  %34 = load i32, i32* %8, align 8, !tbaa !278
  %35 = add nsw i32 %34, 1
  store i32 %35, i32* %8, align 8, !tbaa !278
  %36 = sext i32 %34 to i64
  %37 = getelementptr inbounds %struct.Proto*, %struct.Proto** %33, i64 %36
  store %struct.Proto* %31, %struct.Proto** %37, align 8, !tbaa !79
  %38 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 2
  %39 = load i8, i8* %38, align 1, !tbaa !226
  %40 = and i8 %39, 32
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %50, label %42

; <label>:42:                                     ; preds = %30
  %43 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 2
  %44 = load i8, i8* %43, align 1, !tbaa !226
  %45 = and i8 %44, 24
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %50, label %47

; <label>:47:                                     ; preds = %42
  %48 = bitcast %struct.Proto* %7 to %struct.GCObject*
  %49 = bitcast %struct.Proto* %31 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %3, %struct.GCObject* %48, %struct.GCObject* %49)
  br label %50

; <label>:50:                                     ; preds = %42, %30, %47
  ret %struct.Proto* %31
}

; Function Attrs: nounwind uwtable
define internal fastcc void @new_localvar(%struct.LexState* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = tail call fastcc i32 @registerlocalvar(%struct.LexState* %0, %struct.TString* %1)
  %8 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 1
  %9 = load i32, i32* %8, align 8, !tbaa !257
  %10 = add nsw i32 %9, 1
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 10
  %12 = load i32, i32* %11, align 8, !tbaa !279
  %13 = sub i32 %10, %12
  tail call fastcc void @checklimit(%struct.FuncState* %4, i32 %13, i32 200, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0))
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !260
  %16 = bitcast %struct.Dyndata* %6 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !319
  %18 = load i32, i32* %8, align 8, !tbaa !257
  %19 = add nsw i32 %18, 1
  %20 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 2
  %21 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %15, i8* %17, i32 %19, i32* nonnull %20, i32 2, i32 2147483647, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0))
  %22 = bitcast i8* %21 to %struct.Vardesc*
  store i8* %21, i8** %16, align 8, !tbaa !319
  %23 = trunc i32 %7 to i16
  %24 = load i32, i32* %8, align 8, !tbaa !257
  %25 = add nsw i32 %24, 1
  store i32 %25, i32* %8, align 8, !tbaa !257
  %26 = sext i32 %24 to i64
  %27 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %22, i64 %26, i32 0
  store i16 %23, i16* %27, align 2, !tbaa !320
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @adjustlocalvars(%struct.LexState* nocapture readonly, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !288
  %7 = trunc i32 %1 to i8
  %8 = add i8 %6, %7
  store i8 %8, i8* %5, align 2, !tbaa !288
  %9 = icmp eq i32 %1, 0
  br i1 %9, label %21, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 4
  %12 = zext i8 %8 to i32
  br label %13

; <label>:13:                                     ; preds = %10, %13
  %14 = phi i32 [ %1, %10 ], [ %19, %13 ]
  %15 = load i32, i32* %11, align 8, !tbaa !273
  %16 = sub nsw i32 %12, %14
  %17 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %4, i32 %16)
  %18 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %17, i64 0, i32 1
  store i32 %15, i32* %18, align 8, !tbaa !85
  %19 = add nsw i32 %14, -1
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %13

; <label>:21:                                     ; preds = %13, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @parlist(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %3 = load %struct.FuncState*, %struct.FuncState** %2, align 8, !tbaa !264
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %3, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !251
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !259
  %8 = icmp eq i32 %7, 41
  br i1 %8, label %22, label %9

; <label>:9:                                      ; preds = %1
  br label %12

; <label>:10:                                     ; preds = %17
  %11 = load i32, i32* %6, align 8, !tbaa !259
  br label %12

; <label>:12:                                     ; preds = %9, %10
  %13 = phi i32 [ %11, %10 ], [ %7, %9 ]
  %14 = phi i32 [ %19, %10 ], [ 0, %9 ]
  switch i32 %13, label %15 [
    i32 292, label %17
    i32 281, label %16
  ]

; <label>:15:                                     ; preds = %12
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.259, i64 0, i64 0)) #17
  unreachable

; <label>:16:                                     ; preds = %12
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %22

; <label>:17:                                     ; preds = %12
  %18 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0)
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %18)
  %19 = add nuw nsw i32 %14, 1
  %20 = tail call fastcc i32 @testnext(%struct.LexState* nonnull %0, i32 44)
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %10

; <label>:22:                                     ; preds = %17, %16, %1
  %23 = phi i32 [ %14, %16 ], [ 0, %1 ], [ %19, %17 ]
  %24 = phi i1 [ false, %16 ], [ true, %1 ], [ true, %17 ]
  tail call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 %23)
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %3, i64 0, i32 13
  %26 = load i8, i8* %25, align 2, !tbaa !288
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 3
  store i8 %26, i8* %27, align 2, !tbaa !95
  br i1 %24, label %30, label %28

; <label>:28:                                     ; preds = %22
  %29 = zext i8 %26 to i32
  tail call fastcc void @setvararg(%struct.FuncState* nonnull %3, i32 %29)
  br label %30

; <label>:30:                                     ; preds = %22, %28
  %31 = load i8, i8* %25, align 2, !tbaa !288
  %32 = zext i8 %31 to i32
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* nonnull %3, i32 %32)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeclosure(%struct.LexState* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 1
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !271
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 8
  %8 = load i32, i32* %7, align 8, !tbaa !278
  %9 = add nsw i32 %8, -1
  %10 = tail call fastcc i32 @luaK_codeABx(%struct.FuncState* %6, i32 80, i32 0, i32 %9)
  tail call fastcc void @init_exp(%struct.expdesc* %1, i32 15, i32 %10)
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @registerlocalvar(%struct.LexState* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !251
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 11
  %8 = load i32, i32* %7, align 4, !tbaa !82
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !260
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 21
  %12 = bitcast %struct.LocVar** %11 to i8**
  %13 = load i8*, i8** %12, align 8, !tbaa !84
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 12
  %15 = load i16, i16* %14, align 8, !tbaa !289
  %16 = sext i16 %15 to i32
  %17 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %10, i8* %13, i32 %16, i32* nonnull %7, i32 16, i32 32767, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0))
  store i8* %17, i8** %12, align 8, !tbaa !84
  %18 = load i32, i32* %7, align 4, !tbaa !82
  %19 = icmp slt i32 %8, %18
  %20 = bitcast i8* %17 to %struct.LocVar*
  br i1 %19, label %21, label %32

; <label>:21:                                     ; preds = %2
  %22 = load i32, i32* %7, align 4, !tbaa !82
  %23 = load %struct.LocVar*, %struct.LocVar** %11, align 8, !tbaa !84
  %24 = sext i32 %8 to i64
  %25 = sext i32 %22 to i64
  br label %26

; <label>:26:                                     ; preds = %21, %26
  %27 = phi i64 [ %24, %21 ], [ %29, %26 ]
  %28 = phi %struct.LocVar* [ %20, %21 ], [ %23, %26 ]
  %29 = add nsw i64 %27, 1
  %30 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %28, i64 %27, i32 0
  store %struct.TString* null, %struct.TString** %30, align 8, !tbaa !88
  %31 = icmp slt i64 %29, %25
  br i1 %31, label %26, label %32

; <label>:32:                                     ; preds = %26, %2
  %33 = phi %struct.LocVar* [ %20, %2 ], [ %23, %26 ]
  %34 = load i16, i16* %14, align 8, !tbaa !289
  %35 = sext i16 %34 to i64
  %36 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %33, i64 %35, i32 0
  store %struct.TString* %1, %struct.TString** %36, align 8, !tbaa !88
  %37 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 2
  %38 = load i8, i8* %37, align 1, !tbaa !226
  %39 = and i8 %38, 32
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %50, label %41

; <label>:41:                                     ; preds = %32
  %42 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %43 = load i8, i8* %42, align 1, !tbaa !227
  %44 = and i8 %43, 24
  %45 = icmp eq i8 %44, 0
  br i1 %45, label %50, label %46

; <label>:46:                                     ; preds = %41
  %47 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !260
  %48 = bitcast %struct.Proto* %6 to %struct.GCObject*
  %49 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %47, %struct.GCObject* %48, %struct.GCObject* %49)
  br label %50

; <label>:50:                                     ; preds = %41, %32, %46
  %51 = load i16, i16* %14, align 8, !tbaa !289
  %52 = add i16 %51, 1
  store i16 %52, i16* %14, align 8, !tbaa !289
  %53 = sext i16 %51 to i32
  ret i32 %53
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %4 = load %struct.LexState*, %struct.LexState** %3, align 8, !tbaa !272
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %4, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 0
  %8 = load %struct.Vardesc*, %struct.Vardesc** %7, align 8, !tbaa !319
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 10
  %10 = load i32, i32* %9, align 8, !tbaa !279
  %11 = add nsw i32 %10, %1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %8, i64 %12, i32 0
  %14 = load i16, i16* %13, align 2, !tbaa !320
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %16 = load %struct.Proto*, %struct.Proto** %15, align 8, !tbaa !251
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 21
  %18 = load %struct.LocVar*, %struct.LocVar** %17, align 8, !tbaa !84
  %19 = sext i16 %14 to i64
  %20 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %18, i64 %19
  ret %struct.LocVar* %20
}

; Function Attrs: nounwind uwtable
define internal fastcc void @primaryexp(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !259
  switch i32 %4, label %11 [
    i32 40, label %5
    i32 292, label %10
  ]

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !265
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  tail call fastcc void @expr(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %7)
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %9, %struct.expdesc* %1)
  br label %12

; <label>:10:                                     ; preds = %2
  tail call fastcc void @singlevar(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %12

; <label>:11:                                     ; preds = %2
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.260, i64 0, i64 0)) #17
  unreachable

; <label>:12:                                     ; preds = %10, %5
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fieldsel(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  tail call fastcc void @luaK_exp2anyregup(%struct.FuncState* %5, %struct.expdesc* %1)
  tail call fastcc void @luaX_next(%struct.LexState* %0)
  call fastcc void @codename(%struct.LexState* %0, %struct.expdesc* nonnull %3)
  call fastcc void @luaK_indexed(%struct.FuncState* %5, %struct.expdesc* %1, %struct.expdesc* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_exp2anyregup(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !285
  %5 = icmp eq i32 %4, 9
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !282
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !284
  %11 = icmp eq i32 %8, %10
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %6, %2
  %13 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  br label %14

; <label>:14:                                     ; preds = %6, %12
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_self(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1)
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %6 = bitcast %union.anon.8* %5 to i32*
  %7 = load i32, i32* %6, align 8, !tbaa !21
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %1)
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %9 = load i8, i8* %8, align 4, !tbaa !300
  %10 = zext i8 %9 to i32
  store i32 %10, i32* %6, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 7, i32* %11, align 8, !tbaa !285
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %0, i32 2)
  %12 = load i32, i32* %6, align 8, !tbaa !21
  tail call fastcc void @codeABRK(%struct.FuncState* %0, i32 18, i32 %12, i32 %7, %struct.expdesc* %2)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @funcargs(%struct.LexState*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !259
  switch i32 %9, label %23 [
    i32 40, label %10
    i32 123, label %18
    i32 293, label %19
  ]

; <label>:10:                                     ; preds = %3
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  %11 = load i32, i32* %8, align 8, !tbaa !259
  %12 = icmp eq i32 %11, 41
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %10
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 0, i32* %14, align 8, !tbaa !285
  br label %17

; <label>:15:                                     ; preds = %10
  %16 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4)
  call fastcc void @luaK_setreturns(%struct.FuncState* %6, %struct.expdesc* nonnull %4, i32 -1)
  br label %17

; <label>:17:                                     ; preds = %15, %13
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %2)
  br label %24

; <label>:18:                                     ; preds = %3
  call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4)
  br label %24

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %21 = bitcast %union.SemInfo* %20 to %struct.TString**
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !21
  call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4, %struct.TString* %22)
  tail call fastcc void @luaX_next(%struct.LexState* nonnull %0)
  br label %24

; <label>:23:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.261, i64 0, i64 0)) #17
  unreachable

; <label>:24:                                     ; preds = %19, %18, %17
  %25 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %26 = bitcast %union.anon.8* %25 to i32*
  %27 = load i32, i32* %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  %29 = load i32, i32* %28, align 8, !tbaa !285
  switch i32 %29, label %30 [
    i32 16, label %36
    i32 17, label %36
    i32 0, label %31
  ]

; <label>:30:                                     ; preds = %24
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* nonnull %4)
  br label %31

; <label>:31:                                     ; preds = %24, %30
  %32 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %33 = load i8, i8* %32, align 4, !tbaa !300
  %34 = zext i8 %33 to i32
  %35 = sub i32 %34, %27
  br label %36

; <label>:36:                                     ; preds = %24, %24, %31
  %37 = phi i32 [ %35, %31 ], [ 0, %24 ], [ 0, %24 ]
  %38 = call fastcc i32 @luaK_codeABCk(%struct.FuncState* %6, i32 69, i32 %27, i32 %37, i32 2, i32 0)
  call fastcc void @init_exp(%struct.expdesc* nonnull %1, i32 16, i32 %38)
  call fastcc void @luaK_fixline(%struct.FuncState* %6, i32 %2)
  %39 = trunc i32 %27 to i8
  %40 = add i8 %39, 1
  %41 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  store i8 %40, i8* %41, align 4, !tbaa !300
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @singlevar(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  tail call fastcc void @singlevaraux(%struct.FuncState* %6, %struct.TString* %4, %struct.expdesc* %1, i32 1)
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !285
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 12
  %13 = load %struct.TString*, %struct.TString** %12, align 8, !tbaa !268
  tail call fastcc void @singlevaraux(%struct.FuncState* %6, %struct.TString* %13, %struct.expdesc* nonnull %1, i32 1)
  call fastcc void @codestring(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3, %struct.TString* %4)
  call fastcc void @luaK_indexed(%struct.FuncState* %6, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  br label %14

; <label>:14:                                     ; preds = %10, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @singlevaraux(%struct.FuncState*, %struct.TString*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %5 = icmp eq %struct.FuncState* %0, null
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call fastcc void @init_exp(%struct.expdesc* %2, i32 0, i32 0)
  ret void

; <label>:7:                                      ; preds = %4
  %8 = tail call fastcc i32 @searchvar(%struct.FuncState* nonnull %0, %struct.TString* %1)
  %9 = icmp sgt i32 %8, -1
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %7
  tail call fastcc void @init_exp(%struct.expdesc* %2, i32 8, i32 %8)
  %11 = icmp eq i32 %3, 0
  br i1 %11, label %12, label %26

; <label>:12:                                     ; preds = %10
  tail call fastcc void @markupval(%struct.FuncState* nonnull %0, i32 %8)
  br label %26

; <label>:13:                                     ; preds = %7
  %14 = tail call fastcc i32 @searchupvalue(%struct.FuncState* nonnull %0, %struct.TString* %1)
  %15 = icmp slt i32 %14, 0
  br i1 %15, label %16, label %24

; <label>:16:                                     ; preds = %13
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 1
  %18 = load %struct.FuncState*, %struct.FuncState** %17, align 8, !tbaa !271
  tail call fastcc void @singlevaraux(%struct.FuncState* %18, %struct.TString* %1, %struct.expdesc* %2, i32 0)
  %19 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %20 = load i32, i32* %19, align 8, !tbaa !285
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %26, label %22

; <label>:22:                                     ; preds = %16
  %23 = tail call fastcc i32 @newupvalue(%struct.FuncState* nonnull %0, %struct.TString* %1, %struct.expdesc* nonnull %2)
  br label %24

; <label>:24:                                     ; preds = %22, %13
  %25 = phi i32 [ %23, %22 ], [ %14, %13 ]
  tail call fastcc void @init_exp(%struct.expdesc* %2, i32 9, i32 %25)
  br label %26

; <label>:26:                                     ; preds = %12, %10, %24, %16
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @searchvar(%struct.FuncState* nocapture readonly, %struct.TString* readnone) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %4 = load i8, i8* %3, align 2, !tbaa !288
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %17, label %6

; <label>:6:                                      ; preds = %2
  %7 = zext i8 %4 to i32
  br label %10

; <label>:8:                                      ; preds = %10
  %9 = icmp sgt i32 %11, 1
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %6, %8
  %11 = phi i32 [ %7, %6 ], [ %12, %8 ]
  %12 = add nsw i32 %11, -1
  %13 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %0, i32 %12)
  %14 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %13, i64 0, i32 0
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !88
  %16 = icmp eq %struct.TString* %15, %1
  br i1 %16, label %17, label %8

; <label>:17:                                     ; preds = %10, %8, %2
  %18 = phi i32 [ -1, %2 ], [ -1, %8 ], [ %12, %10 ]
  ret i32 %18
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @markupval(%struct.FuncState* nocapture, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  br label %4

; <label>:4:                                      ; preds = %4, %2
  %5 = phi %struct.BlockCnt** [ %3, %2 ], [ %11, %4 ]
  %6 = load %struct.BlockCnt*, %struct.BlockCnt** %5, align 8, !tbaa !79
  %7 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 3
  %8 = load i8, i8* %7, align 8, !tbaa !292
  %9 = zext i8 %8 to i32
  %10 = icmp sgt i32 %9, %1
  %11 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 0
  br i1 %10, label %4, label %12

; <label>:12:                                     ; preds = %4
  %13 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 4
  store i8 1, i8* %13, align 1, !tbaa !295
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 17
  store i8 1, i8* %14, align 2, !tbaa !322
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @searchupvalue(%struct.FuncState* nocapture readonly, %struct.TString* readnone) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !251
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 18
  %6 = load %struct.Upvaldesc*, %struct.Upvaldesc** %5, align 8, !tbaa !174
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %8 = load i8, i8* %7, align 1, !tbaa !286
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %23, label %10

; <label>:10:                                     ; preds = %2
  br label %11

; <label>:11:                                     ; preds = %10, %16
  %12 = phi i64 [ %17, %16 ], [ 0, %10 ]
  %13 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %6, i64 %12, i32 0
  %14 = load %struct.TString*, %struct.TString** %13, align 8, !tbaa !175
  %15 = icmp eq %struct.TString* %14, %1
  br i1 %15, label %21, label %16

; <label>:16:                                     ; preds = %11
  %17 = add nuw nsw i64 %12, 1
  %18 = load i8, i8* %7, align 1, !tbaa !286
  %19 = zext i8 %18 to i64
  %20 = icmp ult i64 %17, %19
  br i1 %20, label %11, label %23

; <label>:21:                                     ; preds = %11
  %22 = trunc i64 %12 to i32
  br label %23

; <label>:23:                                     ; preds = %16, %21, %2
  %24 = phi i32 [ -1, %2 ], [ %22, %21 ], [ -1, %16 ]
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @explist(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1)
  %3 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %13, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  br label %7

; <label>:7:                                      ; preds = %5, %7
  %8 = phi i32 [ 1, %5 ], [ %10, %7 ]
  %9 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !264
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %9, %struct.expdesc* %1)
  tail call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* %1)
  %10 = add nuw nsw i32 %8, 1
  %11 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %7

; <label>:13:                                     ; preds = %7, %2
  %14 = phi i32 [ 1, %2 ], [ %10, %7 ]
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @isSCnumber(%struct.expdesc* nocapture readonly, i64* nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  switch i32 %5, label %28 [
    i32 6, label %6
    i32 5, label %9
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  store i64 %8, i64* %1, align 8, !tbaa !109
  br label %16

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to double*
  %12 = load double, double* %11, align 8, !tbaa !21
  %13 = tail call fastcc i32 @floatI(double %12, i64* %1)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %28, label %15

; <label>:15:                                     ; preds = %9
  store i32 1, i32* %2, align 4, !tbaa !70
  br label %16

; <label>:16:                                     ; preds = %15, %6
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %18 = load i32, i32* %17, align 8, !tbaa !282
  %19 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %20 = load i32, i32* %19, align 4, !tbaa !284
  %21 = icmp eq i32 %18, %20
  br i1 %21, label %22, label %28

; <label>:22:                                     ; preds = %16
  %23 = load i64, i64* %1, align 8, !tbaa !109
  %24 = tail call fastcc i32 @fitsC(i64 %23)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %28, label %26

; <label>:26:                                     ; preds = %22
  %27 = add nsw i64 %23, 127
  store i64 %27, i64* %1, align 8, !tbaa !109
  br label %28

; <label>:28:                                     ; preds = %16, %22, %9, %3, %26
  %29 = phi i32 [ 1, %26 ], [ 0, %3 ], [ 0, %9 ], [ 0, %22 ], [ 0, %16 ]
  ret i32 %29
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @fitsC(i64) unnamed_addr #6 {
  %2 = add i64 %0, 127
  %3 = icmp ult i64 %2, 256
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeconcat(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture readonly, i32) unnamed_addr #0 {
  %5 = tail call fastcc i32* @previousinstruction(%struct.FuncState* %0)
  %6 = load i32, i32* %5, align 4, !tbaa !70
  %7 = and i32 %6, 127
  %8 = icmp eq i32 %7, 54
  br i1 %8, label %9, label %22

; <label>:9:                                      ; preds = %4
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  %10 = load i32, i32* %5, align 4, !tbaa !70
  %11 = and i32 %10, -16744321
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  %15 = shl i32 %14, 7
  %16 = and i32 %15, 32640
  %17 = and i32 %6, 16711680
  %18 = add nuw nsw i32 %17, 65536
  %19 = and i32 %18, 16711680
  %20 = or i32 %11, %19
  %21 = or i32 %20, %16
  store i32 %21, i32* %5, align 4, !tbaa !70
  br label %27

; <label>:22:                                     ; preds = %4
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = load i32, i32* %24, align 8, !tbaa !21
  %26 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 54, i32 %25, i32 2, i32 0, i32 0)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* %2)
  tail call fastcc void @luaK_fixline(%struct.FuncState* %0, i32 %3)
  br label %27

; <label>:27:                                     ; preds = %22, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codecommutative(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @tonumeral(%struct.expdesc* %2, %struct.TValue* null)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %5
  tail call fastcc void @swapexps(%struct.expdesc* %2, %struct.expdesc* %3)
  br label %9

; <label>:9:                                      ; preds = %5, %8
  %10 = phi i32 [ 1, %8 ], [ 0, %5 ]
  tail call fastcc void @codearith(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %10, i32 %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codearith(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %7 = tail call fastcc i32 @isSCint(%struct.expdesc* %3)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %11, label %9

; <label>:9:                                      ; preds = %6
  %10 = add i32 %1, -19
  tail call fastcc void @codebini(%struct.FuncState* %0, i32 %10, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4, i32 %5)
  br label %26

; <label>:11:                                     ; preds = %6
  %12 = tail call fastcc i32 @tonumeral(%struct.expdesc* %3, %struct.TValue* null)
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %22, label %14

; <label>:14:                                     ; preds = %11
  %15 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* %3)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %22, label %17

; <label>:17:                                     ; preds = %14
  %18 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %19 = bitcast %union.anon.8* %18 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = add i32 %1, -12
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %21, i32 %20, i32 %4, i32 %5)
  br label %26

; <label>:22:                                     ; preds = %14, %11
  %23 = icmp eq i32 %4, 0
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %22
  tail call fastcc void @swapexps(%struct.expdesc* %2, %struct.expdesc* %3)
  br label %25

; <label>:25:                                     ; preds = %22, %24
  tail call fastcc void @codebinexpval(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %5)
  br label %26

; <label>:26:                                     ; preds = %17, %25, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codebitwise(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !285
  %8 = icmp eq i32 %7, 6
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %5
  %10 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* nonnull %2)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  tail call fastcc void @swapexps(%struct.expdesc* nonnull %2, %struct.expdesc* %3)
  br label %22

; <label>:13:                                     ; preds = %9, %5
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %15 = load i32, i32* %14, align 8, !tbaa !285
  %16 = icmp eq i32 %15, 6
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %13
  %18 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* nonnull %3)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %17, %13
  %21 = add i32 %1, 38
  tail call fastcc void @codebinexpval(%struct.FuncState* %0, i32 %21, %struct.expdesc* nonnull %2, %struct.expdesc* nonnull %3, i32 %4)
  br label %28

; <label>:22:                                     ; preds = %17, %12
  %23 = phi i32 [ 1, %12 ], [ 0, %17 ]
  %24 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %25 = bitcast %union.anon.8* %24 to i32*
  %26 = load i32, i32* %25, align 8, !tbaa !21
  %27 = add i32 %1, 26
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* nonnull %2, %struct.expdesc* %3, i32 %27, i32 %26, i32 %23, i32 %4)
  br label %28

; <label>:28:                                     ; preds = %22, %20
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @isSCint(%struct.expdesc* nocapture readonly) unnamed_addr #3 {
  %2 = tail call fastcc i32 @luaK_isKint(%struct.expdesc* %0)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %10, label %4

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %6 = load i64, i64* %5, align 8, !tbaa !21
  %7 = tail call fastcc i32 @fitsC(i64 %6)
  %8 = icmp ne i32 %7, 0
  %9 = zext i1 %8 to i32
  br label %10

; <label>:10:                                     ; preds = %1, %4
  %11 = phi i32 [ 0, %1 ], [ %9, %4 ]
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal fastcc void @swapexps(%struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4)
  %5 = bitcast %struct.expdesc* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %4, i8* %5, i64 24, i32 8, i1 false), !tbaa.struct !311
  %6 = bitcast %struct.expdesc* %1 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 24, i32 8, i1 false), !tbaa.struct !311
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* nonnull %4, i64 24, i32 8, i1 false), !tbaa.struct !311
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codebini(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly, i32, i32) unnamed_addr #0 {
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = trunc i64 %8 to i32
  %10 = add nsw i32 %9, 127
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %1, i32 %10, i32 %4, i32 %5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeshift(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @isSCint(%struct.expdesc* %3)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %16, label %8

; <label>:8:                                      ; preds = %5
  %9 = icmp eq i32 %1, 48
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %8
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = sub nsw i64 0, %12
  store i64 %13, i64* %11, align 8, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %10, %8
  %15 = phi i32 [ 1, %10 ], [ 0, %8 ]
  tail call fastcc void @codebini(%struct.FuncState* %0, i32 36, %struct.expdesc* %2, %struct.expdesc* %3, i32 %15, i32 %4)
  br label %17

; <label>:16:                                     ; preds = %5
  tail call fastcc void @codebinexpval(%struct.FuncState* %0, i32 %1, %struct.expdesc* %2, %struct.expdesc* %3, i32 %4)
  br label %17

; <label>:17:                                     ; preds = %16, %14
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeeq(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  store i32 0, i32* %6, align 4, !tbaa !70
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !285
  %11 = icmp eq i32 %10, 7
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %4
  tail call fastcc void @swapexps(%struct.expdesc* nonnull %2, %struct.expdesc* %3)
  br label %13

; <label>:13:                                     ; preds = %4, %12
  %14 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %2)
  %15 = call fastcc i32 @isSCnumber(%struct.expdesc* %3, i64* nonnull %5, i32* nonnull %6)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %20, label %17

; <label>:17:                                     ; preds = %13
  %18 = load i64, i64* %5, align 8, !tbaa !109
  %19 = trunc i64 %18 to i32
  br label %29

; <label>:20:                                     ; preds = %13
  %21 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %3)
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %27, label %23

; <label>:23:                                     ; preds = %20
  %24 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %25 = bitcast %union.anon.8* %24 to i32*
  %26 = load i32, i32* %25, align 8, !tbaa !21
  br label %29

; <label>:27:                                     ; preds = %20
  %28 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3)
  br label %29

; <label>:29:                                     ; preds = %23, %27, %17
  %30 = phi i32 [ %19, %17 ], [ %26, %23 ], [ %28, %27 ]
  %31 = phi i32 [ 62, %17 ], [ 61, %23 ], [ 58, %27 ]
  tail call fastcc void @freeexps(%struct.FuncState* %0, %struct.expdesc* nonnull %2, %struct.expdesc* %3)
  %32 = load i32, i32* %6, align 4, !tbaa !70
  %33 = icmp eq i32 %1, 13
  %34 = zext i1 %33 to i32
  %35 = tail call fastcc i32 @condjump(%struct.FuncState* %0, i32 %31, i32 %14, i32 %30, i32 %32, i32 %34)
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to i32*
  store i32 %35, i32* %37, align 8, !tbaa !21
  store i32 14, i32* %9, align 8, !tbaa !285
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codeorder(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  store i32 0, i32* %6, align 4, !tbaa !70
  %9 = call fastcc i32 @isSCnumber(%struct.expdesc* %3, i64* nonnull %5, i32* nonnull %6)
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  %13 = load i64, i64* %5, align 8, !tbaa !109
  %14 = trunc i64 %13 to i32
  %15 = add i32 %1, 4
  br label %28

; <label>:16:                                     ; preds = %4
  %17 = call fastcc i32 @isSCnumber(%struct.expdesc* %2, i64* nonnull %5, i32* nonnull %6)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %16
  %20 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3)
  %21 = load i64, i64* %5, align 8, !tbaa !109
  %22 = trunc i64 %21 to i32
  %23 = icmp eq i32 %1, 59
  %24 = select i1 %23, i32 65, i32 66
  br label %28

; <label>:25:                                     ; preds = %16
  %26 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2)
  %27 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3)
  br label %28

; <label>:28:                                     ; preds = %19, %25, %11
  %29 = phi i32 [ %15, %11 ], [ %24, %19 ], [ %1, %25 ]
  %30 = phi i32 [ %12, %11 ], [ %20, %19 ], [ %26, %25 ]
  %31 = phi i32 [ %14, %11 ], [ %22, %19 ], [ %27, %25 ]
  tail call fastcc void @freeexps(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3)
  %32 = load i32, i32* %6, align 4, !tbaa !70
  %33 = tail call fastcc i32 @condjump(%struct.FuncState* %0, i32 %29, i32 %30, i32 %31, i32 %32, i32 1)
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %35 = bitcast %union.anon.8* %34 to i32*
  store i32 %33, i32* %35, align 8, !tbaa !21
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 14, i32* %36, align 8, !tbaa !285
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @finishbinexpval(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  %8 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1)
  %9 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %3, i32 0, i32 %8, i32 %4, i32 %5)
  tail call fastcc void @freeexps(%struct.FuncState* %0, %struct.expdesc* %1, %struct.expdesc* %2)
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  store i32 %9, i32* %11, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %12, align 8, !tbaa !285
  tail call fastcc void @luaK_fixline(%struct.FuncState* %0, i32 %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @codebinexpval(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3)
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* %3, i32 %1, i32 %6, i32 0, i32 %4)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @freeexps(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture readonly) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  %6 = icmp eq i32 %5, 7
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  br label %11

; <label>:11:                                     ; preds = %3, %7
  %12 = phi i32 [ %10, %7 ], [ -1, %3 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !285
  %15 = icmp eq i32 %14, 7
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %11
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  %19 = load i32, i32* %18, align 8, !tbaa !21
  br label %20

; <label>:20:                                     ; preds = %11, %16
  %21 = phi i32 [ %19, %16 ], [ -1, %11 ]
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %12, i32 %21)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @condjump(%struct.FuncState* nocapture, i32, i32, i32, i32, i32) unnamed_addr #0 {
  %7 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5)
  %8 = tail call fastcc i32 @luaK_jump(%struct.FuncState* %0)
  ret i32 %8
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc %struct.Labeldesc* @findlabel(%struct.LexState* nocapture readonly, %struct.TString* readnone) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %4 = load %struct.Dyndata*, %struct.Dyndata** %3, align 8, !tbaa !254
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 11
  %8 = load i32, i32* %7, align 4, !tbaa !280
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 2, i32 1
  %10 = load i32, i32* %9, align 8, !tbaa !255
  %11 = icmp slt i32 %8, %10
  br i1 %11, label %12, label %27

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 2, i32 0
  %14 = load %struct.Labeldesc*, %struct.Labeldesc** %13, align 8, !tbaa !323
  %15 = sext i32 %8 to i64
  br label %20

; <label>:16:                                     ; preds = %20
  %17 = load i32, i32* %9, align 8, !tbaa !255
  %18 = sext i32 %17 to i64
  %19 = icmp slt i64 %26, %18
  br i1 %19, label %20, label %27

; <label>:20:                                     ; preds = %12, %16
  %21 = phi i64 [ %15, %12 ], [ %26, %16 ]
  %22 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %21
  %23 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %22, i64 0, i32 0
  %24 = load %struct.TString*, %struct.TString** %23, align 8, !tbaa !324
  %25 = icmp eq %struct.TString* %24, %1
  %26 = add nsw i64 %21, 1
  br i1 %25, label %27, label %16

; <label>:27:                                     ; preds = %16, %20, %2
  %28 = phi %struct.Labeldesc* [ null, %2 ], [ %22, %20 ], [ null, %16 ]
  ret %struct.Labeldesc* %28
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @jumponcond(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  %6 = icmp eq i32 %5, 15
  br i1 %6, label %7, label %26

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !251
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !134
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds i32, i32* %11, i64 %15
  %17 = load i32, i32* %16, align 4, !tbaa !70
  %18 = and i32 %17, 127
  %19 = icmp eq i32 %18, 52
  br i1 %19, label %20, label %26

; <label>:20:                                     ; preds = %7
  tail call fastcc void @removelastinstruction(%struct.FuncState* nonnull %0)
  %21 = lshr i32 %17, 16
  %22 = and i32 %21, 255
  %23 = icmp eq i32 %2, 0
  %24 = zext i1 %23 to i32
  %25 = tail call fastcc i32 @condjump(%struct.FuncState* nonnull %0, i32 67, i32 %22, i32 0, i32 0, i32 %24)
  br label %31

; <label>:26:                                     ; preds = %7, %3
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  tail call fastcc void @freeexp(%struct.FuncState* %0, %struct.expdesc* nonnull %1)
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %28 = bitcast %union.anon.8* %27 to i32*
  %29 = load i32, i32* %28, align 8, !tbaa !21
  %30 = tail call fastcc i32 @condjump(%struct.FuncState* %0, i32 68, i32 255, i32 %29, i32 0, i32 %2)
  br label %31

; <label>:31:                                     ; preds = %20, %26
  %32 = phi i32 [ %30, %26 ], [ %25, %20 ]
  ret i32 %32
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @removelastinstruction(%struct.FuncState* nocapture) unnamed_addr #2 {
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %0)
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %3 = load i32, i32* %2, align 8, !tbaa !273
  %4 = add nsw i32 %3, -1
  store i32 %4, i32* %2, align 8, !tbaa !273
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @newlabelentry(%struct.LexState* nocapture readonly, %struct.Labellist* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 1
  %7 = load i32, i32* %6, align 8, !tbaa !325
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !260
  %10 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 0
  %11 = bitcast %struct.Labellist* %1 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !326
  %13 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 2
  %14 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %9, i8* %12, i32 %7, i32* nonnull %13, i32 24, i32 32767, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.262, i64 0, i64 0))
  %15 = bitcast i8* %14 to %struct.Labeldesc*
  store i8* %14, i8** %11, align 8, !tbaa !326
  %16 = sext i32 %7 to i64
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %15, i64 %16, i32 0
  store %struct.TString* %2, %struct.TString** %17, align 8, !tbaa !324
  %18 = load %struct.Labeldesc*, %struct.Labeldesc** %10, align 8, !tbaa !326
  %19 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %18, i64 %16, i32 2
  store i32 %3, i32* %19, align 4, !tbaa !327
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %21 = load %struct.FuncState*, %struct.FuncState** %20, align 8, !tbaa !264
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %21, i64 0, i32 13
  %23 = load i8, i8* %22, align 2, !tbaa !288
  %24 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %18, i64 %16, i32 3
  store i8 %23, i8* %24, align 8, !tbaa !301
  %25 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %18, i64 %16, i32 4
  store i8 0, i8* %25, align 1, !tbaa !328
  %26 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %18, i64 %16, i32 1
  store i32 %4, i32* %26, align 8, !tbaa !303
  %27 = add nsw i32 %7, 1
  store i32 %27, i32* %6, align 8, !tbaa !325
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @createlabel(%struct.LexState* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %8 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !254
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %8, i64 0, i32 2
  %10 = tail call fastcc i32 @luaK_getlabel(%struct.FuncState* %6)
  %11 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %9, %struct.TString* %1, i32 %2, i32 %10)
  %12 = icmp eq i32 %3, 0
  br i1 %12, label %22, label %13

; <label>:13:                                     ; preds = %4
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 3
  %15 = load %struct.BlockCnt*, %struct.BlockCnt** %14, align 8, !tbaa !281
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 3
  %17 = load i8, i8* %16, align 8, !tbaa !292
  %18 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %19 = load %struct.Labeldesc*, %struct.Labeldesc** %18, align 8, !tbaa !326
  %20 = sext i32 %11 to i64
  %21 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %19, i64 %20, i32 3
  store i8 %17, i8* %21, align 8, !tbaa !301
  br label %22

; <label>:22:                                     ; preds = %4, %13
  %23 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %24 = load %struct.Labeldesc*, %struct.Labeldesc** %23, align 8, !tbaa !326
  %25 = sext i32 %11 to i64
  %26 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %24, i64 %25
  %27 = tail call fastcc i32 @solvegotos(%struct.LexState* nonnull %0, %struct.Labeldesc* %26)
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %34, label %29

; <label>:29:                                     ; preds = %22
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 13
  %31 = load i8, i8* %30, align 2, !tbaa !288
  %32 = zext i8 %31 to i32
  %33 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %6, i32 55, i32 %32, i32 0, i32 0, i32 0)
  br label %34

; <label>:34:                                     ; preds = %22, %29
  %35 = phi i32 [ 1, %29 ], [ 0, %22 ]
  ret i32 %35
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @removevars(%struct.FuncState* nocapture, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %4 = load i8, i8* %3, align 2, !tbaa !288
  %5 = zext i8 %4 to i32
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %7 = load %struct.LexState*, %struct.LexState** %6, align 8, !tbaa !272
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %7, i64 0, i32 10
  %9 = load %struct.Dyndata*, %struct.Dyndata** %8, align 8, !tbaa !254
  %10 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %9, i64 0, i32 0, i32 1
  %11 = load i32, i32* %10, align 8, !tbaa !257
  %12 = sub i32 %1, %5
  %13 = add i32 %12, %11
  store i32 %13, i32* %10, align 8, !tbaa !257
  %14 = load i8, i8* %3, align 2, !tbaa !288
  %15 = zext i8 %14 to i32
  %16 = icmp sgt i32 %15, %1
  br i1 %16, label %17, label %29

; <label>:17:                                     ; preds = %2
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  br label %19

; <label>:19:                                     ; preds = %17, %19
  %20 = phi i8 [ %14, %17 ], [ %26, %19 ]
  %21 = load i32, i32* %18, align 8, !tbaa !273
  %22 = add i8 %20, -1
  store i8 %22, i8* %3, align 2, !tbaa !288
  %23 = zext i8 %22 to i32
  %24 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nonnull %0, i32 %23)
  %25 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %24, i64 0, i32 2
  store i32 %21, i32* %25, align 4, !tbaa !87
  %26 = load i8, i8* %3, align 2, !tbaa !288
  %27 = zext i8 %26 to i32
  %28 = icmp sgt i32 %27, %1
  br i1 %28, label %19, label %29

; <label>:29:                                     ; preds = %19, %2
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @movegotosout(%struct.FuncState* nocapture readonly, %struct.BlockCnt* nocapture readonly) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %4 = load %struct.LexState*, %struct.LexState** %3, align 8, !tbaa !272
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %4, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !254
  %7 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 4, !tbaa !294
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 1, i32 1
  %10 = load i32, i32* %9, align 8, !tbaa !325
  %11 = icmp slt i32 %8, %10
  br i1 %11, label %12, label %34

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 1, i32 0
  %14 = load %struct.Labeldesc*, %struct.Labeldesc** %13, align 8, !tbaa !326
  %15 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 3
  %16 = load i8, i8* %15, align 8, !tbaa !292
  %17 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %1, i64 0, i32 4
  %18 = load i32, i32* %9, align 8, !tbaa !325
  %19 = sext i32 %8 to i64
  %20 = sext i32 %18 to i64
  br label %21

; <label>:21:                                     ; preds = %12, %31
  %22 = phi i64 [ %19, %12 ], [ %32, %31 ]
  %23 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %22, i32 3
  %24 = load i8, i8* %23, align 8, !tbaa !301
  %25 = icmp ugt i8 %24, %16
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %21
  store i8 %16, i8* %23, align 8, !tbaa !301
  %27 = load i8, i8* %17, align 1, !tbaa !295
  %28 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %22, i32 4
  %29 = load i8, i8* %28, align 1, !tbaa !328
  %30 = or i8 %29, %27
  store i8 %30, i8* %28, align 1, !tbaa !328
  br label %31

; <label>:31:                                     ; preds = %26, %21
  %32 = add nsw i64 %22, 1
  %33 = icmp slt i64 %32, %20
  br i1 %33, label %21, label %34

; <label>:34:                                     ; preds = %31, %2
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @undefgoto(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 0
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !324
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %6 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !260
  %7 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5)
  %8 = icmp eq %struct.TString* %4, %7
  %9 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !260
  br i1 %8, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !327
  %13 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.264, i64 0, i64 0), i32 %12)
  br label %21

; <label>:14:                                     ; preds = %2
  %15 = bitcast %struct.Labeldesc* %1 to i8**
  %16 = load i8*, i8** %15, align 8, !tbaa !324
  %17 = getelementptr inbounds i8, i8* %16, i64 24
  %18 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %19 = load i32, i32* %18, align 4, !tbaa !327
  %20 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.265, i64 0, i64 0), i8* nonnull %17, i32 %19)
  br label %21

; <label>:21:                                     ; preds = %14, %10
  %22 = phi i8* [ %13, %10 ], [ %20, %14 ]
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %22) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @solvegotos(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %4 = load %struct.Dyndata*, %struct.Dyndata** %3, align 8, !tbaa !254
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 3
  %8 = load %struct.BlockCnt*, %struct.BlockCnt** %7, align 8, !tbaa !281
  %9 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %8, i64 0, i32 2
  %10 = load i32, i32* %9, align 4, !tbaa !294
  %11 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 1, i32 1
  %12 = load i32, i32* %11, align 8, !tbaa !325
  %13 = icmp slt i32 %10, %12
  br i1 %13, label %14, label %38

; <label>:14:                                     ; preds = %2
  %15 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %4, i64 0, i32 1, i32 0
  %16 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %14, %33
  %18 = phi i32 [ 0, %14 ], [ %35, %33 ]
  %19 = phi i32 [ %10, %14 ], [ %34, %33 ]
  %20 = load %struct.Labeldesc*, %struct.Labeldesc** %15, align 8, !tbaa !326
  %21 = sext i32 %19 to i64
  %22 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %20, i64 %21, i32 0
  %23 = load %struct.TString*, %struct.TString** %22, align 8, !tbaa !324
  %24 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !324
  %25 = icmp eq %struct.TString* %23, %24
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %17
  %27 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %20, i64 %21, i32 4
  %28 = load i8, i8* %27, align 1, !tbaa !328
  %29 = zext i8 %28 to i32
  %30 = or i32 %18, %29
  tail call fastcc void @solvegoto(%struct.LexState* %0, i32 %19, %struct.Labeldesc* nonnull %1)
  br label %33

; <label>:31:                                     ; preds = %17
  %32 = add nsw i32 %19, 1
  br label %33

; <label>:33:                                     ; preds = %31, %26
  %34 = phi i32 [ %19, %26 ], [ %32, %31 ]
  %35 = phi i32 [ %30, %26 ], [ %18, %31 ]
  %36 = load i32, i32* %11, align 8, !tbaa !325
  %37 = icmp slt i32 %34, %36
  br i1 %37, label %17, label %38

; <label>:38:                                     ; preds = %33, %2
  %39 = phi i32 [ 0, %2 ], [ %35, %33 ]
  ret i32 %39
}

; Function Attrs: nounwind uwtable
define internal fastcc void @solvegoto(%struct.LexState* nocapture, i32, %struct.Labeldesc* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %5 = load %struct.Dyndata*, %struct.Dyndata** %4, align 8, !tbaa !254
  %6 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %5, i64 0, i32 1, i32 0
  %7 = load %struct.Labeldesc*, %struct.Labeldesc** %6, align 8, !tbaa !326
  %8 = sext i32 %1 to i64
  %9 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %7, i64 %8, i32 3
  %10 = load i8, i8* %9, align 8, !tbaa !301
  %11 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %2, i64 0, i32 3
  %12 = load i8, i8* %11, align 8, !tbaa !301
  %13 = icmp ult i8 %10, %12
  br i1 %13, label %14, label %16, !prof !33

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %7, i64 %8
  tail call fastcc void @jumpscopeerror(%struct.LexState* nonnull %0, %struct.Labeldesc* %15) #17
  unreachable

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %18 = load %struct.FuncState*, %struct.FuncState** %17, align 8, !tbaa !264
  %19 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %7, i64 %8, i32 1
  %20 = load i32, i32* %19, align 8, !tbaa !303
  %21 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %2, i64 0, i32 1
  %22 = load i32, i32* %21, align 8, !tbaa !303
  tail call fastcc void @luaK_patchlist(%struct.FuncState* %18, i32 %20, i32 %22)
  %23 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %5, i64 0, i32 1, i32 1
  %24 = load i32, i32* %23, align 8, !tbaa !325
  %25 = add nsw i32 %24, -1
  %26 = icmp sgt i32 %25, %1
  br i1 %26, label %27, label %41

; <label>:27:                                     ; preds = %16
  %28 = sext i32 %1 to i64
  br label %29

; <label>:29:                                     ; preds = %27, %29
  %30 = phi i64 [ %28, %27 ], [ %33, %29 ]
  %31 = load %struct.Labeldesc*, %struct.Labeldesc** %6, align 8, !tbaa !326
  %32 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %31, i64 %30
  %33 = add nsw i64 %30, 1
  %34 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %31, i64 %33
  %35 = bitcast %struct.Labeldesc* %32 to i8*
  %36 = bitcast %struct.Labeldesc* %34 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %35, i8* %36, i64 24, i32 8, i1 false), !tbaa.struct !329
  %37 = load i32, i32* %23, align 8, !tbaa !325
  %38 = add nsw i32 %37, -1
  %39 = sext i32 %38 to i64
  %40 = icmp slt i64 %33, %39
  br i1 %40, label %29, label %41

; <label>:41:                                     ; preds = %29, %16
  %42 = phi i32 [ %25, %16 ], [ %38, %29 ]
  store i32 %42, i32* %23, align 8, !tbaa !325
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @jumpscopeerror(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !264
  %5 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 3
  %6 = load i8, i8* %5, align 8, !tbaa !301
  %7 = zext i8 %6 to i32
  %8 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %4, i32 %7)
  %9 = bitcast %struct.LocVar* %8 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !88
  %11 = getelementptr inbounds i8, i8* %10, i64 24
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %13 = load %struct.lua_State*, %struct.lua_State** %12, align 8, !tbaa !260
  %14 = bitcast %struct.Labeldesc* %1 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !324
  %16 = getelementptr inbounds i8, i8* %15, i64 24
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %18 = load i32, i32* %17, align 4, !tbaa !327
  %19 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.263, i64 0, i64 0), i8* nonnull %16, i32 %18, i8* nonnull %11)
  tail call fastcc void @luaK_semerror(%struct.LexState* %0, i8* %19) #17
  unreachable
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @luaK_semerror(%struct.LexState* nocapture, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 0, i32* %3, align 8, !tbaa !259
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %1) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @codesJ(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 2147483449)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @cond(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %2)
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !285
  %6 = icmp eq i32 %5, 1
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  store i32 3, i32* %4, align 8, !tbaa !285
  br label %8

; <label>:8:                                      ; preds = %7, %1
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %10 = load %struct.FuncState*, %struct.FuncState** %9, align 8, !tbaa !264
  call fastcc void @luaK_goiftrue(%struct.FuncState* %10, %struct.expdesc* nonnull %2)
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %12 = load i32, i32* %11, align 4, !tbaa !284
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret i32 %12
}

; Function Attrs: noreturn nounwind uwtable
define internal fastcc void @error_expected(%struct.LexState* nocapture readonly, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !260
  %5 = tail call fastcc i8* @luaX_token2str(%struct.LexState* %0, i32 %1)
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.267, i64 0, i64 0), i8* %5)
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %6) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fornum(%struct.LexState*, %struct.TString*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 15
  %7 = load i8, i8* %6, align 4, !tbaa !300
  %8 = zext i8 %7 to i32
  %9 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.269, i64 0, i64 0), i64 11)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %9)
  %10 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.270, i64 0, i64 0), i64 11)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %10)
  %11 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.271, i64 0, i64 0), i64 10)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %11)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %1)
  tail call fastcc void @checknext(%struct.LexState* %0, i32 61)
  tail call fastcc void @exp1(%struct.LexState* %0)
  tail call fastcc void @checknext(%struct.LexState* %0, i32 44)
  tail call fastcc void @exp1(%struct.LexState* %0)
  %12 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %3
  tail call fastcc void @exp1(%struct.LexState* nonnull %0)
  br label %18

; <label>:15:                                     ; preds = %3
  %16 = load i8, i8* %6, align 4, !tbaa !300
  %17 = zext i8 %16 to i32
  tail call fastcc void @luaK_int(%struct.FuncState* %5, i32 %17, i64 1)
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %5, i32 1)
  br label %18

; <label>:18:                                     ; preds = %15, %14
  tail call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 3)
  tail call fastcc void @forbody(%struct.LexState* nonnull %0, i32 %8, i32 %2, i32 1, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @forlist(%struct.LexState*, %struct.TString*) unnamed_addr #0 {
  %3 = alloca %struct.expdesc, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 15
  %8 = load i8, i8* %7, align 4, !tbaa !300
  %9 = zext i8 %8 to i32
  %10 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.272, i64 0, i64 0), i64 15)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %10)
  %11 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.273, i64 0, i64 0), i64 11)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %11)
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 13
  %13 = load i8, i8* %12, align 2, !tbaa !288
  %14 = zext i8 %13 to i32
  tail call fastcc void @markupval(%struct.FuncState* %5, i32 %14)
  %15 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.274, i64 0, i64 0), i64 13)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %15)
  %16 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.275, i64 0, i64 0), i64 13)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %16)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %1)
  %17 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %28, label %19

; <label>:19:                                     ; preds = %2
  br label %20

; <label>:20:                                     ; preds = %19, %20
  %21 = phi i32 [ %23, %20 ], [ 5, %19 ]
  %22 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %22)
  %23 = add nuw nsw i32 %21, 1
  %24 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %20

; <label>:26:                                     ; preds = %20
  %27 = add nsw i32 %21, -3
  br label %28

; <label>:28:                                     ; preds = %26, %2
  %29 = phi i32 [ 1, %2 ], [ %27, %26 ]
  tail call fastcc void @checknext(%struct.LexState* %0, i32 268)
  %30 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %31 = load i32, i32* %30, align 4, !tbaa !265
  %32 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %3)
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 4, i32 %32, %struct.expdesc* nonnull %3)
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 4)
  call fastcc void @luaK_checkstack(%struct.FuncState* %5, i32 3)
  call fastcc void @forbody(%struct.LexState* %0, i32 %9, i32 %31, i32 %29, i32 1)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @exp1(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  call fastcc void @expr(%struct.LexState* %0, %struct.expdesc* nonnull %2)
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @forbody(%struct.LexState*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !264
  tail call fastcc void @checknext(%struct.LexState* %0, i32 259)
  %10 = sext i32 %4 to i64
  %11 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forprep, i64 0, i64 %10
  %12 = load i32, i32* %11, align 4, !tbaa !21
  %13 = tail call fastcc i32 @luaK_codeABx(%struct.FuncState* %9, i32 %12, i32 %1, i32 0)
  call fastcc void @enterblock(%struct.FuncState* %9, %struct.BlockCnt* nonnull %6, i8 zeroext 0)
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 %3)
  call fastcc void @luaK_reserveregs(%struct.FuncState* %9, i32 %3)
  call fastcc void @block(%struct.LexState* %0)
  call fastcc void @leaveblock(%struct.FuncState* %9)
  %14 = call fastcc i32 @luaK_getlabel(%struct.FuncState* %9)
  call fastcc void @fixforjump(%struct.FuncState* %9, i32 %13, i32 %14, i32 0)
  %15 = icmp eq i32 %4, 0
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %5
  %17 = call fastcc i32 @luaK_codeABCk(%struct.FuncState* %9, i32 77, i32 %1, i32 0, i32 %3, i32 0)
  call fastcc void @luaK_fixline(%struct.FuncState* %9, i32 %2)
  %18 = add nsw i32 %1, 2
  br label %19

; <label>:19:                                     ; preds = %5, %16
  %20 = phi i32 [ %18, %16 ], [ %1, %5 ]
  %21 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forloop, i64 0, i64 %10
  %22 = load i32, i32* %21, align 4, !tbaa !21
  %23 = call fastcc i32 @luaK_codeABx(%struct.FuncState* %9, i32 %22, i32 %20, i32 0)
  %24 = add nsw i32 %13, 1
  call fastcc void @fixforjump(%struct.FuncState* %9, i32 %23, i32 %24, i32 1)
  call fastcc void @luaK_fixline(%struct.FuncState* %9, i32 %2)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fixforjump(%struct.FuncState* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !251
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 16
  %8 = load i32*, i32** %7, align 8, !tbaa !134
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds i32, i32* %8, i64 %9
  %11 = xor i32 %1, -1
  %12 = add i32 %11, %2
  %13 = icmp eq i32 %3, 0
  %14 = sub nsw i32 0, %12
  %15 = select i1 %13, i32 %12, i32 %14
  %16 = icmp sgt i32 %15, 131071
  br i1 %16, label %17, label %20, !prof !33

; <label>:17:                                     ; preds = %4
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %19 = load %struct.LexState*, %struct.LexState** %18, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %19, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #17
  unreachable

; <label>:20:                                     ; preds = %4
  %21 = load i32, i32* %10, align 4, !tbaa !70
  %22 = and i32 %21, 32767
  %23 = shl i32 %15, 15
  %24 = or i32 %22, %23
  store i32 %24, i32* %10, align 4, !tbaa !70
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @adjust_assign(%struct.LexState* nocapture readonly, i32, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !264
  %7 = sub nsw i32 %1, %2
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !285
  switch i32 %9, label %10 [
    i32 16, label %17
    i32 17, label %17
    i32 0, label %11
  ]

; <label>:10:                                     ; preds = %4
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* nonnull %3)
  br label %11

; <label>:11:                                     ; preds = %4, %10
  %12 = icmp sgt i32 %7, 0
  br i1 %12, label %13, label %23

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %15 = load i8, i8* %14, align 4, !tbaa !300
  %16 = zext i8 %15 to i32
  tail call fastcc void @luaK_nil(%struct.FuncState* %6, i32 %16, i32 %7)
  br label %22

; <label>:17:                                     ; preds = %4, %4
  %18 = add nsw i32 %7, 1
  %19 = icmp sgt i32 %18, 0
  %20 = select i1 %19, i32 %18, i32 0
  tail call fastcc void @luaK_setreturns(%struct.FuncState* %6, %struct.expdesc* nonnull %3, i32 %20)
  %21 = icmp sgt i32 %7, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %13, %17
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %6, i32 %7)
  br label %28

; <label>:23:                                     ; preds = %11, %17
  %24 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %25 = load i8, i8* %24, align 4, !tbaa !300
  %26 = trunc i32 %7 to i8
  %27 = add i8 %25, %26
  store i8 %27, i8* %24, align 4, !tbaa !300
  br label %28

; <label>:28:                                     ; preds = %23, %22
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @funcname(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @singlevar(%struct.LexState* %0, %struct.expdesc* %1)
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %4

; <label>:4:                                      ; preds = %6, %2
  %5 = load i32, i32* %3, align 8, !tbaa !259
  switch i32 %5, label %8 [
    i32 46, label %6
    i32 58, label %7
  ]

; <label>:6:                                      ; preds = %4
  tail call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %4

; <label>:7:                                      ; preds = %4
  tail call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* %1)
  br label %8

; <label>:8:                                      ; preds = %4, %7
  %9 = phi i32 [ 1, %7 ], [ 0, %4 ]
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal fastcc void @tocloselocalstat(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %3 = load %struct.FuncState*, %struct.FuncState** %2, align 8, !tbaa !264
  %4 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 1
  %6 = bitcast %struct.TString* %5 to i8*
  %7 = tail call i32 @strcmp(i8* nonnull %6, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.276, i64 0, i64 0)) #19
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !260
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %11, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.277, i64 0, i64 0), %struct.TString* nonnull %5)
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %12) #17
  unreachable

; <label>:13:                                     ; preds = %1
  %14 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0)
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %14)
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61)
  tail call fastcc void @exp1(%struct.LexState* nonnull %0)
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %3, i64 0, i32 13
  %16 = load i8, i8* %15, align 2, !tbaa !288
  %17 = zext i8 %16 to i32
  tail call fastcc void @markupval(%struct.FuncState* %3, i32 %17)
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %3, i64 0, i32 3
  %19 = load %struct.BlockCnt*, %struct.BlockCnt** %18, align 8, !tbaa !281
  %20 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %19, i64 0, i32 6
  store i8 1, i8* %20, align 1, !tbaa !296
  tail call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 1)
  %21 = load i8, i8* %15, align 2, !tbaa !288
  %22 = zext i8 %21 to i32
  %23 = add nsw i32 %22, -1
  %24 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %3, i32 56, i32 %23, i32 0, i32 0, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @commonlocalstat(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  br label %4

; <label>:4:                                      ; preds = %4, %1
  %5 = phi i32 [ 0, %1 ], [ %7, %4 ]
  %6 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0)
  tail call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %6)
  %7 = add nuw nsw i32 %5, 1
  %8 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %4

; <label>:10:                                     ; preds = %4
  %11 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 61)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %10
  %14 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %2)
  br label %17

; <label>:15:                                     ; preds = %10
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 0, i32* %16, align 8, !tbaa !285
  br label %17

; <label>:17:                                     ; preds = %15, %13
  %18 = phi i32 [ %14, %13 ], [ 0, %15 ]
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 %7, i32 %18, %struct.expdesc* nonnull %2)
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 %7)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkrepeated(%struct.LexState* nocapture, %struct.TString*) unnamed_addr #0 {
  %3 = tail call fastcc %struct.Labeldesc* @findlabel(%struct.LexState* %0, %struct.TString* %1)
  %4 = icmp eq %struct.Labeldesc* %3, null
  br i1 %4, label %12, label %5, !prof !103

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !260
  %8 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %9 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %3, i64 0, i32 2
  %10 = load i32, i32* %9, align 4, !tbaa !327
  %11 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.278, i64 0, i64 0), %struct.TString* nonnull %8, i32 %10)
  tail call fastcc void @luaK_semerror(%struct.LexState* %0, i8* %11) #17
  unreachable

; <label>:12:                                     ; preds = %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_ret(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 1
  %5 = select i1 %4, i32 73, i32 71
  %6 = icmp eq i32 %2, 0
  %7 = select i1 %6, i32 72, i32 %5
  %8 = add nsw i32 %2, 1
  %9 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %0, i32 %7, i32 %1, i32 %8, i32 0, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @restassign(%struct.LexState*, %struct.LHS_assign*, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LHS_assign, align 8
  %6 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %1, i64 0, i32 1
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %7, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !306
  %10 = add i32 %9, -8
  %11 = icmp ult i32 %10, 6
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #17
  unreachable

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc i32 @testnext(%struct.LexState* %0, i32 44)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %33, label %16

; <label>:16:                                     ; preds = %13
  %17 = bitcast %struct.LHS_assign* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %17) #7
  %18 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 0
  store %struct.LHS_assign* %1, %struct.LHS_assign** %18, align 8, !tbaa !304
  %19 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* %0, %struct.expdesc* nonnull %19)
  %20 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %19, i64 0, i32 0
  %21 = load i32, i32* %20, align 8, !tbaa !306
  %22 = add i32 %21, -10
  %23 = icmp ult i32 %22, 4
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %16
  call fastcc void @check_conflict(%struct.LexState* %0, %struct.LHS_assign* nonnull %1, %struct.expdesc* nonnull %19)
  br label %25

; <label>:25:                                     ; preds = %16, %24
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %27 = load %struct.lua_State*, %struct.lua_State** %26, align 8, !tbaa !260
  call fastcc void @luaE_enterCcall(%struct.lua_State* %27)
  %28 = add nsw i32 %2, 1
  call fastcc void @restassign(%struct.LexState* %0, %struct.LHS_assign* nonnull %5, i32 %28)
  %29 = load %struct.lua_State*, %struct.lua_State** %26, align 8, !tbaa !260
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %29, i64 0, i32 19
  %31 = load i32, i32* %30, align 8, !tbaa !40
  %32 = add i32 %31, -1
  store i32 %32, i32* %30, align 8, !tbaa !40
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %17) #7
  br label %41

; <label>:33:                                     ; preds = %13
  tail call fastcc void @checknext(%struct.LexState* %0, i32 61)
  %34 = call fastcc i32 @explist(%struct.LexState* %0, %struct.expdesc* nonnull %4)
  %35 = icmp eq i32 %34, %2
  br i1 %35, label %37, label %36

; <label>:36:                                     ; preds = %33
  call fastcc void @adjust_assign(%struct.LexState* %0, i32 %2, i32 %34, %struct.expdesc* nonnull %4)
  br label %41

; <label>:37:                                     ; preds = %33
  %38 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %39 = load %struct.FuncState*, %struct.FuncState** %38, align 8, !tbaa !264
  call fastcc void @luaK_setoneret(%struct.FuncState* %39, %struct.expdesc* nonnull %4)
  %40 = load %struct.FuncState*, %struct.FuncState** %38, align 8, !tbaa !264
  call fastcc void @luaK_storevar(%struct.FuncState* %40, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4)
  br label %49

; <label>:41:                                     ; preds = %36, %25
  %42 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %43 = load %struct.FuncState*, %struct.FuncState** %42, align 8, !tbaa !264
  %44 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %43, i64 0, i32 15
  %45 = load i8, i8* %44, align 4, !tbaa !300
  %46 = zext i8 %45 to i32
  %47 = add nsw i32 %46, -1
  call fastcc void @init_exp(%struct.expdesc* nonnull %4, i32 7, i32 %47)
  %48 = load %struct.FuncState*, %struct.FuncState** %42, align 8, !tbaa !264
  call fastcc void @luaK_storevar(%struct.FuncState* %48, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4)
  br label %49

; <label>:49:                                     ; preds = %37, %41
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @check_conflict(%struct.LexState* nocapture readonly, %struct.LHS_assign*, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 15
  %7 = load i8, i8* %6, align 4, !tbaa !300
  %8 = zext i8 %7 to i32
  %9 = icmp eq %struct.LHS_assign* %1, null
  br i1 %9, label %81, label %10

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %15 = bitcast %union.anon.8* %14 to i32*
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %17 = bitcast %union.anon.8* %16 to i32*
  %18 = zext i8 %7 to i16
  br label %19

; <label>:19:                                     ; preds = %10, %65
  %20 = phi %struct.LHS_assign* [ %1, %10 ], [ %68, %65 ]
  %21 = phi i32 [ 0, %10 ], [ %66, %65 ]
  %22 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %20, i64 0, i32 1, i32 0
  %23 = load i32, i32* %22, align 8, !tbaa !306
  %24 = add i32 %23, -10
  %25 = icmp ult i32 %24, 4
  br i1 %25, label %26, label %65

; <label>:26:                                     ; preds = %19
  %27 = icmp eq i32 %23, 11
  %28 = load i32, i32* %11, align 8, !tbaa !285
  br i1 %27, label %29, label %40

; <label>:29:                                     ; preds = %26
  %30 = icmp eq i32 %28, 9
  br i1 %30, label %31, label %65

; <label>:31:                                     ; preds = %29
  %32 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %20, i64 0, i32 1, i32 1
  %33 = bitcast %union.anon.8* %32 to %struct.anon.9*
  %34 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %33, i64 0, i32 1
  %35 = load i8, i8* %34, align 2, !tbaa !21
  %36 = zext i8 %35 to i32
  %37 = load i32, i32* %13, align 8, !tbaa !21
  %38 = icmp eq i32 %37, %36
  br i1 %38, label %39, label %65

; <label>:39:                                     ; preds = %31
  store i32 13, i32* %22, align 8, !tbaa !306
  store i8 %7, i8* %34, align 2, !tbaa !21
  br label %65

; <label>:40:                                     ; preds = %26
  %41 = icmp eq i32 %28, 8
  br i1 %41, label %42, label %51

; <label>:42:                                     ; preds = %40
  %43 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %20, i64 0, i32 1, i32 1
  %44 = bitcast %union.anon.8* %43 to %struct.anon.9*
  %45 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %44, i64 0, i32 1
  %46 = load i8, i8* %45, align 2, !tbaa !21
  %47 = zext i8 %46 to i32
  %48 = load i32, i32* %15, align 8, !tbaa !21
  %49 = icmp eq i32 %48, %47
  br i1 %49, label %50, label %51

; <label>:50:                                     ; preds = %42
  store i8 %7, i8* %45, align 2, !tbaa !21
  br label %51

; <label>:51:                                     ; preds = %50, %42, %40
  %52 = phi i32 [ 1, %50 ], [ %21, %42 ], [ %21, %40 ]
  %53 = icmp eq i32 %23, 10
  br i1 %53, label %54, label %65

; <label>:54:                                     ; preds = %51
  %55 = load i32, i32* %11, align 8, !tbaa !285
  %56 = icmp eq i32 %55, 8
  br i1 %56, label %57, label %65

; <label>:57:                                     ; preds = %54
  %58 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %20, i64 0, i32 1, i32 1
  %59 = bitcast %union.anon.8* %58 to i16*
  %60 = load i16, i16* %59, align 8, !tbaa !21
  %61 = sext i16 %60 to i32
  %62 = load i32, i32* %17, align 8, !tbaa !21
  %63 = icmp eq i32 %62, %61
  br i1 %63, label %64, label %65

; <label>:64:                                     ; preds = %57
  store i16 %18, i16* %59, align 8, !tbaa !21
  br label %65

; <label>:65:                                     ; preds = %19, %51, %54, %57, %64, %29, %31, %39
  %66 = phi i32 [ 1, %39 ], [ %21, %31 ], [ %21, %29 ], [ 1, %64 ], [ %52, %57 ], [ %52, %54 ], [ %52, %51 ], [ %21, %19 ]
  %67 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %20, i64 0, i32 0
  %68 = load %struct.LHS_assign*, %struct.LHS_assign** %67, align 8, !tbaa !304
  %69 = icmp eq %struct.LHS_assign* %68, null
  br i1 %69, label %70, label %19

; <label>:70:                                     ; preds = %65
  %71 = icmp eq i32 %66, 0
  br i1 %71, label %81, label %72

; <label>:72:                                     ; preds = %70
  %73 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %74 = load i32, i32* %73, align 8, !tbaa !285
  %75 = icmp eq i32 %74, 8
  %76 = select i1 %75, i32 0, i32 7
  %77 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %78 = bitcast %union.anon.8* %77 to i32*
  %79 = load i32, i32* %78, align 8, !tbaa !21
  %80 = tail call fastcc i32 @luaK_codeABCk(%struct.FuncState* %5, i32 %76, i32 %8, i32 %79, i32 0, i32 0)
  tail call fastcc void @luaK_reserveregs(%struct.FuncState* %5, i32 1)
  br label %81

; <label>:81:                                     ; preds = %3, %70, %72
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @luaK_finish(%struct.FuncState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %3 = load %struct.Proto*, %struct.Proto** %2, align 8, !tbaa !251
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !273
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %64

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 16
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 17
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 17
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 4
  %12 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 4
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 4
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 3
  br label %15

; <label>:15:                                     ; preds = %7, %59
  %16 = phi i64 [ 0, %7 ], [ %60, %59 ]
  %17 = load i32*, i32** %8, align 8, !tbaa !134
  %18 = getelementptr inbounds i32, i32* %17, i64 %16
  %19 = load i32, i32* %18, align 4, !tbaa !70
  %20 = trunc i32 %19 to i7
  switch i7 %20, label %59 [
    i7 -56, label %21
    i7 -55, label %21
    i7 -57, label %30
    i7 -58, label %30
    i7 57, label %55
  ]

; <label>:21:                                     ; preds = %15, %15
  %22 = load i8, i8* %9, align 2, !tbaa !322
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %27

; <label>:24:                                     ; preds = %21
  %25 = load i8, i8* %11, align 1, !tbaa !94
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %59, label %27

; <label>:27:                                     ; preds = %24, %21
  %28 = and i32 %19, -128
  %29 = or i32 %28, 71
  store i32 %29, i32* %18, align 4, !tbaa !70
  br label %30

; <label>:30:                                     ; preds = %15, %15, %27
  %31 = load i8, i8* %10, align 2, !tbaa !322
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %33, label %39

; <label>:33:                                     ; preds = %30
  %34 = load i8, i8* %12, align 1, !tbaa !94
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %59, label %36

; <label>:36:                                     ; preds = %33
  %37 = load i32, i32* %18, align 4, !tbaa !70
  %38 = and i32 %37, 16744447
  br label %44

; <label>:39:                                     ; preds = %30
  %40 = load i8, i8* %13, align 1, !tbaa !94
  %41 = load i32, i32* %18, align 4, !tbaa !70
  %42 = and i32 %41, 16744447
  %43 = icmp eq i8 %40, 0
  br i1 %43, label %49, label %44

; <label>:44:                                     ; preds = %36, %39
  %45 = phi i32 [ %38, %36 ], [ %42, %39 ]
  %46 = load i8, i8* %14, align 2, !tbaa !95
  %47 = zext i8 %46 to i32
  %48 = add nuw nsw i32 %47, 1
  br label %49

; <label>:49:                                     ; preds = %39, %44
  %50 = phi i32 [ %45, %44 ], [ %42, %39 ]
  %51 = phi i32 [ %48, %44 ], [ 0, %39 ]
  %52 = shl i32 %51, 24
  %53 = or i32 %50, %52
  %54 = or i32 %53, 32768
  store i32 %54, i32* %18, align 4, !tbaa !70
  br label %59

; <label>:55:                                     ; preds = %15
  %56 = trunc i64 %16 to i32
  %57 = tail call fastcc i32 @finaltarget(i32* %17, i32 %56)
  %58 = trunc i64 %16 to i32
  tail call fastcc void @fixjump(%struct.FuncState* nonnull %0, i32 %58, i32 %57)
  br label %59

; <label>:59:                                     ; preds = %24, %33, %15, %49, %55
  %60 = add nuw nsw i64 %16, 1
  %61 = load i32, i32* %4, align 8, !tbaa !273
  %62 = sext i32 %61 to i64
  %63 = icmp slt i64 %60, %62
  br i1 %63, label %15, label %64

; <label>:64:                                     ; preds = %59, %1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @luaM_shrinkvector_(%struct.lua_State*, i8*, i32* nocapture, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = load i32, i32* %2, align 4, !tbaa !70
  %9 = mul nsw i32 %8, %4
  %10 = sext i32 %9 to i64
  %11 = mul nsw i32 %4, %3
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %14 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %13, align 8, !tbaa !31
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !32
  %17 = tail call i8* %14(i8* %16, i8* %1, i64 %10, i64 %12) #7
  %18 = icmp eq i8* %17, null
  %19 = icmp sgt i32 %3, 0
  %20 = and i1 %19, %18
  br i1 %20, label %21, label %22, !prof !33

; <label>:21:                                     ; preds = %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #17
  unreachable

; <label>:22:                                     ; preds = %5
  %23 = sub nsw i64 %12, %10
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !11
  %26 = add i64 %23, %25
  store i64 %26, i64* %24, align 8, !tbaa !11
  store i32 %3, i32* %2, align 4, !tbaa !70
  ret i8* %17
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal fastcc i32 @finaltarget(i32* nocapture readonly, i32) unnamed_addr #3 {
  br label %3

; <label>:3:                                      ; preds = %2, %11
  %4 = phi i32 [ %1, %2 ], [ %14, %11 ]
  %5 = phi i32 [ 0, %2 ], [ %15, %11 ]
  %6 = sext i32 %4 to i64
  %7 = getelementptr inbounds i32, i32* %0, i64 %6
  %8 = load i32, i32* %7, align 4, !tbaa !70
  %9 = and i32 %8, 127
  %10 = icmp eq i32 %9, 57
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %3
  %12 = lshr i32 %8, 7
  %13 = add i32 %4, -16777214
  %14 = add i32 %13, %12
  %15 = add nuw nsw i32 %5, 1
  %16 = icmp ult i32 %15, 100
  br i1 %16, label %3, label %17

; <label>:17:                                     ; preds = %3, %11
  %18 = phi i32 [ %4, %3 ], [ %14, %11 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpHeader(%struct.DumpState* nocapture) unnamed_addr #0 {
  tail call fastcc void @DumpBlock(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 0), i64 4, %struct.DumpState* %0)
  tail call fastcc void @DumpInt(i32 504, %struct.DumpState* %0)
  tail call fastcc void @DumpByte(i32 0, %struct.DumpState* %0)
  tail call fastcc void @DumpBlock(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i64 6, %struct.DumpState* %0)
  tail call fastcc void @DumpByte(i32 4, %struct.DumpState* %0)
  tail call fastcc void @DumpByte(i32 8, %struct.DumpState* %0)
  tail call fastcc void @DumpByte(i32 8, %struct.DumpState* %0)
  tail call fastcc void @DumpInteger(i64 22136, %struct.DumpState* %0)
  tail call fastcc void @DumpNumber(double 3.705000e+02, %struct.DumpState* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpByte(i32, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %3) #7
  %4 = trunc i32 %0 to i8
  store i8 %4, i8* %3, align 1, !tbaa !21
  call fastcc void @DumpBlock(i8* nonnull %3, i64 1, %struct.DumpState* %1)
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpFunction(%struct.Proto* nocapture readonly, %struct.TString* readnone, %struct.DumpState* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 3
  %5 = load i32, i32* %4, align 8, !tbaa !164
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !104
  %10 = icmp eq %struct.TString* %9, %1
  br i1 %10, label %11, label %12

; <label>:11:                                     ; preds = %3, %7
  tail call fastcc void @DumpString(%struct.TString* null, %struct.DumpState* nonnull %2)
  br label %13

; <label>:12:                                     ; preds = %7
  tail call fastcc void @DumpString(%struct.TString* %9, %struct.DumpState* nonnull %2)
  br label %13

; <label>:13:                                     ; preds = %12, %11
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  %15 = load i32, i32* %14, align 4, !tbaa !101
  tail call fastcc void @DumpInt(i32 %15, %struct.DumpState* nonnull %2)
  %16 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 14
  %17 = load i32, i32* %16, align 8, !tbaa !233
  tail call fastcc void @DumpInt(i32 %17, %struct.DumpState* nonnull %2)
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 3
  %19 = load i8, i8* %18, align 2, !tbaa !95
  %20 = zext i8 %19 to i32
  tail call fastcc void @DumpByte(i32 %20, %struct.DumpState* nonnull %2)
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 4
  %22 = load i8, i8* %21, align 1, !tbaa !94
  %23 = zext i8 %22 to i32
  tail call fastcc void @DumpByte(i32 %23, %struct.DumpState* nonnull %2)
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 5
  %25 = load i8, i8* %24, align 4, !tbaa !133
  %26 = zext i8 %25 to i32
  tail call fastcc void @DumpByte(i32 %26, %struct.DumpState* nonnull %2)
  tail call fastcc void @DumpCode(%struct.Proto* %0, %struct.DumpState* nonnull %2)
  tail call fastcc void @DumpConstants(%struct.Proto* %0, %struct.DumpState* nonnull %2)
  tail call fastcc void @DumpUpvalues(%struct.Proto* %0, %struct.DumpState* nonnull %2)
  tail call fastcc void @DumpProtos(%struct.Proto* %0, %struct.DumpState* nonnull %2)
  tail call fastcc void @DumpDebug(%struct.Proto* %0, %struct.DumpState* nonnull %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpBlock(i8*, i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 4
  %5 = load i32, i32* %4, align 4, !tbaa !165
  %6 = icmp eq i32 %5, 0
  %7 = icmp ne i64 %1, 0
  %8 = and i1 %7, %6
  br i1 %8, label %9, label %17

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %11 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %10, align 8, !tbaa !162
  %12 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %13 = load %struct.lua_State*, %struct.lua_State** %12, align 8, !tbaa !160
  %14 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %15 = load i8*, i8** %14, align 8, !tbaa !163
  %16 = tail call i32 %11(%struct.lua_State* %13, i8* %0, i64 %1, i8* %15) #7
  store i32 %16, i32* %4, align 4, !tbaa !165
  br label %17

; <label>:17:                                     ; preds = %9, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpInt(i32, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = sext i32 %0 to i64
  tail call fastcc void @DumpSize(i64 %3, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpInteger(i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca i64, align 8
  store i64 %0, i64* %3, align 8, !tbaa !109
  %4 = bitcast i64* %3 to i8*
  call fastcc void @DumpBlock(i8* nonnull %4, i64 8, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpNumber(double, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca double, align 8
  store double %0, double* %3, align 8, !tbaa !107
  %4 = bitcast double* %3 to i8*
  call fastcc void @DumpBlock(i8* nonnull %4, i64 8, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpSize(i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca [10 x i8], align 1
  %4 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %4) #7
  br label %5

; <label>:5:                                      ; preds = %5, %2
  %6 = phi i64 [ %10, %5 ], [ 0, %2 ]
  %7 = phi i64 [ %13, %5 ], [ %0, %2 ]
  %8 = trunc i64 %7 to i8
  %9 = and i8 %8, 127
  %10 = add nuw nsw i64 %6, 1
  %11 = sub nsw i64 9, %6
  %12 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 %11
  store i8 %9, i8* %12, align 1, !tbaa !21
  %13 = lshr i64 %7, 7
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %15, label %5

; <label>:15:                                     ; preds = %5
  %16 = and i64 %10, 4294967295
  %17 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 9
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = or i8 %18, -128
  store i8 %19, i8* %17, align 1, !tbaa !21
  %20 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 10
  %21 = sub nsw i64 0, %16
  %22 = getelementptr inbounds i8, i8* %20, i64 %21
  call fastcc void @DumpBlock(i8* nonnull %22, i64 %16, %struct.DumpState* %1)
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpString(%struct.TString*, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = icmp eq %struct.TString* %0, null
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @DumpSize(i64 0, %struct.DumpState* %1)
  br label %21

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !57
  %8 = icmp eq i8 %7, 20
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !232
  %12 = zext i8 %11 to i64
  br label %16

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %13, %9
  %17 = phi i64 [ %12, %9 ], [ %15, %13 ]
  %18 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %19 = bitcast %struct.TString* %18 to i8*
  %20 = add i64 %17, 1
  tail call fastcc void @DumpSize(i64 %20, %struct.DumpState* %1)
  tail call fastcc void @DumpBlock(i8* nonnull %19, i64 %17, %struct.DumpState* %1)
  br label %21

; <label>:21:                                     ; preds = %16, %4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpCode(%struct.Proto* nocapture readonly, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 8
  %4 = load i32, i32* %3, align 8, !tbaa !206
  tail call fastcc void @DumpInt(i32 %4, %struct.DumpState* %1)
  %5 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  %6 = bitcast i32** %5 to i8**
  %7 = load i8*, i8** %6, align 8, !tbaa !134
  %8 = load i32, i32* %3, align 8, !tbaa !206
  %9 = sext i32 %8 to i64
  %10 = shl nsw i64 %9, 2
  tail call fastcc void @DumpBlock(i8* %7, i64 %10, %struct.DumpState* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpConstants(%struct.Proto* nocapture readonly, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 7
  %4 = load i32, i32* %3, align 4, !tbaa !210
  tail call fastcc void @DumpInt(i32 %4, %struct.DumpState* %1)
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %34

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %8 = zext i32 %4 to i64
  br label %9

; <label>:9:                                      ; preds = %31, %6
  %10 = phi i64 [ 0, %6 ], [ %32, %31 ]
  %11 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !209
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 %10
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 %10, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 63
  %16 = zext i8 %15 to i32
  tail call fastcc void @DumpByte(i32 %16, %struct.DumpState* %1)
  %17 = load i8, i8* %13, align 8, !tbaa !22
  %18 = trunc i8 %17 to i6
  switch i6 %18, label %31 [
    i6 -28, label %28
    i6 1, label %19
    i6 19, label %22
    i6 -29, label %25
    i6 20, label %28
  ]

; <label>:19:                                     ; preds = %9
  %20 = bitcast %struct.TValue* %12 to i32*
  %21 = load i32, i32* %20, align 8, !tbaa !21
  tail call fastcc void @DumpByte(i32 %21, %struct.DumpState* %1)
  br label %31

; <label>:22:                                     ; preds = %9
  %23 = bitcast %struct.TValue* %12 to double*
  %24 = load double, double* %23, align 8, !tbaa !21
  tail call fastcc void @DumpNumber(double %24, %struct.DumpState* %1)
  br label %31

; <label>:25:                                     ; preds = %9
  %26 = bitcast %struct.TValue* %12 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !21
  tail call fastcc void @DumpInteger(i64 %27, %struct.DumpState* %1)
  br label %31

; <label>:28:                                     ; preds = %9, %9
  %29 = bitcast %struct.TValue* %12 to %struct.TString**
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !21
  tail call fastcc void @DumpString(%struct.TString* %30, %struct.DumpState* %1)
  br label %31

; <label>:31:                                     ; preds = %9, %28, %25, %22, %19
  %32 = add nuw nsw i64 %10, 1
  %33 = icmp eq i64 %32, %8
  br i1 %33, label %34, label %9

; <label>:34:                                     ; preds = %31, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpUpvalues(%struct.Proto* nocapture readonly, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 6
  %4 = load i32, i32* %3, align 8, !tbaa !166
  tail call fastcc void @DumpInt(i32 %4, %struct.DumpState* %1)
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %21

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %8 = zext i32 %4 to i64
  br label %9

; <label>:9:                                      ; preds = %9, %6
  %10 = phi i64 [ 0, %6 ], [ %19, %9 ]
  %11 = load %struct.Upvaldesc*, %struct.Upvaldesc** %7, align 8, !tbaa !174
  %12 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %11, i64 %10, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !236
  %14 = zext i8 %13 to i32
  tail call fastcc void @DumpByte(i32 %14, %struct.DumpState* %1)
  %15 = load %struct.Upvaldesc*, %struct.Upvaldesc** %7, align 8, !tbaa !174
  %16 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %15, i64 %10, i32 2
  %17 = load i8, i8* %16, align 1, !tbaa !237
  %18 = zext i8 %17 to i32
  tail call fastcc void @DumpByte(i32 %18, %struct.DumpState* %1)
  %19 = add nuw nsw i64 %10, 1
  %20 = icmp eq i64 %19, %8
  br i1 %20, label %21, label %9

; <label>:21:                                     ; preds = %9, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpProtos(%struct.Proto* nocapture readonly, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 10
  %4 = load i32, i32* %3, align 8, !tbaa !208
  tail call fastcc void @DumpInt(i32 %4, %struct.DumpState* %1)
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %18

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 17
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %9 = zext i32 %4 to i64
  br label %10

; <label>:10:                                     ; preds = %10, %6
  %11 = phi i64 [ 0, %6 ], [ %16, %10 ]
  %12 = load %struct.Proto**, %struct.Proto*** %7, align 8, !tbaa !207
  %13 = getelementptr inbounds %struct.Proto*, %struct.Proto** %12, i64 %11
  %14 = load %struct.Proto*, %struct.Proto** %13, align 8, !tbaa !79
  %15 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !104
  tail call fastcc void @DumpFunction(%struct.Proto* %14, %struct.TString* %15, %struct.DumpState* %1)
  %16 = add nuw nsw i64 %11, 1
  %17 = icmp eq i64 %16, %9
  br i1 %17, label %18, label %10

; <label>:18:                                     ; preds = %10, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @DumpDebug(%struct.Proto* nocapture readonly, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 3
  %4 = load i32, i32* %3, align 8, !tbaa !164
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 9
  %8 = load i32, i32* %7, align 4, !tbaa !102
  br label %9

; <label>:9:                                      ; preds = %2, %6
  %10 = phi i32 [ %8, %6 ], [ 0, %2 ]
  tail call fastcc void @DumpInt(i32 %10, %struct.DumpState* nonnull %1)
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %12 = load i8*, i8** %11, align 8, !tbaa !211
  %13 = sext i32 %10 to i64
  tail call fastcc void @DumpBlock(i8* %12, i64 %13, %struct.DumpState* nonnull %1)
  %14 = load i32, i32* %3, align 8, !tbaa !164
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %17, label %16

; <label>:16:                                     ; preds = %9
  tail call fastcc void @DumpInt(i32 0, %struct.DumpState* nonnull %1)
  br label %34

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %19 = load i32, i32* %18, align 8, !tbaa !213
  tail call fastcc void @DumpInt(i32 %19, %struct.DumpState* nonnull %1)
  %20 = icmp sgt i32 %19, 0
  br i1 %20, label %21, label %34

; <label>:21:                                     ; preds = %17
  %22 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %23 = zext i32 %19 to i64
  br label %24

; <label>:24:                                     ; preds = %24, %21
  %25 = phi i64 [ 0, %21 ], [ %32, %24 ]
  %26 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %22, align 8, !tbaa !212
  %27 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %26, i64 %25, i32 0
  %28 = load i32, i32* %27, align 4, !tbaa !234
  tail call fastcc void @DumpInt(i32 %28, %struct.DumpState* %1)
  %29 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %22, align 8, !tbaa !212
  %30 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %29, i64 %25, i32 1
  %31 = load i32, i32* %30, align 4, !tbaa !258
  tail call fastcc void @DumpInt(i32 %31, %struct.DumpState* %1)
  %32 = add nuw nsw i64 %25, 1
  %33 = icmp eq i64 %32, %23
  br i1 %33, label %34, label %24

; <label>:34:                                     ; preds = %24, %16, %17
  %35 = load i32, i32* %3, align 8, !tbaa !164
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %38, label %37

; <label>:37:                                     ; preds = %34
  tail call fastcc void @DumpInt(i32 0, %struct.DumpState* nonnull %1)
  br label %58

; <label>:38:                                     ; preds = %34
  %39 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %40 = load i32, i32* %39, align 4, !tbaa !82
  tail call fastcc void @DumpInt(i32 %40, %struct.DumpState* nonnull %1)
  %41 = icmp sgt i32 %40, 0
  br i1 %41, label %42, label %58

; <label>:42:                                     ; preds = %38
  %43 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %44 = zext i32 %40 to i64
  br label %45

; <label>:45:                                     ; preds = %45, %42
  %46 = phi i64 [ 0, %42 ], [ %56, %45 ]
  %47 = load %struct.LocVar*, %struct.LocVar** %43, align 8, !tbaa !84
  %48 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %47, i64 %46, i32 0
  %49 = load %struct.TString*, %struct.TString** %48, align 8, !tbaa !88
  tail call fastcc void @DumpString(%struct.TString* %49, %struct.DumpState* %1)
  %50 = load %struct.LocVar*, %struct.LocVar** %43, align 8, !tbaa !84
  %51 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %50, i64 %46, i32 1
  %52 = load i32, i32* %51, align 8, !tbaa !85
  tail call fastcc void @DumpInt(i32 %52, %struct.DumpState* %1)
  %53 = load %struct.LocVar*, %struct.LocVar** %43, align 8, !tbaa !84
  %54 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %53, i64 %46, i32 2
  %55 = load i32, i32* %54, align 4, !tbaa !87
  tail call fastcc void @DumpInt(i32 %55, %struct.DumpState* %1)
  %56 = add nuw nsw i64 %46, 1
  %57 = icmp eq i64 %56, %44
  br i1 %57, label %58, label %45

; <label>:58:                                     ; preds = %45, %37, %38
  %59 = load i32, i32* %3, align 8, !tbaa !164
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %62, label %61

; <label>:61:                                     ; preds = %58
  tail call fastcc void @DumpInt(i32 0, %struct.DumpState* nonnull %1)
  br label %76

; <label>:62:                                     ; preds = %58
  %63 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 6
  %64 = load i32, i32* %63, align 8, !tbaa !166
  tail call fastcc void @DumpInt(i32 %64, %struct.DumpState* nonnull %1)
  %65 = icmp sgt i32 %64, 0
  br i1 %65, label %66, label %76

; <label>:66:                                     ; preds = %62
  %67 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %68 = zext i32 %64 to i64
  br label %69

; <label>:69:                                     ; preds = %69, %66
  %70 = phi i64 [ 0, %66 ], [ %74, %69 ]
  %71 = load %struct.Upvaldesc*, %struct.Upvaldesc** %67, align 8, !tbaa !174
  %72 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %71, i64 %70, i32 0
  %73 = load %struct.TString*, %struct.TString** %72, align 8, !tbaa !175
  tail call fastcc void @DumpString(%struct.TString* %73, %struct.DumpState* %1)
  %74 = add nuw nsw i64 %70, 1
  %75 = icmp eq i64 %74, %68
  br i1 %75, label %76, label %69

; <label>:76:                                     ; preds = %69, %61, %62
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @fullinc(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  %4 = load i8, i8* %3, align 1, !tbaa !62
  %5 = icmp ult i8 %4, 3
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  tail call fastcc void @entersweep(%struct.lua_State* %0)
  br label %7

; <label>:7:                                      ; preds = %6, %2
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 256)
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 128)
  tail call fastcc void @luaC_runtilstate(%struct.lua_State* %0, i32 256)
  tail call fastcc void @setpause(%struct.global_State* nonnull %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @findindex(%struct.lua_State*, %struct.Table* nocapture readonly, %struct.TValue* nocapture readonly, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %35, label %9

; <label>:9:                                      ; preds = %4
  %10 = icmp eq i8 %6, 35
  br i1 %10, label %11, label %15

; <label>:11:                                     ; preds = %9
  %12 = bitcast %struct.TValue* %2 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !21
  %14 = tail call fastcc i32 @arrayindex(i64 %13)
  br label %15

; <label>:15:                                     ; preds = %9, %11
  %16 = phi i32 [ %14, %11 ], [ 0, %9 ]
  %17 = add i32 %16, -1
  %18 = icmp ult i32 %17, %3
  br i1 %18, label %35, label %19

; <label>:19:                                     ; preds = %15
  %20 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %1, %struct.TValue* nonnull %2)
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = icmp eq i8 %22, 32
  br i1 %23, label %24, label %25, !prof !33

; <label>:24:                                     ; preds = %19
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.280, i64 0, i64 0)) #17
  unreachable

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %27 = bitcast %union.Node** %26 to i64*
  %28 = load i64, i64* %27, align 8, !tbaa !123
  %29 = ptrtoint %struct.TValue* %20 to i64
  %30 = sub i64 %29, %28
  %31 = sdiv exact i64 %30, 24
  %32 = trunc i64 %31 to i32
  %33 = add i32 %3, 1
  %34 = add i32 %33, %32
  br label %35

; <label>:35:                                     ; preds = %15, %4, %25
  %36 = phi i32 [ %34, %25 ], [ 0, %4 ], [ %16, %15 ]
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define internal void @trynewtbcupval(%struct.lua_State*, i8*) #0 {
  %3 = bitcast i8* %1 to %union.StackValue*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 25, %union.StackValue* %3, %struct.UpVal** nonnull %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @copy2buff(%union.StackValue* nocapture readonly, i32, i8* nocapture) unnamed_addr #0 {
  %4 = sext i32 %1 to i64
  br label %5

; <label>:5:                                      ; preds = %22, %3
  %6 = phi i64 [ %29, %22 ], [ %4, %3 ]
  %7 = phi i64 [ %28, %22 ], [ 0, %3 ]
  %8 = sub nsw i64 0, %6
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %0, i64 %8, i32 0, i32 0, i32 0
  %10 = bitcast %struct.GCObject** %9 to %struct.TString**
  %11 = load %struct.TString*, %struct.TString** %10, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = icmp eq i8 %13, 20
  br i1 %14, label %15, label %19

; <label>:15:                                     ; preds = %5
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 4
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  br label %22

; <label>:19:                                     ; preds = %5
  %20 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 6, i32 0
  %21 = load i64, i64* %20, align 8, !tbaa !21
  br label %22

; <label>:22:                                     ; preds = %19, %15
  %23 = phi i64 [ %18, %15 ], [ %21, %19 ]
  %24 = getelementptr inbounds i8, i8* %2, i64 %7
  %25 = bitcast %struct.GCObject** %9 to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds i8, i8* %26, i64 24
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* nonnull %27, i64 %23, i32 1, i1 false)
  %28 = add i64 %23, %7
  %29 = add nsw i64 %6, -1
  %30 = icmp sgt i64 %6, 1
  br i1 %30, label %5, label %31

; <label>:31:                                     ; preds = %22
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @findfield(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %28, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %7 = icmp eq i32 %6, 5
  br i1 %7, label %8, label %28

; <label>:8:                                      ; preds = %5
  tail call void @lua_pushnil(%struct.lua_State* %0)
  %9 = tail call i32 @lua_next(%struct.lua_State* %0, i32 -2)
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %28, label %11

; <label>:11:                                     ; preds = %8
  %12 = add nsw i32 %2, -1
  br label %13

; <label>:13:                                     ; preds = %11, %25
  %14 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -2)
  %15 = icmp eq i32 %14, 4
  br i1 %15, label %16, label %25

; <label>:16:                                     ; preds = %13
  %17 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 %1, i32 -1)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %20, label %19

; <label>:19:                                     ; preds = %16
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %28

; <label>:20:                                     ; preds = %16
  %21 = tail call fastcc i32 @findfield(%struct.lua_State* %0, i32 %1, i32 %12)
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %24 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0))
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  tail call void @lua_concat(%struct.lua_State* %0, i32 3)
  br label %28

; <label>:25:                                     ; preds = %20, %13
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %26 = tail call i32 @lua_next(%struct.lua_State* %0, i32 -2)
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %13

; <label>:28:                                     ; preds = %25, %8, %3, %5, %23, %19
  %29 = phi i32 [ 1, %19 ], [ 1, %23 ], [ 0, %5 ], [ 0, %3 ], [ 0, %8 ], [ 0, %25 ]
  ret i32 %29
}

; Function Attrs: nounwind readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc i64 @newbuffsize(%struct.luaL_Buffer* nocapture readonly, i64) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 1
  %4 = load i64, i64* %3, align 8, !tbaa !180
  %5 = shl i64 %4, 1
  %6 = xor i64 %1, -1
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %8 = load i64, i64* %7, align 8, !tbaa !182
  %9 = icmp ugt i64 %8, %6
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !184
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %12, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.292, i64 0, i64 0))
  unreachable

; <label>:14:                                     ; preds = %2
  %15 = add i64 %8, %1
  %16 = icmp ult i64 %5, %15
  %17 = select i1 %16, i64 %15, i64 %5
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @resizebox(%struct.lua_State*, i32, i64) unnamed_addr #0 {
  %4 = alloca i8*, align 8
  %5 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* (i8*, i8*, i64, i64)* @lua_getallocf(%struct.lua_State* %0, i8** nonnull %4)
  %7 = call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1)
  %8 = load i8*, i8** %4, align 8, !tbaa !79
  %9 = bitcast i8* %7 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !330
  %11 = getelementptr inbounds i8, i8* %7, i64 8
  %12 = bitcast i8* %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !332
  %14 = call i8* %6(i8* %8, i8* %10, i64 %13, i64 %2) #7
  %15 = icmp eq i8* %14, null
  %16 = icmp ne i64 %2, 0
  %17 = and i1 %16, %15
  br i1 %17, label %18, label %20

; <label>:18:                                     ; preds = %3
  %19 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.293, i64 0, i64 0))
  unreachable

; <label>:20:                                     ; preds = %3
  store i8* %14, i8** %9, align 8, !tbaa !330
  store i64 %2, i64* %12, align 8, !tbaa !332
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %14
}

; Function Attrs: nounwind uwtable
define internal fastcc void @newbox(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0)
  call void @llvm.memset.p0i8.i64(i8* nonnull %2, i8 0, i64 16, i32 8, i1 false)
  %3 = tail call i32 @luaL_newmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.294, i64 0, i64 0))
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %6, label %5

; <label>:5:                                      ; preds = %1
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @boxmt, i64 0, i64 0), i32 0)
  br label %6

; <label>:6:                                      ; preds = %1, %5
  %7 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @boxgc(%struct.lua_State*) #0 {
  %2 = tail call fastcc i8* @resizebox(%struct.lua_State* %0, i32 1, i64 0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @skipBOM(%struct.LoadF* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 0
  store i32 0, i32* %2, align 8, !tbaa !187
  %3 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  br label %4

; <label>:4:                                      ; preds = %14, %1
  %5 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.296, i64 0, i64 0), %1 ], [ %10, %14 ]
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** %3, align 8, !tbaa !185
  %7 = tail call i32 @_IO_getc(%struct._IO_FILE* %6)
  %8 = icmp eq i32 %7, -1
  br i1 %8, label %26, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds i8, i8* %5, i64 1
  %11 = load i8, i8* %5, align 1, !tbaa !21
  %12 = zext i8 %11 to i32
  %13 = icmp eq i32 %7, %12
  br i1 %13, label %14, label %26

; <label>:14:                                     ; preds = %9
  %15 = trunc i32 %7 to i8
  %16 = load i32, i32* %2, align 8, !tbaa !187
  %17 = add nsw i32 %16, 1
  store i32 %17, i32* %2, align 8, !tbaa !187
  %18 = sext i32 %16 to i64
  %19 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 2, i64 %18
  store i8 %15, i8* %19, align 1, !tbaa !21
  %20 = load i8, i8* %10, align 1, !tbaa !21
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %4

; <label>:22:                                     ; preds = %14
  %23 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  store i32 0, i32* %2, align 8, !tbaa !187
  %24 = load %struct._IO_FILE*, %struct._IO_FILE** %23, align 8, !tbaa !185
  %25 = tail call i32 @_IO_getc(%struct._IO_FILE* %24)
  br label %26

; <label>:26:                                     ; preds = %4, %9, %22
  %27 = phi i32 [ %25, %22 ], [ -1, %4 ], [ %7, %9 ]
  ret i32 %27
}

; Function Attrs: nounwind
declare i32 @_IO_getc(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @feof(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i64 @fread(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare void @free(i8* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @fflush(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal i32 @luaB_assert(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %7

; <label>:4:                                      ; preds = %1
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.324, i64 0, i64 0))
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  %6 = tail call i32 @luaB_error(%struct.lua_State* %0)
  unreachable

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_collectgarbage(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i64 0, i64 0), i8** getelementptr inbounds ([11 x i8*], [11 x i8*]* @luaB_collectgarbage.opts, i64 0, i64 0))
  %3 = sext i32 %2 to i64
  %4 = getelementptr inbounds [10 x i32], [10 x i32]* @luaB_collectgarbage.optsnum, i64 0, i64 %3
  %5 = load i32, i32* %4, align 4, !tbaa !70
  switch i32 %5, label %38 [
    i32 3, label %6
    i32 5, label %13
    i32 6, label %17
    i32 7, label %17
    i32 9, label %22
    i32 10, label %24
    i32 11, label %30
  ]

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5)
  %8 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 4)
  %9 = sitofp i32 %7 to double
  %10 = sitofp i32 %8 to double
  %11 = fmul double %10, 0x3F50000000000000
  %12 = fadd double %11, %9
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %12)
  br label %41

; <label>:13:                                     ; preds = %1
  %14 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0)
  %15 = trunc i64 %14 to i32
  %16 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %15)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %16)
  br label %41

; <label>:17:                                     ; preds = %1, %1
  %18 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0)
  %19 = trunc i64 %18 to i32
  %20 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %19)
  %21 = sext i32 %20 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %21)
  br label %41

; <label>:22:                                     ; preds = %1
  %23 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %23)
  br label %41

; <label>:24:                                     ; preds = %1
  %25 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0)
  %26 = trunc i64 %25 to i32
  %27 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0)
  %28 = trunc i64 %27 to i32
  %29 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %26, i32 %28)
  tail call fastcc void @pushmode(%struct.lua_State* %0, i32 %29)
  br label %41

; <label>:30:                                     ; preds = %1
  %31 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0)
  %32 = trunc i64 %31 to i32
  %33 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0)
  %34 = trunc i64 %33 to i32
  %35 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 0)
  %36 = trunc i64 %35 to i32
  %37 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %32, i32 %34, i32 %36)
  tail call fastcc void @pushmode(%struct.lua_State* %0, i32 %37)
  br label %41

; <label>:38:                                     ; preds = %1
  %39 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5)
  %40 = sext i32 %39 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %40)
  br label %41

; <label>:41:                                     ; preds = %38, %30, %24, %22, %17, %13, %6
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_dofile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  %3 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %2, i8* null)
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @lua_error(%struct.lua_State* %0)
  unreachable

; <label>:7:                                      ; preds = %1
  tail call void @lua_callk(%struct.lua_State* %0, i32 0, i32 -1, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @dofilecont)
  %8 = tail call i32 @dofilecont(%struct.lua_State* %0, i32 0, i64 0)
  ret i32 %8
}

; Function Attrs: noreturn nounwind uwtable
define internal i32 @luaB_error(%struct.lua_State*) #5 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %3 = trunc i64 %2 to i32
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %5 = icmp eq i32 %4, 4
  %6 = icmp sgt i32 %3, 0
  %7 = and i1 %6, %5
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %1
  tail call void @luaL_where(%struct.lua_State* %0, i32 %3)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_concat(%struct.lua_State* %0, i32 2)
  br label %9

; <label>:9:                                      ; preds = %8, %1
  %10 = tail call i32 @lua_error(%struct.lua_State* %0)
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0))
  br label %7

; <label>:7:                                      ; preds = %5, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_ipairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @ipairsaux, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 0)
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_loadfile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* null, i64* null)
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 3)
  %5 = icmp eq i32 %4, -1
  %6 = select i1 %5, i32 0, i32 3
  %7 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %2, i8* %3)
  %8 = tail call fastcc i32 @load_aux(%struct.lua_State* %0, i32 %7, i32 %6)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_load(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.335, i64 0, i64 0), i64* null)
  %6 = call i32 @lua_type(%struct.lua_State* %0, i32 4)
  %7 = icmp eq i32 %6, -1
  %8 = select i1 %7, i32 0, i32 4
  %9 = icmp eq i8* %4, null
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* nonnull %4, i64* null)
  %12 = load i64, i64* %2, align 8, !tbaa !113
  %13 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %4, i64 %12, i8* %11, i8* %5)
  br label %17

; <label>:14:                                     ; preds = %1
  %15 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.336, i64 0, i64 0), i64* null)
  call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  call void @lua_settop(%struct.lua_State* %0, i32 5)
  %16 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @generic_reader, i8* null, i8* %15, i8* %5)
  br label %17

; <label>:17:                                     ; preds = %14, %10
  %18 = phi i32 [ %13, %10 ], [ %16, %14 ]
  %19 = call fastcc i32 @load_aux(%struct.lua_State* %0, i32 %18, i32 %8)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_next(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %2 = tail call i32 @lua_next(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %5

; <label>:5:                                      ; preds = %1, %4
  %6 = phi i32 [ 1, %4 ], [ 2, %1 ]
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %2 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.339, i64 0, i64 0))
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @luaB_next, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %6

; <label>:5:                                      ; preds = %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_callk(%struct.lua_State* %0, i32 1, i32 3, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  br label %6

; <label>:6:                                      ; preds = %5, %4
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_pcall(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1)
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = add nsw i32 %2, -2
  %4 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %3, i32 -1, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall)
  %5 = tail call i32 @finishpcall(%struct.lua_State* %0, i32 %4, i64 0)
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_print(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %20, label %5

; <label>:5:                                      ; preds = %1
  %6 = bitcast i64* %2 to i8*
  br label %7

; <label>:7:                                      ; preds = %14, %5
  %8 = phi i32 [ 1, %5 ], [ %18, %14 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %9 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %8, i64* nonnull %2)
  %10 = icmp ugt i32 %8, 1
  br i1 %10, label %11, label %14

; <label>:11:                                     ; preds = %7
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %13 = call i32 @fputc(i32 9, %struct._IO_FILE* %12)
  br label %14

; <label>:14:                                     ; preds = %11, %7
  %15 = load i64, i64* %2, align 8, !tbaa !113
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %17 = call i64 @fwrite(i8* %9, i64 1, i64 %15, %struct._IO_FILE* %16)
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  %18 = add nuw nsw i32 %8, 1
  %19 = icmp eq i32 %8, %3
  br i1 %19, label %20, label %7

; <label>:20:                                     ; preds = %14, %1
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %22 = call i32 @fputc(i32 10, %struct._IO_FILE* %21)
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %24 = call i32 @fflush(%struct._IO_FILE* %23)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_warn(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2)
  tail call void @lua_warning(%struct.lua_State* %0, i8* %2, i32 %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawequal(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2)
  %2 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 1, i32 2)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %2)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawlen(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = or i32 %2, 1
  %4 = icmp eq i32 %3, 5
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.341, i64 0, i64 0))
  br label %7

; <label>:7:                                      ; preds = %5, %1
  %8 = tail call i64 @lua_rawlen(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %8)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawget(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2)
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %2 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_rawset(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2)
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3)
  tail call void @lua_settop(%struct.lua_State* %0, i32 3)
  tail call void @lua_rawset(%struct.lua_State* %0, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_select(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %4 = icmp eq i32 %3, 4
  br i1 %4, label %5, label %12

; <label>:5:                                      ; preds = %1
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  %7 = load i8, i8* %6, align 1, !tbaa !21
  %8 = icmp eq i8 %7, 35
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %5
  %10 = add nsw i32 %2, -1
  %11 = sext i32 %10 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %11)
  br label %26

; <label>:12:                                     ; preds = %5, %1
  %13 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1)
  %14 = icmp slt i64 %13, 0
  %15 = sext i32 %2 to i64
  %16 = add nsw i64 %13, %15
  %17 = icmp sgt i64 %13, %15
  %18 = select i1 %17, i64 %15, i64 %13
  %19 = select i1 %14, i64 %16, i64 %18
  %20 = icmp sgt i64 %19, 0
  br i1 %20, label %23, label %21

; <label>:21:                                     ; preds = %12
  %22 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.342, i64 0, i64 0))
  br label %23

; <label>:23:                                     ; preds = %21, %12
  %24 = trunc i64 %19 to i32
  %25 = sub nsw i32 %2, %24
  br label %26

; <label>:26:                                     ; preds = %23, %9
  %27 = phi i32 [ 1, %9 ], [ %25, %23 ]
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_setmetatable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %1
  %4 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0))
  br label %5

; <label>:5:                                      ; preds = %1, %1, %3
  %6 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0))
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.344, i64 0, i64 0))
  unreachable

; <label>:10:                                     ; preds = %5
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %11 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_tonumber(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %6 = icmp slt i32 %5, 1
  br i1 %6, label %7, label %22

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %9 = icmp eq i32 %8, 3
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %7
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  br label %41

; <label>:11:                                     ; preds = %7
  %12 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %12) #7
  %13 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %14 = icmp eq i8* %13, null
  br i1 %14, label %20, label %15

; <label>:15:                                     ; preds = %11
  %16 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %13)
  %17 = load i64, i64* %2, align 8, !tbaa !113
  %18 = add i64 %17, 1
  %19 = icmp eq i64 %16, %18
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %11, %15
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %12) #7
  br label %40

; <label>:21:                                     ; preds = %15
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %12) #7
  br label %41

; <label>:22:                                     ; preds = %1
  %23 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %23) #7
  %24 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %24) #7
  store i64 0, i64* %4, align 8, !tbaa !109
  %25 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 4)
  %26 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %3)
  %27 = add i64 %25, -2
  %28 = icmp ult i64 %27, 35
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %22
  %30 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.345, i64 0, i64 0))
  br label %31

; <label>:31:                                     ; preds = %22, %29
  %32 = trunc i64 %25 to i32
  %33 = call fastcc i8* @b_str2int(i8* %26, i32 %32, i64* nonnull %4)
  %34 = load i64, i64* %3, align 8, !tbaa !113
  %35 = getelementptr inbounds i8, i8* %26, i64 %34
  %36 = icmp eq i8* %33, %35
  br i1 %36, label %37, label %39

; <label>:37:                                     ; preds = %31
  %38 = load i64, i64* %4, align 8, !tbaa !109
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %38)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %24) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %23) #7
  br label %41

; <label>:39:                                     ; preds = %31
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %24) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %23) #7
  br label %40

; <label>:40:                                     ; preds = %39, %20
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %41

; <label>:41:                                     ; preds = %37, %21, %40, %10
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_tostring(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %2 = tail call i8* @luaL_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_type(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0))
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %2)
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_xpcall(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 2, i32 6)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 3, i32 2)
  %3 = add nsw i32 %2, -2
  %4 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %3, i32 -1, i32 2, i64 2, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall)
  %5 = tail call i32 @finishpcall(%struct.lua_State* %0, i32 %4, i64 2)
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushmode(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 11
  %4 = select i1 %3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i64 0, i64 0)
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %4)
  ret void
}

; Function Attrs: norecurse nounwind readonly uwtable
define internal i32 @dofilecont(%struct.lua_State* nocapture readonly, i32, i64) #3 {
  %4 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %5 = add nsw i32 %4, -1
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal i32 @ipairsaux(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %3 = add nsw i64 %2, 1
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %3)
  %4 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3)
  %5 = icmp eq i32 %4, 0
  %6 = select i1 %5, i32 1, i32 2
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @load_aux(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %11

; <label>:5:                                      ; preds = %3
  %6 = icmp eq i32 %2, 0
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %5
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %2)
  %8 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 -2, i32 1)
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %7
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %12

; <label>:11:                                     ; preds = %3
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %12

; <label>:12:                                     ; preds = %10, %5, %7, %11
  %13 = phi i32 [ 2, %11 ], [ 1, %7 ], [ 1, %5 ], [ 1, %10 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i8* @generic_reader(%struct.lua_State*, i8* nocapture readnone, i64*) #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.337, i64 0, i64 0))
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_callk(%struct.lua_State* %0, i32 0, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  store i64 0, i64* %2, align 8, !tbaa !113
  br label %14

; <label>:7:                                      ; preds = %3
  %8 = tail call i32 @lua_isstring(%struct.lua_State* %0, i32 -1)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %7
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.338, i64 0, i64 0))
  unreachable

; <label>:12:                                     ; preds = %7
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 5)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %13 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 5, i64* %2)
  br label %14

; <label>:14:                                     ; preds = %12, %6
  %15 = phi i8* [ null, %6 ], [ %13, %12 ]
  ret i8* %15
}

; Function Attrs: norecurse nounwind uwtable
define internal i32 @finishpcall(%struct.lua_State* nocapture, i32, i64) #2 {
  %4 = icmp ugt i32 %1, 1
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %3
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -2)
  br label %10

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %8 = trunc i64 %2 to i32
  %9 = sub nsw i32 %7, %8
  br label %10

; <label>:10:                                     ; preds = %6, %5
  %11 = phi i32 [ 2, %5 ], [ %9, %6 ]
  ret i32 %11
}

; Function Attrs: nounwind
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i8* @b_str2int(i8* readonly, i32, i64* nocapture) unnamed_addr #0 {
  %4 = tail call i64 @strspn(i8* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #19
  %5 = getelementptr inbounds i8, i8* %0, i64 %4
  %6 = load i8, i8* %5, align 1, !tbaa !21
  switch i8 %6, label %11 [
    i8 45, label %7
    i8 43, label %9
  ]

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds i8, i8* %5, i64 1
  br label %11

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds i8, i8* %5, i64 1
  br label %11

; <label>:11:                                     ; preds = %3, %9, %7
  %12 = phi i32 [ 1, %7 ], [ 0, %9 ], [ 0, %3 ]
  %13 = phi i8* [ %8, %7 ], [ %10, %9 ], [ %5, %3 ]
  %14 = tail call i16** @__ctype_b_loc() #21
  %15 = load i16*, i16** %14, align 8, !tbaa !79
  %16 = load i8, i8* %13, align 1, !tbaa !21
  %17 = zext i8 %16 to i64
  %18 = getelementptr inbounds i16, i16* %15, i64 %17
  %19 = load i16, i16* %18, align 2, !tbaa !312
  %20 = and i16 %19, 8
  %21 = icmp eq i16 %20, 0
  br i1 %21, label %62, label %22

; <label>:22:                                     ; preds = %11
  %23 = sext i32 %1 to i64
  br label %24

; <label>:24:                                     ; preds = %45, %22
  %25 = phi i64 [ 0, %22 ], [ %48, %45 ]
  %26 = phi i8* [ %13, %22 ], [ %49, %45 ]
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = zext i8 %27 to i64
  %29 = getelementptr inbounds i16, i16* %15, i64 %28
  %30 = load i16, i16* %29, align 2, !tbaa !312
  %31 = and i16 %30, 2048
  %32 = icmp eq i16 %31, 0
  br i1 %32, label %36, label %33

; <label>:33:                                     ; preds = %24
  %34 = sext i8 %27 to i32
  %35 = add nsw i32 %34, -48
  br label %42

; <label>:36:                                     ; preds = %24
  %37 = tail call i32** @__ctype_toupper_loc() #21
  %38 = load i32*, i32** %37, align 8, !tbaa !79
  %39 = getelementptr inbounds i32, i32* %38, i64 %28
  %40 = load i32, i32* %39, align 4, !tbaa !70
  %41 = add nsw i32 %40, -55
  br label %42

; <label>:42:                                     ; preds = %36, %33
  %43 = phi i32 [ %35, %33 ], [ %41, %36 ]
  %44 = icmp slt i32 %43, %1
  br i1 %44, label %45, label %62

; <label>:45:                                     ; preds = %42
  %46 = mul i64 %25, %23
  %47 = sext i32 %43 to i64
  %48 = add i64 %46, %47
  %49 = getelementptr inbounds i8, i8* %26, i64 1
  %50 = load i8, i8* %49, align 1, !tbaa !21
  %51 = zext i8 %50 to i64
  %52 = getelementptr inbounds i16, i16* %15, i64 %51
  %53 = load i16, i16* %52, align 2, !tbaa !312
  %54 = and i16 %53, 8
  %55 = icmp eq i16 %54, 0
  br i1 %55, label %56, label %24

; <label>:56:                                     ; preds = %45
  %57 = tail call i64 @strspn(i8* nonnull %49, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #19
  %58 = getelementptr inbounds i8, i8* %49, i64 %57
  %59 = icmp eq i32 %12, 0
  %60 = sub i64 0, %48
  %61 = select i1 %59, i64 %48, i64 %60
  store i64 %61, i64* %2, align 8, !tbaa !109
  br label %62

; <label>:62:                                     ; preds = %42, %11, %56
  %63 = phi i8* [ %58, %56 ], [ null, %11 ], [ null, %42 ]
  ret i8* %63
}

; Function Attrs: nounwind readnone
declare i16** @__ctype_b_loc() local_unnamed_addr #8

; Function Attrs: nounwind readnone
declare i32** @__ctype_toupper_loc() local_unnamed_addr #8

; Function Attrs: nounwind uwtable
define internal i32 @luaB_cocreate(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  %2 = tail call %struct.lua_State* @lua_newthread(%struct.lua_State* %0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* nonnull %2, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_coresume(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0)
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = add nsw i32 %3, -1
  %5 = tail call fastcc i32 @auxresume(%struct.lua_State* %0, %struct.lua_State* %2, i32 %4)
  %6 = icmp slt i32 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 0)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %11

; <label>:8:                                      ; preds = %1
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  %9 = add nsw i32 %5, 1
  %10 = xor i32 %5, -1
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %10, i32 1)
  br label %11

; <label>:11:                                     ; preds = %8, %7
  %12 = phi i32 [ 2, %7 ], [ %9, %8 ]
  ret i32 %12
}

; Function Attrs: norecurse nounwind uwtable
define internal i32 @luaB_corunning(%struct.lua_State*) #2 {
  %2 = tail call i32 @lua_pushthread(%struct.lua_State* %0)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %2)
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_costatus(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0)
  %3 = tail call fastcc i32 @auxstatus(%struct.lua_State* %0, %struct.lua_State* %2)
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !79
  %7 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %6)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_cowrap(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaB_cocreate(%struct.lua_State* %0)
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @luaB_auxwrap, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_yield(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = tail call i32 @lua_yieldk(%struct.lua_State* %0, i32 %2, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_yieldable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0)
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = phi %struct.lua_State* [ %5, %4 ], [ %0, %1 ]
  %8 = tail call i32 @lua_isyieldable(%struct.lua_State* %7)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %8)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_kill(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0)
  %3 = tail call fastcc i32 @auxstatus(%struct.lua_State* %0, %struct.lua_State* %2)
  %4 = add i32 %3, -1
  %5 = icmp ult i32 %4, 2
  br i1 %5, label %6, label %11

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @lua_resetthread(%struct.lua_State* %2)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %6
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %16

; <label>:10:                                     ; preds = %6
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 0)
  tail call void @lua_xmove(%struct.lua_State* %2, %struct.lua_State* %0, i32 1)
  br label %16

; <label>:11:                                     ; preds = %1
  %12 = sext i32 %3 to i64
  %13 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %12
  %14 = load i8*, i8** %13, align 8, !tbaa !79
  %15 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.360, i64 0, i64 0), i8* %14)
  unreachable

; <label>:16:                                     ; preds = %10, %9
  %17 = phi i32 [ 1, %9 ], [ 2, %10 ]
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct.lua_State* @getco(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1)
  %3 = icmp eq %struct.lua_State* %2, null
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i64 0, i64 0))
  br label %6

; <label>:6:                                      ; preds = %1, %4
  ret %struct.lua_State* %2
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @auxresume(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.355, i64 0, i64 0))
  br label %31

; <label>:10:                                     ; preds = %3
  %11 = tail call i32 @lua_status(%struct.lua_State* %1)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %18

; <label>:13:                                     ; preds = %10
  %14 = tail call i32 @lua_gettop(%struct.lua_State* %1)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %13
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0))
  br label %31

; <label>:18:                                     ; preds = %13, %10
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* %1, i32 %2)
  %19 = call i32 @lua_resume(%struct.lua_State* %1, %struct.lua_State* %0, i32 %2, i32* nonnull %4)
  %20 = icmp ult i32 %19, 2
  br i1 %20, label %21, label %30

; <label>:21:                                     ; preds = %18
  %22 = load i32, i32* %4, align 4, !tbaa !70
  %23 = add nsw i32 %22, 1
  %24 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %23)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %21
  %27 = xor i32 %22, -1
  tail call void @lua_settop(%struct.lua_State* %1, i32 %27)
  %28 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.356, i64 0, i64 0))
  br label %31

; <label>:29:                                     ; preds = %21
  tail call void @lua_xmove(%struct.lua_State* %1, %struct.lua_State* %0, i32 %22)
  br label %31

; <label>:30:                                     ; preds = %18
  tail call void @lua_xmove(%struct.lua_State* %1, %struct.lua_State* %0, i32 1)
  br label %31

; <label>:31:                                     ; preds = %30, %29, %26, %16, %8
  %32 = phi i32 [ -1, %16 ], [ %22, %29 ], [ -1, %26 ], [ -1, %30 ], [ -1, %8 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @auxstatus(%struct.lua_State* readnone, %struct.lua_State* readonly) unnamed_addr #0 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %18, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @lua_status(%struct.lua_State* %1)
  switch i32 %6, label %17 [
    i32 1, label %18
    i32 0, label %7
  ]

; <label>:7:                                      ; preds = %5
  %8 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %8) #7
  %9 = call i32 @lua_getstack(%struct.lua_State* %1, i32 0, %struct.lua_Debug* nonnull %3)
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %15

; <label>:11:                                     ; preds = %7
  %12 = tail call i32 @lua_gettop(%struct.lua_State* %1)
  %13 = icmp eq i32 %12, 0
  %14 = select i1 %13, i32 1, i32 2
  br label %15

; <label>:15:                                     ; preds = %11, %7
  %16 = phi i32 [ 3, %7 ], [ %14, %11 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %8) #7
  br label %18

; <label>:17:                                     ; preds = %5
  br label %18

; <label>:18:                                     ; preds = %5, %2, %17, %15
  %19 = phi i32 [ 1, %17 ], [ %16, %15 ], [ 0, %2 ], [ 2, %5 ]
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal i32 @luaB_auxwrap(%struct.lua_State*) #0 {
  %2 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 -1001001)
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = tail call fastcc i32 @auxresume(%struct.lua_State* %0, %struct.lua_State* %2, i32 %3)
  %5 = icmp slt i32 %4, 0
  br i1 %5, label %6, label %19

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @lua_status(%struct.lua_State* %2)
  %8 = icmp ugt i32 %7, 1
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %6
  %10 = tail call i32 @lua_resetthread(%struct.lua_State* %2)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  tail call void @lua_xmove(%struct.lua_State* %2, %struct.lua_State* %0, i32 1)
  br label %13

; <label>:13:                                     ; preds = %9, %12, %6
  %14 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %15 = icmp eq i32 %14, 4
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %13
  tail call void @luaL_where(%struct.lua_State* %0, i32 1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  tail call void @lua_concat(%struct.lua_State* %0, i32 2)
  br label %17

; <label>:17:                                     ; preds = %16, %13
  %18 = tail call i32 @lua_error(%struct.lua_State* %0)
  unreachable

; <label>:19:                                     ; preds = %1
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @db_debug(%struct.lua_State*) #0 {
  %2 = alloca [250 x i8], align 16
  %3 = getelementptr inbounds [250 x i8], [250 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 250, i8* nonnull %3) #7
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %5 = call i64 @fwrite(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.375, i64 0, i64 0), i64 11, i64 1, %struct._IO_FILE* %4) #22
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %7 = call i32 @fflush(%struct._IO_FILE* %6)
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !79
  %9 = call i8* @fgets(i8* nonnull %3, i32 250, %struct._IO_FILE* %8)
  %10 = icmp eq i8* %9, null
  br i1 %10, label %36, label %11

; <label>:11:                                     ; preds = %1
  br label %12

; <label>:12:                                     ; preds = %11, %28
  %13 = call i32 @strcmp(i8* nonnull %3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.376, i64 0, i64 0)) #19
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %36, label %15

; <label>:15:                                     ; preds = %12
  %16 = call i64 @strlen(i8* nonnull %3) #19
  %17 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %3, i64 %16, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.377, i64 0, i64 0), i8* null)
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %22

; <label>:19:                                     ; preds = %15
  %20 = call i32 @lua_pcallk(%struct.lua_State* %0, i32 0, i32 0, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %28, label %22

; <label>:22:                                     ; preds = %19, %15
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %24 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %25 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %23, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %24) #22
  %26 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %27 = call i32 @fflush(%struct._IO_FILE* %26)
  br label %28

; <label>:28:                                     ; preds = %19, %22
  call void @lua_settop(%struct.lua_State* %0, i32 0)
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %3) #7
  call void @llvm.lifetime.start.p0i8(i64 250, i8* nonnull %3) #7
  %29 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %30 = call i64 @fwrite(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.375, i64 0, i64 0), i64 11, i64 1, %struct._IO_FILE* %29) #22
  %31 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %32 = call i32 @fflush(%struct._IO_FILE* %31)
  %33 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !79
  %34 = call i8* @fgets(i8* nonnull %3, i32 250, %struct._IO_FILE* %33)
  %35 = icmp eq i8* %34, null
  br i1 %35, label %36, label %12

; <label>:36:                                     ; preds = %12, %28, %1
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %3) #7
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %4 = icmp eq i32 %3, 7
  br i1 %4, label %6, label %5

; <label>:5:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %11

; <label>:6:                                      ; preds = %1
  %7 = trunc i64 %2 to i32
  %8 = tail call i32 @lua_getiuservalue(%struct.lua_State* %0, i32 1, i32 %7)
  %9 = icmp eq i32 %8, -1
  br i1 %9, label %11, label %10

; <label>:10:                                     ; preds = %6
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %11

; <label>:11:                                     ; preds = %5, %6, %10
  %12 = phi i32 [ 2, %10 ], [ 1, %6 ], [ 1, %5 ]
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal i32 @db_gethook(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca [5 x i8], align 1
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2)
  %6 = getelementptr inbounds [5 x i8], [5 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 5, i8* nonnull %6) #7
  %7 = tail call i32 @lua_gethookmask(%struct.lua_State* %5)
  %8 = tail call void (%struct.lua_State*, %struct.lua_Debug*)* @lua_gethook(%struct.lua_State* %5)
  %9 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %8, null
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %19

; <label>:11:                                     ; preds = %1
  %12 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %8, @hookf
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %11
  %14 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.378, i64 0, i64 0))
  br label %19

; <label>:15:                                     ; preds = %11
  %16 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*))
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1)
  %17 = tail call i32 @lua_pushthread(%struct.lua_State* %5)
  tail call void @lua_xmove(%struct.lua_State* %5, %struct.lua_State* %0, i32 1)
  %18 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %19

; <label>:19:                                     ; preds = %13, %15, %10
  %20 = call fastcc i8* @unmakemask(i32 %7, i8* nonnull %6)
  %21 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %20)
  %22 = call i32 @lua_gethookcount(%struct.lua_State* %5)
  %23 = sext i32 %22 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %23)
  call void @llvm.lifetime.end.p0i8(i64 5, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 3
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getinfo(%struct.lua_State*) #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = alloca i32, align 4
  %4 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %4) #7
  %5 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %3)
  %7 = load i32, i32* %3, align 4, !tbaa !70
  %8 = add nsw i32 %7, 2
  %9 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.381, i64 0, i64 0), i64* null)
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %6, i32 3)
  %10 = add nsw i32 %7, 1
  %11 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %10)
  %12 = icmp eq i32 %11, 6
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %1
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.382, i64 0, i64 0), i8* %9)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %10)
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* %6, i32 1)
  br label %21

; <label>:15:                                     ; preds = %1
  %16 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %10)
  %17 = trunc i64 %16 to i32
  %18 = call i32 @lua_getstack(%struct.lua_State* %6, i32 %17, %struct.lua_Debug* nonnull %2)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %15
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %95

; <label>:21:                                     ; preds = %15, %13
  %22 = phi i8* [ %14, %13 ], [ %9, %15 ]
  %23 = call i32 @lua_getinfo(%struct.lua_State* %6, i8* %22, %struct.lua_Debug* nonnull %2)
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %27

; <label>:25:                                     ; preds = %21
  %26 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.383, i64 0, i64 0))
  br label %95

; <label>:27:                                     ; preds = %21
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0)
  %28 = tail call i8* @strchr(i8* %22, i32 83) #19
  %29 = icmp eq i8* %28, null
  br i1 %29, label %43, label %30

; <label>:30:                                     ; preds = %27
  %31 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 4
  %32 = load i8*, i8** %31, align 8, !tbaa !229
  %33 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 5
  %34 = load i64, i64* %33, align 8, !tbaa !230
  %35 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %32, i64 %34)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.384, i64 0, i64 0))
  %36 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 15, i64 0
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.385, i64 0, i64 0), i8* nonnull %36)
  %37 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 7
  %38 = load i32, i32* %37, align 4, !tbaa !179
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.386, i64 0, i64 0), i32 %38)
  %39 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 8
  %40 = load i32, i32* %39, align 8, !tbaa !231
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.387, i64 0, i64 0), i32 %40)
  %41 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 3
  %42 = load i8*, i8** %41, align 8, !tbaa !178
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.388, i64 0, i64 0), i8* %42)
  br label %43

; <label>:43:                                     ; preds = %27, %30
  %44 = call i8* @strchr(i8* %22, i32 108) #19
  %45 = icmp eq i8* %44, null
  br i1 %45, label %49, label %46

; <label>:46:                                     ; preds = %43
  %47 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %48 = load i32, i32* %47, align 8, !tbaa !90
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.389, i64 0, i64 0), i32 %48)
  br label %49

; <label>:49:                                     ; preds = %43, %46
  %50 = call i8* @strchr(i8* %22, i32 117) #19
  %51 = icmp eq i8* %50, null
  br i1 %51, label %62, label %52

; <label>:52:                                     ; preds = %49
  %53 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %54 = load i8, i8* %53, align 4, !tbaa !91
  %55 = zext i8 %54 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.390, i64 0, i64 0), i32 %55)
  %56 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %57 = load i8, i8* %56, align 1, !tbaa !93
  %58 = zext i8 %57 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.391, i64 0, i64 0), i32 %58)
  %59 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %60 = load i8, i8* %59, align 2, !tbaa !92
  %61 = sext i8 %60 to i32
  call fastcc void @settabsb(%struct.lua_State* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.392, i64 0, i64 0), i32 %61)
  br label %62

; <label>:62:                                     ; preds = %49, %52
  %63 = call i8* @strchr(i8* %22, i32 110) #19
  %64 = icmp eq i8* %63, null
  br i1 %64, label %70, label %65

; <label>:65:                                     ; preds = %62
  %66 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %67 = load i8*, i8** %66, align 8, !tbaa !98
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.393, i64 0, i64 0), i8* %67)
  %68 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %69 = load i8*, i8** %68, align 8, !tbaa !97
  call fastcc void @settabss(%struct.lua_State* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.394, i64 0, i64 0), i8* %69)
  br label %70

; <label>:70:                                     ; preds = %62, %65
  %71 = call i8* @strchr(i8* %22, i32 114) #19
  %72 = icmp eq i8* %71, null
  br i1 %72, label %80, label %73

; <label>:73:                                     ; preds = %70
  %74 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %75 = load i16, i16* %74, align 8, !tbaa !100
  %76 = zext i16 %75 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.395, i64 0, i64 0), i32 %76)
  %77 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %78 = load i16, i16* %77, align 2, !tbaa !99
  %79 = zext i16 %78 to i32
  call fastcc void @settabsi(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.396, i64 0, i64 0), i32 %79)
  br label %80

; <label>:80:                                     ; preds = %70, %73
  %81 = call i8* @strchr(i8* %22, i32 116) #19
  %82 = icmp eq i8* %81, null
  br i1 %82, label %87, label %83

; <label>:83:                                     ; preds = %80
  %84 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %85 = load i8, i8* %84, align 1, !tbaa !96
  %86 = sext i8 %85 to i32
  call fastcc void @settabsb(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.397, i64 0, i64 0), i32 %86)
  br label %87

; <label>:87:                                     ; preds = %80, %83
  %88 = call i8* @strchr(i8* %22, i32 76) #19
  %89 = icmp eq i8* %88, null
  br i1 %89, label %91, label %90

; <label>:90:                                     ; preds = %87
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %6, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.398, i64 0, i64 0))
  br label %91

; <label>:91:                                     ; preds = %87, %90
  %92 = call i8* @strchr(i8* %22, i32 102) #19
  %93 = icmp eq i8* %92, null
  br i1 %93, label %95, label %94

; <label>:94:                                     ; preds = %91
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.399, i64 0, i64 0))
  br label %95

; <label>:95:                                     ; preds = %94, %91, %25, %20
  %96 = phi i32 [ %26, %25 ], [ 1, %20 ], [ 1, %91 ], [ 1, %94 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %4) #7
  ret i32 %96
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getlocal(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2)
  %6 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = load i32, i32* %2, align 4, !tbaa !70
  %8 = add nsw i32 %7, 2
  %9 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %8)
  %10 = trunc i64 %9 to i32
  %11 = add nsw i32 %7, 1
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %11)
  %13 = icmp eq i32 %12, 6
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %11)
  %15 = tail call i8* @lua_getlocal(%struct.lua_State* %0, %struct.lua_Debug* null, i32 %10)
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %15)
  br label %30

; <label>:17:                                     ; preds = %1
  %18 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %11)
  %19 = trunc i64 %18 to i32
  %20 = call i32 @lua_getstack(%struct.lua_State* %5, i32 %19, %struct.lua_Debug* nonnull %3)
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %17
  %23 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %11, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0))
  br label %30

; <label>:24:                                     ; preds = %17
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1)
  %25 = call i8* @lua_getlocal(%struct.lua_State* %5, %struct.lua_Debug* nonnull %3, i32 %10)
  %26 = icmp eq i8* %25, null
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  call void @lua_xmove(%struct.lua_State* %5, %struct.lua_State* %0, i32 1)
  %28 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %25)
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %30

; <label>:29:                                     ; preds = %24
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %30

; <label>:30:                                     ; preds = %22, %27, %29, %14
  %31 = phi i32 [ 1, %14 ], [ 2, %27 ], [ 1, %29 ], [ %23, %22 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 %31
}

; Function Attrs: norecurse nounwind uwtable
define internal i32 @db_getregistry(%struct.lua_State* nocapture) #2 {
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1001000)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %5

; <label>:5:                                      ; preds = %1, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_getupvalue(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 1)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @db_upvaluejoin(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2)
  %3 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 3, i32 4)
  %4 = tail call i32 @lua_iscfunction(%struct.lua_State* %0, i32 1)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0))
  br label %8

; <label>:8:                                      ; preds = %1, %6
  %9 = tail call i32 @lua_iscfunction(%struct.lua_State* %0, i32 3)
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0))
  br label %13

; <label>:13:                                     ; preds = %8, %11
  tail call void @lua_upvaluejoin(%struct.lua_State* %0, i32 1, i32 %2, i32 3, i32 %3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @db_upvalueid(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2)
  %3 = tail call i8* @lua_upvalueid(%struct.lua_State* %0, i32 1, i32 %2)
  tail call void @lua_pushlightuserdata(%struct.lua_State* %0, i8* %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1)
  %3 = trunc i64 %2 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 7)
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2)
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %4 = tail call i32 @lua_setiuservalue(%struct.lua_State* %0, i32 1, i32 %3)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %7

; <label>:7:                                      ; preds = %1, %6
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_sethook(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2)
  %5 = load i32, i32* %2, align 4, !tbaa !70
  %6 = add nsw i32 %5, 1
  %7 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %6)
  %8 = icmp slt i32 %7, 1
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %6)
  br label %17

; <label>:10:                                     ; preds = %1
  %11 = add nsw i32 %5, 2
  %12 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %11, i64* null)
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %6, i32 6)
  %13 = add nsw i32 %5, 3
  %14 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 %13, i64 0)
  %15 = trunc i64 %14 to i32
  %16 = tail call fastcc i32 @makemask(i8* %12, i32 %15)
  br label %17

; <label>:17:                                     ; preds = %10, %9
  %18 = phi void (%struct.lua_State*, %struct.lua_Debug*)* [ null, %9 ], [ @hookf, %10 ]
  %19 = phi i32 [ 0, %9 ], [ %15, %10 ]
  %20 = phi i32 [ 0, %9 ], [ %16, %10 ]
  %21 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*))
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %17
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 2)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  tail call void @lua_rawsetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*))
  %24 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.403, i64 0, i64 0))
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i64 0, i64 0))
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  %25 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2)
  br label %26

; <label>:26:                                     ; preds = %23, %17
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %4, i32 1)
  %27 = tail call i32 @lua_pushthread(%struct.lua_State* %4)
  tail call void @lua_xmove(%struct.lua_State* %4, %struct.lua_State* %0, i32 1)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %6)
  tail call void @lua_rawset(%struct.lua_State* %0, i32 -3)
  tail call void @lua_sethook(%struct.lua_State* %4, void (%struct.lua_State*, %struct.lua_Debug*)* %18, i32 %20, i32 %19)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setlocal(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2)
  %6 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = load i32, i32* %2, align 4, !tbaa !70
  %8 = add nsw i32 %7, 1
  %9 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %8)
  %10 = trunc i64 %9 to i32
  %11 = add nsw i32 %7, 2
  %12 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %11)
  %13 = call i32 @lua_getstack(%struct.lua_State* %5, i32 %10, %struct.lua_Debug* nonnull %3)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %17

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %8, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0))
  br label %25

; <label>:17:                                     ; preds = %1
  %18 = trunc i64 %12 to i32
  %19 = add nsw i32 %7, 3
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 %19)
  tail call void @lua_settop(%struct.lua_State* %0, i32 %19)
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %5, i32 1)
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* %5, i32 1)
  %20 = call i8* @lua_setlocal(%struct.lua_State* %5, %struct.lua_Debug* nonnull %3, i32 %18)
  %21 = icmp eq i8* %20, null
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call void @lua_settop(%struct.lua_State* %5, i32 -2)
  br label %23

; <label>:23:                                     ; preds = %22, %17
  %24 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %20)
  br label %25

; <label>:25:                                     ; preds = %23, %15
  %26 = phi i32 [ 1, %23 ], [ %16, %15 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setmetatable(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  switch i32 %2, label %3 [
    i32 5, label %5
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %1
  %4 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0))
  br label %5

; <label>:5:                                      ; preds = %1, %1, %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %6 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 1)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @db_setupvalue(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3)
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 0)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @db_traceback(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call fastcc %struct.lua_State* @getthread(%struct.lua_State* %0, i32* nonnull %2)
  %5 = load i32, i32* %2, align 4, !tbaa !70
  %6 = add nsw i32 %5, 1
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %6, i64* null)
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %1
  %10 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %6)
  %11 = icmp slt i32 %10, 1
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %6)
  br label %19

; <label>:13:                                     ; preds = %9, %1
  %14 = add nsw i32 %5, 2
  %15 = icmp eq %struct.lua_State* %4, %0
  %16 = zext i1 %15 to i64
  %17 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 %14, i64 %16)
  %18 = trunc i64 %17 to i32
  tail call void @luaL_traceback(%struct.lua_State* %0, %struct.lua_State* %4, i8* %7, i32 %18)
  br label %19

; <label>:19:                                     ; preds = %13, %12
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind
declare i8* @fgets(i8*, i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: norecurse nounwind uwtable
define internal fastcc %struct.lua_State* @getthread(%struct.lua_State* readonly, i32* nocapture) unnamed_addr #2 {
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %4 = icmp eq i32 %3, 8
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  store i32 1, i32* %1, align 4, !tbaa !70
  %6 = tail call %struct.lua_State* @lua_tothread(%struct.lua_State* %0, i32 1)
  br label %8

; <label>:7:                                      ; preds = %2
  store i32 0, i32* %1, align 4, !tbaa !70
  br label %8

; <label>:8:                                      ; preds = %7, %5
  %9 = phi %struct.lua_State* [ %6, %5 ], [ %0, %7 ]
  ret %struct.lua_State* %9
}

; Function Attrs: nounwind uwtable
define internal void @hookf(%struct.lua_State*, %struct.lua_Debug* nocapture readonly) #0 {
  %3 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*))
  %4 = tail call i32 @lua_pushthread(%struct.lua_State* %0)
  %5 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2)
  %6 = icmp eq i32 %5, 6
  br i1 %6, label %7, label %21

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !238
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds [5 x i8*], [5 x i8*]* @hookf.hooknames, i64 0, i64 %10
  %12 = load i8*, i8** %11, align 8, !tbaa !79
  %13 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %12)
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 6
  %15 = load i32, i32* %14, align 8, !tbaa !90
  %16 = icmp sgt i32 %15, -1
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %7
  %18 = sext i32 %15 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %18)
  br label %20

; <label>:19:                                     ; preds = %7
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %20

; <label>:20:                                     ; preds = %19, %17
  tail call void @lua_callk(%struct.lua_State* %0, i32 2, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  br label %21

; <label>:21:                                     ; preds = %20, %2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkstack(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0))
  unreachable

; <label>:10:                                     ; preds = %5, %3
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @unmakemask(i32, i8* returned) unnamed_addr #2 {
  %3 = and i32 %0, 1
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %6, label %5

; <label>:5:                                      ; preds = %2
  store i8 99, i8* %1, align 1, !tbaa !21
  br label %6

; <label>:6:                                      ; preds = %2, %5
  %7 = phi i32 [ 1, %5 ], [ 0, %2 ]
  %8 = and i32 %0, 2
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %6
  %11 = add nuw nsw i32 %7, 1
  %12 = zext i32 %7 to i64
  %13 = getelementptr inbounds i8, i8* %1, i64 %12
  store i8 114, i8* %13, align 1, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %6, %10
  %15 = phi i32 [ %11, %10 ], [ %7, %6 ]
  %16 = and i32 %0, 4
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %22, label %18

; <label>:18:                                     ; preds = %14
  %19 = add nsw i32 %15, 1
  %20 = sext i32 %15 to i64
  %21 = getelementptr inbounds i8, i8* %1, i64 %20
  store i8 108, i8* %21, align 1, !tbaa !21
  br label %22

; <label>:22:                                     ; preds = %14, %18
  %23 = phi i32 [ %19, %18 ], [ %15, %14 ]
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds i8, i8* %1, i64 %24
  store i8 0, i8* %25, align 1, !tbaa !21
  ret i8* %1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @settabss(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @settabsi(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = sext i32 %2 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %4)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @settabsb(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %2)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @treatstackoption(%struct.lua_State*, %struct.lua_State*, i8*) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %3
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %7

; <label>:6:                                      ; preds = %3
  tail call void @lua_xmove(%struct.lua_State* %1, %struct.lua_State* %0, i32 1)
  br label %7

; <label>:7:                                      ; preds = %6, %5
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @auxupvalue(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %4 = trunc i64 %3 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  %5 = icmp eq i32 %1, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %2
  %7 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 1, i32 %4)
  br label %10

; <label>:8:                                      ; preds = %2
  %9 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 1, i32 %4)
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  %12 = icmp eq i8* %11, null
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %10
  %14 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11)
  %15 = add nsw i32 %1, 1
  %16 = xor i32 %1, -1
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 1)
  br label %17

; <label>:17:                                     ; preds = %10, %13
  %18 = phi i32 [ %15, %13 ], [ 0, %10 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @checkupval(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %2)
  %5 = trunc i64 %4 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 6)
  %6 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 %1, i32 %5)
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.402, i64 0, i64 0))
  br label %10

; <label>:10:                                     ; preds = %3, %8
  ret i32 %5
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @makemask(i8* readonly, i32) unnamed_addr #14 {
  %3 = tail call i8* @strchr(i8* %0, i32 99) #19
  %4 = icmp ne i8* %3, null
  %5 = zext i1 %4 to i32
  %6 = tail call i8* @strchr(i8* %0, i32 114) #19
  %7 = icmp eq i8* %6, null
  %8 = or i32 %5, 2
  %9 = select i1 %7, i32 %5, i32 %8
  %10 = tail call i8* @strchr(i8* %0, i32 108) #19
  %11 = icmp eq i8* %10, null
  %12 = or i32 %9, 4
  %13 = select i1 %11, i32 %9, i32 %12
  %14 = icmp sgt i32 %1, 0
  %15 = or i32 %13, 8
  %16 = select i1 %14, i32 %15, i32 %13
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @io_close(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0))
  br label %6

; <label>:6:                                      ; preds = %4, %1
  %7 = tail call i32 @f_close(%struct.lua_State* %0)
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @io_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0))
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2)
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null)
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @io_input(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_lines(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, -1
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %5

; <label>:5:                                      ; preds = %4, %1
  %6 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %11

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0))
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %10 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 0)
  br label %13

; <label>:11:                                     ; preds = %5
  %12 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  tail call fastcc void @opencheck(%struct.lua_State* %0, i8* %12, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0))
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  br label %13

; <label>:13:                                     ; preds = %8, %11
  %14 = phi i32 [ 4, %11 ], [ 1, %8 ]
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @io_open(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null)
  %4 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0)
  %5 = tail call fastcc i32 @l_checkmode(i8* %3)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.421, i64 0, i64 0))
  br label %9

; <label>:9:                                      ; preds = %1, %7
  %10 = tail call %struct._IO_FILE* @fopen64(i8* %2, i8* %3)
  %11 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %4, i64 0, i32 0
  store %struct._IO_FILE* %10, %struct._IO_FILE** %11, align 8, !tbaa !194
  %12 = icmp eq %struct._IO_FILE* %10, null
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %9
  %14 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* %2)
  br label %15

; <label>:15:                                     ; preds = %9, %13
  %16 = phi i32 [ %14, %13 ], [ 1, %9 ]
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @io_output(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.424, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: noreturn nounwind uwtable
define internal i32 @io_popen(%struct.lua_State*) #5 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null)
  %4 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0)
  %5 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.425, i64 0, i64 0))
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @io_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0))
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @io_tmpfile(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0)
  %3 = tail call %struct._IO_FILE* @tmpfile64()
  %4 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 0
  store %struct._IO_FILE* %3, %struct._IO_FILE** %4, align 8, !tbaa !194
  %5 = icmp eq %struct._IO_FILE* %3, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null)
  br label %8

; <label>:8:                                      ; preds = %1, %6
  %9 = phi i32 [ %7, %6 ], [ 1, %1 ]
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @io_type(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  %2 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %14

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds i8, i8* %2, i64 8
  %7 = bitcast i8* %6 to i32 (%struct.lua_State*)**
  %8 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %7, align 8, !tbaa !196
  %9 = icmp eq i32 (%struct.lua_State*)* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %5
  %11 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.426, i64 0, i64 0))
  br label %14

; <label>:12:                                     ; preds = %5
  %13 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.427, i64 0, i64 0))
  br label %14

; <label>:14:                                     ; preds = %10, %12, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @io_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0))
  %3 = tail call fastcc i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @f_close(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %3 = tail call fastcc i32 @aux_close(%struct.lua_State* %0)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct._IO_FILE* @tofile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !196
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.412, i64 0, i64 0))
  unreachable

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !194
  ret %struct._IO_FILE* %11
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @aux_close(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4)
  %5 = getelementptr inbounds i8, i8* %3, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = bitcast i8* %5 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !196
  store volatile i64 %8, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %6, align 8, !tbaa !196
  %9 = load volatile i64, i64* %2, align 8
  %10 = inttoptr i64 %9 to i32 (%struct.lua_State*)*
  %11 = tail call i32 %10(%struct.lua_State* %0) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4)
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal fastcc %struct._IO_FILE* @getiofile(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1)
  %5 = getelementptr inbounds i8, i8* %4, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %6, align 8, !tbaa !196
  %8 = icmp eq i32 (%struct.lua_State*)* %7, null
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds i8, i8* %1, i64 4
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.413, i64 0, i64 0), i8* nonnull %10)
  unreachable

; <label>:12:                                     ; preds = %2
  %13 = bitcast i8* %4 to %struct._IO_FILE**
  %14 = load %struct._IO_FILE*, %struct._IO_FILE** %13, align 8, !tbaa !194
  ret %struct._IO_FILE* %14
}

; Function Attrs: nounwind uwtable
define internal fastcc void @g_iofile(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %5 = icmp slt i32 %4, 1
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  %8 = icmp eq i8* %7, null
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %6
  tail call fastcc void @opencheck(%struct.lua_State* %0, i8* nonnull %7, i8* %2)
  br label %12

; <label>:10:                                     ; preds = %6
  %11 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  br label %12

; <label>:12:                                     ; preds = %10, %9
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  br label %13

; <label>:13:                                     ; preds = %12, %3
  %14 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @opencheck(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc %struct.luaL_Stream* @newfile(%struct.lua_State* %0)
  %5 = tail call %struct._IO_FILE* @fopen64(i8* %1, i8* %2)
  %6 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %4, i64 0, i32 0
  store %struct._IO_FILE* %5, %struct._IO_FILE** %6, align 8, !tbaa !194
  %7 = icmp eq %struct._IO_FILE* %5, null
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %3
  %9 = tail call i32* @__errno_location() #21
  %10 = load i32, i32* %9, align 4, !tbaa !70
  %11 = tail call i8* @strerror(i32 %10) #7
  %12 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.414, i64 0, i64 0), i8* %1, i8* %11)
  unreachable

; <label>:13:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc nonnull %struct.luaL_Stream* @newfile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0)
  %3 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 0
  store %struct._IO_FILE* null, %struct._IO_FILE** %3, align 8, !tbaa !194
  %4 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %2, i64 0, i32 1
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !196
  ret %struct.luaL_Stream* %2
}

; Function Attrs: nounwind uwtable
define internal fastcc nonnull %struct.luaL_Stream* @newprefile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0)
  %3 = bitcast i8* %2 to %struct.luaL_Stream*
  %4 = getelementptr inbounds i8, i8* %2, i64 8
  %5 = bitcast i8* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %5, align 8, !tbaa !196
  tail call void @luaL_setmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  ret %struct.luaL_Stream* %3
}

; Function Attrs: nounwind uwtable
define internal i32 @io_fclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = bitcast i8* %2 to %struct._IO_FILE**
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** %3, align 8, !tbaa !194
  %5 = tail call i32 @fclose(%struct._IO_FILE* %4)
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  %8 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %7, i8* null)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc void @aux_lines(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = add nsw i32 %3, -1
  %5 = icmp slt i32 %3, 252
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %2
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 252, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0))
  br label %8

; <label>:8:                                      ; preds = %6, %2
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  %9 = sext i32 %4 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %9)
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 2, i32 3)
  %10 = add nsw i32 %3, 2
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @io_readline, i32 %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @io_readline(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001)
  %3 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1001002, i32* null)
  %4 = trunc i64 %3 to i32
  %5 = getelementptr inbounds i8, i8* %2, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %6, align 8, !tbaa !196
  %8 = icmp eq i32 (%struct.lua_State*)* %7, null
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %1
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.416, i64 0, i64 0))
  unreachable

; <label>:11:                                     ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0))
  %12 = icmp slt i32 %4, 1
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %11
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i32 [ %17, %14 ], [ 1, %13 ]
  %16 = sub nuw i32 -1001003, %15
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %16)
  %17 = add nuw nsw i32 %15, 1
  %18 = icmp eq i32 %15, %4
  br i1 %18, label %19, label %14

; <label>:19:                                     ; preds = %14, %11
  %20 = bitcast i8* %2 to %struct._IO_FILE**
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** %20, align 8, !tbaa !194
  %22 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %21, i32 2)
  %23 = sub nsw i32 0, %22
  %24 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 %23)
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %37

; <label>:26:                                     ; preds = %19
  %27 = icmp sgt i32 %22, 1
  br i1 %27, label %28, label %32

; <label>:28:                                     ; preds = %26
  %29 = sub i32 1, %22
  %30 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %29, i64* null)
  %31 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* %30)
  unreachable

; <label>:32:                                     ; preds = %26
  %33 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1001003)
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %37, label %35

; <label>:35:                                     ; preds = %32
  tail call void @lua_settop(%struct.lua_State* %0, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1001001)
  %36 = tail call fastcc i32 @aux_close(%struct.lua_State* %0)
  br label %37

; <label>:37:                                     ; preds = %35, %32, %19
  %38 = phi i32 [ %22, %19 ], [ 0, %32 ], [ 0, %35 ]
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @g_read(%struct.lua_State*, %struct._IO_FILE*, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  tail call void @clearerr(%struct._IO_FILE* %1) #7
  %5 = icmp eq i32 %4, 1
  br i1 %5, label %6, label %9

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 1)
  %8 = add nsw i32 %2, 1
  br label %48

; <label>:9:                                      ; preds = %3
  %10 = add nsw i32 %4, 19
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %10, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0))
  %11 = add nsw i32 %4, -2
  br label %12

; <label>:12:                                     ; preds = %9, %41
  %13 = phi i32 [ %11, %9 ], [ %44, %41 ]
  %14 = phi i32 [ %2, %9 ], [ %43, %41 ]
  %15 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %14)
  %16 = icmp eq i32 %15, 3
  br i1 %16, label %17, label %24

; <label>:17:                                     ; preds = %12
  %18 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %14)
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %17
  %21 = tail call fastcc i32 @test_eof(%struct.lua_State* %0, %struct._IO_FILE* %1)
  br label %41

; <label>:22:                                     ; preds = %17
  %23 = tail call fastcc i32 @read_chars(%struct.lua_State* %0, %struct._IO_FILE* %1, i64 %18)
  br label %41

; <label>:24:                                     ; preds = %12
  %25 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %14, i64* null)
  %26 = load i8, i8* %25, align 1, !tbaa !21
  %27 = icmp eq i8 %26, 42
  %28 = getelementptr inbounds i8, i8* %25, i64 1
  %29 = select i1 %27, i8* %28, i8* %25
  %30 = load i8, i8* %29, align 1, !tbaa !21
  %31 = sext i8 %30 to i32
  switch i32 %31, label %39 [
    i32 110, label %32
    i32 108, label %34
    i32 76, label %36
    i32 97, label %38
  ]

; <label>:32:                                     ; preds = %24
  %33 = tail call fastcc i32 @read_number(%struct.lua_State* %0, %struct._IO_FILE* %1)
  br label %41

; <label>:34:                                     ; preds = %24
  %35 = tail call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 1)
  br label %41

; <label>:36:                                     ; preds = %24
  %37 = tail call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 0)
  br label %41

; <label>:38:                                     ; preds = %24
  tail call fastcc void @read_all(%struct.lua_State* %0, %struct._IO_FILE* %1)
  br label %41

; <label>:39:                                     ; preds = %24
  %40 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %14, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.417, i64 0, i64 0))
  br label %60

; <label>:41:                                     ; preds = %32, %34, %36, %38, %20, %22
  %42 = phi i32 [ %21, %20 ], [ %23, %22 ], [ %33, %32 ], [ %35, %34 ], [ %37, %36 ], [ 1, %38 ]
  %43 = add nsw i32 %14, 1
  %44 = add nsw i32 %13, -1
  %45 = icmp ne i32 %13, 0
  %46 = icmp ne i32 %42, 0
  %47 = and i1 %45, %46
  br i1 %47, label %12, label %48

; <label>:48:                                     ; preds = %41, %6
  %49 = phi i32 [ %8, %6 ], [ %43, %41 ]
  %50 = phi i32 [ %7, %6 ], [ %42, %41 ]
  %51 = tail call i32 @ferror(%struct._IO_FILE* %1) #7
  %52 = icmp eq i32 %51, 0
  br i1 %52, label %55, label %53

; <label>:53:                                     ; preds = %48
  %54 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null)
  br label %60

; <label>:55:                                     ; preds = %48
  %56 = icmp eq i32 %50, 0
  br i1 %56, label %57, label %58

; <label>:57:                                     ; preds = %55
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %58

; <label>:58:                                     ; preds = %55, %57
  %59 = sub nsw i32 %49, %2
  br label %60

; <label>:60:                                     ; preds = %39, %58, %53
  %61 = phi i32 [ %54, %53 ], [ %59, %58 ], [ %40, %39 ]
  ret i32 %61
}

; Function Attrs: nounwind
declare void @clearerr(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_line(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %4)
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  br label %7

; <label>:7:                                      ; preds = %23, %3
  %8 = phi i32 [ 0, %3 ], [ %14, %23 ]
  switch i32 %8, label %9 [
    i32 -1, label %28
    i32 10, label %28
  ]

; <label>:9:                                      ; preds = %7
  %10 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1024)
  br label %11

; <label>:11:                                     ; preds = %9, %15
  %12 = phi i64 [ 0, %9 ], [ %17, %15 ]
  %13 = phi i32 [ 0, %9 ], [ %18, %15 ]
  %14 = call i32 @_IO_getc(%struct._IO_FILE* %1)
  switch i32 %14, label %15 [
    i32 -1, label %21
    i32 10, label %21
  ]

; <label>:15:                                     ; preds = %11
  %16 = trunc i32 %14 to i8
  %17 = add nuw nsw i64 %12, 1
  %18 = add nuw nsw i32 %13, 1
  %19 = getelementptr inbounds i8, i8* %10, i64 %12
  store i8 %16, i8* %19, align 1, !tbaa !21
  %20 = icmp ult i64 %17, 1024
  br i1 %20, label %11, label %23

; <label>:21:                                     ; preds = %11, %11
  %22 = trunc i64 %12 to i32
  br label %23

; <label>:23:                                     ; preds = %15, %21
  %24 = phi i32 [ %22, %21 ], [ %18, %15 ]
  %25 = zext i32 %24 to i64
  %26 = load i64, i64* %6, align 8, !tbaa !182
  %27 = add i64 %26, %25
  store i64 %27, i64* %6, align 8, !tbaa !182
  br label %7

; <label>:28:                                     ; preds = %7, %7
  %29 = icmp eq i32 %2, 0
  %30 = icmp eq i32 %8, 10
  %31 = and i1 %29, %30
  br i1 %31, label %32, label %47

; <label>:32:                                     ; preds = %28
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %34 = load i64, i64* %33, align 8, !tbaa !182
  %35 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %36 = load i64, i64* %35, align 8, !tbaa !180
  %37 = icmp ult i64 %34, %36
  br i1 %37, label %40, label %38

; <label>:38:                                     ; preds = %32
  %39 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1)
  br label %40

; <label>:40:                                     ; preds = %38, %32
  %41 = trunc i32 %8 to i8
  %42 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 0
  %43 = load i8*, i8** %42, align 8, !tbaa !183
  %44 = load i64, i64* %33, align 8, !tbaa !182
  %45 = add i64 %44, 1
  store i64 %45, i64* %33, align 8, !tbaa !182
  %46 = getelementptr inbounds i8, i8* %43, i64 %44
  store i8 %41, i8* %46, align 1, !tbaa !21
  br label %47

; <label>:47:                                     ; preds = %28, %40
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4)
  br i1 %30, label %52, label %48

; <label>:48:                                     ; preds = %47
  %49 = call i64 @lua_rawlen(%struct.lua_State* %0, i32 -1)
  %50 = icmp ne i64 %49, 0
  %51 = zext i1 %50 to i32
  br label %52

; <label>:52:                                     ; preds = %48, %47
  %53 = phi i32 [ 1, %47 ], [ %51, %48 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @test_eof(%struct.lua_State*, %struct._IO_FILE* nocapture) unnamed_addr #0 {
  %3 = tail call i32 @_IO_getc(%struct._IO_FILE* %1)
  %4 = tail call i32 @ungetc(i32 %3, %struct._IO_FILE* %1)
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  %6 = icmp ne i32 %3, -1
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_chars(%struct.lua_State*, %struct._IO_FILE* nocapture, i64) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %4)
  %6 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 %2)
  %7 = call i64 @fread(i8* %6, i64 1, i64 %2, %struct._IO_FILE* %1)
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %9 = load i64, i64* %8, align 8, !tbaa !182
  %10 = add i64 %9, %7
  store i64 %10, i64* %8, align 8, !tbaa !182
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4)
  %11 = icmp ne i64 %7, 0
  %12 = zext i1 %11 to i32
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @read_number(%struct.lua_State* nocapture, %struct._IO_FILE*) unnamed_addr #0 {
  %3 = alloca %struct.RN, align 8
  %4 = alloca [2 x i8], align 1
  %5 = bitcast %struct.RN* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 224, i8* nonnull %5) #7
  %6 = getelementptr inbounds [2 x i8], [2 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 2, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 0
  store %struct._IO_FILE* %1, %struct._IO_FILE** %7, align 8, !tbaa !333
  %8 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 2
  store i32 0, i32* %8, align 4, !tbaa !335
  %9 = tail call %struct.lconv* @localeconv() #7
  %10 = getelementptr inbounds %struct.lconv, %struct.lconv* %9, i64 0, i32 0
  %11 = load i8*, i8** %10, align 8, !tbaa !239
  %12 = load i8, i8* %11, align 1, !tbaa !21
  store i8 %12, i8* %6, align 1, !tbaa !21
  %13 = getelementptr inbounds [2 x i8], [2 x i8]* %4, i64 0, i64 1
  store i8 46, i8* %13, align 1, !tbaa !21
  br label %14

; <label>:14:                                     ; preds = %14, %2
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %7, align 8, !tbaa !333
  %16 = tail call i32 @_IO_getc(%struct._IO_FILE* %15)
  %17 = tail call i16** @__ctype_b_loc() #21
  %18 = load i16*, i16** %17, align 8, !tbaa !79
  %19 = sext i32 %16 to i64
  %20 = getelementptr inbounds i16, i16* %18, i64 %19
  %21 = load i16, i16* %20, align 2, !tbaa !312
  %22 = and i16 %21, 8192
  %23 = icmp eq i16 %22, 0
  br i1 %23, label %24, label %14

; <label>:24:                                     ; preds = %14
  %25 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 1
  store i32 %16, i32* %25, align 8, !tbaa !336
  %26 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 1
  %27 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0))
  %28 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.418, i64 0, i64 0))
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %36, label %30

; <label>:30:                                     ; preds = %24
  %31 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.246, i64 0, i64 0))
  %32 = icmp eq i32 %31, 0
  %33 = zext i1 %32 to i32
  %34 = xor i1 %32, true
  %35 = zext i1 %34 to i32
  br label %36

; <label>:36:                                     ; preds = %30, %24
  %37 = phi i32 [ 0, %24 ], [ %33, %30 ]
  %38 = phi i32 [ 0, %24 ], [ %35, %30 ]
  %39 = call fastcc i32 @readdigits(%struct.RN* nonnull %3, i32 %38)
  %40 = add nsw i32 %39, %37
  %41 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* nonnull %6)
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %46, label %43

; <label>:43:                                     ; preds = %36
  %44 = call fastcc i32 @readdigits(%struct.RN* nonnull %3, i32 %38)
  %45 = add nsw i32 %44, %40
  br label %46

; <label>:46:                                     ; preds = %36, %43
  %47 = phi i32 [ %45, %43 ], [ %40, %36 ]
  %48 = icmp sgt i32 %47, 0
  br i1 %48, label %49, label %57

; <label>:49:                                     ; preds = %46
  %50 = icmp eq i32 %38, 0
  %51 = select i1 %50, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.420, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.419, i64 0, i64 0)
  %52 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* %51)
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %57, label %54

; <label>:54:                                     ; preds = %49
  %55 = call fastcc i32 @test2(%struct.RN* nonnull %3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0))
  %56 = call fastcc i32 @readdigits(%struct.RN* nonnull %3, i32 0)
  br label %57

; <label>:57:                                     ; preds = %49, %54, %46
  %58 = load i32, i32* %26, align 8, !tbaa !336
  %59 = load %struct._IO_FILE*, %struct._IO_FILE** %7, align 8, !tbaa !333
  %60 = tail call i32 @ungetc(i32 %58, %struct._IO_FILE* %59)
  %61 = load i32, i32* %8, align 4, !tbaa !335
  %62 = sext i32 %61 to i64
  %63 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 3, i64 %62
  store i8 0, i8* %63, align 1, !tbaa !21
  %64 = getelementptr inbounds %struct.RN, %struct.RN* %3, i64 0, i32 3, i64 0
  %65 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %64)
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %67, label %68

; <label>:67:                                     ; preds = %57
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %68

; <label>:68:                                     ; preds = %57, %67
  %69 = phi i32 [ 0, %67 ], [ 1, %57 ]
  call void @llvm.lifetime.end.p0i8(i64 2, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 224, i8* nonnull %5) #7
  ret i32 %69
}

; Function Attrs: nounwind uwtable
define internal fastcc void @read_all(%struct.lua_State*, %struct._IO_FILE* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3)
  %5 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  br label %6

; <label>:6:                                      ; preds = %6, %2
  %7 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 1024)
  %8 = call i64 @fread(i8* %7, i64 1, i64 1024, %struct._IO_FILE* %1)
  %9 = load i64, i64* %5, align 8, !tbaa !182
  %10 = add i64 %9, %8
  store i64 %10, i64* %5, align 8, !tbaa !182
  %11 = icmp eq i64 %8, 1024
  br i1 %11, label %6, label %12

; <label>:12:                                     ; preds = %6
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind
declare i32 @ungetc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @test2(%struct.RN* nocapture, i8* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  %4 = load i32, i32* %3, align 8, !tbaa !336
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %13, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds i8, i8* %1, i64 1
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %4, %11
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %8, %2
  %14 = tail call fastcc i32 @nextc(%struct.RN* nonnull %0)
  br label %15

; <label>:15:                                     ; preds = %8, %13
  %16 = phi i32 [ %14, %13 ], [ 0, %8 ]
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @readdigits(%struct.RN* nocapture, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  %4 = tail call i16** @__ctype_b_loc() #21
  %5 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  br label %6

; <label>:6:                                      ; preds = %23, %2
  %7 = phi i32 [ 0, %2 ], [ %24, %23 ]
  %8 = load i16*, i16** %4, align 8, !tbaa !79
  %9 = load i32, i32* %5, align 8, !tbaa !336
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i16, i16* %8, i64 %10
  %12 = load i16, i16* %11, align 2, !tbaa !312
  %13 = zext i16 %12 to i32
  br i1 %3, label %17, label %14

; <label>:14:                                     ; preds = %6
  %15 = and i32 %13, 4096
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %25, label %20

; <label>:17:                                     ; preds = %6
  %18 = and i32 %13, 2048
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %14, %17
  %21 = tail call fastcc i32 @nextc(%struct.RN* nonnull %0)
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %20
  %24 = add nuw nsw i32 %7, 1
  br label %6

; <label>:25:                                     ; preds = %20, %14, %17
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @nextc(%struct.RN* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 2
  %3 = load i32, i32* %2, align 4, !tbaa !335
  %4 = icmp sgt i32 %3, 199
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 0
  store i8 0, i8* %6, align 8, !tbaa !21
  br label %17

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 8, !tbaa !336
  %10 = trunc i32 %9 to i8
  %11 = add nsw i32 %3, 1
  store i32 %11, i32* %2, align 4, !tbaa !335
  %12 = sext i32 %3 to i64
  %13 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 %12
  store i8 %10, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 0
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %14, align 8, !tbaa !333
  %16 = tail call i32 @_IO_getc(%struct._IO_FILE* %15)
  store i32 %16, i32* %8, align 8, !tbaa !336
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ 0, %5 ], [ 1, %7 ]
  ret i32 %18
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @l_checkmode(i8* nocapture readonly) unnamed_addr #14 {
  %2 = load i8, i8* %0, align 1, !tbaa !21
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %18, label %4

; <label>:4:                                      ; preds = %1
  %5 = sext i8 %2 to i32
  %6 = getelementptr inbounds i8, i8* %0, i64 1
  %7 = tail call i8* @memchr(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.422, i64 0, i64 0), i32 %5, i64 4)
  %8 = icmp eq i8* %7, null
  br i1 %8, label %18, label %9

; <label>:9:                                      ; preds = %4
  %10 = load i8, i8* %6, align 1, !tbaa !21
  %11 = icmp eq i8 %10, 43
  %12 = getelementptr inbounds i8, i8* %0, i64 2
  %13 = select i1 %11, i8* %12, i8* %6
  %14 = tail call i64 @strspn(i8* nonnull %13, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.423, i64 0, i64 0)) #19
  %15 = tail call i64 @strlen(i8* nonnull %13) #19
  %16 = icmp eq i64 %14, %15
  %17 = zext i1 %16 to i32
  br label %18

; <label>:18:                                     ; preds = %4, %1, %9
  %19 = phi i32 [ 0, %4 ], [ 0, %1 ], [ %17, %9 ]
  ret i32 %19
}

; Function Attrs: nounwind
declare noalias %struct._IO_FILE* @tmpfile64() local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @g_write(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %6 = sub nsw i32 %5, %2
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %49, label %8

; <label>:8:                                      ; preds = %3
  %9 = bitcast i64* %4 to i8*
  br label %10

; <label>:10:                                     ; preds = %8, %41
  %11 = phi i32 [ %6, %8 ], [ %14, %41 ]
  %12 = phi i32 [ %2, %8 ], [ %44, %41 ]
  %13 = phi i32 [ 1, %8 ], [ %43, %41 ]
  %14 = add nsw i32 %11, -1
  %15 = call i32 @lua_type(%struct.lua_State* %0, i32 %12)
  %16 = icmp eq i32 %15, 3
  br i1 %16, label %17, label %31

; <label>:17:                                     ; preds = %10
  %18 = call i32 @lua_isinteger(%struct.lua_State* %0, i32 %12)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %23, label %20

; <label>:20:                                     ; preds = %17
  %21 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %12, i32* null)
  %22 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %21)
  br label %26

; <label>:23:                                     ; preds = %17
  %24 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %12, i32* null)
  %25 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %24)
  br label %26

; <label>:26:                                     ; preds = %23, %20
  %27 = phi i32 [ %22, %20 ], [ %25, %23 ]
  %28 = icmp ne i32 %13, 0
  %29 = icmp sgt i32 %27, 0
  %30 = and i1 %28, %29
  br label %41

; <label>:31:                                     ; preds = %10
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %32 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %12, i64* nonnull %4)
  %33 = icmp eq i32 %13, 0
  br i1 %33, label %39, label %34

; <label>:34:                                     ; preds = %31
  %35 = load i64, i64* %4, align 8, !tbaa !113
  %36 = call i64 @fwrite(i8* %32, i64 1, i64 %35, %struct._IO_FILE* %1)
  %37 = load i64, i64* %4, align 8, !tbaa !113
  %38 = icmp eq i64 %36, %37
  br label %39

; <label>:39:                                     ; preds = %31, %34
  %40 = phi i1 [ false, %31 ], [ %38, %34 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  br label %41

; <label>:41:                                     ; preds = %26, %39
  %42 = phi i1 [ %30, %26 ], [ %40, %39 ]
  %43 = zext i1 %42 to i32
  %44 = add nsw i32 %12, 1
  %45 = icmp eq i32 %14, 0
  br i1 %45, label %46, label %10

; <label>:46:                                     ; preds = %41
  br i1 %42, label %49, label %47

; <label>:47:                                     ; preds = %46
  %48 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %43, i8* null)
  br label %49

; <label>:49:                                     ; preds = %46, %3, %47
  %50 = phi i32 [ %48, %47 ], [ 1, %46 ], [ 1, %3 ]
  ret i32 %50
}

; Function Attrs: nounwind uwtable
define internal i32 @f_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2)
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null)
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @f_lines(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 0)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @f_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 2)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @f_seek(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i64 0, i64 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_seek.modenames, i64 0, i64 0))
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0)
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_seek.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !70
  %8 = tail call i32 @fseek(%struct._IO_FILE* %2, i64 %4, i32 %7)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %1
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null)
  br label %14

; <label>:12:                                     ; preds = %1
  %13 = tail call i64 @ftell(%struct._IO_FILE* %2)
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %13)
  br label %14

; <label>:14:                                     ; preds = %12, %10
  %15 = phi i32 [ %11, %10 ], [ 1, %12 ]
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @f_setvbuf(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* null, i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_setvbuf.modenames, i64 0, i64 0))
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1024)
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_setvbuf.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !70
  %8 = tail call i32 @setvbuf(%struct._IO_FILE* %2, i8* null, i32 %7, i64 %4) #7
  %9 = icmp eq i32 %8, 0
  %10 = zext i1 %9 to i32
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %10, i8* null)
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @f_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  %3 = tail call fastcc i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 2)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @f_gc(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !196
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %13, label %7

; <label>:7:                                      ; preds = %1
  %8 = bitcast i8* %2 to %struct._IO_FILE**
  %9 = load %struct._IO_FILE*, %struct._IO_FILE** %8, align 8, !tbaa !194
  %10 = icmp eq %struct._IO_FILE* %9, null
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %7
  %12 = tail call fastcc i32 @aux_close(%struct.lua_State* %0)
  br label %13

; <label>:13:                                     ; preds = %7, %11, %1
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @f_tostring(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !196
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.435, i64 0, i64 0))
  br label %13

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !194
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.436, i64 0, i64 0), %struct._IO_FILE* %11)
  br label %13

; <label>:13:                                     ; preds = %9, %7
  ret i32 1
}

; Function Attrs: nounwind
declare i32 @fseek(%struct._IO_FILE* nocapture, i64, i32) local_unnamed_addr #9

; Function Attrs: nounwind
declare i64 @ftell(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @setvbuf(%struct._IO_FILE* nocapture, i8*, i32, i64) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal i32 @io_noclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0))
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !196
  tail call void @lua_pushnil(%struct.lua_State* %0)
  %5 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.437, i64 0, i64 0))
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @math_abs(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %9, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null)
  %6 = icmp slt i64 %5, 0
  %7 = sub i64 0, %5
  %8 = select i1 %6, i64 %7, i64 %5
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %8)
  br label %12

; <label>:9:                                      ; preds = %1
  %10 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %11 = tail call double @llvm.fabs.f64(double %10)
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %11)
  br label %12

; <label>:12:                                     ; preds = %9, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_acos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @acos(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_asin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @asin(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_atan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @luaL_optnumber(%struct.lua_State* %0, i32 2, double 1.000000e+00)
  %4 = tail call double @atan2(double %2, double %3) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %4)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_ceil(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  br label %8

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %7 = tail call double @llvm.ceil.f64(double %6)
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %7)
  br label %8

; <label>:8:                                      ; preds = %5, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_cos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @cos(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_deg(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = fmul double %2, 0x404CA5DC1A63C1F8
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_exp(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @exp(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_toint(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* nonnull %2)
  %5 = load i32, i32* %2, align 4, !tbaa !70
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %8, label %7

; <label>:7:                                      ; preds = %1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %4)
  br label %9

; <label>:8:                                      ; preds = %1
  call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %9

; <label>:9:                                      ; preds = %8, %7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_floor(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  br label %8

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %7 = tail call double @llvm.floor.f64(double %6)
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %7)
  br label %8

; <label>:8:                                      ; preds = %5, %4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_fmod(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %19, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 2)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %19, label %7

; <label>:7:                                      ; preds = %4
  %8 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 2, i32* null)
  %9 = add i64 %8, 1
  %10 = icmp ult i64 %9, 2
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %7
  %12 = icmp eq i64 %8, 0
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.460, i64 0, i64 0))
  br label %15

; <label>:15:                                     ; preds = %11, %13
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 0)
  br label %23

; <label>:16:                                     ; preds = %7
  %17 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null)
  %18 = srem i64 %17, %8
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %18)
  br label %23

; <label>:19:                                     ; preds = %4, %1
  %20 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %21 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 2)
  %22 = tail call double @fmod(double %20, double %21) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %22)
  br label %23

; <label>:23:                                     ; preds = %15, %16, %19
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_ult(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1)
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %4 = icmp ult i64 %2, %3
  %5 = zext i1 %4 to i32
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %5)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_log(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call double @log(double %2) #7
  br label %20

; <label>:7:                                      ; preds = %1
  %8 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 2)
  %9 = fcmp oeq double %8, 2.000000e+00
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %7
  %11 = tail call double @log2(double %2) #7
  br label %20

; <label>:12:                                     ; preds = %7
  %13 = fcmp oeq double %8, 1.000000e+01
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %12
  %15 = tail call double @log10(double %2) #7
  br label %20

; <label>:16:                                     ; preds = %12
  %17 = tail call double @log(double %2) #7
  %18 = tail call double @log(double %8) #7
  %19 = fdiv double %17, %18
  br label %20

; <label>:20:                                     ; preds = %10, %16, %14, %5
  %21 = phi double [ %6, %5 ], [ %11, %10 ], [ %15, %14 ], [ %19, %16 ]
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %21)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_max(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = icmp sgt i32 %2, 0
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0))
  br label %17

; <label>:6:                                      ; preds = %1
  %7 = icmp eq i32 %2, 1
  br i1 %7, label %17, label %8

; <label>:8:                                      ; preds = %6
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i32 [ %15, %9 ], [ 2, %8 ]
  %11 = phi i32 [ %14, %9 ], [ 1, %8 ]
  %12 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %11, i32 %10, i32 1)
  %13 = icmp eq i32 %12, 0
  %14 = select i1 %13, i32 %11, i32 %10
  %15 = add nuw nsw i32 %10, 1
  %16 = icmp eq i32 %10, %2
  br i1 %16, label %17, label %9

; <label>:17:                                     ; preds = %9, %4, %6
  %18 = phi i32 [ 1, %6 ], [ 1, %4 ], [ %14, %9 ]
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %18)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_min(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = icmp sgt i32 %2, 0
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0))
  br label %17

; <label>:6:                                      ; preds = %1
  %7 = icmp eq i32 %2, 1
  br i1 %7, label %17, label %8

; <label>:8:                                      ; preds = %6
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i32 [ %15, %9 ], [ 2, %8 ]
  %11 = phi i32 [ %14, %9 ], [ 1, %8 ]
  %12 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %10, i32 %11, i32 1)
  %13 = icmp eq i32 %12, 0
  %14 = select i1 %13, i32 %11, i32 %10
  %15 = add nuw nsw i32 %10, 1
  %16 = icmp eq i32 %10, %2
  br i1 %16, label %17, label %9

; <label>:17:                                     ; preds = %9, %4, %6
  %18 = phi i32 [ 1, %6 ], [ 1, %4 ], [ %14, %9 ]
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %18)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_modf(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushnumber(%struct.lua_State* %0, double 0.000000e+00)
  br label %14

; <label>:5:                                      ; preds = %1
  %6 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %7 = fcmp olt double %6, 0.000000e+00
  %8 = tail call double @llvm.ceil.f64(double %6)
  %9 = tail call double @llvm.floor.f64(double %6)
  %10 = select i1 %7, double %8, double %9
  tail call fastcc void @pushnumint(%struct.lua_State* %0, double %10)
  %11 = fcmp oeq double %6, %10
  %12 = fsub double %6, %10
  %13 = select i1 %11, double 0.000000e+00, double %12
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %13)
  br label %14

; <label>:14:                                     ; preds = %5, %4
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @math_rad(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = fmul double %2, 0x3F91DF46A2529D39
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_sin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @sin(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_sqrt(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @sqrt(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_tan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1)
  %3 = tail call double @tan(double %2) #7
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_type(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 3
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 1)
  %6 = icmp eq i32 %5, 0
  %7 = select i1 %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.462, i64 0, i64 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.461, i64 0, i64 0)
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7)
  br label %10

; <label>:9:                                      ; preds = %1
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  br label %10

; <label>:10:                                     ; preds = %9, %4
  ret i32 1
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.fabs.f64(double) #13

; Function Attrs: nounwind
declare double @acos(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @asin(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @atan2(double, double) local_unnamed_addr #9

; Function Attrs: nounwind readnone speculatable
declare double @llvm.ceil.f64(double) #13

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @pushnumint(%struct.lua_State* nocapture, double) unnamed_addr #2 {
  %3 = fcmp oge double %1, 0xC3E0000000000000
  %4 = fcmp olt double %1, 0x43E0000000000000
  %5 = and i1 %3, %4
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %2
  %7 = fptosi double %1 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %7)
  br label %9

; <label>:8:                                      ; preds = %2
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %1)
  br label %9

; <label>:9:                                      ; preds = %8, %6
  ret void
}

; Function Attrs: nounwind
declare double @cos(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @exp(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @log(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @log2(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @log10(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @sin(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @sqrt(double) local_unnamed_addr #9

; Function Attrs: nounwind
declare double @tan(double) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc void @randseed(%struct.lua_State*, %struct.RanState* nocapture) unnamed_addr #0 {
  %3 = tail call i64 @time(i64* null) #7
  %4 = ptrtoint %struct.lua_State* %0 to i64
  %5 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 0
  tail call fastcc void @setseed(i64* %5, i64 %3, i64 %4)
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @setseed(i64* nocapture, i64, i64) unnamed_addr #2 {
  store i64 %1, i64* %0, align 8, !tbaa !113
  %4 = getelementptr inbounds i64, i64* %0, i64 1
  store i64 255, i64* %4, align 8, !tbaa !113
  %5 = getelementptr inbounds i64, i64* %0, i64 2
  store i64 %2, i64* %5, align 8, !tbaa !113
  %6 = getelementptr inbounds i64, i64* %0, i64 3
  store i64 0, i64* %6, align 8, !tbaa !113
  br label %7

; <label>:7:                                      ; preds = %7, %3
  %8 = phi i32 [ 0, %3 ], [ %10, %7 ]
  %9 = tail call fastcc i64 @nextrand(i64* %0)
  %10 = add nuw nsw i32 %8, 1
  %11 = icmp eq i32 %10, 16
  br i1 %11, label %12, label %7

; <label>:12:                                     ; preds = %7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i64 @nextrand(i64* nocapture) unnamed_addr #2 {
  %2 = load i64, i64* %0, align 8, !tbaa !113
  %3 = getelementptr inbounds i64, i64* %0, i64 1
  %4 = load i64, i64* %3, align 8, !tbaa !113
  %5 = getelementptr inbounds i64, i64* %0, i64 2
  %6 = load i64, i64* %5, align 8, !tbaa !113
  %7 = xor i64 %6, %2
  %8 = getelementptr inbounds i64, i64* %0, i64 3
  %9 = load i64, i64* %8, align 8, !tbaa !113
  %10 = xor i64 %9, %4
  %11 = mul i64 %4, 5
  %12 = tail call fastcc i64 @rotl(i64 %11, i32 7)
  %13 = mul i64 %12, 9
  %14 = xor i64 %10, %2
  store i64 %14, i64* %0, align 8, !tbaa !113
  %15 = xor i64 %7, %4
  store i64 %15, i64* %3, align 8, !tbaa !113
  %16 = shl i64 %4, 17
  %17 = xor i64 %7, %16
  store i64 %17, i64* %5, align 8, !tbaa !113
  %18 = tail call fastcc i64 @rotl(i64 %10, i32 45)
  store i64 %18, i64* %8, align 8, !tbaa !113
  ret i64 %13
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i64 @rotl(i64, i32) unnamed_addr #6 {
  %3 = zext i32 %1 to i64
  %4 = shl i64 %0, %3
  %5 = sub nsw i32 64, %1
  %6 = zext i32 %5 to i64
  %7 = lshr i64 %0, %6
  %8 = or i64 %7, %4
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @math_random(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001)
  %3 = bitcast i8* %2 to %struct.RanState*
  %4 = bitcast i8* %2 to i64*
  %5 = tail call fastcc i64 @nextrand(i64* %4)
  %6 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  switch i32 %6, label %16 [
    i32 0, label %7
    i32 1, label %9
    i32 2, label %13
  ]

; <label>:7:                                      ; preds = %1
  %8 = tail call fastcc double @I2d(i64 %5)
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %8)
  br label %28

; <label>:9:                                      ; preds = %1
  %10 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1)
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %12, label %18

; <label>:12:                                     ; preds = %9
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %5)
  br label %28

; <label>:13:                                     ; preds = %1
  %14 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1)
  %15 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.463, i64 0, i64 0))
  unreachable

; <label>:18:                                     ; preds = %9, %13
  %19 = phi i64 [ %15, %13 ], [ %10, %9 ]
  %20 = phi i64 [ %14, %13 ], [ 1, %9 ]
  %21 = icmp slt i64 %19, %20
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %18
  %23 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.464, i64 0, i64 0))
  br label %24

; <label>:24:                                     ; preds = %18, %22
  %25 = sub i64 %19, %20
  %26 = tail call fastcc i64 @project(i64 %5, i64 %25, %struct.RanState* %3)
  %27 = add i64 %26, %20
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %27)
  br label %28

; <label>:28:                                     ; preds = %24, %12, %7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @math_randomseed(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %4 = icmp eq i32 %3, -1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = bitcast i8* %2 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* %0, %struct.RanState* %6)
  br label %11

; <label>:7:                                      ; preds = %1
  %8 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1)
  %9 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0)
  %10 = bitcast i8* %2 to i64*
  tail call fastcc void @setseed(i64* %10, i64 %8, i64 %9)
  br label %11

; <label>:11:                                     ; preds = %7, %5
  ret i32 0
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc double @I2d(i64) unnamed_addr #6 {
  %2 = lshr i64 %0, 11
  %3 = uitofp i64 %2 to double
  %4 = fmul double %3, 0x3CA0000000000000
  ret double %4
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i64 @project(i64, i64, %struct.RanState* nocapture) unnamed_addr #2 {
  %4 = add i64 %1, 1
  %5 = and i64 %4, %1
  %6 = icmp eq i64 %5, 0
  br i1 %6, label %20, label %7

; <label>:7:                                      ; preds = %3
  %8 = lshr i64 %1, 1
  %9 = or i64 %8, %1
  %10 = lshr i64 %9, 2
  %11 = or i64 %10, %9
  %12 = lshr i64 %11, 4
  %13 = or i64 %12, %11
  %14 = lshr i64 %13, 8
  %15 = or i64 %14, %13
  %16 = lshr i64 %15, 16
  %17 = or i64 %16, %15
  %18 = lshr i64 %17, 32
  %19 = or i64 %18, %17
  br label %20

; <label>:20:                                     ; preds = %3, %7
  %21 = phi i64 [ %19, %7 ], [ %1, %3 ]
  %22 = and i64 %21, %0
  %23 = icmp ugt i64 %22, %1
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %20
  %25 = getelementptr inbounds %struct.RanState, %struct.RanState* %2, i64 0, i32 0, i64 0
  br label %26

; <label>:26:                                     ; preds = %24, %26
  %27 = tail call fastcc i64 @nextrand(i64* %25)
  %28 = and i64 %27, %21
  %29 = icmp ugt i64 %28, %1
  br i1 %29, label %26, label %30

; <label>:30:                                     ; preds = %26, %20
  %31 = phi i64 [ %22, %20 ], [ %28, %26 ]
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define internal i32 @gctm(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  %3 = icmp sgt i64 %2, 0
  br i1 %3, label %4, label %10

; <label>:4:                                      ; preds = %1
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i64 [ %8, %5 ], [ %2, %4 ]
  %7 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 1, i64 %6)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %8 = add nsw i64 %6, -1
  %9 = icmp sgt i64 %6, 1
  br i1 %9, label %5, label %10

; <label>:10:                                     ; preds = %5, %1
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_loadlib(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null)
  %4 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %2, i8* %3)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  %7 = icmp eq i32 %4, 1
  %8 = select i1 %7, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.468, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.469, i64 0, i64 0)
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %8)
  br label %10

; <label>:10:                                     ; preds = %1, %6
  %11 = phi i32 [ 3, %6 ], [ 1, %1 ]
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_searchpath(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null)
  %4 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i64* null)
  %5 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0), i64* null)
  %6 = tail call fastcc i8* @searchpath(%struct.lua_State* %0, i8* %2, i8* %3, i8* %4, i8* %5)
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %1
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %9

; <label>:9:                                      ; preds = %1, %8
  %10 = phi i32 [ 2, %8 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @lookforfunc(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc i8* @checkclib(%struct.lua_State* %0, i8* %1)
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %3
  tail call fastcc void @lsys_load(%struct.lua_State* %0)
  br label %12

; <label>:7:                                      ; preds = %3
  %8 = load i8, i8* %2, align 1, !tbaa !21
  %9 = icmp eq i8 %8, 42
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %7
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  br label %12

; <label>:11:                                     ; preds = %7
  tail call fastcc void @lsys_sym(%struct.lua_State* %0)
  br label %12

; <label>:12:                                     ; preds = %11, %10, %6
  %13 = phi i32 [ 1, %6 ], [ 0, %10 ], [ 2, %11 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @checkclib(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*))
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1)
  %5 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  ret i8* %5
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lsys_load(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @lsys_sym(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @searchpath(%struct.lua_State*, i8*, i8*, i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {
  %6 = alloca %struct.luaL_Buffer, align 8
  %7 = alloca i8*, align 8
  %8 = bitcast %struct.luaL_Buffer* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %8) #7
  %9 = bitcast i8** %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = load i8, i8* %3, align 1, !tbaa !21
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %18, label %12

; <label>:12:                                     ; preds = %5
  %13 = sext i8 %10 to i32
  %14 = tail call i8* @strchr(i8* %1, i32 %13) #19
  %15 = icmp eq i8* %14, null
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %12
  %17 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %1, i8* nonnull %3, i8* %4)
  br label %18

; <label>:18:                                     ; preds = %12, %5, %16
  %19 = phi i8* [ %17, %16 ], [ %1, %12 ], [ %1, %5 ]
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %6)
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %6, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %19)
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 2
  %21 = load i64, i64* %20, align 8, !tbaa !182
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 1
  %23 = load i64, i64* %22, align 8, !tbaa !180
  %24 = icmp ult i64 %21, %23
  br i1 %24, label %27, label %25

; <label>:25:                                     ; preds = %18
  %26 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %6, i64 1)
  br label %27

; <label>:27:                                     ; preds = %25, %18
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 0
  %29 = load i8*, i8** %28, align 8, !tbaa !183
  %30 = load i64, i64* %20, align 8, !tbaa !182
  %31 = add i64 %30, 1
  store i64 %31, i64* %20, align 8, !tbaa !182
  %32 = getelementptr inbounds i8, i8* %29, i64 %30
  store i8 0, i8* %32, align 1, !tbaa !21
  %33 = load i8*, i8** %28, align 8, !tbaa !183
  store i8* %33, i8** %7, align 8, !tbaa !79
  %34 = load i64, i64* %20, align 8, !tbaa !182
  %35 = getelementptr inbounds i8, i8* %33, i64 %34
  %36 = getelementptr inbounds i8, i8* %35, i64 -1
  %37 = call fastcc i8* @getnextfilename(i8** nonnull %7, i8* nonnull %36)
  %38 = icmp eq i8* %37, null
  br i1 %38, label %49, label %39

; <label>:39:                                     ; preds = %27
  br label %43

; <label>:40:                                     ; preds = %43
  %41 = call fastcc i8* @getnextfilename(i8** nonnull %7, i8* nonnull %36)
  %42 = icmp eq i8* %41, null
  br i1 %42, label %49, label %43

; <label>:43:                                     ; preds = %39, %40
  %44 = phi i8* [ %41, %40 ], [ %37, %39 ]
  %45 = call fastcc i32 @readable(i8* nonnull %44)
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %40, label %47

; <label>:47:                                     ; preds = %43
  %48 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %44)
  br label %51

; <label>:49:                                     ; preds = %40, %27
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %6)
  %50 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  call fastcc void @pusherrornotfound(%struct.lua_State* %0, i8* %50)
  br label %51

; <label>:51:                                     ; preds = %49, %47
  %52 = phi i8* [ %48, %47 ], [ null, %49 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %8) #7
  ret i8* %52
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @getnextfilename(i8** nocapture, i8*) unnamed_addr #0 {
  %3 = load i8*, i8** %0, align 8, !tbaa !79
  %4 = icmp eq i8* %3, %1
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %2
  %6 = load i8, i8* %3, align 1, !tbaa !21
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %5
  store i8 59, i8* %3, align 1, !tbaa !21
  %9 = getelementptr inbounds i8, i8* %3, i64 1
  br label %10

; <label>:10:                                     ; preds = %5, %8
  %11 = phi i8* [ %9, %8 ], [ %3, %5 ]
  %12 = tail call i8* @strchr(i8* nonnull %11, i32 59) #19
  %13 = icmp eq i8* %12, null
  %14 = select i1 %13, i8* %1, i8* %12
  store i8 0, i8* %14, align 1, !tbaa !21
  store i8* %14, i8** %0, align 8, !tbaa !79
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi i8* [ %11, %10 ], [ null, %2 ]
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @readable(i8* nocapture readonly) unnamed_addr #0 {
  %2 = tail call %struct._IO_FILE* @fopen64(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0))
  %3 = icmp eq %struct._IO_FILE* %2, null
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @fclose(%struct._IO_FILE* nonnull %2)
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = phi i32 [ 1, %4 ], [ 0, %1 ]
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pusherrornotfound(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3)
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.473, i64 0, i64 0))
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %3, i8* %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.472, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.474, i64 0, i64 0))
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.475, i64 0, i64 0))
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_preload(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0))
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %2)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.476, i64 0, i64 0), i8* %2)
  br label %10

; <label>:8:                                      ; preds = %1
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.477, i64 0, i64 0))
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i32 [ 1, %6 ], [ 2, %8 ]
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_Lua(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0))
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* nonnull %3, i8* null)
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3)
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_C(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0))
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %3, i8* %2)
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3)
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @searcher_Croot(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @strchr(i8* %2, i32 46) #19
  %4 = icmp eq i8* %3, null
  br i1 %4, label %20, label %5

; <label>:5:                                      ; preds = %1
  %6 = ptrtoint i8* %3 to i64
  %7 = ptrtoint i8* %2 to i64
  %8 = sub i64 %6, %7
  %9 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %2, i64 %8)
  %10 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %11 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0))
  %12 = icmp eq i8* %11, null
  br i1 %12, label %20, label %13

; <label>:13:                                     ; preds = %5
  %14 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %11, i8* %2)
  switch i32 %14, label %15 [
    i32 0, label %18
    i32 2, label %16
  ]

; <label>:15:                                     ; preds = %13
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 0, i8* nonnull %11)
  br label %20

; <label>:16:                                     ; preds = %13
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.483, i64 0, i64 0), i8* %2, i8* nonnull %11)
  br label %20

; <label>:18:                                     ; preds = %13
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11)
  br label %20

; <label>:20:                                     ; preds = %5, %1, %18, %16, %15
  %21 = phi i32 [ 2, %15 ], [ 1, %16 ], [ 2, %18 ], [ 0, %1 ], [ 1, %5 ]
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @findfile(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001001, i8* %2)
  %5 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %6 = icmp eq i8* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.478, i64 0, i64 0), i8* %2)
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = tail call fastcc i8* @searchpath(%struct.lua_State* %0, i8* %1, i8* nonnull %5, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0))
  ret i8* %10
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checkload(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %9

; <label>:5:                                      ; preds = %3
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.479, i64 0, i64 0), i8* %6, i8* %2, i8* %7)
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @loadfunc(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.480, i64 0, i64 0))
  %5 = tail call i8* @strchr(i8* %4, i32 45) #19
  %6 = icmp eq i8* %5, null
  br i1 %6, label %16, label %7

; <label>:7:                                      ; preds = %3
  %8 = ptrtoint i8* %5 to i64
  %9 = ptrtoint i8* %4 to i64
  %10 = sub i64 %8, %9
  %11 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %4, i64 %10)
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* nonnull %11)
  %13 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %12)
  %14 = icmp eq i32 %13, 2
  %15 = getelementptr inbounds i8, i8* %5, i64 1
  br i1 %14, label %16, label %20

; <label>:16:                                     ; preds = %3, %7
  %17 = phi i8* [ %15, %7 ], [ %4, %3 ]
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* %17)
  %19 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %18)
  br label %20

; <label>:20:                                     ; preds = %7, %16
  %21 = phi i32 [ %19, %16 ], [ %13, %7 ]
  ret i32 %21
}

; Function Attrs: nounwind readonly
declare i8* @getenv(i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc i32 @noenv(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0))
  %3 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @ll_require(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  %3 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0))
  %4 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 2, i8* %2)
  %5 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %17

; <label>:7:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call fastcc void @findloader(%struct.lua_State* %0, i8* %2)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -3)
  tail call void @lua_callk(%struct.lua_State* %0, i32 2, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %11, label %10

; <label>:10:                                     ; preds = %7
  tail call void @lua_setfield(%struct.lua_State* %0, i32 2, i8* %2)
  br label %12

; <label>:11:                                     ; preds = %7
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %12

; <label>:12:                                     ; preds = %11, %10
  %13 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 2, i8* %2)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %16

; <label>:15:                                     ; preds = %12
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 1)
  tail call void @lua_copy(%struct.lua_State* %0, i32 -1, i32 -2)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 2, i8* %2)
  br label %16

; <label>:16:                                     ; preds = %15, %12
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  br label %17

; <label>:17:                                     ; preds = %1, %16
  %18 = phi i32 [ 2, %16 ], [ 1, %1 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc void @findloader(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  %5 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1001001, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0))
  %6 = icmp eq i32 %5, 5
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.489, i64 0, i64 0))
  unreachable

; <label>:9:                                      ; preds = %2
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3)
  %10 = call i32 @lua_rawgeti(%struct.lua_State* %0, i32 3, i64 1)
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %9
  br label %16

; <label>:13:                                     ; preds = %27, %9
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3)
  %14 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %15 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.490, i64 0, i64 0), i8* %1, i8* %14)
  unreachable

; <label>:16:                                     ; preds = %12, %27
  %17 = phi i64 [ %28, %27 ], [ 1, %12 ]
  %18 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  call void @lua_callk(%struct.lua_State* %0, i32 1, i32 2, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %19 = call i32 @lua_type(%struct.lua_State* %0, i32 -2)
  %20 = icmp eq i32 %19, 6
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret void

; <label>:22:                                     ; preds = %16
  %23 = call i32 @lua_isstring(%struct.lua_State* %0, i32 -2)
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %26, label %25

; <label>:25:                                     ; preds = %22
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %3)
  br label %27

; <label>:26:                                     ; preds = %22
  call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %27

; <label>:27:                                     ; preds = %26, %25
  %28 = add nuw i64 %17, 1
  %29 = call i32 @lua_rawgeti(%struct.lua_State* %0, i32 3, i64 %28)
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %13, label %16
}

; Function Attrs: nounwind uwtable
define internal i32 @os_clock(%struct.lua_State* nocapture) #0 {
  %2 = tail call i64 @clock() #7
  %3 = sitofp i64 %2 to double
  %4 = fdiv double %3, 1.000000e+06
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %4)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_date(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca [4 x i8], align 1
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.501, i64 0, i64 0), i64* nonnull %2)
  %8 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %10 = icmp slt i32 %9, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %1
  %12 = call i64 @time(i64* null) #7
  br label %15

; <label>:13:                                     ; preds = %1
  %14 = call fastcc i64 @l_checktime(%struct.lua_State* %0, i32 2)
  br label %15

; <label>:15:                                     ; preds = %13, %11
  %16 = phi i64 [ %12, %11 ], [ %14, %13 ]
  store i64 %16, i64* %3, align 8, !tbaa !113
  %17 = load i64, i64* %2, align 8, !tbaa !113
  %18 = getelementptr inbounds i8, i8* %7, i64 %17
  %19 = load i8, i8* %7, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 33
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %15
  %22 = call %struct.tm* @gmtime(i64* nonnull %3) #7
  %23 = getelementptr inbounds i8, i8* %7, i64 1
  br label %26

; <label>:24:                                     ; preds = %15
  %25 = call %struct.tm* @localtime(i64* nonnull %3) #7
  br label %26

; <label>:26:                                     ; preds = %24, %21
  %27 = phi %struct.tm* [ %22, %21 ], [ %25, %24 ]
  %28 = phi i8* [ %23, %21 ], [ %7, %24 ]
  %29 = icmp eq %struct.tm* %27, null
  br i1 %29, label %30, label %32

; <label>:30:                                     ; preds = %26
  %31 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0))
  unreachable

; <label>:32:                                     ; preds = %26
  %33 = call i32 @strcmp(i8* nonnull %28, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.503, i64 0, i64 0)) #19
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %35, label %36

; <label>:35:                                     ; preds = %32
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 9)
  call fastcc void @setallfields(%struct.lua_State* %0, %struct.tm* nonnull %27)
  br label %77

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %37) #7
  %38 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %38) #7
  store i8 37, i8* %37, align 1, !tbaa !21
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %5)
  %39 = icmp ult i8* %28, %18
  br i1 %39, label %40, label %76

; <label>:40:                                     ; preds = %36
  %41 = ptrtoint i8* %18 to i64
  %42 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 1
  %43 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %44 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %45 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %46 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  br label %47

; <label>:47:                                     ; preds = %40, %73
  %48 = phi i8* [ %28, %40 ], [ %74, %73 ]
  %49 = load i8, i8* %48, align 1, !tbaa !21
  %50 = icmp eq i8 %49, 37
  br i1 %50, label %64, label %51

; <label>:51:                                     ; preds = %47
  %52 = load i64, i64* %44, align 8, !tbaa !182
  %53 = load i64, i64* %45, align 8, !tbaa !180
  %54 = icmp ult i64 %52, %53
  br i1 %54, label %57, label %55

; <label>:55:                                     ; preds = %51
  %56 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1)
  br label %57

; <label>:57:                                     ; preds = %55, %51
  %58 = getelementptr inbounds i8, i8* %48, i64 1
  %59 = load i8, i8* %48, align 1, !tbaa !21
  %60 = load i8*, i8** %46, align 8, !tbaa !183
  %61 = load i64, i64* %44, align 8, !tbaa !182
  %62 = add i64 %61, 1
  store i64 %62, i64* %44, align 8, !tbaa !182
  %63 = getelementptr inbounds i8, i8* %60, i64 %61
  store i8 %59, i8* %63, align 1, !tbaa !21
  br label %73

; <label>:64:                                     ; preds = %47
  %65 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 250)
  %66 = getelementptr inbounds i8, i8* %48, i64 1
  %67 = ptrtoint i8* %66 to i64
  %68 = sub i64 %41, %67
  %69 = call fastcc i8* @checkoption(%struct.lua_State* %0, i8* nonnull %66, i64 %68, i8* nonnull %42)
  %70 = call i64 @strftime(i8* %65, i64 250, i8* nonnull %37, %struct.tm* nonnull %27) #7
  %71 = load i64, i64* %43, align 8, !tbaa !182
  %72 = add i64 %71, %70
  store i64 %72, i64* %43, align 8, !tbaa !182
  br label %73

; <label>:73:                                     ; preds = %64, %57
  %74 = phi i8* [ %58, %57 ], [ %69, %64 ]
  %75 = icmp ult i8* %74, %18
  br i1 %75, label %47, label %76

; <label>:76:                                     ; preds = %73, %36
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %38) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %37) #7
  br label %77

; <label>:77:                                     ; preds = %35, %76
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_difftime(%struct.lua_State*) #0 {
  %2 = tail call fastcc i64 @l_checktime(%struct.lua_State* %0, i32 1)
  %3 = tail call fastcc i64 @l_checktime(%struct.lua_State* %0, i32 2)
  %4 = tail call double @difftime(i64 %2, i64 %3) #21
  tail call void @lua_pushnumber(%struct.lua_State* %0, double %4)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_execute(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  %3 = tail call i32 @system(i8* %2) #7
  %4 = icmp eq i8* %2, null
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_execresult(%struct.lua_State* %0, i32 %3)
  br label %8

; <label>:7:                                      ; preds = %1
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %3)
  br label %8

; <label>:8:                                      ; preds = %7, %5
  %9 = phi i32 [ %6, %5 ], [ 1, %7 ]
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @os_exit(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 1
  br i1 %3, label %4, label %8

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 1)
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  br label %11

; <label>:8:                                      ; preds = %1
  %9 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 1, i64 0)
  %10 = trunc i64 %9 to i32
  br label %11

; <label>:11:                                     ; preds = %8, %4
  %12 = phi i32 [ %7, %4 ], [ %10, %8 ]
  %13 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %16, label %15

; <label>:15:                                     ; preds = %11
  tail call void @lua_close(%struct.lua_State* %0)
  br label %16

; <label>:16:                                     ; preds = %11, %15
  %17 = icmp eq %struct.lua_State* %0, null
  br i1 %17, label %19, label %18

; <label>:18:                                     ; preds = %16
  tail call void @exit(i32 %12) #20
  unreachable

; <label>:19:                                     ; preds = %16
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @os_getenv(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @getenv(i8* %2) #7
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_remove(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i32 @remove(i8* %2) #7
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* %2)
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @os_rename(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null)
  %4 = tail call i32 @rename(i8* %2, i8* %3) #7
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  %7 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %6, i8* null)
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @os_setlocale(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null)
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i64 0, i64 0), i8** getelementptr inbounds ([7 x i8*], [7 x i8*]* @os_setlocale.catnames, i64 0, i64 0))
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [6 x i32], [6 x i32]* @os_setlocale.cat, i64 0, i64 %4
  %6 = load i32, i32* %5, align 4, !tbaa !70
  %7 = tail call i8* @setlocale(i32 %6, i8* %2) #7
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_time(%struct.lua_State*) #0 {
  %2 = alloca %struct.tm, align 8
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call i64 @time(i64* null) #7
  br label %24

; <label>:7:                                      ; preds = %1
  %8 = bitcast %struct.tm* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %8) #7
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5)
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  %9 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0), i32 0, i32 0)
  %10 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 0
  store i32 %9, i32* %10, align 8, !tbaa !337
  %11 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0), i32 0, i32 0)
  %12 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 1
  store i32 %11, i32* %12, align 4, !tbaa !339
  %13 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0), i32 12, i32 0)
  %14 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 2
  store i32 %13, i32* %14, align 8, !tbaa !340
  %15 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0), i32 -1, i32 0)
  %16 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 3
  store i32 %15, i32* %16, align 4, !tbaa !341
  %17 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0), i32 -1, i32 1)
  %18 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 4
  store i32 %17, i32* %18, align 8, !tbaa !342
  %19 = tail call fastcc i32 @getfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0), i32 -1, i32 1900)
  %20 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 5
  store i32 %19, i32* %20, align 4, !tbaa !343
  %21 = tail call fastcc i32 @getboolfield(%struct.lua_State* %0)
  %22 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 8
  store i32 %21, i32* %22, align 8, !tbaa !344
  %23 = call i64 @mktime(%struct.tm* nonnull %2) #7
  call fastcc void @setallfields(%struct.lua_State* %0, %struct.tm* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %8) #7
  br label %24

; <label>:24:                                     ; preds = %7, %5
  %25 = phi i64 [ %6, %5 ], [ %23, %7 ]
  %26 = icmp eq i64 %25, -1
  br i1 %26, label %27, label %29

; <label>:27:                                     ; preds = %24
  %28 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0))
  unreachable

; <label>:29:                                     ; preds = %24
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %25)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @os_tmpname(%struct.lua_State*) #0 {
  %2 = alloca [20 x i8], align 16
  %3 = getelementptr inbounds [20 x i8], [20 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %3) #7
  %4 = call i8* @tmpnam(i8* nonnull %3) #7
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.523, i64 0, i64 0))
  unreachable

; <label>:8:                                      ; preds = %1
  %9 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %3)
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind
declare i64 @clock() local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i64 @l_checktime(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1)
  ret i64 %3
}

; Function Attrs: nounwind
declare %struct.tm* @gmtime(i64*) local_unnamed_addr #9

; Function Attrs: nounwind
declare %struct.tm* @localtime(i64*) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc void @setallfields(%struct.lua_State*, %struct.tm* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !337
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0), i32 %4)
  %5 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 1
  %6 = load i32, i32* %5, align 4, !tbaa !339
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0), i32 %6)
  %7 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 2
  %8 = load i32, i32* %7, align 8, !tbaa !340
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0), i32 %8)
  %9 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 3
  %10 = load i32, i32* %9, align 4, !tbaa !341
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0), i32 %10)
  %11 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 4
  %12 = load i32, i32* %11, align 8, !tbaa !342
  %13 = add nsw i32 %12, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0), i32 %13)
  %14 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !343
  %16 = add nsw i32 %15, 1900
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0), i32 %16)
  %17 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 6
  %18 = load i32, i32* %17, align 8, !tbaa !345
  %19 = add nsw i32 %18, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.510, i64 0, i64 0), i32 %19)
  %20 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 7
  %21 = load i32, i32* %20, align 4, !tbaa !346
  %22 = add nsw i32 %21, 1
  tail call fastcc void @setfield(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.511, i64 0, i64 0), i32 %22)
  %23 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 8
  %24 = load i32, i32* %23, align 8, !tbaa !344
  tail call fastcc void @setboolfield(%struct.lua_State* %0, i32 %24)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @checkoption(%struct.lua_State*, i8*, i64, i8* nocapture) unnamed_addr #0 {
  br label %5

; <label>:5:                                      ; preds = %4, %21
  %6 = phi i8 [ 97, %4 ], [ %25, %21 ]
  %7 = phi i32 [ 1, %4 ], [ %22, %21 ]
  %8 = phi i8* [ getelementptr inbounds ([78 x i8], [78 x i8]* @.str.513, i64 0, i64 0), %4 ], [ %24, %21 ]
  %9 = sext i32 %7 to i64
  %10 = icmp sgt i64 %9, %2
  br i1 %10, label %27, label %11

; <label>:11:                                     ; preds = %5
  %12 = icmp eq i8 %6, 124
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = add nsw i32 %7, 1
  br label %21

; <label>:15:                                     ; preds = %11
  %16 = tail call i32 @memcmp(i8* %1, i8* %8, i64 %9) #19
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %21

; <label>:18:                                     ; preds = %15
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %1, i64 %9, i32 1, i1 false)
  %19 = getelementptr inbounds i8, i8* %3, i64 %9
  store i8 0, i8* %19, align 1, !tbaa !21
  %20 = getelementptr inbounds i8, i8* %1, i64 %9
  br label %30

; <label>:21:                                     ; preds = %13, %15
  %22 = phi i32 [ %14, %13 ], [ %7, %15 ]
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i8, i8* %8, i64 %23
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %27, label %5

; <label>:27:                                     ; preds = %5, %21
  %28 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.514, i64 0, i64 0), i8* %1)
  %29 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* nonnull %28)
  br label %30

; <label>:30:                                     ; preds = %27, %18
  %31 = phi i8* [ %20, %18 ], [ %1, %27 ]
  ret i8* %31
}

; Function Attrs: nounwind
declare i64 @strftime(i8*, i64, i8*, %struct.tm*) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc void @setfield(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = sext i32 %2 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %4)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @setboolfield(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp slt i32 %1, 0
  br i1 %3, label %5, label %4

; <label>:4:                                      ; preds = %2
  tail call void @lua_pushboolean(%struct.lua_State* %0, i32 %1)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0))
  br label %5

; <label>:5:                                      ; preds = %2, %4
  ret void
}

; Function Attrs: nounwind readnone
declare double @difftime(i64, i64) local_unnamed_addr #8

declare i32 @system(i8* nocapture readonly) local_unnamed_addr #11

; Function Attrs: noreturn nounwind
declare void @exit(i32) local_unnamed_addr #15

; Function Attrs: nounwind
declare i32 @remove(i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @rename(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind
declare i8* @setlocale(i32, i8*) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @getfield(%struct.lua_State*, i8*, i32, i32) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %6) #7
  %7 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* %1)
  %8 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %5)
  %9 = load i32, i32* %5, align 4, !tbaa !70
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %21

; <label>:11:                                     ; preds = %4
  %12 = icmp eq i32 %7, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %11
  %14 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.520, i64 0, i64 0), i8* %1)
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = icmp slt i32 %2, 0
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %15
  %18 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.521, i64 0, i64 0), i8* %1)
  unreachable

; <label>:19:                                     ; preds = %15
  %20 = sext i32 %2 to i64
  br label %29

; <label>:21:                                     ; preds = %4
  %22 = add i64 %8, 1073741823
  %23 = icmp ult i64 %22, 2147483647
  br i1 %23, label %26, label %24

; <label>:24:                                     ; preds = %21
  %25 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.522, i64 0, i64 0), i8* %1)
  unreachable

; <label>:26:                                     ; preds = %21
  %27 = sext i32 %3 to i64
  %28 = sub nsw i64 %8, %27
  br label %29

; <label>:29:                                     ; preds = %19, %26
  %30 = phi i64 [ %28, %26 ], [ %20, %19 ]
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %31 = trunc i64 %30 to i32
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #7
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @getboolfield(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i32 @lua_getfield(%struct.lua_State* %0, i32 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0))
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1)
  br label %6

; <label>:6:                                      ; preds = %1, %4
  %7 = phi i32 [ %5, %4 ], [ -1, %1 ]
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 %7
}

; Function Attrs: nounwind
declare i64 @mktime(%struct.tm* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i8* @tmpnam(i8*) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal i32 @str_byte(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %6 = load i64, i64* %2, align 8, !tbaa !113
  %7 = call fastcc i64 @posrelatI(i64 %5, i64 %6)
  %8 = call fastcc i64 @getendpos(%struct.lua_State* %0, i64 %5, i64 %6)
  %9 = icmp ult i64 %8, %7
  br i1 %9, label %31, label %10

; <label>:10:                                     ; preds = %1
  %11 = sub i64 %8, %7
  %12 = icmp ugt i64 %11, 2147483646
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %10
  %14 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0))
  unreachable

; <label>:15:                                     ; preds = %10
  %16 = trunc i64 %11 to i32
  %17 = add nsw i32 %16, 1
  call void @luaL_checkstack(%struct.lua_State* %0, i32 %17, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0))
  %18 = icmp slt i32 %16, 0
  br i1 %18, label %31, label %19

; <label>:19:                                     ; preds = %15
  %20 = add i64 %7, -1
  %21 = add i64 %11, 1
  %22 = and i64 %21, 4294967295
  br label %23

; <label>:23:                                     ; preds = %23, %19
  %24 = phi i64 [ %29, %23 ], [ 0, %19 ]
  %25 = add i64 %20, %24
  %26 = getelementptr inbounds i8, i8* %4, i64 %25
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = zext i8 %27 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %28)
  %29 = add nuw nsw i64 %24, 1
  %30 = icmp eq i64 %29, %22
  br i1 %30, label %31, label %23

; <label>:31:                                     ; preds = %23, %15, %1
  %32 = phi i32 [ 0, %1 ], [ %17, %15 ], [ %17, %23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define internal i32 @str_char(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  %5 = sext i32 %3 to i64
  %6 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %5)
  %7 = icmp slt i32 %3, 1
  br i1 %7, label %25, label %8

; <label>:8:                                      ; preds = %1
  %9 = add i32 %3, 1
  %10 = zext i32 %9 to i64
  br label %11

; <label>:11:                                     ; preds = %19, %8
  %12 = phi i64 [ %23, %19 ], [ 1, %8 ]
  %13 = trunc i64 %12 to i32
  %14 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %13)
  %15 = icmp ult i64 %14, 256
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %11
  %17 = trunc i64 %12 to i32
  %18 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %17, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0))
  br label %19

; <label>:19:                                     ; preds = %16, %11
  %20 = trunc i64 %14 to i8
  %21 = add nsw i64 %12, -1
  %22 = getelementptr inbounds i8, i8* %6, i64 %21
  store i8 %20, i8* %22, align 1, !tbaa !21
  %23 = add nuw nsw i64 %12, 1
  %24 = icmp eq i64 %23, %10
  br i1 %24, label %25, label %11

; <label>:25:                                     ; preds = %19, %1
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %2, i64 %5)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_dump(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %3) #7
  %4 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2)
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6)
  tail call void @lua_settop(%struct.lua_State* %0, i32 1)
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2)
  %5 = call i32 @lua_dump(%struct.lua_State* %0, i32 (%struct.lua_State*, i8*, i64, i8*)* nonnull @writer, i8* nonnull %3, i32 %4)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %1
  %8 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.543, i64 0, i64 0))
  unreachable

; <label>:9:                                      ; preds = %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_find(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 1)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @str_format(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = alloca [32 x i8], align 16
  %5 = alloca i64, align 8
  %6 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %7 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = getelementptr inbounds i8, i8* %8, i64 %9
  %11 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %11) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3)
  %12 = icmp sgt i64 %9, 0
  br i1 %12, label %13, label %136

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 1
  %16 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %17 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 1
  %18 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i64 0, i64 0
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 0
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 0
  %21 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %22 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i64 0, i64 2
  %23 = bitcast i64* %5 to i8*
  %24 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i64 0, i64 2
  br label %25

; <label>:25:                                     ; preds = %13, %132
  %26 = phi i32 [ 1, %13 ], [ %134, %132 ]
  %27 = phi i8* [ %8, %13 ], [ %133, %132 ]
  %28 = load i8, i8* %27, align 1, !tbaa !21
  %29 = icmp eq i8 %28, 37
  br i1 %29, label %43, label %30

; <label>:30:                                     ; preds = %25
  %31 = load i64, i64* %14, align 8, !tbaa !182
  %32 = load i64, i64* %15, align 8, !tbaa !180
  %33 = icmp ult i64 %31, %32
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %30
  %35 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 1)
  br label %36

; <label>:36:                                     ; preds = %34, %30
  %37 = getelementptr inbounds i8, i8* %27, i64 1
  %38 = load i8, i8* %27, align 1, !tbaa !21
  %39 = load i8*, i8** %19, align 8, !tbaa !183
  %40 = load i64, i64* %14, align 8, !tbaa !182
  %41 = add i64 %40, 1
  store i64 %41, i64* %14, align 8, !tbaa !182
  %42 = getelementptr inbounds i8, i8* %39, i64 %40
  store i8 %38, i8* %42, align 1, !tbaa !21
  br label %132

; <label>:43:                                     ; preds = %25
  %44 = getelementptr inbounds i8, i8* %27, i64 1
  %45 = load i8, i8* %44, align 1, !tbaa !21
  %46 = icmp eq i8 %45, 37
  br i1 %46, label %47, label %60

; <label>:47:                                     ; preds = %43
  %48 = load i64, i64* %16, align 8, !tbaa !182
  %49 = load i64, i64* %17, align 8, !tbaa !180
  %50 = icmp ult i64 %48, %49
  br i1 %50, label %53, label %51

; <label>:51:                                     ; preds = %47
  %52 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 1)
  br label %53

; <label>:53:                                     ; preds = %51, %47
  %54 = getelementptr inbounds i8, i8* %27, i64 2
  %55 = load i8, i8* %44, align 1, !tbaa !21
  %56 = load i8*, i8** %20, align 8, !tbaa !183
  %57 = load i64, i64* %16, align 8, !tbaa !182
  %58 = add i64 %57, 1
  store i64 %58, i64* %16, align 8, !tbaa !182
  %59 = getelementptr inbounds i8, i8* %56, i64 %57
  store i8 %55, i8* %59, align 1, !tbaa !21
  br label %132

; <label>:60:                                     ; preds = %43
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %18) #7
  %61 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 120)
  %62 = add nsw i32 %26, 1
  %63 = icmp slt i32 %26, %6
  br i1 %63, label %64, label %130

; <label>:64:                                     ; preds = %60
  %65 = call fastcc i8* @scanformat(%struct.lua_State* %0, i8* nonnull %44, i8* nonnull %18)
  %66 = getelementptr inbounds i8, i8* %65, i64 1
  %67 = load i8, i8* %65, align 1, !tbaa !21
  %68 = sext i8 %67 to i32
  switch i32 %68, label %123 [
    i32 99, label %69
    i32 100, label %73
    i32 105, label %73
    i32 111, label %73
    i32 117, label %73
    i32 120, label %73
    i32 88, label %73
    i32 97, label %76
    i32 65, label %76
    i32 101, label %79
    i32 69, label %79
    i32 102, label %79
    i32 103, label %79
    i32 71, label %79
    i32 112, label %92
    i32 113, label %95
    i32 115, label %101
  ]

; <label>:69:                                     ; preds = %64
  %70 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %62)
  %71 = trunc i64 %70 to i32
  %72 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %61, i64 120, i8* nonnull %18, i32 %71) #7
  br label %125

; <label>:73:                                     ; preds = %64, %64, %64, %64, %64, %64
  %74 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %62)
  call fastcc void @addlenmod(i8* nonnull %18, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.554, i64 0, i64 0))
  %75 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %61, i64 120, i8* nonnull %18, i64 %74) #7
  br label %125

; <label>:76:                                     ; preds = %64, %64
  call fastcc void @addlenmod(i8* nonnull %18, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  %77 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %62)
  %78 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %61, i64 120, i8* nonnull %18, double %77) #7
  br label %125

; <label>:79:                                     ; preds = %64, %64, %64, %64, %64
  %80 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %62)
  %81 = load i8, i8* %65, align 1, !tbaa !21
  %82 = icmp ne i8 %81, 102
  %83 = call double @llvm.fabs.f64(double %80)
  %84 = fcmp ult double %83, 1.000000e+100
  %85 = or i1 %82, %84
  br i1 %85, label %88, label %86

; <label>:86:                                     ; preds = %79
  %87 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 418)
  br label %88

; <label>:88:                                     ; preds = %79, %86
  %89 = phi i8* [ %87, %86 ], [ %61, %79 ]
  %90 = phi i64 [ 418, %86 ], [ 120, %79 ]
  call fastcc void @addlenmod(i8* nonnull %18, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  %91 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %89, i64 %90, i8* nonnull %18, double %80) #7
  br label %125

; <label>:92:                                     ; preds = %64
  %93 = call i8* @lua_topointer(%struct.lua_State* %0, i32 %62)
  %94 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %61, i64 120, i8* nonnull %18, i8* %93) #7
  br label %125

; <label>:95:                                     ; preds = %64
  %96 = load i8, i8* %22, align 2, !tbaa !21
  %97 = icmp eq i8 %96, 0
  br i1 %97, label %100, label %98

; <label>:98:                                     ; preds = %95
  %99 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.555, i64 0, i64 0))
  unreachable

; <label>:100:                                    ; preds = %95
  call fastcc void @addliteral(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i32 %62)
  br label %125

; <label>:101:                                    ; preds = %64
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %23) #7
  %102 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %62, i64* nonnull %5)
  %103 = load i8, i8* %24, align 2, !tbaa !21
  %104 = icmp eq i8 %103, 0
  br i1 %104, label %105, label %106

; <label>:105:                                    ; preds = %101
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %3)
  br label %121

; <label>:106:                                    ; preds = %101
  %107 = load i64, i64* %5, align 8, !tbaa !113
  %108 = call i64 @strlen(i8* %102) #19
  %109 = icmp eq i64 %107, %108
  br i1 %109, label %112, label %110

; <label>:110:                                    ; preds = %106
  %111 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %62, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0))
  br label %112

; <label>:112:                                    ; preds = %110, %106
  %113 = call i8* @strchr(i8* nonnull %18, i32 46) #19
  %114 = icmp eq i8* %113, null
  %115 = load i64, i64* %5, align 8
  %116 = icmp ugt i64 %115, 99
  %117 = and i1 %114, %116
  br i1 %117, label %118, label %119

; <label>:118:                                    ; preds = %112
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %3)
  br label %121

; <label>:119:                                    ; preds = %112
  %120 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %61, i64 120, i8* nonnull %18, i8* %102) #7
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %121

; <label>:121:                                    ; preds = %118, %119, %105
  %122 = phi i32 [ 0, %105 ], [ 0, %118 ], [ %120, %119 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %23) #7
  br label %125

; <label>:123:                                    ; preds = %64
  %124 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.557, i64 0, i64 0), i8* nonnull %18)
  unreachable

; <label>:125:                                    ; preds = %69, %73, %76, %88, %92, %100, %121
  %126 = phi i32 [ %122, %121 ], [ 0, %100 ], [ %94, %92 ], [ %91, %88 ], [ %78, %76 ], [ %75, %73 ], [ %72, %69 ]
  %127 = sext i32 %126 to i64
  %128 = load i64, i64* %21, align 8, !tbaa !182
  %129 = add i64 %128, %127
  store i64 %129, i64* %21, align 8, !tbaa !182
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %18) #7
  br label %132

; <label>:130:                                    ; preds = %60
  %131 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %62, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i64 0, i64 0))
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %18) #7
  br label %137

; <label>:132:                                    ; preds = %125, %53, %36
  %133 = phi i8* [ %37, %36 ], [ %54, %53 ], [ %66, %125 ]
  %134 = phi i32 [ %26, %36 ], [ %26, %53 ], [ %62, %125 ]
  %135 = icmp ult i8* %133, %10
  br i1 %135, label %25, label %136

; <label>:136:                                    ; preds = %132, %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3)
  br label %137

; <label>:137:                                    ; preds = %130, %136
  %138 = phi i32 [ %131, %130 ], [ 1, %136 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret i32 %138
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %3)
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = call fastcc i64 @posrelatI(i64 %8, i64 %9)
  %11 = add i64 %10, -1
  call void @lua_settop(%struct.lua_State* %0, i32 2)
  %12 = call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 576, i32 0)
  %13 = load i64, i64* %2, align 8, !tbaa !113
  %14 = icmp ugt i64 %11, %13
  %15 = add i64 %13, 1
  %16 = select i1 %14, i64 %15, i64 %11
  %17 = getelementptr inbounds i8, i8* %12, i64 24
  %18 = bitcast i8* %17 to %struct.MatchState*
  %19 = load i64, i64* %3, align 8, !tbaa !113
  call fastcc void @prepstate(%struct.MatchState* nonnull %18, %struct.lua_State* %0, i8* %6, i64 %13, i8* %7, i64 %19)
  %20 = getelementptr inbounds i8, i8* %6, i64 %16
  %21 = bitcast i8* %12 to i8**
  store i8* %20, i8** %21, align 8, !tbaa !347
  %22 = getelementptr inbounds i8, i8* %12, i64 8
  %23 = bitcast i8* %22 to i8**
  store i8* %7, i8** %23, align 8, !tbaa !350
  %24 = getelementptr inbounds i8, i8* %12, i64 16
  %25 = bitcast i8* %24 to i8**
  store i8* null, i8** %25, align 8, !tbaa !351
  call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @gmatch_aux, i32 3)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_gsub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.MatchState, align 8
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %9 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %3)
  %10 = call i32 @lua_type(%struct.lua_State* %0, i32 3)
  %11 = load i64, i64* %2, align 8, !tbaa !113
  %12 = add i64 %11, 1
  %13 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 %12)
  %14 = load i8, i8* %9, align 1, !tbaa !21
  %15 = icmp eq i8 %14, 94
  %16 = bitcast %struct.MatchState* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %16) #7
  %17 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %17) #7
  %18 = add i32 %10, -3
  %19 = icmp ult i32 %18, 4
  br i1 %19, label %22, label %20

; <label>:20:                                     ; preds = %1
  %21 = call i32 @luaL_typeerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.569, i64 0, i64 0))
  br label %22

; <label>:22:                                     ; preds = %20, %1
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %5)
  br i1 %15, label %23, label %27

; <label>:23:                                     ; preds = %22
  %24 = getelementptr inbounds i8, i8* %9, i64 1
  %25 = load i64, i64* %3, align 8, !tbaa !113
  %26 = add i64 %25, -1
  store i64 %26, i64* %3, align 8, !tbaa !113
  br label %27

; <label>:27:                                     ; preds = %23, %22
  %28 = phi i8* [ %24, %23 ], [ %9, %22 ]
  %29 = load i64, i64* %2, align 8, !tbaa !113
  %30 = load i64, i64* %3, align 8, !tbaa !113
  call fastcc void @prepstate(%struct.MatchState* nonnull %4, %struct.lua_State* %0, i8* %8, i64 %29, i8* %28, i64 %30)
  %31 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %4, i64 0, i32 1
  %32 = icmp sgt i64 %13, 0
  br i1 %32, label %33, label %79

; <label>:33:                                     ; preds = %27
  %34 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %35 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %36 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %37 = xor i1 %15, true
  br label %38

; <label>:38:                                     ; preds = %67, %33
  %39 = phi i8* [ %8, %33 ], [ %71, %67 ]
  %40 = phi i32 [ 0, %33 ], [ %70, %67 ]
  %41 = phi i64 [ 0, %33 ], [ %69, %67 ]
  %42 = phi i8* [ null, %33 ], [ %68, %67 ]
  call fastcc void @reprepstate(%struct.MatchState* nonnull %4)
  %43 = call fastcc i8* @match(%struct.MatchState* nonnull %4, i8* %39, i8* %28)
  %44 = icmp eq i8* %43, null
  %45 = icmp eq i8* %43, %42
  %46 = or i1 %44, %45
  br i1 %46, label %51, label %47

; <label>:47:                                     ; preds = %38
  %48 = add nsw i64 %41, 1
  %49 = call fastcc i32 @add_value(%struct.MatchState* nonnull %4, %struct.luaL_Buffer* nonnull %5, i8* %39, i8* nonnull %43, i32 %10)
  %50 = or i32 %49, %40
  br label %67

; <label>:51:                                     ; preds = %38
  %52 = load i8*, i8** %31, align 8, !tbaa !352
  %53 = icmp ult i8* %39, %52
  br i1 %53, label %54, label %74

; <label>:54:                                     ; preds = %51
  %55 = load i64, i64* %34, align 8, !tbaa !182
  %56 = load i64, i64* %35, align 8, !tbaa !180
  %57 = icmp ult i64 %55, %56
  br i1 %57, label %60, label %58

; <label>:58:                                     ; preds = %54
  %59 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1)
  br label %60

; <label>:60:                                     ; preds = %58, %54
  %61 = getelementptr inbounds i8, i8* %39, i64 1
  %62 = load i8, i8* %39, align 1, !tbaa !21
  %63 = load i8*, i8** %36, align 8, !tbaa !183
  %64 = load i64, i64* %34, align 8, !tbaa !182
  %65 = add i64 %64, 1
  store i64 %65, i64* %34, align 8, !tbaa !182
  %66 = getelementptr inbounds i8, i8* %63, i64 %64
  store i8 %62, i8* %66, align 1, !tbaa !21
  br label %67

; <label>:67:                                     ; preds = %47, %60
  %68 = phi i8* [ %43, %47 ], [ %42, %60 ]
  %69 = phi i64 [ %48, %47 ], [ %41, %60 ]
  %70 = phi i32 [ %50, %47 ], [ %40, %60 ]
  %71 = phi i8* [ %43, %47 ], [ %61, %60 ]
  %72 = icmp slt i64 %69, %13
  %73 = and i1 %72, %37
  br i1 %73, label %38, label %74

; <label>:74:                                     ; preds = %51, %67
  %75 = phi i64 [ %41, %51 ], [ %69, %67 ]
  %76 = phi i32 [ %40, %51 ], [ %70, %67 ]
  %77 = phi i8* [ %39, %51 ], [ %71, %67 ]
  %78 = icmp eq i32 %76, 0
  br i1 %78, label %79, label %81

; <label>:79:                                     ; preds = %27, %74
  %80 = phi i64 [ %75, %74 ], [ 0, %27 ]
  call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  br label %87

; <label>:81:                                     ; preds = %74
  %82 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %4, i64 0, i32 1
  %83 = bitcast i8** %82 to i64*
  %84 = load i64, i64* %83, align 8, !tbaa !352
  %85 = ptrtoint i8* %77 to i64
  %86 = sub i64 %84, %85
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %5, i8* %77, i64 %86)
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5)
  br label %87

; <label>:87:                                     ; preds = %81, %79
  %88 = phi i64 [ %75, %81 ], [ %80, %79 ]
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %88)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %17) #7
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %16) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 2
}

; Function Attrs: nounwind uwtable
define internal i32 @str_len(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = load i64, i64* %2, align 8, !tbaa !113
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %5)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_lower(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %7 = load i64, i64* %2, align 8, !tbaa !113
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %26, label %11

; <label>:11:                                     ; preds = %1
  %12 = tail call i32** @__ctype_tolower_loc() #21
  br label %13

; <label>:13:                                     ; preds = %11, %13
  %14 = phi i64 [ 0, %11 ], [ %23, %13 ]
  %15 = load i32*, i32** %12, align 8, !tbaa !79
  %16 = getelementptr inbounds i8, i8* %6, i64 %14
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  %19 = getelementptr inbounds i32, i32* %15, i64 %18
  %20 = load i32, i32* %19, align 4, !tbaa !70
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds i8, i8* %8, i64 %14
  store i8 %21, i8* %22, align 1, !tbaa !21
  %23 = add nuw i64 %14, 1
  %24 = load i64, i64* %2, align 8, !tbaa !113
  %25 = icmp ult i64 %23, %24
  br i1 %25, label %13, label %26

; <label>:26:                                     ; preds = %13, %1
  %27 = phi i64 [ 0, %1 ], [ %24, %13 ]
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %27)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_match(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 0)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @str_rep(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %8 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %9 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3)
  %10 = icmp slt i64 %8, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %1
  %12 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  br label %49

; <label>:13:                                     ; preds = %1
  %14 = load i64, i64* %2, align 8, !tbaa !113
  %15 = load i64, i64* %3, align 8, !tbaa !113
  %16 = add i64 %15, %14
  %17 = icmp ult i64 %16, %14
  br i1 %17, label %21, label %18

; <label>:18:                                     ; preds = %13
  %19 = udiv i64 2147483647, %8
  %20 = icmp ugt i64 %16, %19
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %18, %13
  %22 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.572, i64 0, i64 0))
  unreachable

; <label>:23:                                     ; preds = %18
  %24 = mul i64 %14, %8
  %25 = add nsw i64 %8, -1
  %26 = mul i64 %15, %25
  %27 = add i64 %26, %24
  %28 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %28) #7
  %29 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %4, i64 %27)
  %30 = icmp sgt i64 %8, 1
  %31 = load i64, i64* %2, align 8, !tbaa !113
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %29, i8* %7, i64 %31, i32 1, i1 false)
  br i1 %30, label %32, label %48

; <label>:32:                                     ; preds = %23
  br label %33

; <label>:33:                                     ; preds = %32, %44
  %34 = phi i64 [ %36, %44 ], [ %8, %32 ]
  %35 = phi i8* [ %45, %44 ], [ %29, %32 ]
  %36 = add nsw i64 %34, -1
  %37 = load i64, i64* %2, align 8, !tbaa !113
  %38 = getelementptr inbounds i8, i8* %35, i64 %37
  %39 = load i64, i64* %3, align 8, !tbaa !113
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %44, label %41

; <label>:41:                                     ; preds = %33
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %38, i8* %9, i64 %39, i32 1, i1 false)
  %42 = load i64, i64* %3, align 8, !tbaa !113
  %43 = getelementptr inbounds i8, i8* %38, i64 %42
  br label %44

; <label>:44:                                     ; preds = %33, %41
  %45 = phi i8* [ %43, %41 ], [ %38, %33 ]
  %46 = icmp sgt i64 %34, 2
  %47 = load i64, i64* %2, align 8, !tbaa !113
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %7, i64 %47, i32 1, i1 false)
  br i1 %46, label %33, label %48

; <label>:48:                                     ; preds = %44, %23
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %4, i64 %27)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %28) #7
  br label %49

; <label>:49:                                     ; preds = %11, %48
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_reverse(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %7 = load i64, i64* %2, align 8, !tbaa !113
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %23, label %11

; <label>:11:                                     ; preds = %1
  br label %12

; <label>:12:                                     ; preds = %11, %12
  %13 = phi i64 [ %21, %12 ], [ %9, %11 ]
  %14 = phi i64 [ %20, %12 ], [ 0, %11 ]
  %15 = xor i64 %14, -1
  %16 = add i64 %13, %15
  %17 = getelementptr inbounds i8, i8* %6, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = getelementptr inbounds i8, i8* %8, i64 %14
  store i8 %18, i8* %19, align 1, !tbaa !21
  %20 = add i64 %14, 1
  %21 = load i64, i64* %2, align 8, !tbaa !113
  %22 = icmp ugt i64 %21, %20
  br i1 %22, label %12, label %23

; <label>:23:                                     ; preds = %12, %1
  %24 = phi i64 [ 0, %1 ], [ %21, %12 ]
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %24)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_sub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %6 = load i64, i64* %2, align 8, !tbaa !113
  %7 = call fastcc i64 @posrelatI(i64 %5, i64 %6)
  %8 = call fastcc i64 @getendpos(%struct.lua_State* %0, i64 -1, i64 %6)
  %9 = icmp ult i64 %8, %7
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds i8, i8* %4, i64 %7
  %12 = getelementptr inbounds i8, i8* %11, i64 -1
  %13 = sub i64 1, %7
  %14 = add i64 %13, %8
  %15 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* nonnull %12, i64 %14)
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0))
  br label %18

; <label>:18:                                     ; preds = %16, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_upper(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %7 = load i64, i64* %2, align 8, !tbaa !113
  %8 = call i8* @luaL_buffinitsize(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %3, i64 %7)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %26, label %11

; <label>:11:                                     ; preds = %1
  %12 = tail call i32** @__ctype_toupper_loc() #21
  br label %13

; <label>:13:                                     ; preds = %11, %13
  %14 = phi i64 [ 0, %11 ], [ %23, %13 ]
  %15 = load i32*, i32** %12, align 8, !tbaa !79
  %16 = getelementptr inbounds i8, i8* %6, i64 %14
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i64
  %19 = getelementptr inbounds i32, i32* %15, i64 %18
  %20 = load i32, i32* %19, align 4, !tbaa !70
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds i8, i8* %8, i64 %14
  store i8 %21, i8* %22, align 1, !tbaa !21
  %23 = add nuw i64 %14, 1
  %24 = load i64, i64* %2, align 8, !tbaa !113
  %25 = icmp ult i64 %23, %24
  br i1 %25, label %13, label %26

; <label>:26:                                     ; preds = %13, %1
  %27 = phi i64 [ 0, %1 ], [ %24, %13 ]
  call void @luaL_pushresultsize(%struct.luaL_Buffer* nonnull %3, i64 %27)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_pack(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca %struct.Header, align 8
  %4 = alloca i8*, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %11) #7
  %12 = bitcast %struct.Header* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %12) #7
  %13 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %13) #7
  %14 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %14, i8** %4, align 8, !tbaa !79
  call fastcc void @initheader(%struct.lua_State* %0, %struct.Header* nonnull %3)
  tail call void @lua_pushnil(%struct.lua_State* %0)
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2)
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %200, label %17

; <label>:17:                                     ; preds = %1
  %18 = bitcast i32* %5 to i8*
  %19 = bitcast i32* %6 to i8*
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %21 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  %23 = bitcast %union.Ftypes* %7 to i8*
  %24 = bitcast i64* %8 to i8*
  %25 = bitcast i64* %9 to i8*
  %26 = bitcast i64* %10 to i8*
  %27 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %29 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  %30 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  %31 = bitcast %union.Ftypes* %7 to float*
  %32 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %34 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  %35 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  %36 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %37 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %38 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  %39 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %40 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %41 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  %42 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  br label %43

; <label>:43:                                     ; preds = %17, %194
  %44 = phi i32 [ 1, %17 ], [ %196, %194 ]
  %45 = phi i64 [ 0, %17 ], [ %195, %194 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %18) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %19) #7
  %46 = call fastcc i32 @getdetails(%struct.Header* nonnull %3, i64 %45, i8** nonnull %4, i32* nonnull %5, i32* nonnull %6)
  %47 = load i32, i32* %6, align 4, !tbaa !70
  %48 = load i32, i32* %5, align 4, !tbaa !70
  %49 = add nsw i32 %48, %47
  %50 = sext i32 %49 to i64
  %51 = add i64 %45, %50
  %52 = add nsw i32 %47, -1
  store i32 %52, i32* %6, align 4, !tbaa !70
  %53 = icmp sgt i32 %47, 0
  br i1 %53, label %54, label %71

; <label>:54:                                     ; preds = %43
  %55 = load i32, i32* %6, align 4, !tbaa !70
  br label %56

; <label>:56:                                     ; preds = %54, %63
  %57 = phi i32 [ %55, %54 ], [ %68, %63 ]
  %58 = load i64, i64* %20, align 8, !tbaa !182
  %59 = load i64, i64* %21, align 8, !tbaa !180
  %60 = icmp ult i64 %58, %59
  br i1 %60, label %63, label %61

; <label>:61:                                     ; preds = %56
  %62 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1)
  br label %63

; <label>:63:                                     ; preds = %61, %56
  %64 = load i8*, i8** %22, align 8, !tbaa !183
  %65 = load i64, i64* %20, align 8, !tbaa !182
  %66 = add i64 %65, 1
  store i64 %66, i64* %20, align 8, !tbaa !182
  %67 = getelementptr inbounds i8, i8* %64, i64 %65
  store i8 0, i8* %67, align 1, !tbaa !21
  %68 = add nsw i32 %57, -1
  %69 = icmp sgt i32 %57, 0
  br i1 %69, label %56, label %70

; <label>:70:                                     ; preds = %63
  store i32 %68, i32* %6, align 4, !tbaa !70
  br label %71

; <label>:71:                                     ; preds = %70, %43
  %72 = add nsw i32 %44, 1
  switch i32 %46, label %194 [
    i32 0, label %73
    i32 1, label %91
    i32 2, label %103
    i32 3, label %115
    i32 4, label %143
    i32 5, label %160
    i32 6, label %182
    i32 7, label %193
    i32 8, label %193
  ]

; <label>:73:                                     ; preds = %71
  %74 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %72)
  %75 = icmp slt i32 %48, 8
  br i1 %75, label %76, label %87

; <label>:76:                                     ; preds = %73
  %77 = shl i32 %48, 3
  %78 = add nsw i32 %77, -1
  %79 = zext i32 %78 to i64
  %80 = shl i64 1, %79
  %81 = sub nsw i64 0, %80
  %82 = icmp sge i64 %74, %81
  %83 = icmp slt i64 %74, %80
  %84 = and i1 %82, %83
  br i1 %84, label %87, label %85

; <label>:85:                                     ; preds = %76
  %86 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %72, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0))
  br label %87

; <label>:87:                                     ; preds = %85, %76, %73
  %88 = load i32, i32* %29, align 8, !tbaa !353
  %89 = lshr i64 %74, 63
  %90 = trunc i64 %89 to i32
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %74, i32 %88, i32 %48, i32 %90)
  br label %194

; <label>:91:                                     ; preds = %71
  %92 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %72)
  %93 = icmp slt i32 %48, 8
  br i1 %93, label %94, label %101

; <label>:94:                                     ; preds = %91
  %95 = shl nsw i32 %48, 3
  %96 = zext i32 %95 to i64
  %97 = shl i64 1, %96
  %98 = icmp ult i64 %92, %97
  br i1 %98, label %101, label %99

; <label>:99:                                     ; preds = %94
  %100 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %72, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.573, i64 0, i64 0))
  br label %101

; <label>:101:                                    ; preds = %94, %99, %91
  %102 = load i32, i32* %30, align 8, !tbaa !353
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %92, i32 %102, i32 %48, i32 0)
  br label %194

; <label>:103:                                    ; preds = %71
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %23) #7
  %104 = sext i32 %48 to i64
  %105 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %104)
  %106 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %72)
  %107 = icmp eq i32 %48, 4
  br i1 %107, label %108, label %110

; <label>:108:                                    ; preds = %103
  %109 = fptrunc double %106 to float
  store volatile float %109, float* %31, align 8, !tbaa !21
  br label %111

; <label>:110:                                    ; preds = %103
  store volatile double %106, double* %34, align 8, !tbaa !21
  br label %111

; <label>:111:                                    ; preds = %110, %108
  %112 = load i32, i32* %32, align 8, !tbaa !353
  call fastcc void @copywithendian(i8* %105, i8* nonnull %23, i32 %48, i32 %112)
  %113 = load i64, i64* %33, align 8, !tbaa !182
  %114 = add i64 %113, %104
  store i64 %114, i64* %33, align 8, !tbaa !182
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %23) #7
  br label %194

; <label>:115:                                    ; preds = %71
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %24) #7
  %116 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %72, i64* nonnull %8)
  %117 = load i64, i64* %8, align 8, !tbaa !113
  %118 = sext i32 %48 to i64
  %119 = icmp ugt i64 %117, %118
  br i1 %119, label %120, label %122

; <label>:120:                                    ; preds = %115
  %121 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %72, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.574, i64 0, i64 0))
  br label %122

; <label>:122:                                    ; preds = %115, %120
  %123 = load i64, i64* %8, align 8, !tbaa !113
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %116, i64 %123)
  %124 = load i64, i64* %8, align 8, !tbaa !113
  %125 = add i64 %124, 1
  store i64 %125, i64* %8, align 8, !tbaa !113
  %126 = icmp ult i64 %124, %118
  br i1 %126, label %127, label %142

; <label>:127:                                    ; preds = %122
  br label %128

; <label>:128:                                    ; preds = %127, %134
  %129 = load i64, i64* %39, align 8, !tbaa !182
  %130 = load i64, i64* %40, align 8, !tbaa !180
  %131 = icmp ult i64 %129, %130
  br i1 %131, label %134, label %132

; <label>:132:                                    ; preds = %128
  %133 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1)
  br label %134

; <label>:134:                                    ; preds = %132, %128
  %135 = load i8*, i8** %41, align 8, !tbaa !183
  %136 = load i64, i64* %39, align 8, !tbaa !182
  %137 = add i64 %136, 1
  store i64 %137, i64* %39, align 8, !tbaa !182
  %138 = getelementptr inbounds i8, i8* %135, i64 %136
  store i8 0, i8* %138, align 1, !tbaa !21
  %139 = load i64, i64* %8, align 8, !tbaa !113
  %140 = add i64 %139, 1
  store i64 %140, i64* %8, align 8, !tbaa !113
  %141 = icmp ult i64 %139, %118
  br i1 %141, label %128, label %142

; <label>:142:                                    ; preds = %134, %122
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %24) #7
  br label %194

; <label>:143:                                    ; preds = %71
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %25) #7
  %144 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %72, i64* nonnull %9)
  %145 = icmp sgt i32 %48, 7
  br i1 %145, label %154, label %146

; <label>:146:                                    ; preds = %143
  %147 = load i64, i64* %9, align 8, !tbaa !113
  %148 = shl nsw i32 %48, 3
  %149 = zext i32 %148 to i64
  %150 = shl i64 1, %149
  %151 = icmp ult i64 %147, %150
  br i1 %151, label %154, label %152

; <label>:152:                                    ; preds = %146
  %153 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %72, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.575, i64 0, i64 0))
  br label %154

; <label>:154:                                    ; preds = %152, %146, %143
  %155 = load i64, i64* %9, align 8, !tbaa !113
  %156 = load i32, i32* %35, align 8, !tbaa !353
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %155, i32 %156, i32 %48, i32 0)
  %157 = load i64, i64* %9, align 8, !tbaa !113
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %144, i64 %157)
  %158 = load i64, i64* %9, align 8, !tbaa !113
  %159 = add i64 %158, %51
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %25) #7
  br label %194

; <label>:160:                                    ; preds = %71
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %26) #7
  %161 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %72, i64* nonnull %10)
  %162 = call i64 @strlen(i8* %161) #19
  %163 = load i64, i64* %10, align 8, !tbaa !113
  %164 = icmp eq i64 %162, %163
  br i1 %164, label %167, label %165

; <label>:165:                                    ; preds = %160
  %166 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %72, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0))
  br label %167

; <label>:167:                                    ; preds = %165, %160
  %168 = load i64, i64* %10, align 8, !tbaa !113
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %161, i64 %168)
  %169 = load i64, i64* %36, align 8, !tbaa !182
  %170 = load i64, i64* %37, align 8, !tbaa !180
  %171 = icmp ult i64 %169, %170
  br i1 %171, label %174, label %172

; <label>:172:                                    ; preds = %167
  %173 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1)
  br label %174

; <label>:174:                                    ; preds = %172, %167
  %175 = load i8*, i8** %42, align 8, !tbaa !183
  %176 = load i64, i64* %36, align 8, !tbaa !182
  %177 = add i64 %176, 1
  store i64 %177, i64* %36, align 8, !tbaa !182
  %178 = getelementptr inbounds i8, i8* %175, i64 %176
  store i8 0, i8* %178, align 1, !tbaa !21
  %179 = load i64, i64* %10, align 8, !tbaa !113
  %180 = add i64 %51, 1
  %181 = add i64 %180, %179
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %26) #7
  br label %194

; <label>:182:                                    ; preds = %71
  %183 = load i64, i64* %27, align 8, !tbaa !182
  %184 = load i64, i64* %28, align 8, !tbaa !180
  %185 = icmp ult i64 %183, %184
  br i1 %185, label %188, label %186

; <label>:186:                                    ; preds = %182
  %187 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1)
  br label %188

; <label>:188:                                    ; preds = %186, %182
  %189 = load i8*, i8** %38, align 8, !tbaa !183
  %190 = load i64, i64* %27, align 8, !tbaa !182
  %191 = add i64 %190, 1
  store i64 %191, i64* %27, align 8, !tbaa !182
  %192 = getelementptr inbounds i8, i8* %189, i64 %190
  store i8 0, i8* %192, align 1, !tbaa !21
  br label %193

; <label>:193:                                    ; preds = %71, %71, %188
  br label %194

; <label>:194:                                    ; preds = %71, %193, %174, %154, %142, %111, %101, %87
  %195 = phi i64 [ %51, %71 ], [ %51, %193 ], [ %181, %174 ], [ %159, %154 ], [ %51, %142 ], [ %51, %111 ], [ %51, %101 ], [ %51, %87 ]
  %196 = phi i32 [ %72, %71 ], [ %44, %193 ], [ %72, %174 ], [ %72, %154 ], [ %72, %142 ], [ %72, %111 ], [ %72, %101 ], [ %72, %87 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %19) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %18) #7
  %197 = load i8*, i8** %4, align 8, !tbaa !79
  %198 = load i8, i8* %197, align 1, !tbaa !21
  %199 = icmp eq i8 %198, 0
  br i1 %199, label %200, label %43

; <label>:200:                                    ; preds = %194, %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %11) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_packsize(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %8, i8** %3, align 8, !tbaa !79
  call fastcc void @initheader(%struct.lua_State* %0, %struct.Header* nonnull %2)
  %9 = load i8, i8* %8, align 1, !tbaa !21
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %35, label %11

; <label>:11:                                     ; preds = %1
  %12 = bitcast i32* %4 to i8*
  %13 = bitcast i32* %5 to i8*
  br label %14

; <label>:14:                                     ; preds = %11, %30
  %15 = phi i64 [ 0, %11 ], [ %31, %30 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %13) #7
  %16 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %15, i8** nonnull %3, i32* nonnull %4, i32* nonnull %5)
  %17 = or i32 %16, 1
  %18 = icmp eq i32 %17, 5
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %14
  %20 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.581, i64 0, i64 0))
  br label %21

; <label>:21:                                     ; preds = %14, %19
  %22 = load i32, i32* %5, align 4, !tbaa !70
  %23 = load i32, i32* %4, align 4, !tbaa !70
  %24 = add nsw i32 %23, %22
  store i32 %24, i32* %4, align 4, !tbaa !70
  %25 = sext i32 %24 to i64
  %26 = sub nsw i64 2147483647, %25
  %27 = icmp ugt i64 %15, %26
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %21
  %29 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.582, i64 0, i64 0))
  br label %30

; <label>:30:                                     ; preds = %21, %28
  %31 = add i64 %15, %25
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #7
  %32 = load i8*, i8** %3, align 8, !tbaa !79
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %35, label %14

; <label>:35:                                     ; preds = %30, %1
  %36 = phi i64 [ 0, %1 ], [ %31, %30 ]
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %36)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @str_unpack(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i64, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  store i8* %10, i8** %3, align 8, !tbaa !79
  %11 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %11) #7
  %12 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4)
  %13 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1)
  %14 = load i64, i64* %4, align 8, !tbaa !113
  %15 = call fastcc i64 @posrelatI(i64 %13, i64 %14)
  %16 = add i64 %15, -1
  %17 = icmp ugt i64 %16, %14
  br i1 %17, label %18, label %20

; <label>:18:                                     ; preds = %1
  %19 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0))
  br label %20

; <label>:20:                                     ; preds = %1, %18
  call fastcc void @initheader(%struct.lua_State* %0, %struct.Header* nonnull %2)
  %21 = load i8*, i8** %3, align 8, !tbaa !79
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %106, label %24

; <label>:24:                                     ; preds = %20
  %25 = bitcast i32* %5 to i8*
  %26 = bitcast i32* %6 to i8*
  %27 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  %28 = bitcast %union.Ftypes* %7 to i8*
  %29 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  %30 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  %31 = bitcast %union.Ftypes* %7 to float*
  %32 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  br label %33

; <label>:33:                                     ; preds = %24, %99
  %34 = phi i64 [ %16, %24 ], [ %102, %99 ]
  %35 = phi i32 [ 0, %24 ], [ %100, %99 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %25) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %26) #7
  %36 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %34, i8** nonnull %3, i32* nonnull %5, i32* nonnull %6)
  %37 = load i32, i32* %6, align 4, !tbaa !70
  %38 = sext i32 %37 to i64
  %39 = load i32, i32* %5, align 4, !tbaa !70
  %40 = sext i32 %39 to i64
  %41 = add nsw i64 %40, %38
  %42 = load i64, i64* %4, align 8, !tbaa !113
  %43 = sub i64 %42, %34
  %44 = icmp ugt i64 %41, %43
  br i1 %44, label %45, label %47

; <label>:45:                                     ; preds = %33
  %46 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0))
  br label %47

; <label>:47:                                     ; preds = %33, %45
  %48 = add i64 %34, %38
  call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.585, i64 0, i64 0))
  %49 = add nsw i32 %35, 1
  switch i32 %36, label %99 [
    i32 0, label %50
    i32 1, label %50
    i32 2, label %56
    i32 3, label %67
    i32 4, label %70
    i32 5, label %84
    i32 7, label %98
    i32 6, label %98
    i32 8, label %98
  ]

; <label>:50:                                     ; preds = %47, %47
  %51 = getelementptr inbounds i8, i8* %12, i64 %48
  %52 = load i32, i32* %27, align 8, !tbaa !353
  %53 = icmp eq i32 %36, 0
  %54 = zext i1 %53 to i32
  %55 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %51, i32 %52, i32 %39, i32 %54)
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %55)
  br label %99

; <label>:56:                                     ; preds = %47
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %28) #7
  %57 = getelementptr inbounds i8, i8* %12, i64 %48
  %58 = load i32, i32* %29, align 8, !tbaa !353
  call fastcc void @copywithendian(i8* nonnull %28, i8* %57, i32 %39, i32 %58)
  %59 = icmp eq i32 %39, 4
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %56
  %61 = load volatile float, float* %31, align 8, !tbaa !21
  %62 = fpext float %61 to double
  br label %65

; <label>:63:                                     ; preds = %56
  %64 = load volatile double, double* %32, align 8, !tbaa !21
  br label %65

; <label>:65:                                     ; preds = %63, %60
  %66 = phi double [ %62, %60 ], [ %64, %63 ]
  call void @lua_pushnumber(%struct.lua_State* %0, double %66)
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %28) #7
  br label %99

; <label>:67:                                     ; preds = %47
  %68 = getelementptr inbounds i8, i8* %12, i64 %48
  %69 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %68, i64 %40)
  br label %99

; <label>:70:                                     ; preds = %47
  %71 = getelementptr inbounds i8, i8* %12, i64 %48
  %72 = load i32, i32* %30, align 8, !tbaa !353
  %73 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %71, i32 %72, i32 %39, i32 0)
  %74 = load i64, i64* %4, align 8, !tbaa !113
  %75 = add i64 %48, %40
  %76 = sub i64 %74, %75
  %77 = icmp ugt i64 %73, %76
  br i1 %77, label %78, label %80

; <label>:78:                                     ; preds = %70
  %79 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0))
  br label %80

; <label>:80:                                     ; preds = %70, %78
  %81 = getelementptr inbounds i8, i8* %71, i64 %40
  %82 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %81, i64 %73)
  %83 = add i64 %73, %48
  br label %99

; <label>:84:                                     ; preds = %47
  %85 = getelementptr inbounds i8, i8* %12, i64 %48
  %86 = call i64 @strlen(i8* %85) #19
  %87 = shl i64 %86, 32
  %88 = ashr exact i64 %87, 32
  %89 = add i64 %88, %48
  %90 = load i64, i64* %4, align 8, !tbaa !113
  %91 = icmp ult i64 %89, %90
  br i1 %91, label %94, label %92

; <label>:92:                                     ; preds = %84
  %93 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.586, i64 0, i64 0))
  br label %94

; <label>:94:                                     ; preds = %92, %84
  %95 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %85, i64 %88)
  %96 = add i64 %88, %48
  %97 = add i64 %96, 1
  br label %99

; <label>:98:                                     ; preds = %47, %47, %47
  br label %99

; <label>:99:                                     ; preds = %47, %98, %94, %80, %67, %65, %50
  %100 = phi i32 [ %49, %47 ], [ %35, %98 ], [ %49, %94 ], [ %49, %80 ], [ %49, %67 ], [ %49, %65 ], [ %49, %50 ]
  %101 = phi i64 [ %48, %47 ], [ %48, %98 ], [ %97, %94 ], [ %83, %80 ], [ %48, %67 ], [ %48, %65 ], [ %48, %50 ]
  %102 = add i64 %101, %40
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %26) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %25) #7
  %103 = load i8*, i8** %3, align 8, !tbaa !79
  %104 = load i8, i8* %103, align 1, !tbaa !21
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %106, label %33

; <label>:106:                                    ; preds = %99, %20
  %107 = phi i32 [ 0, %20 ], [ %100, %99 ]
  %108 = phi i64 [ %16, %20 ], [ %102, %99 ]
  %109 = add i64 %108, 1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %109)
  %110 = add nsw i32 %107, 1
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %110
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i64 @posrelatI(i64, i64) unnamed_addr #6 {
  %3 = icmp sgt i64 %0, 0
  br i1 %3, label %12, label %4

; <label>:4:                                      ; preds = %2
  %5 = icmp eq i64 %0, 0
  %6 = sub nsw i64 0, %1
  %7 = icmp sgt i64 %6, %0
  %8 = or i1 %5, %7
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %4
  %10 = add i64 %0, 1
  %11 = add i64 %10, %1
  br label %12

; <label>:12:                                     ; preds = %4, %2, %9
  %13 = phi i64 [ %11, %9 ], [ %0, %2 ], [ 1, %4 ]
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @getendpos(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %1)
  %5 = icmp sgt i64 %4, %2
  br i1 %5, label %14, label %6

; <label>:6:                                      ; preds = %3
  %7 = icmp sgt i64 %4, -1
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %6
  %9 = sub nsw i64 0, %2
  %10 = icmp slt i64 %4, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %8
  %12 = add i64 %2, 1
  %13 = add i64 %12, %4
  br label %14

; <label>:14:                                     ; preds = %8, %6, %3, %11
  %15 = phi i64 [ %13, %11 ], [ %2, %3 ], [ %4, %6 ], [ 0, %8 ]
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @writer(%struct.lua_State* nocapture readnone, i8* nocapture readonly, i64, i8*) #0 {
  %5 = bitcast i8* %3 to %struct.luaL_Buffer*
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %5, i8* %1, i64 %2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @str_find_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.MatchState, align 8
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3)
  %9 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4)
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1)
  %11 = load i64, i64* %3, align 8, !tbaa !113
  %12 = call fastcc i64 @posrelatI(i64 %10, i64 %11)
  %13 = add i64 %12, -1
  %14 = icmp ult i64 %11, %13
  br i1 %14, label %15, label %16

; <label>:15:                                     ; preds = %2
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %76

; <label>:16:                                     ; preds = %2
  %17 = icmp ne i32 %1, 0
  br i1 %17, label %18, label %38

; <label>:18:                                     ; preds = %16
  %19 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4)
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %18
  %22 = load i64, i64* %4, align 8, !tbaa !113
  %23 = call fastcc i32 @nospecials(i8* %9, i64 %22)
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %38, label %25

; <label>:25:                                     ; preds = %21, %18
  %26 = getelementptr inbounds i8, i8* %8, i64 %13
  %27 = sub i64 %11, %13
  %28 = load i64, i64* %4, align 8, !tbaa !113
  %29 = call fastcc i8* @lmemfind(i8* %26, i64 %27, i8* %9, i64 %28)
  %30 = icmp eq i8* %29, null
  br i1 %30, label %75, label %31

; <label>:31:                                     ; preds = %25
  %32 = ptrtoint i8* %29 to i64
  %33 = ptrtoint i8* %8 to i64
  %34 = sub i64 %32, %33
  %35 = add nsw i64 %34, 1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %35)
  %36 = load i64, i64* %4, align 8, !tbaa !113
  %37 = add i64 %36, %34
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %37)
  br label %76

; <label>:38:                                     ; preds = %21, %16
  %39 = bitcast %struct.MatchState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %39) #7
  %40 = getelementptr inbounds i8, i8* %8, i64 %13
  %41 = load i8, i8* %9, align 1, !tbaa !21
  %42 = icmp eq i8 %41, 94
  br i1 %42, label %43, label %47

; <label>:43:                                     ; preds = %38
  %44 = getelementptr inbounds i8, i8* %9, i64 1
  %45 = load i64, i64* %4, align 8, !tbaa !113
  %46 = add i64 %45, -1
  store i64 %46, i64* %4, align 8, !tbaa !113
  br label %47

; <label>:47:                                     ; preds = %43, %38
  %48 = phi i8* [ %44, %43 ], [ %9, %38 ]
  %49 = load i64, i64* %4, align 8, !tbaa !113
  call fastcc void @prepstate(%struct.MatchState* nonnull %5, %struct.lua_State* %0, i8* %8, i64 %11, i8* nonnull %48, i64 %49)
  %50 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 1
  br label %51

; <label>:51:                                     ; preds = %70, %47
  %52 = phi i8* [ %40, %47 ], [ %71, %70 ]
  call fastcc void @reprepstate(%struct.MatchState* nonnull %5)
  %53 = call fastcc i8* @match(%struct.MatchState* nonnull %5, i8* %52, i8* %48)
  %54 = icmp eq i8* %53, null
  br i1 %54, label %67, label %55

; <label>:55:                                     ; preds = %51
  br i1 %17, label %56, label %65

; <label>:56:                                     ; preds = %55
  %57 = ptrtoint i8* %52 to i64
  %58 = ptrtoint i8* %8 to i64
  %59 = sub i64 1, %58
  %60 = add i64 %59, %57
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %60)
  %61 = ptrtoint i8* %53 to i64
  %62 = sub i64 %61, %58
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %62)
  %63 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* null, i8* null)
  %64 = add nsw i32 %63, 2
  br label %73

; <label>:65:                                     ; preds = %55
  %66 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* %52, i8* nonnull %53)
  br label %73

; <label>:67:                                     ; preds = %51
  %68 = load i8*, i8** %50, align 8, !tbaa !352
  %69 = icmp ult i8* %52, %68
  br i1 %69, label %70, label %72

; <label>:70:                                     ; preds = %67
  %71 = getelementptr inbounds i8, i8* %52, i64 1
  br i1 %42, label %72, label %51

; <label>:72:                                     ; preds = %70, %67
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %39) #7
  br label %75

; <label>:73:                                     ; preds = %56, %65
  %74 = phi i32 [ %66, %65 ], [ %64, %56 ]
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %39) #7
  br label %76

; <label>:75:                                     ; preds = %72, %25
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %76

; <label>:76:                                     ; preds = %73, %31, %75, %15
  %77 = phi i32 [ 1, %15 ], [ 1, %75 ], [ %74, %73 ], [ 2, %31 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 %77
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @nospecials(i8* readonly, i64) unnamed_addr #14 {
  br label %3

; <label>:3:                                      ; preds = %8, %2
  %4 = phi i64 [ 0, %2 ], [ %11, %8 ]
  %5 = getelementptr inbounds i8, i8* %0, i64 %4
  %6 = tail call i8* @strpbrk(i8* %5, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.544, i64 0, i64 0)) #19
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %3
  %9 = tail call i64 @strlen(i8* %5) #19
  %10 = add i64 %4, 1
  %11 = add i64 %10, %9
  %12 = icmp ugt i64 %11, %1
  br i1 %12, label %13, label %3

; <label>:13:                                     ; preds = %8, %3
  %14 = phi i32 [ 0, %3 ], [ 1, %8 ]
  ret i32 %14
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i8* @lmemfind(i8*, i64, i8* nocapture readonly, i64) unnamed_addr #14 {
  %5 = icmp eq i64 %3, 0
  br i1 %5, label %31, label %6

; <label>:6:                                      ; preds = %4
  %7 = icmp ugt i64 %3, %1
  br i1 %7, label %31, label %8

; <label>:8:                                      ; preds = %6
  %9 = add i64 %3, -1
  %10 = sub i64 %1, %9
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %31, label %12

; <label>:12:                                     ; preds = %8
  %13 = load i8, i8* %2, align 1, !tbaa !21
  %14 = sext i8 %13 to i32
  %15 = getelementptr inbounds i8, i8* %2, i64 1
  br label %16

; <label>:16:                                     ; preds = %12, %25
  %17 = phi i64 [ %10, %12 ], [ %29, %25 ]
  %18 = phi i8* [ %0, %12 ], [ %22, %25 ]
  %19 = tail call i8* @memchr(i8* %18, i32 %14, i64 %17) #19
  %20 = icmp eq i8* %19, null
  br i1 %20, label %31, label %21

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds i8, i8* %19, i64 1
  %23 = tail call i32 @memcmp(i8* nonnull %22, i8* nonnull %15, i64 %9) #19
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %31, label %25

; <label>:25:                                     ; preds = %21
  %26 = ptrtoint i8* %22 to i64
  %27 = ptrtoint i8* %18 to i64
  %28 = add i64 %17, %27
  %29 = sub i64 %28, %26
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %31, label %16

; <label>:31:                                     ; preds = %25, %16, %21, %8, %6, %4
  %32 = phi i8* [ %0, %4 ], [ null, %6 ], [ null, %8 ], [ null, %25 ], [ null, %16 ], [ %19, %21 ]
  ret i8* %32
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @prepstate(%struct.MatchState* nocapture, %struct.lua_State*, i8*, i64, i8*, i64) unnamed_addr #2 {
  %7 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  store %struct.lua_State* %1, %struct.lua_State** %7, align 8, !tbaa !355
  %8 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 4
  store i32 200, i32* %8, align 8, !tbaa !356
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 0
  store i8* %2, i8** %9, align 8, !tbaa !357
  %10 = getelementptr inbounds i8, i8* %2, i64 %3
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  store i8* %10, i8** %11, align 8, !tbaa !352
  %12 = getelementptr inbounds i8, i8* %4, i64 %5
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  store i8* %12, i8** %13, align 8, !tbaa !358
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @reprepstate(%struct.MatchState* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  store i8 0, i8* %2, align 4, !tbaa !359
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @match(%struct.MatchState* nocapture, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !356
  %6 = add nsw i32 %5, -1
  store i32 %6, i32* %4, align 8, !tbaa !356
  %7 = icmp eq i32 %5, 0
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !355
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.545, i64 0, i64 0))
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %14 = load i8*, i8** %13, align 8, !tbaa !358
  %15 = icmp eq i8* %14, %2
  br i1 %15, label %121, label %16

; <label>:16:                                     ; preds = %12
  %17 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %16, %116
  %19 = phi i8* [ %14, %16 ], [ %119, %116 ]
  %20 = phi i8* [ %1, %16 ], [ %118, %116 ]
  %21 = phi i8* [ %2, %16 ], [ %117, %116 ]
  %22 = getelementptr inbounds i8, i8* %20, i64 -1
  br label %26

; <label>:23:                                     ; preds = %81
  %24 = load i8*, i8** %13, align 8, !tbaa !358
  %25 = icmp eq i8* %70, %24
  br i1 %25, label %121, label %26

; <label>:26:                                     ; preds = %18, %23
  %27 = phi i8* [ %19, %18 ], [ %24, %23 ]
  %28 = phi i8* [ %21, %18 ], [ %70, %23 ]
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = sext i8 %29 to i32
  switch i32 %30, label %92 [
    i32 40, label %31
    i32 41, label %40
    i32 36, label %43
    i32 37, label %51
  ]

; <label>:31:                                     ; preds = %26
  %32 = getelementptr inbounds i8, i8* %28, i64 1
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = icmp eq i8 %33, 41
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %31
  %36 = getelementptr inbounds i8, i8* %28, i64 2
  %37 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %36, i32 -2)
  br label %121

; <label>:38:                                     ; preds = %31
  %39 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %32, i32 -1)
  br label %121

; <label>:40:                                     ; preds = %26
  %41 = getelementptr inbounds i8, i8* %28, i64 1
  %42 = tail call fastcc i8* @end_capture(%struct.MatchState* nonnull %0, i8* %20, i8* nonnull %41)
  br label %121

; <label>:43:                                     ; preds = %26
  %44 = getelementptr inbounds i8, i8* %28, i64 1
  %45 = icmp eq i8* %44, %27
  br i1 %45, label %46, label %92

; <label>:46:                                     ; preds = %43
  %47 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %48 = load i8*, i8** %47, align 8, !tbaa !352
  %49 = icmp eq i8* %20, %48
  %50 = select i1 %49, i8* %20, i8* null
  br label %121

; <label>:51:                                     ; preds = %26
  %52 = getelementptr inbounds i8, i8* %28, i64 1
  %53 = load i8, i8* %52, align 1, !tbaa !21
  %54 = sext i8 %53 to i32
  switch i32 %54, label %92 [
    i32 98, label %55
    i32 102, label %61
    i32 48, label %86
    i32 49, label %86
    i32 50, label %86
    i32 51, label %86
    i32 52, label %86
    i32 53, label %86
    i32 54, label %86
    i32 55, label %86
    i32 56, label %86
    i32 57, label %86
  ]

; <label>:55:                                     ; preds = %51
  %56 = getelementptr inbounds i8, i8* %28, i64 2
  %57 = tail call fastcc i8* @matchbalance(%struct.MatchState* %0, i8* %20, i8* nonnull %56)
  %58 = icmp eq i8* %57, null
  br i1 %58, label %121, label %59

; <label>:59:                                     ; preds = %55
  %60 = getelementptr inbounds i8, i8* %28, i64 4
  br label %116

; <label>:61:                                     ; preds = %51
  %62 = getelementptr inbounds i8, i8* %28, i64 2
  %63 = load i8, i8* %62, align 1, !tbaa !21
  %64 = icmp eq i8 %63, 91
  br i1 %64, label %69, label %65

; <label>:65:                                     ; preds = %61
  %66 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %67 = load %struct.lua_State*, %struct.lua_State** %66, align 8, !tbaa !355
  %68 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %67, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.546, i64 0, i64 0))
  unreachable

; <label>:69:                                     ; preds = %61
  %70 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %62)
  %71 = load i8*, i8** %17, align 8, !tbaa !357
  %72 = icmp eq i8* %20, %71
  br i1 %72, label %75, label %73

; <label>:73:                                     ; preds = %69
  %74 = load i8, i8* %22, align 1, !tbaa !21
  br label %75

; <label>:75:                                     ; preds = %69, %73
  %76 = phi i8 [ %74, %73 ], [ 0, %69 ]
  %77 = zext i8 %76 to i32
  %78 = getelementptr inbounds i8, i8* %70, i64 -1
  %79 = tail call fastcc i32 @matchbracketclass(i32 %77, i8* nonnull %62, i8* nonnull %78)
  %80 = icmp eq i32 %79, 0
  br i1 %80, label %81, label %121

; <label>:81:                                     ; preds = %75
  %82 = load i8, i8* %20, align 1, !tbaa !21
  %83 = zext i8 %82 to i32
  %84 = tail call fastcc i32 @matchbracketclass(i32 %83, i8* nonnull %62, i8* nonnull %78)
  %85 = icmp eq i32 %84, 0
  br i1 %85, label %121, label %23

; <label>:86:                                     ; preds = %51, %51, %51, %51, %51, %51, %51, %51, %51, %51
  %87 = zext i8 %53 to i32
  %88 = tail call fastcc i8* @match_capture(%struct.MatchState* %0, i8* %20, i32 %87)
  %89 = icmp eq i8* %88, null
  br i1 %89, label %121, label %90

; <label>:90:                                     ; preds = %86
  %91 = getelementptr inbounds i8, i8* %28, i64 2
  br label %116

; <label>:92:                                     ; preds = %26, %51, %43
  %93 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %28)
  %94 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %20, i8* nonnull %28, i8* nonnull %93)
  %95 = icmp eq i32 %94, 0
  %96 = load i8, i8* %93, align 1, !tbaa !21
  br i1 %95, label %97, label %100

; <label>:97:                                     ; preds = %92
  switch i8 %96, label %121 [
    i8 42, label %98
    i8 63, label %98
    i8 45, label %98
  ]

; <label>:98:                                     ; preds = %97, %97, %97
  %99 = getelementptr inbounds i8, i8* %93, i64 1
  br label %116

; <label>:100:                                    ; preds = %92
  %101 = sext i8 %96 to i32
  switch i32 %101, label %114 [
    i32 63, label %102
    i32 43, label %107
    i32 42, label %109
    i32 45, label %112
  ]

; <label>:102:                                    ; preds = %100
  %103 = getelementptr inbounds i8, i8* %20, i64 1
  %104 = getelementptr inbounds i8, i8* %93, i64 1
  %105 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* nonnull %103, i8* nonnull %104)
  %106 = icmp eq i8* %105, null
  br i1 %106, label %116, label %121

; <label>:107:                                    ; preds = %100
  %108 = getelementptr inbounds i8, i8* %20, i64 1
  br label %109

; <label>:109:                                    ; preds = %100, %107
  %110 = phi i8* [ %108, %107 ], [ %20, %100 ]
  %111 = tail call fastcc i8* @max_expand(%struct.MatchState* %0, i8* %110, i8* nonnull %28, i8* nonnull %93)
  br label %121

; <label>:112:                                    ; preds = %100
  %113 = tail call fastcc i8* @min_expand(%struct.MatchState* %0, i8* %20, i8* nonnull %28, i8* nonnull %93)
  br label %121

; <label>:114:                                    ; preds = %100
  %115 = getelementptr inbounds i8, i8* %20, i64 1
  br label %116

; <label>:116:                                    ; preds = %98, %102, %114, %90, %59
  %117 = phi i8* [ %60, %59 ], [ %91, %90 ], [ %99, %98 ], [ %104, %102 ], [ %93, %114 ]
  %118 = phi i8* [ %57, %59 ], [ %88, %90 ], [ %20, %98 ], [ %20, %102 ], [ %115, %114 ]
  %119 = load i8*, i8** %13, align 8, !tbaa !358
  %120 = icmp eq i8* %117, %119
  br i1 %120, label %121, label %18

; <label>:121:                                    ; preds = %116, %55, %86, %97, %102, %23, %81, %75, %112, %109, %12, %40, %46, %38, %35
  %122 = phi i8* [ %50, %46 ], [ %42, %40 ], [ %37, %35 ], [ %39, %38 ], [ %1, %12 ], [ %113, %112 ], [ %111, %109 ], [ null, %75 ], [ null, %81 ], [ %20, %23 ], [ null, %97 ], [ %105, %102 ], [ %118, %116 ], [ null, %86 ], [ null, %55 ]
  %123 = load i32, i32* %4, align 8, !tbaa !356
  %124 = add nsw i32 %123, 1
  store i32 %124, i32* %4, align 8, !tbaa !356
  ret i8* %122
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @push_captures(%struct.MatchState* nocapture readonly, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %5 = load i8, i8* %4, align 4, !tbaa !359
  %6 = icmp eq i8 %5, 0
  %7 = icmp ne i8* %1, null
  %8 = and i1 %7, %6
  %9 = zext i8 %5 to i32
  %10 = select i1 %8, i32 1, i32 %9
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !355
  tail call void @luaL_checkstack(%struct.lua_State* %12, i32 %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0))
  %13 = icmp eq i32 %10, 0
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %3
  br label %15

; <label>:15:                                     ; preds = %14, %15
  %16 = phi i32 [ %17, %15 ], [ 0, %14 ]
  tail call fastcc void @push_onecapture(%struct.MatchState* %0, i32 %16, i8* %1, i8* %2)
  %17 = add nuw nsw i32 %16, 1
  %18 = icmp eq i32 %17, %10
  br i1 %18, label %19, label %15

; <label>:19:                                     ; preds = %15, %3
  ret i32 %10
}

; Function Attrs: nounwind readonly
declare i8* @memchr(i8*, i32, i64) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc i8* @start_capture(%struct.MatchState* nocapture, i8*, i8*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %6 = load i8, i8* %5, align 4, !tbaa !359
  %7 = icmp ugt i8 %6, 31
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !355
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0))
  unreachable

; <label>:12:                                     ; preds = %4
  %13 = zext i8 %6 to i64
  %14 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 0
  store i8* %1, i8** %14, align 8, !tbaa !360
  %15 = sext i32 %3 to i64
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 1
  store i64 %15, i64* %16, align 8, !tbaa !362
  %17 = add i8 %6, 1
  store i8 %17, i8* %5, align 4, !tbaa !359
  %18 = tail call fastcc i8* @match(%struct.MatchState* nonnull %0, i8* %1, i8* %2)
  %19 = icmp eq i8* %18, null
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %12
  %21 = load i8, i8* %5, align 4, !tbaa !359
  %22 = add i8 %21, -1
  store i8 %22, i8* %5, align 4, !tbaa !359
  br label %23

; <label>:23:                                     ; preds = %20, %12
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @end_capture(%struct.MatchState* nocapture, i8*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc i32 @capture_to_close(%struct.MatchState* %0)
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %5
  %7 = bitcast %struct.anon.11* %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !360
  %9 = ptrtoint i8* %1 to i64
  %10 = sub i64 %9, %8
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %5, i32 1
  store i64 %10, i64* %11, align 8, !tbaa !362
  %12 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %1, i8* %2)
  %13 = icmp eq i8* %12, null
  br i1 %13, label %14, label %15

; <label>:14:                                     ; preds = %3
  store i64 -1, i64* %11, align 8, !tbaa !362
  br label %15

; <label>:15:                                     ; preds = %14, %3
  ret i8* %12
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @matchbalance(%struct.MatchState* nocapture readonly, i8* readonly, i8* readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %5 = load i8*, i8** %4, align 8, !tbaa !358
  %6 = getelementptr inbounds i8, i8* %5, i64 -1
  %7 = icmp ugt i8* %6, %2
  br i1 %7, label %12, label %8

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !355
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.549, i64 0, i64 0))
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = load i8, i8* %1, align 1, !tbaa !21
  %14 = load i8, i8* %2, align 1, !tbaa !21
  %15 = icmp eq i8 %13, %14
  br i1 %15, label %16, label %44

; <label>:16:                                     ; preds = %12
  %17 = getelementptr inbounds i8, i8* %2, i64 1
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = getelementptr inbounds i8, i8* %1, i64 1
  %20 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %21 = load i8*, i8** %20, align 8, !tbaa !352
  %22 = icmp ult i8* %19, %21
  br i1 %22, label %23, label %44

; <label>:23:                                     ; preds = %16
  br label %24

; <label>:24:                                     ; preds = %23, %37
  %25 = phi i8* [ %39, %37 ], [ %19, %23 ]
  %26 = phi i32 [ %38, %37 ], [ 1, %23 ]
  %27 = phi i8* [ %25, %37 ], [ %1, %23 ]
  %28 = load i8, i8* %25, align 1, !tbaa !21
  %29 = icmp eq i8 %28, %18
  br i1 %29, label %30, label %33

; <label>:30:                                     ; preds = %24
  %31 = add nsw i32 %26, -1
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %42, label %37

; <label>:33:                                     ; preds = %24
  %34 = icmp eq i8 %28, %14
  %35 = zext i1 %34 to i32
  %36 = add nsw i32 %26, %35
  br label %37

; <label>:37:                                     ; preds = %33, %30
  %38 = phi i32 [ %31, %30 ], [ %36, %33 ]
  %39 = getelementptr inbounds i8, i8* %25, i64 1
  %40 = load i8*, i8** %20, align 8, !tbaa !352
  %41 = icmp ult i8* %39, %40
  br i1 %41, label %24, label %44

; <label>:42:                                     ; preds = %30
  %43 = getelementptr inbounds i8, i8* %27, i64 2
  br label %44

; <label>:44:                                     ; preds = %37, %16, %12, %42
  %45 = phi i8* [ %43, %42 ], [ null, %12 ], [ null, %16 ], [ null, %37 ]
  ret i8* %45
}

; Function Attrs: nounwind uwtable
define internal fastcc nonnull i8* @classend(%struct.MatchState* nocapture readonly, i8* readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds i8, i8* %1, i64 1
  %4 = load i8, i8* %1, align 1, !tbaa !21
  %5 = sext i8 %4 to i32
  switch i32 %5, label %42 [
    i32 37, label %6
    i32 91, label %16
  ]

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %8 = load i8*, i8** %7, align 8, !tbaa !358
  %9 = icmp eq i8* %3, %8
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !355
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %12, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.550, i64 0, i64 0))
  unreachable

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds i8, i8* %1, i64 2
  br label %42

; <label>:16:                                     ; preds = %2
  %17 = load i8, i8* %3, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 94
  %19 = getelementptr inbounds i8, i8* %1, i64 2
  %20 = select i1 %18, i8* %19, i8* %3
  %21 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %22 = load i8*, i8** %21, align 8, !tbaa !358
  br label %23

; <label>:23:                                     ; preds = %30, %16
  %24 = phi i8* [ %20, %16 ], [ %37, %30 ]
  %25 = icmp eq i8* %24, %22
  br i1 %25, label %26, label %30

; <label>:26:                                     ; preds = %23
  %27 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %28 = load %struct.lua_State*, %struct.lua_State** %27, align 8, !tbaa !355
  %29 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %28, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.551, i64 0, i64 0))
  unreachable

; <label>:30:                                     ; preds = %23
  %31 = getelementptr inbounds i8, i8* %24, i64 1
  %32 = load i8, i8* %24, align 1, !tbaa !21
  %33 = icmp eq i8 %32, 37
  %34 = icmp ult i8* %31, %22
  %35 = getelementptr inbounds i8, i8* %24, i64 2
  %36 = and i1 %34, %33
  %37 = select i1 %36, i8* %35, i8* %31
  %38 = load i8, i8* %37, align 1, !tbaa !21
  %39 = icmp eq i8 %38, 93
  br i1 %39, label %40, label %23

; <label>:40:                                     ; preds = %30
  %41 = getelementptr inbounds i8, i8* %37, i64 1
  br label %42

; <label>:42:                                     ; preds = %2, %40, %14
  %43 = phi i8* [ %41, %40 ], [ %15, %14 ], [ %3, %2 ]
  ret i8* %43
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @matchbracketclass(i32, i8* readonly, i8* readnone) unnamed_addr #14 {
  %4 = getelementptr inbounds i8, i8* %1, i64 1
  %5 = load i8, i8* %4, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 94
  %7 = select i1 %6, i8* %4, i8* %1
  %8 = xor i1 %6, true
  %9 = zext i1 %8 to i32
  %10 = getelementptr inbounds i8, i8* %7, i64 1
  %11 = icmp ult i8* %10, %2
  br i1 %11, label %12, label %43

; <label>:12:                                     ; preds = %3
  br label %13

; <label>:13:                                     ; preds = %12, %39
  %14 = phi i8* [ %41, %39 ], [ %10, %12 ]
  %15 = phi i8* [ %40, %39 ], [ %7, %12 ]
  %16 = load i8, i8* %14, align 1, !tbaa !21
  %17 = icmp eq i8 %16, 37
  %18 = getelementptr inbounds i8, i8* %15, i64 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  br i1 %17, label %20, label %24

; <label>:20:                                     ; preds = %13
  %21 = zext i8 %19 to i32
  %22 = tail call fastcc i32 @match_class(i32 %0, i32 %21)
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %39, label %45

; <label>:24:                                     ; preds = %13
  %25 = icmp eq i8 %19, 45
  br i1 %25, label %26, label %36

; <label>:26:                                     ; preds = %24
  %27 = getelementptr inbounds i8, i8* %15, i64 3
  %28 = icmp ult i8* %27, %2
  br i1 %28, label %29, label %36

; <label>:29:                                     ; preds = %26
  %30 = zext i8 %16 to i32
  %31 = icmp sgt i32 %30, %0
  br i1 %31, label %39, label %32

; <label>:32:                                     ; preds = %29
  %33 = load i8, i8* %27, align 1, !tbaa !21
  %34 = zext i8 %33 to i32
  %35 = icmp slt i32 %34, %0
  br i1 %35, label %39, label %45

; <label>:36:                                     ; preds = %26, %24
  %37 = zext i8 %16 to i32
  %38 = icmp eq i32 %37, %0
  br i1 %38, label %45, label %39

; <label>:39:                                     ; preds = %20, %32, %29, %36
  %40 = phi i8* [ %18, %20 ], [ %27, %32 ], [ %27, %29 ], [ %14, %36 ]
  %41 = getelementptr inbounds i8, i8* %40, i64 1
  %42 = icmp ult i8* %41, %2
  br i1 %42, label %13, label %43

; <label>:43:                                     ; preds = %39, %3
  %44 = xor i32 %9, 1
  br label %45

; <label>:45:                                     ; preds = %36, %32, %20, %43
  %46 = phi i32 [ %44, %43 ], [ %9, %20 ], [ %9, %32 ], [ %9, %36 ]
  ret i32 %46
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @match_capture(%struct.MatchState* nocapture readonly, i8*, i32) unnamed_addr #0 {
  %4 = tail call fastcc i32 @check_capture(%struct.MatchState* %0, i32 %2)
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %5, i32 1
  %7 = load i64, i64* %6, align 8, !tbaa !362
  %8 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %9 = bitcast i8** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !352
  %11 = ptrtoint i8* %1 to i64
  %12 = sub i64 %10, %11
  %13 = icmp ult i64 %12, %7
  br i1 %13, label %21, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %5, i32 0
  %16 = load i8*, i8** %15, align 8, !tbaa !360
  %17 = tail call i32 @memcmp(i8* %16, i8* %1, i64 %7) #19
  %18 = icmp eq i32 %17, 0
  %19 = getelementptr inbounds i8, i8* %1, i64 %7
  %20 = select i1 %18, i8* %19, i8* null
  ret i8* %20

; <label>:21:                                     ; preds = %3
  ret i8* null
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @singlematch(%struct.MatchState* nocapture readonly, i8* readonly, i8* readonly, i8* readnone) unnamed_addr #14 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %6 = load i8*, i8** %5, align 8, !tbaa !352
  %7 = icmp ugt i8* %6, %1
  br i1 %7, label %8, label %24

; <label>:8:                                      ; preds = %4
  %9 = load i8, i8* %1, align 1, !tbaa !21
  %10 = zext i8 %9 to i32
  %11 = load i8, i8* %2, align 1, !tbaa !21
  %12 = sext i8 %11 to i32
  switch i32 %12, label %21 [
    i32 46, label %24
    i32 37, label %13
    i32 91, label %18
  ]

; <label>:13:                                     ; preds = %8
  %14 = getelementptr inbounds i8, i8* %2, i64 1
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = zext i8 %15 to i32
  %17 = tail call fastcc i32 @match_class(i32 %10, i32 %16)
  br label %24

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds i8, i8* %3, i64 -1
  %20 = tail call fastcc i32 @matchbracketclass(i32 %10, i8* nonnull %2, i8* nonnull %19)
  br label %24

; <label>:21:                                     ; preds = %8
  %22 = icmp eq i8 %11, %9
  %23 = zext i1 %22 to i32
  br label %24

; <label>:24:                                     ; preds = %13, %18, %21, %8, %4
  %25 = phi i32 [ 0, %4 ], [ %23, %21 ], [ %20, %18 ], [ %17, %13 ], [ 1, %8 ]
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @max_expand(%struct.MatchState* nocapture, i8*, i8* readonly, i8*) unnamed_addr #0 {
  br label %5

; <label>:5:                                      ; preds = %5, %4
  %6 = phi i64 [ 0, %4 ], [ %10, %5 ]
  %7 = getelementptr inbounds i8, i8* %1, i64 %6
  %8 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %7, i8* %2, i8* %3)
  %9 = icmp eq i32 %8, 0
  %10 = add nuw nsw i64 %6, 1
  br i1 %9, label %11, label %5

; <label>:11:                                     ; preds = %5
  %12 = getelementptr inbounds i8, i8* %3, i64 1
  br label %15

; <label>:13:                                     ; preds = %15
  %14 = icmp sgt i64 %21, -1
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %11, %13
  %16 = phi i64 [ %6, %11 ], [ %21, %13 ]
  %17 = getelementptr inbounds i8, i8* %1, i64 %16
  %18 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %17, i8* nonnull %12)
  %19 = icmp eq i8* %18, null
  %20 = sext i1 %19 to i64
  %21 = add nsw i64 %16, %20
  br i1 %19, label %13, label %22

; <label>:22:                                     ; preds = %15, %13
  %23 = phi i8* [ %18, %15 ], [ null, %13 ]
  ret i8* %23
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @min_expand(%struct.MatchState* nocapture, i8*, i8* readonly, i8*) unnamed_addr #0 {
  %5 = getelementptr inbounds i8, i8* %3, i64 1
  %6 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %1, i8* nonnull %5)
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %17

; <label>:8:                                      ; preds = %4
  br label %12

; <label>:9:                                      ; preds = %12
  %10 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* nonnull %16, i8* nonnull %5)
  %11 = icmp eq i8* %10, null
  br i1 %11, label %12, label %17

; <label>:12:                                     ; preds = %8, %9
  %13 = phi i8* [ %16, %9 ], [ %1, %8 ]
  %14 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %13, i8* %2, i8* %3)
  %15 = icmp eq i32 %14, 0
  %16 = getelementptr inbounds i8, i8* %13, i64 1
  br i1 %15, label %17, label %9

; <label>:17:                                     ; preds = %9, %12, %4
  %18 = phi i8* [ %6, %4 ], [ null, %12 ], [ %10, %9 ]
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @capture_to_close(%struct.MatchState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %3 = load i8, i8* %2, align 4, !tbaa !359
  %4 = icmp eq i8 %3, 0
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %1
  %6 = zext i8 %3 to i64
  br label %9

; <label>:7:                                      ; preds = %9
  %8 = icmp sgt i64 %10, 1
  br i1 %8, label %9, label %15

; <label>:9:                                      ; preds = %5, %7
  %10 = phi i64 [ %6, %5 ], [ %11, %7 ]
  %11 = add nsw i64 %10, -1
  %12 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %11, i32 1
  %13 = load i64, i64* %12, align 8, !tbaa !362
  %14 = icmp eq i64 %13, -1
  br i1 %14, label %19, label %7

; <label>:15:                                     ; preds = %7, %1
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %17 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !355
  %18 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %17, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.548, i64 0, i64 0))
  unreachable

; <label>:19:                                     ; preds = %9
  %20 = trunc i64 %11 to i32
  ret i32 %20
}

; Function Attrs: nounwind readonly uwtable
define internal fastcc i32 @match_class(i32, i32) unnamed_addr #14 {
  %3 = tail call i32 @tolower(i32 %1) #19
  switch i32 %3, label %87 [
    i32 97, label %4
    i32 99, label %12
    i32 100, label %20
    i32 103, label %28
    i32 108, label %36
    i32 112, label %44
    i32 115, label %52
    i32 117, label %60
    i32 119, label %68
    i32 120, label %76
    i32 122, label %84
  ]

; <label>:4:                                      ; preds = %2
  %5 = tail call i16** @__ctype_b_loc() #21
  %6 = load i16*, i16** %5, align 8, !tbaa !79
  %7 = sext i32 %0 to i64
  %8 = getelementptr inbounds i16, i16* %6, i64 %7
  %9 = load i16, i16* %8, align 2, !tbaa !312
  %10 = and i16 %9, 1024
  %11 = zext i16 %10 to i32
  br label %90

; <label>:12:                                     ; preds = %2
  %13 = tail call i16** @__ctype_b_loc() #21
  %14 = load i16*, i16** %13, align 8, !tbaa !79
  %15 = sext i32 %0 to i64
  %16 = getelementptr inbounds i16, i16* %14, i64 %15
  %17 = load i16, i16* %16, align 2, !tbaa !312
  %18 = and i16 %17, 2
  %19 = zext i16 %18 to i32
  br label %90

; <label>:20:                                     ; preds = %2
  %21 = tail call i16** @__ctype_b_loc() #21
  %22 = load i16*, i16** %21, align 8, !tbaa !79
  %23 = sext i32 %0 to i64
  %24 = getelementptr inbounds i16, i16* %22, i64 %23
  %25 = load i16, i16* %24, align 2, !tbaa !312
  %26 = and i16 %25, 2048
  %27 = zext i16 %26 to i32
  br label %90

; <label>:28:                                     ; preds = %2
  %29 = tail call i16** @__ctype_b_loc() #21
  %30 = load i16*, i16** %29, align 8, !tbaa !79
  %31 = sext i32 %0 to i64
  %32 = getelementptr inbounds i16, i16* %30, i64 %31
  %33 = load i16, i16* %32, align 2, !tbaa !312
  %34 = and i16 %33, -32768
  %35 = zext i16 %34 to i32
  br label %90

; <label>:36:                                     ; preds = %2
  %37 = tail call i16** @__ctype_b_loc() #21
  %38 = load i16*, i16** %37, align 8, !tbaa !79
  %39 = sext i32 %0 to i64
  %40 = getelementptr inbounds i16, i16* %38, i64 %39
  %41 = load i16, i16* %40, align 2, !tbaa !312
  %42 = and i16 %41, 512
  %43 = zext i16 %42 to i32
  br label %90

; <label>:44:                                     ; preds = %2
  %45 = tail call i16** @__ctype_b_loc() #21
  %46 = load i16*, i16** %45, align 8, !tbaa !79
  %47 = sext i32 %0 to i64
  %48 = getelementptr inbounds i16, i16* %46, i64 %47
  %49 = load i16, i16* %48, align 2, !tbaa !312
  %50 = and i16 %49, 4
  %51 = zext i16 %50 to i32
  br label %90

; <label>:52:                                     ; preds = %2
  %53 = tail call i16** @__ctype_b_loc() #21
  %54 = load i16*, i16** %53, align 8, !tbaa !79
  %55 = sext i32 %0 to i64
  %56 = getelementptr inbounds i16, i16* %54, i64 %55
  %57 = load i16, i16* %56, align 2, !tbaa !312
  %58 = and i16 %57, 8192
  %59 = zext i16 %58 to i32
  br label %90

; <label>:60:                                     ; preds = %2
  %61 = tail call i16** @__ctype_b_loc() #21
  %62 = load i16*, i16** %61, align 8, !tbaa !79
  %63 = sext i32 %0 to i64
  %64 = getelementptr inbounds i16, i16* %62, i64 %63
  %65 = load i16, i16* %64, align 2, !tbaa !312
  %66 = and i16 %65, 256
  %67 = zext i16 %66 to i32
  br label %90

; <label>:68:                                     ; preds = %2
  %69 = tail call i16** @__ctype_b_loc() #21
  %70 = load i16*, i16** %69, align 8, !tbaa !79
  %71 = sext i32 %0 to i64
  %72 = getelementptr inbounds i16, i16* %70, i64 %71
  %73 = load i16, i16* %72, align 2, !tbaa !312
  %74 = and i16 %73, 8
  %75 = zext i16 %74 to i32
  br label %90

; <label>:76:                                     ; preds = %2
  %77 = tail call i16** @__ctype_b_loc() #21
  %78 = load i16*, i16** %77, align 8, !tbaa !79
  %79 = sext i32 %0 to i64
  %80 = getelementptr inbounds i16, i16* %78, i64 %79
  %81 = load i16, i16* %80, align 2, !tbaa !312
  %82 = and i16 %81, 4096
  %83 = zext i16 %82 to i32
  br label %90

; <label>:84:                                     ; preds = %2
  %85 = icmp eq i32 %0, 0
  %86 = zext i1 %85 to i32
  br label %90

; <label>:87:                                     ; preds = %2
  %88 = icmp eq i32 %1, %0
  %89 = zext i1 %88 to i32
  br label %102

; <label>:90:                                     ; preds = %84, %76, %68, %60, %52, %44, %36, %28, %20, %12, %4
  %91 = phi i32 [ %86, %84 ], [ %83, %76 ], [ %75, %68 ], [ %67, %60 ], [ %59, %52 ], [ %51, %44 ], [ %43, %36 ], [ %35, %28 ], [ %27, %20 ], [ %19, %12 ], [ %11, %4 ]
  %92 = tail call i16** @__ctype_b_loc() #21
  %93 = load i16*, i16** %92, align 8, !tbaa !79
  %94 = sext i32 %1 to i64
  %95 = getelementptr inbounds i16, i16* %93, i64 %94
  %96 = load i16, i16* %95, align 2, !tbaa !312
  %97 = and i16 %96, 512
  %98 = icmp eq i16 %97, 0
  %99 = icmp eq i32 %91, 0
  %100 = zext i1 %99 to i32
  %101 = select i1 %98, i32 %100, i32 %91
  br label %102

; <label>:102:                                    ; preds = %90, %87
  %103 = phi i32 [ %89, %87 ], [ %101, %90 ]
  ret i32 %103
}

; Function Attrs: inlinehint nounwind readonly uwtable
define available_externally i32 @tolower(i32) local_unnamed_addr #16 {
  %2 = add i32 %0, 128
  %3 = icmp ult i32 %2, 384
  br i1 %3, label %4, label %10

; <label>:4:                                      ; preds = %1
  %5 = tail call i32** @__ctype_tolower_loc() #21
  %6 = load i32*, i32** %5, align 8, !tbaa !79
  %7 = sext i32 %0 to i64
  %8 = getelementptr inbounds i32, i32* %6, i64 %7
  %9 = load i32, i32* %8, align 4, !tbaa !70
  br label %10

; <label>:10:                                     ; preds = %1, %4
  %11 = phi i32 [ %9, %4 ], [ %0, %1 ]
  ret i32 %11
}

; Function Attrs: nounwind readnone
declare i32** @__ctype_tolower_loc() local_unnamed_addr #8

; Function Attrs: nounwind uwtable
define internal fastcc i32 @check_capture(%struct.MatchState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = add nsw i32 %1, -49
  %4 = icmp slt i32 %1, 49
  br i1 %4, label %15, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %7 = load i8, i8* %6, align 4, !tbaa !359
  %8 = zext i8 %7 to i32
  %9 = icmp slt i32 %3, %8
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %5
  %11 = sext i32 %3 to i64
  %12 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %11, i32 1
  %13 = load i64, i64* %12, align 8, !tbaa !362
  %14 = icmp eq i64 %13, -1
  br i1 %14, label %15, label %20

; <label>:15:                                     ; preds = %5, %10, %2
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %17 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !355
  %18 = add nsw i32 %1, -48
  %19 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %17, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %18)
  unreachable

; <label>:20:                                     ; preds = %10
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal fastcc void @push_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call fastcc i64 @get_onecapture(%struct.MatchState* %0, i32 %1, i8* %2, i8* %3, i8** nonnull %5)
  %8 = icmp eq i64 %7, -2
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !355
  %12 = load i8*, i8** %5, align 8, !tbaa !79
  %13 = tail call i8* @lua_pushlstring(%struct.lua_State* %11, i8* %12, i64 %7)
  br label %14

; <label>:14:                                     ; preds = %4, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @get_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*, i8** nocapture) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %7 = load i8, i8* %6, align 4, !tbaa !359
  %8 = zext i8 %7 to i32
  %9 = icmp sgt i32 %8, %1
  br i1 %9, label %21, label %10

; <label>:10:                                     ; preds = %5
  %11 = icmp eq i32 %1, 0
  br i1 %11, label %17, label %12

; <label>:12:                                     ; preds = %10
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !355
  %15 = add nsw i32 %1, 1
  %16 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %14, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %15)
  unreachable

; <label>:17:                                     ; preds = %10
  store i8* %2, i8** %4, align 8, !tbaa !79
  %18 = ptrtoint i8* %3 to i64
  %19 = ptrtoint i8* %2 to i64
  %20 = sub i64 %18, %19
  br label %41

; <label>:21:                                     ; preds = %5
  %22 = sext i32 %1 to i64
  %23 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 1
  %24 = load i64, i64* %23, align 8, !tbaa !362
  %25 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 0
  %26 = bitcast i8** %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !360
  %28 = bitcast i8** %4 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !79
  switch i64 %24, label %41 [
    i64 -1, label %29
    i64 -2, label %33
  ]

; <label>:29:                                     ; preds = %21
  %30 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !355
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.553, i64 0, i64 0))
  unreachable

; <label>:33:                                     ; preds = %21
  %34 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %35 = load %struct.lua_State*, %struct.lua_State** %34, align 8, !tbaa !355
  %36 = load i64, i64* %26, align 8, !tbaa !360
  %37 = bitcast %struct.MatchState* %0 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !357
  %39 = add i64 %36, 1
  %40 = sub i64 %39, %38
  tail call void @lua_pushinteger(%struct.lua_State* %35, i64 %40)
  br label %41

; <label>:41:                                     ; preds = %33, %21, %17
  %42 = phi i64 [ %20, %17 ], [ %24, %21 ], [ -2, %33 ]
  ret i64 %42
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @scanformat(%struct.lua_State*, i8*, i8* nocapture) unnamed_addr #0 {
  %4 = load i8, i8* %1, align 1, !tbaa !21
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %21, label %6

; <label>:6:                                      ; preds = %3
  br label %7

; <label>:7:                                      ; preds = %6, %17
  %8 = phi i8 [ %19, %17 ], [ %4, %6 ]
  %9 = phi i8* [ %18, %17 ], [ %1, %6 ]
  %10 = sext i8 %8 to i64
  %11 = and i64 %10, 4294967295
  %12 = icmp ult i64 %11, 64
  %13 = shl i64 1, %11
  %14 = and i64 %13, 325494096527361
  %15 = icmp ne i64 %14, 0
  %16 = and i1 %12, %15
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %7
  %18 = getelementptr inbounds i8, i8* %9, i64 1
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %7

; <label>:21:                                     ; preds = %7, %17, %3
  %22 = phi i8* [ %1, %3 ], [ %18, %17 ], [ %9, %7 ]
  %23 = phi i8 [ 0, %3 ], [ 0, %17 ], [ %8, %7 ]
  %24 = ptrtoint i8* %22 to i64
  %25 = ptrtoint i8* %1 to i64
  %26 = sub i64 %24, %25
  %27 = icmp ugt i64 %26, 5
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %21
  %29 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.559, i64 0, i64 0))
  unreachable

; <label>:30:                                     ; preds = %21
  %31 = tail call i16** @__ctype_b_loc() #21
  %32 = load i16*, i16** %31, align 8, !tbaa !79
  %33 = zext i8 %23 to i64
  %34 = getelementptr inbounds i16, i16* %32, i64 %33
  %35 = load i16, i16* %34, align 2, !tbaa !312
  %36 = and i16 %35, 2048
  %37 = icmp eq i16 %36, 0
  %38 = getelementptr inbounds i8, i8* %22, i64 1
  %39 = select i1 %37, i8* %22, i8* %38
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = zext i8 %40 to i64
  %42 = getelementptr inbounds i16, i16* %32, i64 %41
  %43 = load i16, i16* %42, align 2, !tbaa !312
  %44 = and i16 %43, 2048
  %45 = icmp eq i16 %44, 0
  %46 = getelementptr inbounds i8, i8* %39, i64 1
  %47 = select i1 %45, i8* %39, i8* %46
  %48 = load i8, i8* %47, align 1, !tbaa !21
  %49 = icmp eq i8 %48, 46
  br i1 %49, label %50, label %68

; <label>:50:                                     ; preds = %30
  %51 = getelementptr inbounds i8, i8* %47, i64 1
  %52 = load i8, i8* %51, align 1, !tbaa !21
  %53 = zext i8 %52 to i64
  %54 = getelementptr inbounds i16, i16* %32, i64 %53
  %55 = load i16, i16* %54, align 2, !tbaa !312
  %56 = and i16 %55, 2048
  %57 = icmp eq i16 %56, 0
  %58 = getelementptr inbounds i8, i8* %47, i64 2
  %59 = select i1 %57, i8* %51, i8* %58
  %60 = load i8, i8* %59, align 1, !tbaa !21
  %61 = zext i8 %60 to i64
  %62 = getelementptr inbounds i16, i16* %32, i64 %61
  %63 = load i16, i16* %62, align 2, !tbaa !312
  %64 = and i16 %63, 2048
  %65 = icmp eq i16 %64, 0
  %66 = getelementptr inbounds i8, i8* %59, i64 1
  %67 = select i1 %65, i8* %59, i8* %66
  br label %68

; <label>:68:                                     ; preds = %50, %30
  %69 = phi i8* [ %47, %30 ], [ %67, %50 ]
  %70 = load i8, i8* %69, align 1, !tbaa !21
  %71 = zext i8 %70 to i64
  %72 = getelementptr inbounds i16, i16* %32, i64 %71
  %73 = load i16, i16* %72, align 2, !tbaa !312
  %74 = and i16 %73, 2048
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %78, label %76

; <label>:76:                                     ; preds = %68
  %77 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.560, i64 0, i64 0))
  unreachable

; <label>:78:                                     ; preds = %68
  %79 = getelementptr inbounds i8, i8* %2, i64 1
  store i8 37, i8* %2, align 1, !tbaa !21
  %80 = ptrtoint i8* %69 to i64
  %81 = sub i64 %80, %25
  %82 = add nsw i64 %81, 1
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %79, i8* %1, i64 %82, i32 1, i1 false)
  %83 = getelementptr inbounds i8, i8* %79, i64 %82
  store i8 0, i8* %83, align 1, !tbaa !21
  ret i8* %69
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addlenmod(i8*, i8* nocapture readonly) unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %0) #19
  %4 = tail call i64 @strlen(i8* %1) #19
  %5 = add i64 %3, -1
  %6 = getelementptr inbounds i8, i8* %0, i64 %5
  %7 = load i8, i8* %6, align 1, !tbaa !21
  %8 = getelementptr inbounds i8, i8* %0, i64 %3
  %9 = getelementptr inbounds i8, i8* %8, i64 -1
  %10 = tail call i8* @strcpy(i8* nonnull %9, i8* %1) #7
  %11 = add i64 %4, %3
  %12 = add i64 %11, -1
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  store i8 %7, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds i8, i8* %0, i64 %11
  store i8 0, i8* %14, align 1, !tbaa !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addliteral(%struct.lua_State*, %struct.luaL_Buffer*, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %2)
  switch i32 %5, label %30 [
    i32 4, label %6
    i32 3, label %10
    i32 0, label %28
    i32 1, label %28
  ]

; <label>:6:                                      ; preds = %3
  %7 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %2, i64* nonnull %4)
  %9 = load i64, i64* %4, align 8, !tbaa !113
  call fastcc void @addquoted(%struct.luaL_Buffer* %1, i8* %8, i64 %9)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  br label %32

; <label>:10:                                     ; preds = %3
  %11 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %1, i64 120)
  %12 = tail call i32 @lua_isinteger(%struct.lua_State* %0, i32 %2)
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %10
  %15 = tail call double @lua_tonumberx(%struct.lua_State* %0, i32 %2, i32* null)
  %16 = tail call fastcc i32 @quotefloat(i8* %11, double %15)
  br label %22

; <label>:17:                                     ; preds = %10
  %18 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %2, i32* null)
  %19 = icmp eq i64 %18, -9223372036854775808
  %20 = select i1 %19, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.561, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0)
  %21 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %11, i64 120, i8* %20, i64 %18) #7
  br label %22

; <label>:22:                                     ; preds = %17, %14
  %23 = phi i32 [ %21, %17 ], [ %16, %14 ]
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 2
  %26 = load i64, i64* %25, align 8, !tbaa !182
  %27 = add i64 %26, %24
  store i64 %27, i64* %25, align 8, !tbaa !182
  br label %32

; <label>:28:                                     ; preds = %3, %3
  %29 = tail call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %2, i64* null)
  tail call void @luaL_addvalue(%struct.luaL_Buffer* %1)
  br label %32

; <label>:30:                                     ; preds = %3
  %31 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.562, i64 0, i64 0))
  br label %32

; <label>:32:                                     ; preds = %30, %28, %22, %6
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addquoted(%struct.luaL_Buffer*, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = alloca [10 x i8], align 1
  %5 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %6 = load i64, i64* %5, align 8, !tbaa !182
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 1
  %8 = load i64, i64* %7, align 8, !tbaa !180
  %9 = icmp ult i64 %6, %8
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %3
  %11 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %0, i64 1)
  br label %12

; <label>:12:                                     ; preds = %10, %3
  %13 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %14 = load i8*, i8** %13, align 8, !tbaa !183
  %15 = load i64, i64* %5, align 8, !tbaa !182
  %16 = add i64 %15, 1
  store i64 %16, i64* %5, align 8, !tbaa !182
  %17 = getelementptr inbounds i8, i8* %14, i64 %15
  store i8 34, i8* %17, align 1, !tbaa !21
  %18 = icmp eq i64 %2, 0
  br i1 %18, label %85, label %19

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds [10 x i8], [10 x i8]* %4, i64 0, i64 0
  br label %21

; <label>:21:                                     ; preds = %19, %82
  %22 = phi i64 [ %2, %19 ], [ %24, %82 ]
  %23 = phi i8* [ %1, %19 ], [ %83, %82 ]
  %24 = add i64 %22, -1
  %25 = load i8, i8* %23, align 1, !tbaa !21
  switch i8 %25, label %48 [
    i8 34, label %26
    i8 92, label %26
    i8 10, label %26
  ]

; <label>:26:                                     ; preds = %21, %21, %21
  %27 = load i64, i64* %5, align 8, !tbaa !182
  %28 = load i64, i64* %7, align 8, !tbaa !180
  %29 = icmp ult i64 %27, %28
  br i1 %29, label %32, label %30

; <label>:30:                                     ; preds = %26
  %31 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %0, i64 1)
  br label %32

; <label>:32:                                     ; preds = %30, %26
  %33 = load i8*, i8** %13, align 8, !tbaa !183
  %34 = load i64, i64* %5, align 8, !tbaa !182
  %35 = add i64 %34, 1
  store i64 %35, i64* %5, align 8, !tbaa !182
  %36 = getelementptr inbounds i8, i8* %33, i64 %34
  store i8 92, i8* %36, align 1, !tbaa !21
  %37 = load i64, i64* %5, align 8, !tbaa !182
  %38 = load i64, i64* %7, align 8, !tbaa !180
  %39 = icmp ult i64 %37, %38
  br i1 %39, label %42, label %40

; <label>:40:                                     ; preds = %32
  %41 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %0, i64 1)
  br label %42

; <label>:42:                                     ; preds = %40, %32
  %43 = load i8, i8* %23, align 1, !tbaa !21
  %44 = load i8*, i8** %13, align 8, !tbaa !183
  %45 = load i64, i64* %5, align 8, !tbaa !182
  %46 = add i64 %45, 1
  store i64 %46, i64* %5, align 8, !tbaa !182
  %47 = getelementptr inbounds i8, i8* %44, i64 %45
  store i8 %43, i8* %47, align 1, !tbaa !21
  br label %82

; <label>:48:                                     ; preds = %21
  %49 = tail call i16** @__ctype_b_loc() #21
  %50 = load i16*, i16** %49, align 8, !tbaa !79
  %51 = zext i8 %25 to i64
  %52 = getelementptr inbounds i16, i16* %50, i64 %51
  %53 = load i16, i16* %52, align 2, !tbaa !312
  %54 = and i16 %53, 2
  %55 = icmp eq i16 %54, 0
  br i1 %55, label %70, label %56

; <label>:56:                                     ; preds = %48
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %20) #7
  %57 = getelementptr inbounds i8, i8* %23, i64 1
  %58 = load i8, i8* %57, align 1, !tbaa !21
  %59 = zext i8 %58 to i64
  %60 = getelementptr inbounds i16, i16* %50, i64 %59
  %61 = load i16, i16* %60, align 2, !tbaa !312
  %62 = and i16 %61, 2048
  %63 = icmp eq i16 %62, 0
  %64 = zext i8 %25 to i32
  br i1 %63, label %65, label %67

; <label>:65:                                     ; preds = %56
  %66 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %20, i64 10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.563, i64 0, i64 0), i32 %64) #7
  br label %69

; <label>:67:                                     ; preds = %56
  %68 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %20, i64 10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.564, i64 0, i64 0), i32 %64) #7
  br label %69

; <label>:69:                                     ; preds = %67, %65
  call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* nonnull %20)
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %20) #7
  br label %82

; <label>:70:                                     ; preds = %48
  %71 = load i64, i64* %5, align 8, !tbaa !182
  %72 = load i64, i64* %7, align 8, !tbaa !180
  %73 = icmp ult i64 %71, %72
  br i1 %73, label %76, label %74

; <label>:74:                                     ; preds = %70
  %75 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %0, i64 1)
  br label %76

; <label>:76:                                     ; preds = %74, %70
  %77 = load i8, i8* %23, align 1, !tbaa !21
  %78 = load i8*, i8** %13, align 8, !tbaa !183
  %79 = load i64, i64* %5, align 8, !tbaa !182
  %80 = add i64 %79, 1
  store i64 %80, i64* %5, align 8, !tbaa !182
  %81 = getelementptr inbounds i8, i8* %78, i64 %79
  store i8 %77, i8* %81, align 1, !tbaa !21
  br label %82

; <label>:82:                                     ; preds = %69, %76, %42
  %83 = getelementptr inbounds i8, i8* %23, i64 1
  %84 = icmp eq i64 %24, 0
  br i1 %84, label %85, label %21

; <label>:85:                                     ; preds = %82, %12
  %86 = load i64, i64* %5, align 8, !tbaa !182
  %87 = load i64, i64* %7, align 8, !tbaa !180
  %88 = icmp ult i64 %86, %87
  br i1 %88, label %91, label %89

; <label>:89:                                     ; preds = %85
  %90 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %0, i64 1)
  br label %91

; <label>:91:                                     ; preds = %89, %85
  %92 = load i8*, i8** %13, align 8, !tbaa !183
  %93 = load i64, i64* %5, align 8, !tbaa !182
  %94 = add i64 %93, 1
  store i64 %94, i64* %5, align 8, !tbaa !182
  %95 = getelementptr inbounds i8, i8* %92, i64 %93
  store i8 34, i8* %95, align 1, !tbaa !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @quotefloat(i8*, double) unnamed_addr #0 {
  %3 = fcmp oeq double %1, 0x7FF0000000000000
  br i1 %3, label %22, label %4

; <label>:4:                                      ; preds = %2
  %5 = fcmp oeq double %1, 0xFFF0000000000000
  br i1 %5, label %22, label %6

; <label>:6:                                      ; preds = %4
  %7 = fcmp uno double %1, 0.000000e+00
  br i1 %7, label %22, label %8

; <label>:8:                                      ; preds = %6
  %9 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %0, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.568, i64 0, i64 0), double %1) #7
  %10 = sext i32 %9 to i64
  %11 = tail call i8* @memchr(i8* %0, i32 46, i64 %10) #19
  %12 = icmp eq i8* %11, null
  br i1 %12, label %13, label %25

; <label>:13:                                     ; preds = %8
  %14 = tail call %struct.lconv* @localeconv() #7
  %15 = getelementptr inbounds %struct.lconv, %struct.lconv* %14, i64 0, i32 0
  %16 = load i8*, i8** %15, align 8, !tbaa !239
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = sext i8 %17 to i32
  %19 = tail call i8* @memchr(i8* %0, i32 %18, i64 %10) #19
  %20 = icmp eq i8* %19, null
  br i1 %20, label %25, label %21

; <label>:21:                                     ; preds = %13
  store i8 46, i8* %19, align 1, !tbaa !21
  br label %25

; <label>:22:                                     ; preds = %6, %4, %2
  %23 = phi i8* [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.565, i64 0, i64 0), %2 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.566, i64 0, i64 0), %4 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.567, i64 0, i64 0), %6 ]
  %24 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %0, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* nonnull %23) #7
  br label %25

; <label>:25:                                     ; preds = %8, %13, %21, %22
  %26 = phi i32 [ %24, %22 ], [ %9, %21 ], [ %9, %13 ], [ %9, %8 ]
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define internal i32 @gmatch_aux(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001003)
  %3 = getelementptr inbounds i8, i8* %2, i64 24
  %4 = bitcast i8* %3 to %struct.MatchState*
  %5 = getelementptr inbounds i8, i8* %2, i64 48
  %6 = bitcast i8* %5 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %6, align 8, !tbaa !363
  %7 = bitcast i8* %2 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !347
  %9 = getelementptr inbounds i8, i8* %2, i64 32
  %10 = bitcast i8* %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !364
  %12 = icmp ugt i8* %8, %11
  br i1 %12, label %33, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds i8, i8* %2, i64 8
  %15 = bitcast i8* %14 to i8**
  %16 = getelementptr inbounds i8, i8* %2, i64 16
  %17 = bitcast i8* %16 to i8**
  br label %18

; <label>:18:                                     ; preds = %13, %29
  %19 = phi i8* [ %8, %13 ], [ %30, %29 ]
  tail call fastcc void @reprepstate(%struct.MatchState* nonnull %4)
  %20 = load i8*, i8** %15, align 8, !tbaa !350
  %21 = tail call fastcc i8* @match(%struct.MatchState* nonnull %4, i8* %19, i8* %20)
  %22 = icmp eq i8* %21, null
  br i1 %22, label %29, label %23

; <label>:23:                                     ; preds = %18
  %24 = load i8*, i8** %17, align 8, !tbaa !351
  %25 = icmp eq i8* %21, %24
  br i1 %25, label %29, label %26

; <label>:26:                                     ; preds = %23
  %27 = bitcast i8* %16 to i8**
  store i8* %21, i8** %27, align 8, !tbaa !351
  store i8* %21, i8** %7, align 8, !tbaa !347
  %28 = tail call fastcc i32 @push_captures(%struct.MatchState* nonnull %4, i8* %19, i8* nonnull %21)
  br label %33

; <label>:29:                                     ; preds = %23, %18
  %30 = getelementptr inbounds i8, i8* %19, i64 1
  %31 = load i8*, i8** %10, align 8, !tbaa !364
  %32 = icmp ugt i8* %30, %31
  br i1 %32, label %33, label %18

; <label>:33:                                     ; preds = %29, %1, %26
  %34 = phi i32 [ %28, %26 ], [ 0, %1 ], [ 0, %29 ]
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @add_value(%struct.MatchState* nocapture readonly, %struct.luaL_Buffer*, i8*, i8*, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !355
  switch i32 %4, label %12 [
    i32 6, label %8
    i32 5, label %10
  ]

; <label>:8:                                      ; preds = %5
  tail call void @lua_pushvalue(%struct.lua_State* %7, i32 3)
  %9 = tail call fastcc i32 @push_captures(%struct.MatchState* nonnull %0, i8* %2, i8* %3)
  tail call void @lua_callk(%struct.lua_State* %7, i32 %9, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  br label %13

; <label>:10:                                     ; preds = %5
  tail call fastcc void @push_onecapture(%struct.MatchState* nonnull %0, i32 0, i8* %2, i8* %3)
  %11 = tail call i32 @lua_gettable(%struct.lua_State* %7, i32 3)
  br label %13

; <label>:12:                                     ; preds = %5
  tail call fastcc void @add_s(%struct.MatchState* nonnull %0, %struct.luaL_Buffer* %1, i8* %2, i8* %3)
  br label %28

; <label>:13:                                     ; preds = %10, %8
  %14 = tail call i32 @lua_toboolean(%struct.lua_State* %7, i32 -1)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %13
  tail call void @lua_settop(%struct.lua_State* %7, i32 -2)
  %17 = ptrtoint i8* %3 to i64
  %18 = ptrtoint i8* %2 to i64
  %19 = sub i64 %17, %18
  tail call void @luaL_addlstring(%struct.luaL_Buffer* %1, i8* %2, i64 %19)
  br label %28

; <label>:20:                                     ; preds = %13
  %21 = tail call i32 @lua_isstring(%struct.lua_State* %7, i32 -1)
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %27

; <label>:23:                                     ; preds = %20
  %24 = tail call i32 @lua_type(%struct.lua_State* %7, i32 -1)
  %25 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %24)
  %26 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %7, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.570, i64 0, i64 0), i8* %25)
  unreachable

; <label>:27:                                     ; preds = %20
  tail call void @luaL_addvalue(%struct.luaL_Buffer* %1)
  br label %28

; <label>:28:                                     ; preds = %27, %16, %12
  %29 = phi i32 [ 1, %12 ], [ 1, %27 ], [ 0, %16 ]
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal fastcc void @add_s(%struct.MatchState* nocapture readonly, %struct.luaL_Buffer*, i8*, i8*) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca i8*, align 8
  %7 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !355
  %10 = call i8* @lua_tolstring(%struct.lua_State* %9, i32 3, i64* nonnull %5)
  %11 = load i64, i64* %5, align 8, !tbaa !113
  %12 = call i8* @memchr(i8* %10, i32 37, i64 %11) #19
  %13 = icmp eq i8* %12, null
  br i1 %13, label %70, label %14

; <label>:14:                                     ; preds = %4
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 2
  %16 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  %17 = ptrtoint i8* %3 to i64
  %18 = ptrtoint i8* %2 to i64
  %19 = sub i64 %17, %18
  %20 = bitcast i8** %6 to i8*
  %21 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 0
  br label %22

; <label>:22:                                     ; preds = %14, %62
  %23 = phi i8* [ %12, %14 ], [ %68, %62 ]
  %24 = phi i8* [ %10, %14 ], [ %63, %62 ]
  %25 = ptrtoint i8* %23 to i64
  %26 = ptrtoint i8* %24 to i64
  %27 = sub i64 %25, %26
  call void @luaL_addlstring(%struct.luaL_Buffer* %1, i8* %24, i64 %27)
  %28 = getelementptr inbounds i8, i8* %23, i64 1
  %29 = load i8, i8* %28, align 1, !tbaa !21
  switch i8 %29, label %43 [
    i8 37, label %30
    i8 48, label %42
  ]

; <label>:30:                                     ; preds = %22
  %31 = load i64, i64* %15, align 8, !tbaa !182
  %32 = load i64, i64* %16, align 8, !tbaa !180
  %33 = icmp ult i64 %31, %32
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %30
  %35 = call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* nonnull %1, i64 1)
  br label %36

; <label>:36:                                     ; preds = %34, %30
  %37 = load i8, i8* %28, align 1, !tbaa !21
  %38 = load i8*, i8** %21, align 8, !tbaa !183
  %39 = load i64, i64* %15, align 8, !tbaa !182
  %40 = add i64 %39, 1
  store i64 %40, i64* %15, align 8, !tbaa !182
  %41 = getelementptr inbounds i8, i8* %38, i64 %39
  store i8 %37, i8* %41, align 1, !tbaa !21
  br label %62

; <label>:42:                                     ; preds = %22
  call void @luaL_addlstring(%struct.luaL_Buffer* %1, i8* %2, i64 %19)
  br label %62

; <label>:43:                                     ; preds = %22
  %44 = tail call i16** @__ctype_b_loc() #21
  %45 = load i16*, i16** %44, align 8, !tbaa !79
  %46 = zext i8 %29 to i64
  %47 = getelementptr inbounds i16, i16* %45, i64 %46
  %48 = load i16, i16* %47, align 2, !tbaa !312
  %49 = and i16 %48, 2048
  %50 = icmp eq i16 %49, 0
  br i1 %50, label %60, label %51

; <label>:51:                                     ; preds = %43
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %52 = sext i8 %29 to i32
  %53 = add nsw i32 %52, -49
  %54 = call fastcc i64 @get_onecapture(%struct.MatchState* %0, i32 %53, i8* %2, i8* %3, i8** nonnull %6)
  %55 = icmp eq i64 %54, -2
  br i1 %55, label %56, label %57

; <label>:56:                                     ; preds = %51
  call void @luaL_addvalue(%struct.luaL_Buffer* %1)
  br label %59

; <label>:57:                                     ; preds = %51
  %58 = load i8*, i8** %6, align 8, !tbaa !79
  call void @luaL_addlstring(%struct.luaL_Buffer* %1, i8* %58, i64 %54)
  br label %59

; <label>:59:                                     ; preds = %57, %56
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %62

; <label>:60:                                     ; preds = %43
  %61 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %9, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.571, i64 0, i64 0), i32 37)
  unreachable

; <label>:62:                                     ; preds = %42, %59, %36
  %63 = getelementptr inbounds i8, i8* %23, i64 2
  %64 = ptrtoint i8* %63 to i64
  %65 = load i64, i64* %5, align 8, !tbaa !113
  %66 = sub i64 %26, %64
  %67 = add i64 %66, %65
  store i64 %67, i64* %5, align 8, !tbaa !113
  %68 = call i8* @memchr(i8* nonnull %63, i32 37, i64 %67) #19
  %69 = icmp eq i8* %68, null
  br i1 %69, label %70, label %22

; <label>:70:                                     ; preds = %62, %4
  %71 = phi i8* [ %10, %4 ], [ %63, %62 ]
  %72 = phi i64 [ %11, %4 ], [ %67, %62 ]
  call void @luaL_addlstring(%struct.luaL_Buffer* %1, i8* %71, i64 %72)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @initheader(%struct.lua_State*, %struct.Header* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.Header, %struct.Header* %1, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %3, align 8, !tbaa !365
  %4 = getelementptr inbounds %struct.Header, %struct.Header* %1, i64 0, i32 1
  store i32 1, i32* %4, align 8, !tbaa !353
  %5 = getelementptr inbounds %struct.Header, %struct.Header* %1, i64 0, i32 2
  store i32 1, i32* %5, align 4, !tbaa !366
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @getdetails(%struct.Header* nocapture, i64, i8** nocapture, i32* nocapture, i32* nocapture) unnamed_addr #0 {
  %6 = alloca i32, align 4
  %7 = tail call fastcc i32 @getoption(%struct.Header* %0, i8** %2, i32* %3)
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  %9 = load i32, i32* %3, align 4, !tbaa !70
  store i32 %9, i32* %6, align 4, !tbaa !70
  %10 = icmp eq i32 %7, 7
  br i1 %10, label %11, label %25

; <label>:11:                                     ; preds = %5
  %12 = load i8*, i8** %2, align 8, !tbaa !79
  %13 = load i8, i8* %12, align 1, !tbaa !21
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %21, label %15

; <label>:15:                                     ; preds = %11
  %16 = call fastcc i32 @getoption(%struct.Header* %0, i8** nonnull %2, i32* nonnull %6)
  %17 = icmp eq i32 %16, 3
  %18 = load i32, i32* %6, align 4
  %19 = icmp eq i32 %18, 0
  %20 = or i1 %17, %19
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %15, %11
  %22 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !365
  %24 = tail call i32 @luaL_argerror(%struct.lua_State* %23, i32 1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.576, i64 0, i64 0))
  br label %25

; <label>:25:                                     ; preds = %21, %15, %5
  %26 = load i32, i32* %6, align 4, !tbaa !70
  %27 = icmp slt i32 %26, 2
  %28 = icmp eq i32 %7, 3
  %29 = or i1 %28, %27
  br i1 %29, label %49, label %30

; <label>:30:                                     ; preds = %25
  %31 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  %32 = load i32, i32* %31, align 4, !tbaa !366
  %33 = icmp sgt i32 %26, %32
  br i1 %33, label %34, label %35

; <label>:34:                                     ; preds = %30
  store i32 %32, i32* %6, align 4, !tbaa !70
  br label %35

; <label>:35:                                     ; preds = %34, %30
  %36 = load i32, i32* %6, align 4, !tbaa !70
  %37 = add nsw i32 %36, -1
  %38 = and i32 %37, %36
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %35
  %41 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %42 = load %struct.lua_State*, %struct.lua_State** %41, align 8, !tbaa !365
  %43 = tail call i32 @luaL_argerror(%struct.lua_State* %42, i32 1, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.577, i64 0, i64 0))
  br label %44

; <label>:44:                                     ; preds = %35, %40
  %45 = trunc i64 %1 to i32
  %46 = and i32 %37, %45
  %47 = sub nsw i32 %36, %46
  %48 = and i32 %47, %37
  br label %49

; <label>:49:                                     ; preds = %25, %44
  %50 = phi i32 [ %48, %44 ], [ 0, %25 ]
  store i32 %50, i32* %4, align 4, !tbaa !70
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal fastcc void @packint(%struct.luaL_Buffer*, i64, i32, i32, i32) unnamed_addr #0 {
  %6 = sext i32 %3 to i64
  %7 = tail call i8* @luaL_prepbuffsize(%struct.luaL_Buffer* %0, i64 %6)
  %8 = trunc i64 %1 to i8
  %9 = icmp ne i32 %2, 0
  %10 = add nsw i32 %3, -1
  %11 = sext i32 %10 to i64
  %12 = select i1 %9, i64 0, i64 %11
  %13 = getelementptr inbounds i8, i8* %7, i64 %12
  store i8 %8, i8* %13, align 1, !tbaa !21
  %14 = icmp sgt i32 %3, 1
  br i1 %14, label %15, label %40

; <label>:15:                                     ; preds = %5
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi i32 [ %25, %16 ], [ 1, %15 ]
  %18 = phi i64 [ %19, %16 ], [ %1, %15 ]
  %19 = lshr i64 %18, 8
  %20 = trunc i64 %19 to i8
  %21 = sub nsw i32 %10, %17
  %22 = select i1 %9, i32 %17, i32 %21
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i8, i8* %7, i64 %23
  store i8 %20, i8* %24, align 1, !tbaa !21
  %25 = add nuw nsw i32 %17, 1
  %26 = icmp eq i32 %25, %3
  br i1 %26, label %27, label %16

; <label>:27:                                     ; preds = %16
  %28 = icmp ne i32 %4, 0
  %29 = icmp sgt i32 %3, 8
  %30 = and i1 %29, %28
  br i1 %30, label %31, label %40

; <label>:31:                                     ; preds = %27
  br label %32

; <label>:32:                                     ; preds = %31, %32
  %33 = phi i32 [ %38, %32 ], [ 8, %31 ]
  %34 = sub nsw i32 %10, %33
  %35 = select i1 %9, i32 %33, i32 %34
  %36 = sext i32 %35 to i64
  %37 = getelementptr inbounds i8, i8* %7, i64 %36
  store i8 -1, i8* %37, align 1, !tbaa !21
  %38 = add nuw nsw i32 %33, 1
  %39 = icmp eq i32 %38, %3
  br i1 %39, label %40, label %32

; <label>:40:                                     ; preds = %32, %5, %27
  %41 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %42 = load i64, i64* %41, align 8, !tbaa !182
  %43 = add i64 %42, %6
  store i64 %43, i64* %41, align 8, !tbaa !182
  ret void
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc void @copywithendian(i8*, i8*, i32, i32) unnamed_addr #2 {
  %5 = icmp eq i32 %3, 1
  %6 = icmp eq i32 %2, 0
  br i1 %5, label %7, label %18

; <label>:7:                                      ; preds = %4
  br i1 %6, label %32, label %8

; <label>:8:                                      ; preds = %7
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i8* [ %16, %9 ], [ %0, %8 ]
  %11 = phi i32 [ %13, %9 ], [ %2, %8 ]
  %12 = phi i8* [ %14, %9 ], [ %1, %8 ]
  %13 = add nsw i32 %11, -1
  %14 = getelementptr inbounds i8, i8* %12, i64 1
  %15 = load volatile i8, i8* %12, align 1, !tbaa !21
  %16 = getelementptr inbounds i8, i8* %10, i64 1
  store volatile i8 %15, i8* %10, align 1, !tbaa !21
  %17 = icmp eq i32 %13, 0
  br i1 %17, label %32, label %9

; <label>:18:                                     ; preds = %4
  br i1 %6, label %32, label %19

; <label>:19:                                     ; preds = %18
  %20 = add nsw i32 %2, -1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds i8, i8* %0, i64 %21
  br label %23

; <label>:23:                                     ; preds = %19, %23
  %24 = phi i8* [ %22, %19 ], [ %30, %23 ]
  %25 = phi i32 [ %2, %19 ], [ %27, %23 ]
  %26 = phi i8* [ %1, %19 ], [ %28, %23 ]
  %27 = add nsw i32 %25, -1
  %28 = getelementptr inbounds i8, i8* %26, i64 1
  %29 = load volatile i8, i8* %26, align 1, !tbaa !21
  %30 = getelementptr inbounds i8, i8* %24, i64 -1
  store volatile i8 %29, i8* %24, align 1, !tbaa !21
  %31 = icmp eq i32 %27, 0
  br i1 %31, label %32, label %23

; <label>:32:                                     ; preds = %23, %9, %18, %7
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @getoption(%struct.Header* nocapture, i8** nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = load i8*, i8** %1, align 8, !tbaa !79
  %5 = getelementptr inbounds i8, i8* %4, i64 1
  store i8* %5, i8** %1, align 8, !tbaa !79
  %6 = load i8, i8* %4, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  store i32 0, i32* %2, align 4, !tbaa !70
  switch i32 %7, label %44 [
    i32 98, label %8
    i32 66, label %9
    i32 104, label %10
    i32 72, label %11
    i32 108, label %12
    i32 76, label %13
    i32 106, label %14
    i32 74, label %15
    i32 84, label %16
    i32 102, label %17
    i32 100, label %18
    i32 110, label %19
    i32 105, label %20
    i32 73, label %22
    i32 115, label %24
    i32 99, label %26
    i32 122, label %49
    i32 120, label %33
    i32 88, label %34
    i32 32, label %48
    i32 60, label %35
    i32 62, label %37
    i32 61, label %39
    i32 33, label %41
  ]

; <label>:8:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:9:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:10:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:11:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:12:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:13:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:14:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:15:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:16:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:17:                                     ; preds = %3
  store i32 4, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:18:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:19:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4)
  store i32 %21, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:22:                                     ; preds = %3
  %23 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4)
  store i32 %23, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:24:                                     ; preds = %3
  %25 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8)
  store i32 %25, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:26:                                     ; preds = %3
  %27 = tail call fastcc i32 @getnum(i8** nonnull %1, i32 -1)
  store i32 %27, i32* %2, align 4, !tbaa !70
  %28 = icmp eq i32 %27, -1
  br i1 %28, label %29, label %49

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !365
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.578, i64 0, i64 0))
  unreachable

; <label>:33:                                     ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !70
  br label %49

; <label>:34:                                     ; preds = %3
  br label %49

; <label>:35:                                     ; preds = %3
  %36 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %36, align 8, !tbaa !353
  br label %48

; <label>:37:                                     ; preds = %3
  %38 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 0, i32* %38, align 8, !tbaa !353
  br label %48

; <label>:39:                                     ; preds = %3
  %40 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %40, align 8, !tbaa !353
  br label %48

; <label>:41:                                     ; preds = %3
  %42 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8)
  %43 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  store i32 %42, i32* %43, align 4, !tbaa !366
  br label %48

; <label>:44:                                     ; preds = %3
  %45 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %46 = load %struct.lua_State*, %struct.lua_State** %45, align 8, !tbaa !365
  %47 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %46, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.579, i64 0, i64 0), i32 %7)
  unreachable

; <label>:48:                                     ; preds = %41, %39, %37, %35, %3
  br label %49

; <label>:49:                                     ; preds = %3, %26, %48, %34, %33, %24, %22, %20, %19, %18, %17, %16, %15, %14, %13, %12, %11, %10, %9, %8
  %50 = phi i32 [ 8, %48 ], [ 7, %34 ], [ 6, %33 ], [ 4, %24 ], [ 1, %22 ], [ 0, %20 ], [ 2, %19 ], [ 2, %18 ], [ 2, %17 ], [ 1, %16 ], [ 1, %15 ], [ 0, %14 ], [ 1, %13 ], [ 0, %12 ], [ 1, %11 ], [ 0, %10 ], [ 1, %9 ], [ 0, %8 ], [ 3, %26 ], [ 5, %3 ]
  ret i32 %50
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @getnumlimit(%struct.Header* nocapture readonly, i8** nocapture, i32) unnamed_addr #0 {
  %4 = tail call fastcc i32 @getnum(i8** %1, i32 %2)
  %5 = add i32 %4, -1
  %6 = icmp ugt i32 %5, 15
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !365
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %9, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.580, i64 0, i64 0), i32 %4, i32 16)
  unreachable

; <label>:11:                                     ; preds = %3
  ret i32 %4
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @getnum(i8** nocapture, i32) unnamed_addr #2 {
  %3 = load i8*, i8** %0, align 8, !tbaa !79
  %4 = load i8, i8* %3, align 1, !tbaa !21
  %5 = sext i8 %4 to i32
  %6 = tail call fastcc i32 @digit(i32 %5)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %24, label %8

; <label>:8:                                      ; preds = %2
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi i32 [ %17, %9 ], [ 0, %8 ]
  %11 = mul nsw i32 %10, 10
  %12 = load i8*, i8** %0, align 8, !tbaa !79
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %0, align 8, !tbaa !79
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = sext i8 %14 to i32
  %16 = add i32 %11, -48
  %17 = add i32 %16, %15
  %18 = load i8, i8* %13, align 1, !tbaa !21
  %19 = sext i8 %18 to i32
  %20 = tail call fastcc i32 @digit(i32 %19)
  %21 = icmp ne i32 %20, 0
  %22 = icmp slt i32 %17, 214748364
  %23 = and i1 %21, %22
  br i1 %23, label %9, label %24

; <label>:24:                                     ; preds = %9, %2
  %25 = phi i32 [ %1, %2 ], [ %17, %9 ]
  ret i32 %25
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @digit(i32) unnamed_addr #6 {
  %2 = add i32 %0, -48
  %3 = icmp ult i32 %2, 10
  %4 = zext i1 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc i64 @unpackint(%struct.lua_State*, i8* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %6 = icmp slt i32 %3, 8
  %7 = icmp sgt i32 %3, 0
  br i1 %7, label %8, label %26

; <label>:8:                                      ; preds = %5
  %9 = icmp eq i32 %2, 0
  %10 = add nsw i32 %3, -1
  %11 = select i1 %6, i32 %3, i32 8
  br label %12

; <label>:12:                                     ; preds = %8, %12
  %13 = phi i32 [ %15, %12 ], [ %11, %8 ]
  %14 = phi i64 [ %24, %12 ], [ 0, %8 ]
  %15 = add nsw i32 %13, -1
  %16 = shl i64 %14, 8
  %17 = sub i32 1, %13
  %18 = add i32 %10, %17
  %19 = select i1 %9, i32 %18, i32 %15
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i8, i8* %1, i64 %20
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  %24 = or i64 %16, %23
  %25 = icmp sgt i32 %13, 1
  br i1 %25, label %12, label %26

; <label>:26:                                     ; preds = %12, %5
  %27 = phi i64 [ 0, %5 ], [ %24, %12 ]
  br i1 %6, label %28, label %37

; <label>:28:                                     ; preds = %26
  %29 = icmp eq i32 %4, 0
  br i1 %29, label %60, label %30

; <label>:30:                                     ; preds = %28
  %31 = shl i32 %3, 3
  %32 = add nsw i32 %31, -1
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = xor i64 %27, %34
  %36 = sub i64 %35, %34
  br label %60

; <label>:37:                                     ; preds = %26
  %38 = icmp eq i32 %3, 8
  br i1 %38, label %60, label %39

; <label>:39:                                     ; preds = %37
  %40 = icmp eq i32 %4, 0
  %41 = icmp sgt i64 %27, -1
  %42 = or i1 %40, %41
  %43 = select i1 %42, i32 0, i32 255
  %44 = icmp eq i32 %2, 0
  %45 = add nsw i32 %3, -1
  br label %48

; <label>:46:                                     ; preds = %48
  %47 = icmp slt i32 %57, %3
  br i1 %47, label %48, label %60

; <label>:48:                                     ; preds = %39, %46
  %49 = phi i32 [ 8, %39 ], [ %57, %46 ]
  %50 = sub i32 %45, %49
  %51 = select i1 %44, i32 %50, i32 %49
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds i8, i8* %1, i64 %52
  %54 = load i8, i8* %53, align 1, !tbaa !21
  %55 = zext i8 %54 to i32
  %56 = icmp eq i32 %43, %55
  %57 = add nuw nsw i32 %49, 1
  br i1 %56, label %46, label %58

; <label>:58:                                     ; preds = %48
  %59 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.587, i64 0, i64 0), i32 %3)
  unreachable

; <label>:60:                                     ; preds = %46, %28, %37, %30
  %61 = phi i64 [ %36, %30 ], [ %27, %28 ], [ %27, %37 ], [ %27, %46 ]
  ret i64 %61
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_add(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_sub(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_mul(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_mod(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_pow(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_div(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_idiv(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @arith_unm(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 12, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal fastcc void @arith(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 1)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 2)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %6
  tail call void @lua_arith(%struct.lua_State* %0, i32 %1)
  br label %11

; <label>:10:                                     ; preds = %6, %3
  tail call fastcc void @trymt(%struct.lua_State* %0, i8* %2)
  br label %11

; <label>:11:                                     ; preds = %10, %9
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @tonum(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i32 %4, 3
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %2
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %1)
  br label %19

; <label>:7:                                      ; preds = %2
  %8 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* nonnull %3)
  %10 = icmp eq i8* %9, null
  br i1 %10, label %17, label %11

; <label>:11:                                     ; preds = %7
  %12 = call i64 @lua_stringtonumber(%struct.lua_State* %0, i8* nonnull %9)
  %13 = load i64, i64* %3, align 8, !tbaa !113
  %14 = add i64 %13, 1
  %15 = icmp eq i64 %12, %14
  %16 = zext i1 %15 to i32
  br label %17

; <label>:17:                                     ; preds = %7, %11
  %18 = phi i32 [ 0, %7 ], [ %16, %11 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  br label %19

; <label>:19:                                     ; preds = %17, %6
  %20 = phi i32 [ 1, %6 ], [ %18, %17 ]
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal fastcc void @trymt(%struct.lua_State*, i8*) unnamed_addr #0 {
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %4 = icmp eq i32 %3, 4
  br i1 %4, label %8, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 2, i8* %1)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %5, %2
  %9 = getelementptr inbounds i8, i8* %1, i64 2
  %10 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -2)
  %11 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %10)
  %12 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %13 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %12)
  %14 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.588, i64 0, i64 0), i8* nonnull %9, i8* %11, i8* %13)
  unreachable

; <label>:15:                                     ; preds = %5
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -3, i32 1)
  tail call void @lua_callk(%struct.lua_State* %0, i32 2, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @tconcat(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca i64, align 8
  %4 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 5)
  %5 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3)
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1)
  %9 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 %5)
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2)
  %10 = icmp slt i64 %8, %9
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %1
  br label %12

; <label>:12:                                     ; preds = %11, %12
  %13 = phi i64 [ %15, %12 ], [ %8, %11 ]
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %13)
  %14 = load i64, i64* %3, align 8, !tbaa !113
  call void @luaL_addlstring(%struct.luaL_Buffer* nonnull %2, i8* %7, i64 %14)
  %15 = add nsw i64 %13, 1
  %16 = icmp eq i64 %15, %9
  br i1 %16, label %19, label %12

; <label>:17:                                     ; preds = %1
  %18 = icmp eq i64 %8, %9
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %12, %17
  %20 = phi i64 [ %8, %17 ], [ %9, %12 ]
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %20)
  br label %21

; <label>:21:                                     ; preds = %19, %17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tinsert(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7)
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  %3 = add nsw i64 %2, 1
  %4 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  switch i32 %4, label %19 [
    i32 2, label %21
    i32 3, label %5
  ]

; <label>:5:                                      ; preds = %1
  %6 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %7 = add i64 %6, -1
  %8 = icmp ult i64 %7, %3
  br i1 %8, label %11, label %9

; <label>:9:                                      ; preds = %5
  %10 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0))
  br label %11

; <label>:11:                                     ; preds = %9, %5
  %12 = icmp slt i64 %2, %6
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %11
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i64 [ %16, %14 ], [ %3, %13 ]
  %16 = add nsw i64 %15, -1
  %17 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %16)
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %15)
  %18 = icmp sgt i64 %16, %6
  br i1 %18, label %14, label %21

; <label>:19:                                     ; preds = %1
  %20 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.595, i64 0, i64 0))
  unreachable

; <label>:21:                                     ; preds = %14, %11, %1
  %22 = phi i64 [ %3, %1 ], [ %6, %11 ], [ %6, %14 ]
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %22)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @tpack(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %2, i32 1)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1)
  %3 = icmp sgt i32 %2, 0
  br i1 %3, label %4, label %10

; <label>:4:                                      ; preds = %1
  %5 = sext i32 %2 to i64
  br label %6

; <label>:6:                                      ; preds = %4, %6
  %7 = phi i64 [ %5, %4 ], [ %8, %6 ]
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %7)
  %8 = add nsw i64 %7, -1
  %9 = icmp sgt i64 %7, 1
  br i1 %9, label %6, label %10

; <label>:10:                                     ; preds = %6, %1
  %11 = sext i32 %2 to i64
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 %11)
  tail call void @lua_setfield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0))
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tunpack(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %3 = tail call i32 @lua_type(%struct.lua_State* %0, i32 3)
  %4 = icmp slt i32 %3, 1
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  br label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 3)
  br label %9

; <label>:9:                                      ; preds = %7, %5
  %10 = phi i64 [ %6, %5 ], [ %8, %7 ]
  %11 = icmp slt i64 %10, %2
  br i1 %11, label %32, label %12

; <label>:12:                                     ; preds = %9
  %13 = sub i64 %10, %2
  %14 = icmp ugt i64 %13, 2147483646
  br i1 %14, label %20, label %15

; <label>:15:                                     ; preds = %12
  %16 = trunc i64 %13 to i32
  %17 = add i32 %16, 1
  %18 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %17)
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %15, %12
  %21 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.596, i64 0, i64 0))
  unreachable

; <label>:22:                                     ; preds = %15
  %23 = icmp sgt i64 %10, %2
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %22
  br label %25

; <label>:25:                                     ; preds = %24, %25
  %26 = phi i64 [ %28, %25 ], [ %2, %24 ]
  %27 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %26)
  %28 = add nsw i64 %26, 1
  %29 = icmp eq i64 %28, %10
  br i1 %29, label %30, label %25

; <label>:30:                                     ; preds = %25, %22
  %31 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %10)
  br label %32

; <label>:32:                                     ; preds = %9, %30
  %33 = phi i32 [ %17, %30 ], [ 0, %9 ]
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define internal i32 @tremove(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7)
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  %3 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 %2)
  %4 = icmp ne i64 %3, %2
  %5 = add i64 %3, -1
  %6 = icmp ugt i64 %5, %2
  %7 = and i1 %4, %6
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %1
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0))
  br label %10

; <label>:10:                                     ; preds = %1, %8
  %11 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3)
  %12 = icmp slt i64 %3, %2
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %10
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i64 [ %16, %14 ], [ %3, %13 ]
  %16 = add nsw i64 %15, 1
  %17 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %16)
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %15)
  %18 = icmp eq i64 %16, %2
  br i1 %18, label %19, label %14

; <label>:19:                                     ; preds = %14, %10
  %20 = phi i64 [ %3, %10 ], [ %2, %14 ]
  tail call void @lua_pushnil(%struct.lua_State* %0)
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %20)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @tmove(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 3)
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 4)
  %5 = tail call i32 @lua_type(%struct.lua_State* %0, i32 5)
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %6, i32 5, i32 1
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 1)
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 %7, i32 2)
  %8 = icmp slt i64 %3, %2
  br i1 %8, label %52, label %9

; <label>:9:                                      ; preds = %1
  %10 = icmp sgt i64 %2, 0
  %11 = add nsw i64 %2, 9223372036854775807
  %12 = icmp slt i64 %3, %11
  %13 = or i1 %10, %12
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %9
  %15 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.597, i64 0, i64 0))
  br label %16

; <label>:16:                                     ; preds = %14, %9
  %17 = sub nsw i64 %3, %2
  %18 = sub i64 9223372036854775807, %17
  %19 = icmp sgt i64 %4, %18
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %16
  %21 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.598, i64 0, i64 0))
  br label %22

; <label>:22:                                     ; preds = %16, %20
  %23 = icmp sle i64 %4, %3
  %24 = icmp sgt i64 %4, %2
  %25 = and i1 %23, %24
  br i1 %25, label %26, label %30

; <label>:26:                                     ; preds = %22
  br i1 %6, label %27, label %42

; <label>:27:                                     ; preds = %26
  %28 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 1, i32 %7, i32 0)
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %30, label %42

; <label>:30:                                     ; preds = %22, %27
  %31 = icmp slt i64 %17, 0
  br i1 %31, label %52, label %32

; <label>:32:                                     ; preds = %30
  %33 = add i64 %3, 1
  %34 = sub i64 %33, %2
  br label %35

; <label>:35:                                     ; preds = %35, %32
  %36 = phi i64 [ 0, %32 ], [ %40, %35 ]
  %37 = add nsw i64 %36, %2
  %38 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %37)
  %39 = add nsw i64 %36, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %7, i64 %39)
  %40 = add nuw nsw i64 %36, 1
  %41 = icmp eq i64 %40, %34
  br i1 %41, label %52, label %35

; <label>:42:                                     ; preds = %27, %26
  %43 = icmp sgt i64 %17, -1
  br i1 %43, label %44, label %52

; <label>:44:                                     ; preds = %42
  br label %45

; <label>:45:                                     ; preds = %44, %45
  %46 = phi i64 [ %50, %45 ], [ %17, %44 ]
  %47 = add nsw i64 %46, %2
  %48 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %47)
  %49 = add nsw i64 %46, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %7, i64 %49)
  %50 = add nsw i64 %46, -1
  %51 = icmp sgt i64 %46, 0
  br i1 %51, label %45, label %52

; <label>:52:                                     ; preds = %45, %35, %42, %30, %1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %7)
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @sort(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7)
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1)
  %3 = icmp sgt i64 %2, 1
  br i1 %3, label %4, label %14

; <label>:4:                                      ; preds = %1
  %5 = icmp slt i64 %2, 2147483647
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.599, i64 0, i64 0))
  br label %8

; <label>:8:                                      ; preds = %6, %4
  %9 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %10 = icmp slt i32 %9, 1
  br i1 %10, label %12, label %11

; <label>:11:                                     ; preds = %8
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 2, i32 6)
  br label %12

; <label>:12:                                     ; preds = %11, %8
  tail call void @lua_settop(%struct.lua_State* %0, i32 2)
  %13 = trunc i64 %2 to i32
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 1, i32 %13, i32 0)
  br label %14

; <label>:14:                                     ; preds = %12, %1
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal fastcc void @checktab(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 %1)
  %5 = icmp eq i32 %4, 5
  br i1 %5, label %35, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %34, label %9

; <label>:9:                                      ; preds = %6
  %10 = and i32 %2, 1
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %15, label %12

; <label>:12:                                     ; preds = %9
  %13 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0), i32 2)
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %34, label %15

; <label>:15:                                     ; preds = %12, %9
  %16 = phi i32 [ 2, %12 ], [ 1, %9 ]
  %17 = and i32 %2, 2
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %15
  %20 = add nuw nsw i32 %16, 1
  %21 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i64 0, i64 0), i32 %20)
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %34, label %23

; <label>:23:                                     ; preds = %19, %15
  %24 = phi i32 [ %20, %19 ], [ %16, %15 ]
  %25 = and i32 %2, 4
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %23
  %28 = add nsw i32 %24, 1
  %29 = tail call fastcc i32 @checkfield(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i64 0, i64 0), i32 %28)
  %30 = icmp eq i32 %29, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %27, %23
  %32 = phi i32 [ %28, %27 ], [ %24, %23 ]
  %33 = xor i32 %32, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %33)
  br label %35

; <label>:34:                                     ; preds = %12, %19, %27, %6
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 5)
  br label %35

; <label>:35:                                     ; preds = %31, %34, %3
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @addfield(%struct.lua_State*, %struct.luaL_Buffer*, i64) unnamed_addr #0 {
  %4 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %2)
  %5 = tail call i32 @lua_isstring(%struct.lua_State* %0, i32 -1)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %9 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %8)
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.593, i64 0, i64 0), i8* %9, i64 %2)
  unreachable

; <label>:11:                                     ; preds = %3
  tail call void @luaL_addvalue(%struct.luaL_Buffer* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @checkfield(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  %5 = sub nsw i32 0, %2
  %6 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 %5)
  %7 = icmp ne i32 %6, 0
  %8 = zext i1 %7 to i32
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc void @auxsort(%struct.lua_State*, i32, i32, i32) unnamed_addr #0 {
  %5 = icmp ugt i32 %2, %1
  br i1 %5, label %6, label %74

; <label>:6:                                      ; preds = %4
  br label %7

; <label>:7:                                      ; preds = %6, %71
  %8 = phi i32 [ %72, %71 ], [ %3, %6 ]
  %9 = phi i32 [ %64, %71 ], [ %2, %6 ]
  %10 = phi i32 [ %63, %71 ], [ %1, %6 ]
  %11 = zext i32 %10 to i64
  %12 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %11)
  %13 = zext i32 %9 to i64
  %14 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %13)
  %15 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2)
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %18, label %17

; <label>:17:                                     ; preds = %7
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %10, i32 %9)
  br label %19

; <label>:18:                                     ; preds = %7
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %19

; <label>:19:                                     ; preds = %18, %17
  %20 = sub i32 %9, %10
  %21 = icmp eq i32 %20, 1
  br i1 %21, label %74, label %22

; <label>:22:                                     ; preds = %19
  %23 = icmp ult i32 %20, 100
  %24 = icmp eq i32 %8, 0
  %25 = or i1 %23, %24
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %22
  %27 = add i32 %9, %10
  %28 = lshr i32 %27, 1
  br label %31

; <label>:29:                                     ; preds = %22
  %30 = tail call fastcc i32 @choosePivot(i32 %10, i32 %9, i32 %8)
  br label %31

; <label>:31:                                     ; preds = %29, %26
  %32 = phi i32 [ %28, %26 ], [ %30, %29 ]
  %33 = zext i32 %32 to i64
  %34 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %33)
  %35 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %11)
  %36 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -2, i32 -1)
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %39, label %38

; <label>:38:                                     ; preds = %31
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %32, i32 %10)
  br label %45

; <label>:39:                                     ; preds = %31
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %40 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %13)
  %41 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2)
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %44, label %43

; <label>:43:                                     ; preds = %39
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %32, i32 %9)
  br label %45

; <label>:44:                                     ; preds = %39
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  br label %45

; <label>:45:                                     ; preds = %43, %44, %38
  %46 = icmp eq i32 %20, 2
  br i1 %46, label %74, label %47

; <label>:47:                                     ; preds = %45
  %48 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %33)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 -1)
  %49 = add i32 %9, -1
  %50 = zext i32 %49 to i64
  %51 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %50)
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %32, i32 %49)
  %52 = tail call fastcc i32 @partition(%struct.lua_State* %0, i32 %10, i32 %9)
  %53 = sub i32 %52, %10
  %54 = sub i32 %9, %52
  %55 = icmp ult i32 %53, %54
  br i1 %55, label %56, label %59

; <label>:56:                                     ; preds = %47
  %57 = add i32 %52, -1
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 %10, i32 %57, i32 %8)
  %58 = add i32 %52, 1
  br label %62

; <label>:59:                                     ; preds = %47
  %60 = add i32 %52, 1
  tail call fastcc void @auxsort(%struct.lua_State* %0, i32 %60, i32 %9, i32 %8)
  %61 = add i32 %52, -1
  br label %62

; <label>:62:                                     ; preds = %59, %56
  %63 = phi i32 [ %58, %56 ], [ %10, %59 ]
  %64 = phi i32 [ %9, %56 ], [ %61, %59 ]
  %65 = phi i32 [ %53, %56 ], [ %54, %59 ]
  %66 = sub i32 %64, %63
  %67 = lshr i32 %66, 7
  %68 = icmp ugt i32 %67, %65
  br i1 %68, label %69, label %71

; <label>:69:                                     ; preds = %62
  %70 = tail call fastcc i32 @l_randomizePivot()
  br label %71

; <label>:71:                                     ; preds = %69, %62
  %72 = phi i32 [ %8, %62 ], [ %70, %69 ]
  %73 = icmp ugt i32 %64, %63
  br i1 %73, label %7, label %74

; <label>:74:                                     ; preds = %71, %45, %19, %4
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @sort_comp(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_type(%struct.lua_State* %0, i32 2)
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %1, i32 %2, i32 1)
  br label %12

; <label>:8:                                      ; preds = %3
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 2)
  %9 = add nsw i32 %1, -1
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %9)
  %10 = add nsw i32 %2, -2
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 %10)
  tail call void @lua_callk(%struct.lua_State* %0, i32 2, i32 1, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %11 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %12

; <label>:12:                                     ; preds = %8, %6
  %13 = phi i32 [ %7, %6 ], [ %11, %8 ]
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal fastcc void @set2(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = zext i32 %1 to i64
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %4)
  %5 = zext i32 %2 to i64
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %5)
  ret void
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i32 @choosePivot(i32, i32, i32) unnamed_addr #6 {
  %4 = sub i32 %1, %0
  %5 = lshr i32 %4, 2
  %6 = shl nuw nsw i32 %5, 1
  %7 = urem i32 %2, %6
  %8 = add i32 %5, %0
  %9 = add i32 %8, %7
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @partition(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = add i32 %2, -1
  br label %5

; <label>:5:                                      ; preds = %50, %3
  %6 = phi i32 [ %1, %3 ], [ %26, %50 ]
  %7 = phi i32 [ %4, %3 ], [ %47, %50 ]
  %8 = add i32 %6, 1
  %9 = zext i32 %8 to i64
  %10 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %9)
  %11 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2)
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %25, label %13

; <label>:13:                                     ; preds = %5
  br label %14

; <label>:14:                                     ; preds = %13, %19
  %15 = phi i32 [ %20, %19 ], [ %8, %13 ]
  %16 = icmp eq i32 %15, %4
  br i1 %16, label %17, label %19

; <label>:17:                                     ; preds = %14
  %18 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0))
  unreachable

; <label>:19:                                     ; preds = %14
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %20 = add i32 %15, 1
  %21 = zext i32 %20 to i64
  %22 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %21)
  %23 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2)
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %25, label %14

; <label>:25:                                     ; preds = %19, %5
  %26 = phi i32 [ %8, %5 ], [ %20, %19 ]
  %27 = add i32 %7, -1
  %28 = zext i32 %27 to i64
  %29 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %28)
  %30 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -3, i32 -1)
  %31 = icmp eq i32 %30, 0
  %32 = icmp ult i32 %27, %26
  br i1 %31, label %46, label %33

; <label>:33:                                     ; preds = %25
  br label %34

; <label>:34:                                     ; preds = %33, %39
  %35 = phi i1 [ %45, %39 ], [ %32, %33 ]
  %36 = phi i32 [ %40, %39 ], [ %27, %33 ]
  br i1 %35, label %37, label %39

; <label>:37:                                     ; preds = %34
  %38 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0))
  unreachable

; <label>:39:                                     ; preds = %34
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %40 = add i32 %36, -1
  %41 = zext i32 %40 to i64
  %42 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %41)
  %43 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -3, i32 -1)
  %44 = icmp eq i32 %43, 0
  %45 = icmp ult i32 %40, %26
  br i1 %44, label %46, label %34

; <label>:46:                                     ; preds = %39, %25
  %47 = phi i32 [ %27, %25 ], [ %40, %39 ]
  %48 = phi i1 [ %32, %25 ], [ %45, %39 ]
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %46
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %4, i32 %26)
  ret i32 %26

; <label>:50:                                     ; preds = %46
  tail call fastcc void @set2(%struct.lua_State* %0, i32 %26, i32 %47)
  br label %5
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @l_randomizePivot() unnamed_addr #0 {
  %1 = alloca [4 x i32], align 16
  %2 = tail call i64 @clock() #7
  %3 = tail call i64 @time(i64* null) #7
  %4 = bitcast [4 x i32]* %1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = bitcast [4 x i32]* %1 to i64*
  store i64 %2, i64* %5, align 16
  %6 = getelementptr inbounds [4 x i32], [4 x i32]* %1, i64 0, i64 2
  %7 = bitcast i32* %6 to i64*
  store i64 %3, i64* %7, align 8
  br label %8

; <label>:8:                                      ; preds = %8, %0
  %9 = phi i64 [ 0, %0 ], [ %14, %8 ]
  %10 = phi i32 [ 0, %0 ], [ %13, %8 ]
  %11 = getelementptr inbounds [4 x i32], [4 x i32]* %1, i64 0, i64 %9
  %12 = load i32, i32* %11, align 4, !tbaa !70
  %13 = add i32 %12, %10
  %14 = add nuw nsw i64 %9, 1
  %15 = icmp eq i64 %14, 4
  br i1 %15, label %16, label %8

; <label>:16:                                     ; preds = %8
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i32 @byteoffset(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2)
  %6 = icmp sgt i64 %5, -1
  %7 = load i64, i64* %2, align 8
  %8 = add i64 %7, 1
  %9 = select i1 %6, i64 1, i64 %8
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %9)
  %11 = load i64, i64* %2, align 8, !tbaa !113
  %12 = call fastcc i64 @u_posrelat(i64 %10, i64 %11)
  %13 = icmp sgt i64 %12, 0
  br i1 %13, label %14, label %17

; <label>:14:                                     ; preds = %1
  %15 = add nsw i64 %12, -1
  %16 = icmp sgt i64 %15, %11
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %14, %1
  %18 = phi i64 [ %15, %14 ], [ %12, %1 ]
  %19 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.604, i64 0, i64 0))
  br label %20

; <label>:20:                                     ; preds = %14, %17
  %21 = phi i64 [ %15, %14 ], [ %18, %17 ]
  %22 = icmp eq i64 %5, 0
  br i1 %22, label %23, label %35

; <label>:23:                                     ; preds = %20
  %24 = icmp sgt i64 %21, 0
  br i1 %24, label %25, label %91

; <label>:25:                                     ; preds = %23
  br label %26

; <label>:26:                                     ; preds = %25, %32
  %27 = phi i64 [ %33, %32 ], [ %21, %25 ]
  %28 = getelementptr inbounds i8, i8* %4, i64 %27
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = and i8 %29, -64
  %31 = icmp eq i8 %30, -128
  br i1 %31, label %32, label %87

; <label>:32:                                     ; preds = %26
  %33 = add nsw i64 %27, -1
  %34 = icmp sgt i64 %27, 1
  br i1 %34, label %26, label %87

; <label>:35:                                     ; preds = %20
  %36 = getelementptr inbounds i8, i8* %4, i64 %21
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = and i8 %37, -64
  %39 = icmp eq i8 %38, -128
  br i1 %39, label %40, label %42

; <label>:40:                                     ; preds = %35
  %41 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.605, i64 0, i64 0))
  unreachable

; <label>:42:                                     ; preds = %35
  %43 = icmp slt i64 %5, 0
  br i1 %43, label %44, label %64

; <label>:44:                                     ; preds = %42
  %45 = icmp sgt i64 %21, 0
  br i1 %45, label %46, label %94

; <label>:46:                                     ; preds = %44
  br label %47

; <label>:47:                                     ; preds = %46, %61
  %48 = phi i64 [ %52, %61 ], [ %21, %46 ]
  %49 = phi i64 [ %62, %61 ], [ %5, %46 ]
  br label %50

; <label>:50:                                     ; preds = %56, %47
  %51 = phi i64 [ %48, %47 ], [ %52, %56 ]
  %52 = add nsw i64 %51, -1
  %53 = icmp sgt i64 %51, 1
  br i1 %53, label %56, label %54

; <label>:54:                                     ; preds = %50
  %55 = add nsw i64 %49, 1
  br label %87

; <label>:56:                                     ; preds = %50
  %57 = getelementptr inbounds i8, i8* %4, i64 %52
  %58 = load i8, i8* %57, align 1, !tbaa !21
  %59 = and i8 %58, -64
  %60 = icmp eq i8 %59, -128
  br i1 %60, label %50, label %61

; <label>:61:                                     ; preds = %56
  %62 = add nsw i64 %49, 1
  %63 = icmp slt i64 %49, -1
  br i1 %63, label %47, label %87

; <label>:64:                                     ; preds = %42
  %65 = add nsw i64 %5, -1
  %66 = icmp sgt i64 %5, 1
  %67 = load i64, i64* %2, align 8
  %68 = icmp slt i64 %21, %67
  %69 = and i1 %66, %68
  br i1 %69, label %70, label %87

; <label>:70:                                     ; preds = %64
  %71 = load i64, i64* %2, align 8
  br label %72

; <label>:72:                                     ; preds = %70, %82
  %73 = phi i64 [ %65, %70 ], [ %83, %82 ]
  %74 = phi i64 [ %21, %70 ], [ %77, %82 ]
  br label %75

; <label>:75:                                     ; preds = %75, %72
  %76 = phi i64 [ %74, %72 ], [ %77, %75 ]
  %77 = add nsw i64 %76, 1
  %78 = getelementptr inbounds i8, i8* %4, i64 %77
  %79 = load i8, i8* %78, align 1, !tbaa !21
  %80 = and i8 %79, -64
  %81 = icmp eq i8 %80, -128
  br i1 %81, label %75, label %82

; <label>:82:                                     ; preds = %75
  %83 = add nsw i64 %73, -1
  %84 = icmp sgt i64 %73, 1
  %85 = icmp slt i64 %77, %71
  %86 = and i1 %84, %85
  br i1 %86, label %72, label %87

; <label>:87:                                     ; preds = %82, %61, %32, %26, %54, %64
  %88 = phi i64 [ %65, %64 ], [ %55, %54 ], [ %5, %26 ], [ %5, %32 ], [ %62, %61 ], [ %83, %82 ]
  %89 = phi i64 [ %21, %64 ], [ %52, %54 ], [ %33, %32 ], [ %27, %26 ], [ %52, %61 ], [ %77, %82 ]
  %90 = icmp eq i64 %88, 0
  br i1 %90, label %91, label %94

; <label>:91:                                     ; preds = %23, %87
  %92 = phi i64 [ %89, %87 ], [ %21, %23 ]
  %93 = add nsw i64 %92, 1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %93)
  br label %95

; <label>:94:                                     ; preds = %44, %87
  call void @lua_pushnil(%struct.lua_State* %0)
  br label %95

; <label>:95:                                     ; preds = %91, %94
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @codepoint(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i32, align 4
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %6 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %7 = load i64, i64* %2, align 8, !tbaa !113
  %8 = call fastcc i64 @u_posrelat(i64 %6, i64 %7)
  %9 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %8)
  %10 = load i64, i64* %2, align 8, !tbaa !113
  %11 = call fastcc i64 @u_posrelat(i64 %9, i64 %10)
  %12 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4)
  %13 = icmp sgt i64 %8, 0
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %1
  %15 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0))
  br label %16

; <label>:16:                                     ; preds = %14, %1
  %17 = load i64, i64* %2, align 8, !tbaa !113
  %18 = icmp sgt i64 %11, %17
  br i1 %18, label %19, label %21

; <label>:19:                                     ; preds = %16
  %20 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0))
  br label %21

; <label>:21:                                     ; preds = %16, %19
  %22 = icmp slt i64 %11, %8
  br i1 %22, label %49, label %23

; <label>:23:                                     ; preds = %21
  %24 = sub nsw i64 %11, %8
  %25 = icmp sgt i64 %24, 2147483646
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %23
  %27 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0))
  unreachable

; <label>:28:                                     ; preds = %23
  %29 = trunc i64 %24 to i32
  %30 = add nsw i32 %29, 1
  call void @luaL_checkstack(%struct.lua_State* %0, i32 %30, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0))
  %31 = getelementptr inbounds i8, i8* %5, i64 %11
  %32 = add nsw i64 %8, -1
  %33 = getelementptr inbounds i8, i8* %5, i64 %32
  %34 = bitcast i32* %3 to i8*
  %35 = icmp eq i32 %12, 0
  %36 = zext i1 %35 to i32
  br label %37

; <label>:37:                                     ; preds = %28, %44
  %38 = phi i32 [ 0, %28 ], [ %47, %44 ]
  %39 = phi i8* [ %33, %28 ], [ %40, %44 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %34) #7
  %40 = call fastcc i8* @utf8_decode(i8* %39, i32* nonnull %3, i32 %36)
  %41 = icmp eq i8* %40, null
  br i1 %41, label %42, label %44

; <label>:42:                                     ; preds = %37
  %43 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0))
  unreachable

; <label>:44:                                     ; preds = %37
  %45 = load i32, i32* %3, align 4, !tbaa !70
  %46 = zext i32 %45 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %46)
  %47 = add nuw nsw i32 %38, 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %34) #7
  %48 = icmp ult i8* %40, %31
  br i1 %48, label %37, label %49

; <label>:49:                                     ; preds = %44, %21
  %50 = phi i32 [ 0, %21 ], [ %47, %44 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %50
}

; Function Attrs: nounwind uwtable
define internal i32 @utfchar(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %4 = icmp eq i32 %3, 1
  br i1 %4, label %5, label %6

; <label>:5:                                      ; preds = %1
  tail call fastcc void @pushutfchar(%struct.lua_State* %0, i32 1)
  br label %15

; <label>:6:                                      ; preds = %1
  %7 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %7) #7
  call void @luaL_buffinit(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2)
  %8 = icmp slt i32 %3, 1
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %6
  br label %10

; <label>:10:                                     ; preds = %9, %10
  %11 = phi i32 [ %12, %10 ], [ 1, %9 ]
  call fastcc void @pushutfchar(%struct.lua_State* %0, i32 %11)
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %2)
  %12 = add nuw nsw i32 %11, 1
  %13 = icmp eq i32 %11, %3
  br i1 %13, label %14, label %10

; <label>:14:                                     ; preds = %10, %6
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2)
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %7) #7
  br label %15

; <label>:15:                                     ; preds = %14, %5
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @utflen(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1)
  %6 = load i64, i64* %2, align 8, !tbaa !113
  %7 = call fastcc i64 @u_posrelat(i64 %5, i64 %6)
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 -1)
  %9 = load i64, i64* %2, align 8, !tbaa !113
  %10 = call fastcc i64 @u_posrelat(i64 %8, i64 %9)
  %11 = call i32 @lua_toboolean(%struct.lua_State* %0, i32 4)
  %12 = icmp sgt i64 %7, 0
  br i1 %12, label %13, label %16

; <label>:13:                                     ; preds = %1
  %14 = add nsw i64 %7, -1
  %15 = icmp sgt i64 %14, %9
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %13, %1
  %17 = phi i64 [ %14, %13 ], [ %7, %1 ]
  %18 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0))
  br label %19

; <label>:19:                                     ; preds = %13, %16
  %20 = phi i64 [ %14, %13 ], [ %17, %16 ]
  %21 = load i64, i64* %2, align 8, !tbaa !113
  %22 = icmp sgt i64 %10, %21
  br i1 %22, label %23, label %25

; <label>:23:                                     ; preds = %19
  %24 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.609, i64 0, i64 0))
  br label %25

; <label>:25:                                     ; preds = %19, %23
  %26 = icmp slt i64 %20, %10
  br i1 %26, label %27, label %44

; <label>:27:                                     ; preds = %25
  %28 = icmp eq i32 %11, 0
  %29 = zext i1 %28 to i32
  %30 = ptrtoint i8* %4 to i64
  br label %31

; <label>:31:                                     ; preds = %27, %39
  %32 = phi i64 [ 0, %27 ], [ %42, %39 ]
  %33 = phi i64 [ %20, %27 ], [ %41, %39 ]
  %34 = getelementptr inbounds i8, i8* %4, i64 %33
  %35 = call fastcc i8* @utf8_decode(i8* %34, i32* null, i32 %29)
  %36 = icmp eq i8* %35, null
  br i1 %36, label %37, label %39

; <label>:37:                                     ; preds = %31
  call void @lua_pushnil(%struct.lua_State* %0)
  %38 = add nsw i64 %33, 1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %38)
  br label %46

; <label>:39:                                     ; preds = %31
  %40 = ptrtoint i8* %35 to i64
  %41 = sub i64 %40, %30
  %42 = add nuw nsw i64 %32, 1
  %43 = icmp slt i64 %41, %10
  br i1 %43, label %31, label %44

; <label>:44:                                     ; preds = %39, %25
  %45 = phi i64 [ 0, %25 ], [ %42, %39 ]
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %45)
  br label %46

; <label>:46:                                     ; preds = %37, %44
  %47 = phi i32 [ 2, %37 ], [ 1, %44 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %47
}

; Function Attrs: nounwind uwtable
define internal i32 @iter_codes(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_toboolean(%struct.lua_State* %0, i32 2)
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null)
  %4 = icmp eq i32 %2, 0
  %5 = select i1 %4, i32 (%struct.lua_State*)* @iter_auxstrict, i32 (%struct.lua_State*)* @iter_auxlax
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull %5, i32 0)
  tail call void @lua_pushvalue(%struct.lua_State* %0, i32 1)
  tail call void @lua_pushinteger(%struct.lua_State* %0, i64 0)
  ret i32 3
}

; Function Attrs: norecurse nounwind readnone uwtable
define internal fastcc i64 @u_posrelat(i64, i64) unnamed_addr #6 {
  %3 = icmp sgt i64 %0, -1
  br i1 %3, label %10, label %4

; <label>:4:                                      ; preds = %2
  %5 = sub i64 0, %0
  %6 = icmp ugt i64 %5, %1
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = add i64 %0, 1
  %9 = add i64 %8, %1
  br label %10

; <label>:10:                                     ; preds = %4, %2, %7
  %11 = phi i64 [ %9, %7 ], [ %0, %2 ], [ 0, %4 ]
  ret i64 %11
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i8* @utf8_decode(i8* readonly, i32*, i32) unnamed_addr #2 {
  %4 = load i8, i8* %0, align 1, !tbaa !21
  %5 = zext i8 %4 to i32
  %6 = icmp sgt i8 %4, -1
  br i1 %6, label %47, label %7

; <label>:7:                                      ; preds = %3
  %8 = and i32 %5, 64
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %30, label %10

; <label>:10:                                     ; preds = %7
  br label %11

; <label>:11:                                     ; preds = %10, %21
  %12 = phi i64 [ %15, %21 ], [ 0, %10 ]
  %13 = phi i32 [ %24, %21 ], [ 0, %10 ]
  %14 = phi i32 [ %25, %21 ], [ %5, %10 ]
  %15 = add nuw i64 %12, 1
  %16 = getelementptr inbounds i8, i8* %0, i64 %15
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  %19 = and i32 %18, 192
  %20 = icmp eq i32 %19, 128
  br i1 %20, label %21, label %61

; <label>:21:                                     ; preds = %11
  %22 = shl i32 %13, 6
  %23 = and i32 %18, 63
  %24 = or i32 %23, %22
  %25 = shl i32 %14, 1
  %26 = and i32 %14, 32
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %11

; <label>:28:                                     ; preds = %21
  %29 = trunc i64 %15 to i32
  br label %30

; <label>:30:                                     ; preds = %28, %7
  %31 = phi i32 [ %5, %7 ], [ %25, %28 ]
  %32 = phi i32 [ 0, %7 ], [ %24, %28 ]
  %33 = phi i32 [ 0, %7 ], [ %29, %28 ]
  %34 = and i32 %31, 127
  %35 = mul nsw i32 %33, 5
  %36 = shl i32 %34, %35
  %37 = or i32 %36, %32
  %38 = icmp ugt i32 %33, 5
  %39 = icmp slt i32 %37, 0
  %40 = or i1 %38, %39
  br i1 %40, label %61, label %41

; <label>:41:                                     ; preds = %30
  %42 = zext i32 %33 to i64
  %43 = getelementptr inbounds [6 x i32], [6 x i32]* @utf8_decode.limits, i64 0, i64 %42
  %44 = load i32, i32* %43, align 4, !tbaa !70
  %45 = icmp ult i32 %37, %44
  %46 = getelementptr inbounds i8, i8* %0, i64 %42
  br i1 %45, label %61, label %47

; <label>:47:                                     ; preds = %41, %3
  %48 = phi i8* [ %0, %3 ], [ %46, %41 ]
  %49 = phi i32 [ %5, %3 ], [ %37, %41 ]
  %50 = icmp eq i32 %2, 0
  br i1 %50, label %56, label %51

; <label>:51:                                     ; preds = %47
  %52 = icmp ugt i32 %49, 1114111
  %53 = and i32 %49, -2048
  %54 = icmp eq i32 %53, 55296
  %55 = or i1 %52, %54
  br i1 %55, label %61, label %56

; <label>:56:                                     ; preds = %51, %47
  %57 = icmp eq i32* %1, null
  br i1 %57, label %59, label %58

; <label>:58:                                     ; preds = %56
  store i32 %49, i32* %1, align 4, !tbaa !70
  br label %59

; <label>:59:                                     ; preds = %56, %58
  %60 = getelementptr inbounds i8, i8* %48, i64 1
  br label %61

; <label>:61:                                     ; preds = %11, %41, %30, %51, %59
  %62 = phi i8* [ %60, %59 ], [ null, %51 ], [ null, %30 ], [ null, %41 ], [ null, %11 ]
  ret i8* %62
}

; Function Attrs: nounwind uwtable
define internal fastcc void @pushutfchar(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1)
  %4 = icmp ult i64 %3, 2147483648
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0))
  br label %7

; <label>:7:                                      ; preds = %5, %2
  %8 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.608, i64 0, i64 0), i64 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @iter_auxlax(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 0)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @iter_auxstrict(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 1)
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @iter_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3)
  %7 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 2, i32* null)
  %8 = icmp slt i64 %7, 1
  br i1 %8, label %21, label %9

; <label>:9:                                      ; preds = %2
  %10 = add nsw i64 %7, -1
  %11 = load i64, i64* %3, align 8, !tbaa !113
  %12 = icmp sgt i64 %7, %11
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %9
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i64 [ %20, %14 ], [ %7, %13 ]
  %16 = getelementptr inbounds i8, i8* %6, i64 %15
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = and i8 %17, -64
  %19 = icmp eq i8 %18, -128
  %20 = add nsw i64 %15, 1
  br i1 %19, label %14, label %21

; <label>:21:                                     ; preds = %14, %2, %9
  %22 = phi i64 [ %10, %9 ], [ 0, %2 ], [ %15, %14 ]
  %23 = load i64, i64* %3, align 8, !tbaa !113
  %24 = icmp slt i64 %22, %23
  br i1 %24, label %25, label %36

; <label>:25:                                     ; preds = %21
  %26 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %26) #7
  %27 = getelementptr inbounds i8, i8* %6, i64 %22
  %28 = call fastcc i8* @utf8_decode(i8* %27, i32* nonnull %4, i32 %1)
  %29 = icmp eq i8* %28, null
  br i1 %29, label %30, label %32

; <label>:30:                                     ; preds = %25
  %31 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0))
  unreachable

; <label>:32:                                     ; preds = %25
  %33 = add nsw i64 %22, 1
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %33)
  %34 = load i32, i32* %4, align 4, !tbaa !70
  %35 = zext i32 %34 to i64
  call void @lua_pushinteger(%struct.lua_State* %0, i64 %35)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %26) #7
  br label %36

; <label>:36:                                     ; preds = %21, %32
  %37 = phi i32 [ 2, %32 ], [ 0, %21 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 %37
}

; Function Attrs: norecurse nounwind uwtable
define internal fastcc i32 @collectargs(i8** nocapture readonly, i32* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds i8*, i8** %0, i64 1
  %4 = load i8*, i8** %3, align 8, !tbaa !79
  %5 = icmp eq i8* %4, null
  store i32 1, i32* %1, align 4, !tbaa !70
  br i1 %5, label %64, label %6

; <label>:6:                                      ; preds = %2
  br label %7

; <label>:7:                                      ; preds = %6, %54
  %8 = phi i8* [ %60, %54 ], [ %4, %6 ]
  %9 = phi i32 [ %57, %54 ], [ 1, %6 ]
  %10 = phi i32 [ %55, %54 ], [ 0, %6 ]
  %11 = load i8, i8* %8, align 1, !tbaa !21
  %12 = icmp eq i8 %11, 45
  br i1 %12, label %13, label %62

; <label>:13:                                     ; preds = %7
  %14 = getelementptr inbounds i8, i8* %8, i64 1
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = sext i8 %15 to i32
  switch i32 %16, label %64 [
    i32 45, label %17
    i32 0, label %62
    i32 69, label %23
    i32 105, label %29
    i32 118, label %31
    i32 101, label %38
    i32 108, label %40
  ]

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds i8, i8* %8, i64 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %64

; <label>:21:                                     ; preds = %17
  %22 = add nsw i32 %9, 1
  store i32 %22, i32* %1, align 4, !tbaa !70
  br label %64

; <label>:23:                                     ; preds = %13
  %24 = getelementptr inbounds i8, i8* %8, i64 2
  %25 = load i8, i8* %24, align 1, !tbaa !21
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %27, label %62

; <label>:27:                                     ; preds = %23
  %28 = or i32 %10, 16
  br label %54

; <label>:29:                                     ; preds = %13
  %30 = or i32 %10, 2
  br label %31

; <label>:31:                                     ; preds = %13, %29
  %32 = phi i32 [ %10, %13 ], [ %30, %29 ]
  %33 = getelementptr inbounds i8, i8* %8, i64 2
  %34 = load i8, i8* %33, align 1, !tbaa !21
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %62

; <label>:36:                                     ; preds = %31
  %37 = or i32 %32, 4
  br label %54

; <label>:38:                                     ; preds = %13
  %39 = or i32 %10, 8
  br label %40

; <label>:40:                                     ; preds = %13, %38
  %41 = phi i32 [ %10, %13 ], [ %39, %38 ]
  %42 = getelementptr inbounds i8, i8* %8, i64 2
  %43 = load i8, i8* %42, align 1, !tbaa !21
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %45, label %54

; <label>:45:                                     ; preds = %40
  %46 = add nsw i32 %9, 1
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds i8*, i8** %0, i64 %47
  %49 = load i8*, i8** %48, align 8, !tbaa !79
  %50 = icmp eq i8* %49, null
  br i1 %50, label %62, label %51

; <label>:51:                                     ; preds = %45
  %52 = load i8, i8* %49, align 1, !tbaa !21
  %53 = icmp eq i8 %52, 45
  br i1 %53, label %62, label %54

; <label>:54:                                     ; preds = %27, %36, %51, %40
  %55 = phi i32 [ %41, %51 ], [ %41, %40 ], [ %37, %36 ], [ %28, %27 ]
  %56 = phi i32 [ %46, %51 ], [ %9, %40 ], [ %9, %36 ], [ %9, %27 ]
  %57 = add nsw i32 %56, 1
  %58 = sext i32 %57 to i64
  %59 = getelementptr inbounds i8*, i8** %0, i64 %58
  %60 = load i8*, i8** %59, align 8, !tbaa !79
  %61 = icmp eq i8* %60, null
  store i32 %57, i32* %1, align 4, !tbaa !70
  br i1 %61, label %62, label %7

; <label>:62:                                     ; preds = %54, %45, %51, %31, %23, %13, %7
  %63 = phi i32 [ %55, %54 ], [ 1, %45 ], [ 1, %51 ], [ 1, %31 ], [ 1, %23 ], [ %10, %13 ], [ %10, %7 ]
  br label %64

; <label>:64:                                     ; preds = %13, %62, %2, %17, %21
  %65 = phi i32 [ %10, %21 ], [ 1, %17 ], [ 0, %2 ], [ %63, %62 ], [ 1, %13 ]
  ret i32 %65
}

; Function Attrs: nounwind uwtable
define internal fastcc void @print_usage(i8*) unnamed_addr #0 {
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %3 = load i8*, i8** @progname, align 8, !tbaa !79
  %4 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* %3) #22
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5)
  %7 = getelementptr inbounds i8, i8* %0, i64 1
  %8 = load i8, i8* %7, align 1, !tbaa !21
  switch i8 %8, label %14 [
    i8 101, label %9
    i8 108, label %9
  ]

; <label>:9:                                      ; preds = %1, %1
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %11 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.618, i64 0, i64 0), i8* nonnull %0) #22
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %13 = tail call i32 @fflush(%struct._IO_FILE* %12)
  br label %19

; <label>:14:                                     ; preds = %1
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %16 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.619, i64 0, i64 0), i8* nonnull %0) #22
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %18 = tail call i32 @fflush(%struct._IO_FILE* %17)
  br label %19

; <label>:19:                                     ; preds = %14, %9
  %20 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %21 = load i8*, i8** @progname, align 8, !tbaa !79
  %22 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %20, i8* getelementptr inbounds ([365 x i8], [365 x i8]* @.str.620, i64 0, i64 0), i8* %21) #22
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !79
  %24 = tail call i32 @fflush(%struct._IO_FILE* %23)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @print_version() unnamed_addr #0 {
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %2 = tail call i64 @fwrite(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.621, i64 0, i64 0), i64 1, i64 51, %struct._IO_FILE* %1)
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %4 = tail call i32 @fputc(i32 10, %struct._IO_FILE* %3)
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @createargtable(%struct.lua_State*, i8** nocapture readonly, i32, i32) unnamed_addr #0 {
  %5 = icmp eq i32 %3, %2
  %6 = select i1 %5, i32 0, i32 %3
  %7 = add nsw i32 %6, 1
  %8 = sub nsw i32 %2, %7
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %8, i32 %7)
  %9 = icmp sgt i32 %2, 0
  br i1 %9, label %10, label %22

; <label>:10:                                     ; preds = %4
  %11 = zext i32 %2 to i64
  br label %12

; <label>:12:                                     ; preds = %12, %10
  %13 = phi i64 [ 0, %10 ], [ %20, %12 ]
  %14 = getelementptr inbounds i8*, i8** %1, i64 %13
  %15 = load i8*, i8** %14, align 8, !tbaa !79
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %15)
  %17 = trunc i64 %13 to i32
  %18 = sub nsw i32 %17, %6
  %19 = sext i32 %18 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 -2, i64 %19)
  %20 = add nuw nsw i64 %13, 1
  %21 = icmp eq i64 %20, %11
  br i1 %21, label %22, label %12

; <label>:22:                                     ; preds = %12, %4
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @handle_luainit(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @getenv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 1)) #7
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %7

; <label>:4:                                      ; preds = %1
  %5 = tail call i8* @getenv(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 1)) #7
  %6 = icmp eq i8* %5, null
  br i1 %6, label %17, label %7

; <label>:7:                                      ; preds = %1, %4
  %8 = phi i8* [ %5, %4 ], [ %2, %1 ]
  %9 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 0), %4 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 0), %1 ]
  %10 = load i8, i8* %8, align 1, !tbaa !21
  %11 = icmp eq i8 %10, 64
  br i1 %11, label %12, label %15

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds i8, i8* %8, i64 1
  %14 = tail call fastcc i32 @dofile(%struct.lua_State* %0, i8* nonnull %13)
  br label %17

; <label>:15:                                     ; preds = %7
  %16 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* nonnull %8, i8* %9)
  br label %17

; <label>:17:                                     ; preds = %4, %15, %12
  %18 = phi i32 [ %14, %12 ], [ %16, %15 ], [ 0, %4 ]
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @runargs(%struct.lua_State*, i8** nocapture readonly, i32) unnamed_addr #0 {
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %5, label %37

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %33
  %7 = phi i32 [ %35, %33 ], [ 1, %5 ]
  %8 = sext i32 %7 to i64
  %9 = getelementptr inbounds i8*, i8** %1, i64 %8
  %10 = load i8*, i8** %9, align 8, !tbaa !79
  %11 = getelementptr inbounds i8, i8* %10, i64 1
  %12 = load i8, i8* %11, align 1, !tbaa !21
  %13 = icmp eq i8 %12, 101
  switch i8 %12, label %33 [
    i8 108, label %14
    i8 101, label %14
  ]

; <label>:14:                                     ; preds = %6, %6
  %15 = getelementptr inbounds i8, i8* %10, i64 2
  %16 = load i8, i8* %15, align 1, !tbaa !21
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %14
  %19 = add nsw i32 %7, 1
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i8*, i8** %1, i64 %20
  %22 = load i8*, i8** %21, align 8, !tbaa !79
  br label %23

; <label>:23:                                     ; preds = %18, %14
  %24 = phi i32 [ %19, %18 ], [ %7, %14 ]
  %25 = phi i8* [ %22, %18 ], [ %15, %14 ]
  br i1 %13, label %26, label %28

; <label>:26:                                     ; preds = %23
  %27 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* %25, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.627, i64 0, i64 0))
  br label %30

; <label>:28:                                     ; preds = %23
  %29 = tail call fastcc i32 @dolibrary(%struct.lua_State* %0, i8* %25)
  br label %30

; <label>:30:                                     ; preds = %28, %26
  %31 = phi i32 [ %27, %26 ], [ %29, %28 ]
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %37

; <label>:33:                                     ; preds = %6, %30
  %34 = phi i32 [ %24, %30 ], [ %7, %6 ]
  %35 = add nsw i32 %34, 1
  %36 = icmp slt i32 %35, %2
  br i1 %36, label %6, label %37

; <label>:37:                                     ; preds = %33, %30, %3
  %38 = phi i32 [ 1, %3 ], [ 0, %30 ], [ 1, %33 ]
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @handle_script(%struct.lua_State*, i8** nocapture readonly) unnamed_addr #0 {
  %3 = load i8*, i8** %1, align 8, !tbaa !79
  %4 = tail call i32 @strcmp(i8* %3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.481, i64 0, i64 0)) #19
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds i8*, i8** %1, i64 -1
  %8 = load i8*, i8** %7, align 8, !tbaa !79
  %9 = tail call i32 @strcmp(i8* %8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.628, i64 0, i64 0)) #19
  %10 = icmp eq i32 %9, 0
  %11 = select i1 %10, i8* %3, i8* null
  br label %12

; <label>:12:                                     ; preds = %6, %2
  %13 = phi i8* [ %3, %2 ], [ %11, %6 ]
  %14 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %13, i8* null)
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %12
  %17 = tail call fastcc i32 @pushargs(%struct.lua_State* %0)
  %18 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 %17, i32 -1)
  br label %19

; <label>:19:                                     ; preds = %16, %12
  %20 = phi i32 [ %18, %16 ], [ %14, %12 ]
  %21 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %20)
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define internal fastcc void @doREPL(%struct.lua_State*) unnamed_addr #0 {
  %2 = load i64, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !79
  store i8* null, i8** @progname, align 8, !tbaa !79
  br label %3

; <label>:3:                                      ; preds = %12, %1
  %4 = tail call fastcc i32 @loadline(%struct.lua_State* %0)
  switch i32 %4, label %9 [
    i32 -1, label %13
    i32 0, label %5
  ]

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 0, i32 -1)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %5
  tail call fastcc void @l_print(%struct.lua_State* %0)
  br label %12

; <label>:9:                                      ; preds = %3, %5
  %10 = phi i32 [ %6, %5 ], [ %4, %3 ]
  %11 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %10)
  br label %12

; <label>:12:                                     ; preds = %9, %8
  br label %3

; <label>:13:                                     ; preds = %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 0)
  %14 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %15 = tail call i32 @fputc(i32 10, %struct._IO_FILE* %14)
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %17 = tail call i32 @fflush(%struct._IO_FILE* %16)
  store i64 %2, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !79
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @dofile(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %1, i8* null)
  %4 = tail call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %3)
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @dostring(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i64 @strlen(i8* %1) #19
  %5 = tail call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %1, i64 %4, i8* %2, i8* null)
  %6 = tail call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %5)
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @dochunk(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %2
  %5 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 0, i32 0)
  br label %6

; <label>:6:                                      ; preds = %4, %2
  %7 = phi i32 [ %5, %4 ], [ %1, %2 ]
  %8 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %7)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @docall(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %5 = sub nsw i32 %4, %1
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @msghandler, i32 0)
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %5, i32 1)
  store %struct.lua_State* %0, %struct.lua_State** @globalL, align 8, !tbaa !79
  %6 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* nonnull @laction) #7
  %7 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %1, i32 %2, i32 %5, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %8 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* null) #7
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %5, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @msghandler(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null)
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %14

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0))
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %10, label %7

; <label>:7:                                      ; preds = %4
  %8 = tail call i32 @lua_type(%struct.lua_State* %0, i32 -1)
  %9 = icmp eq i32 %8, 4
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %4, %7
  %11 = tail call i32 @lua_type(%struct.lua_State* %0, i32 1)
  %12 = tail call i8* @lua_typename(%struct.lua_State* undef, i32 %11)
  %13 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.625, i64 0, i64 0), i8* %12)
  br label %14

; <label>:14:                                     ; preds = %10, %1
  %15 = phi i8* [ %13, %10 ], [ %2, %1 ]
  tail call void @luaL_traceback(%struct.lua_State* %0, %struct.lua_State* %0, i8* nonnull %15, i32 1)
  br label %16

; <label>:16:                                     ; preds = %7, %14
  ret i32 1
}

; Function Attrs: nounwind
declare void (i32)* @__sysv_signal(i32, void (i32)*) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal void @laction(i32) #0 {
  %2 = tail call void (i32)* @__sysv_signal(i32 %0, void (i32)* null) #7
  %3 = load %struct.lua_State*, %struct.lua_State** @globalL, align 8, !tbaa !79
  tail call void @lua_sethook(%struct.lua_State* %3, void (%struct.lua_State*, %struct.lua_Debug*)* nonnull @lstop, i32 11, i32 1)
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @lstop(%struct.lua_State*, %struct.lua_Debug* nocapture readnone) #5 {
  tail call void @lua_sethook(%struct.lua_State* %0, void (%struct.lua_State*, %struct.lua_Debug*)* null, i32 0, i32 0)
  %3 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.626, i64 0, i64 0))
  unreachable
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @dolibrary(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i64 0, i64 0))
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %1)
  %5 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 1, i32 1)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %2
  tail call void @lua_setglobal(%struct.lua_State* %0, i8* %1)
  br label %8

; <label>:8:                                      ; preds = %7, %2
  %9 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %5)
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @pushargs(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0))
  %3 = icmp eq i32 %2, 5
  br i1 %3, label %6, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.629, i64 0, i64 0))
  unreachable

; <label>:6:                                      ; preds = %1
  %7 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 -1)
  %8 = trunc i64 %7 to i32
  %9 = add nsw i32 %8, 3
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %9, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.630, i64 0, i64 0))
  %10 = icmp slt i32 %8, 1
  br i1 %10, label %25, label %11

; <label>:11:                                     ; preds = %6
  %12 = add i64 %7, 1
  %13 = and i64 %12, 4294967295
  br label %14

; <label>:14:                                     ; preds = %14, %11
  %15 = phi i64 [ %19, %14 ], [ 1, %11 ]
  %16 = phi i32 [ %21, %14 ], [ -1, %11 ]
  %17 = phi i32 [ %20, %14 ], [ 1, %11 ]
  %18 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %16, i64 %15)
  %19 = add nuw nsw i64 %15, 1
  %20 = add nuw nsw i32 %17, 1
  %21 = xor i32 %17, -1
  %22 = icmp eq i64 %19, %13
  br i1 %22, label %23, label %14

; <label>:23:                                     ; preds = %14
  %24 = xor i32 %8, -1
  br label %25

; <label>:25:                                     ; preds = %23, %6
  %26 = phi i32 [ -1, %6 ], [ %24, %23 ]
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %26, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @loadline(%struct.lua_State*) unnamed_addr #0 {
  tail call void @lua_settop(%struct.lua_State* %0, i32 0)
  %2 = tail call fastcc i32 @pushline(%struct.lua_State* %0, i32 1)
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %11, label %4

; <label>:4:                                      ; preds = %1
  %5 = tail call fastcc i32 @addreturn(%struct.lua_State* %0)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %4
  %8 = tail call fastcc i32 @multiline(%struct.lua_State* %0)
  br label %9

; <label>:9:                                      ; preds = %4, %7
  %10 = phi i32 [ %8, %7 ], [ 0, %4 ]
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  br label %11

; <label>:11:                                     ; preds = %1, %9
  %12 = phi i32 [ %10, %9 ], [ -1, %1 ]
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal fastcc void @l_print(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i32 @lua_gettop(%struct.lua_State* %0)
  %3 = icmp sgt i32 %2, 0
  br i1 %3, label %4, label %12

; <label>:4:                                      ; preds = %1
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 20, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.637, i64 0, i64 0))
  %5 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i64 0, i64 0))
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1)
  %6 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %2, i32 0, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* null)
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %12, label %8

; <label>:8:                                      ; preds = %4
  %9 = load i8*, i8** @progname, align 8, !tbaa !79
  %10 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %11 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.638, i64 0, i64 0), i8* %10)
  tail call fastcc void @l_message(i8* %9, i8* nonnull %11)
  br label %12

; <label>:12:                                     ; preds = %4, %8, %1
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @pushline(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [512 x i8], align 16
  %4 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %4) #7
  %5 = tail call fastcc i8* @get_prompt(%struct.lua_State* %0, i32 %1)
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %7 = tail call i32 @fputs(i8* %5, %struct._IO_FILE* %6)
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !79
  %9 = tail call i32 @fflush(%struct._IO_FILE* %8)
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !79
  %11 = call i8* @fgets(i8* nonnull %4, i32 512, %struct._IO_FILE* %10)
  %12 = icmp eq i8* %11, null
  br i1 %12, label %33, label %13

; <label>:13:                                     ; preds = %2
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  %14 = call i64 @strlen(i8* nonnull %4) #19
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %13
  %17 = add i64 %14, -1
  %18 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 %17
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 10
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %16
  store i8 0, i8* %18, align 1, !tbaa !21
  br label %22

; <label>:22:                                     ; preds = %13, %21, %16
  %23 = phi i64 [ %17, %21 ], [ %14, %16 ], [ 0, %13 ]
  %24 = icmp ne i32 %1, 0
  %25 = load i8, i8* %4, align 16
  %26 = icmp eq i8 %25, 61
  %27 = and i1 %24, %26
  br i1 %27, label %28, label %31

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 1
  %30 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.631, i64 0, i64 0), i8* nonnull %29)
  br label %33

; <label>:31:                                     ; preds = %22
  %32 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* nonnull %4, i64 %23)
  br label %33

; <label>:33:                                     ; preds = %28, %31, %2
  %34 = phi i32 [ 0, %2 ], [ 1, %31 ], [ 1, %28 ]
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %4) #7
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @addreturn(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %3 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.636, i64 0, i64 0), i8* %2)
  %4 = tail call i64 @strlen(i8* nonnull %3) #19
  %5 = tail call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* nonnull %3, i64 %4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null)
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1)
  tail call void @lua_settop(%struct.lua_State* %0, i32 -2)
  ret i32 0

; <label>:8:                                      ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 -3)
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal fastcc i32 @multiline(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %5 = load i64, i64* %2, align 8, !tbaa !113
  %6 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %4, i64 %5, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null)
  %7 = call fastcc i32 @incomplete(%struct.lua_State* %0, i32 %6)
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %21, label %9

; <label>:9:                                      ; preds = %1
  br label %10

; <label>:10:                                     ; preds = %9, %14
  %11 = phi i32 [ %18, %14 ], [ %6, %9 ]
  %12 = call fastcc i32 @pushline(%struct.lua_State* %0, i32 0)
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %21, label %14

; <label>:14:                                     ; preds = %10
  %15 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.300, i64 0, i64 0))
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1)
  call void @lua_concat(%struct.lua_State* %0, i32 3)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %16 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %2)
  %17 = load i64, i64* %2, align 8, !tbaa !113
  %18 = call i32 @luaL_loadbufferx(%struct.lua_State* %0, i8* %16, i64 %17, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null)
  %19 = call fastcc i32 @incomplete(%struct.lua_State* %0, i32 %18)
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %10

; <label>:21:                                     ; preds = %14, %10, %1
  %22 = phi i32 [ %6, %1 ], [ %11, %10 ], [ %18, %14 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal fastcc i8* @get_prompt(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp ne i32 %1, 0
  %4 = select i1 %3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.632, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.633, i64 0, i64 0)
  %5 = tail call i32 @lua_getglobal(%struct.lua_State* %0, i8* %4)
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null)
  %7 = icmp eq i8* %6, null
  %8 = select i1 %3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.634, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.635, i64 0, i64 0)
  %9 = select i1 %7, i8* %8, i8* %6
  ret i8* %9
}

; Function Attrs: nounwind
declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind uwtable
define internal fastcc i32 @incomplete(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = icmp eq i32 %1, 3
  br i1 %4, label %5, label %17

; <label>:5:                                      ; preds = %2
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* nonnull %3)
  %8 = load i64, i64* %3, align 8, !tbaa !113
  %9 = icmp ugt i64 %8, 4
  br i1 %9, label %10, label %16

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds i8, i8* %7, i64 %8
  %12 = getelementptr inbounds i8, i8* %11, i64 -5
  %13 = call i32 @strcmp(i8* nonnull %12, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i64 0, i64 0)) #19
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %16

; <label>:15:                                     ; preds = %10
  call void @lua_settop(%struct.lua_State* %0, i32 -2)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  br label %17

; <label>:16:                                     ; preds = %5, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  br label %17

; <label>:17:                                     ; preds = %2, %16, %15
  %18 = phi i32 [ 1, %15 ], [ 0, %16 ], [ 0, %2 ]
  ret i32 %18
}

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #7

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { norecurse nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { norecurse nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { noreturn nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { norecurse nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { argmemonly nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #12 = { nounwind returns_twice "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #13 = { nounwind readnone speculatable }
attributes #14 = { nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #15 = { noreturn nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #16 = { inlinehint nounwind readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #17 = { noreturn }
attributes #18 = { nounwind returns_twice }
attributes #19 = { nounwind readonly }
attributes #20 = { noreturn nounwind }
attributes #21 = { nounwind readnone }
attributes #22 = { cold }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"lua_State", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !7, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !8, i64 96, !4, i64 160, !9, i64 168, !10, i64 176, !10, i64 180, !10, i64 184, !10, i64 188, !10, i64 192}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"short", !5, i64 0}
!8 = !{!"CallInfo", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !5, i64 32, !5, i64 56, !7, i64 60, !7, i64 62}
!9 = !{!"long", !5, i64 0}
!10 = !{!"int", !5, i64 0}
!11 = !{!12, !9, i64 24}
!12 = !{!"global_State", !4, i64 0, !4, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !13, i64 48, !14, i64 64, !14, i64 80, !10, i64 96, !5, i64 100, !5, i64 101, !5, i64 102, !5, i64 103, !5, i64 104, !5, i64 105, !5, i64 106, !5, i64 107, !5, i64 108, !5, i64 109, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !5, i64 272, !5, i64 472, !5, i64 544, !4, i64 1392, !4, i64 1400}
!13 = !{!"stringtable", !4, i64 0, !10, i64 8, !10, i64 12}
!14 = !{!"TValue", !5, i64 0, !5, i64 8}
!15 = !{!12, !5, i64 100}
!16 = !{!3, !5, i64 9}
!17 = !{!3, !5, i64 8}
!18 = !{!12, !4, i64 112}
!19 = !{!3, !4, i64 0}
!20 = !{!3, !4, i64 16}
!21 = !{!5, !5, i64 0}
!22 = !{!14, !5, i64 8}
!23 = !{!3, !10, i64 192}
!24 = !{!3, !10, i64 184}
!25 = !{!3, !4, i64 160}
!26 = !{!3, !10, i64 188}
!27 = !{!12, !4, i64 256}
!28 = !{!12, !5, i64 105}
!29 = !{!12, !5, i64 102}
!30 = !{!12, !9, i64 40}
!31 = !{!12, !4, i64 0}
!32 = !{!12, !4, i64 8}
!33 = !{!"branch_weights", i32 1, i32 2000}
!34 = !{!3, !4, i64 56}
!35 = !{!3, !4, i64 32}
!36 = !{!3, !7, i64 12}
!37 = !{!3, !10, i64 180}
!38 = !{!3, !4, i64 80}
!39 = !{!3, !4, i64 88}
!40 = !{!3, !10, i64 176}
!41 = !{!3, !5, i64 11}
!42 = !{!3, !4, i64 64}
!43 = !{!3, !5, i64 10}
!44 = !{!3, !9, i64 168}
!45 = !{!3, !4, i64 48}
!46 = !{!8, !7, i64 62}
!47 = !{!8, !4, i64 0}
!48 = !{!8, !7, i64 60}
!49 = !{!8, !4, i64 8}
!50 = !{!51, !4, i64 16}
!51 = !{!"UpVal", !4, i64 0, !5, i64 8, !5, i64 9, !4, i64 16, !5, i64 24}
!52 = !{!51, !5, i64 9}
!53 = !{!54, !5, i64 9}
!54 = !{!"GCObject", !4, i64 0, !5, i64 8, !5, i64 9}
!55 = !{!51, !5, i64 8}
!56 = !{!12, !4, i64 264}
!57 = !{!58, !5, i64 8}
!58 = !{!"TString", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !5, i64 16}
!59 = !{!12, !10, i64 96}
!60 = !{!12, !5, i64 72}
!61 = !{!12, !4, i64 248}
!62 = !{!12, !5, i64 101}
!63 = !{!12, !5, i64 106}
!64 = !{!12, !9, i64 16}
!65 = !{!12, !5, i64 107}
!66 = !{!12, !5, i64 108}
!67 = !{!12, !5, i64 109}
!68 = !{!12, !5, i64 104}
!69 = !{!12, !5, i64 103}
!70 = !{!10, !10, i64 0}
!71 = !{!72, !10, i64 208}
!72 = !{!"lua_longjmp", !4, i64 0, !5, i64 8, !10, i64 208}
!73 = !{!72, !4, i64 0}
!74 = !{!12, !5, i64 88}
!75 = !{!12, !4, i64 48}
!76 = !{!12, !10, i64 60}
!77 = !{!3, !4, i64 40}
!78 = !{!8, !4, i64 16}
!79 = !{!4, !4, i64 0}
!80 = !{!81, !4, i64 128}
!81 = !{!"lua_Debug", !10, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !9, i64 40, !10, i64 48, !10, i64 52, !10, i64 56, !5, i64 60, !5, i64 61, !5, i64 62, !5, i64 63, !7, i64 64, !7, i64 66, !5, i64 68, !4, i64 128}
!82 = !{!83, !10, i64 36}
!83 = !{!"Proto", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !5, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120}
!84 = !{!83, !4, i64 104}
!85 = !{!86, !10, i64 8}
!86 = !{!"LocVar", !4, i64 0, !10, i64 8, !10, i64 12}
!87 = !{!86, !10, i64 12}
!88 = !{!86, !4, i64 0}
!89 = !{!8, !4, i64 24}
!90 = !{!81, !10, i64 48}
!91 = !{!81, !5, i64 60}
!92 = !{!81, !5, i64 62}
!93 = !{!81, !5, i64 61}
!94 = !{!83, !5, i64 11}
!95 = !{!83, !5, i64 10}
!96 = !{!81, !5, i64 63}
!97 = !{!81, !4, i64 16}
!98 = !{!81, !4, i64 8}
!99 = !{!81, !7, i64 66}
!100 = !{!81, !7, i64 64}
!101 = !{!83, !10, i64 44}
!102 = !{!83, !10, i64 28}
!103 = !{!"branch_weights", i32 2000, i32 1}
!104 = !{!83, !4, i64 112}
!105 = !{!106, !5, i64 10}
!106 = !{!"CClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!107 = !{!108, !108, i64 0}
!108 = !{!"double", !5, i64 0}
!109 = !{!110, !110, i64 0}
!110 = !{!"long long", !5, i64 0}
!111 = !{!112, !5, i64 10}
!112 = !{!"Table", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!113 = !{!9, !9, i64 0}
!114 = !{!112, !10, i64 12}
!115 = !{!112, !4, i64 16}
!116 = !{!112, !5, i64 9}
!117 = !{!112, !4, i64 32}
!118 = !{!119, !10, i64 12}
!119 = !{!"BuffFS", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!120 = !{!119, !10, i64 8}
!121 = !{!119, !4, i64 0}
!122 = !{!106, !4, i64 24}
!123 = !{!112, !4, i64 24}
!124 = !{!112, !5, i64 11}
!125 = !{!112, !4, i64 40}
!126 = !{!12, !4, i64 144}
!127 = !{!12, !4, i64 120}
!128 = !{!12, !4, i64 192}
!129 = !{!54, !4, i64 0}
!130 = !{!12, !4, i64 200}
!131 = !{!12, !4, i64 208}
!132 = !{!12, !4, i64 128}
!133 = !{!83, !5, i64 12}
!134 = !{!83, !4, i64 64}
!135 = !{!136, !4, i64 0}
!136 = !{!"CallS", !4, i64 0, !10, i64 8}
!137 = !{!136, !10, i64 8}
!138 = !{!139, !5, i64 10}
!139 = !{!"LClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!140 = !{!141, !4, i64 32}
!141 = !{!"Zio", !9, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32}
!142 = !{!141, !4, i64 16}
!143 = !{!141, !4, i64 24}
!144 = !{!145, !4, i64 0}
!145 = !{!"SParser", !4, i64 0, !146, i64 8, !147, i64 32, !4, i64 80, !4, i64 88}
!146 = !{!"Mbuffer", !4, i64 0, !9, i64 8, !9, i64 16}
!147 = !{!"Dyndata", !148, i64 0, !149, i64 16, !149, i64 32}
!148 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12}
!149 = !{!"Labellist", !4, i64 0, !10, i64 8, !10, i64 12}
!150 = !{!145, !4, i64 88}
!151 = !{!145, !4, i64 80}
!152 = !{!145, !10, i64 44}
!153 = !{!145, !4, i64 48}
!154 = !{!145, !10, i64 60}
!155 = !{!145, !4, i64 64}
!156 = !{!145, !10, i64 76}
!157 = !{!145, !4, i64 8}
!158 = !{!145, !9, i64 24}
!159 = !{!145, !4, i64 32}
!160 = !{!161, !4, i64 0}
!161 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16, !10, i64 24, !10, i64 28}
!162 = !{!161, !4, i64 8}
!163 = !{!161, !4, i64 16}
!164 = !{!161, !10, i64 24}
!165 = !{!161, !10, i64 28}
!166 = !{!83, !10, i64 16}
!167 = !{!12, !4, i64 1400}
!168 = !{!12, !4, i64 1392}
!169 = !{!170, !7, i64 10}
!170 = !{!"Udata", !4, i64 0, !5, i64 8, !5, i64 9, !7, i64 10, !9, i64 16, !4, i64 24, !4, i64 32, !5, i64 40}
!171 = !{!170, !9, i64 16}
!172 = !{!170, !4, i64 24}
!173 = !{!139, !4, i64 24}
!174 = !{!83, !4, i64 80}
!175 = !{!176, !4, i64 0}
!176 = !{!"Upvaldesc", !4, i64 0, !5, i64 8, !5, i64 9}
!177 = !{!139, !5, i64 9}
!178 = !{!81, !4, i64 24}
!179 = !{!81, !10, i64 52}
!180 = !{!181, !9, i64 8}
!181 = !{!"luaL_Buffer", !4, i64 0, !9, i64 8, !9, i64 16, !4, i64 24, !5, i64 32}
!182 = !{!181, !9, i64 16}
!183 = !{!181, !4, i64 0}
!184 = !{!181, !4, i64 24}
!185 = !{!186, !4, i64 8}
!186 = !{!"LoadF", !10, i64 0, !4, i64 8, !5, i64 16}
!187 = !{!186, !10, i64 0}
!188 = !{!189, !4, i64 0}
!189 = !{!"LoadS", !4, i64 0, !9, i64 8}
!190 = !{!189, !9, i64 8}
!191 = !{!192, !4, i64 0}
!192 = !{!"luaL_Reg", !4, i64 0, !4, i64 8}
!193 = !{!192, !4, i64 8}
!194 = !{!195, !4, i64 0}
!195 = !{!"luaL_Stream", !4, i64 0, !4, i64 8}
!196 = !{!195, !4, i64 8}
!197 = !{!13, !4, i64 0}
!198 = !{!13, !10, i64 12}
!199 = !{!58, !5, i64 10}
!200 = !{!58, !10, i64 12}
!201 = !{!12, !4, i64 184}
!202 = !{!12, !4, i64 224}
!203 = !{!12, !4, i64 216}
!204 = !{!12, !4, i64 176}
!205 = !{!54, !5, i64 8}
!206 = !{!83, !10, i64 24}
!207 = !{!83, !4, i64 72}
!208 = !{!83, !10, i64 32}
!209 = !{!83, !4, i64 56}
!210 = !{!83, !10, i64 20}
!211 = !{!83, !4, i64 88}
!212 = !{!83, !4, i64 96}
!213 = !{!83, !10, i64 40}
!214 = !{!13, !10, i64 8}
!215 = !{!12, !9, i64 32}
!216 = !{!12, !4, i64 232}
!217 = !{!12, !4, i64 136}
!218 = !{!12, !4, i64 152}
!219 = !{!12, !4, i64 168}
!220 = !{!12, !4, i64 160}
!221 = !{!3, !4, i64 72}
!222 = !{!12, !10, i64 56}
!223 = !{!112, !4, i64 48}
!224 = !{!170, !4, i64 32}
!225 = !{!170, !5, i64 9}
!226 = !{!83, !5, i64 9}
!227 = !{!58, !5, i64 9}
!228 = !{!12, !4, i64 240}
!229 = !{!81, !4, i64 32}
!230 = !{!81, !9, i64 40}
!231 = !{!81, !10, i64 56}
!232 = !{!58, !5, i64 11}
!233 = !{!83, !10, i64 48}
!234 = !{!235, !10, i64 0}
!235 = !{!"AbsLineInfo", !10, i64 0, !10, i64 4}
!236 = !{!176, !5, i64 8}
!237 = !{!176, !5, i64 9}
!238 = !{!81, !10, i64 0}
!239 = !{!240, !4, i64 0}
!240 = !{!"lconv", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !5, i64 80, !5, i64 81, !5, i64 82, !5, i64 83, !5, i64 84, !5, i64 85, !5, i64 86, !5, i64 87, !5, i64 88, !5, i64 89, !5, i64 90, !5, i64 91, !5, i64 92, !5, i64 93}
!241 = !{i64 0, i64 8, !79, i64 0, i64 8, !79, i64 0, i64 4, !70, i64 0, i64 8, !79, i64 0, i64 8, !109, i64 0, i64 8, !107, i64 8, i64 1, !21, i64 9, i64 1, !21, i64 12, i64 4, !70, i64 16, i64 8, !79, i64 16, i64 8, !79, i64 16, i64 4, !70, i64 16, i64 8, !79, i64 16, i64 8, !109, i64 16, i64 8, !107, i64 0, i64 8, !79, i64 0, i64 8, !79, i64 0, i64 4, !70, i64 0, i64 8, !79, i64 0, i64 8, !109, i64 0, i64 8, !107, i64 8, i64 1, !21}
!242 = !{!141, !9, i64 0}
!243 = !{!141, !4, i64 8}
!244 = !{!245, !4, i64 16}
!245 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16}
!246 = !{!245, !4, i64 0}
!247 = !{!245, !4, i64 8}
!248 = !{!249, !4, i64 80}
!249 = !{!"LexState", !10, i64 0, !10, i64 4, !10, i64 8, !250, i64 16, !250, i64 32, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104}
!250 = !{!"Token", !10, i64 0, !5, i64 8}
!251 = !{!252, !4, i64 0}
!252 = !{!"FuncState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !10, i64 52, !10, i64 56, !10, i64 60, !7, i64 64, !5, i64 66, !5, i64 67, !5, i64 68, !5, i64 69, !5, i64 70}
!253 = !{!249, !4, i64 72}
!254 = !{!249, !4, i64 88}
!255 = !{!147, !10, i64 40}
!256 = !{!147, !10, i64 24}
!257 = !{!147, !10, i64 8}
!258 = !{!235, !10, i64 4}
!259 = !{!249, !10, i64 16}
!260 = !{!249, !4, i64 56}
!261 = !{!249, !10, i64 0}
!262 = !{!249, !10, i64 32}
!263 = !{!249, !4, i64 64}
!264 = !{!249, !4, i64 48}
!265 = !{!249, !10, i64 4}
!266 = !{!249, !10, i64 8}
!267 = !{!249, !4, i64 96}
!268 = !{!249, !4, i64 104}
!269 = !{!146, !4, i64 0}
!270 = !{!146, !9, i64 16}
!271 = !{!252, !4, i64 8}
!272 = !{!252, !4, i64 16}
!273 = !{!252, !10, i64 32}
!274 = !{!252, !10, i64 40}
!275 = !{!252, !10, i64 36}
!276 = !{!252, !10, i64 44}
!277 = !{!252, !10, i64 52}
!278 = !{!252, !10, i64 48}
!279 = !{!252, !10, i64 56}
!280 = !{!252, !10, i64 60}
!281 = !{!252, !4, i64 24}
!282 = !{!283, !10, i64 16}
!283 = !{!"expdesc", !5, i64 0, !5, i64 8, !10, i64 16, !10, i64 20}
!284 = !{!283, !10, i64 20}
!285 = !{!283, !5, i64 0}
!286 = !{!252, !5, i64 67}
!287 = !{i64 0, i64 4, !70, i64 8, i64 8, !107, i64 8, i64 8, !109, i64 8, i64 8, !79}
!288 = !{!252, !5, i64 66}
!289 = !{!252, !7, i64 64}
!290 = !{!291, !5, i64 18}
!291 = !{!"BlockCnt", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19}
!292 = !{!291, !5, i64 16}
!293 = !{!291, !10, i64 8}
!294 = !{!291, !10, i64 12}
!295 = !{!291, !5, i64 17}
!296 = !{!291, !5, i64 19}
!297 = !{!291, !4, i64 0}
!298 = !{!252, !5, i64 69}
!299 = !{!146, !9, i64 8}
!300 = !{!252, !5, i64 68}
!301 = !{!302, !5, i64 16}
!302 = !{!"Labeldesc", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17}
!303 = !{!302, !10, i64 8}
!304 = !{!305, !4, i64 0}
!305 = !{!"LHS_assign", !4, i64 0, !283, i64 8}
!306 = !{!305, !5, i64 8}
!307 = !{!147, !4, i64 16}
!308 = !{!309, !5, i64 0}
!309 = !{!"", !5, i64 0, !5, i64 1}
!310 = !{!309, !5, i64 1}
!311 = !{i64 0, i64 4, !21, i64 8, i64 8, !109, i64 8, i64 8, !107, i64 8, i64 4, !70, i64 8, i64 2, !312, i64 10, i64 1, !21, i64 16, i64 4, !70, i64 20, i64 4, !70}
!312 = !{!7, !7, i64 0}
!313 = !{!314, !10, i64 40}
!314 = !{!"ConsControl", !283, i64 0, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40}
!315 = !{!314, !10, i64 32}
!316 = !{!314, !10, i64 36}
!317 = !{!314, !4, i64 24}
!318 = !{!314, !5, i64 0}
!319 = !{!147, !4, i64 0}
!320 = !{!321, !7, i64 0}
!321 = !{!"Vardesc", !7, i64 0}
!322 = !{!252, !5, i64 70}
!323 = !{!147, !4, i64 32}
!324 = !{!302, !4, i64 0}
!325 = !{!149, !10, i64 8}
!326 = !{!149, !4, i64 0}
!327 = !{!302, !10, i64 12}
!328 = !{!302, !5, i64 17}
!329 = !{i64 0, i64 8, !79, i64 8, i64 4, !70, i64 12, i64 4, !70, i64 16, i64 1, !21, i64 17, i64 1, !21}
!330 = !{!331, !4, i64 0}
!331 = !{!"UBox", !4, i64 0, !9, i64 8}
!332 = !{!331, !9, i64 8}
!333 = !{!334, !4, i64 0}
!334 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!335 = !{!334, !10, i64 12}
!336 = !{!334, !10, i64 8}
!337 = !{!338, !10, i64 0}
!338 = !{!"tm", !10, i64 0, !10, i64 4, !10, i64 8, !10, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !9, i64 40, !4, i64 48}
!339 = !{!338, !10, i64 4}
!340 = !{!338, !10, i64 8}
!341 = !{!338, !10, i64 12}
!342 = !{!338, !10, i64 16}
!343 = !{!338, !10, i64 20}
!344 = !{!338, !10, i64 32}
!345 = !{!338, !10, i64 24}
!346 = !{!338, !10, i64 28}
!347 = !{!348, !4, i64 0}
!348 = !{!"GMatchState", !4, i64 0, !4, i64 8, !4, i64 16, !349, i64 24}
!349 = !{!"MatchState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !5, i64 36, !5, i64 40}
!350 = !{!348, !4, i64 8}
!351 = !{!348, !4, i64 16}
!352 = !{!349, !4, i64 8}
!353 = !{!354, !10, i64 8}
!354 = !{!"Header", !4, i64 0, !10, i64 8, !10, i64 12}
!355 = !{!349, !4, i64 24}
!356 = !{!349, !10, i64 32}
!357 = !{!349, !4, i64 0}
!358 = !{!349, !4, i64 16}
!359 = !{!349, !5, i64 36}
!360 = !{!361, !4, i64 0}
!361 = !{!"", !4, i64 0, !9, i64 8}
!362 = !{!361, !9, i64 8}
!363 = !{!348, !4, i64 48}
!364 = !{!348, !4, i64 32}
!365 = !{!354, !4, i64 0}
!366 = !{!354, !10, i64 12}
