; ModuleID = 'onelua.c'
source_filename = "onelua.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.luaL_Reg = type { i8*, i32 (%struct.lua_State*)* }
%struct.lua_State = type { %struct.GCObject*, i8, i8, i8, i8, i16, %union.StackValue*, %struct.global_State*, %struct.CallInfo*, i32*, %union.StackValue*, %union.StackValue*, %struct.UpVal*, %struct.GCObject*, %struct.lua_State*, %struct.lua_longjmp*, %struct.CallInfo, void (%struct.lua_State*, %struct.lua_Debug*)*, i64, i32, i32, i32, i32, i32 }
%struct.global_State = type { i8* (i8*, i8*, i64, i64)*, i8*, i64, i64, i64, i64, %struct.stringtable, %struct.TValue, %struct.TValue, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %struct.GCObject*, %struct.GCObject**, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.GCObject*, %struct.lua_State*, i32 (%struct.lua_State*)*, %struct.lua_State*, %struct.TString*, [25 x %struct.TString*], [9 x %struct.Table*], [53 x [2 x %struct.TString*]], void (i8*, i8*, i32)*, i8* }
%struct.stringtable = type { %struct.TString**, i32, i32 }
%struct.TValue = type { %union.Value, i8 }
%union.Value = type { %struct.GCObject* }
%struct.TString = type { %struct.GCObject*, i8, i8, i8, i8, i32, %union.anon }
%union.anon = type { i64 }
%struct.Table = type { %struct.GCObject*, i8, i8, i8, i8, i32, %struct.TValue*, %union.Node*, %union.Node*, %struct.Table*, %struct.GCObject* }
%union.Node = type { %struct.NodeKey }
%struct.NodeKey = type { %union.Value, i8, i8, i32, %union.Value }
%union.StackValue = type { %struct.TValue }
%struct.UpVal = type { %struct.GCObject*, i8, i8, %struct.TValue*, %union.anon.4 }
%union.anon.4 = type { %struct.anon.5 }
%struct.anon.5 = type { %struct.UpVal*, %struct.UpVal** }
%struct.GCObject = type { %struct.GCObject*, i8, i8 }
%struct.lua_longjmp = type { %struct.lua_longjmp*, [1 x %struct.__jmp_buf_tag], i32 }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.CallInfo = type { %union.StackValue*, %union.StackValue*, %struct.CallInfo*, %struct.CallInfo*, %union.anon.0, %union.anon.2, i16, i16 }
%union.anon.0 = type { %struct.anon.1 }
%struct.anon.1 = type { i32 (%struct.lua_State*, i32, i64)*, i64, i64 }
%union.anon.2 = type { i32 }
%struct.lua_Debug = type { i32, i8*, i8*, i8*, i8*, i64, i32, i32, i32, i8, i8, i8, i8, i16, i16, [60 x i8], %struct.CallInfo* }
%struct.anon.10 = type { i8, i8 }
%struct.expdesc = type { i32, %union.anon.8, i32, i32 }
%union.anon.8 = type { i64 }
%struct.LClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, %struct.Proto*, [1 x %struct.UpVal*] }
%struct.Proto = type { %struct.GCObject*, i8, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.TValue*, i32*, %struct.Proto**, %struct.Upvaldesc*, i8*, %struct.AbsLineInfo*, %struct.LocVar*, %struct.TString*, %struct.GCObject* }
%struct.Upvaldesc = type { %struct.TString*, i8, i8 }
%struct.AbsLineInfo = type { i32, i32 }
%struct.LocVar = type { %struct.TString*, i32, i32 }
%struct.anon = type { i32*, i32, i32 }
%union.Closure = type { %struct.CClosure }
%struct.CClosure = type { %struct.GCObject*, i8, i8, i8, %struct.GCObject*, i32 (%struct.lua_State*)*, [1 x %struct.TValue] }
%struct.anon.3 = type { i16, i16 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.Udata = type { %struct.GCObject*, i8, i8, i16, i64, %struct.Table*, %struct.GCObject*, [1 x %union.UValue] }
%union.UValue = type { %struct.TValue }
%struct.lconv = type { i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.BuffFS = type { %struct.lua_State*, i32, i32, [400 x i8] }
%union.GCUnion = type { %struct.lua_State }
%struct.CallS = type { %union.StackValue*, i32 }
%struct.SParser = type { %struct.Zio*, %struct.Mbuffer, %struct.Dyndata, i8*, i8* }
%struct.Zio = type { i64, i8*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, %struct.lua_State* }
%struct.Mbuffer = type { i8*, i64, i64 }
%struct.Dyndata = type { %struct.anon.7, %struct.Labellist, %struct.Labellist }
%struct.anon.7 = type { %struct.Vardesc*, i32, i32 }
%struct.Vardesc = type { i16 }
%struct.Labellist = type { %struct.Labeldesc*, i32, i32 }
%struct.Labeldesc = type { %struct.TString*, i32, i32, i8, i8 }
%struct.DumpState = type { %struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32, i32 }
%struct.luaL_Buffer = type { i8*, i64, i64, %struct.lua_State*, %union.anon.6 }
%union.anon.6 = type { double, [1016 x i8] }
%struct.LoadF = type { i32, %struct._IO_FILE*, [8192 x i8] }
%struct.LoadS = type { i8*, i64 }
%struct.luaL_Stream = type { %struct._IO_FILE*, i32 (%struct.lua_State*)* }
%struct.RanState = type { [4 x i64] }
%struct.BlockCnt = type { %struct.BlockCnt*, i32, i32, i8, i8, i8, i8 }
%struct.LexState = type { i32, i32, i32, %struct.Token, %struct.Token, %struct.FuncState*, %struct.lua_State*, %struct.Zio*, %struct.Mbuffer*, %struct.Table*, %struct.Dyndata*, %struct.TString*, %struct.TString* }
%struct.Token = type { i32, %union.SemInfo }
%union.SemInfo = type { double }
%struct.FuncState = type { %struct.Proto*, %struct.FuncState*, %struct.LexState*, %struct.BlockCnt*, i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8, i8, i8 }
%struct.LoadState = type { %struct.lua_State*, %struct.Zio*, i8* }
%struct.LHS_assign = type { %struct.LHS_assign*, %struct.expdesc }
%struct.anon.9 = type { i16, i8 }
%struct.ConsControl = type { %struct.expdesc, %struct.expdesc*, i32, i32, i32 }
%struct.RN = type { %struct._IO_FILE*, i32, i32, [201 x i8] }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.MatchState = type { i8*, i8*, i8*, %struct.lua_State*, i32, i8, [32 x %struct.anon.11] }
%struct.anon.11 = type { i8*, i64 }
%struct.Header = type { %struct.lua_State*, i32, i32 }
%union.Ftypes = type { double, [32 x i8] }

@.str = private unnamed_addr constant [38 x i8] c"cannot resume non-suspended coroutine\00", align 1
@.str.1 = private unnamed_addr constant [29 x i8] c"cannot resume dead coroutine\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"C stack overflow\00", align 1
@.str.3 = private unnamed_addr constant [42 x i8] c"attempt to yield across a C-call boundary\00", align 1
@.str.4 = private unnamed_addr constant [42 x i8] c"attempt to yield from outside a coroutine\00", align 1
@lua_ident = local_unnamed_addr constant [129 x i8] c"$LuaVersion: Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio $$LuaAuthors: R. Ierusalimschy, L. H. de Figueiredo, W. Celes $\00", align 16
@luaT_typenames_ = internal unnamed_addr constant [12 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.182, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.183, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @udatatypename, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.187, i32 0, i32 0)], align 16
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.8 = private unnamed_addr constant [17 x i8] c"stack traceback:\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"\0A\09...\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"Slnt\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"\0A\09%s:\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"%d:\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c" in \00", align 1
@.str.14 = private unnamed_addr constant [21 x i8] c"\0A\09(...tail calls...)\00", align 1
@.str.15 = private unnamed_addr constant [22 x i8] c"bad argument #%d (%s)\00", align 1
@.str.16 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.17 = private unnamed_addr constant [7 x i8] c"method\00", align 1
@.str.18 = private unnamed_addr constant [30 x i8] c"calling '%s' on bad self (%s)\00", align 1
@.str.19 = private unnamed_addr constant [30 x i8] c"bad argument #%d to '%s' (%s)\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"__name\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"light userdata\00", align 1
@.str.22 = private unnamed_addr constant [20 x i8] c"%s expected, got %s\00", align 1
@.str.23 = private unnamed_addr constant [3 x i8] c"Sl\00", align 1
@.str.24 = private unnamed_addr constant [8 x i8] c"%s:%d: \00", align 1
@.str.25 = private unnamed_addr constant [7 x i8] c"%s: %s\00", align 1
@.str.26 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"invalid option '%s'\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"stack overflow (%s)\00", align 1
@.str.29 = private unnamed_addr constant [15 x i8] c"stack overflow\00", align 1
@.str.30 = private unnamed_addr constant [15 x i8] c"value expected\00", align 1
@.str.31 = private unnamed_addr constant [7 x i8] c"=stdin\00", align 1
@stdin = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.32 = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@.str.33 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"\1BLua\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.37 = private unnamed_addr constant [7 x i8] c"reopen\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.39 = private unnamed_addr constant [32 x i8] c"object length is not an integer\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"__tostring\00", align 1
@.str.41 = private unnamed_addr constant [34 x i8] c"'__tostring' must return a string\00", align 1
@.str.42 = private unnamed_addr constant [3 x i8] c"%I\00", align 1
@.str.43 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.44 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.45 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.46 = private unnamed_addr constant [4 x i8] c"nil\00", align 1
@.str.47 = private unnamed_addr constant [7 x i8] c"%s: %p\00", align 1
@.str.48 = private unnamed_addr constant [18 x i8] c"too many upvalues\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"_LOADED\00", align 1
@.str.50 = private unnamed_addr constant [49 x i8] c"core and library have incompatible numeric types\00", align 1
@.str.51 = private unnamed_addr constant [54 x i8] c"version mismatch: app. needs %f, Lua core provides %f\00", align 1
@base_funcs = internal constant [26 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.301, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_assert }, %struct.luaL_Reg { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.302, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_collectgarbage }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.303, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_dofile }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.304, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_error }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.306, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_ipairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.307, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_loadfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.308, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_load }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.309, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_next }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.310, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pairs }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.311, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_pcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_print }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.313, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_warn }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.314, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawequal }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.315, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawlen }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.316, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawget }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.317, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_rawset }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.318, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_select }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.320, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tonumber }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.321, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_tostring }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.323, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_xpcall }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.52 = private unnamed_addr constant [3 x i8] c"_G\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"Lua 5.4\00", align 1
@.str.54 = private unnamed_addr constant [9 x i8] c"_VERSION\00", align 1
@co_funcs = internal constant [9 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.347, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cocreate }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.348, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_coresume }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_corunning }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.350, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_costatus }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.351, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_cowrap }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.352, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yield }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.353, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_yieldable }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.354, i32 0, i32 0), i32 (%struct.lua_State*)* @luaB_kill }, %struct.luaL_Reg zeroinitializer], align 16
@dblib = internal constant [17 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @db_debug }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.362, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.363, i32 0, i32 0), i32 (%struct.lua_State*)* @db_gethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.364, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getinfo }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.365, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.366, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getregistry }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.305, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.367, i32 0, i32 0), i32 (%struct.lua_State*)* @db_getupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.368, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvaluejoin }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.369, i32 0, i32 0), i32 (%struct.lua_State*)* @db_upvalueid }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.370, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setuservalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.371, i32 0, i32 0), i32 (%struct.lua_State*)* @db_sethook }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.372, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setlocal }, %struct.luaL_Reg { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.319, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setmetatable }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.373, i32 0, i32 0), i32 (%struct.lua_State*)* @db_setupvalue }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.374, i32 0, i32 0), i32 (%struct.lua_State*)* @db_traceback }, %struct.luaL_Reg zeroinitializer], align 16
@iolib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @io_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @io_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.406, i32 0, i32 0), i32 (%struct.lua_State*)* @io_input }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @io_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i32 0, i32 0), i32 (%struct.lua_State*)* @io_open }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.407, i32 0, i32 0), i32 (%struct.lua_State*)* @io_output }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.408, i32 0, i32 0), i32 (%struct.lua_State*)* @io_popen }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @io_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.409, i32 0, i32 0), i32 (%struct.lua_State*)* @io_tmpfile }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @io_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @io_write }, %struct.luaL_Reg zeroinitializer], align 16
@.str.55 = private unnamed_addr constant [10 x i8] c"_IO_input\00", align 1
@.str.56 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@stdout = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.57 = private unnamed_addr constant [11 x i8] c"_IO_output\00", align 1
@.str.58 = private unnamed_addr constant [7 x i8] c"stdout\00", align 1
@stderr = external local_unnamed_addr global %struct._IO_FILE*, align 8
@.str.59 = private unnamed_addr constant [7 x i8] c"stderr\00", align 1
@mathlib = internal constant [28 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.438, i32 0, i32 0), i32 (%struct.lua_State*)* @math_abs }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.439, i32 0, i32 0), i32 (%struct.lua_State*)* @math_acos }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.440, i32 0, i32 0), i32 (%struct.lua_State*)* @math_asin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.441, i32 0, i32 0), i32 (%struct.lua_State*)* @math_atan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.442, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ceil }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.443, i32 0, i32 0), i32 (%struct.lua_State*)* @math_cos }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.444, i32 0, i32 0), i32 (%struct.lua_State*)* @math_deg }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.445, i32 0, i32 0), i32 (%struct.lua_State*)* @math_exp }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.446, i32 0, i32 0), i32 (%struct.lua_State*)* @math_toint }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.447, i32 0, i32 0), i32 (%struct.lua_State*)* @math_floor }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.448, i32 0, i32 0), i32 (%struct.lua_State*)* @math_fmod }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.449, i32 0, i32 0), i32 (%struct.lua_State*)* @math_ult }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.450, i32 0, i32 0), i32 (%struct.lua_State*)* @math_log }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.451, i32 0, i32 0), i32 (%struct.lua_State*)* @math_max }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i32 0, i32 0), i32 (%struct.lua_State*)* @math_min }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.453, i32 0, i32 0), i32 (%struct.lua_State*)* @math_modf }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.454, i32 0, i32 0), i32 (%struct.lua_State*)* @math_rad }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.455, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sin }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.456, i32 0, i32 0), i32 (%struct.lua_State*)* @math_sqrt }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.457, i32 0, i32 0), i32 (%struct.lua_State*)* @math_tan }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.322, i32 0, i32 0), i32 (%struct.lua_State*)* @math_type }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.60 = private unnamed_addr constant [3 x i8] c"pi\00", align 1
@.str.61 = private unnamed_addr constant [5 x i8] c"huge\00", align 1
@.str.62 = private unnamed_addr constant [11 x i8] c"maxinteger\00", align 1
@.str.63 = private unnamed_addr constant [11 x i8] c"mininteger\00", align 1
@pk_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.465, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_loadlib }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.466, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_searchpath }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.64 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.65 = private unnamed_addr constant [9 x i8] c"LUA_PATH\00", align 1
@.str.66 = private unnamed_addr constant [151 x i8] c"/usr/local/share/lua/5.4/?.lua;/usr/local/share/lua/5.4/?/init.lua;/usr/local/lib/lua/5.4/?.lua;/usr/local/lib/lua/5.4/?/init.lua;./?.lua;./?/init.lua\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"cpath\00", align 1
@.str.68 = private unnamed_addr constant [10 x i8] c"LUA_CPATH\00", align 1
@.str.69 = private unnamed_addr constant [69 x i8] c"/usr/local/lib/lua/5.4/?.so;/usr/local/lib/lua/5.4/loadall.so;./?.so\00", align 1
@.str.70 = private unnamed_addr constant [11 x i8] c"/\0A;\0A?\0A!\0A-\0A\00", align 1
@.str.71 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str.72 = private unnamed_addr constant [7 x i8] c"loaded\00", align 1
@.str.73 = private unnamed_addr constant [9 x i8] c"_PRELOAD\00", align 1
@.str.74 = private unnamed_addr constant [8 x i8] c"preload\00", align 1
@ll_funcs = internal constant [2 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i32 0, i32 0), i32 (%struct.lua_State*)* @ll_require }, %struct.luaL_Reg zeroinitializer], align 16
@syslib = internal constant [12 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.491, i32 0, i32 0), i32 (%struct.lua_State*)* @os_clock }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.492, i32 0, i32 0), i32 (%struct.lua_State*)* @os_date }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.493, i32 0, i32 0), i32 (%struct.lua_State*)* @os_difftime }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.494, i32 0, i32 0), i32 (%struct.lua_State*)* @os_execute }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i32 0, i32 0), i32 (%struct.lua_State*)* @os_exit }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.495, i32 0, i32 0), i32 (%struct.lua_State*)* @os_getenv }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @os_remove }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.497, i32 0, i32 0), i32 (%struct.lua_State*)* @os_rename }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.498, i32 0, i32 0), i32 (%struct.lua_State*)* @os_setlocale }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i32 (%struct.lua_State*)* @os_time }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.500, i32 0, i32 0), i32 (%struct.lua_State*)* @os_tmpname }, %struct.luaL_Reg zeroinitializer], align 16
@strlib = internal constant [18 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.524, i32 0, i32 0), i32 (%struct.lua_State*)* @str_byte }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @str_char }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.526, i32 0, i32 0), i32 (%struct.lua_State*)* @str_dump }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.527, i32 0, i32 0), i32 (%struct.lua_State*)* @str_find }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.528, i32 0, i32 0), i32 (%struct.lua_State*)* @str_format }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.529, i32 0, i32 0), i32 (%struct.lua_State*)* @gmatch }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.530, i32 0, i32 0), i32 (%struct.lua_State*)* @str_gsub }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @str_len }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.532, i32 0, i32 0), i32 (%struct.lua_State*)* @str_lower }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.533, i32 0, i32 0), i32 (%struct.lua_State*)* @str_match }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.534, i32 0, i32 0), i32 (%struct.lua_State*)* @str_rep }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.535, i32 0, i32 0), i32 (%struct.lua_State*)* @str_reverse }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.536, i32 0, i32 0), i32 (%struct.lua_State*)* @str_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.537, i32 0, i32 0), i32 (%struct.lua_State*)* @str_upper }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @str_pack }, %struct.luaL_Reg { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.539, i32 0, i32 0), i32 (%struct.lua_State*)* @str_packsize }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @str_unpack }, %struct.luaL_Reg zeroinitializer], align 16
@tab_funcs = internal constant [8 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.589, i32 0, i32 0), i32 (%struct.lua_State*)* @tconcat }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.590, i32 0, i32 0), i32 (%struct.lua_State*)* @tinsert }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.538, i32 0, i32 0), i32 (%struct.lua_State*)* @tpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.540, i32 0, i32 0), i32 (%struct.lua_State*)* @tunpack }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.496, i32 0, i32 0), i32 (%struct.lua_State*)* @tremove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.591, i32 0, i32 0), i32 (%struct.lua_State*)* @tmove }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.592, i32 0, i32 0), i32 (%struct.lua_State*)* @sort }, %struct.luaL_Reg zeroinitializer], align 16
@funcs = internal constant [7 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.601, i32 0, i32 0), i32 (%struct.lua_State*)* @byteoffset }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.602, i32 0, i32 0), i32 (%struct.lua_State*)* @codepoint }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.525, i32 0, i32 0), i32 (%struct.lua_State*)* @utfchar }, %struct.luaL_Reg { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.531, i32 0, i32 0), i32 (%struct.lua_State*)* @utflen }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.603, i32 0, i32 0), i32 (%struct.lua_State*)* @iter_codes }, %struct.luaL_Reg { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.75 = private unnamed_addr constant [15 x i8] c"[\00-\7F\C2-\FD][\80-\BF]*\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"charpattern\00", align 1
@loadedlibs = internal unnamed_addr constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_base }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.610, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_package }, %struct.luaL_Reg { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.611, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_coroutine }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.185, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_table }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.612, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_io }, %struct.luaL_Reg { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.613, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_os }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_string }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.614, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_math }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.615, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_utf8 }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0), i32 (%struct.lua_State*)* @luaopen_debug }, %struct.luaL_Reg zeroinitializer], align 16
@.str.77 = private unnamed_addr constant [39 x i8] c"cannot create state: not enough memory\00", align 1
@.str.78 = private unnamed_addr constant [18 x i8] c"not enough memory\00", align 1
@luaT_init.luaT_eventname = internal unnamed_addr constant [25 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.92, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.94, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.95, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.96, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.99, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.100, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0)], align 16
@.str.79 = private unnamed_addr constant [8 x i8] c"__index\00", align 1
@.str.80 = private unnamed_addr constant [11 x i8] c"__newindex\00", align 1
@.str.81 = private unnamed_addr constant [5 x i8] c"__gc\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"__mode\00", align 1
@.str.83 = private unnamed_addr constant [6 x i8] c"__len\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"__eq\00", align 1
@.str.85 = private unnamed_addr constant [6 x i8] c"__add\00", align 1
@.str.86 = private unnamed_addr constant [6 x i8] c"__sub\00", align 1
@.str.87 = private unnamed_addr constant [6 x i8] c"__mul\00", align 1
@.str.88 = private unnamed_addr constant [6 x i8] c"__mod\00", align 1
@.str.89 = private unnamed_addr constant [6 x i8] c"__pow\00", align 1
@.str.90 = private unnamed_addr constant [6 x i8] c"__div\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"__idiv\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"__band\00", align 1
@.str.93 = private unnamed_addr constant [6 x i8] c"__bor\00", align 1
@.str.94 = private unnamed_addr constant [7 x i8] c"__bxor\00", align 1
@.str.95 = private unnamed_addr constant [6 x i8] c"__shl\00", align 1
@.str.96 = private unnamed_addr constant [6 x i8] c"__shr\00", align 1
@.str.97 = private unnamed_addr constant [6 x i8] c"__unm\00", align 1
@.str.98 = private unnamed_addr constant [7 x i8] c"__bnot\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"__lt\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"__le\00", align 1
@.str.101 = private unnamed_addr constant [9 x i8] c"__concat\00", align 1
@.str.102 = private unnamed_addr constant [7 x i8] c"__call\00", align 1
@.str.103 = private unnamed_addr constant [8 x i8] c"__close\00", align 1
@.str.104 = private unnamed_addr constant [5 x i8] c"_ENV\00", align 1
@luaX_tokens = internal unnamed_addr constant [37 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.105, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.107, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.112, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.113, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.114, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.115, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.117, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.118, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.119, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.121, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.122, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.124, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.125, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.127, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.129, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.130, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.131, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.132, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.133, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.135, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.136, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.138, i32 0, i32 0)], align 16
@.str.105 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.106 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.108 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.109 = private unnamed_addr constant [7 x i8] c"elseif\00", align 1
@.str.110 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.111 = private unnamed_addr constant [4 x i8] c"for\00", align 1
@.str.112 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"goto\00", align 1
@.str.114 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.115 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.116 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.117 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.118 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.119 = private unnamed_addr constant [7 x i8] c"repeat\00", align 1
@.str.120 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.121 = private unnamed_addr constant [5 x i8] c"then\00", align 1
@.str.122 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@.str.123 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@.str.124 = private unnamed_addr constant [3 x i8] c"//\00", align 1
@.str.125 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.126 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.127 = private unnamed_addr constant [3 x i8] c"==\00", align 1
@.str.128 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.129 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.130 = private unnamed_addr constant [3 x i8] c"~=\00", align 1
@.str.131 = private unnamed_addr constant [3 x i8] c"<<\00", align 1
@.str.132 = private unnamed_addr constant [3 x i8] c">>\00", align 1
@.str.133 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str.134 = private unnamed_addr constant [6 x i8] c"<eof>\00", align 1
@.str.135 = private unnamed_addr constant [9 x i8] c"<number>\00", align 1
@.str.136 = private unnamed_addr constant [10 x i8] c"<integer>\00", align 1
@.str.137 = private unnamed_addr constant [7 x i8] c"<name>\00", align 1
@.str.138 = private unnamed_addr constant [9 x i8] c"<string>\00", align 1
@.str.139 = private unnamed_addr constant [29 x i8] c"error object is not a string\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"error in __gc metamethod (\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c")\00", align 1
@absentkey = internal constant %struct.TValue { %union.Value zeroinitializer, i8 32 }, align 8
@sweepgen.nextage = internal unnamed_addr constant [7 x i8] c"\01\03\03\04\04\05\06", align 1
@.str.142 = private unnamed_addr constant [12 x i8] c"(temporary)\00", align 1
@.str.143 = private unnamed_addr constant [14 x i8] c"(C temporary)\00", align 1
@.str.144 = private unnamed_addr constant [9 x i8] c"(vararg)\00", align 1
@.str.145 = private unnamed_addr constant [5 x i8] c"=[C]\00", align 1
@.str.146 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.147 = private unnamed_addr constant [3 x i8] c"=?\00", align 1
@.str.148 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c"Lua\00", align 1
@.str.150 = private unnamed_addr constant [10 x i8] c"[string \22\00", align 1
@.str.151 = private unnamed_addr constant [3 x i8] c"\22]\00", align 1
@.str.152 = private unnamed_addr constant [11 x i8] c"metamethod\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"hook\00", align 1
@.str.154 = private unnamed_addr constant [13 x i8] c"for iterator\00", align 1
@.str.155 = private unnamed_addr constant [6 x i8] c"order\00", align 1
@.str.156 = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str.157 = private unnamed_addr constant [14 x i8] c"integer index\00", align 1
@.str.158 = private unnamed_addr constant [6 x i8] c"field\00", align 1
@.str.159 = private unnamed_addr constant [8 x i8] c"upvalue\00", align 1
@.str.160 = private unnamed_addr constant [9 x i8] c"constant\00", align 1
@luaP_opmodes = internal unnamed_addr constant [84 x i8] c"\08\0A\0A\09\09\08\08\08\00\08\08\08\08\00\00\00\00\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\00\00\04\10\10\10\10\10\10\10\10\10\10\18hh \00\00\09\09\01\00\09 \09H\08\03", align 16
@.str.161 = private unnamed_addr constant [7 x i8] c"global\00", align 1
@.str.162 = private unnamed_addr constant [44 x i8] c"attempt to close non-closable variable '%s'\00", align 1
@.str.163 = private unnamed_addr constant [24 x i8] c"error in error handling\00", align 1
@luaV_execute.disptab = internal unnamed_addr constant [84 x i8*] [i8* blockaddress(@luaV_execute, %141), i8* blockaddress(@luaV_execute, %187), i8* blockaddress(@luaV_execute, %203), i8* blockaddress(@luaV_execute, %167), i8* blockaddress(@luaV_execute, %219), i8* blockaddress(@luaV_execute, %241), i8* blockaddress(@luaV_execute, %259), i8* blockaddress(@luaV_execute, %280), i8* blockaddress(@luaV_execute, %304), i8* blockaddress(@luaV_execute, %346), i8* blockaddress(@luaV_execute, %392), i8* blockaddress(@luaV_execute, %465), i8* blockaddress(@luaV_execute, %519), i8* blockaddress(@luaV_execute, %562), i8* blockaddress(@luaV_execute, %634), i8* blockaddress(@luaV_execute, %730), i8* blockaddress(@luaV_execute, %807), i8* blockaddress(@luaV_execute, %873), i8* blockaddress(@luaV_execute, %944), i8* blockaddress(@luaV_execute, %997), i8* blockaddress(@luaV_execute, %1038), i8* blockaddress(@luaV_execute, %1077), i8* blockaddress(@luaV_execute, %1118), i8* blockaddress(@luaV_execute, %1168), i8* blockaddress(@luaV_execute, %1206), i8* blockaddress(@luaV_execute, %1244), i8* blockaddress(@luaV_execute, %1284), i8* blockaddress(@luaV_execute, %1345), i8* blockaddress(@luaV_execute, %1404), i8* blockaddress(@luaV_execute, %1465), i8* blockaddress(@luaV_execute, %1535), i8* blockaddress(@luaV_execute, %1583), i8* blockaddress(@luaV_execute, %1631), i8* blockaddress(@luaV_execute, %2094), i8* blockaddress(@luaV_execute, %2141), i8* blockaddress(@luaV_execute, %2188), i8* blockaddress(@luaV_execute, %2421), i8* blockaddress(@luaV_execute, %2485), i8* blockaddress(@luaV_execute, %1691), i8* blockaddress(@luaV_execute, %1750), i8* blockaddress(@luaV_execute, %1809), i8* blockaddress(@luaV_execute, %1868), i8* blockaddress(@luaV_execute, %1938), i8* blockaddress(@luaV_execute, %1986), i8* blockaddress(@luaV_execute, %2034), i8* blockaddress(@luaV_execute, %2235), i8* blockaddress(@luaV_execute, %2297), i8* blockaddress(@luaV_execute, %2359), i8* blockaddress(@luaV_execute, %2614), i8* blockaddress(@luaV_execute, %2541), i8* blockaddress(@luaV_execute, %2687), i8* blockaddress(@luaV_execute, %2721), i8* blockaddress(@luaV_execute, %2762), i8* blockaddress(@luaV_execute, %2792), i8* blockaddress(@luaV_execute, %2809), i8* blockaddress(@luaV_execute, %2831), i8* blockaddress(@luaV_execute, %2845), i8* blockaddress(@luaV_execute, %2856), i8* blockaddress(@luaV_execute, %2872), i8* blockaddress(@luaV_execute, %2902), i8* blockaddress(@luaV_execute, %2966), i8* blockaddress(@luaV_execute, %3030), i8* blockaddress(@luaV_execute, %3062), i8* blockaddress(@luaV_execute, %3108), i8* blockaddress(@luaV_execute, %3166), i8* blockaddress(@luaV_execute, %3224), i8* blockaddress(@luaV_execute, %3282), i8* blockaddress(@luaV_execute, %3340), i8* blockaddress(@luaV_execute, %3382), i8* blockaddress(@luaV_execute, %3433), i8* blockaddress(@luaV_execute, %3454), i8* blockaddress(@luaV_execute, %3591), i8* blockaddress(@luaV_execute, %3622), i8* blockaddress(@luaV_execute, %3648), i8* blockaddress(@luaV_execute, %3686), i8* blockaddress(@luaV_execute, %3745), i8* blockaddress(@luaV_execute, %3897), i8* blockaddress(@luaV_execute, %3910), i8* blockaddress(@luaV_execute, %3933), i8* blockaddress(@luaV_execute, %3965), i8* blockaddress(@luaV_execute, %4059), i8* blockaddress(@luaV_execute, %4134), i8* blockaddress(@luaV_execute, %4215), i8* blockaddress(@luaV_execute, %4294)], align 16
@.str.164 = private unnamed_addr constant [19 x i8] c"'for' step is zero\00", align 1
@.str.165 = private unnamed_addr constant [6 x i8] c"limit\00", align 1
@.str.166 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@.str.167 = private unnamed_addr constant [14 x i8] c"initial value\00", align 1
@.str.168 = private unnamed_addr constant [26 x i8] c"attempt to perform 'n%%0'\00", align 1
@.str.169 = private unnamed_addr constant [26 x i8] c"attempt to divide by zero\00", align 1
@.str.170 = private unnamed_addr constant [29 x i8] c"perform bitwise operation on\00", align 1
@.str.171 = private unnamed_addr constant [22 x i8] c"perform arithmetic on\00", align 1
@.str.172 = private unnamed_addr constant [12 x i8] c"concatenate\00", align 1
@.str.173 = private unnamed_addr constant [27 x i8] c"attempt to %s a %s value%s\00", align 1
@.str.174 = private unnamed_addr constant [11 x i8] c" (%s '%s')\00", align 1
@.str.175 = private unnamed_addr constant [39 x i8] c"number%s has no integer representation\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"attempt to compare two %s values\00", align 1
@.str.177 = private unnamed_addr constant [30 x i8] c"attempt to compare %s with %s\00", align 1
@.str.178 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.179 = private unnamed_addr constant [39 x i8] c"bad 'for' %s (number expected, got %s)\00", align 1
@.str.180 = private unnamed_addr constant [10 x i8] c"%s:%d: %s\00", align 1
@.str.181 = private unnamed_addr constant [9 x i8] c"no value\00", align 1
@.str.182 = private unnamed_addr constant [8 x i8] c"boolean\00", align 1
@udatatypename = internal constant [9 x i8] c"userdata\00", align 1
@.str.183 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.184 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.185 = private unnamed_addr constant [6 x i8] c"table\00", align 1
@.str.186 = private unnamed_addr constant [7 x i8] c"thread\00", align 1
@.str.187 = private unnamed_addr constant [6 x i8] c"proto\00", align 1
@luai_ctype_ = internal unnamed_addr constant [257 x i8] c"\00\00\00\00\00\00\00\00\00\00\08\08\08\08\08\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0C\04\04\04\04\04\04\04\04\04\04\04\04\04\04\04\16\16\16\16\16\16\16\16\16\16\04\04\04\04\04\04\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\05\04\15\15\15\15\15\15\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\04\04\04\04\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 16
@.str.188 = private unnamed_addr constant [6 x i8] c".xXnN\00", align 1
@.str.189 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.190 = private unnamed_addr constant [6 x i8] c"%.14g\00", align 1
@.str.191 = private unnamed_addr constant [12 x i8] c"-0123456789\00", align 1
@.str.192 = private unnamed_addr constant [39 x i8] c"memory allocation error: block too big\00", align 1
@.str.193 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.194 = private unnamed_addr constant [3 x i8] c"%p\00", align 1
@.str.195 = private unnamed_addr constant [2 x i8] c"%\00", align 1
@.str.196 = private unnamed_addr constant [43 x i8] c"invalid option '%%%c' to 'lua_pushfstring'\00", align 1
@.str.197 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.198 = private unnamed_addr constant [40 x i8] c"'__index' chain too long; possible loop\00", align 1
@dummynode_ = internal constant %union.Node { %struct.NodeKey { %union.Value zeroinitializer, i8 16, i8 0, i32 0, %union.Value zeroinitializer } }, align 8
@.str.199 = private unnamed_addr constant [15 x i8] c"table overflow\00", align 1
@luaO_ceillog2.log_2 = internal unnamed_addr constant [256 x i8] c"\00\01\02\02\03\03\03\03\04\04\04\04\04\04\04\04\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\05\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\07\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08\08", align 16
@.str.200 = private unnamed_addr constant [43 x i8] c"'__newindex' chain too long; possible loop\00", align 1
@.str.201 = private unnamed_addr constant [19 x i8] c"table index is nil\00", align 1
@.str.202 = private unnamed_addr constant [19 x i8] c"table index is NaN\00", align 1
@.str.203 = private unnamed_addr constant [7 x i8] c"binary\00", align 1
@.str.204 = private unnamed_addr constant [5 x i8] c"text\00", align 1
@.str.205 = private unnamed_addr constant [42 x i8] c"attempt to load a %s chunk (mode is '%s')\00", align 1
@.str.206 = private unnamed_addr constant [14 x i8] c"binary string\00", align 1
@.str.207 = private unnamed_addr constant [19 x i8] c"not a binary chunk\00", align 1
@.str.208 = private unnamed_addr constant [17 x i8] c"version mismatch\00", align 1
@.str.209 = private unnamed_addr constant [16 x i8] c"format mismatch\00", align 1
@.str.210 = private unnamed_addr constant [7 x i8] c"\19\93\0D\0A\1A\0A\00", align 1
@.str.211 = private unnamed_addr constant [16 x i8] c"corrupted chunk\00", align 1
@.str.212 = private unnamed_addr constant [12 x i8] c"Instruction\00", align 1
@.str.213 = private unnamed_addr constant [12 x i8] c"lua_Integer\00", align 1
@.str.214 = private unnamed_addr constant [11 x i8] c"lua_Number\00", align 1
@.str.215 = private unnamed_addr constant [24 x i8] c"integer format mismatch\00", align 1
@.str.216 = private unnamed_addr constant [22 x i8] c"float format mismatch\00", align 1
@.str.217 = private unnamed_addr constant [16 x i8] c"truncated chunk\00", align 1
@.str.218 = private unnamed_addr constant [17 x i8] c"integer overflow\00", align 1
@.str.219 = private unnamed_addr constant [27 x i8] c"%s: bad binary format (%s)\00", align 1
@.str.220 = private unnamed_addr constant [17 x i8] c"%s size mismatch\00", align 1
@.str.221 = private unnamed_addr constant [31 x i8] c"bad format for constant string\00", align 1
@.str.222 = private unnamed_addr constant [8 x i8] c"opcodes\00", align 1
@.str.223 = private unnamed_addr constant [26 x i8] c"too many %s (limit is %d)\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.225 = private unnamed_addr constant [9 x i8] c"upvalues\00", align 1
@.str.226 = private unnamed_addr constant [14 x i8] c"main function\00", align 1
@.str.227 = private unnamed_addr constant [20 x i8] c"function at line %d\00", align 1
@.str.228 = private unnamed_addr constant [32 x i8] c"too many %s (limit is %d) in %s\00", align 1
@.str.229 = private unnamed_addr constant [11 x i8] c"%s near %s\00", align 1
@.str.230 = private unnamed_addr constant [5 x i8] c"'%s'\00", align 1
@.str.231 = private unnamed_addr constant [25 x i8] c"lexical element too long\00", align 1
@.str.232 = private unnamed_addr constant [5 x i8] c"'%c'\00", align 1
@.str.233 = private unnamed_addr constant [8 x i8] c"'<\5C%d>'\00", align 1
@.str.234 = private unnamed_addr constant [30 x i8] c"invalid long string delimiter\00", align 1
@.str.235 = private unnamed_addr constant [25 x i8] c"chunk has too many lines\00", align 1
@.str.236 = private unnamed_addr constant [8 x i8] c"comment\00", align 1
@.str.237 = private unnamed_addr constant [41 x i8] c"unfinished long %s (starting at line %d)\00", align 1
@.str.238 = private unnamed_addr constant [18 x i8] c"unfinished string\00", align 1
@.str.239 = private unnamed_addr constant [24 x i8] c"invalid escape sequence\00", align 1
@.str.240 = private unnamed_addr constant [27 x i8] c"hexadecimal digit expected\00", align 1
@.str.241 = private unnamed_addr constant [12 x i8] c"missing '{'\00", align 1
@.str.242 = private unnamed_addr constant [22 x i8] c"UTF-8 value too large\00", align 1
@.str.243 = private unnamed_addr constant [12 x i8] c"missing '}'\00", align 1
@.str.244 = private unnamed_addr constant [25 x i8] c"decimal escape too large\00", align 1
@.str.245 = private unnamed_addr constant [3 x i8] c"Ee\00", align 1
@.str.246 = private unnamed_addr constant [3 x i8] c"xX\00", align 1
@.str.247 = private unnamed_addr constant [3 x i8] c"Pp\00", align 1
@.str.248 = private unnamed_addr constant [3 x i8] c"-+\00", align 1
@.str.249 = private unnamed_addr constant [17 x i8] c"malformed number\00", align 1
@priority = internal unnamed_addr constant [21 x %struct.anon.10] [%struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 10, i8 10 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 14, i8 13 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 11, i8 11 }, %struct.anon.10 { i8 6, i8 6 }, %struct.anon.10 { i8 4, i8 4 }, %struct.anon.10 { i8 5, i8 5 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 7, i8 7 }, %struct.anon.10 { i8 9, i8 8 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 3, i8 3 }, %struct.anon.10 { i8 2, i8 2 }, %struct.anon.10 { i8 1, i8 1 }], align 16
@luaK_prefix.ef = internal constant %struct.expdesc { i32 6, %union.anon.8 zeroinitializer, i32 -1, i32 -1 }, align 8
@previousinstruction.invalidinstruction = internal unnamed_addr constant i32 -1, align 4
@.str.250 = private unnamed_addr constant [10 x i8] c"constants\00", align 1
@.str.251 = private unnamed_addr constant [27 x i8] c"control structure too long\00", align 1
@.str.252 = private unnamed_addr constant [48 x i8] c"function or expression needs too many registers\00", align 1
@.str.253 = private unnamed_addr constant [43 x i8] c"cannot use '...' outside a vararg function\00", align 1
@.str.254 = private unnamed_addr constant [21 x i8] c"constructor too long\00", align 1
@.str.256 = private unnamed_addr constant [5 x i8] c"self\00", align 1
@.str.257 = private unnamed_addr constant [10 x i8] c"functions\00", align 1
@.str.258 = private unnamed_addr constant [16 x i8] c"local variables\00", align 1
@.str.259 = private unnamed_addr constant [25 x i8] c"<name> or '...' expected\00", align 1
@.str.260 = private unnamed_addr constant [18 x i8] c"unexpected symbol\00", align 1
@.str.261 = private unnamed_addr constant [28 x i8] c"function arguments expected\00", align 1
@.str.262 = private unnamed_addr constant [13 x i8] c"labels/gotos\00", align 1
@.str.263 = private unnamed_addr constant [56 x i8] c"<goto %s> at line %d jumps into the scope of local '%s'\00", align 1
@.str.264 = private unnamed_addr constant [30 x i8] c"break outside loop at line %d\00", align 1
@.str.265 = private unnamed_addr constant [44 x i8] c"no visible label '%s' for <goto> at line %d\00", align 1
@.str.266 = private unnamed_addr constant [37 x i8] c"%s expected (to close %s at line %d)\00", align 1
@.str.267 = private unnamed_addr constant [12 x i8] c"%s expected\00", align 1
@.str.268 = private unnamed_addr constant [21 x i8] c"'=' or 'in' expected\00", align 1
@.str.269 = private unnamed_addr constant [12 x i8] c"(for index)\00", align 1
@.str.270 = private unnamed_addr constant [12 x i8] c"(for limit)\00", align 1
@.str.271 = private unnamed_addr constant [11 x i8] c"(for step)\00", align 1
@forbody.forprep = internal unnamed_addr constant [2 x i32] [i32 75, i32 76], align 4
@forbody.forloop = internal unnamed_addr constant [2 x i32] [i32 74, i32 78], align 4
@.str.272 = private unnamed_addr constant [16 x i8] c"(for generator)\00", align 1
@.str.273 = private unnamed_addr constant [12 x i8] c"(for state)\00", align 1
@.str.274 = private unnamed_addr constant [14 x i8] c"(for control)\00", align 1
@.str.275 = private unnamed_addr constant [14 x i8] c"(for toclose)\00", align 1
@.str.276 = private unnamed_addr constant [8 x i8] c"toclose\00", align 1
@.str.277 = private unnamed_addr constant [23 x i8] c"unknown attribute '%s'\00", align 1
@.str.278 = private unnamed_addr constant [38 x i8] c"label '%s' already defined on line %d\00", align 1
@.str.279 = private unnamed_addr constant [13 x i8] c"syntax error\00", align 1
@.str.280 = private unnamed_addr constant [22 x i8] c"invalid key to 'next'\00", align 1
@.str.281 = private unnamed_addr constant [23 x i8] c"string length overflow\00", align 1
@.str.282 = private unnamed_addr constant [14 x i8] c"get length of\00", align 1
@.str.283 = private unnamed_addr constant [10 x i8] c"(no name)\00", align 1
@.str.284 = private unnamed_addr constant [14 x i8] c"function '%s'\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"%s '%s'\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"main chunk\00", align 1
@.str.287 = private unnamed_addr constant [17 x i8] c"function <%s:%d>\00", align 1
@.str.288 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.289 = private unnamed_addr constant [4 x i8] c"_G.\00", align 1
@.str.290 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.291 = private unnamed_addr constant [37 x i8] c"number has no integer representation\00", align 1
@.str.292 = private unnamed_addr constant [17 x i8] c"buffer too large\00", align 1
@.str.293 = private unnamed_addr constant [40 x i8] c"not enough memory for buffer allocation\00", align 1
@.str.294 = private unnamed_addr constant [7 x i8] c"_UBOX*\00", align 1
@boxmt = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @boxgc }, %struct.luaL_Reg zeroinitializer], align 16
@.str.295 = private unnamed_addr constant [17 x i8] c"cannot %s %s: %s\00", align 1
@.str.296 = private unnamed_addr constant [4 x i8] c"\EF\BB\BF\00", align 1
@.str.297 = private unnamed_addr constant [50 x i8] c"PANIC: unprotected error in call to Lua API (%s)\0A\00", align 1
@.str.298 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.299 = private unnamed_addr constant [14 x i8] c"Lua warning: \00", align 1
@.str.300 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.301 = private unnamed_addr constant [7 x i8] c"assert\00", align 1
@.str.302 = private unnamed_addr constant [15 x i8] c"collectgarbage\00", align 1
@.str.303 = private unnamed_addr constant [7 x i8] c"dofile\00", align 1
@.str.304 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.305 = private unnamed_addr constant [13 x i8] c"getmetatable\00", align 1
@.str.306 = private unnamed_addr constant [7 x i8] c"ipairs\00", align 1
@.str.307 = private unnamed_addr constant [9 x i8] c"loadfile\00", align 1
@.str.308 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.310 = private unnamed_addr constant [6 x i8] c"pairs\00", align 1
@.str.311 = private unnamed_addr constant [6 x i8] c"pcall\00", align 1
@.str.312 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.313 = private unnamed_addr constant [5 x i8] c"warn\00", align 1
@.str.314 = private unnamed_addr constant [9 x i8] c"rawequal\00", align 1
@.str.315 = private unnamed_addr constant [7 x i8] c"rawlen\00", align 1
@.str.316 = private unnamed_addr constant [7 x i8] c"rawget\00", align 1
@.str.317 = private unnamed_addr constant [7 x i8] c"rawset\00", align 1
@.str.318 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.319 = private unnamed_addr constant [13 x i8] c"setmetatable\00", align 1
@.str.320 = private unnamed_addr constant [9 x i8] c"tonumber\00", align 1
@.str.321 = private unnamed_addr constant [9 x i8] c"tostring\00", align 1
@.str.322 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.323 = private unnamed_addr constant [7 x i8] c"xpcall\00", align 1
@.str.324 = private unnamed_addr constant [18 x i8] c"assertion failed!\00", align 1
@luaB_collectgarbage.opts = internal constant [11 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.325, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.326, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.329, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.330, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.331, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i32 0, i32 0), i8* null], align 16
@.str.325 = private unnamed_addr constant [5 x i8] c"stop\00", align 1
@.str.326 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str.327 = private unnamed_addr constant [8 x i8] c"collect\00", align 1
@.str.328 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"setpause\00", align 1
@.str.330 = private unnamed_addr constant [11 x i8] c"setstepmul\00", align 1
@.str.331 = private unnamed_addr constant [10 x i8] c"isrunning\00", align 1
@.str.332 = private unnamed_addr constant [13 x i8] c"generational\00", align 1
@.str.333 = private unnamed_addr constant [12 x i8] c"incremental\00", align 1
@luaB_collectgarbage.optsnum = internal unnamed_addr constant [10 x i32] [i32 0, i32 1, i32 2, i32 3, i32 5, i32 6, i32 7, i32 9, i32 10, i32 11], align 16
@.str.334 = private unnamed_addr constant [12 x i8] c"__metatable\00", align 1
@.str.335 = private unnamed_addr constant [3 x i8] c"bt\00", align 1
@.str.336 = private unnamed_addr constant [8 x i8] c"=(load)\00", align 1
@.str.337 = private unnamed_addr constant [26 x i8] c"too many nested functions\00", align 1
@.str.338 = private unnamed_addr constant [37 x i8] c"reader function must return a string\00", align 1
@.str.339 = private unnamed_addr constant [8 x i8] c"__pairs\00", align 1
@.str.341 = private unnamed_addr constant [16 x i8] c"table or string\00", align 1
@.str.342 = private unnamed_addr constant [19 x i8] c"index out of range\00", align 1
@.str.343 = private unnamed_addr constant [13 x i8] c"nil or table\00", align 1
@.str.344 = private unnamed_addr constant [36 x i8] c"cannot change a protected metatable\00", align 1
@.str.345 = private unnamed_addr constant [18 x i8] c"base out of range\00", align 1
@.str.346 = private unnamed_addr constant [7 x i8] c" \0C\0A\0D\09\0B\00", align 1
@.str.347 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str.348 = private unnamed_addr constant [7 x i8] c"resume\00", align 1
@.str.349 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str.350 = private unnamed_addr constant [7 x i8] c"status\00", align 1
@.str.351 = private unnamed_addr constant [5 x i8] c"wrap\00", align 1
@.str.352 = private unnamed_addr constant [6 x i8] c"yield\00", align 1
@.str.353 = private unnamed_addr constant [12 x i8] c"isyieldable\00", align 1
@.str.354 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@.str.355 = private unnamed_addr constant [29 x i8] c"too many arguments to resume\00", align 1
@.str.356 = private unnamed_addr constant [27 x i8] c"too many results to resume\00", align 1
@statname = internal unnamed_addr constant [4 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.349, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.357, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.358, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.359, i32 0, i32 0)], align 16
@.str.357 = private unnamed_addr constant [5 x i8] c"dead\00", align 1
@.str.358 = private unnamed_addr constant [10 x i8] c"suspended\00", align 1
@.str.359 = private unnamed_addr constant [7 x i8] c"normal\00", align 1
@.str.360 = private unnamed_addr constant [27 x i8] c"cannot kill a %s coroutine\00", align 1
@.str.361 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.362 = private unnamed_addr constant [13 x i8] c"getuservalue\00", align 1
@.str.363 = private unnamed_addr constant [8 x i8] c"gethook\00", align 1
@.str.364 = private unnamed_addr constant [8 x i8] c"getinfo\00", align 1
@.str.365 = private unnamed_addr constant [9 x i8] c"getlocal\00", align 1
@.str.366 = private unnamed_addr constant [12 x i8] c"getregistry\00", align 1
@.str.367 = private unnamed_addr constant [11 x i8] c"getupvalue\00", align 1
@.str.368 = private unnamed_addr constant [12 x i8] c"upvaluejoin\00", align 1
@.str.369 = private unnamed_addr constant [10 x i8] c"upvalueid\00", align 1
@.str.370 = private unnamed_addr constant [13 x i8] c"setuservalue\00", align 1
@.str.371 = private unnamed_addr constant [8 x i8] c"sethook\00", align 1
@.str.372 = private unnamed_addr constant [9 x i8] c"setlocal\00", align 1
@.str.373 = private unnamed_addr constant [11 x i8] c"setupvalue\00", align 1
@.str.374 = private unnamed_addr constant [10 x i8] c"traceback\00", align 1
@.str.375 = private unnamed_addr constant [12 x i8] c"lua_debug> \00", align 1
@.str.376 = private unnamed_addr constant [6 x i8] c"cont\0A\00", align 1
@.str.377 = private unnamed_addr constant [17 x i8] c"=(debug command)\00", align 1
@.str.378 = private unnamed_addr constant [14 x i8] c"external hook\00", align 1
@HOOKKEY = internal constant i32 0, align 4
@hookf.hooknames = internal unnamed_addr constant [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.120, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.380, i32 0, i32 0)], align 16
@.str.379 = private unnamed_addr constant [5 x i8] c"line\00", align 1
@.str.380 = private unnamed_addr constant [10 x i8] c"tail call\00", align 1
@.str.381 = private unnamed_addr constant [8 x i8] c"flnSrtu\00", align 1
@.str.382 = private unnamed_addr constant [4 x i8] c">%s\00", align 1
@.str.383 = private unnamed_addr constant [15 x i8] c"invalid option\00", align 1
@.str.384 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@.str.385 = private unnamed_addr constant [10 x i8] c"short_src\00", align 1
@.str.386 = private unnamed_addr constant [12 x i8] c"linedefined\00", align 1
@.str.387 = private unnamed_addr constant [16 x i8] c"lastlinedefined\00", align 1
@.str.388 = private unnamed_addr constant [5 x i8] c"what\00", align 1
@.str.389 = private unnamed_addr constant [12 x i8] c"currentline\00", align 1
@.str.390 = private unnamed_addr constant [5 x i8] c"nups\00", align 1
@.str.391 = private unnamed_addr constant [8 x i8] c"nparams\00", align 1
@.str.392 = private unnamed_addr constant [9 x i8] c"isvararg\00", align 1
@.str.393 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.394 = private unnamed_addr constant [9 x i8] c"namewhat\00", align 1
@.str.395 = private unnamed_addr constant [10 x i8] c"ftransfer\00", align 1
@.str.396 = private unnamed_addr constant [10 x i8] c"ntransfer\00", align 1
@.str.397 = private unnamed_addr constant [11 x i8] c"istailcall\00", align 1
@.str.398 = private unnamed_addr constant [12 x i8] c"activelines\00", align 1
@.str.399 = private unnamed_addr constant [5 x i8] c"func\00", align 1
@.str.400 = private unnamed_addr constant [19 x i8] c"level out of range\00", align 1
@.str.401 = private unnamed_addr constant [22 x i8] c"Lua function expected\00", align 1
@.str.402 = private unnamed_addr constant [22 x i8] c"invalid upvalue index\00", align 1
@.str.403 = private unnamed_addr constant [2 x i8] c"k\00", align 1
@.str.404 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@.str.405 = private unnamed_addr constant [6 x i8] c"flush\00", align 1
@.str.406 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.407 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.408 = private unnamed_addr constant [6 x i8] c"popen\00", align 1
@.str.409 = private unnamed_addr constant [8 x i8] c"tmpfile\00", align 1
@.str.410 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.411 = private unnamed_addr constant [6 x i8] c"FILE*\00", align 1
@.str.412 = private unnamed_addr constant [29 x i8] c"attempt to use a closed file\00", align 1
@.str.413 = private unnamed_addr constant [27 x i8] c"standard %s file is closed\00", align 1
@.str.414 = private unnamed_addr constant [27 x i8] c"cannot open file '%s' (%s)\00", align 1
@.str.415 = private unnamed_addr constant [19 x i8] c"too many arguments\00", align 1
@.str.416 = private unnamed_addr constant [23 x i8] c"file is already closed\00", align 1
@.str.417 = private unnamed_addr constant [15 x i8] c"invalid format\00", align 1
@.str.419 = private unnamed_addr constant [3 x i8] c"pP\00", align 1
@.str.420 = private unnamed_addr constant [3 x i8] c"eE\00", align 1
@.str.421 = private unnamed_addr constant [13 x i8] c"invalid mode\00", align 1
@.str.422 = private unnamed_addr constant [4 x i8] c"rwa\00", align 1
@.str.423 = private unnamed_addr constant [2 x i8] c"b\00", align 1
@.str.424 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.425 = private unnamed_addr constant [22 x i8] c"'popen' not supported\00", align 1
@.str.426 = private unnamed_addr constant [12 x i8] c"closed file\00", align 1
@.str.427 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@flib = internal constant [11 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.404, i32 0, i32 0), i32 (%struct.lua_State*)* @f_close }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.405, i32 0, i32 0), i32 (%struct.lua_State*)* @f_flush }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0), i32 (%struct.lua_State*)* @f_lines }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i32 (%struct.lua_State*)* @f_read }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.428, i32 0, i32 0), i32 (%struct.lua_State*)* @f_seek }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.429, i32 0, i32 0), i32 (%struct.lua_State*)* @f_setvbuf }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.410, i32 0, i32 0), i32 (%struct.lua_State*)* @f_write }, %struct.luaL_Reg { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.103, i32 0, i32 0), i32 (%struct.lua_State*)* @f_gc }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i32 (%struct.lua_State*)* @f_tostring }, %struct.luaL_Reg zeroinitializer], align 16
@.str.428 = private unnamed_addr constant [5 x i8] c"seek\00", align 1
@.str.429 = private unnamed_addr constant [8 x i8] c"setvbuf\00", align 1
@f_seek.mode = internal unnamed_addr constant [3 x i32] [i32 0, i32 1, i32 2], align 4
@f_seek.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.430, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.110, i32 0, i32 0), i8* null], align 16
@.str.430 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.431 = private unnamed_addr constant [4 x i8] c"cur\00", align 1
@f_setvbuf.mode = internal unnamed_addr constant [3 x i32] [i32 2, i32 0, i32 1], align 4
@f_setvbuf.modenames = internal constant [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.433, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.434, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.379, i32 0, i32 0), i8* null], align 16
@.str.433 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.434 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str.435 = private unnamed_addr constant [14 x i8] c"file (closed)\00", align 1
@.str.436 = private unnamed_addr constant [10 x i8] c"file (%p)\00", align 1
@.str.437 = private unnamed_addr constant [27 x i8] c"cannot close standard file\00", align 1
@.str.438 = private unnamed_addr constant [4 x i8] c"abs\00", align 1
@.str.439 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str.440 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str.441 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str.442 = private unnamed_addr constant [5 x i8] c"ceil\00", align 1
@.str.443 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str.444 = private unnamed_addr constant [4 x i8] c"deg\00", align 1
@.str.445 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str.446 = private unnamed_addr constant [10 x i8] c"tointeger\00", align 1
@.str.447 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str.448 = private unnamed_addr constant [5 x i8] c"fmod\00", align 1
@.str.449 = private unnamed_addr constant [4 x i8] c"ult\00", align 1
@.str.450 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str.451 = private unnamed_addr constant [4 x i8] c"max\00", align 1
@.str.452 = private unnamed_addr constant [4 x i8] c"min\00", align 1
@.str.453 = private unnamed_addr constant [5 x i8] c"modf\00", align 1
@.str.454 = private unnamed_addr constant [4 x i8] c"rad\00", align 1
@.str.455 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str.456 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str.457 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str.458 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.459 = private unnamed_addr constant [11 x i8] c"randomseed\00", align 1
@.str.460 = private unnamed_addr constant [5 x i8] c"zero\00", align 1
@.str.461 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.462 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@randfuncs = internal constant [3 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.458, i32 0, i32 0), i32 (%struct.lua_State*)* @math_random }, %struct.luaL_Reg { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.459, i32 0, i32 0), i32 (%struct.lua_State*)* @math_randomseed }, %struct.luaL_Reg zeroinitializer], align 16
@.str.463 = private unnamed_addr constant [26 x i8] c"wrong number of arguments\00", align 1
@.str.464 = private unnamed_addr constant [18 x i8] c"interval is empty\00", align 1
@CLIBS = internal constant i32 0, align 4
@.str.465 = private unnamed_addr constant [8 x i8] c"loadlib\00", align 1
@.str.466 = private unnamed_addr constant [11 x i8] c"searchpath\00", align 1
@.str.467 = private unnamed_addr constant [10 x i8] c"searchers\00", align 1
@.str.468 = private unnamed_addr constant [7 x i8] c"absent\00", align 1
@.str.469 = private unnamed_addr constant [5 x i8] c"init\00", align 1
@.str.470 = private unnamed_addr constant [59 x i8] c"dynamic libraries not enabled; check your Lua installation\00", align 1
@.str.471 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.472 = private unnamed_addr constant [2 x i8] c";\00", align 1
@.str.473 = private unnamed_addr constant [12 x i8] c"\0A\09no file '\00", align 1
@.str.474 = private unnamed_addr constant [13 x i8] c"'\0A\09no file '\00", align 1
@.str.475 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@createsearcherstable.searchers = internal unnamed_addr constant [5 x i32 (%struct.lua_State*)*] [i32 (%struct.lua_State*)* @searcher_preload, i32 (%struct.lua_State*)* @searcher_Lua, i32 (%struct.lua_State*)* @searcher_C, i32 (%struct.lua_State*)* @searcher_Croot, i32 (%struct.lua_State*)* null], align 16
@.str.476 = private unnamed_addr constant [33 x i8] c"\0A\09no field package.preload['%s']\00", align 1
@.str.477 = private unnamed_addr constant [10 x i8] c":preload:\00", align 1
@.str.478 = private unnamed_addr constant [30 x i8] c"'package.%s' must be a string\00", align 1
@.str.479 = private unnamed_addr constant [46 x i8] c"error loading module '%s' from file '%s':\0A\09%s\00", align 1
@.str.480 = private unnamed_addr constant [2 x i8] c"_\00", align 1
@.str.481 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.482 = private unnamed_addr constant [11 x i8] c"luaopen_%s\00", align 1
@.str.483 = private unnamed_addr constant [30 x i8] c"\0A\09no module '%s' in file '%s'\00", align 1
@.str.484 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@.str.485 = private unnamed_addr constant [5 x i8] c"_5_4\00", align 1
@.str.486 = private unnamed_addr constant [3 x i8] c";;\00", align 1
@.str.487 = private unnamed_addr constant [10 x i8] c"LUA_NOENV\00", align 1
@.str.488 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.489 = private unnamed_addr constant [36 x i8] c"'package.searchers' must be a table\00", align 1
@.str.490 = private unnamed_addr constant [25 x i8] c"module '%s' not found:%s\00", align 1
@.str.491 = private unnamed_addr constant [6 x i8] c"clock\00", align 1
@.str.492 = private unnamed_addr constant [5 x i8] c"date\00", align 1
@.str.493 = private unnamed_addr constant [9 x i8] c"difftime\00", align 1
@.str.494 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str.495 = private unnamed_addr constant [7 x i8] c"getenv\00", align 1
@.str.496 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@.str.497 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@.str.498 = private unnamed_addr constant [10 x i8] c"setlocale\00", align 1
@.str.499 = private unnamed_addr constant [5 x i8] c"time\00", align 1
@.str.500 = private unnamed_addr constant [8 x i8] c"tmpname\00", align 1
@.str.501 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.502 = private unnamed_addr constant [55 x i8] c"time result cannot be represented in this installation\00", align 1
@.str.503 = private unnamed_addr constant [3 x i8] c"*t\00", align 1
@.str.505 = private unnamed_addr constant [4 x i8] c"sec\00", align 1
@.str.506 = private unnamed_addr constant [5 x i8] c"hour\00", align 1
@.str.507 = private unnamed_addr constant [4 x i8] c"day\00", align 1
@.str.508 = private unnamed_addr constant [6 x i8] c"month\00", align 1
@.str.509 = private unnamed_addr constant [5 x i8] c"year\00", align 1
@.str.510 = private unnamed_addr constant [5 x i8] c"wday\00", align 1
@.str.511 = private unnamed_addr constant [5 x i8] c"yday\00", align 1
@.str.512 = private unnamed_addr constant [6 x i8] c"isdst\00", align 1
@.str.513 = private unnamed_addr constant [78 x i8] c"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy\00", align 1
@.str.514 = private unnamed_addr constant [36 x i8] c"invalid conversion specifier '%%%s'\00", align 1
@os_setlocale.cat = internal unnamed_addr constant [6 x i32] [i32 6, i32 3, i32 0, i32 4, i32 1, i32 2], align 16
@os_setlocale.catnames = internal constant [7 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.516, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.517, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.518, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.519, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.499, i32 0, i32 0), i8* null], align 16
@.str.515 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.516 = private unnamed_addr constant [8 x i8] c"collate\00", align 1
@.str.517 = private unnamed_addr constant [6 x i8] c"ctype\00", align 1
@.str.518 = private unnamed_addr constant [9 x i8] c"monetary\00", align 1
@.str.519 = private unnamed_addr constant [8 x i8] c"numeric\00", align 1
@.str.520 = private unnamed_addr constant [29 x i8] c"field '%s' is not an integer\00", align 1
@.str.521 = private unnamed_addr constant [33 x i8] c"field '%s' missing in date table\00", align 1
@.str.522 = private unnamed_addr constant [27 x i8] c"field '%s' is out-of-bound\00", align 1
@.str.523 = private unnamed_addr constant [37 x i8] c"unable to generate a unique filename\00", align 1
@.str.524 = private unnamed_addr constant [5 x i8] c"byte\00", align 1
@.str.525 = private unnamed_addr constant [5 x i8] c"char\00", align 1
@.str.526 = private unnamed_addr constant [5 x i8] c"dump\00", align 1
@.str.527 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.528 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@.str.529 = private unnamed_addr constant [7 x i8] c"gmatch\00", align 1
@.str.530 = private unnamed_addr constant [5 x i8] c"gsub\00", align 1
@.str.531 = private unnamed_addr constant [4 x i8] c"len\00", align 1
@.str.532 = private unnamed_addr constant [6 x i8] c"lower\00", align 1
@.str.533 = private unnamed_addr constant [6 x i8] c"match\00", align 1
@.str.534 = private unnamed_addr constant [4 x i8] c"rep\00", align 1
@.str.535 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str.536 = private unnamed_addr constant [4 x i8] c"sub\00", align 1
@.str.537 = private unnamed_addr constant [6 x i8] c"upper\00", align 1
@.str.538 = private unnamed_addr constant [5 x i8] c"pack\00", align 1
@.str.539 = private unnamed_addr constant [9 x i8] c"packsize\00", align 1
@.str.540 = private unnamed_addr constant [7 x i8] c"unpack\00", align 1
@.str.541 = private unnamed_addr constant [22 x i8] c"string slice too long\00", align 1
@.str.542 = private unnamed_addr constant [19 x i8] c"value out of range\00", align 1
@.str.543 = private unnamed_addr constant [30 x i8] c"unable to dump given function\00", align 1
@.str.544 = private unnamed_addr constant [11 x i8] c"^$*+?.([%-\00", align 1
@.str.545 = private unnamed_addr constant [20 x i8] c"pattern too complex\00", align 1
@.str.546 = private unnamed_addr constant [35 x i8] c"missing '[' after '%%f' in pattern\00", align 1
@.str.547 = private unnamed_addr constant [18 x i8] c"too many captures\00", align 1
@.str.548 = private unnamed_addr constant [24 x i8] c"invalid pattern capture\00", align 1
@.str.549 = private unnamed_addr constant [47 x i8] c"malformed pattern (missing arguments to '%%b')\00", align 1
@.str.550 = private unnamed_addr constant [35 x i8] c"malformed pattern (ends with '%%')\00", align 1
@.str.551 = private unnamed_addr constant [32 x i8] c"malformed pattern (missing ']')\00", align 1
@.str.552 = private unnamed_addr constant [27 x i8] c"invalid capture index %%%d\00", align 1
@.str.553 = private unnamed_addr constant [19 x i8] c"unfinished capture\00", align 1
@.str.554 = private unnamed_addr constant [3 x i8] c"ll\00", align 1
@.str.555 = private unnamed_addr constant [38 x i8] c"specifier '%%q' cannot have modifiers\00", align 1
@.str.556 = private unnamed_addr constant [22 x i8] c"string contains zeros\00", align 1
@.str.557 = private unnamed_addr constant [36 x i8] c"invalid conversion '%s' to 'format'\00", align 1
@.str.559 = private unnamed_addr constant [32 x i8] c"invalid format (repeated flags)\00", align 1
@.str.560 = private unnamed_addr constant [45 x i8] c"invalid format (width or precision too long)\00", align 1
@.str.561 = private unnamed_addr constant [7 x i8] c"0x%llx\00", align 1
@.str.562 = private unnamed_addr constant [26 x i8] c"value has no literal form\00", align 1
@.str.563 = private unnamed_addr constant [4 x i8] c"\5C%d\00", align 1
@.str.564 = private unnamed_addr constant [6 x i8] c"\5C%03d\00", align 1
@.str.565 = private unnamed_addr constant [7 x i8] c"1e9999\00", align 1
@.str.566 = private unnamed_addr constant [8 x i8] c"-1e9999\00", align 1
@.str.567 = private unnamed_addr constant [6 x i8] c"(0/0)\00", align 1
@.str.568 = private unnamed_addr constant [3 x i8] c"%a\00", align 1
@.str.569 = private unnamed_addr constant [22 x i8] c"string/function/table\00", align 1
@.str.570 = private unnamed_addr constant [33 x i8] c"invalid replacement value (a %s)\00", align 1
@.str.571 = private unnamed_addr constant [42 x i8] c"invalid use of '%c' in replacement string\00", align 1
@.str.572 = private unnamed_addr constant [27 x i8] c"resulting string too large\00", align 1
@.str.573 = private unnamed_addr constant [18 x i8] c"unsigned overflow\00", align 1
@.str.574 = private unnamed_addr constant [30 x i8] c"string longer than given size\00", align 1
@.str.575 = private unnamed_addr constant [41 x i8] c"string length does not fit in given size\00", align 1
@.str.576 = private unnamed_addr constant [35 x i8] c"invalid next option for option 'X'\00", align 1
@.str.577 = private unnamed_addr constant [41 x i8] c"format asks for alignment not power of 2\00", align 1
@.str.578 = private unnamed_addr constant [35 x i8] c"missing size for format option 'c'\00", align 1
@.str.579 = private unnamed_addr constant [27 x i8] c"invalid format option '%c'\00", align 1
@.str.580 = private unnamed_addr constant [40 x i8] c"integral size (%d) out of limits [1,%d]\00", align 1
@.str.581 = private unnamed_addr constant [23 x i8] c"variable-length format\00", align 1
@.str.582 = private unnamed_addr constant [24 x i8] c"format result too large\00", align 1
@.str.583 = private unnamed_addr constant [31 x i8] c"initial position out of string\00", align 1
@.str.584 = private unnamed_addr constant [22 x i8] c"data string too short\00", align 1
@.str.585 = private unnamed_addr constant [17 x i8] c"too many results\00", align 1
@.str.586 = private unnamed_addr constant [33 x i8] c"unfinished string for format 'z'\00", align 1
@.str.587 = private unnamed_addr constant [46 x i8] c"%d-byte integer does not fit into Lua Integer\00", align 1
@stringmetamethods = internal constant [10 x %struct.luaL_Reg] [%struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_add }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_sub }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mul }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_mod }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_pow }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_div }, %struct.luaL_Reg { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_idiv }, %struct.luaL_Reg { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), i32 (%struct.lua_State*)* @arith_unm }, %struct.luaL_Reg { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i32 (%struct.lua_State*)* null }, %struct.luaL_Reg zeroinitializer], align 16
@.str.588 = private unnamed_addr constant [33 x i8] c"attempt to %s a '%s' with a '%s'\00", align 1
@.str.589 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.590 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.591 = private unnamed_addr constant [5 x i8] c"move\00", align 1
@.str.592 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@.str.593 = private unnamed_addr constant [53 x i8] c"invalid value (%s) at index %d in table for 'concat'\00", align 1
@.str.594 = private unnamed_addr constant [23 x i8] c"position out of bounds\00", align 1
@.str.595 = private unnamed_addr constant [38 x i8] c"wrong number of arguments to 'insert'\00", align 1
@.str.596 = private unnamed_addr constant [27 x i8] c"too many results to unpack\00", align 1
@.str.597 = private unnamed_addr constant [26 x i8] c"too many elements to move\00", align 1
@.str.598 = private unnamed_addr constant [24 x i8] c"destination wrap around\00", align 1
@.str.599 = private unnamed_addr constant [14 x i8] c"array too big\00", align 1
@.str.600 = private unnamed_addr constant [35 x i8] c"invalid order function for sorting\00", align 1
@.str.601 = private unnamed_addr constant [7 x i8] c"offset\00", align 1
@.str.602 = private unnamed_addr constant [10 x i8] c"codepoint\00", align 1
@.str.603 = private unnamed_addr constant [6 x i8] c"codes\00", align 1
@.str.604 = private unnamed_addr constant [22 x i8] c"position out of range\00", align 1
@.str.605 = private unnamed_addr constant [40 x i8] c"initial position is a continuation byte\00", align 1
@.str.606 = private unnamed_addr constant [13 x i8] c"out of range\00", align 1
@.str.607 = private unnamed_addr constant [19 x i8] c"invalid UTF-8 code\00", align 1
@utf8_decode.limits = internal unnamed_addr constant [6 x i32] [i32 -1, i32 128, i32 2048, i32 65536, i32 2097152, i32 67108864], align 16
@.str.608 = private unnamed_addr constant [3 x i8] c"%U\00", align 1
@.str.609 = private unnamed_addr constant [29 x i8] c"final position out of string\00", align 1
@.str.610 = private unnamed_addr constant [8 x i8] c"package\00", align 1
@.str.611 = private unnamed_addr constant [10 x i8] c"coroutine\00", align 1
@.str.612 = private unnamed_addr constant [3 x i8] c"io\00", align 1
@.str.613 = private unnamed_addr constant [3 x i8] c"os\00", align 1
@.str.614 = private unnamed_addr constant [5 x i8] c"math\00", align 1
@.str.615 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str.616 = private unnamed_addr constant [5 x i8] c"%s: \00", align 1
@progname = internal unnamed_addr global i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.617, i64 0, i64 0), align 8
@.str.617 = private unnamed_addr constant [4 x i8] c"lua\00", align 1
@.str.618 = private unnamed_addr constant [21 x i8] c"'%s' needs argument\0A\00", align 1
@.str.619 = private unnamed_addr constant [26 x i8] c"unrecognized option '%s'\0A\00", align 1
@.str.620 = private unnamed_addr constant [365 x i8] c"usage: %s [options] [script [args]]\0AAvailable options are:\0A  -e stat  execute string 'stat'\0A  -i       enter interactive mode after executing 'script'\0A  -l name  require library 'name' into global 'name'\0A  -v       show version information\0A  -E       ignore environment variables\0A  --       stop handling options\0A  -        stop handling options and execute stdin\0A\00", align 1
@.str.621 = private unnamed_addr constant [52 x i8] c"Lua 5.4.0  Copyright (C) 1994-2019 Lua.org, PUC-Rio\00", align 1
@.str.622 = private unnamed_addr constant [4 x i8] c"arg\00", align 1
@.str.623 = private unnamed_addr constant [14 x i8] c"=LUA_INIT_5_4\00", align 1
@.str.624 = private unnamed_addr constant [10 x i8] c"=LUA_INIT\00", align 1
@globalL = internal unnamed_addr global %struct.lua_State* null, align 8
@.str.625 = private unnamed_addr constant [29 x i8] c"(error object is a %s value)\00", align 1
@.str.626 = private unnamed_addr constant [13 x i8] c"interrupted!\00", align 1
@.str.627 = private unnamed_addr constant [16 x i8] c"=(command line)\00", align 1
@.str.628 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str.629 = private unnamed_addr constant [21 x i8] c"'arg' is not a table\00", align 1
@.str.630 = private unnamed_addr constant [29 x i8] c"too many arguments to script\00", align 1
@.str.631 = private unnamed_addr constant [10 x i8] c"return %s\00", align 1
@.str.632 = private unnamed_addr constant [8 x i8] c"_PROMPT\00", align 1
@.str.633 = private unnamed_addr constant [9 x i8] c"_PROMPT2\00", align 1
@.str.634 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str.635 = private unnamed_addr constant [4 x i8] c">> \00", align 1
@.str.636 = private unnamed_addr constant [11 x i8] c"return %s;\00", align 1
@.str.637 = private unnamed_addr constant [26 x i8] c"too many results to print\00", align 1
@.str.638 = private unnamed_addr constant [27 x i8] c"error calling 'print' (%s)\00", align 1

; Function Attrs: nounwind optsize uwtable
define nonnull %struct.lua_State* @lua_newthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %5 = load i64, i64* %4, align 8, !tbaa !11
  %6 = icmp sgt i64 %5, 0
  br i1 %6, label %7, label %8

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %8

; <label>:8:                                      ; preds = %7, %1
  %9 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* nonnull %0, i64 208, i32 8) #16
  %10 = getelementptr inbounds i8, i8* %9, i64 8
  %11 = bitcast i8* %10 to %struct.lua_State*
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %13 = load i8, i8* %12, align 4, !tbaa !15
  %14 = and i8 %13, 24
  %15 = getelementptr inbounds i8, i8* %9, i64 17
  store i8 %14, i8* %15, align 1, !tbaa !16
  %16 = getelementptr inbounds i8, i8* %9, i64 16
  store i8 8, i8* %16, align 8, !tbaa !17
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %18 = bitcast %struct.GCObject** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !18
  %20 = bitcast i8* %10 to i64*
  store i64 %19, i64* %20, align 8, !tbaa !19
  %21 = bitcast %struct.GCObject** %17 to i8**
  store i8* %10, i8** %21, align 8, !tbaa !18
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %23 = bitcast %union.StackValue** %22 to %struct.TValue**
  %24 = load %struct.TValue*, %struct.TValue** %23, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i8**
  store i8* %10, i8** %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 72, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %22, align 8, !tbaa !20
  %29 = getelementptr inbounds i8, i8* %9, i64 32
  %30 = bitcast i8* %29 to %struct.global_State**
  store %struct.global_State* %3, %struct.global_State** %30, align 8, !tbaa !2
  %31 = getelementptr inbounds i8, i8* %9, i64 64
  %32 = bitcast i8* %31 to %union.StackValue**
  store %union.StackValue* null, %union.StackValue** %32, align 8, !tbaa !23
  %33 = getelementptr inbounds i8, i8* %9, i64 40
  %34 = bitcast i8* %33 to %struct.CallInfo**
  store %struct.CallInfo* null, %struct.CallInfo** %34, align 8, !tbaa !24
  %35 = getelementptr inbounds i8, i8* %9, i64 20
  %36 = bitcast i8* %35 to i16*
  store i16 0, i16* %36, align 4, !tbaa !25
  %37 = getelementptr inbounds i8, i8* %9, i64 188
  %38 = bitcast i8* %37 to i32*
  store i32 0, i32* %38, align 4, !tbaa !26
  %39 = getelementptr inbounds i8, i8* %9, i64 88
  %40 = bitcast i8* %39 to i8**
  store i8* %10, i8** %40, align 8, !tbaa !27
  %41 = getelementptr inbounds i8, i8* %9, i64 96
  %42 = bitcast i8* %41 to %struct.lua_longjmp**
  store %struct.lua_longjmp* null, %struct.lua_longjmp** %42, align 8, !tbaa !28
  %43 = getelementptr inbounds i8, i8* %9, i64 184
  %44 = bitcast i8* %43 to i32*
  store i32 0, i32* %44, align 8, !tbaa !29
  %45 = getelementptr inbounds i8, i8* %9, i64 168
  %46 = bitcast i8* %45 to void (%struct.lua_State*, %struct.lua_Debug*)**
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %46, align 8, !tbaa !30
  %47 = getelementptr inbounds i8, i8* %9, i64 200
  %48 = bitcast i8* %47 to i32*
  store i32 0, i32* %48, align 8, !tbaa !31
  %49 = getelementptr inbounds i8, i8* %9, i64 192
  %50 = bitcast i8* %49 to i32*
  store i32 0, i32* %50, align 8, !tbaa !32
  %51 = getelementptr inbounds i8, i8* %9, i64 19
  store i8 1, i8* %51, align 1, !tbaa !33
  %52 = getelementptr inbounds i8, i8* %9, i64 196
  %53 = bitcast i8* %52 to i32*
  %54 = getelementptr inbounds i8, i8* %9, i64 72
  %55 = bitcast i8* %54 to %struct.UpVal**
  store %struct.UpVal* null, %struct.UpVal** %55, align 8, !tbaa !34
  %56 = getelementptr inbounds i8, i8* %9, i64 18
  store i8 0, i8* %56, align 2, !tbaa !35
  %57 = getelementptr inbounds i8, i8* %9, i64 176
  %58 = bitcast i8* %57 to i64*
  store i64 0, i64* %58, align 8, !tbaa !36
  %59 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %60 = load i32, i32* %59, align 8, !tbaa !31
  store i32 %60, i32* %48, align 8, !tbaa !31
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %62 = load i32, i32* %61, align 8, !tbaa !32
  store i32 %62, i32* %50, align 8, !tbaa !32
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %64 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %63, align 8, !tbaa !30
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %64, void (%struct.lua_State*, %struct.lua_Debug*)** %46, align 8, !tbaa !30
  store i32 %62, i32* %53, align 4, !tbaa !37
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %66 = bitcast %struct.lua_State** %65 to i8**
  %67 = load i8*, i8** %66, align 8, !tbaa !38
  %68 = getelementptr inbounds i8, i8* %67, i64 -8
  %69 = bitcast i8* %68 to i64*
  %70 = bitcast i8* %9 to i64*
  %71 = load i64, i64* %69, align 1
  store i64 %71, i64* %70, align 1
  tail call fastcc void @stack_init(%struct.lua_State* nonnull %11, %struct.lua_State* nonnull %0) #16
  ret %struct.lua_State* %11
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaC_step(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 15
  %5 = load i8, i8* %4, align 1, !tbaa !39
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %267, label %7

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 12
  %9 = load i8, i8* %8, align 2, !tbaa !40
  %10 = icmp eq i8 %9, 1
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 5
  %12 = load i64, i64* %11, align 8, !tbaa !41
  %13 = icmp eq i64 %12, 0
  br i1 %10, label %15, label %14

; <label>:14:                                     ; preds = %7
  br i1 %13, label %202, label %18

; <label>:15:                                     ; preds = %7
  br i1 %13, label %94, label %16

; <label>:16:                                     ; preds = %15
  tail call fastcc void @enterinc(%struct.global_State* nonnull %3) #17
  %17 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  br label %18

; <label>:18:                                     ; preds = %14, %16
  %19 = phi %struct.global_State* [ %17, %16 ], [ %3, %14 ]
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %19, i64 0, i32 11
  %21 = load i8, i8* %20, align 1, !tbaa !42
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %28, label %23

; <label>:23:                                     ; preds = %18
  br label %24

; <label>:24:                                     ; preds = %23, %24
  %25 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %26 = load i8, i8* %20, align 1, !tbaa !42
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %24

; <label>:28:                                     ; preds = %24, %18
  %29 = tail call fastcc i64 @atomic(%struct.lua_State* %0) #17
  %30 = lshr i64 %12, 3
  %31 = add i64 %30, %12
  %32 = icmp ult i64 %29, %31
  br i1 %32, label %33, label %49

; <label>:33:                                     ; preds = %28
  tail call fastcc void @atomic2gen(%struct.lua_State* %0, %struct.global_State* %3) #17
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %35 = load i64, i64* %34, align 8, !tbaa !43
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %37 = load i64, i64* %36, align 8, !tbaa !11
  %38 = add nsw i64 %37, %35
  %39 = udiv i64 %38, 100
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 13
  %41 = load i8, i8* %40, align 1, !tbaa !44
  %42 = zext i8 %41 to i64
  %43 = sub nsw i64 0, %42
  %44 = mul i64 %39, %43
  %45 = add nsw i64 %38, -9223372036854775807
  %46 = icmp sgt i64 %45, %44
  %47 = select i1 %46, i64 %45, i64 %44
  %48 = sub nsw i64 %38, %47
  store i64 %48, i64* %34, align 8, !tbaa !43
  store i64 %47, i64* %36, align 8, !tbaa !11
  br label %267

; <label>:49:                                     ; preds = %28
  %50 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %51 = load i64, i64* %50, align 8, !tbaa !43
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %53 = load i64, i64* %52, align 8, !tbaa !11
  %54 = add nsw i64 %53, %51
  %55 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  store i64 %54, i64* %55, align 8, !tbaa !45
  %56 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 11
  store i8 3, i8* %57, align 1, !tbaa !42
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 20
  br label %59

; <label>:59:                                     ; preds = %59, %49
  %60 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %58, i32 1, i32* null) #17
  %61 = icmp eq %struct.GCObject** %60, %58
  br i1 %61, label %59, label %62

; <label>:62:                                     ; preds = %59
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 21
  store %struct.GCObject** %60, %struct.GCObject*** %63, align 8, !tbaa !46
  %64 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %64, i64 0, i32 11
  %66 = load i8, i8* %65, align 1, !tbaa !42
  %67 = icmp eq i8 %66, 8
  br i1 %67, label %73, label %68

; <label>:68:                                     ; preds = %62
  br label %69

; <label>:69:                                     ; preds = %68, %69
  %70 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %71 = load i8, i8* %65, align 1, !tbaa !42
  %72 = icmp eq i8 %71, 8
  br i1 %72, label %73, label %69

; <label>:73:                                     ; preds = %69, %62
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 17
  %75 = load i8, i8* %74, align 1, !tbaa !47
  %76 = zext i8 %75 to i64
  %77 = shl nuw nsw i64 %76, 2
  %78 = load i64, i64* %55, align 8, !tbaa !45
  %79 = udiv i64 %78, 100
  %80 = udiv i64 9223372036854775807, %79
  %81 = icmp ult i64 %77, %80
  %82 = mul nsw i64 %79, %77
  %83 = select i1 %81, i64 %82, i64 9223372036854775807
  %84 = load i64, i64* %50, align 8, !tbaa !43
  %85 = load i64, i64* %52, align 8, !tbaa !11
  %86 = add nsw i64 %85, %84
  %87 = sub i64 %86, %83
  %88 = icmp slt i64 %87, 0
  %89 = select i1 %88, i64 %87, i64 0
  %90 = add nsw i64 %86, -9223372036854775807
  %91 = icmp sgt i64 %90, %89
  %92 = select i1 %91, i64 %90, i64 %89
  %93 = sub nsw i64 %86, %92
  store i64 %93, i64* %50, align 8, !tbaa !43
  store i64 %92, i64* %52, align 8, !tbaa !11
  store i64 %29, i64* %11, align 8, !tbaa !41
  br label %267

; <label>:94:                                     ; preds = %15
  %95 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  %96 = load i64, i64* %95, align 8, !tbaa !45
  %97 = udiv i64 %96, 100
  %98 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 14
  %99 = load i8, i8* %98, align 8, !tbaa !48
  %100 = zext i8 %99 to i64
  %101 = shl nuw nsw i64 %100, 2
  %102 = mul i64 %101, %97
  %103 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %104 = load i64, i64* %103, align 8, !tbaa !11
  %105 = icmp sgt i64 %104, 0
  %106 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  br i1 %105, label %107, label %149

; <label>:107:                                    ; preds = %94
  %108 = load i64, i64* %106, align 8, !tbaa !43
  %109 = add nsw i64 %108, %104
  %110 = add i64 %102, %96
  %111 = icmp ugt i64 %109, %110
  br i1 %111, label %112, label %149

; <label>:112:                                    ; preds = %107
  tail call fastcc void @enterinc(%struct.global_State* nonnull %3) #17
  %113 = tail call fastcc i64 @entergen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3) #17
  %114 = load i64, i64* %106, align 8, !tbaa !43
  %115 = load i64, i64* %103, align 8, !tbaa !11
  %116 = add nsw i64 %115, %114
  %117 = lshr exact i64 %102, 1
  %118 = add i64 %117, %96
  %119 = icmp ult i64 %116, %118
  br i1 %119, label %120, label %131

; <label>:120:                                    ; preds = %112
  %121 = udiv i64 %116, 100
  %122 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 13
  %123 = load i8, i8* %122, align 1, !tbaa !44
  %124 = zext i8 %123 to i64
  %125 = sub nsw i64 0, %121
  %126 = mul i64 %125, %124
  %127 = add nsw i64 %116, -9223372036854775807
  %128 = icmp sgt i64 %127, %126
  %129 = select i1 %128, i64 %127, i64 %126
  %130 = sub nsw i64 %116, %129
  store i64 %130, i64* %106, align 8, !tbaa !43
  store i64 %129, i64* %103, align 8, !tbaa !11
  br label %267

; <label>:131:                                    ; preds = %112
  store i64 %113, i64* %11, align 8, !tbaa !41
  %132 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 17
  %133 = load i8, i8* %132, align 1, !tbaa !47
  %134 = zext i8 %133 to i64
  %135 = shl nuw nsw i64 %134, 2
  %136 = load i64, i64* %95, align 8, !tbaa !45
  %137 = udiv i64 %136, 100
  %138 = udiv i64 9223372036854775807, %137
  %139 = icmp ult i64 %135, %138
  %140 = mul nsw i64 %137, %135
  %141 = select i1 %139, i64 %140, i64 9223372036854775807
  %142 = sub i64 %116, %141
  %143 = icmp slt i64 %142, 0
  %144 = select i1 %143, i64 %142, i64 0
  %145 = add nsw i64 %116, -9223372036854775807
  %146 = icmp sgt i64 %145, %144
  %147 = select i1 %146, i64 %145, i64 %144
  %148 = sub nsw i64 %116, %147
  store i64 %148, i64* %106, align 8, !tbaa !43
  store i64 %147, i64* %103, align 8, !tbaa !11
  br label %267

; <label>:149:                                    ; preds = %94, %107
  %150 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 30
  %151 = load %struct.GCObject*, %struct.GCObject** %150, align 8, !tbaa !49
  %152 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 32
  %153 = load %struct.GCObject*, %struct.GCObject** %152, align 8, !tbaa !50
  tail call fastcc void @markold(%struct.global_State* nonnull %3, %struct.GCObject* %151, %struct.GCObject* %153) #17
  %154 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %155 = load %struct.GCObject*, %struct.GCObject** %154, align 8, !tbaa !51
  %156 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 35
  %157 = load %struct.GCObject*, %struct.GCObject** %156, align 8, !tbaa !52
  tail call fastcc void @markold(%struct.global_State* nonnull %3, %struct.GCObject* %155, %struct.GCObject* %157) #17
  %158 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0) #17
  %159 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %160 = load %struct.GCObject*, %struct.GCObject** %150, align 8, !tbaa !49
  %161 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %159, %struct.GCObject* %160) #17
  %162 = load %struct.GCObject*, %struct.GCObject** %152, align 8, !tbaa !50
  %163 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** %161, %struct.GCObject* %162) #17
  %164 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 31
  %165 = bitcast %struct.GCObject** %164 to i64*
  %166 = load i64, i64* %165, align 8, !tbaa !53
  %167 = bitcast %struct.GCObject** %152 to i64*
  store i64 %166, i64* %167, align 8, !tbaa !50
  %168 = bitcast %struct.GCObject** %161 to i64*
  %169 = load i64, i64* %168, align 8, !tbaa !54
  store i64 %169, i64* %165, align 8, !tbaa !53
  %170 = bitcast %struct.GCObject** %159 to i64*
  %171 = load i64, i64* %170, align 8, !tbaa !18
  %172 = bitcast %struct.GCObject** %150 to i64*
  store i64 %171, i64* %172, align 8, !tbaa !49
  %173 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 33
  %174 = load %struct.GCObject*, %struct.GCObject** %173, align 8, !tbaa !55
  %175 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %154, %struct.GCObject* %174) #17
  %176 = load %struct.GCObject*, %struct.GCObject** %156, align 8, !tbaa !52
  %177 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** %175, %struct.GCObject* %176) #17
  %178 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 34
  %179 = bitcast %struct.GCObject** %178 to i64*
  %180 = load i64, i64* %179, align 8, !tbaa !56
  %181 = bitcast %struct.GCObject** %156 to i64*
  store i64 %180, i64* %181, align 8, !tbaa !52
  %182 = bitcast %struct.GCObject** %175 to i64*
  %183 = load i64, i64* %182, align 8, !tbaa !54
  store i64 %183, i64* %179, align 8, !tbaa !56
  %184 = bitcast %struct.GCObject** %154 to i64*
  %185 = load i64, i64* %184, align 8, !tbaa !51
  %186 = bitcast %struct.GCObject** %173 to i64*
  store i64 %185, i64* %186, align 8, !tbaa !55
  %187 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %188 = tail call fastcc %struct.GCObject** @sweepgen(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3, %struct.GCObject** nonnull %187, %struct.GCObject* null) #17
  tail call fastcc void @finishgencycle(%struct.lua_State* nonnull %0, %struct.global_State* nonnull %3) #17
  %189 = load i64, i64* %106, align 8, !tbaa !43
  %190 = load i64, i64* %103, align 8, !tbaa !11
  %191 = add nsw i64 %190, %189
  %192 = udiv i64 %191, 100
  %193 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 13
  %194 = load i8, i8* %193, align 1, !tbaa !44
  %195 = zext i8 %194 to i64
  %196 = sub nsw i64 0, %195
  %197 = mul i64 %192, %196
  %198 = add nsw i64 %191, -9223372036854775807
  %199 = icmp sgt i64 %198, %197
  %200 = select i1 %199, i64 %198, i64 %197
  %201 = sub nsw i64 %191, %200
  store i64 %201, i64* %106, align 8, !tbaa !43
  store i64 %200, i64* %103, align 8, !tbaa !11
  store i64 %96, i64* %95, align 8, !tbaa !45
  br label %267

; <label>:202:                                    ; preds = %14
  %203 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 18
  %204 = load i8, i8* %203, align 4, !tbaa !57
  %205 = zext i8 %204 to i64
  %206 = shl nuw nsw i64 %205, 2
  %207 = or i64 %206, 1
  %208 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %209 = load i64, i64* %208, align 8, !tbaa !11
  %210 = lshr i64 %209, 4
  %211 = mul i64 %207, %210
  %212 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 19
  %213 = load i8, i8* %212, align 1, !tbaa !58
  %214 = icmp ult i8 %213, 63
  br i1 %214, label %215, label %221

; <label>:215:                                    ; preds = %202
  %216 = zext i8 %213 to i64
  %217 = shl i64 1, %216
  %218 = lshr i64 %217, 4
  %219 = sub nsw i64 0, %207
  %220 = mul i64 %218, %219
  br label %221

; <label>:221:                                    ; preds = %215, %202
  %222 = phi i64 [ %220, %215 ], [ -9223372036854775807, %202 ]
  %223 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  br label %224

; <label>:224:                                    ; preds = %231, %221
  %225 = phi i64 [ %211, %221 ], [ %227, %231 ]
  %226 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %227 = sub i64 %225, %226
  %228 = icmp sgt i64 %227, %222
  %229 = load i8, i8* %223, align 1, !tbaa !42
  %230 = icmp eq i8 %229, 8
  br i1 %228, label %231, label %232

; <label>:231:                                    ; preds = %224
  br i1 %230, label %233, label %224

; <label>:232:                                    ; preds = %224
  br i1 %230, label %233, label %256

; <label>:233:                                    ; preds = %231, %232
  %234 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 17
  %235 = load i8, i8* %234, align 1, !tbaa !47
  %236 = zext i8 %235 to i64
  %237 = shl nuw nsw i64 %236, 2
  %238 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  %239 = load i64, i64* %238, align 8, !tbaa !45
  %240 = udiv i64 %239, 100
  %241 = udiv i64 9223372036854775807, %240
  %242 = icmp ult i64 %237, %241
  %243 = mul nsw i64 %240, %237
  %244 = select i1 %242, i64 %243, i64 9223372036854775807
  %245 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %246 = load i64, i64* %245, align 8, !tbaa !43
  %247 = load i64, i64* %208, align 8, !tbaa !11
  %248 = add nsw i64 %247, %246
  %249 = sub i64 %248, %244
  %250 = icmp slt i64 %249, 0
  %251 = select i1 %250, i64 %249, i64 0
  %252 = add nsw i64 %248, -9223372036854775807
  %253 = icmp sgt i64 %252, %251
  %254 = select i1 %253, i64 %252, i64 %251
  %255 = sub nsw i64 %248, %254
  store i64 %255, i64* %245, align 8, !tbaa !43
  store i64 %254, i64* %208, align 8, !tbaa !11
  br label %267

; <label>:256:                                    ; preds = %232
  %257 = sdiv i64 %227, %207
  %258 = shl i64 %257, 4
  %259 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %260 = load i64, i64* %259, align 8, !tbaa !43
  %261 = load i64, i64* %208, align 8, !tbaa !11
  %262 = add nsw i64 %261, %260
  %263 = add nsw i64 %262, -9223372036854775807
  %264 = icmp sgt i64 %263, %258
  %265 = select i1 %264, i64 %263, i64 %258
  %266 = sub nsw i64 %262, %265
  store i64 %266, i64* %259, align 8, !tbaa !43
  store i64 %265, i64* %208, align 8, !tbaa !11
  br label %267

; <label>:267:                                    ; preds = %256, %233, %149, %131, %120, %73, %33, %1
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaM_malloc_(%struct.lua_State*, i64, i32) unnamed_addr #0 {
  %4 = icmp eq i64 %1, 0
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %9 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %8, align 8, !tbaa !59
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %11 = load i8*, i8** %10, align 8, !tbaa !60
  %12 = sext i32 %2 to i64
  %13 = tail call i8* %9(i8* %11, i8* null, i64 %12, i64 %1) #17
  %14 = icmp eq i8* %13, null
  br i1 %14, label %15, label %19, !prof !61

; <label>:15:                                     ; preds = %5
  %16 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* null, i64 %12, i64 %1) #16
  %17 = icmp eq i8* %16, null
  br i1 %17, label %18, label %19

; <label>:18:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:19:                                     ; preds = %15, %5
  %20 = phi i8* [ %16, %15 ], [ %13, %5 ]
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %22 = load i64, i64* %21, align 8, !tbaa !11
  %23 = add i64 %22, %1
  store i64 %23, i64* %21, align 8, !tbaa !11
  br label %24

; <label>:24:                                     ; preds = %3, %19
  %25 = phi i8* [ %20, %19 ], [ null, %3 ]
  ret i8* %25
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @stack_init(%struct.lua_State*, %struct.lua_State*) unnamed_addr #0 {
  %3 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %1, i64 640, i32 0) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = bitcast %union.StackValue** %4 to i8**
  store i8* %3, i8** %5, align 8, !tbaa !23
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  store i32 40, i32* %6, align 4, !tbaa !26
  %7 = bitcast i8* %3 to %union.StackValue*
  br label %8

; <label>:8:                                      ; preds = %8, %2
  %9 = phi i64 [ 0, %2 ], [ %12, %8 ]
  %10 = phi %union.StackValue* [ %7, %2 ], [ %13, %8 ]
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 %9, i32 0, i32 1
  store i8 0, i8* %11, align 8, !tbaa !21
  %12 = add nuw nsw i64 %9, 1
  %13 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !23
  %14 = icmp eq i64 %12, 40
  br i1 %14, label %15, label %8

; <label>:15:                                     ; preds = %8
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %13, %union.StackValue** %16, align 8, !tbaa !20
  %17 = load i32, i32* %6, align 4, !tbaa !26
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 %18
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -5
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %20, %union.StackValue** %21, align 8, !tbaa !62
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 2
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  %25 = bitcast %struct.CallInfo** %23 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %25, i8 0, i64 16, i32 8, i1 false)
  store i16 2, i16* %24, align 2, !tbaa !63
  %26 = ptrtoint %union.StackValue* %13 to i64
  %27 = bitcast %struct.CallInfo* %22 to i64*
  store i64 %26, i64* %27, align 8, !tbaa !64
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* null, i32 (%struct.lua_State*, i32, i64)** %28, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 6
  store i16 0, i16* %29, align 4, !tbaa !65
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 0, i32 0, i32 1
  store i8 0, i8* %30, align 8, !tbaa !21
  %31 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %16, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 21
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %33, %union.StackValue** %34, align 8, !tbaa !66
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %22, %struct.CallInfo** %35, align 8, !tbaa !24
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_resetthread(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !23
  %5 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4, i32 -2) #16
  %6 = bitcast %union.StackValue** %3 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !23
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = icmp eq i32 %5, -2
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !23
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  br i1 %9, label %17, label %12

; <label>:12:                                     ; preds = %1
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %5, %union.StackValue* nonnull %11) #16
  %13 = bitcast %union.StackValue** %3 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !23
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %16 = load %union.StackValue*, %union.StackValue** %15, align 8, !tbaa !20
  br label %20

; <label>:17:                                     ; preds = %1
  %18 = ptrtoint %union.StackValue* %10 to i64
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %11, %union.StackValue** %19, align 8, !tbaa !20
  br label %20

; <label>:20:                                     ; preds = %17, %12
  %21 = phi %union.StackValue* [ %16, %12 ], [ %11, %17 ]
  %22 = phi i64 [ %14, %12 ], [ %18, %17 ]
  %23 = phi i32 [ %5, %12 ], [ 0, %17 ]
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 7
  store i16 2, i16* %24, align 2, !tbaa !63
  %25 = bitcast %struct.CallInfo* %2 to i64*
  store i64 %22, i64* %25, align 8, !tbaa !64
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 20
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16, i32 1
  store %union.StackValue* %26, %union.StackValue** %27, align 8, !tbaa !66
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %2, %struct.CallInfo** %28, align 8, !tbaa !24
  %29 = trunc i32 %23 to i8
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %29, i8* %30, align 2, !tbaa !35
  ret i32 %23
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaF_close(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = load %struct.UpVal*, %struct.UpVal** %4, align 8, !tbaa !34
  %6 = icmp eq %struct.UpVal* %5, null
  br i1 %6, label %125, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = bitcast %union.StackValue** %8 to i8**
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %13

; <label>:13:                                     ; preds = %7, %120
  %14 = phi %struct.UpVal* [ %5, %7 ], [ %123, %120 ]
  %15 = phi %union.StackValue* [ %1, %7 ], [ %122, %120 ]
  %16 = phi i32 [ %2, %7 ], [ %121, %120 ]
  %17 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 3
  %18 = bitcast %struct.TValue** %17 to %union.StackValue**
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !67
  %20 = icmp ult %union.StackValue* %19, %15
  br i1 %20, label %125, label %21

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 4
  %23 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 4, i32 0
  %24 = getelementptr inbounds %struct.anon.5, %struct.anon.5* %23, i64 0, i32 0
  %25 = bitcast %struct.anon.5* %23 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 4, i32 0, i32 1
  %28 = bitcast %struct.UpVal*** %27 to i64**
  %29 = load i64*, i64** %28, align 8, !tbaa !21
  store i64 %26, i64* %29, align 8, !tbaa !54
  %30 = load %struct.UpVal*, %struct.UpVal** %24, align 8, !tbaa !21
  %31 = icmp eq %struct.UpVal* %30, null
  br i1 %31, label %37, label %32

; <label>:32:                                     ; preds = %21
  %33 = bitcast %struct.UpVal*** %27 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !21
  %35 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %30, i64 0, i32 4, i32 0, i32 1
  %36 = bitcast %struct.UpVal*** %35 to i64*
  store i64 %34, i64* %36, align 8, !tbaa !21
  br label %37

; <label>:37:                                     ; preds = %21, %32
  %38 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !67
  %39 = bitcast %struct.TValue* %38 to i64*
  %40 = bitcast %union.anon.4* %22 to i64*
  %41 = load i64, i64* %39, align 8
  store i64 %41, i64* %40, align 8
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  %43 = load i8, i8* %42, align 8, !tbaa !22
  %44 = bitcast %struct.UpVal*** %27 to i8*
  store i8 %43, i8* %44, align 8, !tbaa !22
  %45 = bitcast %struct.TValue** %17 to %union.anon.4**
  store %union.anon.4* %22, %union.anon.4** %45, align 8, !tbaa !67
  %46 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !69
  %48 = and i8 %47, 24
  %49 = icmp eq i8 %48, 0
  %50 = inttoptr i64 %41 to %struct.GCObject*
  br i1 %49, label %51, label %53

; <label>:51:                                     ; preds = %37
  %52 = or i8 %47, 32
  store i8 %52, i8* %46, align 1, !tbaa !69
  br label %53

; <label>:53:                                     ; preds = %37, %51
  %54 = phi i8 [ %47, %37 ], [ %52, %51 ]
  %55 = and i8 %43, 64
  %56 = icmp eq i8 %55, 0
  %57 = and i8 %54, 32
  %58 = icmp eq i8 %57, 0
  %59 = or i1 %56, %58
  br i1 %59, label %67, label %60

; <label>:60:                                     ; preds = %53
  %61 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %50, i64 0, i32 2
  %62 = load i8, i8* %61, align 1, !tbaa !70
  %63 = and i8 %62, 24
  %64 = icmp eq i8 %63, 0
  br i1 %64, label %67, label %65

; <label>:65:                                     ; preds = %60
  %66 = bitcast %struct.UpVal* %14 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %66, %struct.GCObject* nonnull %50) #16
  br label %67

; <label>:67:                                     ; preds = %60, %53, %65
  %68 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %14, i64 0, i32 1
  %69 = load i8, i8* %68, align 8, !tbaa !72
  %70 = icmp eq i8 %69, 25
  %71 = icmp ne i32 %16, -1
  %72 = and i1 %71, %70
  br i1 %72, label %73, label %120

; <label>:73:                                     ; preds = %67
  %74 = load i64, i64* %9, align 8, !tbaa !23
  %75 = ptrtoint %union.StackValue* %15 to i64
  %76 = sub i64 %75, %74
  %77 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !67
  %78 = icmp eq i32 %16, 0
  br i1 %78, label %79, label %104, !prof !73

; <label>:79:                                     ; preds = %73
  %80 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %81 = getelementptr inbounds %struct.global_State, %struct.global_State* %80, i64 0, i32 8
  %82 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* nonnull %0, %struct.TValue* %77, %struct.TValue* nonnull %81) #17
  %83 = icmp eq i32 %82, 0
  br i1 %83, label %87, label %84

; <label>:84:                                     ; preds = %79
  %85 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %86 = getelementptr inbounds %union.StackValue, %union.StackValue* %85, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %86, i32 0) #17
  br label %115

; <label>:87:                                     ; preds = %79
  %88 = getelementptr inbounds %struct.TValue, %struct.TValue* %77, i64 0, i32 1
  %89 = load i8, i8* %88, align 8, !tbaa !22
  %90 = and i8 %89, 15
  %91 = icmp eq i8 %90, 0
  br i1 %91, label %115, label %92

; <label>:92:                                     ; preds = %87
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %94 = load %struct.CallInfo*, %struct.CallInfo** %93, align 8, !tbaa !24
  %95 = bitcast %struct.CallInfo* %94 to i64*
  %96 = load i64, i64* %95, align 8, !tbaa !64
  %97 = ptrtoint %union.StackValue* %19 to i64
  %98 = sub i64 %97, %96
  %99 = lshr exact i64 %98, 4
  %100 = trunc i64 %99 to i32
  %101 = tail call fastcc i8* @luaG_findlocal(%struct.lua_State* nonnull %0, %struct.CallInfo* %94, i32 %100, %union.StackValue** null) #17
  %102 = icmp eq i8* %101, null
  %103 = select i1 %102, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %101
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.162, i64 0, i64 0), i8* %103) #19
  unreachable

; <label>:104:                                    ; preds = %73
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %16, %union.StackValue* %19) #17
  %105 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 0, i32 0
  %106 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* nonnull %0, %struct.TValue* %77, %struct.TValue* %105) #17
  %107 = icmp eq i32 %106, 0
  br i1 %107, label %115, label %108

; <label>:108:                                    ; preds = %104
  %109 = load i64, i64* %9, align 8, !tbaa !23
  %110 = ptrtoint %union.StackValue* %19 to i64
  %111 = sub i64 %110, %109
  %112 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @callclose, i8* null, i64 %111, i64 0) #17
  %113 = icmp eq i32 %112, 0
  %114 = select i1 %113, i32 %16, i32 %112
  br label %115

; <label>:115:                                    ; preds = %84, %87, %104, %108
  %116 = phi i32 [ 0, %84 ], [ 0, %87 ], [ %114, %108 ], [ %16, %104 ]
  %117 = load i8*, i8** %11, align 8, !tbaa !23
  %118 = getelementptr inbounds i8, i8* %117, i64 %76
  %119 = bitcast i8* %118 to %union.StackValue*
  br label %120

; <label>:120:                                    ; preds = %115, %67
  %121 = phi i32 [ %116, %115 ], [ %16, %67 ]
  %122 = phi %union.StackValue* [ %119, %115 ], [ %15, %67 ]
  %123 = load %struct.UpVal*, %struct.UpVal** %4, align 8, !tbaa !34
  %124 = icmp eq %struct.UpVal* %123, null
  br i1 %124, label %125, label %13

; <label>:125:                                    ; preds = %120, %13, %3
  %126 = phi i32 [ %2, %3 ], [ %16, %13 ], [ %121, %120 ]
  ret i32 %126
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_seterrorobj(%struct.lua_State*, i32, %union.StackValue*) unnamed_addr #0 {
  switch i32 %1, label %19 [
    i32 4, label %4
    i32 5, label %13
    i32 -2, label %28
  ]

; <label>:4:                                      ; preds = %3
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 39
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !74
  %9 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %8, %struct.TString** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %8, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !75
  %12 = or i8 %11, 64
  br label %28

; <label>:13:                                     ; preds = %3
  %14 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.163, i64 0, i64 0), i64 23) #16
  %15 = bitcast %union.StackValue* %2 to %struct.TString**
  store %struct.TString* %14, %struct.TString** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %14, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !75
  %18 = or i8 %17, 64
  br label %28

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = bitcast %struct.TValue* %22 to i64*
  %24 = bitcast %union.StackValue* %2 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  br label %28

; <label>:28:                                     ; preds = %3, %19, %13, %4
  %29 = phi i8 [ %27, %19 ], [ %18, %13 ], [ %12, %4 ], [ 0, %3 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 1
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %31, %union.StackValue** %32, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)*, i8*) #0 {
  %3 = alloca [24 x i8], align 16
  %4 = alloca i32, align 4
  %5 = tail call i8* %0(i8* %1, i8* null, i64 8, i64 1616) #17
  %6 = icmp eq i8* %5, null
  br i1 %6, label %106, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds i8, i8* %5, i64 8
  %9 = getelementptr inbounds i8, i8* %5, i64 208
  %10 = getelementptr inbounds i8, i8* %5, i64 16
  store i8 8, i8* %10, align 8, !tbaa !17
  %11 = getelementptr inbounds i8, i8* %5, i64 308
  store i8 8, i8* %11, align 4, !tbaa !15
  %12 = getelementptr inbounds i8, i8* %5, i64 17
  store i8 8, i8* %12, align 1, !tbaa !16
  %13 = getelementptr inbounds i8, i8* %5, i64 32
  %14 = bitcast i8* %13 to i8**
  store i8* %9, i8** %14, align 8, !tbaa !2
  %15 = getelementptr inbounds i8, i8* %5, i64 64
  %16 = bitcast i8* %15 to %union.StackValue**
  store %union.StackValue* null, %union.StackValue** %16, align 8, !tbaa !23
  %17 = getelementptr inbounds i8, i8* %5, i64 40
  %18 = bitcast i8* %17 to %struct.CallInfo**
  store %struct.CallInfo* null, %struct.CallInfo** %18, align 8, !tbaa !24
  %19 = getelementptr inbounds i8, i8* %5, i64 20
  %20 = bitcast i8* %19 to i16*
  store i16 0, i16* %20, align 4, !tbaa !25
  %21 = getelementptr inbounds i8, i8* %5, i64 188
  %22 = bitcast i8* %21 to i32*
  store i32 0, i32* %22, align 4, !tbaa !26
  %23 = getelementptr inbounds i8, i8* %5, i64 88
  %24 = bitcast i8* %23 to i8**
  store i8* %8, i8** %24, align 8, !tbaa !27
  %25 = getelementptr inbounds i8, i8* %5, i64 96
  %26 = bitcast i8* %25 to %struct.lua_longjmp**
  store %struct.lua_longjmp* null, %struct.lua_longjmp** %26, align 8, !tbaa !28
  %27 = getelementptr inbounds i8, i8* %5, i64 184
  %28 = bitcast i8* %27 to i32*
  store i32 0, i32* %28, align 8, !tbaa !29
  %29 = getelementptr inbounds i8, i8* %5, i64 168
  %30 = bitcast i8* %29 to void (%struct.lua_State*, %struct.lua_Debug*)**
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)** %30, align 8, !tbaa !30
  %31 = getelementptr inbounds i8, i8* %5, i64 200
  %32 = bitcast i8* %31 to i32*
  store i32 0, i32* %32, align 8, !tbaa !31
  %33 = getelementptr inbounds i8, i8* %5, i64 192
  %34 = bitcast i8* %33 to i32*
  store i32 0, i32* %34, align 8, !tbaa !32
  %35 = getelementptr inbounds i8, i8* %5, i64 19
  store i8 1, i8* %35, align 1, !tbaa !33
  %36 = getelementptr inbounds i8, i8* %5, i64 196
  %37 = bitcast i8* %36 to i32*
  store i32 0, i32* %37, align 4, !tbaa !37
  %38 = getelementptr inbounds i8, i8* %5, i64 72
  %39 = bitcast i8* %38 to %struct.UpVal**
  store %struct.UpVal* null, %struct.UpVal** %39, align 8, !tbaa !34
  %40 = getelementptr inbounds i8, i8* %5, i64 18
  store i8 0, i8* %40, align 2, !tbaa !35
  %41 = getelementptr inbounds i8, i8* %5, i64 176
  %42 = bitcast i8* %41 to i64*
  store i64 0, i64* %42, align 8, !tbaa !36
  %43 = getelementptr inbounds i8, i8* %5, i64 320
  %44 = bitcast i8* %43 to i8**
  store i8* %8, i8** %44, align 8, !tbaa !18
  %45 = bitcast i8* %8 to %struct.GCObject**
  store %struct.GCObject* null, %struct.GCObject** %45, align 8, !tbaa !19
  %46 = bitcast i8* %9 to i8* (i8*, i8*, i64, i64)**
  store i8* (i8*, i8*, i64, i64)* %0, i8* (i8*, i8*, i64, i64)** %46, align 8, !tbaa !59
  %47 = getelementptr inbounds i8, i8* %5, i64 216
  %48 = bitcast i8* %47 to i8**
  store i8* %1, i8** %48, align 8, !tbaa !60
  %49 = getelementptr inbounds i8, i8* %5, i64 1600
  %50 = getelementptr inbounds i8, i8* %5, i64 464
  %51 = bitcast i8* %50 to i8**
  call void @llvm.memset.p0i8.i64(i8* nonnull %49, i8 0, i64 16, i32 8, i1 false)
  store i8* %8, i8** %51, align 8, !tbaa !38
  %52 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %52) #7
  %53 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %53) #7
  %54 = tail call i64 @time(i64* null) #17
  %55 = trunc i64 %54 to i32
  store i32 %55, i32* %4, align 4, !tbaa !77
  %56 = ptrtoint i8* %8 to i64
  %57 = bitcast [24 x i8]* %3 to i64*
  store i64 %56, i64* %57, align 16
  %58 = ptrtoint i32* %4 to i64
  %59 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 8
  %60 = bitcast i8* %59 to i64*
  store i64 %58, i64* %60, align 8
  %61 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 16
  %62 = bitcast i8* %61 to i64*
  store i64 ptrtoint (%struct.lua_State* (i8* (i8*, i8*, i64, i64)*, i8*)* @lua_newstate to i64), i64* %62, align 16
  %63 = xor i32 %55, 24
  br label %64

; <label>:64:                                     ; preds = %64, %7
  %65 = phi i64 [ 24, %7 ], [ %70, %64 ]
  %66 = phi i32 [ %63, %7 ], [ %75, %64 ]
  %67 = shl i32 %66, 5
  %68 = lshr i32 %66, 2
  %69 = add i32 %67, %68
  %70 = add nsw i64 %65, -1
  %71 = getelementptr inbounds [24 x i8], [24 x i8]* %3, i64 0, i64 %70
  %72 = load i8, i8* %71, align 1, !tbaa !21
  %73 = zext i8 %72 to i32
  %74 = add i32 %69, %73
  %75 = xor i32 %74, %66
  %76 = icmp eq i64 %70, 0
  br i1 %76, label %77, label %64

; <label>:77:                                     ; preds = %64
  %78 = bitcast i8* %8 to %struct.lua_State*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %53) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %52) #7
  %79 = getelementptr inbounds i8, i8* %5, i64 304
  %80 = bitcast i8* %79 to i32*
  store i32 %75, i32* %80, align 8, !tbaa !78
  %81 = getelementptr inbounds i8, i8* %5, i64 313
  store i8 0, i8* %81, align 1, !tbaa !39
  %82 = getelementptr inbounds i8, i8* %5, i64 256
  %83 = getelementptr inbounds i8, i8* %5, i64 280
  store i8 0, i8* %83, align 8, !tbaa !79
  %84 = getelementptr inbounds i8, i8* %5, i64 456
  %85 = bitcast i8* %84 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %85, align 8, !tbaa !80
  %86 = getelementptr inbounds i8, i8* %5, i64 309
  call void @llvm.memset.p0i8.i64(i8* nonnull %82, i8 0, i64 16, i32 8, i1 false)
  store i8 8, i8* %86, align 1, !tbaa !42
  %87 = getelementptr inbounds i8, i8* %5, i64 310
  store i8 0, i8* %87, align 2, !tbaa !40
  %88 = getelementptr inbounds i8, i8* %5, i64 314
  store i8 0, i8* %88, align 2, !tbaa !81
  %89 = getelementptr inbounds i8, i8* %5, i64 328
  %90 = getelementptr inbounds i8, i8* %5, i64 224
  call void @llvm.memset.p0i8.i64(i8* nonnull %89, i8 0, i64 128, i32 8, i1 false)
  %91 = bitcast i8* %90 to <2 x i64>*
  store <2 x i64> <i64 1616, i64 0>, <2 x i64>* %91, align 8, !tbaa !82
  %92 = getelementptr inbounds i8, i8* %5, i64 248
  %93 = bitcast i8* %92 to i64*
  store i64 0, i64* %93, align 8, !tbaa !41
  %94 = getelementptr inbounds i8, i8* %5, i64 288
  %95 = bitcast i8* %94 to i64*
  store i64 0, i64* %95, align 8, !tbaa !21
  %96 = getelementptr inbounds i8, i8* %5, i64 296
  store i8 35, i8* %96, align 8, !tbaa !22
  %97 = getelementptr inbounds i8, i8* %5, i64 315
  store i8 50, i8* %97, align 1, !tbaa !47
  %98 = getelementptr inbounds i8, i8* %5, i64 316
  store i8 25, i8* %98, align 4, !tbaa !57
  %99 = getelementptr inbounds i8, i8* %5, i64 317
  store i8 13, i8* %99, align 1, !tbaa !58
  %100 = getelementptr inbounds i8, i8* %5, i64 312
  store i8 25, i8* %100, align 8, !tbaa !48
  %101 = getelementptr inbounds i8, i8* %5, i64 311
  store i8 20, i8* %101, align 1, !tbaa !44
  %102 = getelementptr inbounds i8, i8* %5, i64 680
  call void @llvm.memset.p0i8.i64(i8* nonnull %102, i8 0, i64 72, i32 8, i1 false)
  %103 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %78, void (%struct.lua_State*, i8*)* nonnull @f_luaopen, i8* null) #16
  %104 = icmp eq i32 %103, 0
  br i1 %104, label %106, label %105

; <label>:105:                                    ; preds = %77
  call fastcc void @close_state(%struct.lua_State* nonnull %78) #16
  br label %106

; <label>:106:                                    ; preds = %105, %77, %2
  %107 = phi %struct.lua_State* [ null, %2 ], [ null, %105 ], [ %78, %77 ]
  ret %struct.lua_State* %107
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaD_rawrunprotected(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*) unnamed_addr #0 {
  %4 = alloca %struct.lua_longjmp, align 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %6 = load i32, i32* %5, align 8, !tbaa !29
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %8 = load i16, i16* %7, align 4, !tbaa !25
  %9 = zext i16 %8 to i32
  %10 = sub i32 %6, %9
  %11 = bitcast %struct.lua_longjmp* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 216, i8* nonnull %11) #7
  %12 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 0, i32* %12, align 8, !tbaa !83
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %14 = bitcast %struct.lua_longjmp** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !28
  %16 = bitcast %struct.lua_longjmp* %4 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !85
  store %struct.lua_longjmp* %4, %struct.lua_longjmp** %13, align 8, !tbaa !28
  %17 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  %18 = call i32 @_setjmp(%struct.__jmp_buf_tag* nonnull %17) #20
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %3
  call void %1(%struct.lua_State* nonnull %0, i8* %2) #17
  br label %21

; <label>:21:                                     ; preds = %20, %3
  %22 = load i64, i64* %16, align 8, !tbaa !85
  store i64 %22, i64* %14, align 8, !tbaa !28
  %23 = load i16, i16* %7, align 4, !tbaa !25
  %24 = zext i16 %23 to i32
  %25 = add i32 %10, %24
  store i32 %25, i32* %5, align 8, !tbaa !29
  %26 = load volatile i32, i32* %12, align 8, !tbaa !83
  call void @llvm.lifetime.end.p0i8(i64 216, i8* nonnull %11) #7
  ret i32 %26
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_luaopen(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  tail call fastcc void @stack_init(%struct.lua_State* %0, %struct.lua_State* %0) #16
  %6 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 56, i32 5) #17
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 10
  %10 = load i8, i8* %9, align 4, !tbaa !15
  %11 = and i8 %10, 24
  %12 = getelementptr inbounds i8, i8* %8, i64 9
  store i8 %11, i8* %12, align 1, !tbaa !70
  %13 = getelementptr inbounds i8, i8* %8, i64 8
  store i8 5, i8* %13, align 8, !tbaa !86
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 20
  %15 = bitcast %struct.GCObject** %14 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !18
  %17 = bitcast i8* %8 to i64*
  store i64 %16, i64* %17, align 8, !tbaa !87
  %18 = bitcast %struct.GCObject** %14 to i8**
  store i8* %8, i8** %18, align 8, !tbaa !18
  %19 = bitcast i8* %8 to %struct.Table*
  %20 = getelementptr inbounds i8, i8* %8, i64 40
  %21 = bitcast i8* %20 to %struct.Table**
  store %struct.Table* null, %struct.Table** %21, align 8, !tbaa !88
  %22 = getelementptr inbounds i8, i8* %8, i64 10
  store i8 -1, i8* %22, align 2, !tbaa !90
  %23 = getelementptr inbounds i8, i8* %8, i64 16
  %24 = bitcast i8* %23 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %24, align 8, !tbaa !91
  %25 = getelementptr inbounds i8, i8* %8, i64 12
  %26 = bitcast i8* %25 to i32*
  store i32 0, i32* %26, align 4, !tbaa !92
  %27 = getelementptr inbounds i8, i8* %8, i64 24
  %28 = getelementptr inbounds i8, i8* %8, i64 11
  store i8 0, i8* %28, align 1, !tbaa !93
  %29 = bitcast i8* %27 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %29, align 8, !tbaa !54
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 7
  %31 = bitcast %struct.TValue* %30 to i8**
  store i8* %8, i8** %31, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 7, i32 1
  store i8 69, i8* %32, align 8, !tbaa !22
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %19, i32 2, i32 0) #17
  %33 = bitcast %struct.TValue* %3 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %33, align 8, !tbaa !21
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 72, i8* %34, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %19, i64 1, %struct.TValue* nonnull %3) #17
  %35 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %36 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 56, i32 5) #17
  %37 = getelementptr inbounds %struct.global_State, %struct.global_State* %35, i64 0, i32 10
  %38 = load i8, i8* %37, align 4, !tbaa !15
  %39 = and i8 %38, 24
  %40 = getelementptr inbounds i8, i8* %36, i64 9
  store i8 %39, i8* %40, align 1, !tbaa !70
  %41 = getelementptr inbounds i8, i8* %36, i64 8
  store i8 5, i8* %41, align 8, !tbaa !86
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %35, i64 0, i32 20
  %43 = bitcast %struct.GCObject** %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !18
  %45 = bitcast i8* %36 to i64*
  store i64 %44, i64* %45, align 8, !tbaa !87
  %46 = bitcast %struct.GCObject** %42 to i8**
  store i8* %36, i8** %46, align 8, !tbaa !18
  %47 = getelementptr inbounds i8, i8* %36, i64 40
  %48 = bitcast i8* %47 to %struct.Table**
  store %struct.Table* null, %struct.Table** %48, align 8, !tbaa !88
  %49 = getelementptr inbounds i8, i8* %36, i64 10
  store i8 -1, i8* %49, align 2, !tbaa !90
  %50 = getelementptr inbounds i8, i8* %36, i64 16
  %51 = bitcast i8* %50 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %51, align 8, !tbaa !91
  %52 = getelementptr inbounds i8, i8* %36, i64 12
  %53 = bitcast i8* %52 to i32*
  store i32 0, i32* %53, align 4, !tbaa !92
  %54 = getelementptr inbounds i8, i8* %36, i64 24
  %55 = getelementptr inbounds i8, i8* %36, i64 11
  store i8 0, i8* %55, align 1, !tbaa !93
  %56 = bitcast i8* %54 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %56, align 8, !tbaa !54
  %57 = bitcast %struct.TValue* %3 to i8**
  store i8* %36, i8** %57, align 8, !tbaa !21
  store i8 69, i8* %34, align 8, !tbaa !22
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %19, i64 2, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  %58 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %59 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 6
  %60 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 1024, i32 0) #17
  %61 = bitcast %struct.stringtable* %59 to i8**
  store i8* %60, i8** %61, align 8, !tbaa !94
  tail call void @llvm.memset.p0i8.i64(i8* %60, i8 0, i64 1024, i32 8, i1 false) #7
  %62 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 6, i32 2
  store i32 128, i32* %62, align 4, !tbaa !95
  %63 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.78, i64 0, i64 0), i64 17) #17
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 39
  store %struct.TString* %63, %struct.TString** %64, align 8, !tbaa !74
  %65 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %66 = getelementptr inbounds %struct.TString, %struct.TString* %63, i64 0, i32 2
  %67 = load i8, i8* %66, align 1, !tbaa !70
  %68 = and i8 %67, -32
  %69 = or i8 %68, 4
  store i8 %69, i8* %66, align 1, !tbaa !70
  %70 = bitcast %struct.TString* %63 to i64*
  %71 = load i64, i64* %70, align 8, !tbaa !87
  %72 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 20
  %73 = bitcast %struct.GCObject** %72 to i64*
  store i64 %71, i64* %73, align 8, !tbaa !18
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 29
  %75 = bitcast %struct.GCObject** %74 to i64*
  %76 = load i64, i64* %75, align 8, !tbaa !96
  store i64 %76, i64* %70, align 8, !tbaa !87
  %77 = bitcast %struct.GCObject** %74 to %struct.TString**
  store %struct.TString* %63, %struct.TString** %77, align 8, !tbaa !96
  %78 = ptrtoint %struct.TString* %63 to i64
  %79 = insertelement <2 x i64> undef, i64 %78, i32 0
  %80 = shufflevector <2 x i64> %79, <2 x i64> undef, <2 x i32> zeroinitializer
  br label %81

; <label>:81:                                     ; preds = %2, %89
  %82 = phi i64 [ 0, %2 ], [ %90, %89 ]
  br label %83

; <label>:83:                                     ; preds = %83, %81
  %84 = phi i64 [ 0, %81 ], [ %87, %83 ]
  %85 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 42, i64 %82, i64 %84
  %86 = bitcast %struct.TString** %85 to <2 x i64>*
  store <2 x i64> %80, <2 x i64>* %86, align 8, !tbaa !54
  %87 = add i64 %84, 2
  %88 = icmp eq i64 %84, 0
  br i1 %88, label %89, label %83, !llvm.loop !97

; <label>:89:                                     ; preds = %83
  %90 = add nuw nsw i64 %82, 1
  %91 = icmp eq i64 %90, 53
  br i1 %91, label %92, label %81

; <label>:92:                                     ; preds = %89
  br label %93

; <label>:93:                                     ; preds = %92, %93
  %94 = phi i64 [ %115, %93 ], [ 0, %92 ]
  %95 = getelementptr inbounds [25 x i8*], [25 x i8*]* @luaT_init.luaT_eventname, i64 0, i64 %94
  %96 = load i8*, i8** %95, align 8, !tbaa !54
  %97 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %96) #17
  %98 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %99 = getelementptr inbounds %struct.global_State, %struct.global_State* %98, i64 0, i32 40, i64 %94
  store %struct.TString* %97, %struct.TString** %99, align 8, !tbaa !54
  %100 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %101 = getelementptr inbounds %struct.global_State, %struct.global_State* %100, i64 0, i32 40, i64 %94
  %102 = bitcast %struct.TString** %101 to %struct.GCObject**
  %103 = load %struct.GCObject*, %struct.GCObject** %102, align 8, !tbaa !54
  %104 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %103, i64 0, i32 2
  %105 = load i8, i8* %104, align 1, !tbaa !70
  %106 = and i8 %105, -32
  %107 = or i8 %106, 4
  store i8 %107, i8* %104, align 1, !tbaa !70
  %108 = bitcast %struct.GCObject* %103 to i64*
  %109 = load i64, i64* %108, align 8, !tbaa !87
  %110 = getelementptr inbounds %struct.global_State, %struct.global_State* %100, i64 0, i32 20
  %111 = bitcast %struct.GCObject** %110 to i64*
  store i64 %109, i64* %111, align 8, !tbaa !18
  %112 = getelementptr inbounds %struct.global_State, %struct.global_State* %100, i64 0, i32 29
  %113 = bitcast %struct.GCObject** %112 to i64*
  %114 = load i64, i64* %113, align 8, !tbaa !96
  store i64 %114, i64* %108, align 8, !tbaa !87
  store %struct.GCObject* %103, %struct.GCObject** %112, align 8, !tbaa !96
  %115 = add nuw nsw i64 %94, 1
  %116 = icmp eq i64 %115, 25
  br i1 %116, label %117, label %93

; <label>:117:                                    ; preds = %93
  %118 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4) #17
  %119 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %120 = getelementptr inbounds %struct.TString, %struct.TString* %118, i64 0, i32 2
  %121 = load i8, i8* %120, align 1, !tbaa !70
  %122 = and i8 %121, -32
  %123 = or i8 %122, 4
  store i8 %123, i8* %120, align 1, !tbaa !70
  %124 = bitcast %struct.TString* %118 to i64*
  %125 = load i64, i64* %124, align 8, !tbaa !87
  %126 = getelementptr inbounds %struct.global_State, %struct.global_State* %119, i64 0, i32 20
  %127 = bitcast %struct.GCObject** %126 to i64*
  store i64 %125, i64* %127, align 8, !tbaa !18
  %128 = getelementptr inbounds %struct.global_State, %struct.global_State* %119, i64 0, i32 29
  %129 = bitcast %struct.GCObject** %128 to i64*
  %130 = load i64, i64* %129, align 8, !tbaa !96
  store i64 %130, i64* %124, align 8, !tbaa !87
  %131 = bitcast %struct.GCObject** %128 to %struct.TString**
  store %struct.TString* %118, %struct.TString** %131, align 8, !tbaa !96
  br label %132

; <label>:132:                                    ; preds = %132, %117
  %133 = phi i64 [ 0, %117 ], [ %150, %132 ]
  %134 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %133
  %135 = load i8*, i8** %134, align 8, !tbaa !54
  %136 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* nonnull %0, i8* %135) #17
  %137 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %138 = getelementptr inbounds %struct.TString, %struct.TString* %136, i64 0, i32 2
  %139 = load i8, i8* %138, align 1, !tbaa !70
  %140 = and i8 %139, -32
  %141 = or i8 %140, 4
  store i8 %141, i8* %138, align 1, !tbaa !70
  %142 = bitcast %struct.TString* %136 to i64*
  %143 = load i64, i64* %142, align 8, !tbaa !87
  %144 = getelementptr inbounds %struct.global_State, %struct.global_State* %137, i64 0, i32 20
  %145 = bitcast %struct.GCObject** %144 to i64*
  store i64 %143, i64* %145, align 8, !tbaa !18
  %146 = getelementptr inbounds %struct.global_State, %struct.global_State* %137, i64 0, i32 29
  %147 = bitcast %struct.GCObject** %146 to i64*
  %148 = load i64, i64* %147, align 8, !tbaa !96
  store i64 %148, i64* %142, align 8, !tbaa !87
  %149 = bitcast %struct.GCObject** %146 to %struct.TString**
  store %struct.TString* %136, %struct.TString** %149, align 8, !tbaa !96
  %150 = add nuw nsw i64 %133, 1
  %151 = getelementptr inbounds %struct.TString, %struct.TString* %136, i64 0, i32 3
  %152 = trunc i64 %150 to i8
  store i8 %152, i8* %151, align 2, !tbaa !99
  %153 = icmp eq i64 %150, 22
  br i1 %153, label %154, label %132

; <label>:154:                                    ; preds = %132
  %155 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 15
  store i8 1, i8* %155, align 1, !tbaa !39
  %156 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 8, i32 1
  store i8 0, i8* %156, align 8, !tbaa !100
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @close_state(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !23
  %6 = tail call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %5, i32 -2) #16
  %7 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 12
  %9 = load i8, i8* %8, align 2, !tbaa !40
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %12, label %11

; <label>:11:                                     ; preds = %1
  tail call fastcc void @enterinc(%struct.global_State* %7) #17
  br label %12

; <label>:12:                                     ; preds = %11, %1
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 5
  store i64 0, i64* %13, align 8, !tbaa !41
  tail call fastcc void @separatetobefnz(%struct.global_State* %7, i32 1) #17
  %14 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 28
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !101
  %17 = icmp eq %struct.GCObject* %16, null
  br i1 %17, label %22, label %18

; <label>:18:                                     ; preds = %12
  br label %19

; <label>:19:                                     ; preds = %18, %19
  tail call fastcc void @GCTM(%struct.lua_State* %0) #17
  %20 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !101
  %21 = icmp eq %struct.GCObject* %20, null
  br i1 %21, label %22, label %19

; <label>:22:                                     ; preds = %19, %12
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 20
  %24 = load %struct.GCObject*, %struct.GCObject** %23, align 8, !tbaa !18
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 38
  %26 = bitcast %struct.lua_State** %25 to %struct.GCObject**
  %27 = load %struct.GCObject*, %struct.GCObject** %26, align 8, !tbaa !38
  %28 = icmp eq %struct.GCObject* %24, %27
  br i1 %28, label %35, label %29

; <label>:29:                                     ; preds = %22
  br label %30

; <label>:30:                                     ; preds = %29, %30
  %31 = phi %struct.GCObject* [ %33, %30 ], [ %24, %29 ]
  %32 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %31, i64 0, i32 0
  %33 = load %struct.GCObject*, %struct.GCObject** %32, align 8, !tbaa !87
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* %31) #17
  %34 = icmp eq %struct.GCObject* %33, %27
  br i1 %34, label %35, label %30

; <label>:35:                                     ; preds = %30, %22
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 22
  %37 = load %struct.GCObject*, %struct.GCObject** %36, align 8, !tbaa !51
  %38 = icmp eq %struct.GCObject* %37, null
  br i1 %38, label %45, label %39

; <label>:39:                                     ; preds = %35
  br label %40

; <label>:40:                                     ; preds = %39, %40
  %41 = phi %struct.GCObject* [ %43, %40 ], [ %37, %39 ]
  %42 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %41, i64 0, i32 0
  %43 = load %struct.GCObject*, %struct.GCObject** %42, align 8, !tbaa !87
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %41) #17
  %44 = icmp eq %struct.GCObject* %43, null
  br i1 %44, label %45, label %40

; <label>:45:                                     ; preds = %40, %35
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 29
  %47 = load %struct.GCObject*, %struct.GCObject** %46, align 8, !tbaa !96
  %48 = icmp eq %struct.GCObject* %47, null
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %45
  br label %50

; <label>:50:                                     ; preds = %49, %50
  %51 = phi %struct.GCObject* [ %53, %50 ], [ %47, %49 ]
  %52 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %51, i64 0, i32 0
  %53 = load %struct.GCObject*, %struct.GCObject** %52, align 8, !tbaa !87
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %51) #17
  %54 = icmp eq %struct.GCObject* %53, null
  br i1 %54, label %55, label %50

; <label>:55:                                     ; preds = %50, %45
  %56 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 6
  %58 = bitcast %struct.stringtable* %57 to i8**
  %59 = load i8*, i8** %58, align 8, !tbaa !102
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 6, i32 2
  %61 = load i32, i32* %60, align 4, !tbaa !103
  %62 = sext i32 %61 to i64
  %63 = shl nsw i64 %62, 3
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 0
  %65 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %64, align 8, !tbaa !59
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 1
  %67 = load i8*, i8** %66, align 8, !tbaa !60
  %68 = tail call i8* %65(i8* %67, i8* %59, i64 %63, i64 0) #17
  %69 = getelementptr inbounds %struct.global_State, %struct.global_State* %56, i64 0, i32 3
  %70 = load i64, i64* %69, align 8, !tbaa !11
  %71 = sub i64 %70, %63
  store i64 %71, i64* %69, align 8, !tbaa !11
  tail call fastcc void @freestack(%struct.lua_State* %0) #16
  %72 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 0
  %73 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %72, align 8, !tbaa !59
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 1
  %75 = load i8*, i8** %74, align 8, !tbaa !60
  %76 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 -1, i32 23
  %77 = bitcast i32* %76 to i8*
  %78 = tail call i8* %73(i8* %75, i8* nonnull %77, i64 1616, i64 0) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_close(%struct.lua_State* nocapture readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !38
  tail call fastcc void @close_state(%struct.lua_State* %5) #16
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_sethook(%struct.lua_State*, void (%struct.lua_State*, %struct.lua_Debug*)*, i32, i32) local_unnamed_addr #2 {
  %5 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %1, null
  %6 = icmp eq i32 %2, 0
  %7 = or i1 %5, %6
  %8 = select i1 %7, i32 0, i32 %2
  %9 = select i1 %7, void (%struct.lua_State*, %struct.lua_Debug*)* null, void (%struct.lua_State*, %struct.lua_Debug*)* %1
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !24
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 7
  %13 = load i16, i16* %12, align 2, !tbaa !63
  %14 = and i16 %13, 2
  %15 = icmp eq i16 %14, 0
  br i1 %15, label %16, label %22

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 4
  %18 = bitcast %union.anon.0* %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %21 = bitcast i32** %20 to i64*
  store i64 %19, i64* %21, align 8, !tbaa !104
  br label %22

; <label>:22:                                     ; preds = %4, %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  store volatile void (%struct.lua_State*, %struct.lua_Debug*)* %9, void (%struct.lua_State*, %struct.lua_Debug*)** %23, align 8, !tbaa !30
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  store i32 %3, i32* %24, align 8, !tbaa !32
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  store i32 %3, i32* %25, align 4, !tbaa !37
  %26 = and i32 %8, 255
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  store i32 %26, i32* %27, align 8, !tbaa !31
  %28 = icmp eq i32 %8, 0
  %29 = icmp eq %struct.CallInfo* %11, null
  %30 = or i1 %28, %29
  br i1 %30, label %47, label %31

; <label>:31:                                     ; preds = %22
  br label %32

; <label>:32:                                     ; preds = %31, %44
  %33 = phi i16 [ %46, %44 ], [ %13, %31 ]
  %34 = phi %struct.CallInfo* [ %42, %44 ], [ %11, %31 ]
  %35 = and i16 %33, 2
  %36 = icmp eq i16 %35, 0
  br i1 %36, label %37, label %40

; <label>:37:                                     ; preds = %32
  %38 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 4, i32 0, i32 1
  %39 = bitcast i64* %38 to i32*
  store i32 1, i32* %39, align 8, !tbaa !21
  br label %40

; <label>:40:                                     ; preds = %37, %32
  %41 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 2
  %42 = load %struct.CallInfo*, %struct.CallInfo** %41, align 8, !tbaa !105
  %43 = icmp eq %struct.CallInfo* %42, null
  br i1 %43, label %47, label %44

; <label>:44:                                     ; preds = %40
  %45 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 7
  %46 = load i16, i16* %45, align 2, !tbaa !63
  br label %32

; <label>:47:                                     ; preds = %40, %22
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void (%struct.lua_State*, %struct.lua_Debug*)* @lua_gethook(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %3 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %2, align 8, !tbaa !30
  ret void (%struct.lua_State*, %struct.lua_Debug*)* %3
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_gethookmask(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %3 = load i32, i32* %2, align 8, !tbaa !31
  ret i32 %3
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_gethookcount(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %3 = load i32, i32* %2, align 8, !tbaa !32
  ret i32 %3
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_getstack(%struct.lua_State* readonly, i32, %struct.lua_Debug* nocapture) local_unnamed_addr #2 {
  %4 = icmp slt i32 %1, 0
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !54
  %8 = icmp ne i32 %1, 0
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %10 = icmp ne %struct.CallInfo* %7, %9
  %11 = and i1 %8, %10
  br i1 %11, label %12, label %22

; <label>:12:                                     ; preds = %5
  br label %13

; <label>:13:                                     ; preds = %12, %13
  %14 = phi %struct.CallInfo* [ %18, %13 ], [ %7, %12 ]
  %15 = phi i32 [ %16, %13 ], [ %1, %12 ]
  %16 = add nsw i32 %15, -1
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %14, i64 0, i32 2
  %18 = load %struct.CallInfo*, %struct.CallInfo** %17, align 8, !tbaa !54
  %19 = icmp sgt i32 %15, 1
  %20 = icmp ne %struct.CallInfo* %18, %9
  %21 = and i1 %19, %20
  br i1 %21, label %13, label %22

; <label>:22:                                     ; preds = %13, %5
  %23 = phi i32 [ %1, %5 ], [ %16, %13 ]
  %24 = phi %struct.CallInfo* [ %7, %5 ], [ %18, %13 ]
  %25 = icmp ne i32 %23, 0
  %26 = icmp eq %struct.CallInfo* %24, %9
  %27 = or i1 %25, %26
  br i1 %27, label %30, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %24, %struct.CallInfo** %29, align 8, !tbaa !106
  br label %30

; <label>:30:                                     ; preds = %28, %22, %3
  %31 = phi i32 [ 0, %3 ], [ 1, %28 ], [ 0, %22 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_getlocal(%struct.lua_State* nocapture, %struct.lua_Debug* readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = icmp eq %struct.lua_Debug* %1, null
  br i1 %5, label %6, label %19

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !21
  %11 = icmp eq i8 %10, 86
  br i1 %11, label %12, label %40

; <label>:12:                                     ; preds = %6
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 0, i32 0
  %14 = bitcast %struct.GCObject** %13 to %struct.LClosure**
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %17, i32 %2, i32 0) #16
  br label %40

; <label>:19:                                     ; preds = %3
  %20 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !54
  %21 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %22 = load %struct.CallInfo*, %struct.CallInfo** %21, align 8, !tbaa !106
  %23 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %22, i32 %2, %union.StackValue** nonnull %4) #16
  %24 = icmp eq i8* %23, null
  br i1 %24, label %39, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %union.StackValue** %4 to %struct.TValue**
  %30 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !54
  %31 = bitcast %struct.TValue* %30 to i64*
  %32 = bitcast %struct.TValue* %28 to i64*
  %33 = load i64, i64* %31, align 8
  store i64 %33, i64* %32, align 8
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !22
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %26, align 8, !tbaa !20
  br label %39

; <label>:39:                                     ; preds = %19, %25
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %40

; <label>:40:                                     ; preds = %6, %12, %39
  %41 = phi i8* [ %18, %12 ], [ %23, %39 ], [ null, %6 ]
  ret i8* %41
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc i8* @luaF_getlocalname(%struct.Proto* nocapture readonly, i32, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %5 = load i32, i32* %4, align 4, !tbaa !108
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %34

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %9 = load %struct.LocVar*, %struct.LocVar** %8, align 8, !tbaa !110
  %10 = sext i32 %5 to i64
  br label %11

; <label>:11:                                     ; preds = %7, %30
  %12 = phi i64 [ 0, %7 ], [ %32, %30 ]
  %13 = phi i32 [ %1, %7 ], [ %31, %30 ]
  %14 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %12, i32 1
  %15 = load i32, i32* %14, align 8, !tbaa !111
  %16 = icmp sgt i32 %15, %2
  br i1 %16, label %34, label %17

; <label>:17:                                     ; preds = %11
  %18 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %12, i32 2
  %19 = load i32, i32* %18, align 4, !tbaa !113
  %20 = icmp sgt i32 %19, %2
  br i1 %20, label %21, label %30

; <label>:21:                                     ; preds = %17
  %22 = add nsw i32 %13, -1
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %21
  %25 = and i64 %12, 4294967295
  %26 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %9, i64 %25, i32 0
  %27 = bitcast %struct.TString** %26 to i8**
  %28 = load i8*, i8** %27, align 8, !tbaa !114
  %29 = getelementptr inbounds i8, i8* %28, i64 24
  br label %34

; <label>:30:                                     ; preds = %17, %21
  %31 = phi i32 [ %22, %21 ], [ %13, %17 ]
  %32 = add nuw nsw i64 %12, 1
  %33 = icmp slt i64 %32, %10
  br i1 %33, label %11, label %34

; <label>:34:                                     ; preds = %11, %30, %3, %24
  %35 = phi i8* [ %29, %24 ], [ null, %3 ], [ null, %30 ], [ null, %11 ]
  ret i8* %35
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i8* @luaG_findlocal(%struct.lua_State* nocapture readonly, %struct.CallInfo* readonly, i32, %union.StackValue**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !63
  %10 = and i16 %9, 2
  %11 = icmp eq i16 %10, 0
  br i1 %11, label %12, label %49

; <label>:12:                                     ; preds = %4
  %13 = bitcast %union.StackValue* %6 to %struct.LClosure**
  %14 = icmp slt i32 %2, 0
  %15 = load %struct.LClosure*, %struct.LClosure** %13, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  br i1 %14, label %18, label %36

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 4
  %20 = load i8, i8* %19, align 1, !tbaa !115
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %79, label %22

; <label>:22:                                     ; preds = %18
  %23 = sub nsw i32 0, %2
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %25 = bitcast %union.anon.0* %24 to %struct.anon*
  %26 = getelementptr inbounds %struct.anon, %struct.anon* %25, i64 0, i32 2
  %27 = load i32, i32* %26, align 4, !tbaa !21
  %28 = icmp slt i32 %27, %23
  br i1 %28, label %79, label %29

; <label>:29:                                     ; preds = %22
  %30 = sext i32 %27 to i64
  %31 = sub nsw i64 0, %30
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %31
  %33 = xor i32 %2, -1
  %34 = sext i32 %33 to i64
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 %34
  store %union.StackValue* %35, %union.StackValue** %3, align 8, !tbaa !54
  br label %79

; <label>:36:                                     ; preds = %12
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %38 = bitcast %union.anon.0* %37 to i64*
  %39 = load i64, i64* %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 16
  %41 = bitcast i32** %40 to i64*
  %42 = load i64, i64* %41, align 8, !tbaa !116
  %43 = sub i64 %39, %42
  %44 = lshr exact i64 %43, 2
  %45 = trunc i64 %44 to i32
  %46 = add nsw i32 %45, -1
  %47 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %17, i32 %2, i32 %46) #16
  %48 = icmp eq i8* %47, null
  br i1 %48, label %49, label %72

; <label>:49:                                     ; preds = %4, %36
  %50 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %51 = load %struct.CallInfo*, %struct.CallInfo** %50, align 8, !tbaa !24
  %52 = icmp eq %struct.CallInfo* %51, %1
  br i1 %52, label %53, label %55

; <label>:53:                                     ; preds = %49
  %54 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %59

; <label>:55:                                     ; preds = %49
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 3
  %57 = load %struct.CallInfo*, %struct.CallInfo** %56, align 8, !tbaa !117
  %58 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %57, i64 0, i32 0
  br label %59

; <label>:59:                                     ; preds = %55, %53
  %60 = phi %union.StackValue** [ %54, %53 ], [ %58, %55 ]
  %61 = bitcast %union.StackValue** %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !54
  %63 = ptrtoint %union.StackValue* %7 to i64
  %64 = sub i64 %62, %63
  %65 = ashr exact i64 %64, 4
  %66 = sext i32 %2 to i64
  %67 = icmp sge i64 %65, %66
  %68 = icmp sgt i32 %2, 0
  %69 = and i1 %68, %67
  br i1 %69, label %70, label %79

; <label>:70:                                     ; preds = %59
  %71 = select i1 %11, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.142, i64 0, i64 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.143, i64 0, i64 0)
  br label %72

; <label>:72:                                     ; preds = %70, %36
  %73 = phi i8* [ %47, %36 ], [ %71, %70 ]
  %74 = icmp eq %union.StackValue** %3, null
  br i1 %74, label %79, label %75

; <label>:75:                                     ; preds = %72
  %76 = add nsw i32 %2, -1
  %77 = sext i32 %76 to i64
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %77
  store %union.StackValue* %78, %union.StackValue** %3, align 8, !tbaa !54
  br label %79

; <label>:79:                                     ; preds = %59, %29, %22, %18, %75, %72
  %80 = phi i8* [ %73, %72 ], [ %73, %75 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.144, i64 0, i64 0), %29 ], [ null, %22 ], [ null, %18 ], [ null, %59 ]
  ret i8* %80
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_setlocal(%struct.lua_State* nocapture, %struct.lua_Debug* nocapture readonly, i32) local_unnamed_addr #0 {
  %4 = alloca %union.StackValue*, align 8
  %5 = bitcast %union.StackValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %union.StackValue* null, %union.StackValue** %4, align 8, !tbaa !54
  %6 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 16
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !106
  %8 = call fastcc i8* @luaG_findlocal(%struct.lua_State* %0, %struct.CallInfo* %7, i32 %2, %union.StackValue** nonnull %4) #16
  %9 = icmp eq i8* %8, null
  br i1 %9, label %24, label %10

; <label>:10:                                     ; preds = %3
  %11 = bitcast %union.StackValue** %4 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !54
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0
  %16 = bitcast %struct.TValue* %15 to i64*
  %17 = bitcast %struct.TValue* %12 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1
  store %union.StackValue* %23, %union.StackValue** %13, align 8, !tbaa !20
  br label %24

; <label>:24:                                     ; preds = %3, %10
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %8
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_getinfo(%struct.lua_State*, i8* readonly, %struct.lua_Debug*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 62
  br i1 %6, label %7, label %13

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1, i32 0
  %11 = getelementptr inbounds i8, i8* %1, i64 1
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1
  store %union.StackValue* %12, %union.StackValue** %8, align 8, !tbaa !20
  br label %18

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  %15 = load %struct.CallInfo*, %struct.CallInfo** %14, align 8, !tbaa !106
  %16 = bitcast %struct.CallInfo* %15 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !64
  br label %18

; <label>:18:                                     ; preds = %13, %7
  %19 = phi %struct.TValue* [ %10, %7 ], [ %17, %13 ]
  %20 = phi %struct.CallInfo* [ null, %7 ], [ %15, %13 ]
  %21 = phi i8* [ %11, %7 ], [ %1, %13 ]
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = and i8 %23, 31
  %25 = icmp eq i8 %24, 22
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %18
  %27 = bitcast %struct.TValue* %19 to %union.Closure**
  %28 = load %union.Closure*, %union.Closure** %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %18, %26
  %30 = phi %union.Closure* [ %28, %26 ], [ null, %18 ]
  %31 = load i8, i8* %21, align 1, !tbaa !21
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %238, label %33

; <label>:33:                                     ; preds = %29
  %34 = icmp eq %union.Closure* %30, null
  %35 = icmp eq %struct.CallInfo* %20, null
  %36 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %37 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 4
  %38 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 5
  %39 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 7
  %40 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 8
  %41 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 3
  %42 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 15, i64 0
  %43 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 1
  %44 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %45 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 7
  %46 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %47 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %48 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %49 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 3
  %50 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %51 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %52 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %53 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %54 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 5
  %55 = bitcast i32 (%struct.lua_State*)** %54 to %struct.Proto**
  %56 = bitcast %struct.CallInfo* %20 to %struct.LClosure***
  %57 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 4
  %58 = bitcast %union.anon.0* %57 to i64*
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 5
  %60 = bitcast %union.anon.2* %59 to %struct.anon.3*
  %61 = bitcast %union.anon.2* %59 to i16*
  %62 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %60, i64 0, i32 1
  %63 = bitcast i8** %37 to %struct.TString**
  %64 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 2
  %65 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %66 = bitcast i8** %36 to <2 x i8*>*
  br label %67

; <label>:67:                                     ; preds = %233, %33
  %68 = phi i8 [ %31, %33 ], [ %236, %233 ]
  %69 = phi i32 [ 1, %33 ], [ %234, %233 ]
  %70 = phi i8* [ %21, %33 ], [ %235, %233 ]
  %71 = sext i8 %68 to i32
  switch i32 %71, label %232 [
    i32 83, label %72
    i32 108, label %109
    i32 117, label %130
    i32 116, label %144
    i32 110, label %151
    i32 114, label %223
    i32 76, label %233
    i32 102, label %233
  ]

; <label>:72:                                     ; preds = %67
  br i1 %34, label %76, label %73

; <label>:73:                                     ; preds = %72
  %74 = load i8, i8* %43, align 8, !tbaa !21
  %75 = icmp eq i8 %74, 54
  br i1 %75, label %76, label %77

; <label>:76:                                     ; preds = %73, %72
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.145, i64 0, i64 0), i8** %37, align 8, !tbaa !118
  store i64 4, i64* %38, align 8, !tbaa !119
  store i32 -1, i32* %39, align 4, !tbaa !120
  store i32 -1, i32* %40, align 8, !tbaa !121
  br label %105

; <label>:77:                                     ; preds = %73
  %78 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 22
  %80 = load %struct.TString*, %struct.TString** %79, align 8, !tbaa !122
  %81 = icmp eq %struct.TString* %80, null
  br i1 %81, label %95, label %82

; <label>:82:                                     ; preds = %77
  %83 = getelementptr inbounds %struct.TString, %struct.TString* %80, i64 1
  store %struct.TString* %83, %struct.TString** %63, align 8, !tbaa !118
  %84 = getelementptr inbounds %struct.TString, %struct.TString* %80, i64 0, i32 1
  %85 = load i8, i8* %84, align 8, !tbaa !75
  %86 = icmp eq i8 %85, 20
  %87 = bitcast %struct.TString* %83 to i8*
  br i1 %86, label %88, label %92

; <label>:88:                                     ; preds = %82
  %89 = getelementptr inbounds %struct.TString, %struct.TString* %80, i64 0, i32 4
  %90 = load i8, i8* %89, align 1, !tbaa !123
  %91 = zext i8 %90 to i64
  br label %96

; <label>:92:                                     ; preds = %82
  %93 = getelementptr inbounds %struct.TString, %struct.TString* %80, i64 0, i32 6, i32 0
  %94 = load i64, i64* %93, align 8, !tbaa !21
  br label %96

; <label>:95:                                     ; preds = %77
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.147, i64 0, i64 0), i8** %37, align 8, !tbaa !118
  br label %96

; <label>:96:                                     ; preds = %95, %92, %88
  %97 = phi i64 [ 2, %95 ], [ %91, %88 ], [ %94, %92 ]
  %98 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.147, i64 0, i64 0), %95 ], [ %87, %88 ], [ %87, %92 ]
  store i64 %97, i64* %38, align 8, !tbaa !119
  %99 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 13
  %100 = load i32, i32* %99, align 4, !tbaa !124
  store i32 %100, i32* %39, align 4, !tbaa !120
  %101 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 14
  %102 = load i32, i32* %101, align 8, !tbaa !125
  store i32 %102, i32* %40, align 8, !tbaa !121
  %103 = icmp eq i32 %100, 0
  %104 = select i1 %103, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.148, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.149, i64 0, i64 0)
  br label %105

; <label>:105:                                    ; preds = %96, %76
  %106 = phi i8* [ %104, %96 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.146, i64 0, i64 0), %76 ]
  %107 = phi i64 [ %97, %96 ], [ 4, %76 ]
  %108 = phi i8* [ %98, %96 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.145, i64 0, i64 0), %76 ]
  store i8* %106, i8** %41, align 8, !tbaa !126
  tail call fastcc void @luaO_chunkid(i8* nonnull %42, i8* %108, i64 %107) #17
  br label %233

; <label>:109:                                    ; preds = %67
  br i1 %35, label %128, label %110

; <label>:110:                                    ; preds = %109
  %111 = load i16, i16* %45, align 2, !tbaa !63
  %112 = and i16 %111, 2
  %113 = icmp eq i16 %112, 0
  br i1 %113, label %114, label %128

; <label>:114:                                    ; preds = %110
  %115 = load %struct.LClosure**, %struct.LClosure*** %56, align 8, !tbaa !64
  %116 = load %struct.LClosure*, %struct.LClosure** %115, align 8, !tbaa !21
  %117 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %116, i64 0, i32 5
  %118 = load %struct.Proto*, %struct.Proto** %117, align 8, !tbaa !21
  %119 = load i64, i64* %58, align 8, !tbaa !21
  %120 = getelementptr inbounds %struct.Proto, %struct.Proto* %118, i64 0, i32 16
  %121 = bitcast i32** %120 to i64*
  %122 = load i64, i64* %121, align 8, !tbaa !116
  %123 = sub i64 %119, %122
  %124 = lshr exact i64 %123, 2
  %125 = trunc i64 %124 to i32
  %126 = add nsw i32 %125, -1
  %127 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %118, i32 %126) #17
  br label %128

; <label>:128:                                    ; preds = %114, %110, %109
  %129 = phi i32 [ %127, %114 ], [ -1, %110 ], [ -1, %109 ]
  store i32 %129, i32* %44, align 8, !tbaa !127
  br label %233

; <label>:130:                                    ; preds = %67
  br i1 %34, label %135, label %131

; <label>:131:                                    ; preds = %130
  %132 = load i8, i8* %49, align 2, !tbaa !21
  store i8 %132, i8* %46, align 4, !tbaa !128
  %133 = load i8, i8* %43, align 8, !tbaa !21
  %134 = icmp eq i8 %133, 54
  br i1 %134, label %136, label %137

; <label>:135:                                    ; preds = %130
  store i8 0, i8* %46, align 4, !tbaa !128
  br label %136

; <label>:136:                                    ; preds = %135, %131
  store i8 1, i8* %47, align 2, !tbaa !129
  store i8 0, i8* %48, align 1, !tbaa !130
  br label %233

; <label>:137:                                    ; preds = %131
  %138 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !21
  %139 = getelementptr inbounds %struct.Proto, %struct.Proto* %138, i64 0, i32 4
  %140 = load i8, i8* %139, align 1, !tbaa !115
  store i8 %140, i8* %47, align 2, !tbaa !129
  %141 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !21
  %142 = getelementptr inbounds %struct.Proto, %struct.Proto* %141, i64 0, i32 3
  %143 = load i8, i8* %142, align 2, !tbaa !131
  store i8 %143, i8* %48, align 1, !tbaa !130
  br label %233

; <label>:144:                                    ; preds = %67
  br i1 %35, label %149, label %145

; <label>:145:                                    ; preds = %144
  %146 = load i16, i16* %45, align 2, !tbaa !63
  %147 = trunc i16 %146 to i8
  %148 = and i8 %147, 16
  br label %149

; <label>:149:                                    ; preds = %145, %144
  %150 = phi i8 [ %148, %145 ], [ 0, %144 ]
  store i8 %150, i8* %50, align 1, !tbaa !132
  br label %233

; <label>:151:                                    ; preds = %67
  br i1 %35, label %216, label %152

; <label>:152:                                    ; preds = %151
  %153 = load i16, i16* %45, align 2, !tbaa !63
  %154 = zext i16 %153 to i32
  %155 = and i32 %154, 64
  %156 = icmp eq i32 %155, 0
  br i1 %156, label %157, label %213

; <label>:157:                                    ; preds = %152
  %158 = and i32 %154, 16
  %159 = icmp eq i32 %158, 0
  br i1 %159, label %160, label %216

; <label>:160:                                    ; preds = %157
  %161 = load %struct.CallInfo*, %struct.CallInfo** %64, align 8, !tbaa !105
  %162 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %161, i64 0, i32 7
  %163 = load i16, i16* %162, align 2, !tbaa !63
  %164 = and i16 %163, 2
  %165 = icmp eq i16 %164, 0
  br i1 %165, label %166, label %216

; <label>:166:                                    ; preds = %160
  %167 = bitcast %struct.CallInfo* %161 to %struct.LClosure***
  %168 = load %struct.LClosure**, %struct.LClosure*** %167, align 8, !tbaa !64
  %169 = load %struct.LClosure*, %struct.LClosure** %168, align 8, !tbaa !21
  %170 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %169, i64 0, i32 5
  %171 = load %struct.Proto*, %struct.Proto** %170, align 8, !tbaa !21
  %172 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %161, i64 0, i32 4
  %173 = bitcast %union.anon.0* %172 to i64*
  %174 = load i64, i64* %173, align 8, !tbaa !21
  %175 = getelementptr inbounds %struct.Proto, %struct.Proto* %171, i64 0, i32 16
  %176 = bitcast i32** %175 to i64*
  %177 = load i64, i64* %176, align 8, !tbaa !116
  %178 = sub i64 %174, %177
  %179 = lshr exact i64 %178, 2
  %180 = trunc i64 %179 to i32
  %181 = add nsw i32 %180, -1
  %182 = inttoptr i64 %177 to i32*
  %183 = sext i32 %181 to i64
  %184 = getelementptr inbounds i32, i32* %182, i64 %183
  %185 = load i32, i32* %184, align 4, !tbaa !77
  %186 = and i16 %163, 4
  %187 = icmp eq i16 %186, 0
  br i1 %187, label %188, label %213

; <label>:188:                                    ; preds = %166
  %189 = and i32 %185, 127
  %190 = trunc i32 %185 to i7
  switch i7 %190, label %216 [
    i7 -59, label %217
    i7 -58, label %217
    i7 -51, label %213
    i7 18, label %205
    i7 9, label %205
    i7 10, label %205
    i7 11, label %205
    i7 12, label %205
    i7 13, label %191
    i7 14, label %191
    i7 15, label %191
    i7 16, label %191
    i7 19, label %192
    i7 20, label %192
    i7 21, label %192
    i7 22, label %192
    i7 23, label %192
    i7 24, label %192
    i7 25, label %192
    i7 26, label %194
    i7 27, label %194
    i7 28, label %194
    i7 29, label %194
    i7 30, label %194
    i7 31, label %194
    i7 32, label %194
    i7 33, label %194
    i7 34, label %194
    i7 35, label %194
    i7 38, label %196
    i7 39, label %196
    i7 40, label %196
    i7 41, label %196
    i7 42, label %196
    i7 43, label %196
    i7 44, label %196
    i7 45, label %196
    i7 46, label %196
    i7 47, label %196
    i7 48, label %196
    i7 49, label %196
    i7 50, label %198
    i7 51, label %199
    i7 53, label %200
    i7 54, label %201
    i7 58, label %202
    i7 59, label %203
    i7 60, label %203
    i7 63, label %203
    i7 -64, label %203
    i7 36, label %204
    i7 37, label %204
  ]

; <label>:191:                                    ; preds = %188, %188, %188, %188
  br label %205

; <label>:192:                                    ; preds = %188, %188, %188, %188, %188, %188, %188
  %193 = add nsw i32 %189, -13
  br label %205

; <label>:194:                                    ; preds = %188, %188, %188, %188, %188, %188, %188, %188, %188, %188
  %195 = add nsw i32 %189, -20
  br label %205

; <label>:196:                                    ; preds = %188, %188, %188, %188, %188, %188, %188, %188, %188, %188, %188, %188
  %197 = add nsw i32 %189, -32
  br label %205

; <label>:198:                                    ; preds = %188
  br label %205

; <label>:199:                                    ; preds = %188
  br label %205

; <label>:200:                                    ; preds = %188
  br label %205

; <label>:201:                                    ; preds = %188
  br label %205

; <label>:202:                                    ; preds = %188
  br label %205

; <label>:203:                                    ; preds = %188, %188, %188, %188
  br label %213

; <label>:204:                                    ; preds = %188, %188
  br label %213

; <label>:205:                                    ; preds = %202, %201, %200, %199, %198, %196, %194, %192, %191, %188, %188, %188, %188, %188
  %206 = phi i32 [ 5, %202 ], [ 22, %201 ], [ 4, %200 ], [ 19, %199 ], [ 18, %198 ], [ %197, %196 ], [ %195, %194 ], [ %193, %192 ], [ 1, %191 ], [ 0, %188 ], [ 0, %188 ], [ 0, %188 ], [ 0, %188 ], [ 0, %188 ]
  %207 = load %struct.global_State*, %struct.global_State** %65, align 8, !tbaa !2
  %208 = zext i32 %206 to i64
  %209 = getelementptr inbounds %struct.global_State, %struct.global_State* %207, i64 0, i32 40, i64 %208
  %210 = bitcast %struct.TString** %209 to i8**
  %211 = load i8*, i8** %210, align 8, !tbaa !54
  %212 = getelementptr inbounds i8, i8* %211, i64 26
  br label %213

; <label>:213:                                    ; preds = %188, %166, %152, %205, %204, %203
  %214 = phi i8* [ %212, %205 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.156, i64 0, i64 0), %204 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.155, i64 0, i64 0), %203 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0), %152 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %166 ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), %188 ]
  %215 = phi i8* [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %205 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %204 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %203 ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.152, i64 0, i64 0), %152 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.153, i64 0, i64 0), %166 ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i64 0, i64 0), %188 ]
  store i8* %214, i8** %36, align 8, !tbaa !54
  store i8* %215, i8** %51, align 8, !tbaa !133
  br label %233

; <label>:216:                                    ; preds = %188, %160, %157, %151
  store i8* null, i8** %51, align 8, !tbaa !133
  br label %222

; <label>:217:                                    ; preds = %188, %188
  %218 = lshr i32 %185, 7
  %219 = and i32 %218, 255
  %220 = tail call fastcc i8* @getobjname(%struct.Proto* %171, i32 %181, i32 %219, i8** nonnull %36) #17
  store i8* %220, i8** %51, align 8, !tbaa !133
  %221 = icmp eq i8* %220, null
  br i1 %221, label %222, label %233

; <label>:222:                                    ; preds = %217, %216
  store <2 x i8*> <i8* null, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)>, <2 x i8*>* %66, align 8, !tbaa !54
  br label %233

; <label>:223:                                    ; preds = %67
  br i1 %35, label %228, label %224

; <label>:224:                                    ; preds = %223
  %225 = load i16, i16* %45, align 2, !tbaa !63
  %226 = trunc i16 %225 to i8
  %227 = icmp slt i8 %226, 0
  br i1 %227, label %229, label %228

; <label>:228:                                    ; preds = %224, %223
  store i16 0, i16* %52, align 2, !tbaa !134
  store i16 0, i16* %53, align 8, !tbaa !135
  br label %233

; <label>:229:                                    ; preds = %224
  %230 = load i16, i16* %61, align 8, !tbaa !21
  store i16 %230, i16* %53, align 8, !tbaa !135
  %231 = load i16, i16* %62, align 2, !tbaa !21
  store i16 %231, i16* %52, align 2, !tbaa !134
  br label %233

; <label>:232:                                    ; preds = %67
  br label %233

; <label>:233:                                    ; preds = %232, %229, %228, %222, %217, %213, %149, %137, %136, %128, %105, %67, %67
  %234 = phi i32 [ 0, %232 ], [ %69, %67 ], [ %69, %67 ], [ %69, %228 ], [ %69, %229 ], [ %69, %222 ], [ %69, %217 ], [ %69, %149 ], [ %69, %136 ], [ %69, %137 ], [ %69, %128 ], [ %69, %105 ], [ %69, %213 ]
  %235 = getelementptr inbounds i8, i8* %70, i64 1
  %236 = load i8, i8* %235, align 1, !tbaa !21
  %237 = icmp eq i8 %236, 0
  br i1 %237, label %238, label %67

; <label>:238:                                    ; preds = %233, %29
  %239 = phi i32 [ 1, %29 ], [ %234, %233 ]
  %240 = tail call i8* @strchr(i8* %21, i32 102) #21
  %241 = icmp eq i8* %240, null
  br i1 %241, label %253, label %242

; <label>:242:                                    ; preds = %238
  %243 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %244 = bitcast %union.StackValue** %243 to %struct.TValue**
  %245 = load %struct.TValue*, %struct.TValue** %244, align 8, !tbaa !20
  %246 = bitcast %struct.TValue* %19 to i64*
  %247 = bitcast %struct.TValue* %245 to i64*
  %248 = load i64, i64* %246, align 8
  store i64 %248, i64* %247, align 8
  %249 = load i8, i8* %22, align 8, !tbaa !22
  %250 = getelementptr inbounds %struct.TValue, %struct.TValue* %245, i64 0, i32 1
  store i8 %249, i8* %250, align 8, !tbaa !22
  %251 = load %union.StackValue*, %union.StackValue** %243, align 8, !tbaa !20
  %252 = getelementptr inbounds %union.StackValue, %union.StackValue* %251, i64 1
  store %union.StackValue* %252, %union.StackValue** %243, align 8, !tbaa !20
  br label %253

; <label>:253:                                    ; preds = %238, %242
  %254 = tail call i8* @strchr(i8* %21, i32 76) #21
  %255 = icmp eq i8* %254, null
  br i1 %255, label %335, label %256

; <label>:256:                                    ; preds = %253
  %257 = icmp eq %union.Closure* %30, null
  br i1 %257, label %262, label %258

; <label>:258:                                    ; preds = %256
  %259 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 1
  %260 = load i8, i8* %259, align 8, !tbaa !21
  %261 = icmp eq i8 %260, 54
  br i1 %261, label %262, label %269

; <label>:262:                                    ; preds = %258, %256
  %263 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %264 = bitcast %union.StackValue** %263 to %struct.TValue**
  %265 = load %struct.TValue*, %struct.TValue** %264, align 8, !tbaa !20
  %266 = getelementptr inbounds %struct.TValue, %struct.TValue* %265, i64 0, i32 1
  store i8 0, i8* %266, align 8, !tbaa !21
  %267 = load %union.StackValue*, %union.StackValue** %263, align 8, !tbaa !20
  %268 = getelementptr inbounds %union.StackValue, %union.StackValue* %267, i64 1
  store %union.StackValue* %268, %union.StackValue** %263, align 8, !tbaa !20
  br label %335

; <label>:269:                                    ; preds = %258
  %270 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %270) #7
  %271 = getelementptr inbounds %union.Closure, %union.Closure* %30, i64 0, i32 0, i32 5
  %272 = bitcast i32 (%struct.lua_State*)** %271 to %struct.Proto**
  %273 = load %struct.Proto*, %struct.Proto** %272, align 8, !tbaa !21
  %274 = getelementptr inbounds %struct.Proto, %struct.Proto* %273, i64 0, i32 13
  %275 = load i32, i32* %274, align 4, !tbaa !124
  %276 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %277 = load %struct.global_State*, %struct.global_State** %276, align 8, !tbaa !2
  %278 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 56, i32 5) #17
  %279 = getelementptr inbounds %struct.global_State, %struct.global_State* %277, i64 0, i32 10
  %280 = load i8, i8* %279, align 4, !tbaa !15
  %281 = and i8 %280, 24
  %282 = getelementptr inbounds i8, i8* %278, i64 9
  store i8 %281, i8* %282, align 1, !tbaa !70
  %283 = getelementptr inbounds i8, i8* %278, i64 8
  store i8 5, i8* %283, align 8, !tbaa !86
  %284 = getelementptr inbounds %struct.global_State, %struct.global_State* %277, i64 0, i32 20
  %285 = bitcast %struct.GCObject** %284 to i64*
  %286 = load i64, i64* %285, align 8, !tbaa !18
  %287 = bitcast i8* %278 to i64*
  store i64 %286, i64* %287, align 8, !tbaa !87
  %288 = bitcast %struct.GCObject** %284 to i8**
  store i8* %278, i8** %288, align 8, !tbaa !18
  %289 = bitcast i8* %278 to %struct.Table*
  %290 = getelementptr inbounds i8, i8* %278, i64 40
  %291 = bitcast i8* %290 to %struct.Table**
  store %struct.Table* null, %struct.Table** %291, align 8, !tbaa !88
  %292 = getelementptr inbounds i8, i8* %278, i64 10
  store i8 -1, i8* %292, align 2, !tbaa !90
  %293 = getelementptr inbounds i8, i8* %278, i64 16
  %294 = bitcast i8* %293 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %294, align 8, !tbaa !91
  %295 = getelementptr inbounds i8, i8* %278, i64 12
  %296 = bitcast i8* %295 to i32*
  store i32 0, i32* %296, align 4, !tbaa !92
  %297 = getelementptr inbounds i8, i8* %278, i64 24
  %298 = getelementptr inbounds i8, i8* %278, i64 11
  store i8 0, i8* %298, align 1, !tbaa !93
  %299 = bitcast i8* %297 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %299, align 8, !tbaa !54
  %300 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %301 = bitcast %union.StackValue** %300 to %struct.TValue**
  %302 = load %struct.TValue*, %struct.TValue** %301, align 8, !tbaa !20
  %303 = bitcast %struct.TValue* %302 to i8**
  store i8* %278, i8** %303, align 8, !tbaa !21
  %304 = getelementptr inbounds %struct.TValue, %struct.TValue* %302, i64 0, i32 1
  store i8 69, i8* %304, align 8, !tbaa !22
  %305 = load %union.StackValue*, %union.StackValue** %300, align 8, !tbaa !20
  %306 = getelementptr inbounds %union.StackValue, %union.StackValue* %305, i64 1
  store %union.StackValue* %306, %union.StackValue** %300, align 8, !tbaa !20
  %307 = bitcast %struct.TValue* %4 to i32*
  store i32 1, i32* %307, align 8, !tbaa !21
  %308 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 1, i8* %308, align 8, !tbaa !22
  %309 = getelementptr inbounds %struct.Proto, %struct.Proto* %273, i64 0, i32 9
  %310 = load i32, i32* %309, align 4, !tbaa !136
  %311 = icmp sgt i32 %310, 0
  br i1 %311, label %312, label %334

; <label>:312:                                    ; preds = %269
  %313 = getelementptr inbounds %struct.Proto, %struct.Proto* %273, i64 0, i32 19
  br label %314

; <label>:314:                                    ; preds = %327, %312
  %315 = phi i64 [ 0, %312 ], [ %330, %327 ]
  %316 = phi i32 [ %275, %312 ], [ %328, %327 ]
  %317 = load i8*, i8** %313, align 8, !tbaa !137
  %318 = getelementptr inbounds i8, i8* %317, i64 %315
  %319 = load i8, i8* %318, align 1, !tbaa !21
  %320 = icmp eq i8 %319, -128
  br i1 %320, label %324, label %321

; <label>:321:                                    ; preds = %314
  %322 = sext i8 %319 to i32
  %323 = add nsw i32 %316, %322
  br label %327

; <label>:324:                                    ; preds = %314
  %325 = trunc i64 %315 to i32
  %326 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %273, i32 %325) #17
  br label %327

; <label>:327:                                    ; preds = %324, %321
  %328 = phi i32 [ %323, %321 ], [ %326, %324 ]
  %329 = sext i32 %328 to i64
  call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %289, i64 %329, %struct.TValue* nonnull %4) #17
  %330 = add nuw nsw i64 %315, 1
  %331 = load i32, i32* %309, align 4, !tbaa !136
  %332 = sext i32 %331 to i64
  %333 = icmp slt i64 %330, %332
  br i1 %333, label %314, label %334

; <label>:334:                                    ; preds = %327, %269
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %270) #7
  br label %335

; <label>:335:                                    ; preds = %334, %262, %253
  ret i32 %239
}

; Function Attrs: nounwind optsize readonly
declare i8* @strchr(i8*, i32) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define i32 @lua_resume(%struct.lua_State*, %struct.lua_State* readonly, i32, i32* nocapture) local_unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  store i32 %2, i32* %5, align 4, !tbaa !77
  %7 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %9 = load i8, i8* %8, align 2, !tbaa !35
  switch i8 %9, label %29 [
    i8 0, label %10
    i8 1, label %43
  ]

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %14 = icmp eq %struct.CallInfo* %12, %13
  br i1 %14, label %43, label %15

; <label>:15:                                     ; preds = %10
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %18 = sext i32 %2 to i64
  %19 = sub nsw i64 0, %18
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 %19
  store %union.StackValue* %20, %union.StackValue** %16, align 8, !tbaa !20
  %21 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str, i64 0, i64 0)) #17
  %22 = bitcast %union.StackValue* %20 to %struct.TString**
  store %struct.TString* %21, %struct.TString** %22, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !75
  %25 = or i8 %24, 64
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 %19, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %16, align 8, !tbaa !20
  br label %157

; <label>:29:                                     ; preds = %4
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %32 = sext i32 %2 to i64
  %33 = sub nsw i64 0, %32
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 %33
  store %union.StackValue* %34, %union.StackValue** %30, align 8, !tbaa !20
  %35 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0)) #17
  %36 = bitcast %union.StackValue* %34 to %struct.TString**
  store %struct.TString* %35, %struct.TString** %36, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TString, %struct.TString* %35, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !75
  %39 = or i8 %38, 64
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 %33, i32 0, i32 1
  store i8 %39, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %30, align 8, !tbaa !20
  br label %157

; <label>:43:                                     ; preds = %4, %10
  %44 = icmp eq %struct.lua_State* %1, null
  br i1 %44, label %45, label %47

; <label>:45:                                     ; preds = %43
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 1, i32* %46, align 8
  br label %76

; <label>:47:                                     ; preds = %43
  %48 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 19
  %49 = load i32, i32* %48, align 8, !tbaa !29
  %50 = and i32 %49, 65535
  %51 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 5
  %52 = load i16, i16* %51, align 4, !tbaa !25
  %53 = zext i16 %52 to i32
  %54 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %55 = load i16, i16* %54, align 4, !tbaa !25
  %56 = zext i16 %55 to i32
  %57 = add nuw nsw i32 %50, 10
  %58 = sub nsw i32 %57, %53
  %59 = add nsw i32 %58, %56
  %60 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  store i32 %59, i32* %60, align 8
  %61 = icmp ugt i32 %59, 2199
  br i1 %61, label %62, label %76

; <label>:62:                                     ; preds = %47
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %64 = load %union.StackValue*, %union.StackValue** %63, align 8, !tbaa !20
  %65 = sext i32 %2 to i64
  %66 = sub nsw i64 0, %65
  %67 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 %66
  store %union.StackValue* %67, %union.StackValue** %63, align 8, !tbaa !20
  %68 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0)) #17
  %69 = bitcast %union.StackValue* %67 to %struct.TString**
  store %struct.TString* %68, %struct.TString** %69, align 8, !tbaa !21
  %70 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !75
  %72 = or i8 %71, 64
  %73 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 %66, i32 0, i32 1
  store i8 %72, i8* %73, align 8, !tbaa !22
  %74 = load %union.StackValue*, %union.StackValue** %63, align 8, !tbaa !20
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %74, i64 1
  store %union.StackValue* %75, %union.StackValue** %63, align 8, !tbaa !20
  br label %157

; <label>:76:                                     ; preds = %45, %47
  %77 = bitcast i32* %5 to i8*
  %78 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @resume, i8* nonnull %77) #16
  store i32 %78, i32* %6, align 4, !tbaa !77
  %79 = icmp sgt i32 %78, 1
  br i1 %79, label %80, label %134

; <label>:80:                                     ; preds = %76
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %82 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %83 = bitcast %union.StackValue** %82 to i8**
  %84 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %85 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  br label %86

; <label>:86:                                     ; preds = %80, %101
  %87 = phi i32 [ %78, %80 ], [ %120, %101 ]
  %88 = load %struct.CallInfo*, %struct.CallInfo** %81, align 8, !tbaa !54
  %89 = icmp eq %struct.CallInfo* %88, null
  br i1 %89, label %124, label %90

; <label>:90:                                     ; preds = %86
  br label %91

; <label>:91:                                     ; preds = %90, %97
  %92 = phi %struct.CallInfo* [ %99, %97 ], [ %88, %90 ]
  %93 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %92, i64 0, i32 7
  %94 = load i16, i16* %93, align 2, !tbaa !63
  %95 = and i16 %94, 8
  %96 = icmp eq i16 %95, 0
  br i1 %96, label %97, label %101

; <label>:97:                                     ; preds = %91
  %98 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %92, i64 0, i32 2
  %99 = load %struct.CallInfo*, %struct.CallInfo** %98, align 8, !tbaa !54
  %100 = icmp eq %struct.CallInfo* %99, null
  br i1 %100, label %122, label %91

; <label>:101:                                    ; preds = %91
  %102 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %92, i64 0, i32 7
  %103 = load i8*, i8** %83, align 8, !tbaa !23
  %104 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %92, i64 0, i32 5, i32 0
  %105 = load i32, i32* %104, align 8, !tbaa !21
  %106 = sext i32 %105 to i64
  %107 = getelementptr inbounds i8, i8* %103, i64 %106
  %108 = bitcast i8* %107 to %union.StackValue*
  %109 = call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %108, i32 %87) #17
  %110 = load i8*, i8** %83, align 8, !tbaa !23
  %111 = load i32, i32* %104, align 8, !tbaa !21
  %112 = sext i32 %111 to i64
  %113 = getelementptr inbounds i8, i8* %110, i64 %112
  %114 = bitcast i8* %113 to %union.StackValue*
  call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %87, %union.StackValue* %114) #17
  store %struct.CallInfo* %92, %struct.CallInfo** %81, align 8, !tbaa !24
  %115 = load i16, i16* %102, align 2, !tbaa !63
  %116 = trunc i16 %115 to i8
  %117 = and i8 %116, 1
  store i8 %117, i8* %84, align 1, !tbaa !33
  call fastcc void @luaD_shrinkstack(%struct.lua_State* %0) #17
  %118 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %92, i64 0, i32 4, i32 0, i32 1
  %119 = load i64, i64* %118, align 8, !tbaa !21
  store i64 %119, i64* %85, align 8, !tbaa !36
  %120 = call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @unroll, i8* nonnull %7) #16
  store i32 %120, i32* %6, align 4, !tbaa !77
  %121 = icmp sgt i32 %120, 1
  br i1 %121, label %86, label %134

; <label>:122:                                    ; preds = %97
  %123 = icmp slt i32 %87, 2
  br i1 %123, label %134, label %124, !prof !73

; <label>:124:                                    ; preds = %86, %122
  %125 = trunc i32 %87 to i8
  store i8 %125, i8* %8, align 2, !tbaa !35
  %126 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %127 = load %union.StackValue*, %union.StackValue** %126, align 8, !tbaa !20
  call fastcc void @luaD_seterrorobj(%struct.lua_State* %0, i32 %87, %union.StackValue* %127) #16
  %128 = bitcast %union.StackValue** %126 to i64*
  %129 = load i64, i64* %128, align 8, !tbaa !20
  %130 = load %struct.CallInfo*, %struct.CallInfo** %81, align 8, !tbaa !24
  %131 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %130, i64 0, i32 1
  %132 = bitcast %union.StackValue** %131 to i64*
  store i64 %129, i64* %132, align 8, !tbaa !66
  %133 = load i32, i32* %6, align 4, !tbaa !77
  br label %134

; <label>:134:                                    ; preds = %101, %76, %122, %124
  %135 = phi i32 [ %87, %122 ], [ %133, %124 ], [ %78, %76 ], [ %120, %101 ]
  %136 = icmp eq i32 %135, 1
  br i1 %136, label %137, label %142

; <label>:137:                                    ; preds = %134
  %138 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %139 = load %struct.CallInfo*, %struct.CallInfo** %138, align 8, !tbaa !24
  %140 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %139, i64 0, i32 5, i32 0
  %141 = load i32, i32* %140, align 8, !tbaa !21
  br label %155

; <label>:142:                                    ; preds = %134
  %143 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %144 = bitcast %union.StackValue** %143 to i64*
  %145 = load i64, i64* %144, align 8, !tbaa !20
  %146 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %147 = load %struct.CallInfo*, %struct.CallInfo** %146, align 8, !tbaa !24
  %148 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %147, i64 0, i32 0
  %149 = load %union.StackValue*, %union.StackValue** %148, align 8, !tbaa !64
  %150 = getelementptr inbounds %union.StackValue, %union.StackValue* %149, i64 1
  %151 = ptrtoint %union.StackValue* %150 to i64
  %152 = sub i64 %145, %151
  %153 = lshr exact i64 %152, 4
  %154 = trunc i64 %153 to i32
  br label %155

; <label>:155:                                    ; preds = %142, %137
  %156 = phi i32 [ %141, %137 ], [ %154, %142 ]
  store i32 %156, i32* %3, align 4, !tbaa !77
  br label %157

; <label>:157:                                    ; preds = %155, %62, %29, %15
  %158 = phi i32 [ 2, %15 ], [ 2, %62 ], [ %135, %155 ], [ 2, %29 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  ret i32 %158
}

; Function Attrs: nounwind optsize uwtable
define internal void @resume(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to i32*
  %4 = load i32, i32* %3, align 4, !tbaa !77
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %8 = load i8, i8* %7, align 2, !tbaa !35
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %17

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = sext i32 %4 to i64
  %14 = sub nsw i64 0, %13
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 %14
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %16, i32 -1) #16
  br label %34

; <label>:17:                                     ; preds = %2
  store i8 0, i8* %7, align 2, !tbaa !35
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %19 = load i16, i16* %18, align 2, !tbaa !63
  %20 = and i16 %19, 2
  %21 = icmp eq i16 %20, 0
  br i1 %21, label %22, label %23

; <label>:22:                                     ; preds = %17
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6) #16
  br label %33

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  %25 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %24, align 8, !tbaa !21
  %26 = icmp eq i32 (%struct.lua_State*, i32, i64)* %25, null
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %23
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %25(%struct.lua_State* nonnull %0, i32 1, i64 %29) #17
  br label %31

; <label>:31:                                     ; preds = %23, %27
  %32 = phi i32 [ %30, %27 ], [ %4, %23 ]
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %6, i32 %32) #16
  br label %33

; <label>:33:                                     ; preds = %31, %22
  tail call void @unroll(%struct.lua_State* nonnull %0, i8* null) #16
  br label %34

; <label>:34:                                     ; preds = %33, %10
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @unroll(%struct.lua_State*, i8* readonly) #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %7, label %4

; <label>:4:                                      ; preds = %2
  %5 = bitcast i8* %1 to i32*
  %6 = load i32, i32* %5, align 4, !tbaa !77
  tail call fastcc void @finishCcall(%struct.lua_State* %0, i32 %6) #16
  br label %7

; <label>:7:                                      ; preds = %2, %4
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !24
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %11 = icmp eq %struct.CallInfo* %9, %10
  br i1 %11, label %93, label %12

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %14

; <label>:14:                                     ; preds = %12, %90
  %15 = phi %struct.CallInfo* [ %9, %12 ], [ %91, %90 ]
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 7
  %17 = load i16, i16* %16, align 2, !tbaa !63
  %18 = and i16 %17, 2
  %19 = icmp eq i16 %18, 0
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %14
  tail call fastcc void @finishCcall(%struct.lua_State* nonnull %0, i32 1) #16
  br label %90

; <label>:21:                                     ; preds = %14
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 0
  %23 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !64
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  %25 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 4
  %26 = bitcast %union.anon.0* %25 to i32**
  %27 = load i32*, i32** %26, align 8, !tbaa !21
  %28 = getelementptr inbounds i32, i32* %27, i64 -1
  %29 = load i32, i32* %28, align 4, !tbaa !77
  %30 = trunc i32 %29 to i7
  switch i7 %30, label %89 [
    i7 19, label %31
    i7 20, label %31
    i7 21, label %31
    i7 24, label %31
    i7 25, label %31
    i7 22, label %31
    i7 23, label %31
    i7 38, label %31
    i7 39, label %31
    i7 40, label %31
    i7 43, label %31
    i7 44, label %31
    i7 33, label %31
    i7 34, label %31
    i7 35, label %31
    i7 45, label %31
    i7 46, label %31
    i7 47, label %31
    i7 36, label %31
    i7 48, label %31
    i7 49, label %31
    i7 41, label %31
    i7 42, label %31
    i7 50, label %31
    i7 51, label %31
    i7 53, label %31
    i7 9, label %31
    i7 10, label %31
    i7 11, label %31
    i7 12, label %31
    i7 18, label %31
    i7 59, label %44
    i7 60, label %44
    i7 63, label %44
    i7 -64, label %44
    i7 -63, label %44
    i7 -62, label %44
    i7 58, label %44
    i7 54, label %67
  ]

; <label>:31:                                     ; preds = %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21, %21
  %32 = lshr i32 %29, 7
  %33 = and i32 %32, 255
  %34 = zext i32 %33 to i64
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %34
  %36 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1
  store %union.StackValue* %37, %union.StackValue** %13, align 8, !tbaa !20
  %38 = bitcast %union.StackValue* %37 to i64*
  %39 = bitcast %union.StackValue* %35 to i64*
  %40 = load i64, i64* %38, align 8
  store i64 %40, i64* %39, align 8
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1, i32 0, i32 1
  %42 = load i8, i8* %41, align 8, !tbaa !22
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 0, i32 0, i32 1
  store i8 %42, i8* %43, align 8, !tbaa !22
  br label %89

; <label>:44:                                     ; preds = %21, %21, %21, %21, %21, %21, %21
  %45 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 -1, i32 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !21
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %58, label %50

; <label>:50:                                     ; preds = %44
  %51 = icmp eq i8 %47, 1
  br i1 %51, label %52, label %58

; <label>:52:                                     ; preds = %50
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 -1, i32 0, i32 0
  %54 = bitcast %union.Value* %53 to i32*
  %55 = load i32, i32* %54, align 8, !tbaa !21
  %56 = icmp ne i32 %55, 0
  %57 = zext i1 %56 to i32
  br label %58

; <label>:58:                                     ; preds = %52, %50, %44
  %59 = phi i32 [ 0, %44 ], [ 1, %50 ], [ %57, %52 ]
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 -1
  store %union.StackValue* %60, %union.StackValue** %13, align 8, !tbaa !20
  %61 = lshr i32 %29, 15
  %62 = and i32 %61, 1
  %63 = icmp eq i32 %59, %62
  br i1 %63, label %89, label %64

; <label>:64:                                     ; preds = %58
  %65 = load i32*, i32** %26, align 8, !tbaa !21
  %66 = getelementptr inbounds i32, i32* %65, i64 1
  store i32* %66, i32** %26, align 8, !tbaa !21
  br label %89

; <label>:67:                                     ; preds = %21
  %68 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %69 = lshr i32 %29, 7
  %70 = and i32 %69, 255
  %71 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -2
  %72 = zext i32 %70 to i64
  %73 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %72
  %74 = ptrtoint %union.StackValue* %71 to i64
  %75 = ptrtoint %union.StackValue* %73 to i64
  %76 = sub i64 %74, %75
  %77 = lshr exact i64 %76, 4
  %78 = trunc i64 %77 to i32
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -3, i32 0
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1, i32 0
  %81 = bitcast %struct.TValue* %80 to i64*
  %82 = bitcast %struct.TValue* %79 to i64*
  %83 = load i64, i64* %81, align 8
  store i64 %83, i64* %82, align 8
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1, i32 0, i32 1
  %85 = load i8, i8* %84, align 8, !tbaa !22
  %86 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -3, i32 0, i32 1
  store i8 %85, i8* %86, align 8, !tbaa !22
  %87 = icmp sgt i32 %78, 1
  br i1 %87, label %88, label %89

; <label>:88:                                     ; preds = %67
  store %union.StackValue* %71, %union.StackValue** %13, align 8, !tbaa !20
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %0, i32 %78) #17
  br label %89

; <label>:89:                                     ; preds = %21, %31, %58, %64, %67, %88
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %15) #16
  br label %90

; <label>:90:                                     ; preds = %89, %20
  %91 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !24
  %92 = icmp eq %struct.CallInfo* %91, %10
  br i1 %92, label %93, label %14

; <label>:93:                                     ; preds = %90, %7
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_isyieldable(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !29
  %4 = icmp ult i32 %3, 65536
  %5 = zext i1 %4 to i32
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_yieldk(%struct.lua_State*, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %8 = load i32, i32* %7, align 8, !tbaa !29
  %9 = icmp ugt i32 %8, 65535
  br i1 %9, label %10, label %18, !prof !61

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 38
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !38
  %15 = icmp eq %struct.lua_State* %14, %0
  br i1 %15, label %17, label %16

; <label>:16:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.3, i64 0, i64 0)) #18
  unreachable

; <label>:17:                                     ; preds = %10
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.4, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 1, i8* %19, align 2, !tbaa !35
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %21 = load i16, i16* %20, align 2, !tbaa !63
  %22 = and i16 %21, 2
  %23 = icmp eq i16 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 0, i32* %25, align 8, !tbaa !21
  ret i32 0

; <label>:26:                                     ; preds = %18
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %3, i32 (%struct.lua_State*, i32, i64)** %27, align 8, !tbaa !21
  %28 = icmp eq i32 (%struct.lua_State*, i32, i64)* %3, null
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %26
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4, i32 0, i32 2
  store i64 %2, i64* %30, align 8, !tbaa !21
  br label %31

; <label>:31:                                     ; preds = %26, %29
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 5, i32 0
  store i32 %1, i32* %32, align 8, !tbaa !21
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal void @luaG_runerror(%struct.lua_State*, i8*, ...) unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %13

; <label>:13:                                     ; preds = %12, %2
  %14 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %6)
  %15 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* nonnull %0, i8* %1, %struct.__va_list_tag* nonnull %14) #16
  call void @llvm.va_end(i8* nonnull %6)
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 7
  %17 = load i16, i16* %16, align 2, !tbaa !63
  %18 = and i16 %17, 2
  %19 = icmp eq i16 %18, 0
  br i1 %19, label %20, label %40

; <label>:20:                                     ; preds = %13
  %21 = bitcast %struct.CallInfo* %5 to %struct.LClosure***
  %22 = load %struct.LClosure**, %struct.LClosure*** %21, align 8, !tbaa !64
  %23 = load %struct.LClosure*, %struct.LClosure** %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %23, i64 0, i32 5
  %25 = load %struct.Proto*, %struct.Proto** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %25, i64 0, i32 22
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !122
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 4
  %29 = bitcast %union.anon.0* %28 to i64*
  %30 = load i64, i64* %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.Proto, %struct.Proto* %25, i64 0, i32 16
  %32 = bitcast i32** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !116
  %34 = sub i64 %30, %33
  %35 = lshr exact i64 %34, 2
  %36 = trunc i64 %35 to i32
  %37 = add nsw i32 %36, -1
  %38 = call fastcc i32 @luaG_getfuncline(%struct.Proto* %25, i32 %37) #17
  %39 = call fastcc i8* @luaG_addinfo(%struct.lua_State* nonnull %0, i8* nonnull %15, %struct.TString* %27, i32 %38) #16
  br label %40

; <label>:40:                                     ; preds = %13, %20
  call fastcc void @luaG_errormsg(%struct.lua_State* nonnull %0) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaD_throw(%struct.lua_State*, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 15
  %4 = load %struct.lua_longjmp*, %struct.lua_longjmp** %3, align 8, !tbaa !28
  %5 = icmp eq %struct.lua_longjmp* %4, null
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 2
  store volatile i32 %1, i32* %7, align 8, !tbaa !83
  %8 = getelementptr inbounds %struct.lua_longjmp, %struct.lua_longjmp* %4, i64 0, i32 1, i64 0
  tail call void @longjmp(%struct.__jmp_buf_tag* nonnull %8, i32 1) #19
  unreachable

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !23
  %14 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %13, i32 %1) #16
  %15 = trunc i32 %14 to i8
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  store i8 %15, i8* %16, align 2, !tbaa !35
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 38
  %18 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !38
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 15
  %20 = load %struct.lua_longjmp*, %struct.lua_longjmp** %19, align 8, !tbaa !28
  %21 = icmp eq %struct.lua_longjmp* %20, null
  br i1 %21, label %36, label %22

; <label>:22:                                     ; preds = %9
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %18, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %23, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0
  %29 = bitcast %struct.TValue* %28 to i64*
  %30 = bitcast %union.StackValue* %24 to i64*
  %31 = load i64, i64* %29, align 8
  store i64 %31, i64* %30, align 8
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 0, i32 0, i32 1
  store i8 %33, i8* %34, align 8, !tbaa !22
  %35 = load %struct.lua_State*, %struct.lua_State** %17, align 8, !tbaa !38
  tail call fastcc void @luaD_throw(%struct.lua_State* %35, i32 %14) #18
  unreachable

; <label>:36:                                     ; preds = %9
  %37 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 37
  %38 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !80
  %39 = icmp eq i32 (%struct.lua_State*)* %38, null
  br i1 %39, label %53, label %40

; <label>:40:                                     ; preds = %36
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %42 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %14, %union.StackValue* %42) #16
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %44 = load %struct.CallInfo*, %struct.CallInfo** %43, align 8, !tbaa !24
  %45 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %44, i64 0, i32 1
  %46 = load %union.StackValue*, %union.StackValue** %45, align 8, !tbaa !66
  %47 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %48 = icmp ult %union.StackValue* %46, %47
  br i1 %48, label %49, label %50

; <label>:49:                                     ; preds = %40
  store %union.StackValue* %47, %union.StackValue** %45, align 8, !tbaa !66
  br label %50

; <label>:50:                                     ; preds = %49, %40
  %51 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %37, align 8, !tbaa !80
  %52 = tail call i32 %51(%struct.lua_State* nonnull %0) #17
  br label %53

; <label>:53:                                     ; preds = %36, %50
  tail call void @abort() #19
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_checkstack(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !62
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = sub i64 %7, %10
  %12 = ashr exact i64 %11, 4
  %13 = sext i32 %1 to i64
  %14 = icmp sgt i64 %12, %13
  %15 = inttoptr i64 %10 to %union.StackValue*
  br i1 %14, label %31, label %16

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !23
  %20 = sub i64 %10, %19
  %21 = lshr exact i64 %20, 4
  %22 = trunc i64 %21 to i32
  %23 = add nsw i32 %22, 5
  %24 = sub nsw i32 1000000, %1
  %25 = icmp sgt i32 %23, %24
  br i1 %25, label %39, label %26

; <label>:26:                                     ; preds = %16
  %27 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %1, i32 0) #16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %39, label %29

; <label>:29:                                     ; preds = %26
  %30 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  br label %31

; <label>:31:                                     ; preds = %29, %2
  %32 = phi %union.StackValue* [ %30, %29 ], [ %15, %2 ]
  %33 = phi i32 [ %27, %29 ], [ 1, %2 ]
  %34 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %35 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !66
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 %13
  %37 = icmp ult %union.StackValue* %35, %36
  br i1 %37, label %38, label %39

; <label>:38:                                     ; preds = %31
  store %union.StackValue* %36, %union.StackValue** %34, align 8, !tbaa !66
  br label %39

; <label>:39:                                     ; preds = %16, %26, %38, %31
  %40 = phi i32 [ 0, %26 ], [ %33, %38 ], [ %33, %31 ], [ 0, %16 ]
  ret i32 %40
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaD_growstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !26
  %6 = icmp sgt i32 %5, 1000000
  br i1 %6, label %7, label %10, !prof !61

; <label>:7:                                      ; preds = %3
  %8 = icmp eq i32 %2, 0
  br i1 %8, label %34, label %9

; <label>:9:                                      ; preds = %7
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #18
  unreachable

; <label>:10:                                     ; preds = %3
  %11 = shl nsw i32 %5, 1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %16 = bitcast %union.StackValue** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !23
  %18 = sub i64 %14, %17
  %19 = lshr exact i64 %18, 4
  %20 = trunc i64 %19 to i32
  %21 = add i32 %1, 5
  %22 = add i32 %21, %20
  %23 = icmp sgt i32 %5, 500000
  %24 = select i1 %23, i32 1000000, i32 %11
  %25 = icmp slt i32 %24, %22
  %26 = select i1 %25, i32 %22, i32 %24
  %27 = icmp sgt i32 %26, 1000000
  br i1 %27, label %28, label %32, !prof !61

; <label>:28:                                     ; preds = %10
  %29 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 1000200, i32 %2) #16
  %30 = icmp eq i32 %2, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #18
  unreachable

; <label>:32:                                     ; preds = %10
  %33 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %26, i32 %2) #16
  br label %34

; <label>:34:                                     ; preds = %28, %7, %32
  %35 = phi i32 [ %33, %32 ], [ 0, %7 ], [ 0, %28 ]
  ret i32 %35
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_xmove(%struct.lua_State*, %struct.lua_State*, i32) local_unnamed_addr #2 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %43, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = sext i32 %2 to i64
  %9 = sub nsw i64 0, %8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %9
  store %union.StackValue* %10, %union.StackValue** %6, align 8, !tbaa !20
  %11 = icmp sgt i32 %2, 0
  br i1 %11, label %12, label %43

; <label>:12:                                     ; preds = %5
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = zext i32 %2 to i64
  %17 = bitcast %union.StackValue* %10 to i64*
  %18 = bitcast %struct.TValue* %15 to i64*
  %19 = load i64, i64* %17, align 8
  store i64 %19, i64* %18, align 8
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %9, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %21, i8* %22, align 8, !tbaa !22
  %23 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %13, align 8, !tbaa !20
  %25 = icmp eq i32 %2, 1
  br i1 %25, label %43, label %26

; <label>:26:                                     ; preds = %12
  br label %27

; <label>:27:                                     ; preds = %26, %27
  %28 = phi i64 [ %41, %27 ], [ 1, %26 ]
  %29 = phi %union.StackValue* [ %39, %27 ], [ %23, %26 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1, i32 0
  %31 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 %28, i32 0
  %33 = bitcast %struct.TValue* %32 to i64*
  %34 = bitcast %struct.TValue* %30 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 %28, i32 0, i32 1
  %37 = load i8, i8* %36, align 8, !tbaa !22
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1, i32 0, i32 1
  store i8 %37, i8* %38, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 1
  store %union.StackValue* %40, %union.StackValue** %13, align 8, !tbaa !20
  %41 = add nuw nsw i64 %28, 1
  %42 = icmp eq i64 %41, %16
  br i1 %42, label %43, label %27

; <label>:43:                                     ; preds = %27, %12, %5, %3
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 (%struct.lua_State*)* @lua_atpanic(%struct.lua_State* nocapture readonly, i32 (%struct.lua_State*)*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 37
  %6 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %5, align 8, !tbaa !80
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %5, align 8, !tbaa !80
  ret i32 (%struct.lua_State*)* %6
}

; Function Attrs: norecurse nounwind optsize readnone uwtable
define double @lua_version(%struct.lua_State* nocapture readnone) local_unnamed_addr #6 {
  ret double 5.040000e+02
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_absindex(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = add i32 %1, 1000999
  %4 = icmp ugt i32 %3, 1000999
  br i1 %4, label %17, label %5

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = bitcast %struct.CallInfo** %9 to i64**
  %11 = load i64*, i64** %10, align 8, !tbaa !24
  %12 = load i64, i64* %11, align 8, !tbaa !64
  %13 = sub i64 %8, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, %1
  br label %17

; <label>:17:                                     ; preds = %2, %5
  %18 = phi i32 [ %16, %5 ], [ %1, %2 ]
  ret i32 %18
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_gettop(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define void @lua_settop(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, -1
  br i1 %3, label %4, label %23

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = sext i32 %1 to i64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 %10
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = icmp ult %union.StackValue* %13, %11
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %4
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi %union.StackValue* [ %20, %16 ], [ %13, %15 ]
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %12, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 0, i32 0, i32 1
  store i8 0, i8* %19, align 8, !tbaa !21
  %20 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %21 = icmp ult %union.StackValue* %20, %11
  br i1 %21, label %16, label %22

; <label>:22:                                     ; preds = %16, %4
  store %union.StackValue* %11, %union.StackValue** %12, align 8, !tbaa !20
  br label %29

; <label>:23:                                     ; preds = %2
  %24 = add nsw i32 %1, 1
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %26 = load %union.StackValue*, %union.StackValue** %25, align 8, !tbaa !20
  %27 = sext i32 %24 to i64
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 %27
  store %union.StackValue* %28, %union.StackValue** %25, align 8, !tbaa !20
  br label %29

; <label>:29:                                     ; preds = %23, %22
  %30 = phi %union.StackValue* [ %28, %23 ], [ %11, %22 ]
  %31 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %30, i32 0) #16
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_rotate(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  %7 = icmp sgt i32 %1, 0
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !24
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %10, i64 0, i32 0
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !64
  br label %13

; <label>:13:                                     ; preds = %3, %8
  %14 = phi %union.StackValue* [ %12, %8 ], [ %5, %3 ]
  %15 = sext i32 %1 to i64
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %15
  %17 = icmp sgt i32 %2, -1
  %18 = sext i32 %2 to i64
  %19 = sub nsw i64 0, %18
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 %19
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 %19
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1
  %23 = select i1 %17, %union.StackValue* %20, %union.StackValue* %22
  %24 = icmp ult %union.StackValue* %16, %23
  br i1 %24, label %25, label %40

; <label>:25:                                     ; preds = %13
  br label %26

; <label>:26:                                     ; preds = %25, %26
  %27 = phi %union.StackValue* [ %37, %26 ], [ %16, %25 ]
  %28 = phi %union.StackValue* [ %38, %26 ], [ %23, %25 ]
  %29 = bitcast %union.StackValue* %27 to i64*
  %30 = load i64, i64* %29, align 8
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 0, i32 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = bitcast %union.StackValue* %28 to i64*
  %34 = load i64, i64* %33, align 8
  store i64 %34, i64* %29, align 8
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 0, i32 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  store i8 %36, i8* %31, align 8, !tbaa !22
  store i64 %30, i64* %33, align 8
  store i8 %32, i8* %35, align 8, !tbaa !22
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 -1
  %39 = icmp ult %union.StackValue* %37, %38
  br i1 %39, label %26, label %40

; <label>:40:                                     ; preds = %26, %13
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  %42 = icmp ult %union.StackValue* %41, %6
  br i1 %42, label %43, label %58

; <label>:43:                                     ; preds = %40
  br label %44

; <label>:44:                                     ; preds = %43, %44
  %45 = phi %union.StackValue* [ %55, %44 ], [ %41, %43 ]
  %46 = phi %union.StackValue* [ %56, %44 ], [ %6, %43 ]
  %47 = bitcast %union.StackValue* %45 to i64*
  %48 = load i64, i64* %47, align 8
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 0, i32 0, i32 1
  %50 = load i8, i8* %49, align 8, !tbaa !22
  %51 = bitcast %union.StackValue* %46 to i64*
  %52 = load i64, i64* %51, align 8
  store i64 %52, i64* %47, align 8
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 0, i32 0, i32 1
  %54 = load i8, i8* %53, align 8, !tbaa !22
  store i8 %54, i8* %49, align 8, !tbaa !22
  store i64 %48, i64* %51, align 8
  store i8 %50, i8* %53, align 8, !tbaa !22
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 1
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 -1
  %57 = icmp ult %union.StackValue* %55, %56
  br i1 %57, label %44, label %58

; <label>:58:                                     ; preds = %44, %40
  %59 = icmp ult %union.StackValue* %16, %6
  br i1 %59, label %60, label %75

; <label>:60:                                     ; preds = %58
  br label %61

; <label>:61:                                     ; preds = %60, %61
  %62 = phi %union.StackValue* [ %72, %61 ], [ %16, %60 ]
  %63 = phi %union.StackValue* [ %73, %61 ], [ %6, %60 ]
  %64 = bitcast %union.StackValue* %62 to i64*
  %65 = load i64, i64* %64, align 8
  %66 = getelementptr inbounds %union.StackValue, %union.StackValue* %62, i64 0, i32 0, i32 1
  %67 = load i8, i8* %66, align 8, !tbaa !22
  %68 = bitcast %union.StackValue* %63 to i64*
  %69 = load i64, i64* %68, align 8
  store i64 %69, i64* %64, align 8
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %63, i64 0, i32 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  store i8 %71, i8* %66, align 8, !tbaa !22
  store i64 %65, i64* %68, align 8
  store i8 %67, i8* %70, align 8, !tbaa !22
  %72 = getelementptr inbounds %union.StackValue, %union.StackValue* %62, i64 1
  %73 = getelementptr inbounds %union.StackValue, %union.StackValue* %63, i64 -1
  %74 = icmp ult %union.StackValue* %72, %73
  br i1 %74, label %61, label %75

; <label>:75:                                     ; preds = %61, %58
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_copy(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %6 = bitcast %struct.TValue* %4 to i64*
  %7 = bitcast %struct.TValue* %5 to i64*
  %8 = load i64, i64* %6, align 8
  store i64 %8, i64* %7, align 8
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %10, i8* %11, align 8, !tbaa !22
  %12 = icmp slt i32 %2, -1001000
  br i1 %12, label %13, label %36

; <label>:13:                                     ; preds = %3
  %14 = load i8, i8* %9, align 8, !tbaa !22
  %15 = and i8 %14, 64
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %36, label %17

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = bitcast %struct.CallInfo** %18 to %struct.CClosure****
  %20 = load %struct.CClosure***, %struct.CClosure**** %19, align 8, !tbaa !24
  %21 = load %struct.CClosure**, %struct.CClosure*** %20, align 8, !tbaa !64
  %22 = load %struct.CClosure*, %struct.CClosure** %21, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %22, i64 0, i32 2
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = and i8 %24, 32
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %36, label %27

; <label>:27:                                     ; preds = %17
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %29 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !70
  %32 = and i8 %31, 24
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %27
  %35 = bitcast %struct.CClosure* %22 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %35, %struct.GCObject* %29) #16
  br label %36

; <label>:36:                                     ; preds = %27, %17, %13, %34, %3
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @index2value(%struct.lua_State* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = icmp sgt i32 %1, 0
  br i1 %5, label %6, label %20

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %9
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = icmp ult %union.StackValue* %10, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  br label %59

; <label>:18:                                     ; preds = %6
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  br label %59

; <label>:20:                                     ; preds = %2
  %21 = icmp slt i32 %1, -1000999
  br i1 %21, label %27, label %22

; <label>:22:                                     ; preds = %20
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %25 = sext i32 %1 to i64
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 %25, i32 0
  br label %59

; <label>:27:                                     ; preds = %20
  %28 = icmp eq i32 %1, -1001000
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %27
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %31 = load %struct.global_State*, %struct.global_State** %30, align 8, !tbaa !2
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %31, i64 0, i32 7
  br label %59

; <label>:33:                                     ; preds = %27
  %34 = sub nsw i32 -1001000, %1
  %35 = bitcast %struct.CallInfo* %4 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !64
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !21
  %39 = icmp eq i8 %38, 38
  br i1 %39, label %40, label %44

; <label>:40:                                     ; preds = %33
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %42 = load %struct.global_State*, %struct.global_State** %41, align 8, !tbaa !2
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %42, i64 0, i32 8
  br label %59

; <label>:44:                                     ; preds = %33
  %45 = bitcast %struct.TValue* %36 to %struct.CClosure**
  %46 = load %struct.CClosure*, %struct.CClosure** %45, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 3
  %48 = load i8, i8* %47, align 2, !tbaa !138
  %49 = zext i8 %48 to i32
  %50 = icmp sgt i32 %34, %49
  br i1 %50, label %55, label %51

; <label>:51:                                     ; preds = %44
  %52 = add nsw i32 %34, -1
  %53 = sext i32 %52 to i64
  %54 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %46, i64 0, i32 6, i64 %53
  br label %59

; <label>:55:                                     ; preds = %44
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %57 = load %struct.global_State*, %struct.global_State** %56, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 8
  br label %59

; <label>:59:                                     ; preds = %51, %55, %14, %18, %40, %29, %22
  %60 = phi %struct.TValue* [ %32, %29 ], [ %43, %40 ], [ %26, %22 ], [ %17, %14 ], [ %19, %18 ], [ %54, %51 ], [ %58, %55 ]
  ret %struct.TValue* %60
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaC_barrier_(%struct.lua_State* nocapture readonly, %struct.GCObject* nocapture, %struct.GCObject*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %7 = load i8, i8* %6, align 1, !tbaa !42
  %8 = icmp ult i8 %7, 3
  br i1 %8, label %9, label %18

; <label>:9:                                      ; preds = %3
  tail call fastcc void @reallymarkobject(%struct.global_State* %5, %struct.GCObject* %2) #16
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !70
  %12 = and i8 %11, 6
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %30, label %14

; <label>:14:                                     ; preds = %9
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %2, i64 0, i32 2
  %16 = load i8, i8* %15, align 1, !tbaa !70
  %17 = and i8 %16, -8
  br label %25

; <label>:18:                                     ; preds = %3
  %19 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !70
  %21 = and i8 %20, -64
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %23 = load i8, i8* %22, align 4, !tbaa !15
  %24 = and i8 %23, 24
  br label %25

; <label>:25:                                     ; preds = %18, %14
  %26 = phi i8 [ 2, %14 ], [ %21, %18 ]
  %27 = phi i8 [ %17, %14 ], [ %24, %18 ]
  %28 = phi i8* [ %15, %14 ], [ %19, %18 ]
  %29 = or i8 %27, %26
  store i8 %29, i8* %28, align 1, !tbaa !70
  br label %30

; <label>:30:                                     ; preds = %25, %9
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushvalue(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_type(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 8
  %12 = icmp eq %struct.TValue* %3, %11
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %8, %2
  %14 = zext i8 %6 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %13
  %16 = phi i32 [ %14, %13 ], [ -1, %8 ]
  ret i32 %16
}

; Function Attrs: norecurse nounwind optsize readnone uwtable
define i8* @lua_typename(%struct.lua_State* nocapture readnone, i32) local_unnamed_addr #6 {
  %3 = add nsw i32 %1, 1
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %4
  %6 = load i8*, i8** %5, align 8, !tbaa !54
  ret i8* %6
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_iscfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 38
  %7 = icmp eq i8 %5, 118
  %8 = or i1 %6, %7
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_isinteger(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 35
  %7 = zext i1 %6 to i32
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_isnumber(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #0 {
  %3 = alloca double, align 8
  %4 = bitcast double* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 19
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %5 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  %12 = bitcast double* %3 to i64*
  store i64 %11, i64* %12, align 8, !tbaa !140
  br label %15

; <label>:13:                                     ; preds = %2
  %14 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %5, double* nonnull %3) #16
  br label %15

; <label>:15:                                     ; preds = %13, %9
  %16 = phi i32 [ 1, %9 ], [ %14, %13 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaV_tonumber_(%struct.TValue* nocapture readonly, double* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 35
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %0 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !21
  %11 = sitofp i64 %10 to double
  store double %11, double* %1, align 8, !tbaa !140
  br label %45

; <label>:12:                                     ; preds = %2
  %13 = and i8 %6, 15
  %14 = icmp eq i8 %13, 4
  br i1 %14, label %15, label %45

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %0 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds i8, i8* %17, i64 24
  %19 = call fastcc i64 @luaO_str2num(i8* nonnull %18, %struct.TValue* nonnull %3) #16
  %20 = bitcast %struct.TValue* %0 to %struct.TString**
  %21 = load %struct.TString*, %struct.TString** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !21
  %24 = icmp eq i8 %23, 20
  br i1 %24, label %25, label %29

; <label>:25:                                     ; preds = %15
  %26 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 4
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = zext i8 %27 to i64
  br label %32

; <label>:29:                                     ; preds = %15
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %21, i64 0, i32 6, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %29, %25
  %33 = phi i64 [ %28, %25 ], [ %31, %29 ]
  %34 = add i64 %33, 1
  %35 = icmp eq i64 %19, %34
  br i1 %35, label %36, label %45

; <label>:36:                                     ; preds = %32
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 35
  %40 = bitcast %struct.TValue* %3 to i64*
  %41 = load i64, i64* %40, align 8
  %42 = sitofp i64 %41 to double
  %43 = bitcast i64 %41 to double
  %44 = select i1 %39, double %42, double %43
  store double %44, double* %1, align 8, !tbaa !140
  br label %45

; <label>:45:                                     ; preds = %12, %32, %36, %8
  %46 = phi i32 [ 1, %8 ], [ 1, %36 ], [ 0, %32 ], [ 0, %12 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %46
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_isstring(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = zext i1 %8 to i32
  ret i32 %9
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_isuserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 7
  %8 = icmp eq i8 %5, 2
  %9 = or i1 %8, %7
  %10 = zext i1 %9 to i32
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_rawequal(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  %14 = icmp eq %struct.TValue* %4, %13
  br i1 %14, label %27, label %15

; <label>:15:                                     ; preds = %10, %3
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %25

; <label>:20:                                     ; preds = %15
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 8
  %24 = icmp eq %struct.TValue* %5, %23
  br i1 %24, label %27, label %25

; <label>:25:                                     ; preds = %20, %15
  %26 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %4, %struct.TValue* nonnull %5) #16
  br label %27

; <label>:27:                                     ; preds = %10, %20, %25
  %28 = phi i32 [ %26, %25 ], [ 0, %20 ], [ 0, %10 ]
  ret i32 %28
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaV_equalobj(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = xor i8 %7, %5
  %9 = and i8 %8, 63
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %51, label %11

; <label>:11:                                     ; preds = %3
  %12 = and i8 %5, 15
  %13 = and i8 %7, 15
  %14 = icmp eq i8 %12, %13
  %15 = icmp eq i8 %12, 3
  %16 = and i1 %15, %14
  br i1 %16, label %17, label %241

; <label>:17:                                     ; preds = %11
  switch i8 %5, label %241 [
    i8 35, label %18
    i8 19, label %21
  ]

; <label>:18:                                     ; preds = %17
  %19 = bitcast %struct.TValue* %1 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !21
  br label %32

; <label>:21:                                     ; preds = %17
  %22 = bitcast %struct.TValue* %1 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = tail call double @llvm.floor.f64(double %23) #7
  %25 = fcmp une double %24, %23
  br i1 %25, label %241, label %26

; <label>:26:                                     ; preds = %21
  %27 = fcmp oge double %24, 0xC3E0000000000000
  %28 = fcmp olt double %24, 0x43E0000000000000
  %29 = and i1 %27, %28
  br i1 %29, label %30, label %241

; <label>:30:                                     ; preds = %26
  %31 = fptosi double %24 to i64
  br label %32

; <label>:32:                                     ; preds = %30, %18
  %33 = phi i64 [ %20, %18 ], [ %31, %30 ]
  switch i8 %7, label %241 [
    i8 35, label %34
    i8 19, label %37
  ]

; <label>:34:                                     ; preds = %32
  %35 = bitcast %struct.TValue* %2 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !21
  br label %48

; <label>:37:                                     ; preds = %32
  %38 = bitcast %struct.TValue* %2 to double*
  %39 = load double, double* %38, align 8, !tbaa !21
  %40 = tail call double @llvm.floor.f64(double %39) #7
  %41 = fcmp une double %40, %39
  br i1 %41, label %241, label %42

; <label>:42:                                     ; preds = %37
  %43 = fcmp oge double %40, 0xC3E0000000000000
  %44 = fcmp olt double %40, 0x43E0000000000000
  %45 = and i1 %43, %44
  br i1 %45, label %46, label %241

; <label>:46:                                     ; preds = %42
  %47 = fptosi double %40 to i64
  br label %48

; <label>:48:                                     ; preds = %46, %34
  %49 = phi i64 [ %36, %34 ], [ %47, %46 ]
  %50 = icmp eq i64 %33, %49
  br label %241

; <label>:51:                                     ; preds = %3
  %52 = trunc i8 %5 to i6
  switch i6 %52, label %216 [
    i6 0, label %241
    i6 -29, label %53
    i6 19, label %59
    i6 1, label %65
    i6 2, label %71
    i6 -26, label %77
    i6 20, label %83
    i6 -28, label %89
    i6 7, label %108
    i6 5, label %162
  ]

; <label>:53:                                     ; preds = %51
  %54 = bitcast %struct.TValue* %1 to i64*
  %55 = load i64, i64* %54, align 8, !tbaa !21
  %56 = bitcast %struct.TValue* %2 to i64*
  %57 = load i64, i64* %56, align 8, !tbaa !21
  %58 = icmp eq i64 %55, %57
  br label %241

; <label>:59:                                     ; preds = %51
  %60 = bitcast %struct.TValue* %1 to double*
  %61 = load double, double* %60, align 8, !tbaa !21
  %62 = bitcast %struct.TValue* %2 to double*
  %63 = load double, double* %62, align 8, !tbaa !21
  %64 = fcmp oeq double %61, %63
  br label %241

; <label>:65:                                     ; preds = %51
  %66 = bitcast %struct.TValue* %1 to i32*
  %67 = load i32, i32* %66, align 8, !tbaa !21
  %68 = bitcast %struct.TValue* %2 to i32*
  %69 = load i32, i32* %68, align 8, !tbaa !21
  %70 = icmp eq i32 %67, %69
  br label %241

; <label>:71:                                     ; preds = %51
  %72 = bitcast %struct.TValue* %1 to i8**
  %73 = load i8*, i8** %72, align 8, !tbaa !21
  %74 = bitcast %struct.TValue* %2 to i8**
  %75 = load i8*, i8** %74, align 8, !tbaa !21
  %76 = icmp eq i8* %73, %75
  br label %241

; <label>:77:                                     ; preds = %51
  %78 = bitcast %struct.TValue* %1 to i32 (%struct.lua_State*)**
  %79 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %78, align 8, !tbaa !21
  %80 = bitcast %struct.TValue* %2 to i32 (%struct.lua_State*)**
  %81 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %80, align 8, !tbaa !21
  %82 = icmp eq i32 (%struct.lua_State*)* %79, %81
  br label %241

; <label>:83:                                     ; preds = %51
  %84 = bitcast %struct.TValue* %1 to %struct.TString**
  %85 = load %struct.TString*, %struct.TString** %84, align 8, !tbaa !21
  %86 = bitcast %struct.TValue* %2 to %struct.TString**
  %87 = load %struct.TString*, %struct.TString** %86, align 8, !tbaa !21
  %88 = icmp eq %struct.TString* %85, %87
  br label %241

; <label>:89:                                     ; preds = %51
  %90 = bitcast %struct.TValue* %1 to %struct.TString**
  %91 = load %struct.TString*, %struct.TString** %90, align 8, !tbaa !21
  %92 = bitcast %struct.TValue* %2 to %struct.TString**
  %93 = load %struct.TString*, %struct.TString** %92, align 8, !tbaa !21
  %94 = getelementptr inbounds %struct.TString, %struct.TString* %91, i64 0, i32 6, i32 0
  %95 = load i64, i64* %94, align 8, !tbaa !21
  %96 = icmp eq %struct.TString* %91, %93
  br i1 %96, label %241, label %97

; <label>:97:                                     ; preds = %89
  %98 = getelementptr inbounds %struct.TString, %struct.TString* %93, i64 0, i32 6, i32 0
  %99 = load i64, i64* %98, align 8, !tbaa !21
  %100 = icmp eq i64 %95, %99
  br i1 %100, label %101, label %241

; <label>:101:                                    ; preds = %97
  %102 = getelementptr inbounds %struct.TString, %struct.TString* %91, i64 1
  %103 = bitcast %struct.TString* %102 to i8*
  %104 = getelementptr inbounds %struct.TString, %struct.TString* %93, i64 1
  %105 = bitcast %struct.TString* %104 to i8*
  %106 = tail call i32 @memcmp(i8* nonnull %103, i8* nonnull %105, i64 %95) #21
  %107 = icmp eq i32 %106, 0
  br label %241

; <label>:108:                                    ; preds = %51
  %109 = bitcast %struct.TValue* %1 to %struct.Udata**
  %110 = load %struct.Udata*, %struct.Udata** %109, align 8, !tbaa !21
  %111 = bitcast %struct.TValue* %2 to %struct.Udata**
  %112 = load %struct.Udata*, %struct.Udata** %111, align 8, !tbaa !21
  %113 = icmp eq %struct.Udata* %110, %112
  br i1 %113, label %241, label %114

; <label>:114:                                    ; preds = %108
  %115 = icmp eq %struct.lua_State* %0, null
  br i1 %115, label %241, label %116

; <label>:116:                                    ; preds = %114
  %117 = getelementptr inbounds %struct.Udata, %struct.Udata* %110, i64 0, i32 5
  %118 = load %struct.Table*, %struct.Table** %117, align 8, !tbaa !21
  %119 = icmp eq %struct.Table* %118, null
  br i1 %119, label %140, label %120

; <label>:120:                                    ; preds = %116
  %121 = getelementptr inbounds %struct.Table, %struct.Table* %118, i64 0, i32 3
  %122 = load i8, i8* %121, align 2, !tbaa !90
  %123 = and i8 %122, 32
  %124 = icmp eq i8 %123, 0
  br i1 %124, label %125, label %140

; <label>:125:                                    ; preds = %120
  %126 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %127 = load %struct.global_State*, %struct.global_State** %126, align 8, !tbaa !2
  %128 = getelementptr inbounds %struct.global_State, %struct.global_State* %127, i64 0, i32 40, i64 5
  %129 = load %struct.TString*, %struct.TString** %128, align 8, !tbaa !54
  %130 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %118, %struct.TString* %129) #17
  %131 = getelementptr inbounds %struct.TValue, %struct.TValue* %130, i64 0, i32 1
  %132 = load i8, i8* %131, align 8, !tbaa !22
  %133 = and i8 %132, 15
  %134 = icmp eq i8 %133, 0
  br i1 %134, label %135, label %138

; <label>:135:                                    ; preds = %125
  %136 = or i8 %122, 32
  store i8 %136, i8* %121, align 2, !tbaa !90
  %137 = load %struct.Udata*, %struct.Udata** %111, align 8, !tbaa !21
  br label %140

; <label>:138:                                    ; preds = %125
  %139 = icmp eq %struct.TValue* %130, null
  br i1 %139, label %140, label %225

; <label>:140:                                    ; preds = %135, %120, %116, %138
  %141 = phi %struct.Udata* [ %137, %135 ], [ %112, %120 ], [ %112, %116 ], [ %112, %138 ]
  %142 = getelementptr inbounds %struct.Udata, %struct.Udata* %141, i64 0, i32 5
  %143 = load %struct.Table*, %struct.Table** %142, align 8, !tbaa !21
  %144 = icmp eq %struct.Table* %143, null
  br i1 %144, label %241, label %145

; <label>:145:                                    ; preds = %140
  %146 = getelementptr inbounds %struct.Table, %struct.Table* %143, i64 0, i32 3
  %147 = load i8, i8* %146, align 2, !tbaa !90
  %148 = and i8 %147, 32
  %149 = icmp eq i8 %148, 0
  br i1 %149, label %150, label %241

; <label>:150:                                    ; preds = %145
  %151 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %152 = load %struct.global_State*, %struct.global_State** %151, align 8, !tbaa !2
  %153 = getelementptr inbounds %struct.global_State, %struct.global_State* %152, i64 0, i32 40, i64 5
  %154 = load %struct.TString*, %struct.TString** %153, align 8, !tbaa !54
  %155 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %143, %struct.TString* %154) #17
  %156 = getelementptr inbounds %struct.TValue, %struct.TValue* %155, i64 0, i32 1
  %157 = load i8, i8* %156, align 8, !tbaa !22
  %158 = and i8 %157, 15
  %159 = icmp eq i8 %158, 0
  br i1 %159, label %160, label %222

; <label>:160:                                    ; preds = %150
  %161 = or i8 %147, 32
  store i8 %161, i8* %146, align 2, !tbaa !90
  br label %241

; <label>:162:                                    ; preds = %51
  %163 = bitcast %struct.TValue* %1 to %struct.Table**
  %164 = load %struct.Table*, %struct.Table** %163, align 8, !tbaa !21
  %165 = bitcast %struct.TValue* %2 to %struct.Table**
  %166 = load %struct.Table*, %struct.Table** %165, align 8, !tbaa !21
  %167 = icmp eq %struct.Table* %164, %166
  br i1 %167, label %241, label %168

; <label>:168:                                    ; preds = %162
  %169 = icmp eq %struct.lua_State* %0, null
  br i1 %169, label %241, label %170

; <label>:170:                                    ; preds = %168
  %171 = getelementptr inbounds %struct.Table, %struct.Table* %164, i64 0, i32 9
  %172 = load %struct.Table*, %struct.Table** %171, align 8, !tbaa !21
  %173 = icmp eq %struct.Table* %172, null
  br i1 %173, label %194, label %174

; <label>:174:                                    ; preds = %170
  %175 = getelementptr inbounds %struct.Table, %struct.Table* %172, i64 0, i32 3
  %176 = load i8, i8* %175, align 2, !tbaa !90
  %177 = and i8 %176, 32
  %178 = icmp eq i8 %177, 0
  br i1 %178, label %179, label %194

; <label>:179:                                    ; preds = %174
  %180 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %181 = load %struct.global_State*, %struct.global_State** %180, align 8, !tbaa !2
  %182 = getelementptr inbounds %struct.global_State, %struct.global_State* %181, i64 0, i32 40, i64 5
  %183 = load %struct.TString*, %struct.TString** %182, align 8, !tbaa !54
  %184 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %172, %struct.TString* %183) #17
  %185 = getelementptr inbounds %struct.TValue, %struct.TValue* %184, i64 0, i32 1
  %186 = load i8, i8* %185, align 8, !tbaa !22
  %187 = and i8 %186, 15
  %188 = icmp eq i8 %187, 0
  br i1 %188, label %189, label %192

; <label>:189:                                    ; preds = %179
  %190 = or i8 %176, 32
  store i8 %190, i8* %175, align 2, !tbaa !90
  %191 = load %struct.Table*, %struct.Table** %165, align 8, !tbaa !21
  br label %194

; <label>:192:                                    ; preds = %179
  %193 = icmp eq %struct.TValue* %184, null
  br i1 %193, label %194, label %225

; <label>:194:                                    ; preds = %189, %174, %170, %192
  %195 = phi %struct.Table* [ %191, %189 ], [ %166, %174 ], [ %166, %170 ], [ %166, %192 ]
  %196 = getelementptr inbounds %struct.Table, %struct.Table* %195, i64 0, i32 9
  %197 = load %struct.Table*, %struct.Table** %196, align 8, !tbaa !21
  %198 = icmp eq %struct.Table* %197, null
  br i1 %198, label %241, label %199

; <label>:199:                                    ; preds = %194
  %200 = getelementptr inbounds %struct.Table, %struct.Table* %197, i64 0, i32 3
  %201 = load i8, i8* %200, align 2, !tbaa !90
  %202 = and i8 %201, 32
  %203 = icmp eq i8 %202, 0
  br i1 %203, label %204, label %241

; <label>:204:                                    ; preds = %199
  %205 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %206 = load %struct.global_State*, %struct.global_State** %205, align 8, !tbaa !2
  %207 = getelementptr inbounds %struct.global_State, %struct.global_State* %206, i64 0, i32 40, i64 5
  %208 = load %struct.TString*, %struct.TString** %207, align 8, !tbaa !54
  %209 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %197, %struct.TString* %208) #17
  %210 = getelementptr inbounds %struct.TValue, %struct.TValue* %209, i64 0, i32 1
  %211 = load i8, i8* %210, align 8, !tbaa !22
  %212 = and i8 %211, 15
  %213 = icmp eq i8 %212, 0
  br i1 %213, label %214, label %222

; <label>:214:                                    ; preds = %204
  %215 = or i8 %201, 32
  store i8 %215, i8* %200, align 2, !tbaa !90
  br label %241

; <label>:216:                                    ; preds = %51
  %217 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %218 = load %struct.GCObject*, %struct.GCObject** %217, align 8, !tbaa !21
  %219 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %220 = load %struct.GCObject*, %struct.GCObject** %219, align 8, !tbaa !21
  %221 = icmp eq %struct.GCObject* %218, %220
  br label %241

; <label>:222:                                    ; preds = %204, %150
  %223 = phi %struct.TValue* [ %155, %150 ], [ %209, %204 ]
  %224 = icmp eq %struct.TValue* %223, null
  br i1 %224, label %241, label %225

; <label>:225:                                    ; preds = %138, %192, %222
  %226 = phi %struct.TValue* [ %223, %222 ], [ %130, %138 ], [ %184, %192 ]
  %227 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %228 = load %union.StackValue*, %union.StackValue** %227, align 8, !tbaa !20
  tail call fastcc void @luaT_callTMres(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %226, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2, %union.StackValue* %228) #16
  %229 = bitcast %union.StackValue** %227 to %struct.TValue**
  %230 = load %struct.TValue*, %struct.TValue** %229, align 8, !tbaa !20
  %231 = getelementptr inbounds %struct.TValue, %struct.TValue* %230, i64 0, i32 1
  %232 = load i8, i8* %231, align 8, !tbaa !21
  %233 = and i8 %232, 15
  %234 = icmp eq i8 %233, 0
  br i1 %234, label %241, label %235

; <label>:235:                                    ; preds = %225
  %236 = icmp eq i8 %232, 1
  br i1 %236, label %237, label %241

; <label>:237:                                    ; preds = %235
  %238 = bitcast %struct.TValue* %230 to i32*
  %239 = load i32, i32* %238, align 8, !tbaa !21
  %240 = icmp ne i32 %239, 0
  br label %241

; <label>:241:                                    ; preds = %32, %17, %214, %160, %199, %194, %145, %140, %37, %42, %21, %26, %101, %97, %89, %48, %225, %237, %235, %222, %168, %162, %114, %108, %51, %11, %216, %83, %77, %71, %65, %59, %53
  %242 = phi i1 [ %221, %216 ], [ %88, %83 ], [ %82, %77 ], [ %76, %71 ], [ %70, %65 ], [ %64, %59 ], [ %58, %53 ], [ false, %11 ], [ true, %51 ], [ true, %108 ], [ false, %114 ], [ true, %162 ], [ false, %168 ], [ false, %222 ], [ false, %225 ], [ true, %235 ], [ %240, %237 ], [ %50, %48 ], [ true, %89 ], [ false, %97 ], [ %107, %101 ], [ false, %26 ], [ false, %21 ], [ false, %42 ], [ false, %37 ], [ false, %140 ], [ false, %145 ], [ false, %194 ], [ false, %199 ], [ false, %160 ], [ false, %214 ], [ false, %17 ], [ false, %32 ]
  %243 = zext i1 %242 to i32
  ret i32 %243
}

; Function Attrs: nounwind optsize uwtable
define void @lua_arith(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = or i32 %1, 1
  %4 = icmp eq i32 %3, 13
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  br i1 %4, label %7, label %17

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0
  %9 = bitcast %struct.TValue* %8 to i64*
  %10 = bitcast %union.StackValue* %6 to i64*
  %11 = load i64, i64* %9, align 8
  store i64 %11, i64* %10, align 8
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %5, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %2, %7
  %18 = phi %union.StackValue* [ %16, %7 ], [ %6, %2 ]
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -2
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 0, i32 0
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -1, i32 0
  %22 = tail call fastcc i32 @luaO_rawarith(%struct.lua_State* nonnull %0, i32 %1, %struct.TValue* nonnull %20, %struct.TValue* nonnull %21, %struct.TValue* nonnull %20) #17
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %17
  %25 = add nsw i32 %1, 6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %20, %struct.TValue* nonnull %21, %union.StackValue* nonnull %19, i32 %25) #17
  br label %26

; <label>:26:                                     ; preds = %17, %24
  %27 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  store %union.StackValue* %28, %union.StackValue** %5, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_compare(%struct.lua_State*, i32, i32, i32) local_unnamed_addr #0 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %16

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  %15 = icmp eq %struct.TValue* %5, %14
  br i1 %15, label %45, label %16

; <label>:16:                                     ; preds = %11, %4
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 8
  %25 = icmp eq %struct.TValue* %6, %24
  br i1 %25, label %45, label %26

; <label>:26:                                     ; preds = %21, %16
  switch i32 %3, label %45 [
    i32 0, label %27
    i32 1, label %29
    i32 2, label %37
  ]

; <label>:27:                                     ; preds = %26
  %28 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %6) #16
  br label %45

; <label>:29:                                     ; preds = %26
  %30 = icmp eq i8 %9, 3
  %31 = icmp eq i8 %19, 3
  %32 = and i1 %30, %31
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %29
  %34 = tail call fastcc i32 @LTnum(%struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:35:                                     ; preds = %29
  %36 = tail call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:37:                                     ; preds = %26
  %38 = icmp eq i8 %9, 3
  %39 = icmp eq i8 %19, 3
  %40 = and i1 %38, %39
  br i1 %40, label %41, label %43

; <label>:41:                                     ; preds = %37
  %42 = tail call fastcc i32 @LEnum(%struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:43:                                     ; preds = %37
  %44 = tail call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6) #17
  br label %45

; <label>:45:                                     ; preds = %43, %41, %35, %33, %11, %21, %27, %26
  %46 = phi i32 [ 0, %26 ], [ %28, %27 ], [ 0, %21 ], [ 0, %11 ], [ %34, %33 ], [ %36, %35 ], [ %42, %41 ], [ %44, %43 ]
  ret i32 %46
}

; Function Attrs: nounwind optsize uwtable
define i64 @lua_stringtonumber(%struct.lua_State* nocapture, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc i64 @luaO_str2num(i8* %1, %struct.TValue* %5) #16
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %2
  %9 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %3, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %2, %8
  ret i64 %6
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @luaO_str2num(i8*, %struct.TValue* nocapture) unnamed_addr #0 {
  %3 = alloca [201 x i8], align 16
  %4 = alloca double, align 8
  %5 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  br label %6

; <label>:6:                                      ; preds = %6, %2
  %7 = phi i8* [ %0, %2 ], [ %15, %6 ]
  %8 = load i8, i8* %7, align 1, !tbaa !21
  %9 = zext i8 %8 to i64
  %10 = add nuw nsw i64 %9, 1
  %11 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %10
  %12 = load i8, i8* %11, align 1, !tbaa !21
  %13 = and i8 %12, 8
  %14 = icmp eq i8 %13, 0
  %15 = getelementptr inbounds i8, i8* %7, i64 1
  br i1 %14, label %16, label %6

; <label>:16:                                     ; preds = %6
  switch i8 %8, label %19 [
    i8 45, label %17
    i8 43, label %18
  ]

; <label>:17:                                     ; preds = %16
  br label %19

; <label>:18:                                     ; preds = %16
  br label %19

; <label>:19:                                     ; preds = %18, %17, %16
  %20 = phi i8* [ %7, %16 ], [ %15, %18 ], [ %15, %17 ]
  %21 = phi i32 [ 0, %16 ], [ 0, %18 ], [ 1, %17 ]
  %22 = load i8, i8* %20, align 1, !tbaa !21
  %23 = icmp eq i8 %22, 48
  br i1 %23, label %24, label %58

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds i8, i8* %20, i64 1
  %26 = load i8, i8* %25, align 1, !tbaa !21
  switch i8 %26, label %58 [
    i8 120, label %27
    i8 88, label %27
  ]

; <label>:27:                                     ; preds = %24, %24
  %28 = getelementptr inbounds i8, i8* %20, i64 2
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = zext i8 %29 to i64
  %31 = add nuw nsw i64 %30, 1
  %32 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %31
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = and i8 %33, 16
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %88, label %36

; <label>:36:                                     ; preds = %27
  br label %37

; <label>:37:                                     ; preds = %36, %37
  %38 = phi i8 [ %51, %37 ], [ %29, %36 ]
  %39 = phi i64 [ %49, %37 ], [ 0, %36 ]
  %40 = phi i8* [ %50, %37 ], [ %28, %36 ]
  %41 = shl i64 %39, 4
  %42 = sext i8 %38 to i32
  %43 = add nsw i32 %42, -48
  %44 = icmp ult i32 %43, 10
  %45 = or i32 %42, 32
  %46 = add nsw i32 %45, -87
  %47 = select i1 %44, i32 %43, i32 %46
  %48 = sext i32 %47 to i64
  %49 = add i64 %41, %48
  %50 = getelementptr inbounds i8, i8* %40, i64 1
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = zext i8 %51 to i64
  %53 = add nuw nsw i64 %52, 1
  %54 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %53
  %55 = load i8, i8* %54, align 1, !tbaa !21
  %56 = and i8 %55, 16
  %57 = icmp eq i8 %56, 0
  br i1 %57, label %86, label %37

; <label>:58:                                     ; preds = %24, %19
  %59 = zext i8 %22 to i64
  %60 = add nsw i64 %59, -48
  %61 = icmp ult i64 %60, 10
  br i1 %61, label %62, label %88

; <label>:62:                                     ; preds = %58
  %63 = add nuw nsw i32 %21, 7
  br label %64

; <label>:64:                                     ; preds = %75, %62
  %65 = phi i8 [ %22, %62 ], [ %80, %75 ]
  %66 = phi i64 [ 0, %62 ], [ %78, %75 ]
  %67 = phi i8* [ %20, %62 ], [ %79, %75 ]
  %68 = sext i8 %65 to i32
  %69 = add nsw i32 %68, -48
  %70 = icmp ugt i64 %66, 922337203685477579
  br i1 %70, label %71, label %75

; <label>:71:                                     ; preds = %64
  %72 = icmp ne i64 %66, 922337203685477580
  %73 = icmp sgt i32 %69, %63
  %74 = or i1 %72, %73
  br i1 %74, label %122, label %75

; <label>:75:                                     ; preds = %71, %64
  %76 = mul i64 %66, 10
  %77 = sext i32 %69 to i64
  %78 = add i64 %76, %77
  %79 = getelementptr inbounds i8, i8* %67, i64 1
  %80 = load i8, i8* %79, align 1, !tbaa !21
  %81 = zext i8 %80 to i64
  %82 = add nsw i64 %81, -48
  %83 = icmp ult i64 %82, 10
  br i1 %83, label %64, label %84

; <label>:84:                                     ; preds = %75
  %85 = zext i8 %80 to i64
  br label %88

; <label>:86:                                     ; preds = %37
  %87 = zext i8 %51 to i64
  br label %88

; <label>:88:                                     ; preds = %86, %84, %58, %27
  %89 = phi i64 [ %59, %58 ], [ %30, %27 ], [ %85, %84 ], [ %87, %86 ]
  %90 = phi i8 [ %22, %58 ], [ %29, %27 ], [ %80, %84 ], [ %51, %86 ]
  %91 = phi i8* [ %20, %58 ], [ %28, %27 ], [ %79, %84 ], [ %50, %86 ]
  %92 = phi i32 [ 1, %58 ], [ 1, %27 ], [ 0, %84 ], [ 0, %86 ]
  %93 = phi i64 [ 0, %58 ], [ 0, %27 ], [ %78, %84 ], [ %49, %86 ]
  %94 = add nuw nsw i64 %89, 1
  %95 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %94
  %96 = load i8, i8* %95, align 1, !tbaa !21
  %97 = and i8 %96, 8
  %98 = icmp eq i8 %97, 0
  br i1 %98, label %110, label %99

; <label>:99:                                     ; preds = %88
  br label %100

; <label>:100:                                    ; preds = %99, %100
  %101 = phi i8* [ %102, %100 ], [ %91, %99 ]
  %102 = getelementptr inbounds i8, i8* %101, i64 1
  %103 = load i8, i8* %102, align 1, !tbaa !21
  %104 = zext i8 %103 to i64
  %105 = add nuw nsw i64 %104, 1
  %106 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %105
  %107 = load i8, i8* %106, align 1, !tbaa !21
  %108 = and i8 %107, 8
  %109 = icmp eq i8 %108, 0
  br i1 %109, label %110, label %100

; <label>:110:                                    ; preds = %100, %88
  %111 = phi i8 [ %90, %88 ], [ %103, %100 ]
  %112 = phi i8* [ %91, %88 ], [ %102, %100 ]
  %113 = icmp ne i32 %92, 0
  %114 = icmp ne i8 %111, 0
  %115 = or i1 %114, %113
  %116 = icmp eq i8* %112, null
  %117 = or i1 %115, %116
  br i1 %117, label %122, label %118

; <label>:118:                                    ; preds = %110
  %119 = icmp eq i32 %21, 0
  %120 = sub i64 0, %93
  %121 = select i1 %119, i64 %93, i64 %120
  br label %162

; <label>:122:                                    ; preds = %71, %110
  %123 = tail call i8* @strpbrk(i8* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.188, i64 0, i64 0)) #21
  %124 = icmp eq i8* %123, null
  br i1 %124, label %129, label %125

; <label>:125:                                    ; preds = %122
  %126 = load i8, i8* %123, align 1, !tbaa !21
  %127 = or i8 %126, 32
  %128 = icmp eq i8 %127, 110
  br i1 %128, label %172, label %129

; <label>:129:                                    ; preds = %125, %122
  %130 = call fastcc i8* @l_str2dloc(i8* %0, double* nonnull %4) #17
  %131 = icmp eq i8* %130, null
  br i1 %131, label %132, label %158

; <label>:132:                                    ; preds = %129
  %133 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 201, i8* nonnull %133) #7
  %134 = tail call i8* @strchr(i8* %0, i32 46) #21
  %135 = tail call i64 @strlen(i8* %0) #21
  %136 = icmp ugt i64 %135, 200
  %137 = icmp eq i8* %134, null
  %138 = or i1 %137, %136
  br i1 %138, label %157, label %139

; <label>:139:                                    ; preds = %132
  %140 = call i8* @strcpy(i8* nonnull %133, i8* %0) #17
  %141 = call %struct.lconv* @localeconv() #17
  %142 = getelementptr inbounds %struct.lconv, %struct.lconv* %141, i64 0, i32 0
  %143 = load i8*, i8** %142, align 8, !tbaa !142
  %144 = load i8, i8* %143, align 1, !tbaa !21
  %145 = ptrtoint i8* %134 to i64
  %146 = ptrtoint i8* %0 to i64
  %147 = sub i64 %145, %146
  %148 = getelementptr inbounds [201 x i8], [201 x i8]* %3, i64 0, i64 %147
  store i8 %144, i8* %148, align 1, !tbaa !21
  %149 = call fastcc i8* @l_str2dloc(i8* nonnull %133, double* nonnull %4) #17
  %150 = icmp eq i8* %149, null
  %151 = ptrtoint i8* %149 to i64
  %152 = ptrtoint [201 x i8]* %3 to i64
  %153 = sub i64 %151, %152
  %154 = getelementptr inbounds i8, i8* %0, i64 %153
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %133) #7
  %155 = icmp eq i8* %154, null
  %156 = or i1 %150, %155
  br i1 %156, label %172, label %158

; <label>:157:                                    ; preds = %132
  call void @llvm.lifetime.end.p0i8(i64 201, i8* nonnull %133) #7
  br label %172

; <label>:158:                                    ; preds = %139, %129
  %159 = phi i8* [ %130, %129 ], [ %154, %139 ]
  %160 = bitcast double* %4 to i64*
  %161 = load i64, i64* %160, align 8, !tbaa !140
  br label %162

; <label>:162:                                    ; preds = %158, %118
  %163 = phi i64 [ %161, %158 ], [ %121, %118 ]
  %164 = phi i8 [ 19, %158 ], [ 35, %118 ]
  %165 = phi i8* [ %159, %158 ], [ %112, %118 ]
  %166 = bitcast %struct.TValue* %1 to i64*
  store i64 %163, i64* %166, align 8, !tbaa !21
  %167 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  store i8 %164, i8* %167, align 8, !tbaa !22
  %168 = ptrtoint i8* %165 to i64
  %169 = ptrtoint i8* %0 to i64
  %170 = sub i64 1, %169
  %171 = add i64 %170, %168
  br label %172

; <label>:172:                                    ; preds = %139, %125, %157, %162
  %173 = phi i64 [ %171, %162 ], [ 0, %157 ], [ 0, %125 ], [ 0, %139 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %173
}

; Function Attrs: nounwind optsize uwtable
define double @lua_tonumberx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca double, align 8
  %5 = bitcast double* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 19
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = bitcast double* %4 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !140
  br label %18

; <label>:14:                                     ; preds = %3
  %15 = call fastcc i32 @luaV_tonumber_(%struct.TValue* %6, double* nonnull %4) #16
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  store double 0.000000e+00, double* %4, align 8, !tbaa !140
  br label %18

; <label>:18:                                     ; preds = %10, %14, %17
  %19 = phi i32 [ 1, %10 ], [ %15, %14 ], [ 0, %17 ]
  %20 = icmp eq i32* %2, null
  br i1 %20, label %22, label %21

; <label>:21:                                     ; preds = %18
  store i32 %19, i32* %2, align 4, !tbaa !77
  br label %22

; <label>:22:                                     ; preds = %18, %21
  %23 = load double, double* %4, align 8, !tbaa !140
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret double %23
}

; Function Attrs: nounwind optsize uwtable
define i64 @lua_tointegerx(%struct.lua_State* nocapture readonly, i32, i32*) local_unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 35
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %6 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  store i64 %12, i64* %4, align 8, !tbaa !144
  br label %17

; <label>:13:                                     ; preds = %3
  %14 = call fastcc i32 @luaV_tointeger(%struct.TValue* %6, i64* nonnull %4, i32 0) #16
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %13
  store i64 0, i64* %4, align 8, !tbaa !144
  br label %17

; <label>:17:                                     ; preds = %10, %13, %16
  %18 = phi i32 [ 1, %10 ], [ %14, %13 ], [ 0, %16 ]
  %19 = icmp eq i32* %2, null
  br i1 %19, label %21, label %20

; <label>:20:                                     ; preds = %17
  store i32 %18, i32* %2, align 4, !tbaa !77
  br label %21

; <label>:21:                                     ; preds = %17, %20
  %22 = load i64, i64* %4, align 8, !tbaa !144
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i64 %22
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaV_tointeger(%struct.TValue* nocapture readonly, i64* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 4
  br i1 %9, label %10, label %34

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %0 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds i8, i8* %12, i64 24
  %14 = call fastcc i64 @luaO_str2num(i8* nonnull %13, %struct.TValue* nonnull %4) #16
  %15 = bitcast %struct.TValue* %0 to %struct.TString**
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !21
  %19 = icmp eq i8 %18, 20
  br i1 %19, label %20, label %24

; <label>:20:                                     ; preds = %10
  %21 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 4
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  br label %27

; <label>:24:                                     ; preds = %10
  %25 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 0, i32 6, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !21
  br label %27

; <label>:27:                                     ; preds = %24, %20
  %28 = phi i64 [ %23, %20 ], [ %26, %24 ]
  %29 = add i64 %28, 1
  %30 = icmp eq i64 %14, %29
  %31 = select i1 %30, %struct.TValue* %4, %struct.TValue* %0
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  br label %34

; <label>:34:                                     ; preds = %27, %3
  %35 = phi i8 [ %7, %3 ], [ %33, %27 ]
  %36 = phi %struct.TValue* [ %0, %3 ], [ %31, %27 ]
  switch i8 %35, label %58 [
    i8 19, label %37
    i8 35, label %55
  ]

; <label>:37:                                     ; preds = %34
  %38 = bitcast %struct.TValue* %36 to double*
  %39 = load double, double* %38, align 8, !tbaa !21
  %40 = tail call double @llvm.floor.f64(double %39) #7
  %41 = fcmp une double %40, %39
  br i1 %41, label %42, label %48

; <label>:42:                                     ; preds = %37
  %43 = icmp eq i32 %2, 0
  br i1 %43, label %58, label %44

; <label>:44:                                     ; preds = %42
  %45 = icmp sgt i32 %2, 1
  %46 = fadd double %40, 1.000000e+00
  %47 = select i1 %45, double %46, double %40
  br label %48

; <label>:48:                                     ; preds = %44, %37
  %49 = phi double [ %40, %37 ], [ %47, %44 ]
  %50 = fcmp oge double %49, 0xC3E0000000000000
  %51 = fcmp olt double %49, 0x43E0000000000000
  %52 = and i1 %50, %51
  br i1 %52, label %53, label %58

; <label>:53:                                     ; preds = %48
  %54 = fptosi double %49 to i64
  store i64 %54, i64* %1, align 8, !tbaa !144
  br label %58

; <label>:55:                                     ; preds = %34
  %56 = bitcast %struct.TValue* %36 to i64*
  %57 = load i64, i64* %56, align 8, !tbaa !21
  store i64 %57, i64* %1, align 8, !tbaa !144
  br label %58

; <label>:58:                                     ; preds = %53, %48, %42, %34, %55
  %59 = phi i32 [ 1, %55 ], [ 0, %34 ], [ 0, %42 ], [ 0, %48 ], [ 1, %53 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %59
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_toboolean(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %15, label %8

; <label>:8:                                      ; preds = %2
  %9 = icmp eq i8 %5, 1
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %8
  %11 = bitcast %struct.TValue* %3 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = icmp ne i32 %12, 0
  %14 = zext i1 %13 to i32
  br label %15

; <label>:15:                                     ; preds = %8, %10, %2
  %16 = phi i32 [ 0, %2 ], [ 1, %8 ], [ %14, %10 ]
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = alloca [50 x i8], align 16
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = trunc i8 %7 to i4
  switch i4 %8, label %9 [
    i4 4, label %28
    i4 3, label %12
  ]

; <label>:9:                                      ; preds = %3
  %10 = icmp eq i64* %2, null
  br i1 %10, label %50, label %11

; <label>:11:                                     ; preds = %9
  store i64 0, i64* %2, align 8, !tbaa !82
  br label %50

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds [50 x i8], [50 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %13) #7
  %14 = call fastcc i64 @tostringbuff(%struct.TValue* %5, i8* nonnull %13) #17
  %15 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %13, i64 %14) #17
  %16 = bitcast %struct.TValue* %5 to %struct.TString**
  store %struct.TString* %15, %struct.TString** %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !75
  %19 = or i8 %18, 64
  store i8 %19, i8* %6, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %13) #7
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = icmp sgt i64 %23, 0
  br i1 %24, label %25, label %26

; <label>:25:                                     ; preds = %12
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %26

; <label>:26:                                     ; preds = %25, %12
  %27 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %1) #16
  br label %28

; <label>:28:                                     ; preds = %3, %26
  %29 = phi %struct.TValue* [ %5, %3 ], [ %27, %26 ]
  %30 = icmp eq i64* %2, null
  br i1 %30, label %46, label %31

; <label>:31:                                     ; preds = %28
  %32 = bitcast %struct.TValue* %29 to %struct.TString**
  %33 = load %struct.TString*, %struct.TString** %32, align 8, !tbaa !21
  %34 = getelementptr inbounds %struct.TString, %struct.TString* %33, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !21
  %36 = icmp eq i8 %35, 20
  br i1 %36, label %37, label %41

; <label>:37:                                     ; preds = %31
  %38 = getelementptr inbounds %struct.TString, %struct.TString* %33, i64 0, i32 4
  %39 = load i8, i8* %38, align 1, !tbaa !21
  %40 = zext i8 %39 to i64
  br label %44

; <label>:41:                                     ; preds = %31
  %42 = getelementptr inbounds %struct.TString, %struct.TString* %33, i64 0, i32 6, i32 0
  %43 = load i64, i64* %42, align 8, !tbaa !21
  br label %44

; <label>:44:                                     ; preds = %41, %37
  %45 = phi i64 [ %40, %37 ], [ %43, %41 ]
  store i64 %45, i64* %2, align 8, !tbaa !82
  br label %46

; <label>:46:                                     ; preds = %28, %44
  %47 = bitcast %struct.TValue* %29 to i8**
  %48 = load i8*, i8** %47, align 8, !tbaa !21
  %49 = getelementptr inbounds i8, i8* %48, i64 24
  br label %50

; <label>:50:                                     ; preds = %11, %9, %46
  %51 = phi i8* [ %49, %46 ], [ null, %9 ], [ null, %11 ]
  ret i8* %51
}

; Function Attrs: norecurse nounwind optsize uwtable
define i64 @lua_rawlen(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %27 [
    i6 20, label %7
    i6 -28, label %13
    i6 7, label %18
    i6 5, label %23
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.TString**
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = zext i8 %11 to i64
  br label %27

; <label>:13:                                     ; preds = %2
  %14 = bitcast %struct.TValue* %3 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 0, i32 6, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !21
  br label %27

; <label>:18:                                     ; preds = %2
  %19 = bitcast %struct.TValue* %3 to %struct.Udata**
  %20 = load %struct.Udata*, %struct.Udata** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.Udata, %struct.Udata* %20, i64 0, i32 4
  %22 = load i64, i64* %21, align 8, !tbaa !21
  br label %27

; <label>:23:                                     ; preds = %2
  %24 = bitcast %struct.TValue* %3 to %struct.Table**
  %25 = load %struct.Table*, %struct.Table** %24, align 8, !tbaa !21
  %26 = tail call fastcc i64 @luaH_getn(%struct.Table* %25) #16
  br label %27

; <label>:27:                                     ; preds = %2, %23, %18, %13, %7
  %28 = phi i64 [ %26, %23 ], [ %22, %18 ], [ %17, %13 ], [ %12, %7 ], [ 0, %2 ]
  ret i64 %28
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i64 @luaH_getn(%struct.Table* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %3 = load i32, i32* %2, align 4, !tbaa !92
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %70, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !91
  %8 = add i32 %3, -1
  %9 = zext i32 %8 to i64
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %9, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = and i8 %11, 15
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %70

; <label>:14:                                     ; preds = %5
  %15 = icmp ugt i32 %3, 1
  br i1 %15, label %16, label %54

; <label>:16:                                     ; preds = %14
  %17 = add i32 %3, -2
  %18 = zext i32 %17 to i64
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %18, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %24

; <label>:23:                                     ; preds = %16
  br label %39

; <label>:24:                                     ; preds = %16
  %25 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %26 = load i8, i8* %25, align 1, !tbaa !146
  %27 = icmp slt i8 %26, 0
  br i1 %27, label %34, label %28

; <label>:28:                                     ; preds = %24
  %29 = and i32 %8, %3
  %30 = icmp ne i32 %29, 0
  %31 = and i32 %8, %17
  %32 = icmp eq i32 %31, 0
  %33 = or i1 %30, %32
  br i1 %33, label %173, label %37

; <label>:34:                                     ; preds = %24
  %35 = and i32 %8, %17
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %173, label %37

; <label>:37:                                     ; preds = %28, %34
  store i32 %8, i32* %2, align 4, !tbaa !92
  %38 = or i8 %26, -128
  store i8 %38, i8* %25, align 1, !tbaa !146
  br label %173

; <label>:39:                                     ; preds = %23, %39
  %40 = phi i32 [ %51, %39 ], [ 0, %23 ]
  %41 = phi i32 [ %50, %39 ], [ %3, %23 ]
  %42 = add i32 %41, %40
  %43 = lshr i32 %42, 1
  %44 = add nsw i32 %43, -1
  %45 = zext i32 %44 to i64
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 %45, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  %50 = select i1 %49, i32 %43, i32 %41
  %51 = select i1 %49, i32 %40, i32 %43
  %52 = sub i32 %50, %51
  %53 = icmp ugt i32 %52, 1
  br i1 %53, label %39, label %54

; <label>:54:                                     ; preds = %39, %14
  %55 = phi i32 [ 0, %14 ], [ %51, %39 ]
  %56 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %57 = load i8, i8* %56, align 1, !tbaa !146
  %58 = icmp slt i8 %57, 0
  %59 = and i32 %8, %3
  %60 = icmp eq i32 %59, 0
  %61 = or i1 %60, %58
  br i1 %61, label %62, label %68

; <label>:62:                                     ; preds = %54
  %63 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %64 = lshr i32 %63, 1
  %65 = icmp ugt i32 %55, %64
  br i1 %65, label %66, label %68

; <label>:66:                                     ; preds = %62
  store i32 %55, i32* %2, align 4, !tbaa !92
  %67 = or i8 %57, -128
  store i8 %67, i8* %56, align 1, !tbaa !146
  br label %68

; <label>:68:                                     ; preds = %54, %66, %62
  %69 = zext i32 %55 to i64
  br label %173

; <label>:70:                                     ; preds = %1, %5
  %71 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %72 = load i8, i8* %71, align 1, !tbaa !146
  %73 = icmp slt i8 %72, 0
  br i1 %73, label %74, label %118

; <label>:74:                                     ; preds = %70
  %75 = add i32 %3, -1
  %76 = and i32 %75, %3
  %77 = icmp eq i32 %76, 0
  br i1 %77, label %118, label %78

; <label>:78:                                     ; preds = %74
  %79 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %80 = load %struct.TValue*, %struct.TValue** %79, align 8, !tbaa !91
  %81 = zext i32 %3 to i64
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %80, i64 %81, i32 1
  %83 = load i8, i8* %82, align 8, !tbaa !22
  %84 = and i8 %83, 15
  %85 = icmp eq i8 %84, 0
  br i1 %85, label %173, label %86

; <label>:86:                                     ; preds = %78
  %87 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %88 = add i32 %87, -1
  %89 = zext i32 %88 to i64
  %90 = getelementptr inbounds %struct.TValue, %struct.TValue* %80, i64 %89, i32 1
  %91 = load i8, i8* %90, align 8, !tbaa !22
  %92 = and i8 %91, 15
  %93 = icmp eq i8 %92, 0
  br i1 %93, label %94, label %118

; <label>:94:                                     ; preds = %86
  %95 = sub i32 %87, %3
  %96 = icmp ugt i32 %95, 1
  br i1 %96, label %97, label %115

; <label>:97:                                     ; preds = %94
  br label %98

; <label>:98:                                     ; preds = %97, %98
  %99 = phi i32 [ %110, %98 ], [ %3, %97 ]
  %100 = phi i32 [ %109, %98 ], [ %87, %97 ]
  %101 = add i32 %100, %99
  %102 = lshr i32 %101, 1
  %103 = add nsw i32 %102, -1
  %104 = zext i32 %103 to i64
  %105 = getelementptr inbounds %struct.TValue, %struct.TValue* %80, i64 %104, i32 1
  %106 = load i8, i8* %105, align 8, !tbaa !22
  %107 = and i8 %106, 15
  %108 = icmp eq i8 %107, 0
  %109 = select i1 %108, i32 %102, i32 %100
  %110 = select i1 %108, i32 %99, i32 %102
  %111 = sub i32 %109, %110
  %112 = icmp ugt i32 %111, 1
  br i1 %112, label %98, label %113

; <label>:113:                                    ; preds = %98
  %114 = zext i32 %110 to i64
  br label %115

; <label>:115:                                    ; preds = %113, %94
  %116 = phi i64 [ %114, %113 ], [ %81, %94 ]
  %117 = phi i32 [ %110, %113 ], [ %3, %94 ]
  store i32 %117, i32* %2, align 4, !tbaa !92
  br label %173

; <label>:118:                                    ; preds = %86, %74, %70
  %119 = phi i32 [ %3, %74 ], [ %87, %86 ], [ %3, %70 ]
  %120 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 8
  %121 = load %union.Node*, %union.Node** %120, align 8, !tbaa !147
  %122 = icmp eq %union.Node* %121, null
  br i1 %122, label %131, label %123

; <label>:123:                                    ; preds = %118
  %124 = add i32 %119, 1
  %125 = zext i32 %124 to i64
  %126 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* nonnull %0, i64 %125) #16
  %127 = getelementptr inbounds %struct.TValue, %struct.TValue* %126, i64 0, i32 1
  %128 = load i8, i8* %127, align 8, !tbaa !22
  %129 = and i8 %128, 15
  %130 = icmp eq i8 %129, 0
  br i1 %130, label %131, label %133

; <label>:131:                                    ; preds = %123, %118
  %132 = zext i32 %119 to i64
  br label %173

; <label>:133:                                    ; preds = %123
  %134 = zext i32 %119 to i64
  %135 = icmp eq i32 %119, 0
  %136 = zext i1 %135 to i64
  %137 = add nuw nsw i64 %136, %134
  br label %138

; <label>:138:                                    ; preds = %141, %133
  %139 = phi i64 [ %137, %133 ], [ %142, %141 ]
  %140 = icmp ult i64 %139, 4611686018427387904
  br i1 %140, label %141, label %148

; <label>:141:                                    ; preds = %138
  %142 = shl i64 %139, 1
  %143 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %142) #17
  %144 = getelementptr inbounds %struct.TValue, %struct.TValue* %143, i64 0, i32 1
  %145 = load i8, i8* %144, align 8, !tbaa !22
  %146 = and i8 %145, 15
  %147 = icmp eq i8 %146, 0
  br i1 %147, label %154, label %138

; <label>:148:                                    ; preds = %138
  %149 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 9223372036854775807) #17
  %150 = getelementptr inbounds %struct.TValue, %struct.TValue* %149, i64 0, i32 1
  %151 = load i8, i8* %150, align 8, !tbaa !22
  %152 = and i8 %151, 15
  %153 = icmp eq i8 %152, 0
  br i1 %153, label %154, label %173

; <label>:154:                                    ; preds = %141, %148
  %155 = phi i64 [ 9223372036854775807, %148 ], [ %142, %141 ]
  %156 = sub i64 %155, %139
  %157 = icmp ugt i64 %156, 1
  br i1 %157, label %158, label %173

; <label>:158:                                    ; preds = %154
  br label %159

; <label>:159:                                    ; preds = %158, %159
  %160 = phi i64 [ %170, %159 ], [ %139, %158 ]
  %161 = phi i64 [ %169, %159 ], [ %155, %158 ]
  %162 = add i64 %161, %160
  %163 = lshr i64 %162, 1
  %164 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %163) #17
  %165 = getelementptr inbounds %struct.TValue, %struct.TValue* %164, i64 0, i32 1
  %166 = load i8, i8* %165, align 8, !tbaa !22
  %167 = and i8 %166, 15
  %168 = icmp eq i8 %167, 0
  %169 = select i1 %168, i64 %163, i64 %161
  %170 = select i1 %168, i64 %160, i64 %163
  %171 = sub i64 %169, %170
  %172 = icmp ugt i64 %171, 1
  br i1 %172, label %159, label %173

; <label>:173:                                    ; preds = %159, %154, %148, %78, %34, %37, %28, %131, %115, %68
  %174 = phi i64 [ %69, %68 ], [ %132, %131 ], [ %116, %115 ], [ %9, %28 ], [ %9, %37 ], [ %9, %34 ], [ %81, %78 ], [ 9223372036854775807, %148 ], [ %139, %154 ], [ %170, %159 ]
  ret i64 %174
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 (%struct.lua_State*)* @lua_tocfunction(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %15 [
    i8 38, label %6
    i8 118, label %8
  ]

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %3 to i32 (%struct.lua_State*)**
  br label %12

; <label>:8:                                      ; preds = %2
  %9 = bitcast %struct.TValue* %3 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %12

; <label>:12:                                     ; preds = %6, %8
  %13 = phi i32 (%struct.lua_State*)** [ %11, %8 ], [ %7, %6 ]
  %14 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %2
  %16 = phi i32 (%struct.lua_State*)* [ null, %2 ], [ %14, %12 ]
  ret i32 (%struct.lua_State*)* %16
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i8* @lua_touserdata(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %22 [
    i4 7, label %7
    i4 2, label %19
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.Udata**
  %9 = load %struct.Udata*, %struct.Udata** %8, align 8, !tbaa !21
  %10 = bitcast %struct.Udata* %9 to i8*
  %11 = getelementptr inbounds %struct.Udata, %struct.Udata* %9, i64 0, i32 3
  %12 = load i16, i16* %11, align 2, !tbaa !21
  %13 = icmp eq i16 %12, 0
  %14 = zext i16 %12 to i64
  %15 = shl nuw nsw i64 %14, 4
  %16 = add nuw nsw i64 %15, 40
  %17 = select i1 %13, i64 32, i64 %16
  %18 = getelementptr inbounds i8, i8* %10, i64 %17
  br label %22

; <label>:19:                                     ; preds = %2
  %20 = bitcast %struct.TValue* %3 to i8**
  %21 = load i8*, i8** %20, align 8, !tbaa !21
  br label %22

; <label>:22:                                     ; preds = %2, %7, %19
  %23 = phi i8* [ %21, %19 ], [ %18, %7 ], [ null, %2 ]
  ret i8* %23
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define %struct.lua_State* @lua_tothread(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 72
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.lua_State**
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !21
  br label %10

; <label>:10:                                     ; preds = %2, %7
  %11 = phi %struct.lua_State* [ %9, %7 ], [ null, %2 ]
  ret %struct.lua_State* %11
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i8* @lua_topointer(%struct.lua_State* nocapture readonly, i32) local_unnamed_addr #3 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %27 [
    i6 -26, label %7
    i6 7, label %10
    i6 2, label %10
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !21
  br label %33

; <label>:10:                                     ; preds = %2, %2
  %11 = trunc i8 %5 to i4
  switch i4 %11, label %33 [
    i4 7, label %12
    i4 2, label %24
  ]

; <label>:12:                                     ; preds = %10
  %13 = bitcast %struct.TValue* %3 to %struct.Udata**
  %14 = load %struct.Udata*, %struct.Udata** %13, align 8, !tbaa !21
  %15 = bitcast %struct.Udata* %14 to i8*
  %16 = getelementptr inbounds %struct.Udata, %struct.Udata* %14, i64 0, i32 3
  %17 = load i16, i16* %16, align 2, !tbaa !21
  %18 = icmp eq i16 %17, 0
  %19 = zext i16 %17 to i64
  %20 = shl nuw nsw i64 %19, 4
  %21 = add nuw nsw i64 %20, 40
  %22 = select i1 %18, i64 32, i64 %21
  %23 = getelementptr inbounds i8, i8* %15, i64 %22
  br label %33

; <label>:24:                                     ; preds = %10
  %25 = bitcast %struct.TValue* %3 to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !21
  br label %33

; <label>:27:                                     ; preds = %2
  %28 = and i8 %5, 64
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %33, label %30

; <label>:30:                                     ; preds = %27
  %31 = bitcast %struct.TValue* %3 to i8**
  %32 = load i8*, i8** %31, align 8, !tbaa !21
  br label %33

; <label>:33:                                     ; preds = %24, %12, %10, %27, %30, %7
  %34 = phi i8* [ %32, %30 ], [ %9, %7 ], [ null, %27 ], [ %26, %24 ], [ %23, %12 ], [ null, %10 ]
  ret i8* %34
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushnil(%struct.lua_State* nocapture) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 0, i8* %5, align 8, !tbaa !21
  %6 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %2, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushnumber(%struct.lua_State* nocapture, double) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to double*
  store double %1, double* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 19, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushinteger(%struct.lua_State* nocapture, i64) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i64*
  store i64 %1, i64* %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define nonnull i8* @lua_pushlstring(%struct.lua_State*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %9

; <label>:7:                                      ; preds = %3
  %8 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %2) #16
  br label %9

; <label>:9:                                      ; preds = %7, %5
  %10 = phi %struct.TString* [ %6, %5 ], [ %8, %7 ]
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !75
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %11, align 8, !tbaa !20
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = icmp sgt i64 %24, 0
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %9
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %27

; <label>:27:                                     ; preds = %26, %9
  %28 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %29 = bitcast %struct.TString* %28 to i8*
  ret i8* %29
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TString* @luaS_new(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = ptrtoint i8* %1 to i64
  %4 = trunc i64 %3 to i32
  %5 = urem i32 %4, 53
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = zext i32 %5 to i64
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 0
  br label %13

; <label>:10:                                     ; preds = %13
  %11 = add nuw nsw i64 %14, 1
  %12 = icmp ult i64 %11, 2
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %2, %10
  %14 = phi i64 [ 0, %2 ], [ 1, %10 ]
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 %14
  %16 = load %struct.TString*, %struct.TString** %15, align 8, !tbaa !54
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %16, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = tail call i32 @strcmp(i8* %1, i8* nonnull %18) #21
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %28, label %10

; <label>:21:                                     ; preds = %10
  %22 = bitcast %struct.TString** %9 to i64*
  %23 = load i64, i64* %22, align 8, !tbaa !54
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 42, i64 %8, i64 1
  %25 = bitcast %struct.TString** %24 to i64*
  store i64 %23, i64* %25, align 8, !tbaa !54
  %26 = tail call i64 @strlen(i8* %1) #21
  %27 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* %1, i64 %26) #16
  store %struct.TString* %27, %struct.TString** %9, align 8, !tbaa !54
  br label %28

; <label>:28:                                     ; preds = %13, %21
  %29 = phi %struct.TString* [ %27, %21 ], [ %16, %13 ]
  ret %struct.TString* %29
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TString* @luaS_newlstr(%struct.lua_State*, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 41
  br i1 %4, label %5, label %125

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 9
  %9 = load i32, i32* %8, align 8, !tbaa !78
  %10 = trunc i64 %2 to i32
  %11 = xor i32 %9, %10
  %12 = lshr i64 %2, 5
  %13 = icmp ult i64 %12, %2
  br i1 %13, label %14, label %30

; <label>:14:                                     ; preds = %5
  %15 = xor i64 %12, -1
  br label %16

; <label>:16:                                     ; preds = %16, %14
  %17 = phi i64 [ %2, %14 ], [ %28, %16 ]
  %18 = phi i32 [ %11, %14 ], [ %27, %16 ]
  %19 = shl i32 %18, 5
  %20 = lshr i32 %18, 2
  %21 = add i32 %19, %20
  %22 = add i64 %17, -1
  %23 = getelementptr inbounds i8, i8* %1, i64 %22
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = zext i8 %24 to i32
  %26 = add i32 %21, %25
  %27 = xor i32 %26, %18
  %28 = add i64 %17, %15
  %29 = icmp ugt i64 %28, %12
  br i1 %29, label %16, label %30

; <label>:30:                                     ; preds = %16, %5
  %31 = phi i32 [ %11, %5 ], [ %27, %16 ]
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 0
  %33 = load %struct.TString**, %struct.TString*** %32, align 8, !tbaa !94
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 2
  %35 = load i32, i32* %34, align 4, !tbaa !95
  %36 = add nsw i32 %35, -1
  %37 = and i32 %36, %31
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds %struct.TString*, %struct.TString** %33, i64 %38
  %40 = load %struct.TString*, %struct.TString** %39, align 8, !tbaa !21
  %41 = icmp eq %struct.TString* %40, null
  br i1 %41, label %69, label %42

; <label>:42:                                     ; preds = %30
  br label %43

; <label>:43:                                     ; preds = %42, %64
  %44 = phi %struct.TString* [ %67, %64 ], [ %40, %42 ]
  %45 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 4
  %46 = load i8, i8* %45, align 1, !tbaa !123
  %47 = zext i8 %46 to i64
  %48 = icmp eq i64 %47, %2
  br i1 %48, label %49, label %64

; <label>:49:                                     ; preds = %43
  %50 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 1
  %51 = bitcast %struct.TString* %50 to i8*
  %52 = tail call i32 @memcmp(i8* %1, i8* nonnull %51, i64 %2) #21
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %54, label %64

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 2
  %56 = load i8, i8* %55, align 1, !tbaa !148
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 10
  %58 = load i8, i8* %57, align 4, !tbaa !15
  %59 = xor i8 %58, 24
  %60 = and i8 %59, %56
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %153, label %62

; <label>:62:                                     ; preds = %54
  %63 = xor i8 %56, 24
  store i8 %63, i8* %55, align 1, !tbaa !148
  br label %153

; <label>:64:                                     ; preds = %49, %43
  %65 = getelementptr inbounds %struct.TString, %struct.TString* %44, i64 0, i32 6
  %66 = bitcast %union.anon* %65 to %struct.TString**
  %67 = load %struct.TString*, %struct.TString** %66, align 8, !tbaa !21
  %68 = icmp eq %struct.TString* %67, null
  br i1 %68, label %69, label %43

; <label>:69:                                     ; preds = %64, %30
  %70 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 6, i32 1
  %71 = load i32, i32* %70, align 8, !tbaa !149
  %72 = icmp slt i32 %71, %35
  br i1 %72, label %95, label %73

; <label>:73:                                     ; preds = %69
  %74 = icmp eq i32 %71, 2147483647
  br i1 %74, label %75, label %81, !prof !61

; <label>:75:                                     ; preds = %73
  tail call fastcc void @luaC_fullgc(%struct.lua_State* %0, i32 1) #17
  %76 = load i32, i32* %70, align 8, !tbaa !149
  %77 = icmp eq i32 %76, 2147483647
  br i1 %77, label %80, label %78

; <label>:78:                                     ; preds = %75
  %79 = load i32, i32* %34, align 4, !tbaa !95
  br label %81

; <label>:80:                                     ; preds = %75
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #19
  unreachable

; <label>:81:                                     ; preds = %78, %73
  %82 = phi i32 [ %79, %78 ], [ %35, %73 ]
  %83 = icmp slt i32 %82, 1073741824
  br i1 %83, label %84, label %87

; <label>:84:                                     ; preds = %81
  %85 = shl nsw i32 %82, 1
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %85) #17
  %86 = load i32, i32* %34, align 4, !tbaa !95
  br label %87

; <label>:87:                                     ; preds = %84, %81
  %88 = phi i32 [ %86, %84 ], [ %82, %81 ]
  %89 = load %struct.TString**, %struct.TString*** %32, align 8, !tbaa !94
  %90 = add nsw i32 %88, -1
  %91 = and i32 %90, %31
  %92 = sext i32 %91 to i64
  %93 = getelementptr inbounds %struct.TString*, %struct.TString** %89, i64 %92
  %94 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  br label %95

; <label>:95:                                     ; preds = %87, %69
  %96 = phi %struct.global_State* [ %94, %87 ], [ %7, %69 ]
  %97 = phi %struct.TString** [ %93, %87 ], [ %39, %69 ]
  %98 = add i64 %2, 25
  %99 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %98, i32 4) #17
  %100 = getelementptr inbounds %struct.global_State, %struct.global_State* %96, i64 0, i32 10
  %101 = load i8, i8* %100, align 4, !tbaa !15
  %102 = and i8 %101, 24
  %103 = getelementptr inbounds i8, i8* %99, i64 9
  store i8 %102, i8* %103, align 1, !tbaa !70
  %104 = getelementptr inbounds i8, i8* %99, i64 8
  store i8 20, i8* %104, align 8, !tbaa !86
  %105 = getelementptr inbounds %struct.global_State, %struct.global_State* %96, i64 0, i32 20
  %106 = bitcast %struct.GCObject** %105 to i64*
  %107 = load i64, i64* %106, align 8, !tbaa !18
  %108 = bitcast i8* %99 to i64*
  store i64 %107, i64* %108, align 8, !tbaa !87
  %109 = bitcast %struct.GCObject** %105 to i8**
  store i8* %99, i8** %109, align 8, !tbaa !18
  %110 = bitcast i8* %99 to %struct.TString*
  %111 = getelementptr inbounds i8, i8* %99, i64 12
  %112 = bitcast i8* %111 to i32*
  store i32 %31, i32* %112, align 4, !tbaa !150
  %113 = getelementptr inbounds i8, i8* %99, i64 10
  store i8 0, i8* %113, align 2, !tbaa !99
  %114 = getelementptr inbounds i8, i8* %99, i64 24
  %115 = getelementptr inbounds i8, i8* %114, i64 %2
  store i8 0, i8* %115, align 1, !tbaa !21
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %114, i8* %1, i64 %2, i32 1, i1 false) #7
  %116 = trunc i64 %2 to i8
  %117 = getelementptr inbounds i8, i8* %99, i64 11
  store i8 %116, i8* %117, align 1, !tbaa !123
  %118 = bitcast %struct.TString** %97 to i64*
  %119 = load i64, i64* %118, align 8, !tbaa !54
  %120 = getelementptr inbounds i8, i8* %99, i64 16
  %121 = bitcast i8* %120 to i64*
  store i64 %119, i64* %121, align 8, !tbaa !21
  %122 = bitcast %struct.TString** %97 to i8**
  store i8* %99, i8** %122, align 8, !tbaa !54
  %123 = load i32, i32* %70, align 8, !tbaa !149
  %124 = add nsw i32 %123, 1
  store i32 %124, i32* %70, align 8, !tbaa !149
  br label %153

; <label>:125:                                    ; preds = %3
  %126 = icmp ugt i64 %2, 9223372036854775782
  br i1 %126, label %127, label %128, !prof !61

; <label>:127:                                    ; preds = %125
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #18
  unreachable

; <label>:128:                                    ; preds = %125
  %129 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %130 = load %struct.global_State*, %struct.global_State** %129, align 8, !tbaa !2
  %131 = getelementptr inbounds %struct.global_State, %struct.global_State* %130, i64 0, i32 9
  %132 = load i32, i32* %131, align 8, !tbaa !78
  %133 = add i64 %2, 25
  %134 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %133, i32 4) #17
  %135 = getelementptr inbounds %struct.global_State, %struct.global_State* %130, i64 0, i32 10
  %136 = load i8, i8* %135, align 4, !tbaa !15
  %137 = and i8 %136, 24
  %138 = getelementptr inbounds i8, i8* %134, i64 9
  store i8 %137, i8* %138, align 1, !tbaa !70
  %139 = getelementptr inbounds i8, i8* %134, i64 8
  store i8 36, i8* %139, align 8, !tbaa !86
  %140 = getelementptr inbounds %struct.global_State, %struct.global_State* %130, i64 0, i32 20
  %141 = bitcast %struct.GCObject** %140 to i64*
  %142 = load i64, i64* %141, align 8, !tbaa !18
  %143 = bitcast i8* %134 to i64*
  store i64 %142, i64* %143, align 8, !tbaa !87
  %144 = bitcast %struct.GCObject** %140 to i8**
  store i8* %134, i8** %144, align 8, !tbaa !18
  %145 = bitcast i8* %134 to %struct.TString*
  %146 = getelementptr inbounds i8, i8* %134, i64 12
  %147 = bitcast i8* %146 to i32*
  store i32 %132, i32* %147, align 4, !tbaa !150
  %148 = getelementptr inbounds i8, i8* %134, i64 10
  store i8 0, i8* %148, align 2, !tbaa !99
  %149 = getelementptr inbounds i8, i8* %134, i64 24
  %150 = getelementptr inbounds i8, i8* %149, i64 %2
  store i8 0, i8* %150, align 1, !tbaa !21
  %151 = getelementptr inbounds i8, i8* %134, i64 16
  %152 = bitcast i8* %151 to i64*
  store i64 %2, i64* %152, align 8, !tbaa !21
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %149, i8* %1, i64 %2, i32 1, i1 false)
  br label %153

; <label>:153:                                    ; preds = %95, %62, %54, %128
  %154 = phi %struct.TString* [ %145, %128 ], [ %110, %95 ], [ %44, %54 ], [ %44, %62 ]
  ret %struct.TString* %154
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_pushstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = icmp eq i8* %1, null
  br i1 %3, label %4, label %9

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  br label %21

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* nonnull %1) #16
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  %14 = bitcast %struct.TValue* %13 to %struct.TString**
  store %struct.TString* %10, %struct.TString** %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !75
  %17 = or i8 %16, 64
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %10, i64 1
  %20 = bitcast %struct.TString* %19 to i8*
  br label %21

; <label>:21:                                     ; preds = %9, %4
  %22 = phi %union.StackValue** [ %11, %9 ], [ %5, %4 ]
  %23 = phi i8* [ %20, %9 ], [ null, %4 ]
  %24 = load %union.StackValue*, %union.StackValue** %22, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %22, align 8, !tbaa !20
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %32

; <label>:31:                                     ; preds = %21
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %32

; <label>:32:                                     ; preds = %31, %21
  ret i8* %23
}

; Function Attrs: nounwind optsize uwtable
define nonnull i8* @lua_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) local_unnamed_addr #0 {
  %4 = tail call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* %2) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = icmp sgt i64 %8, 0
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %3
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %11

; <label>:11:                                     ; preds = %10, %3
  ret i8* %4
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc nonnull i8* @luaO_pushvfstring(%struct.lua_State*, i8*, %struct.__va_list_tag*) unnamed_addr #0 {
  %4 = alloca %struct.BuffFS, align 8
  %5 = alloca i8, align 1
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = alloca [8 x i8], align 1
  %10 = bitcast %struct.BuffFS* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 416, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 2
  store i32 0, i32* %11, align 4, !tbaa !151
  %12 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 1
  store i32 0, i32* %12, align 8, !tbaa !153
  %13 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %13, align 8, !tbaa !154
  %14 = call i8* @strchr(i8* %1, i32 37) #21
  %15 = icmp eq i8* %14, null
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 3, i64 0
  br label %177

; <label>:18:                                     ; preds = %3
  %19 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 0
  %20 = bitcast %struct.TValue* %6 to i8*
  %21 = bitcast %struct.TValue* %7 to i8*
  %22 = bitcast %struct.TValue* %8 to i8*
  %23 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 1
  %24 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 0
  %25 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 3
  %26 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %2, i64 0, i32 2
  %27 = bitcast %struct.TValue* %6 to i64*
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %29 = bitcast %struct.TValue* %7 to i64*
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %31 = bitcast %struct.TValue* %8 to i64*
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %33 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 3, i64 0
  %34 = getelementptr inbounds [8 x i8], [8 x i8]* %9, i64 0, i64 8
  br label %35

; <label>:35:                                     ; preds = %18, %173
  %36 = phi i8* [ %14, %18 ], [ %175, %173 ]
  %37 = phi i8* [ %1, %18 ], [ %174, %173 ]
  %38 = ptrtoint i8* %36 to i64
  %39 = ptrtoint i8* %37 to i64
  %40 = sub i64 %38, %39
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %37, i64 %40) #16
  %41 = getelementptr inbounds i8, i8* %36, i64 1
  %42 = load i8, i8* %41, align 1, !tbaa !21
  %43 = sext i8 %42 to i32
  switch i32 %43, label %171 [
    i32 115, label %44
    i32 99, label %62
    i32 100, label %78
    i32 73, label %94
    i32 102, label %109
    i32 112, label %124
    i32 85, label %151
    i32 37, label %170
  ]

; <label>:44:                                     ; preds = %35
  %45 = load i32, i32* %19, align 8
  %46 = icmp ult i32 %45, 41
  br i1 %46, label %47, label %52

; <label>:47:                                     ; preds = %44
  %48 = load i8*, i8** %25, align 8
  %49 = sext i32 %45 to i64
  %50 = getelementptr i8, i8* %48, i64 %49
  %51 = add i32 %45, 8
  store i32 %51, i32* %19, align 8
  br label %55

; <label>:52:                                     ; preds = %44
  %53 = load i8*, i8** %26, align 8
  %54 = getelementptr i8, i8* %53, i64 8
  store i8* %54, i8** %26, align 8
  br label %55

; <label>:55:                                     ; preds = %52, %47
  %56 = phi i8* [ %50, %47 ], [ %53, %52 ]
  %57 = bitcast i8* %56 to i8**
  %58 = load i8*, i8** %57, align 8
  %59 = icmp eq i8* %58, null
  %60 = select i1 %59, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.193, i64 0, i64 0), i8* %58
  %61 = call i64 @strlen(i8* %60) #21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %60, i64 %61) #16
  br label %173

; <label>:62:                                     ; preds = %35
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #7
  %63 = load i32, i32* %19, align 8
  %64 = icmp ult i32 %63, 41
  br i1 %64, label %65, label %70

; <label>:65:                                     ; preds = %62
  %66 = load i8*, i8** %25, align 8
  %67 = sext i32 %63 to i64
  %68 = getelementptr i8, i8* %66, i64 %67
  %69 = add i32 %63, 8
  store i32 %69, i32* %19, align 8
  br label %73

; <label>:70:                                     ; preds = %62
  %71 = load i8*, i8** %26, align 8
  %72 = getelementptr i8, i8* %71, i64 8
  store i8* %72, i8** %26, align 8
  br label %73

; <label>:73:                                     ; preds = %70, %65
  %74 = phi i8* [ %68, %65 ], [ %71, %70 ]
  %75 = bitcast i8* %74 to i32*
  %76 = load i32, i32* %75, align 4
  %77 = trunc i32 %76 to i8
  store i8 %77, i8* %5, align 1, !tbaa !21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %5, i64 1) #16
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #7
  br label %173

; <label>:78:                                     ; preds = %35
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %20) #7
  %79 = load i32, i32* %19, align 8
  %80 = icmp ult i32 %79, 41
  br i1 %80, label %81, label %86

; <label>:81:                                     ; preds = %78
  %82 = load i8*, i8** %25, align 8
  %83 = sext i32 %79 to i64
  %84 = getelementptr i8, i8* %82, i64 %83
  %85 = add i32 %79, 8
  store i32 %85, i32* %19, align 8
  br label %89

; <label>:86:                                     ; preds = %78
  %87 = load i8*, i8** %26, align 8
  %88 = getelementptr i8, i8* %87, i64 8
  store i8* %88, i8** %26, align 8
  br label %89

; <label>:89:                                     ; preds = %86, %81
  %90 = phi i8* [ %84, %81 ], [ %87, %86 ]
  %91 = bitcast i8* %90 to i32*
  %92 = load i32, i32* %91, align 4
  %93 = sext i32 %92 to i64
  store i64 %93, i64* %27, align 8, !tbaa !21
  store i8 35, i8* %28, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %6) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %20) #7
  br label %173

; <label>:94:                                     ; preds = %35
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %21) #7
  %95 = load i32, i32* %19, align 8
  %96 = icmp ult i32 %95, 41
  br i1 %96, label %97, label %102

; <label>:97:                                     ; preds = %94
  %98 = load i8*, i8** %25, align 8
  %99 = sext i32 %95 to i64
  %100 = getelementptr i8, i8* %98, i64 %99
  %101 = add i32 %95, 8
  store i32 %101, i32* %19, align 8
  br label %105

; <label>:102:                                    ; preds = %94
  %103 = load i8*, i8** %26, align 8
  %104 = getelementptr i8, i8* %103, i64 8
  store i8* %104, i8** %26, align 8
  br label %105

; <label>:105:                                    ; preds = %102, %97
  %106 = phi i8* [ %100, %97 ], [ %103, %102 ]
  %107 = bitcast i8* %106 to i64*
  %108 = load i64, i64* %107, align 8
  store i64 %108, i64* %29, align 8, !tbaa !21
  store i8 35, i8* %30, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %7) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %21) #7
  br label %173

; <label>:109:                                    ; preds = %35
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %22) #7
  %110 = load i32, i32* %23, align 4
  %111 = icmp ult i32 %110, 161
  br i1 %111, label %112, label %117

; <label>:112:                                    ; preds = %109
  %113 = load i8*, i8** %25, align 8
  %114 = sext i32 %110 to i64
  %115 = getelementptr i8, i8* %113, i64 %114
  %116 = add i32 %110, 16
  store i32 %116, i32* %23, align 4
  br label %120

; <label>:117:                                    ; preds = %109
  %118 = load i8*, i8** %26, align 8
  %119 = getelementptr i8, i8* %118, i64 8
  store i8* %119, i8** %26, align 8
  br label %120

; <label>:120:                                    ; preds = %117, %112
  %121 = phi i8* [ %115, %112 ], [ %118, %117 ]
  %122 = bitcast i8* %121 to i64*
  %123 = load i64, i64* %122, align 8
  store i64 %123, i64* %31, align 8, !tbaa !21
  store i8 19, i8* %32, align 8, !tbaa !22
  call fastcc void @addnum2buff(%struct.BuffFS* nonnull %4, %struct.TValue* nonnull %8) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %22) #7
  br label %173

; <label>:124:                                    ; preds = %35
  %125 = load i32, i32* %11, align 4, !tbaa !151
  %126 = sext i32 %125 to i64
  %127 = sub nsw i64 400, %126
  %128 = icmp ult i64 %127, 32
  br i1 %128, label %129, label %130

; <label>:129:                                    ; preds = %124
  call fastcc void @pushstr(%struct.BuffFS* nonnull %4, i8* nonnull %33, i64 %126) #17
  store i32 0, i32* %11, align 4, !tbaa !151
  br label %130

; <label>:130:                                    ; preds = %124, %129
  %131 = phi i32 [ %125, %124 ], [ 0, %129 ]
  %132 = sext i32 %131 to i64
  %133 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %4, i64 0, i32 3, i64 %132
  %134 = load i32, i32* %19, align 8
  %135 = icmp ult i32 %134, 41
  br i1 %135, label %136, label %141

; <label>:136:                                    ; preds = %130
  %137 = load i8*, i8** %25, align 8
  %138 = sext i32 %134 to i64
  %139 = getelementptr i8, i8* %137, i64 %138
  %140 = add i32 %134, 8
  store i32 %140, i32* %19, align 8
  br label %144

; <label>:141:                                    ; preds = %130
  %142 = load i8*, i8** %26, align 8
  %143 = getelementptr i8, i8* %142, i64 8
  store i8* %143, i8** %26, align 8
  br label %144

; <label>:144:                                    ; preds = %141, %136
  %145 = phi i8* [ %139, %136 ], [ %142, %141 ]
  %146 = bitcast i8* %145 to i8**
  %147 = load i8*, i8** %146, align 8
  %148 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %133, i64 32, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.194, i64 0, i64 0), i8* %147) #17
  %149 = load i32, i32* %11, align 4, !tbaa !151
  %150 = add nsw i32 %149, %148
  store i32 %150, i32* %11, align 4, !tbaa !151
  br label %173

; <label>:151:                                    ; preds = %35
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %24) #7
  %152 = load i32, i32* %19, align 8
  %153 = icmp ult i32 %152, 41
  br i1 %153, label %154, label %159

; <label>:154:                                    ; preds = %151
  %155 = load i8*, i8** %25, align 8
  %156 = sext i32 %152 to i64
  %157 = getelementptr i8, i8* %155, i64 %156
  %158 = add i32 %152, 8
  store i32 %158, i32* %19, align 8
  br label %162

; <label>:159:                                    ; preds = %151
  %160 = load i8*, i8** %26, align 8
  %161 = getelementptr i8, i8* %160, i64 8
  store i8* %161, i8** %26, align 8
  br label %162

; <label>:162:                                    ; preds = %159, %154
  %163 = phi i8* [ %157, %154 ], [ %160, %159 ]
  %164 = bitcast i8* %163 to i64*
  %165 = load i64, i64* %164, align 8
  %166 = call fastcc i32 @luaO_utf8esc(i8* nonnull %24, i64 %165) #16
  %167 = sext i32 %166 to i64
  %168 = sub nsw i64 0, %167
  %169 = getelementptr inbounds i8, i8* %34, i64 %168
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* nonnull %169, i64 %167) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %24) #7
  br label %173

; <label>:170:                                    ; preds = %35
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.195, i64 0, i64 0), i64 1) #16
  br label %173

; <label>:171:                                    ; preds = %35
  %172 = sext i8 %42 to i32
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.196, i64 0, i64 0), i32 %172) #18
  unreachable

; <label>:173:                                    ; preds = %170, %162, %144, %120, %105, %89, %73, %55
  %174 = getelementptr inbounds i8, i8* %36, i64 2
  %175 = call i8* @strchr(i8* nonnull %174, i32 37) #21
  %176 = icmp eq i8* %175, null
  br i1 %176, label %177, label %35

; <label>:177:                                    ; preds = %173, %16
  %178 = phi i8* [ %17, %16 ], [ %33, %173 ]
  %179 = phi i8* [ %1, %16 ], [ %174, %173 ]
  %180 = call i64 @strlen(i8* %179) #21
  call fastcc void @addstr2buff(%struct.BuffFS* nonnull %4, i8* %179, i64 %180) #16
  %181 = load i32, i32* %11, align 4, !tbaa !151
  %182 = sext i32 %181 to i64
  call fastcc void @pushstr(%struct.BuffFS* nonnull %4, i8* nonnull %178, i64 %182) #17
  store i32 0, i32* %11, align 4, !tbaa !151
  %183 = load i32, i32* %12, align 8, !tbaa !153
  %184 = icmp sgt i32 %183, 1
  br i1 %184, label %185, label %186

; <label>:185:                                    ; preds = %177
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %183) #16
  br label %186

; <label>:186:                                    ; preds = %185, %177
  %187 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %188 = load %union.StackValue*, %union.StackValue** %187, align 8, !tbaa !20
  %189 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 -1, i32 0, i32 0, i32 0
  %190 = bitcast %struct.GCObject** %189 to i8**
  %191 = load i8*, i8** %190, align 8, !tbaa !21
  %192 = getelementptr inbounds i8, i8* %191, i64 24
  call void @llvm.lifetime.end.p0i8(i64 416, i8* nonnull %10) #7
  ret i8* %192
}

; Function Attrs: nounwind optsize uwtable
define nonnull i8* @lua_pushfstring(%struct.lua_State*, i8*, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 3
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %2
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %13

; <label>:13:                                     ; preds = %12, %2
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: nounwind optsize uwtable
define void @lua_pushcclosure(%struct.lua_State*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 38, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  br label %78

; <label>:13:                                     ; preds = %3
  %14 = shl i32 %2, 4
  %15 = add nsw i32 %14, 32
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %16, i32 6) #17
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 10
  %21 = load i8, i8* %20, align 4, !tbaa !15
  %22 = and i8 %21, 24
  %23 = getelementptr inbounds i8, i8* %19, i64 9
  store i8 %22, i8* %23, align 1, !tbaa !70
  %24 = getelementptr inbounds i8, i8* %19, i64 8
  store i8 54, i8* %24, align 8, !tbaa !86
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 20
  %26 = bitcast %struct.GCObject** %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !18
  %28 = bitcast i8* %19 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !87
  %29 = bitcast %struct.GCObject** %25 to i8**
  store i8* %19, i8** %29, align 8, !tbaa !18
  %30 = bitcast i8* %19 to %struct.CClosure*
  %31 = trunc i32 %2 to i8
  %32 = getelementptr inbounds i8, i8* %19, i64 10
  store i8 %31, i8* %32, align 2, !tbaa !138
  %33 = getelementptr inbounds i8, i8* %19, i64 24
  %34 = bitcast i8* %33 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %1, i32 (%struct.lua_State*)** %34, align 8, !tbaa !155
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %36 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %37 = sext i32 %2 to i64
  %38 = sub nsw i64 0, %37
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 %38
  store %union.StackValue* %39, %union.StackValue** %35, align 8, !tbaa !20
  %40 = add nsw i64 %37, -1
  %41 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %30, i64 0, i32 6, i64 %40
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1, i32 0
  %43 = bitcast %struct.TValue* %42 to i64*
  %44 = bitcast %struct.TValue* %41 to i64*
  %45 = load i64, i64* %43, align 8
  store i64 %45, i64* %44, align 8
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1, i32 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %30, i64 0, i32 6, i64 %40, i32 1
  store i8 %47, i8* %48, align 8, !tbaa !22
  %49 = trunc i64 %40 to i32
  %50 = icmp eq i32 %49, 0
  br i1 %50, label %66, label %51

; <label>:51:                                     ; preds = %13
  br label %52

; <label>:52:                                     ; preds = %51, %52
  %53 = phi i64 [ %55, %52 ], [ %40, %51 ]
  %54 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %55 = add nsw i64 %53, -1
  %56 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %30, i64 0, i32 6, i64 %55
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 %55, i32 0
  %58 = bitcast %struct.TValue* %57 to i64*
  %59 = bitcast %struct.TValue* %56 to i64*
  %60 = load i64, i64* %58, align 8
  store i64 %60, i64* %59, align 8
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 %55, i32 0, i32 1
  %62 = load i8, i8* %61, align 8, !tbaa !22
  %63 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %30, i64 0, i32 6, i64 %55, i32 1
  store i8 %62, i8* %63, align 8, !tbaa !22
  %64 = trunc i64 %55 to i32
  %65 = icmp eq i32 %64, 0
  br i1 %65, label %66, label %52

; <label>:66:                                     ; preds = %52, %13
  %67 = bitcast %union.StackValue** %35 to %struct.TValue**
  %68 = load %struct.TValue*, %struct.TValue** %67, align 8, !tbaa !20
  %69 = bitcast %struct.TValue* %68 to i8**
  store i8* %19, i8** %69, align 8, !tbaa !21
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %68, i64 0, i32 1
  store i8 118, i8* %70, align 8, !tbaa !22
  %71 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %72 = getelementptr inbounds %union.StackValue, %union.StackValue* %71, i64 1
  store %union.StackValue* %72, %union.StackValue** %35, align 8, !tbaa !20
  %73 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %73, i64 0, i32 3
  %75 = load i64, i64* %74, align 8, !tbaa !11
  %76 = icmp sgt i64 %75, 0
  br i1 %76, label %77, label %78

; <label>:77:                                     ; preds = %66
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %78

; <label>:78:                                     ; preds = %66, %77, %5
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushboolean(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %1, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_pushlightuserdata(%struct.lua_State* nocapture, i8*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = bitcast %struct.TValue* %5 to i8**
  store i8* %1, i8** %6, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 2, i8* %7, align 8, !tbaa !22
  %8 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %3, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_pushthread(%struct.lua_State*) local_unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 72, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 38
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !38
  %13 = icmp eq %struct.lua_State* %12, %0
  %14 = zext i1 %13 to i32
  ret i32 %14
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_getglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2) #16
  %9 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1) #16
  ret i32 %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @auxgetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %27

; <label>:8:                                      ; preds = %3
  %9 = bitcast %struct.TValue* %1 to %struct.Table**
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %10, %struct.TString* %4) #16
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %27, label %16

; <label>:16:                                     ; preds = %8
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to %struct.TValue**
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %11 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = load i8, i8* %12, align 8, !tbaa !22
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %23, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %17, align 8, !tbaa !20
  br label %41

; <label>:27:                                     ; preds = %3, %8
  %28 = phi %struct.TValue* [ %11, %8 ], [ null, %3 ]
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %30 = bitcast %union.StackValue** %29 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !75
  %35 = or i8 %34, 64
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %35, i8* %36, align 8, !tbaa !22
  %37 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 1
  store %union.StackValue* %38, %union.StackValue** %29, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %39, %union.StackValue* %37, %struct.TValue* %28) #16
  %40 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  br label %41

; <label>:41:                                     ; preds = %27, %16
  %42 = phi %union.StackValue* [ %40, %27 ], [ %26, %16 ]
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -1, i32 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !21
  %45 = and i8 %44, 15
  %46 = zext i8 %45 to i32
  ret i32 %46
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_getint(%struct.Table* nocapture, i64) unnamed_addr #2 {
  %3 = add i64 %1, -1
  %4 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %5 = load i32, i32* %4, align 4, !tbaa !92
  %6 = zext i32 %5 to i64
  %7 = icmp ult i64 %3, %6
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !91
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 %3
  br label %62

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %14 = load i8, i8* %13, align 1, !tbaa !146
  %15 = icmp slt i8 %14, 0
  br i1 %15, label %16, label %33

; <label>:16:                                     ; preds = %12
  %17 = add i32 %5, -1
  %18 = and i32 %17, %5
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %33, label %20

; <label>:20:                                     ; preds = %16
  %21 = add i32 %5, 1
  %22 = zext i32 %21 to i64
  %23 = icmp eq i64 %22, %1
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %20
  %25 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %0) #16
  %26 = zext i32 %25 to i64
  %27 = icmp ult i64 %3, %26
  br i1 %27, label %28, label %33

; <label>:28:                                     ; preds = %24, %20
  %29 = trunc i64 %1 to i32
  store i32 %29, i32* %4, align 4, !tbaa !92
  %30 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 6
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !91
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 %3
  br label %62

; <label>:33:                                     ; preds = %24, %16, %12
  %34 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %35 = load %union.Node*, %union.Node** %34, align 8, !tbaa !156
  %36 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %37 = load i8, i8* %36, align 1, !tbaa !93
  %38 = zext i8 %37 to i32
  %39 = shl i32 1, %38
  %40 = add nsw i32 %39, -1
  %41 = trunc i64 %1 to i32
  %42 = and i32 %40, %41
  br label %43

; <label>:43:                                     ; preds = %58, %33
  %44 = phi i32 [ %42, %33 ], [ %60, %58 ]
  %45 = phi %union.Node* [ %35, %33 ], [ %47, %58 ]
  %46 = sext i32 %44 to i64
  %47 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46
  %48 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !21
  %50 = icmp eq i8 %49, 35
  br i1 %50, label %51, label %58

; <label>:51:                                     ; preds = %43
  %52 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 4
  %53 = bitcast %union.Value* %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21
  %55 = icmp eq i64 %54, %1
  br i1 %55, label %56, label %58

; <label>:56:                                     ; preds = %51
  %57 = bitcast %union.Node* %47 to %struct.TValue*
  br label %62

; <label>:58:                                     ; preds = %51, %43
  %59 = getelementptr inbounds %union.Node, %union.Node* %45, i64 %46, i32 0, i32 3
  %60 = load i32, i32* %59, align 4, !tbaa !21
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %62, label %43

; <label>:62:                                     ; preds = %58, %56, %28, %8
  %63 = phi %struct.TValue* [ %11, %8 ], [ %32, %28 ], [ %57, %56 ], [ @absentkey, %58 ]
  ret %struct.TValue* %63
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_gettable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %28

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %3 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  %15 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %11, %struct.TValue* nonnull %14) #16
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %9
  %21 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = bitcast %struct.TValue* %15 to i64*
  %24 = bitcast %struct.TValue* %22 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = load i8, i8* %16, align 8, !tbaa !22
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  store i8 %26, i8* %27, align 8, !tbaa !22
  br label %34

; <label>:28:                                     ; preds = %7, %9
  %29 = phi %union.StackValue** [ %8, %7 ], [ %12, %9 ]
  %30 = phi %struct.TValue* [ null, %7 ], [ %15, %9 ]
  %31 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -1
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 0, i32 0
  tail call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %33, %union.StackValue* nonnull %32, %struct.TValue* %30) #16
  br label %34

; <label>:34:                                     ; preds = %28, %20
  %35 = phi %union.StackValue** [ %29, %28 ], [ %12, %20 ]
  %36 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !21
  %39 = and i8 %38, 15
  %40 = zext i8 %39 to i32
  ret i32 %40
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_get(%struct.Table* nocapture, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = trunc i8 %4 to i6
  switch i6 %5, label %26 [
    i6 20, label %6
    i6 -29, label %10
    i6 0, label %28
    i6 19, label %14
  ]

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %1 to %struct.TString**
  %8 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !21
  %9 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* %8) #16
  br label %28

; <label>:10:                                     ; preds = %2
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %12) #16
  br label %28

; <label>:14:                                     ; preds = %2
  %15 = bitcast %struct.TValue* %1 to double*
  %16 = load double, double* %15, align 8, !tbaa !21
  %17 = tail call double @llvm.floor.f64(double %16) #7
  %18 = fcmp une double %17, %16
  br i1 %18, label %26, label %19

; <label>:19:                                     ; preds = %14
  %20 = fcmp oge double %17, 0xC3E0000000000000
  %21 = fcmp olt double %17, 0x43E0000000000000
  %22 = and i1 %20, %21
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %19
  %24 = fptosi double %17 to i64
  %25 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %0, i64 %24) #16
  br label %28

; <label>:26:                                     ; preds = %19, %14, %2
  %27 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %1) #16
  br label %28

; <label>:28:                                     ; preds = %23, %2, %26, %10, %6
  %29 = phi %struct.TValue* [ %27, %26 ], [ %25, %23 ], [ %13, %10 ], [ %9, %6 ], [ @absentkey, %2 ]
  ret %struct.TValue* %29
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaV_finishget(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, %struct.TValue* readnone) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %5, %69
  %8 = phi %struct.TValue* [ %1, %5 ], [ %48, %69 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %70, %69 ]
  %10 = phi i32 [ 0, %5 ], [ %71, %69 ]
  %11 = icmp eq %struct.TValue* %9, null
  br i1 %11, label %12, label %19

; <label>:12:                                     ; preds = %7
  %13 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %8, i32 0) #16
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %15 = load i8, i8* %14, align 8, !tbaa !22
  %16 = and i8 %15, 15
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %46, !prof !61

; <label>:18:                                     ; preds = %12
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #18
  unreachable

; <label>:19:                                     ; preds = %7
  %20 = bitcast %struct.TValue* %8 to %struct.Table**
  %21 = load %struct.Table*, %struct.Table** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.Table, %struct.Table* %21, i64 0, i32 9
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  br i1 %24, label %44, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %23, i64 0, i32 3
  %27 = load i8, i8* %26, align 2, !tbaa !90
  %28 = and i8 %27, 1
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %30, label %44

; <label>:30:                                     ; preds = %25
  %31 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %32 = getelementptr inbounds %struct.global_State, %struct.global_State* %31, i64 0, i32 40, i64 0
  %33 = load %struct.TString*, %struct.TString** %32, align 8, !tbaa !54
  %34 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %23, %struct.TString* %33) #17
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  %37 = and i8 %36, 15
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %39, label %42

; <label>:39:                                     ; preds = %30
  %40 = getelementptr inbounds %struct.Table, %struct.Table* %23, i64 0, i32 3
  %41 = or i8 %27, 1
  store i8 %41, i8* %40, align 2, !tbaa !90
  br label %44

; <label>:42:                                     ; preds = %30
  %43 = icmp eq %struct.TValue* %34, null
  br i1 %43, label %44, label %46

; <label>:44:                                     ; preds = %25, %19, %42, %39
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 0, i8* %45, align 8, !tbaa !21
  br label %74

; <label>:46:                                     ; preds = %42, %12
  %47 = phi i8 [ %15, %12 ], [ %36, %42 ]
  %48 = phi %struct.TValue* [ %13, %12 ], [ %34, %42 ]
  %49 = and i8 %47, 15
  %50 = icmp eq i8 %49, 6
  br i1 %50, label %51, label %52

; <label>:51:                                     ; preds = %46
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %48, %struct.TValue* %8, %struct.TValue* %2, %union.StackValue* %3) #16
  br label %74

; <label>:52:                                     ; preds = %46
  %53 = icmp eq i8 %47, 69
  br i1 %53, label %54, label %69

; <label>:54:                                     ; preds = %52
  %55 = bitcast %struct.TValue* %48 to %struct.Table**
  %56 = load %struct.Table*, %struct.Table** %55, align 8, !tbaa !21
  %57 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %56, %struct.TValue* %2) #16
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 0, i32 1
  %59 = load i8, i8* %58, align 8, !tbaa !22
  %60 = and i8 %59, 15
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %69, label %62

; <label>:62:                                     ; preds = %54
  %63 = getelementptr inbounds %struct.TValue, %struct.TValue* %57, i64 0, i32 1
  %64 = bitcast %struct.TValue* %57 to i64*
  %65 = bitcast %union.StackValue* %3 to i64*
  %66 = load i64, i64* %64, align 8
  store i64 %66, i64* %65, align 8
  %67 = load i8, i8* %63, align 8, !tbaa !22
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %3, i64 0, i32 0, i32 1
  store i8 %67, i8* %68, align 8, !tbaa !22
  br label %74

; <label>:69:                                     ; preds = %52, %54
  %70 = phi %struct.TValue* [ %57, %54 ], [ null, %52 ]
  %71 = add nuw nsw i32 %10, 1
  %72 = icmp ult i32 %71, 2000
  br i1 %72, label %7, label %73

; <label>:73:                                     ; preds = %69
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.198, i64 0, i64 0)) #18
  unreachable

; <label>:74:                                     ; preds = %62, %51, %44
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_getfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2) #16
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_geti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %38

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = bitcast %struct.TValue* %5 to %struct.Table**
  %12 = load %struct.Table*, %struct.Table** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 5
  %14 = load i32, i32* %13, align 4, !tbaa !21
  %15 = zext i32 %14 to i64
  %16 = icmp ult i64 %10, %15
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %9
  %18 = getelementptr inbounds %struct.Table, %struct.Table* %12, i64 0, i32 6
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !21
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %10
  br label %23

; <label>:21:                                     ; preds = %9
  %22 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %12, i64 %2) #16
  br label %23

; <label>:23:                                     ; preds = %21, %17
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %38, label %29

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = bitcast %union.StackValue** %30 to %struct.TValue**
  %32 = load %struct.TValue*, %struct.TValue** %31, align 8, !tbaa !20
  %33 = bitcast %struct.TValue* %24 to i64*
  %34 = bitcast %struct.TValue* %32 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = load i8, i8* %25, align 8, !tbaa !22
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  store i8 %36, i8* %37, align 8, !tbaa !22
  br label %45

; <label>:38:                                     ; preds = %3, %23
  %39 = phi %struct.TValue* [ %24, %23 ], [ null, %3 ]
  %40 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %40) #7
  %41 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %44 = load %union.StackValue*, %union.StackValue** %43, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %union.StackValue* %44, %struct.TValue* %39) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %40) #7
  br label %45

; <label>:45:                                     ; preds = %38, %29
  %46 = phi %union.StackValue** [ %43, %38 ], [ %30, %29 ]
  %47 = load %union.StackValue*, %union.StackValue** %46, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 1
  store %union.StackValue* %48, %union.StackValue** %46, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 0, i32 0, i32 1
  %50 = load i8, i8* %49, align 8, !tbaa !21
  %51 = and i8 %50, 15
  %52 = zext i8 %51 to i32
  ret i32 %52
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_rawget(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %4 = bitcast %struct.TValue* %3 to %struct.Table**
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0
  %9 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %5, %struct.TValue* nonnull %8) #16
  %10 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1
  store %union.StackValue* %11, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %21, label %16

; <label>:16:                                     ; preds = %2
  %17 = bitcast %struct.TValue* %9 to i64*
  %18 = bitcast %union.StackValue* %11 to i64*
  %19 = load i64, i64* %17, align 8
  store i64 %19, i64* %18, align 8
  %20 = load i8, i8* %12, align 8, !tbaa !22
  br label %21

; <label>:21:                                     ; preds = %2, %16
  %22 = phi i8 [ %20, %16 ], [ 0, %2 ]
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 1
  store i8 %22, i8* %23, align 8
  %24 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %6, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 0, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !21
  %28 = and i8 %27, 15
  %29 = zext i8 %28 to i32
  ret i32 %29
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_rawgeti(%struct.lua_State* nocapture, i32, i64) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = bitcast %struct.TValue* %4 to %struct.Table**
  %6 = load %struct.Table*, %struct.Table** %5, align 8, !tbaa !21
  %7 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %6, i64 %2) #16
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = and i8 %9, 15
  %11 = icmp eq i8 %10, 0
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to %struct.TValue**
  %14 = load %struct.TValue*, %struct.TValue** %13, align 8, !tbaa !20
  br i1 %11, label %20, label %15

; <label>:15:                                     ; preds = %3
  %16 = bitcast %struct.TValue* %7 to i64*
  %17 = bitcast %struct.TValue* %14 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = load i8, i8* %8, align 8, !tbaa !22
  br label %20

; <label>:20:                                     ; preds = %3, %15
  %21 = phi i8 [ %19, %15 ], [ 0, %3 ]
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 %21, i8* %22, align 8
  %23 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %12, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 0, i32 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !21
  %27 = and i8 %26, 15
  %28 = zext i8 %27 to i32
  ret i32 %28
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_rawgetp(%struct.lua_State* nocapture, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %7 = bitcast %struct.TValue* %6 to %struct.Table**
  %8 = load %struct.Table*, %struct.Table** %7, align 8, !tbaa !21
  %9 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %10, align 8, !tbaa !22
  %11 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %8, %struct.TValue* nonnull %4) #16
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = bitcast %union.StackValue** %16 to %struct.TValue**
  %18 = load %struct.TValue*, %struct.TValue** %17, align 8, !tbaa !20
  br i1 %15, label %24, label %19

; <label>:19:                                     ; preds = %3
  %20 = bitcast %struct.TValue* %11 to i64*
  %21 = bitcast %struct.TValue* %18 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = load i8, i8* %12, align 8, !tbaa !22
  br label %24

; <label>:24:                                     ; preds = %3, %19
  %25 = phi i8 [ %23, %19 ], [ 0, %3 ]
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 %25, i8* %26, align 8
  %27 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %16, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 0, i32 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !21
  %31 = and i8 %30, 15
  %32 = zext i8 %31 to i32
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %32
}

; Function Attrs: nounwind optsize uwtable
define void @lua_createtable(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 56, i32 5) #17
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %8 = load i8, i8* %7, align 4, !tbaa !15
  %9 = and i8 %8, 24
  %10 = getelementptr inbounds i8, i8* %6, i64 9
  store i8 %9, i8* %10, align 1, !tbaa !70
  %11 = getelementptr inbounds i8, i8* %6, i64 8
  store i8 5, i8* %11, align 8, !tbaa !86
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  %13 = bitcast %struct.GCObject** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !18
  %15 = bitcast i8* %6 to i64*
  store i64 %14, i64* %15, align 8, !tbaa !87
  %16 = bitcast %struct.GCObject** %12 to i8**
  store i8* %6, i8** %16, align 8, !tbaa !18
  %17 = getelementptr inbounds i8, i8* %6, i64 40
  %18 = bitcast i8* %17 to %struct.Table**
  store %struct.Table* null, %struct.Table** %18, align 8, !tbaa !88
  %19 = getelementptr inbounds i8, i8* %6, i64 10
  store i8 -1, i8* %19, align 2, !tbaa !90
  %20 = getelementptr inbounds i8, i8* %6, i64 16
  %21 = bitcast i8* %20 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %21, align 8, !tbaa !91
  %22 = getelementptr inbounds i8, i8* %6, i64 12
  %23 = bitcast i8* %22 to i32*
  store i32 0, i32* %23, align 4, !tbaa !92
  %24 = getelementptr inbounds i8, i8* %6, i64 24
  %25 = getelementptr inbounds i8, i8* %6, i64 11
  store i8 0, i8* %25, align 1, !tbaa !93
  %26 = bitcast i8* %24 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %26, align 8, !tbaa !54
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %28 = bitcast %union.StackValue** %27 to %struct.TValue**
  %29 = load %struct.TValue*, %struct.TValue** %28, align 8, !tbaa !20
  %30 = bitcast %struct.TValue* %29 to i8**
  store i8* %6, i8** %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %29, i64 0, i32 1
  store i8 69, i8* %31, align 8, !tbaa !22
  %32 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 1
  store %union.StackValue* %33, %union.StackValue** %27, align 8, !tbaa !20
  %34 = icmp sgt i32 %1, 0
  %35 = icmp sgt i32 %2, 0
  %36 = or i1 %34, %35
  br i1 %36, label %37, label %39

; <label>:37:                                     ; preds = %3
  %38 = bitcast i8* %6 to %struct.Table*
  tail call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %38, i32 %1, i32 %2) #16
  br label %39

; <label>:39:                                     ; preds = %3, %37
  %40 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %41 = getelementptr inbounds %struct.global_State, %struct.global_State* %40, i64 0, i32 3
  %42 = load i64, i64* %41, align 8, !tbaa !11
  %43 = icmp sgt i64 %42, 0
  br i1 %43, label %44, label %45

; <label>:44:                                     ; preds = %39
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %45

; <label>:45:                                     ; preds = %44, %39
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaH_resize(%struct.lua_State*, %struct.Table*, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.Table, align 8
  %7 = bitcast %struct.Table* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %7) #7
  %8 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1) #17
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %8, i32* %9, align 4, !tbaa !92
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !146
  %12 = and i8 %11, 127
  store i8 %12, i8* %10, align 1, !tbaa !146
  %13 = icmp eq i32 %3, 0
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %4
  %15 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %16 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 0, i8* %16, align 1, !tbaa !93
  %17 = bitcast %union.Node** %15 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %17, align 8, !tbaa !54
  br label %63

; <label>:18:                                     ; preds = %4
  %19 = add i32 %3, -1
  %20 = icmp ugt i32 %19, 255
  br i1 %20, label %21, label %28

; <label>:21:                                     ; preds = %18
  br label %22

; <label>:22:                                     ; preds = %21, %22
  %23 = phi i32 [ %25, %22 ], [ 0, %21 ]
  %24 = phi i32 [ %26, %22 ], [ %19, %21 ]
  %25 = add nuw nsw i32 %23, 8
  %26 = lshr i32 %24, 8
  %27 = icmp ugt i32 %24, 65535
  br i1 %27, label %22, label %28

; <label>:28:                                     ; preds = %22, %18
  %29 = phi i32 [ %19, %18 ], [ %26, %22 ]
  %30 = phi i32 [ 0, %18 ], [ %25, %22 ]
  %31 = zext i32 %29 to i64
  %32 = getelementptr inbounds [256 x i8], [256 x i8]* @luaO_ceillog2.log_2, i64 0, i64 %31
  %33 = load i8, i8* %32, align 1, !tbaa !21
  %34 = zext i8 %33 to i32
  %35 = add nuw nsw i32 %30, %34
  %36 = icmp sgt i32 %35, 30
  br i1 %36, label %40, label %37

; <label>:37:                                     ; preds = %28
  %38 = shl i32 1, %35
  %39 = icmp ugt i32 %35, 30
  br i1 %39, label %40, label %41

; <label>:40:                                     ; preds = %37, %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.199, i64 0, i64 0)) #19
  unreachable

; <label>:41:                                     ; preds = %37
  %42 = zext i32 %38 to i64
  %43 = mul nuw nsw i64 %42, 24
  %44 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %43, i32 0) #17
  %45 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %46 = bitcast %union.Node** %45 to i8**
  store i8* %44, i8** %46, align 8, !tbaa !156
  %47 = bitcast i8* %44 to %union.Node*
  %48 = ptrtoint i8* %44 to i64
  %49 = sext i32 %38 to i64
  br label %50

; <label>:50:                                     ; preds = %41, %50
  %51 = phi i64 [ 0, %41 ], [ %55, %50 ]
  %52 = getelementptr inbounds %union.Node, %union.Node* %47, i64 %51, i32 0, i32 3
  store i32 0, i32* %52, align 4, !tbaa !21
  %53 = getelementptr inbounds %union.Node, %union.Node* %47, i64 %51, i32 0, i32 2
  store i8 0, i8* %53, align 1, !tbaa !21
  %54 = getelementptr inbounds %union.Node, %union.Node* %47, i64 %51, i32 0, i32 1
  store i8 16, i8* %54, align 8, !tbaa !21
  %55 = add nuw nsw i64 %51, 1
  %56 = icmp slt i64 %55, %49
  br i1 %56, label %50, label %57

; <label>:57:                                     ; preds = %50
  %58 = trunc i32 %35 to i8
  %59 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %58, i8* %59, align 1, !tbaa !93
  %60 = getelementptr inbounds %union.Node, %union.Node* %47, i64 %42
  %61 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 8
  store %union.Node* %60, %union.Node** %61, align 8, !tbaa !147
  %62 = ptrtoint %union.Node* %60 to i64
  br label %63

; <label>:63:                                     ; preds = %14, %57
  %64 = phi i64 [ 0, %14 ], [ %62, %57 ]
  %65 = phi i64 [ ptrtoint (%union.Node* @dummynode_ to i64), %14 ], [ %48, %57 ]
  %66 = phi i8 [ 0, %14 ], [ %58, %57 ]
  %67 = icmp ugt i32 %8, %2
  br i1 %67, label %71, label %68

; <label>:68:                                     ; preds = %63
  %69 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %70 = zext i32 %2 to i64
  br label %107

; <label>:71:                                     ; preds = %63
  store i32 %2, i32* %9, align 4, !tbaa !92
  %72 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %73 = load i8, i8* %72, align 1, !tbaa !93
  %74 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %75 = bitcast %union.Node** %74 to i64*
  %76 = load i64, i64* %75, align 8, !tbaa !156
  %77 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %78 = bitcast %union.Node** %77 to i64*
  %79 = load i64, i64* %78, align 8, !tbaa !147
  %80 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %66, i8* %72, align 1, !tbaa !93
  %81 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %82 = bitcast %union.Node** %81 to i64*
  store i64 %65, i64* %75, align 8, !tbaa !156
  %83 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 8
  %84 = bitcast %union.Node** %83 to i64*
  store i64 %64, i64* %78, align 8, !tbaa !147
  store i8 %73, i8* %80, align 1, !tbaa !93
  store i64 %76, i64* %82, align 8, !tbaa !156
  store i64 %79, i64* %84, align 8, !tbaa !147
  %85 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %86 = zext i32 %2 to i64
  %87 = zext i32 %8 to i64
  br label %88

; <label>:88:                                     ; preds = %100, %71
  %89 = phi i64 [ %86, %71 ], [ %101, %100 ]
  %90 = load %struct.TValue*, %struct.TValue** %85, align 8, !tbaa !91
  %91 = getelementptr inbounds %struct.TValue, %struct.TValue* %90, i64 %89, i32 1
  %92 = load i8, i8* %91, align 8, !tbaa !22
  %93 = and i8 %92, 15
  %94 = icmp eq i8 %93, 0
  br i1 %94, label %95, label %97

; <label>:95:                                     ; preds = %88
  %96 = add nuw nsw i64 %89, 1
  br label %100

; <label>:97:                                     ; preds = %88
  %98 = getelementptr inbounds %struct.TValue, %struct.TValue* %90, i64 %89
  %99 = add nuw nsw i64 %89, 1
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* nonnull %1, i64 %99, %struct.TValue* %98) #16
  br label %100

; <label>:100:                                    ; preds = %95, %97
  %101 = phi i64 [ %96, %95 ], [ %99, %97 ]
  %102 = icmp eq i64 %101, %87
  br i1 %102, label %103, label %88

; <label>:103:                                    ; preds = %100
  store i32 %8, i32* %9, align 4, !tbaa !92
  %104 = load i8, i8* %72, align 1, !tbaa !93
  %105 = load i64, i64* %75, align 8, !tbaa !156
  %106 = load i64, i64* %78, align 8, !tbaa !147
  store i8 %73, i8* %72, align 1, !tbaa !93
  store i64 %76, i64* %75, align 8, !tbaa !156
  store i64 %79, i64* %78, align 8, !tbaa !147
  store i8 %104, i8* %80, align 1, !tbaa !93
  store i64 %105, i64* %82, align 8, !tbaa !156
  store i64 %106, i64* %84, align 8, !tbaa !147
  br label %107

; <label>:107:                                    ; preds = %68, %103
  %108 = phi i64 [ %70, %68 ], [ %86, %103 ]
  %109 = phi %struct.TValue** [ %69, %68 ], [ %85, %103 ]
  %110 = phi i64 [ %64, %68 ], [ %106, %103 ]
  %111 = phi i64 [ %65, %68 ], [ %105, %103 ]
  %112 = phi i8 [ %66, %68 ], [ %104, %103 ]
  %113 = zext i32 %8 to i64
  %114 = bitcast %struct.TValue** %109 to i8**
  %115 = load i8*, i8** %114, align 8, !tbaa !91
  %116 = shl nuw nsw i64 %113, 4
  %117 = shl nuw nsw i64 %108, 4
  %118 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %115, i64 %116, i64 %117) #16
  %119 = icmp eq i8* %118, null
  %120 = icmp ne i32 %2, 0
  %121 = and i1 %120, %119
  br i1 %121, label %122, label %123, !prof !61

; <label>:122:                                    ; preds = %107
  call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* nonnull %6) #16
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:123:                                    ; preds = %107
  %124 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %125 = load i8, i8* %124, align 1, !tbaa !93
  %126 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %127 = bitcast %union.Node** %126 to i64*
  %128 = load i64, i64* %127, align 8, !tbaa !156
  %129 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %130 = bitcast %union.Node** %129 to i64*
  %131 = load i64, i64* %130, align 8, !tbaa !147
  %132 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 4
  store i8 %112, i8* %124, align 1, !tbaa !93
  %133 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 7
  %134 = bitcast %union.Node** %133 to i64*
  store i64 %111, i64* %127, align 8, !tbaa !156
  %135 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 8
  %136 = bitcast %union.Node** %135 to i64*
  store i64 %110, i64* %130, align 8, !tbaa !147
  store i8 %125, i8* %132, align 1, !tbaa !93
  store i64 %128, i64* %134, align 8, !tbaa !156
  store i64 %131, i64* %136, align 8, !tbaa !147
  store i8* %118, i8** %114, align 8, !tbaa !91
  store i32 %2, i32* %9, align 4, !tbaa !92
  %137 = icmp ult i32 %8, %2
  %138 = bitcast i8* %118 to %struct.TValue*
  %139 = inttoptr i64 %128 to %union.Node*
  %140 = inttoptr i64 %128 to i8*
  br i1 %137, label %141, label %147

; <label>:141:                                    ; preds = %123
  br label %142

; <label>:142:                                    ; preds = %141, %142
  %143 = phi i64 [ %145, %142 ], [ %113, %141 ]
  %144 = getelementptr inbounds %struct.TValue, %struct.TValue* %138, i64 %143, i32 1
  store i8 16, i8* %144, align 8, !tbaa !22
  %145 = add nuw nsw i64 %143, 1
  %146 = icmp eq i64 %145, %108
  br i1 %146, label %147, label %142

; <label>:147:                                    ; preds = %142, %123
  %148 = zext i8 %125 to i32
  %149 = shl i32 1, %148
  %150 = icmp eq i8 %125, 31
  br i1 %150, label %178, label %151

; <label>:151:                                    ; preds = %147
  %152 = bitcast %struct.TValue* %5 to i8*
  %153 = bitcast %struct.TValue* %5 to i64*
  %154 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %155 = sext i32 %149 to i64
  br label %156

; <label>:156:                                    ; preds = %151, %175
  %157 = phi i64 [ 0, %151 ], [ %176, %175 ]
  %158 = getelementptr inbounds %union.Node, %union.Node* %139, i64 %157, i32 0, i32 1
  %159 = load i8, i8* %158, align 8, !tbaa !21
  %160 = and i8 %159, 15
  %161 = icmp eq i8 %160, 0
  br i1 %161, label %175, label %162

; <label>:162:                                    ; preds = %156
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %152) #7
  %163 = getelementptr inbounds %union.Node, %union.Node* %139, i64 %157, i32 0, i32 4
  %164 = bitcast %union.Value* %163 to i64*
  %165 = load i64, i64* %164, align 8
  store i64 %165, i64* %153, align 8
  %166 = getelementptr inbounds %union.Node, %union.Node* %139, i64 %157, i32 0, i32 2
  %167 = load i8, i8* %166, align 1, !tbaa !21
  store i8 %167, i8* %154, align 8, !tbaa !22
  %168 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %5) #17
  %169 = getelementptr inbounds %union.Node, %union.Node* %139, i64 %157, i32 0, i32 0
  %170 = bitcast %union.Value* %169 to i64*
  %171 = bitcast %struct.TValue* %168 to i64*
  %172 = load i64, i64* %170, align 8
  store i64 %172, i64* %171, align 8
  %173 = load i8, i8* %158, align 8, !tbaa !22
  %174 = getelementptr inbounds %struct.TValue, %struct.TValue* %168, i64 0, i32 1
  store i8 %173, i8* %174, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %152) #7
  br label %175

; <label>:175:                                    ; preds = %162, %156
  %176 = add nuw nsw i64 %157, 1
  %177 = icmp slt i64 %176, %155
  br i1 %177, label %156, label %178

; <label>:178:                                    ; preds = %175, %147
  %179 = icmp eq i64 %131, 0
  br i1 %179, label %193, label %180

; <label>:180:                                    ; preds = %178
  %181 = sext i32 %149 to i64
  %182 = mul nsw i64 %181, 24
  %183 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %184 = load %struct.global_State*, %struct.global_State** %183, align 8, !tbaa !2
  %185 = getelementptr inbounds %struct.global_State, %struct.global_State* %184, i64 0, i32 0
  %186 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %185, align 8, !tbaa !59
  %187 = getelementptr inbounds %struct.global_State, %struct.global_State* %184, i64 0, i32 1
  %188 = load i8*, i8** %187, align 8, !tbaa !60
  %189 = tail call i8* %186(i8* %188, i8* %140, i64 %182, i64 0) #17
  %190 = getelementptr inbounds %struct.global_State, %struct.global_State* %184, i64 0, i32 3
  %191 = load i64, i64* %190, align 8, !tbaa !11
  %192 = sub i64 %191, %182
  store i64 %192, i64* %190, align 8, !tbaa !11
  br label %193

; <label>:193:                                    ; preds = %178, %180
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %7) #7
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_getmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #2 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %2
  %8 = bitcast %struct.TValue* %3 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %3 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %2
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  br i1 %24, label %33, label %25

; <label>:25:                                     ; preds = %21
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %28 to %struct.Table**
  store %struct.Table* %23, %struct.Table** %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 69, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %26, align 8, !tbaa !20
  br label %33

; <label>:33:                                     ; preds = %21, %25
  %34 = phi i32 [ 1, %25 ], [ 0, %21 ]
  ret i32 %34
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_getiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = icmp slt i32 %2, 1
  br i1 %4, label %13, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = bitcast %struct.TValue* %6 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp slt i32 %11, %2
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %5, %3
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 0, i8* %17, align 8, !tbaa !21
  %18 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  br label %38

; <label>:19:                                     ; preds = %5
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = bitcast %union.StackValue** %20 to %struct.TValue**
  %22 = load %struct.TValue*, %struct.TValue** %21, align 8, !tbaa !20
  %23 = add nsw i32 %2, -1
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %24, i32 0
  %26 = bitcast %struct.TValue* %25 to i64*
  %27 = bitcast %struct.TValue* %22 to i64*
  %28 = load i64, i64* %26, align 8
  store i64 %28, i64* %27, align 8
  %29 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %24, i32 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %22, i64 0, i32 1
  store i8 %30, i8* %31, align 8, !tbaa !22
  %32 = load %struct.TValue*, %struct.TValue** %21, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !21
  %35 = and i8 %34, 15
  %36 = zext i8 %35 to i32
  %37 = bitcast %struct.TValue* %32 to %union.StackValue*
  br label %38

; <label>:38:                                     ; preds = %19, %13
  %39 = phi %union.StackValue** [ %20, %19 ], [ %14, %13 ]
  %40 = phi %union.StackValue* [ %37, %19 ], [ %18, %13 ]
  %41 = phi i32 [ %36, %19 ], [ -1, %13 ]
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %42, %union.StackValue** %39, align 8, !tbaa !20
  ret i32 %41
}

; Function Attrs: nounwind optsize uwtable
define void @lua_setglobal(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7, i32 0, i32 0
  %6 = bitcast %struct.GCObject** %5 to %struct.Table**
  %7 = load %struct.Table*, %struct.Table** %6, align 8, !tbaa !21
  %8 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %7, i64 2) #16
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %8, i8* %1) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @auxsetstr(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 69
  br i1 %7, label %8, label %49

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %10 = bitcast %struct.TValue* %1 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = tail call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %11, %struct.TString* %4) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %49, label %17

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %12 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  store i8 %25, i8* %13, align 8, !tbaa !22
  %26 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !21
  %29 = and i8 %28, 64
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %46, label %31

; <label>:31:                                     ; preds = %17
  %32 = load %struct.GCObject*, %struct.GCObject** %9, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !70
  %35 = and i8 %34, 32
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %46, label %37

; <label>:37:                                     ; preds = %31
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -1, i32 0, i32 0, i32 0
  %39 = load %struct.GCObject*, %struct.GCObject** %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %39, i64 0, i32 2
  %41 = load i8, i8* %40, align 1, !tbaa !70
  %42 = and i8 %41, 24
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %46, label %44

; <label>:44:                                     ; preds = %37
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %32) #16
  %45 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  br label %46

; <label>:46:                                     ; preds = %37, %31, %17, %44
  %47 = phi %union.StackValue* [ %26, %37 ], [ %26, %31 ], [ %26, %17 ], [ %45, %44 ]
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  br label %65

; <label>:49:                                     ; preds = %3, %8
  %50 = phi %struct.TValue* [ %12, %8 ], [ null, %3 ]
  %51 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %52 = bitcast %union.StackValue** %51 to %struct.TValue**
  %53 = load %struct.TValue*, %struct.TValue** %52, align 8, !tbaa !20
  %54 = bitcast %struct.TValue* %53 to %struct.TString**
  store %struct.TString* %4, %struct.TString** %54, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.TString, %struct.TString* %4, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !75
  %57 = or i8 %56, 64
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  store i8 %57, i8* %58, align 8, !tbaa !22
  %59 = load %union.StackValue*, %union.StackValue** %51, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 1
  store %union.StackValue* %60, %union.StackValue** %51, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 0, i32 0
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %61, %struct.TValue* nonnull %62, %struct.TValue* %50) #16
  %63 = load %union.StackValue*, %union.StackValue** %51, align 8, !tbaa !20
  %64 = getelementptr inbounds %union.StackValue, %union.StackValue* %63, i64 -2
  br label %65

; <label>:65:                                     ; preds = %49, %46
  %66 = phi %union.StackValue** [ %51, %49 ], [ %18, %46 ]
  %67 = phi %union.StackValue* [ %64, %49 ], [ %48, %46 ]
  store %union.StackValue* %67, %union.StackValue** %66, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_settable(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = icmp eq i8 %5, 69
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %48

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %11 = bitcast %struct.TValue* %3 to %struct.Table**
  %12 = load %struct.Table*, %struct.Table** %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -2, i32 0
  %16 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %12, %struct.TValue* nonnull %15) #16
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = and i8 %18, 15
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %48, label %21

; <label>:21:                                     ; preds = %9
  %22 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1, i32 0
  %24 = bitcast %struct.TValue* %23 to i64*
  %25 = bitcast %struct.TValue* %16 to i64*
  %26 = load i64, i64* %24, align 8
  store i64 %26, i64* %25, align 8
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 -1, i32 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  store i8 %28, i8* %17, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !21
  %32 = and i8 %31, 64
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %54, label %34

; <label>:34:                                     ; preds = %21
  %35 = load %struct.GCObject*, %struct.GCObject** %10, align 8, !tbaa !21
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %35, i64 0, i32 2
  %37 = load i8, i8* %36, align 1, !tbaa !70
  %38 = and i8 %37, 32
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %54, label %40

; <label>:40:                                     ; preds = %34
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0, i32 0, i32 0
  %42 = load %struct.GCObject*, %struct.GCObject** %41, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %42, i64 0, i32 2
  %44 = load i8, i8* %43, align 1, !tbaa !70
  %45 = and i8 %44, 24
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %54, label %47

; <label>:47:                                     ; preds = %40
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %35) #16
  br label %54

; <label>:48:                                     ; preds = %7, %9
  %49 = phi %union.StackValue** [ %8, %7 ], [ %13, %9 ]
  %50 = phi %struct.TValue* [ null, %7 ], [ %16, %9 ]
  %51 = load %union.StackValue*, %union.StackValue** %49, align 8, !tbaa !20
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 -2, i32 0
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 -1, i32 0
  tail call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %3, %struct.TValue* nonnull %52, %struct.TValue* nonnull %53, %struct.TValue* %50) #16
  br label %54

; <label>:54:                                     ; preds = %40, %34, %21, %47, %48
  %55 = phi %union.StackValue** [ %13, %40 ], [ %13, %34 ], [ %13, %21 ], [ %13, %47 ], [ %49, %48 ]
  %56 = load %union.StackValue*, %union.StackValue** %55, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 -2
  store %union.StackValue* %57, %union.StackValue** %55, align 8, !tbaa !20
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @luaC_barrierback_(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %4 = load i8, i8* %3, align 1, !tbaa !70
  %5 = and i8 %4, 7
  %6 = icmp eq i8 %5, 6
  br i1 %6, label %15, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %9, i64 0, i32 24
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !157
  %13 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %1) #16
  %14 = bitcast %struct.GCObject** %13 to i64*
  store i64 %12, i64* %14, align 8, !tbaa !54
  store %struct.GCObject* %1, %struct.GCObject** %10, align 8, !tbaa !157
  br label %15

; <label>:15:                                     ; preds = %2, %7
  %16 = and i8 %4, -40
  %17 = or i8 %16, 5
  store i8 %17, i8* %3, align 1, !tbaa !70
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaV_finishset(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %7

; <label>:7:                                      ; preds = %5, %157
  %8 = phi %struct.TValue* [ %1, %5 ], [ %81, %157 ]
  %9 = phi %struct.TValue* [ %4, %5 ], [ %158, %157 ]
  %10 = phi i32 [ 0, %5 ], [ %159, %157 ]
  %11 = icmp eq %struct.TValue* %9, null
  br i1 %11, label %71, label %12

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 0, i32 0
  %14 = load %struct.GCObject*, %struct.GCObject** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 2, i32 1
  %16 = bitcast i8* %15 to %struct.Table**
  %17 = load %struct.Table*, %struct.Table** %16, align 8, !tbaa !88
  %18 = icmp eq %struct.Table* %17, null
  br i1 %18, label %38, label %19

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 3
  %21 = load i8, i8* %20, align 2, !tbaa !90
  %22 = and i8 %21, 2
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %38

; <label>:24:                                     ; preds = %19
  %25 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 40, i64 1
  %27 = load %struct.TString*, %struct.TString** %26, align 8, !tbaa !54
  %28 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %17, %struct.TString* %27) #17
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = and i8 %30, 15
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %33, label %36

; <label>:33:                                     ; preds = %24
  %34 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 3
  %35 = or i8 %21, 2
  store i8 %35, i8* %34, align 2, !tbaa !90
  br label %38

; <label>:36:                                     ; preds = %24
  %37 = icmp eq %struct.TValue* %28, null
  br i1 %37, label %38, label %78

; <label>:38:                                     ; preds = %19, %12, %36, %33
  %39 = bitcast %struct.GCObject* %14 to %struct.Table*
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = icmp eq i8 %41, 32
  br i1 %42, label %43, label %46

; <label>:43:                                     ; preds = %38
  %44 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %39, %struct.TValue* %2) #16
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %44, i64 0, i32 1
  br label %46

; <label>:46:                                     ; preds = %43, %38
  %47 = phi i8* [ %45, %43 ], [ %40, %38 ]
  %48 = phi %struct.TValue* [ %44, %43 ], [ %9, %38 ]
  %49 = bitcast %struct.TValue* %3 to i64*
  %50 = bitcast %struct.TValue* %48 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  store i8 %53, i8* %47, align 8, !tbaa !22
  %54 = getelementptr inbounds %struct.Table, %struct.Table* %39, i64 0, i32 3
  store i8 0, i8* %54, align 2, !tbaa !90
  %55 = load i8, i8* %52, align 8, !tbaa !22
  %56 = and i8 %55, 64
  %57 = icmp eq i8 %56, 0
  br i1 %57, label %162, label %58

; <label>:58:                                     ; preds = %46
  %59 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %14, i64 0, i32 2
  %60 = load i8, i8* %59, align 1, !tbaa !21
  %61 = and i8 %60, 32
  %62 = icmp eq i8 %61, 0
  br i1 %62, label %162, label %63

; <label>:63:                                     ; preds = %58
  %64 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %65 = load %struct.GCObject*, %struct.GCObject** %64, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %65, i64 0, i32 2
  %67 = load i8, i8* %66, align 1, !tbaa !70
  %68 = and i8 %67, 24
  %69 = icmp eq i8 %68, 0
  br i1 %69, label %162, label %70

; <label>:70:                                     ; preds = %63
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %14) #16
  br label %162

; <label>:71:                                     ; preds = %7
  %72 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %8, i32 1) #16
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %72, i64 0, i32 1
  %74 = load i8, i8* %73, align 8, !tbaa !22
  %75 = and i8 %74, 15
  %76 = icmp eq i8 %75, 0
  br i1 %76, label %77, label %78, !prof !61

; <label>:77:                                     ; preds = %71
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %8, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.197, i64 0, i64 0)) #18
  unreachable

; <label>:78:                                     ; preds = %36, %71
  %79 = phi i8* [ %29, %36 ], [ %73, %71 ]
  %80 = phi i8 [ %30, %36 ], [ %74, %71 ]
  %81 = phi %struct.TValue* [ %28, %36 ], [ %72, %71 ]
  %82 = and i8 %80, 15
  %83 = icmp eq i8 %82, 6
  br i1 %83, label %84, label %122

; <label>:84:                                     ; preds = %78
  %85 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %86 = load %union.StackValue*, %union.StackValue** %85, align 8, !tbaa !20
  %87 = bitcast %struct.TValue* %81 to i64*
  %88 = bitcast %union.StackValue* %86 to i64*
  %89 = load i64, i64* %87, align 8
  store i64 %89, i64* %88, align 8
  %90 = load i8, i8* %79, align 8, !tbaa !22
  %91 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 0, i32 0, i32 1
  store i8 %90, i8* %91, align 8, !tbaa !22
  %92 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 1, i32 0
  %93 = bitcast %struct.TValue* %8 to i64*
  %94 = bitcast %struct.TValue* %92 to i64*
  %95 = load i64, i64* %93, align 8
  store i64 %95, i64* %94, align 8
  %96 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %97 = load i8, i8* %96, align 8, !tbaa !22
  %98 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 1, i32 0, i32 1
  store i8 %97, i8* %98, align 8, !tbaa !22
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 2, i32 0
  %100 = bitcast %struct.TValue* %2 to i64*
  %101 = bitcast %struct.TValue* %99 to i64*
  %102 = load i64, i64* %100, align 8
  store i64 %102, i64* %101, align 8
  %103 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !22
  %105 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 2, i32 0, i32 1
  store i8 %104, i8* %105, align 8, !tbaa !22
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 3, i32 0
  %107 = bitcast %struct.TValue* %3 to i64*
  %108 = bitcast %struct.TValue* %106 to i64*
  %109 = load i64, i64* %107, align 8
  store i64 %109, i64* %108, align 8
  %110 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %111 = load i8, i8* %110, align 8, !tbaa !22
  %112 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 3, i32 0, i32 1
  store i8 %111, i8* %112, align 8, !tbaa !22
  %113 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 4
  store %union.StackValue* %113, %union.StackValue** %85, align 8, !tbaa !20
  %114 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %115 = load %struct.CallInfo*, %struct.CallInfo** %114, align 8, !tbaa !24
  %116 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %115, i64 0, i32 7
  %117 = load i16, i16* %116, align 2, !tbaa !63
  %118 = and i16 %117, 6
  %119 = icmp eq i16 %118, 0
  br i1 %119, label %120, label %121

; <label>:120:                                    ; preds = %84
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %86, i32 0) #17
  br label %162

; <label>:121:                                    ; preds = %84
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %86, i32 0) #17
  br label %162

; <label>:122:                                    ; preds = %78
  %123 = icmp eq i8 %80, 69
  br i1 %123, label %124, label %157

; <label>:124:                                    ; preds = %122
  %125 = bitcast %struct.TValue* %81 to %struct.Table**
  %126 = load %struct.Table*, %struct.Table** %125, align 8, !tbaa !21
  %127 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %126, %struct.TValue* %2) #16
  %128 = getelementptr inbounds %struct.TValue, %struct.TValue* %127, i64 0, i32 1
  %129 = load i8, i8* %128, align 8, !tbaa !22
  %130 = and i8 %129, 15
  %131 = icmp eq i8 %130, 0
  br i1 %131, label %157, label %132

; <label>:132:                                    ; preds = %124
  %133 = getelementptr inbounds %struct.TValue, %struct.TValue* %127, i64 0, i32 1
  %134 = bitcast %struct.TValue* %3 to i64*
  %135 = bitcast %struct.TValue* %127 to i64*
  %136 = load i64, i64* %134, align 8
  store i64 %136, i64* %135, align 8
  %137 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %138 = load i8, i8* %137, align 8, !tbaa !22
  store i8 %138, i8* %133, align 8, !tbaa !22
  %139 = load i8, i8* %137, align 8, !tbaa !22
  %140 = and i8 %139, 64
  %141 = icmp eq i8 %140, 0
  br i1 %141, label %162, label %142

; <label>:142:                                    ; preds = %132
  %143 = getelementptr inbounds %struct.TValue, %struct.TValue* %81, i64 0, i32 0, i32 0
  %144 = load %struct.GCObject*, %struct.GCObject** %143, align 8, !tbaa !21
  %145 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %144, i64 0, i32 2
  %146 = load i8, i8* %145, align 1, !tbaa !70
  %147 = and i8 %146, 32
  %148 = icmp eq i8 %147, 0
  br i1 %148, label %162, label %149

; <label>:149:                                    ; preds = %142
  %150 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %151 = load %struct.GCObject*, %struct.GCObject** %150, align 8, !tbaa !21
  %152 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %151, i64 0, i32 2
  %153 = load i8, i8* %152, align 1, !tbaa !70
  %154 = and i8 %153, 24
  %155 = icmp eq i8 %154, 0
  br i1 %155, label %162, label %156

; <label>:156:                                    ; preds = %149
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %144) #16
  br label %162

; <label>:157:                                    ; preds = %122, %124
  %158 = phi %struct.TValue* [ %127, %124 ], [ null, %122 ]
  %159 = add nuw nsw i32 %10, 1
  %160 = icmp ult i32 %159, 2000
  br i1 %160, label %7, label %161

; <label>:161:                                    ; preds = %157
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.200, i64 0, i64 0)) #18
  unreachable

; <label>:162:                                    ; preds = %70, %46, %58, %63, %149, %142, %132, %156, %120, %121
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_setfield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_seti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %58

; <label>:9:                                      ; preds = %3
  %10 = add i64 %2, -1
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 0, i32 0
  %12 = bitcast %struct.TValue* %5 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 5
  %15 = load i32, i32* %14, align 4, !tbaa !21
  %16 = zext i32 %15 to i64
  %17 = icmp ult i64 %10, %16
  br i1 %17, label %18, label %22

; <label>:18:                                     ; preds = %9
  %19 = getelementptr inbounds %struct.Table, %struct.Table* %13, i64 0, i32 6
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 %10
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %13, i64 %2) #16
  br label %24

; <label>:24:                                     ; preds = %22, %18
  %25 = phi %struct.TValue* [ %21, %18 ], [ %23, %22 ]
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = and i8 %27, 15
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %58, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0
  %34 = bitcast %struct.TValue* %33 to i64*
  %35 = bitcast %struct.TValue* %25 to i64*
  %36 = load i64, i64* %34, align 8
  store i64 %36, i64* %35, align 8
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  store i8 %38, i8* %26, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !21
  %42 = and i8 %41, 64
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %66, label %44

; <label>:44:                                     ; preds = %30
  %45 = load %struct.GCObject*, %struct.GCObject** %11, align 8, !tbaa !21
  %46 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %45, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !70
  %48 = and i8 %47, 32
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %66, label %50

; <label>:50:                                     ; preds = %44
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0, i32 0, i32 0
  %52 = load %struct.GCObject*, %struct.GCObject** %51, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %52, i64 0, i32 2
  %54 = load i8, i8* %53, align 1, !tbaa !70
  %55 = and i8 %54, 24
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %66, label %57

; <label>:57:                                     ; preds = %50
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %45) #16
  br label %66

; <label>:58:                                     ; preds = %3, %24
  %59 = phi %struct.TValue* [ %25, %24 ], [ null, %3 ]
  %60 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %60) #7
  %61 = bitcast %struct.TValue* %4 to i64*
  store i64 %2, i64* %61, align 8, !tbaa !21
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %62, align 8, !tbaa !22
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %64 = load %union.StackValue*, %union.StackValue** %63, align 8, !tbaa !20
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 -1, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %5, %struct.TValue* nonnull %4, %struct.TValue* nonnull %65, %struct.TValue* %59) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %60) #7
  br label %66

; <label>:66:                                     ; preds = %50, %44, %30, %57, %58
  %67 = phi %union.StackValue** [ %31, %50 ], [ %31, %44 ], [ %31, %30 ], [ %31, %57 ], [ %63, %58 ]
  %68 = load %union.StackValue*, %union.StackValue** %67, align 8, !tbaa !20
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1
  store %union.StackValue* %69, %union.StackValue** %67, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_rawset(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %4 = bitcast %struct.TValue* %3 to %struct.Table**
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -2, i32 0
  %9 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %5, %struct.TValue* nonnull %8) #16
  %10 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0
  %12 = bitcast %struct.TValue* %11 to i64*
  %13 = bitcast %struct.TValue* %9 to i64*
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %13, align 8
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 %16, i8* %17, align 8, !tbaa !22
  %18 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 3
  store i8 0, i8* %18, align 2, !tbaa !90
  %19 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !21
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %39, label %24

; <label>:24:                                     ; preds = %2
  %25 = bitcast %struct.Table* %5 to %struct.GCObject*
  %26 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 2
  %27 = load i8, i8* %26, align 1, !tbaa !21
  %28 = and i8 %27, 32
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %39, label %30

; <label>:30:                                     ; preds = %24
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %32, i64 0, i32 2
  %34 = load i8, i8* %33, align 1, !tbaa !70
  %35 = and i8 %34, 24
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %39, label %37

; <label>:37:                                     ; preds = %30
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %25) #16
  %38 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  br label %39

; <label>:39:                                     ; preds = %30, %24, %2, %37
  %40 = phi %union.StackValue* [ %19, %30 ], [ %19, %24 ], [ %19, %2 ], [ %38, %37 ]
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 -2
  store %union.StackValue* %41, %union.StackValue** %6, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_set(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @luaH_get(%struct.Table* %1, %struct.TValue* %2) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = icmp eq i8 %6, 32
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %2) #16
  br label %10

; <label>:10:                                     ; preds = %3, %8
  %11 = phi %struct.TValue* [ %9, %8 ], [ %4, %3 ]
  ret %struct.TValue* %11
}

; Function Attrs: nounwind optsize uwtable
define void @lua_rawseti(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = bitcast %struct.TValue* %4 to %struct.Table**
  %6 = load %struct.Table*, %struct.Table** %5, align 8, !tbaa !21
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  tail call fastcc void @luaH_setint(%struct.lua_State* %0, %struct.Table* %6, i64 %2, %struct.TValue* nonnull %9) #16
  %10 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !21
  %13 = and i8 %12, 64
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %30, label %15

; <label>:15:                                     ; preds = %3
  %16 = bitcast %struct.Table* %6 to %struct.GCObject*
  %17 = getelementptr inbounds %struct.Table, %struct.Table* %6, i64 0, i32 2
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = and i8 %18, 32
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %30, label %21

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 0, i32 0
  %23 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %23, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !70
  %26 = and i8 %25, 24
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %30, label %28

; <label>:28:                                     ; preds = %21
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %16) #16
  %29 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  br label %30

; <label>:30:                                     ; preds = %21, %15, %3, %28
  %31 = phi %union.StackValue* [ %10, %21 ], [ %10, %15 ], [ %10, %3 ], [ %29, %28 ]
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -1
  store %union.StackValue* %32, %union.StackValue** %7, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaH_setint(%struct.lua_State*, %struct.Table*, i64, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %1, i64 %2) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = icmp eq i8 %8, 32
  br i1 %9, label %10, label %16

; <label>:10:                                     ; preds = %4
  %11 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #7
  %12 = bitcast %struct.TValue* %5 to i64*
  store i64 %2, i64* %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @luaH_newkey(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #7
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  br label %16

; <label>:16:                                     ; preds = %4, %10
  %17 = phi i8* [ %7, %4 ], [ %15, %10 ]
  %18 = phi %struct.TValue* [ %6, %4 ], [ %14, %10 ]
  %19 = bitcast %struct.TValue* %3 to i64*
  %20 = bitcast %struct.TValue* %18 to i64*
  %21 = load i64, i64* %19, align 8
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  store i8 %23, i8* %17, align 8, !tbaa !22
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_rawsetp(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %7 = bitcast %struct.TValue* %6 to %struct.Table**
  %8 = load %struct.Table*, %struct.Table** %7, align 8, !tbaa !21
  %9 = bitcast %struct.TValue* %4 to i8**
  store i8* %2, i8** %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %10, align 8, !tbaa !22
  %11 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %8, %struct.TValue* nonnull %4) #16
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  %15 = bitcast %struct.TValue* %14 to i64*
  %16 = bitcast %struct.TValue* %11 to i64*
  %17 = load i64, i64* %15, align 8
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 %19, i8* %20, align 8, !tbaa !22
  %21 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !21
  %24 = and i8 %23, 64
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %41, label %26

; <label>:26:                                     ; preds = %3
  %27 = bitcast %struct.Table* %8 to %struct.GCObject*
  %28 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 2
  %29 = load i8, i8* %28, align 1, !tbaa !21
  %30 = and i8 %29, 32
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %41, label %32

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 0, i32 0
  %34 = load %struct.GCObject*, %struct.GCObject** %33, align 8, !tbaa !21
  %35 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %34, i64 0, i32 2
  %36 = load i8, i8* %35, align 1, !tbaa !70
  %37 = and i8 %36, 24
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %41, label %39

; <label>:39:                                     ; preds = %32
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %27) #16
  %40 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  br label %41

; <label>:41:                                     ; preds = %32, %26, %3, %39
  %42 = phi %union.StackValue* [ %21, %32 ], [ %21, %26 ], [ %21, %3 ], [ %40, %39 ]
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -1
  store %union.StackValue* %43, %union.StackValue** %12, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_setmetatable(%struct.lua_State* nocapture, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !21
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %15, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 0, i32 0
  %12 = bitcast %struct.GCObject** %11 to %struct.Table**
  %13 = load %struct.Table*, %struct.Table** %12, align 8, !tbaa !21
  %14 = bitcast %struct.Table* %13 to %union.GCUnion*
  br label %15

; <label>:15:                                     ; preds = %2, %10
  %16 = phi %union.GCUnion* [ %14, %10 ], [ null, %2 ]
  %17 = phi %struct.Table* [ %13, %10 ], [ null, %2 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = trunc i8 %19 to i4
  switch i4 %20, label %66 [
    i4 5, label %21
    i4 7, label %44
  ]

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %23 = bitcast %struct.TValue* %3 to %struct.Table**
  %24 = load %struct.Table*, %struct.Table** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.Table, %struct.Table* %24, i64 0, i32 9
  %26 = bitcast %struct.Table** %25 to %union.GCUnion**
  store %union.GCUnion* %16, %union.GCUnion** %26, align 8, !tbaa !21
  %27 = icmp eq %struct.Table* %17, null
  br i1 %27, label %72, label %28

; <label>:28:                                     ; preds = %21
  %29 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %29, i64 0, i32 2
  %31 = load i8, i8* %30, align 1, !tbaa !70
  %32 = and i8 %31, 32
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %42, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %36 = load i8, i8* %35, align 1, !tbaa !146
  %37 = and i8 %36, 24
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %42, label %39

; <label>:39:                                     ; preds = %34
  %40 = bitcast %struct.Table* %17 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %29, %struct.GCObject* %40) #16
  %41 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !21
  br label %42

; <label>:42:                                     ; preds = %34, %28, %39
  %43 = phi %struct.GCObject* [ %29, %34 ], [ %29, %28 ], [ %41, %39 ]
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %43, %struct.Table* nonnull %17) #16
  br label %72

; <label>:44:                                     ; preds = %15
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 0, i32 0
  %46 = bitcast %struct.TValue* %3 to %struct.Udata**
  %47 = load %struct.Udata*, %struct.Udata** %46, align 8, !tbaa !21
  %48 = getelementptr inbounds %struct.Udata, %struct.Udata* %47, i64 0, i32 5
  store %struct.Table* %17, %struct.Table** %48, align 8, !tbaa !21
  %49 = icmp eq %struct.Table* %17, null
  br i1 %49, label %72, label %50

; <label>:50:                                     ; preds = %44
  %51 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !21
  %52 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %51, i64 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !21
  %54 = and i8 %53, 32
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %64, label %56

; <label>:56:                                     ; preds = %50
  %57 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %58 = load i8, i8* %57, align 1, !tbaa !146
  %59 = and i8 %58, 24
  %60 = icmp eq i8 %59, 0
  br i1 %60, label %64, label %61

; <label>:61:                                     ; preds = %56
  %62 = bitcast %union.GCUnion* %16 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %51, %struct.GCObject* %62) #16
  %63 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !21
  br label %64

; <label>:64:                                     ; preds = %56, %50, %61
  %65 = phi %struct.GCObject* [ %51, %56 ], [ %51, %50 ], [ %63, %61 ]
  tail call fastcc void @luaC_checkfinalizer(%struct.lua_State* nonnull %0, %struct.GCObject* %65, %struct.Table* nonnull %17) #16
  br label %72

; <label>:66:                                     ; preds = %15
  %67 = and i8 %19, 15
  %68 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %69 = load %struct.global_State*, %struct.global_State** %68, align 8, !tbaa !2
  %70 = zext i8 %67 to i64
  %71 = getelementptr inbounds %struct.global_State, %struct.global_State* %69, i64 0, i32 41, i64 %70
  store %struct.Table* %17, %struct.Table** %71, align 8, !tbaa !54
  br label %72

; <label>:72:                                     ; preds = %21, %44, %64, %42, %66
  %73 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %73, i64 -1
  store %union.StackValue* %74, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaC_checkfinalizer(%struct.lua_State* nocapture readonly, %struct.GCObject*, %struct.Table*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %7 = load i8, i8* %6, align 1, !tbaa !70
  %8 = and i8 %7, 64
  %9 = icmp ne i8 %8, 0
  %10 = icmp eq %struct.Table* %2, null
  %11 = or i1 %10, %9
  br i1 %11, label %89, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.Table, %struct.Table* %2, i64 0, i32 3
  %14 = load i8, i8* %13, align 2, !tbaa !90
  %15 = and i8 %14, 4
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %17, label %89

; <label>:17:                                     ; preds = %12
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 40, i64 2
  %19 = load %struct.TString*, %struct.TString** %18, align 8, !tbaa !54
  %20 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %2, %struct.TString* %19) #17
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = and i8 %22, 15
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %25, label %27

; <label>:25:                                     ; preds = %17
  %26 = or i8 %14, 4
  store i8 %26, i8* %13, align 2, !tbaa !90
  br label %89

; <label>:27:                                     ; preds = %17
  %28 = icmp eq %struct.TValue* %20, null
  br i1 %28, label %89, label %29

; <label>:29:                                     ; preds = %27
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 11
  %31 = load i8, i8* %30, align 1, !tbaa !42
  %32 = add i8 %31, -3
  %33 = icmp ult i8 %32, 4
  br i1 %33, label %34, label %49

; <label>:34:                                     ; preds = %29
  %35 = and i8 %7, -64
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 10
  %37 = load i8, i8* %36, align 4, !tbaa !15
  %38 = and i8 %37, 24
  %39 = or i8 %38, %35
  store i8 %39, i8* %6, align 1, !tbaa !70
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 21
  %41 = load %struct.GCObject**, %struct.GCObject*** %40, align 8, !tbaa !46
  %42 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 0
  %43 = icmp eq %struct.GCObject** %41, %42
  br i1 %43, label %44, label %73

; <label>:44:                                     ; preds = %34
  br label %45

; <label>:45:                                     ; preds = %44, %45
  %46 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** %41, i32 1, i32* null) #17
  %47 = icmp eq %struct.GCObject** %46, %41
  br i1 %47, label %45, label %48

; <label>:48:                                     ; preds = %45
  store %struct.GCObject** %46, %struct.GCObject*** %40, align 8, !tbaa !46
  br label %73

; <label>:49:                                     ; preds = %29
  %50 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 30
  %51 = load %struct.GCObject*, %struct.GCObject** %50, align 8, !tbaa !49
  %52 = icmp eq %struct.GCObject* %51, %1
  br i1 %52, label %53, label %57

; <label>:53:                                     ; preds = %49
  %54 = bitcast %struct.GCObject* %1 to i64*
  %55 = load i64, i64* %54, align 8, !tbaa !87
  %56 = bitcast %struct.GCObject** %50 to i64*
  store i64 %55, i64* %56, align 8, !tbaa !49
  br label %57

; <label>:57:                                     ; preds = %53, %49
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 31
  %59 = load %struct.GCObject*, %struct.GCObject** %58, align 8, !tbaa !53
  %60 = icmp eq %struct.GCObject* %59, %1
  br i1 %60, label %61, label %65

; <label>:61:                                     ; preds = %57
  %62 = bitcast %struct.GCObject* %1 to i64*
  %63 = load i64, i64* %62, align 8, !tbaa !87
  %64 = bitcast %struct.GCObject** %58 to i64*
  store i64 %63, i64* %64, align 8, !tbaa !53
  br label %65

; <label>:65:                                     ; preds = %61, %57
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 32
  %67 = load %struct.GCObject*, %struct.GCObject** %66, align 8, !tbaa !50
  %68 = icmp eq %struct.GCObject* %67, %1
  br i1 %68, label %69, label %73

; <label>:69:                                     ; preds = %65
  %70 = bitcast %struct.GCObject* %1 to i64*
  %71 = load i64, i64* %70, align 8, !tbaa !87
  %72 = bitcast %struct.GCObject** %66 to i64*
  store i64 %71, i64* %72, align 8, !tbaa !50
  br label %73

; <label>:73:                                     ; preds = %65, %69, %34, %48
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 20
  br label %75

; <label>:75:                                     ; preds = %75, %73
  %76 = phi %struct.GCObject** [ %74, %73 ], [ %79, %75 ]
  %77 = load %struct.GCObject*, %struct.GCObject** %76, align 8, !tbaa !54
  %78 = icmp eq %struct.GCObject* %77, %1
  %79 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %77, i64 0, i32 0
  br i1 %78, label %80, label %75

; <label>:80:                                     ; preds = %75
  %81 = bitcast %struct.GCObject* %1 to i64*
  %82 = load i64, i64* %81, align 8, !tbaa !87
  %83 = bitcast %struct.GCObject** %76 to i64*
  store i64 %82, i64* %83, align 8, !tbaa !54
  %84 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 22
  %85 = bitcast %struct.GCObject** %84 to i64*
  %86 = load i64, i64* %85, align 8, !tbaa !51
  store i64 %86, i64* %81, align 8, !tbaa !87
  store %struct.GCObject* %1, %struct.GCObject** %84, align 8, !tbaa !51
  %87 = load i8, i8* %6, align 1, !tbaa !70
  %88 = or i8 %87, 64
  store i8 %88, i8* %6, align 1, !tbaa !70
  br label %89

; <label>:89:                                     ; preds = %25, %3, %12, %27, %80
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define i32 @lua_setiuservalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #2 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = add i32 %2, -1
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 0, i32 0
  %7 = bitcast %struct.TValue* %4 to %struct.Udata**
  %8 = load %struct.Udata*, %struct.Udata** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 3
  %10 = load i16, i16* %9, align 2, !tbaa !21
  %11 = zext i16 %10 to i32
  %12 = icmp ult i32 %5, %11
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %46

; <label>:15:                                     ; preds = %3
  %16 = sext i32 %5 to i64
  %17 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %16, i32 0
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %17 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.Udata, %struct.Udata* %8, i64 0, i32 7, i64 %16, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !21
  %30 = and i8 %29, 64
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %46, label %32

; <label>:32:                                     ; preds = %15
  %33 = load %struct.GCObject*, %struct.GCObject** %6, align 8, !tbaa !21
  %34 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %33, i64 0, i32 2
  %35 = load i8, i8* %34, align 1, !tbaa !70
  %36 = and i8 %35, 32
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %46, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 0, i32 0
  %40 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !21
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %40, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !70
  %43 = and i8 %42, 24
  %44 = icmp eq i8 %43, 0
  br i1 %44, label %46, label %45

; <label>:45:                                     ; preds = %38
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* nonnull %0, %struct.GCObject* %33) #16
  br label %46

; <label>:46:                                     ; preds = %13, %45, %15, %32, %38
  %47 = phi %union.StackValue** [ %14, %13 ], [ %18, %45 ], [ %18, %15 ], [ %18, %32 ], [ %18, %38 ]
  %48 = phi i32 [ 0, %13 ], [ 1, %45 ], [ 1, %15 ], [ 1, %32 ], [ 1, %38 ]
  %49 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !20
  %50 = getelementptr inbounds %union.StackValue, %union.StackValue* %49, i64 -1
  store %union.StackValue* %50, %union.StackValue** %47, align 8, !tbaa !20
  ret i32 %48
}

; Function Attrs: nounwind optsize uwtable
define void @lua_callk(%struct.lua_State*, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = add nsw i32 %1, 1
  %9 = sext i32 %8 to i64
  %10 = sub nsw i64 0, %9
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 %10
  %12 = icmp eq i32 (%struct.lua_State*, i32, i64)* %4, null
  br i1 %12, label %23, label %13

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %15 = load i32, i32* %14, align 8, !tbaa !29
  %16 = icmp ult i32 %15, 65536
  br i1 %16, label %17, label %23

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !24
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %4, i32 (%struct.lua_State*, i32, i64)** %20, align 8, !tbaa !21
  %21 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !24
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %21, i64 0, i32 4, i32 0, i32 2
  store i64 %3, i64* %22, align 8, !tbaa !21
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2) #16
  br label %24

; <label>:23:                                     ; preds = %5, %13
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %11, i32 %2) #16
  br label %24

; <label>:24:                                     ; preds = %23, %17
  %25 = icmp slt i32 %2, 0
  br i1 %25, label %26, label %34

; <label>:26:                                     ; preds = %24
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %28 = load %struct.CallInfo*, %struct.CallInfo** %27, align 8, !tbaa !24
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %28, i64 0, i32 1
  %30 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !66
  %31 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %32 = icmp ult %union.StackValue* %30, %31
  br i1 %32, label %33, label %34

; <label>:33:                                     ; preds = %26
  store %union.StackValue* %31, %union.StackValue** %29, align 8, !tbaa !66
  br label %34

; <label>:34:                                     ; preds = %33, %26, %24
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_call(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  br label %5

; <label>:5:                                      ; preds = %150, %3
  %6 = load i8, i8* %4, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %150 [
    i6 -10, label %8
    i6 -26, label %12
    i6 22, label %74
  ]

; <label>:8:                                      ; preds = %5
  %9 = bitcast %union.StackValue* %1 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 5
  br label %14

; <label>:12:                                     ; preds = %5
  %13 = bitcast %union.StackValue* %1 to i32 (%struct.lua_State*)**
  br label %14

; <label>:14:                                     ; preds = %12, %8
  %15 = phi i32 (%struct.lua_State*)** [ %13, %12 ], [ %11, %8 ]
  %16 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %15, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !62
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !20
  %23 = sub i64 %19, %22
  %24 = icmp slt i64 %23, 336
  br i1 %24, label %25, label %43

; <label>:25:                                     ; preds = %14
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %27 = bitcast %union.StackValue** %26 to i64*
  %28 = load i64, i64* %27, align 8, !tbaa !23
  %29 = ptrtoint %union.StackValue* %1 to i64
  %30 = sub i64 %29, %28
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %32 = load %struct.global_State*, %struct.global_State** %31, align 8, !tbaa !2
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %32, i64 0, i32 3
  %34 = load i64, i64* %33, align 8, !tbaa !11
  %35 = icmp sgt i64 %34, 0
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %25
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %37

; <label>:37:                                     ; preds = %36, %25
  %38 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1) #16
  %39 = bitcast %union.StackValue** %26 to i8**
  %40 = load i8*, i8** %39, align 8, !tbaa !23
  %41 = getelementptr inbounds i8, i8* %40, i64 %30
  %42 = bitcast i8* %41 to %union.StackValue*
  br label %43

; <label>:43:                                     ; preds = %14, %37
  %44 = phi %union.StackValue* [ %42, %37 ], [ %1, %14 ]
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %46 = load %struct.CallInfo*, %struct.CallInfo** %45, align 8, !tbaa !24
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %46, i64 0, i32 3
  %48 = load %struct.CallInfo*, %struct.CallInfo** %47, align 8, !tbaa !117
  %49 = icmp eq %struct.CallInfo* %48, null
  br i1 %49, label %50, label %52

; <label>:50:                                     ; preds = %43
  %51 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0) #16
  br label %52

; <label>:52:                                     ; preds = %43, %50
  %53 = phi %struct.CallInfo* [ %51, %50 ], [ %48, %43 ]
  store %struct.CallInfo* %53, %struct.CallInfo** %45, align 8, !tbaa !24
  %54 = trunc i32 %2 to i16
  %55 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 6
  store i16 %54, i16* %55, align 4, !tbaa !65
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 7
  store i16 2, i16* %56, align 2, !tbaa !63
  %57 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 20
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 1
  store %union.StackValue* %58, %union.StackValue** %59, align 8, !tbaa !66
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %53, i64 0, i32 0
  store %union.StackValue* %44, %union.StackValue** %60, align 8, !tbaa !64
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %62 = load i32, i32* %61, align 8, !tbaa !31
  %63 = and i32 %62, 1
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %72, label %65

; <label>:65:                                     ; preds = %52
  %66 = ptrtoint %union.StackValue* %57 to i64
  %67 = ptrtoint %union.StackValue* %44 to i64
  %68 = sub i64 %66, %67
  %69 = lshr exact i64 %68, 4
  %70 = trunc i64 %69 to i32
  %71 = add nsw i32 %70, -1
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 0, i32 -1, i32 1, i32 %71) #16
  br label %72

; <label>:72:                                     ; preds = %52, %65
  %73 = tail call i32 %16(%struct.lua_State* nonnull %0) #17
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %53, i32 %73) #16
  br label %151

; <label>:74:                                     ; preds = %5
  %75 = bitcast %union.StackValue* %1 to %struct.LClosure**
  %76 = load %struct.LClosure*, %struct.LClosure** %75, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %76, i64 0, i32 5
  %78 = load %struct.Proto*, %struct.Proto** %77, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %80 = bitcast %union.StackValue** %79 to i64*
  %81 = load i64, i64* %80, align 8, !tbaa !20
  %82 = ptrtoint %union.StackValue* %1 to i64
  %83 = sub i64 %81, %82
  %84 = lshr exact i64 %83, 4
  %85 = trunc i64 %84 to i32
  %86 = add nsw i32 %85, -1
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 3
  %88 = load i8, i8* %87, align 2, !tbaa !131
  %89 = zext i8 %88 to i32
  %90 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 5
  %91 = load i8, i8* %90, align 4, !tbaa !158
  %92 = zext i8 %91 to i32
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %94 = bitcast %union.StackValue** %93 to i64*
  %95 = load i64, i64* %94, align 8, !tbaa !62
  %96 = sub i64 %95, %81
  %97 = ashr exact i64 %96, 4
  %98 = zext i8 %91 to i64
  %99 = icmp sgt i64 %97, %98
  br i1 %99, label %117, label %100

; <label>:100:                                    ; preds = %74
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %102 = bitcast %union.StackValue** %101 to i64*
  %103 = load i64, i64* %102, align 8, !tbaa !23
  %104 = sub i64 %82, %103
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %106 = load %struct.global_State*, %struct.global_State** %105, align 8, !tbaa !2
  %107 = getelementptr inbounds %struct.global_State, %struct.global_State* %106, i64 0, i32 3
  %108 = load i64, i64* %107, align 8, !tbaa !11
  %109 = icmp sgt i64 %108, 0
  br i1 %109, label %110, label %111

; <label>:110:                                    ; preds = %100
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %111

; <label>:111:                                    ; preds = %110, %100
  %112 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %92, i32 1) #16
  %113 = bitcast %union.StackValue** %101 to i8**
  %114 = load i8*, i8** %113, align 8, !tbaa !23
  %115 = getelementptr inbounds i8, i8* %114, i64 %104
  %116 = bitcast i8* %115 to %union.StackValue*
  br label %117

; <label>:117:                                    ; preds = %74, %111
  %118 = phi %union.StackValue* [ %116, %111 ], [ %1, %74 ]
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %120 = load %struct.CallInfo*, %struct.CallInfo** %119, align 8, !tbaa !24
  %121 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %120, i64 0, i32 3
  %122 = load %struct.CallInfo*, %struct.CallInfo** %121, align 8, !tbaa !117
  %123 = icmp eq %struct.CallInfo* %122, null
  br i1 %123, label %124, label %126

; <label>:124:                                    ; preds = %117
  %125 = tail call fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State* nonnull %0) #16
  br label %126

; <label>:126:                                    ; preds = %117, %124
  %127 = phi %struct.CallInfo* [ %125, %124 ], [ %122, %117 ]
  store %struct.CallInfo* %127, %struct.CallInfo** %119, align 8, !tbaa !24
  %128 = trunc i32 %2 to i16
  %129 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 6
  store i16 %128, i16* %129, align 4, !tbaa !65
  %130 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 16
  %131 = bitcast i32** %130 to i64*
  %132 = load i64, i64* %131, align 8, !tbaa !116
  %133 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 4
  %134 = bitcast %union.anon.0* %133 to i64*
  store i64 %132, i64* %134, align 8, !tbaa !21
  %135 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 7
  store i16 0, i16* %135, align 2, !tbaa !63
  %136 = getelementptr inbounds %union.StackValue, %union.StackValue* %118, i64 1
  %137 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 %98
  %138 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 1
  store %union.StackValue* %137, %union.StackValue** %138, align 8, !tbaa !66
  %139 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %127, i64 0, i32 0
  store %union.StackValue* %118, %union.StackValue** %139, align 8, !tbaa !64
  %140 = icmp sgt i32 %85, %89
  br i1 %140, label %149, label %141

; <label>:141:                                    ; preds = %126
  br label %142

; <label>:142:                                    ; preds = %141, %142
  %143 = phi i32 [ %147, %142 ], [ %86, %141 ]
  %144 = load %union.StackValue*, %union.StackValue** %79, align 8, !tbaa !20
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 1
  store %union.StackValue* %145, %union.StackValue** %79, align 8, !tbaa !20
  %146 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 0, i32 0, i32 1
  store i8 0, i8* %146, align 8, !tbaa !21
  %147 = add nsw i32 %143, 1
  %148 = icmp slt i32 %147, %89
  br i1 %148, label %142, label %149

; <label>:149:                                    ; preds = %142, %126
  tail call fastcc void @luaV_execute(%struct.lua_State* nonnull %0, %struct.CallInfo* %127) #16
  br label %151

; <label>:150:                                    ; preds = %5
  tail call fastcc void @luaD_tryfuncTM(%struct.lua_State* %0, %union.StackValue* nonnull %1) #16
  br label %5

; <label>:151:                                    ; preds = %149, %72
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_callnoyield(%struct.lua_State*, %union.StackValue*, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %5 = load i32, i32* %4, align 8, !tbaa !29
  %6 = add i32 %5, 65546
  store i32 %6, i32* %4, align 8, !tbaa !29
  %7 = and i32 %6, 65528
  %8 = icmp ugt i32 %7, 2199
  br i1 %8, label %9, label %10

; <label>:9:                                      ; preds = %3
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  br label %10

; <label>:10:                                     ; preds = %9, %3
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %1, i32 %2) #16
  %11 = load i32, i32* %4, align 8, !tbaa !29
  %12 = add i32 %11, -65546
  store i32 %12, i32* %4, align 8, !tbaa !29
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_pcallk(%struct.lua_State*, i32, i32, i32, i64, i32 (%struct.lua_State*, i32, i64)*) local_unnamed_addr #0 {
  %7 = alloca %struct.CallS, align 8
  %8 = bitcast %struct.CallS* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %28, label %10

; <label>:10:                                     ; preds = %6
  %11 = icmp sgt i32 %3, 0
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %10
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %14 = load %struct.CallInfo*, %struct.CallInfo** %13, align 8, !tbaa !24
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %14, i64 0, i32 0
  br label %18

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %union.StackValue** [ %15, %12 ], [ %17, %16 ]
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !54
  %21 = sext i32 %3 to i64
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 %21
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %24 = bitcast %union.StackValue** %23 to i64*
  %25 = load i64, i64* %24, align 8, !tbaa !23
  %26 = ptrtoint %union.StackValue* %22 to i64
  %27 = sub i64 %26, %25
  br label %28

; <label>:28:                                     ; preds = %6, %18
  %29 = phi i64 [ %27, %18 ], [ 0, %6 ]
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %32 = add nsw i32 %1, 1
  %33 = sext i32 %32 to i64
  %34 = sub nsw i64 0, %33
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 %34
  %36 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 0
  store %union.StackValue* %35, %union.StackValue** %36, align 8, !tbaa !159
  %37 = icmp eq i32 (%struct.lua_State*, i32, i64)* %5, null
  %38 = ptrtoint %union.StackValue* %35 to i64
  br i1 %37, label %43, label %39

; <label>:39:                                     ; preds = %28
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %41 = load i32, i32* %40, align 8, !tbaa !29
  %42 = icmp ult i32 %41, 65536
  br i1 %42, label %50, label %43

; <label>:43:                                     ; preds = %39, %28
  %44 = getelementptr inbounds %struct.CallS, %struct.CallS* %7, i64 0, i32 1
  store i32 %2, i32* %44, align 8, !tbaa !161
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %46 = bitcast %union.StackValue** %45 to i64*
  %47 = load i64, i64* %46, align 8, !tbaa !23
  %48 = sub i64 %38, %47
  %49 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %8, i64 %48, i64 %29) #16
  br label %75

; <label>:50:                                     ; preds = %39
  %51 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %52 = load %struct.CallInfo*, %struct.CallInfo** %51, align 8, !tbaa !24
  %53 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %52, i64 0, i32 4, i32 0, i32 0
  store i32 (%struct.lua_State*, i32, i64)* %5, i32 (%struct.lua_State*, i32, i64)** %53, align 8, !tbaa !21
  %54 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %52, i64 0, i32 4, i32 0, i32 2
  store i64 %4, i64* %54, align 8, !tbaa !21
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %56 = bitcast %union.StackValue** %55 to i64*
  %57 = load i64, i64* %56, align 8, !tbaa !23
  %58 = sub i64 %38, %57
  %59 = trunc i64 %58 to i32
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %52, i64 0, i32 5, i32 0
  store i32 %59, i32* %60, align 8, !tbaa !21
  %61 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %62 = load i64, i64* %61, align 8, !tbaa !36
  %63 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %52, i64 0, i32 4, i32 0, i32 1
  store i64 %62, i64* %63, align 8, !tbaa !21
  store i64 %29, i64* %61, align 8, !tbaa !36
  %64 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %52, i64 0, i32 7
  %65 = load i16, i16* %64, align 2, !tbaa !63
  %66 = and i16 %65, -10
  %67 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %68 = load i8, i8* %67, align 1, !tbaa !33
  %69 = zext i8 %68 to i16
  %70 = or i16 %66, %69
  %71 = or i16 %70, 8
  store i16 %71, i16* %64, align 2, !tbaa !63
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %35, i32 %2) #16
  %72 = load i16, i16* %64, align 2, !tbaa !63
  %73 = and i16 %72, -9
  store i16 %73, i16* %64, align 2, !tbaa !63
  %74 = load i64, i64* %63, align 8, !tbaa !21
  store i64 %74, i64* %61, align 8, !tbaa !36
  br label %75

; <label>:75:                                     ; preds = %50, %43
  %76 = phi i32 [ %49, %43 ], [ 0, %50 ]
  %77 = icmp slt i32 %2, 0
  br i1 %77, label %78, label %86

; <label>:78:                                     ; preds = %75
  %79 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %80 = load %struct.CallInfo*, %struct.CallInfo** %79, align 8, !tbaa !24
  %81 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %80, i64 0, i32 1
  %82 = load %union.StackValue*, %union.StackValue** %81, align 8, !tbaa !66
  %83 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !20
  %84 = icmp ult %union.StackValue* %82, %83
  br i1 %84, label %85, label %86

; <label>:85:                                     ; preds = %78
  store %union.StackValue* %83, %union.StackValue** %81, align 8, !tbaa !66
  br label %86

; <label>:86:                                     ; preds = %85, %78, %75
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %76
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaD_pcall(%struct.lua_State*, void (%struct.lua_State*, i8*)* nocapture, i8*, i64, i64) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = bitcast %struct.CallInfo** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !33
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %12 = load i64, i64* %11, align 8, !tbaa !36
  store i64 %4, i64* %11, align 8, !tbaa !36
  %13 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* %1, i8* %2) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %25, label %15, !prof !73

; <label>:15:                                     ; preds = %5
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %17 = bitcast %union.StackValue** %16 to i8**
  %18 = load i8*, i8** %17, align 8, !tbaa !23
  %19 = getelementptr inbounds i8, i8* %18, i64 %3
  %20 = bitcast i8* %19 to %union.StackValue*
  store i64 %8, i64* %7, align 8, !tbaa !24
  store i8 %10, i8* %9, align 1, !tbaa !33
  %21 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %20, i32 %13) #16
  %22 = load i8*, i8** %17, align 8, !tbaa !23
  %23 = getelementptr inbounds i8, i8* %22, i64 %3
  %24 = bitcast i8* %23 to %union.StackValue*
  tail call fastcc void @luaD_seterrorobj(%struct.lua_State* nonnull %0, i32 %21, %union.StackValue* %24) #16
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* nonnull %0) #16
  br label %25

; <label>:25:                                     ; preds = %5, %15
  %26 = phi i32 [ %21, %15 ], [ 0, %5 ]
  store i64 %12, i64* %11, align 8, !tbaa !36
  ret i32 %26
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_call(%struct.lua_State*, i8* nocapture readonly) #0 {
  %3 = bitcast i8* %1 to %union.StackValue**
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !159
  %5 = getelementptr inbounds i8, i8* %1, i64 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6, align 8, !tbaa !161
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* %4, i32 %7) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_load(%struct.lua_State*, i8* (%struct.lua_State*, i8*, i64*)*, i8*, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.SParser, align 8
  %7 = alloca %struct.Zio, align 8
  %8 = bitcast %struct.Zio* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %8) #7
  %9 = icmp eq i8* %3, null
  %10 = select i1 %9, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %3
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 4
  store %struct.lua_State* %0, %struct.lua_State** %11, align 8, !tbaa !162
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 2
  store i8* (%struct.lua_State*, i8*, i64*)* %1, i8* (%struct.lua_State*, i8*, i64*)** %12, align 8, !tbaa !164
  %13 = getelementptr inbounds %struct.Zio, %struct.Zio* %7, i64 0, i32 3
  store i8* %2, i8** %13, align 8, !tbaa !165
  call void @llvm.memset.p0i8.i64(i8* nonnull %8, i8 0, i64 16, i32 8, i1 false) #7
  %14 = bitcast %struct.SParser* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* nonnull %14) #7
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %16 = load i32, i32* %15, align 8, !tbaa !29
  %17 = add i32 %16, 65536
  store i32 %17, i32* %15, align 8, !tbaa !29
  %18 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 0
  store %struct.Zio* %7, %struct.Zio** %18, align 8, !tbaa !166
  %19 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 4
  store i8* %10, i8** %19, align 8, !tbaa !172
  %20 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 3
  store i8* %4, i8** %20, align 8, !tbaa !173
  %21 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 0, i32 0
  %22 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 0, i32 2
  store i32 0, i32* %22, align 4, !tbaa !174
  %23 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 1, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %23, align 8, !tbaa !175
  %24 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 1, i32 2
  store i32 0, i32* %24, align 4, !tbaa !176
  %25 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 2, i32 0
  store %struct.Labeldesc* null, %struct.Labeldesc** %25, align 8, !tbaa !177
  %26 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 2, i32 2, i32 2
  store i32 0, i32* %26, align 4, !tbaa !178
  %27 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 1, i32 0
  store i8* null, i8** %27, align 8, !tbaa !179
  %28 = getelementptr inbounds %struct.SParser, %struct.SParser* %6, i64 0, i32 1, i32 2
  %29 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %30 = bitcast %union.StackValue** %29 to i64*
  %31 = bitcast i64* %28 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %31, i8 0, i64 16, i32 8, i1 false) #7
  %32 = load i64, i64* %30, align 8, !tbaa !20
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %34 = bitcast %union.StackValue** %33 to i64*
  %35 = load i64, i64* %34, align 8, !tbaa !23
  %36 = sub i64 %32, %35
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %38 = load i64, i64* %37, align 8, !tbaa !36
  %39 = call fastcc i32 @luaD_pcall(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @f_parser, i8* nonnull %14, i64 %36, i64 %38) #17
  %40 = load i8*, i8** %27, align 8, !tbaa !179
  %41 = load i64, i64* %28, align 8, !tbaa !180
  %42 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %43 = load %struct.global_State*, %struct.global_State** %42, align 8, !tbaa !2
  %44 = getelementptr inbounds %struct.global_State, %struct.global_State* %43, i64 0, i32 0
  %45 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %44, align 8, !tbaa !59
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %43, i64 0, i32 1
  %47 = load i8*, i8** %46, align 8, !tbaa !60
  %48 = call i8* %45(i8* %47, i8* %40, i64 %41, i64 0) #17
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %43, i64 0, i32 3
  %50 = load i64, i64* %49, align 8, !tbaa !11
  %51 = sub i64 %50, %41
  store i64 %51, i64* %49, align 8, !tbaa !11
  store i8* %48, i8** %27, align 8, !tbaa !179
  store i64 0, i64* %28, align 8, !tbaa !180
  %52 = bitcast %struct.Vardesc** %21 to i8**
  %53 = load i8*, i8** %52, align 8, !tbaa !181
  %54 = load i32, i32* %22, align 4, !tbaa !174
  %55 = sext i32 %54 to i64
  %56 = shl nsw i64 %55, 1
  %57 = load %struct.global_State*, %struct.global_State** %42, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 0
  %59 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %58, align 8, !tbaa !59
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 1
  %61 = load i8*, i8** %60, align 8, !tbaa !60
  %62 = call i8* %59(i8* %61, i8* %53, i64 %56, i64 0) #17
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 3
  %64 = load i64, i64* %63, align 8, !tbaa !11
  %65 = sub i64 %64, %56
  store i64 %65, i64* %63, align 8, !tbaa !11
  %66 = bitcast %struct.Labeldesc** %23 to i8**
  %67 = load i8*, i8** %66, align 8, !tbaa !175
  %68 = load i32, i32* %24, align 4, !tbaa !176
  %69 = sext i32 %68 to i64
  %70 = mul nsw i64 %69, 24
  %71 = load %struct.global_State*, %struct.global_State** %42, align 8, !tbaa !2
  %72 = getelementptr inbounds %struct.global_State, %struct.global_State* %71, i64 0, i32 0
  %73 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %72, align 8, !tbaa !59
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %71, i64 0, i32 1
  %75 = load i8*, i8** %74, align 8, !tbaa !60
  %76 = call i8* %73(i8* %75, i8* %67, i64 %70, i64 0) #17
  %77 = getelementptr inbounds %struct.global_State, %struct.global_State* %71, i64 0, i32 3
  %78 = load i64, i64* %77, align 8, !tbaa !11
  %79 = sub i64 %78, %70
  store i64 %79, i64* %77, align 8, !tbaa !11
  %80 = bitcast %struct.Labeldesc** %25 to i8**
  %81 = load i8*, i8** %80, align 8, !tbaa !177
  %82 = load i32, i32* %26, align 4, !tbaa !178
  %83 = sext i32 %82 to i64
  %84 = mul nsw i64 %83, 24
  %85 = load %struct.global_State*, %struct.global_State** %42, align 8, !tbaa !2
  %86 = getelementptr inbounds %struct.global_State, %struct.global_State* %85, i64 0, i32 0
  %87 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %86, align 8, !tbaa !59
  %88 = getelementptr inbounds %struct.global_State, %struct.global_State* %85, i64 0, i32 1
  %89 = load i8*, i8** %88, align 8, !tbaa !60
  %90 = call i8* %87(i8* %89, i8* %81, i64 %84, i64 0) #17
  %91 = getelementptr inbounds %struct.global_State, %struct.global_State* %85, i64 0, i32 3
  %92 = load i64, i64* %91, align 8, !tbaa !11
  %93 = sub i64 %92, %84
  store i64 %93, i64* %91, align 8, !tbaa !11
  %94 = load i32, i32* %15, align 8, !tbaa !29
  %95 = add i32 %94, -65536
  store i32 %95, i32* %15, align 8, !tbaa !29
  call void @llvm.lifetime.end.p0i8(i64 96, i8* nonnull %14) #7
  %96 = icmp eq i32 %39, 0
  br i1 %96, label %97, label %139

; <label>:97:                                     ; preds = %5
  %98 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !20
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %98, i64 -1, i32 0, i32 0, i32 0
  %100 = bitcast %struct.GCObject** %99 to %struct.LClosure**
  %101 = load %struct.LClosure*, %struct.LClosure** %100, align 8, !tbaa !21
  %102 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %101, i64 0, i32 3
  %103 = load i8, i8* %102, align 2, !tbaa !182
  %104 = icmp eq i8 %103, 0
  br i1 %104, label %139, label %105

; <label>:105:                                    ; preds = %97
  %106 = load %struct.global_State*, %struct.global_State** %42, align 8, !tbaa !2
  %107 = getelementptr inbounds %struct.global_State, %struct.global_State* %106, i64 0, i32 7, i32 0, i32 0
  %108 = bitcast %struct.GCObject** %107 to %struct.Table**
  %109 = load %struct.Table*, %struct.Table** %108, align 8, !tbaa !21
  %110 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %109, i64 2) #16
  %111 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %101, i64 0, i32 6, i64 0
  %112 = load %struct.UpVal*, %struct.UpVal** %111, align 8, !tbaa !54
  %113 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %112, i64 0, i32 3
  %114 = load %struct.TValue*, %struct.TValue** %113, align 8, !tbaa !67
  %115 = bitcast %struct.TValue* %110 to i64*
  %116 = bitcast %struct.TValue* %114 to i64*
  %117 = load i64, i64* %115, align 8
  store i64 %117, i64* %116, align 8
  %118 = getelementptr inbounds %struct.TValue, %struct.TValue* %110, i64 0, i32 1
  %119 = load i8, i8* %118, align 8, !tbaa !22
  %120 = getelementptr inbounds %struct.TValue, %struct.TValue* %114, i64 0, i32 1
  store i8 %119, i8* %120, align 8, !tbaa !22
  %121 = load i8, i8* %118, align 8, !tbaa !22
  %122 = and i8 %121, 64
  %123 = icmp eq i8 %122, 0
  br i1 %123, label %139, label %124

; <label>:124:                                    ; preds = %105
  %125 = load %struct.UpVal*, %struct.UpVal** %111, align 8, !tbaa !54
  %126 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %125, i64 0, i32 2
  %127 = load i8, i8* %126, align 1, !tbaa !69
  %128 = and i8 %127, 32
  %129 = icmp eq i8 %128, 0
  br i1 %129, label %139, label %130

; <label>:130:                                    ; preds = %124
  %131 = getelementptr inbounds %struct.TValue, %struct.TValue* %110, i64 0, i32 0, i32 0
  %132 = load %struct.GCObject*, %struct.GCObject** %131, align 8, !tbaa !21
  %133 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %132, i64 0, i32 2
  %134 = load i8, i8* %133, align 1, !tbaa !70
  %135 = and i8 %134, 24
  %136 = icmp eq i8 %135, 0
  br i1 %136, label %139, label %137

; <label>:137:                                    ; preds = %130
  %138 = bitcast %struct.UpVal* %125 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %138, %struct.GCObject* %132) #16
  br label %139

; <label>:139:                                    ; preds = %97, %130, %124, %105, %137, %5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %8) #7
  ret i32 %39
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_dump(%struct.lua_State*, i32 (%struct.lua_State*, i8*, i64, i8*)*, i8*, i32) local_unnamed_addr #0 {
  %5 = alloca i8, align 1
  %6 = alloca double, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %9 = alloca i8, align 1
  %10 = alloca i8, align 1
  %11 = alloca i8, align 1
  %12 = alloca %struct.DumpState, align 8
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = icmp eq i8 %16, 86
  br i1 %17, label %18, label %103

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -1, i32 0, i32 0, i32 0
  %20 = bitcast %struct.GCObject** %19 to %struct.LClosure**
  %21 = load %struct.LClosure*, %struct.LClosure** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %21, i64 0, i32 5
  %23 = load %struct.Proto*, %struct.Proto** %22, align 8, !tbaa !21
  %24 = bitcast %struct.DumpState* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %24) #7
  %25 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %12, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %25, align 8, !tbaa !184
  %26 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %12, i64 0, i32 1
  store i32 (%struct.lua_State*, i8*, i64, i8*)* %1, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %27 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %12, i64 0, i32 2
  store i8* %2, i8** %27, align 8, !tbaa !187
  %28 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %12, i64 0, i32 3
  store i32 %3, i32* %28, align 8, !tbaa !188
  %29 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %12, i64 0, i32 4
  %30 = tail call i32 %1(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 0), i64 4, i8* %2) #17
  store i32 %30, i32* %29, align 4, !tbaa !189
  call fastcc void @DumpSize(i64 504, %struct.DumpState* nonnull %12) #17
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %11) #7
  store i8 0, i8* %11, align 1, !tbaa !21
  %31 = load i32, i32* %29, align 4, !tbaa !189
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %34, label %33

; <label>:33:                                     ; preds = %18
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %11) #7
  br label %40

; <label>:34:                                     ; preds = %18
  %35 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %36 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %37 = load i8*, i8** %27, align 8, !tbaa !187
  %38 = call i32 %35(%struct.lua_State* %36, i8* nonnull %11, i64 1, i8* %37) #17
  store i32 %38, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %11) #7
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %42, label %40

; <label>:40:                                     ; preds = %34, %33
  %41 = phi i32 [ %38, %34 ], [ %31, %33 ]
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %9) #7
  store i8 8, i8* %9, align 1, !tbaa !21
  br label %55

; <label>:42:                                     ; preds = %34
  %43 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %44 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %45 = load i8*, i8** %27, align 8, !tbaa !187
  %46 = call i32 %43(%struct.lua_State* %44, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i64 6, i8* %45) #17
  store i32 %46, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %10) #7
  store i8 4, i8* %10, align 1, !tbaa !21
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %49, label %48

; <label>:48:                                     ; preds = %42
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %10) #7
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %9) #7
  store i8 8, i8* %9, align 1, !tbaa !21
  br label %55

; <label>:49:                                     ; preds = %42
  %50 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %51 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %52 = load i8*, i8** %27, align 8, !tbaa !187
  %53 = call i32 %50(%struct.lua_State* %51, i8* nonnull %10, i64 1, i8* %52) #17
  store i32 %53, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %10) #7
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %9) #7
  store i8 8, i8* %9, align 1, !tbaa !21
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %57, label %55

; <label>:55:                                     ; preds = %49, %48, %40
  %56 = phi i32 [ %53, %49 ], [ %46, %48 ], [ %41, %40 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %9) #7
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %8) #7
  store i8 8, i8* %8, align 1, !tbaa !21
  br label %63

; <label>:57:                                     ; preds = %49
  %58 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %59 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %60 = load i8*, i8** %27, align 8, !tbaa !187
  %61 = call i32 %58(%struct.lua_State* %59, i8* nonnull %9, i64 1, i8* %60) #17
  store i32 %61, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %9) #7
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %8) #7
  store i8 8, i8* %8, align 1, !tbaa !21
  %62 = icmp eq i32 %61, 0
  br i1 %62, label %66, label %63

; <label>:63:                                     ; preds = %57, %55
  %64 = phi i32 [ %61, %57 ], [ %56, %55 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %8) #7
  %65 = bitcast i64* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %65) #7
  store i64 22136, i64* %7, align 8, !tbaa !144
  br label %73

; <label>:66:                                     ; preds = %57
  %67 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %68 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %69 = load i8*, i8** %27, align 8, !tbaa !187
  %70 = call i32 %67(%struct.lua_State* %68, i8* nonnull %8, i64 1, i8* %69) #17
  store i32 %70, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %8) #7
  %71 = bitcast i64* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %71) #7
  store i64 22136, i64* %7, align 8, !tbaa !144
  %72 = icmp eq i32 %70, 0
  br i1 %72, label %77, label %73

; <label>:73:                                     ; preds = %66, %63
  %74 = phi i32 [ %70, %66 ], [ %64, %63 ]
  %75 = phi i8* [ %71, %66 ], [ %65, %63 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %75) #7
  %76 = bitcast double* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %76) #7
  store double 3.705000e+02, double* %6, align 8, !tbaa !140
  br label %89

; <label>:77:                                     ; preds = %66
  %78 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %79 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %80 = load i8*, i8** %27, align 8, !tbaa !187
  %81 = call i32 %78(%struct.lua_State* %79, i8* nonnull %71, i64 8, i8* %80) #17
  store i32 %81, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %71) #7
  %82 = bitcast double* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %82) #7
  store double 3.705000e+02, double* %6, align 8, !tbaa !140
  %83 = icmp eq i32 %81, 0
  br i1 %83, label %84, label %89

; <label>:84:                                     ; preds = %77
  %85 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %86 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %87 = load i8*, i8** %27, align 8, !tbaa !187
  %88 = call i32 %85(%struct.lua_State* %86, i8* nonnull %82, i64 8, i8* %87) #17
  store i32 %88, i32* %29, align 4, !tbaa !189
  br label %89

; <label>:89:                                     ; preds = %84, %77, %73
  %90 = phi i32 [ %74, %73 ], [ %81, %77 ], [ %88, %84 ]
  %91 = phi i8* [ %76, %73 ], [ %82, %77 ], [ %82, %84 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %91) #7
  %92 = getelementptr inbounds %struct.Proto, %struct.Proto* %23, i64 0, i32 6
  %93 = load i32, i32* %92, align 8, !tbaa !190
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #7
  %94 = trunc i32 %93 to i8
  store i8 %94, i8* %5, align 1, !tbaa !21
  %95 = icmp eq i32 %90, 0
  br i1 %95, label %96, label %101

; <label>:96:                                     ; preds = %89
  %97 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %26, align 8, !tbaa !186
  %98 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !184
  %99 = load i8*, i8** %27, align 8, !tbaa !187
  %100 = call i32 %97(%struct.lua_State* %98, i8* nonnull %5, i64 1, i8* %99) #17
  store i32 %100, i32* %29, align 4, !tbaa !189
  br label %101

; <label>:101:                                    ; preds = %89, %96
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #7
  call fastcc void @DumpFunction(%struct.Proto* nonnull %23, %struct.TString* null, %struct.DumpState* nonnull %12) #17
  %102 = load i32, i32* %29, align 4, !tbaa !189
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %24) #7
  br label %103

; <label>:103:                                    ; preds = %4, %101
  %104 = phi i32 [ %102, %101 ], [ 1, %4 ]
  ret i32 %104
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i32 @lua_status(%struct.lua_State* nocapture readonly) local_unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %3 = load i8, i8* %2, align 2, !tbaa !35
  %4 = zext i8 %3 to i32
  ret i32 %4
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_gc(%struct.lua_State*, i32, ...) local_unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  call void @llvm.va_start(i8* nonnull %4)
  switch i32 %1, label %288 [
    i32 0, label %7
    i32 1, label %9
    i32 2, label %16
    i32 3, label %17
    i32 4, label %25
    i32 5, label %33
    i32 6, label %85
    i32 7, label %109
    i32 9, label %133
    i32 10, label %137
    i32 11, label %201
  ]

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 0, i8* %8, align 1, !tbaa !39
  br label %288

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %11 = load i64, i64* %10, align 8, !tbaa !43
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %13 = load i64, i64* %12, align 8, !tbaa !11
  %14 = add nsw i64 %13, %11
  store i64 %14, i64* %10, align 8, !tbaa !43
  store i64 0, i64* %12, align 8, !tbaa !11
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  store i8 1, i8* %15, align 1, !tbaa !39
  br label %288

; <label>:16:                                     ; preds = %2
  call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 0) #16
  br label %288

; <label>:17:                                     ; preds = %2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %19 = load i64, i64* %18, align 8, !tbaa !43
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %21 = load i64, i64* %20, align 8, !tbaa !11
  %22 = add nsw i64 %21, %19
  %23 = lshr i64 %22, 10
  %24 = trunc i64 %23 to i32
  br label %288

; <label>:25:                                     ; preds = %2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %27 = load i64, i64* %26, align 8, !tbaa !43
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = add nsw i64 %29, %27
  %31 = trunc i64 %30 to i32
  %32 = and i32 %31, 1023
  br label %288

; <label>:33:                                     ; preds = %2
  %34 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %35 = load i32, i32* %34, align 16
  %36 = icmp ult i32 %35, 41
  br i1 %36, label %37, label %43

; <label>:37:                                     ; preds = %33
  %38 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %39 = load i8*, i8** %38, align 16
  %40 = sext i32 %35 to i64
  %41 = getelementptr i8, i8* %39, i64 %40
  %42 = add i32 %35, 8
  store i32 %42, i32* %34, align 16
  br label %47

; <label>:43:                                     ; preds = %33
  %44 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %45 = load i8*, i8** %44, align 8
  %46 = getelementptr i8, i8* %45, i64 8
  store i8* %46, i8** %44, align 8
  br label %47

; <label>:47:                                     ; preds = %43, %37
  %48 = phi i8* [ %41, %37 ], [ %45, %43 ]
  %49 = bitcast i8* %48 to i32*
  %50 = load i32, i32* %49, align 4
  %51 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %52 = load i8, i8* %51, align 1, !tbaa !39
  store i8 1, i8* %51, align 1, !tbaa !39
  %53 = icmp eq i32 %50, 0
  br i1 %53, label %54, label %60

; <label>:54:                                     ; preds = %47
  %55 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %56 = load i64, i64* %55, align 8, !tbaa !43
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %58 = load i64, i64* %57, align 8, !tbaa !11
  %59 = add nsw i64 %58, %56
  store i64 %59, i64* %55, align 8, !tbaa !43
  store i64 0, i64* %57, align 8, !tbaa !11
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  store i8 %52, i8* %51, align 1, !tbaa !39
  br label %80

; <label>:60:                                     ; preds = %47
  %61 = sext i32 %50 to i64
  %62 = shl nsw i64 %61, 10
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %64 = load i64, i64* %63, align 8, !tbaa !11
  %65 = add nsw i64 %64, %62
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 2
  %67 = load i64, i64* %66, align 8, !tbaa !43
  %68 = add nsw i64 %67, %64
  %69 = add nsw i64 %68, -9223372036854775807
  %70 = icmp sgt i64 %69, %65
  %71 = select i1 %70, i64 %69, i64 %65
  %72 = sub nsw i64 %68, %71
  store i64 %72, i64* %66, align 8, !tbaa !43
  store i64 %71, i64* %63, align 8, !tbaa !11
  %73 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %74 = getelementptr inbounds %struct.global_State, %struct.global_State* %73, i64 0, i32 3
  %75 = load i64, i64* %74, align 8, !tbaa !11
  %76 = icmp sgt i64 %75, 0
  br i1 %76, label %77, label %78

; <label>:77:                                     ; preds = %60
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %78

; <label>:78:                                     ; preds = %60, %77
  store i8 %52, i8* %51, align 1, !tbaa !39
  %79 = icmp sgt i64 %65, 0
  br i1 %79, label %80, label %288

; <label>:80:                                     ; preds = %54, %78
  %81 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 11
  %82 = load i8, i8* %81, align 1, !tbaa !42
  %83 = icmp eq i8 %82, 8
  %84 = zext i1 %83 to i32
  br label %288

; <label>:85:                                     ; preds = %2
  %86 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %87 = load i32, i32* %86, align 16
  %88 = icmp ult i32 %87, 41
  br i1 %88, label %89, label %95

; <label>:89:                                     ; preds = %85
  %90 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %91 = load i8*, i8** %90, align 16
  %92 = sext i32 %87 to i64
  %93 = getelementptr i8, i8* %91, i64 %92
  %94 = add i32 %87, 8
  store i32 %94, i32* %86, align 16
  br label %99

; <label>:95:                                     ; preds = %85
  %96 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %97 = load i8*, i8** %96, align 8
  %98 = getelementptr i8, i8* %97, i64 8
  store i8* %98, i8** %96, align 8
  br label %99

; <label>:99:                                     ; preds = %95, %89
  %100 = phi i8* [ %93, %89 ], [ %97, %95 ]
  %101 = bitcast i8* %100 to i32*
  %102 = load i32, i32* %101, align 4
  %103 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  %104 = load i8, i8* %103, align 1, !tbaa !47
  %105 = zext i8 %104 to i32
  %106 = shl nuw nsw i32 %105, 2
  %107 = sdiv i32 %102, 4
  %108 = trunc i32 %107 to i8
  store i8 %108, i8* %103, align 1, !tbaa !47
  br label %288

; <label>:109:                                    ; preds = %2
  %110 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %111 = load i32, i32* %110, align 16
  %112 = icmp ult i32 %111, 41
  br i1 %112, label %113, label %119

; <label>:113:                                    ; preds = %109
  %114 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %115 = load i8*, i8** %114, align 16
  %116 = sext i32 %111 to i64
  %117 = getelementptr i8, i8* %115, i64 %116
  %118 = add i32 %111, 8
  store i32 %118, i32* %110, align 16
  br label %123

; <label>:119:                                    ; preds = %109
  %120 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %121 = load i8*, i8** %120, align 8
  %122 = getelementptr i8, i8* %121, i64 8
  store i8* %122, i8** %120, align 8
  br label %123

; <label>:123:                                    ; preds = %119, %113
  %124 = phi i8* [ %117, %113 ], [ %121, %119 ]
  %125 = bitcast i8* %124 to i32*
  %126 = load i32, i32* %125, align 4
  %127 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  %128 = load i8, i8* %127, align 4, !tbaa !57
  %129 = zext i8 %128 to i32
  %130 = shl nuw nsw i32 %129, 2
  %131 = sdiv i32 %126, 4
  %132 = trunc i32 %131 to i8
  store i8 %132, i8* %127, align 4, !tbaa !57
  br label %288

; <label>:133:                                    ; preds = %2
  %134 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 15
  %135 = load i8, i8* %134, align 1, !tbaa !39
  %136 = zext i8 %135 to i32
  br label %288

; <label>:137:                                    ; preds = %2
  %138 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %139 = load i32, i32* %138, align 16
  %140 = icmp ult i32 %139, 41
  br i1 %140, label %147, label %141

; <label>:141:                                    ; preds = %137
  %142 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %143 = load i8*, i8** %142, align 8
  %144 = getelementptr i8, i8* %143, i64 8
  store i8* %144, i8** %142, align 8
  %145 = bitcast i8* %143 to i32*
  %146 = load i32, i32* %145, align 4
  br label %162

; <label>:147:                                    ; preds = %137
  %148 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %149 = load i8*, i8** %148, align 16
  %150 = sext i32 %139 to i64
  %151 = getelementptr i8, i8* %149, i64 %150
  %152 = add i32 %139, 8
  store i32 %152, i32* %138, align 16
  %153 = bitcast i8* %151 to i32*
  %154 = load i32, i32* %153, align 4
  %155 = icmp ult i32 %152, 41
  br i1 %155, label %156, label %162

; <label>:156:                                    ; preds = %147
  %157 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %158 = load i8*, i8** %157, align 16
  %159 = sext i32 %152 to i64
  %160 = getelementptr i8, i8* %158, i64 %159
  %161 = add i32 %139, 16
  store i32 %161, i32* %138, align 16
  br label %167

; <label>:162:                                    ; preds = %141, %147
  %163 = phi i32 [ %146, %141 ], [ %154, %147 ]
  %164 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %165 = load i8*, i8** %164, align 8
  %166 = getelementptr i8, i8* %165, i64 8
  store i8* %166, i8** %164, align 8
  br label %167

; <label>:167:                                    ; preds = %162, %156
  %168 = phi i32 [ %154, %156 ], [ %163, %162 ]
  %169 = phi i8* [ %160, %156 ], [ %165, %162 ]
  %170 = bitcast i8* %169 to i32*
  %171 = load i32, i32* %170, align 4
  %172 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %173 = load i8, i8* %172, align 2, !tbaa !40
  %174 = icmp eq i8 %173, 1
  br i1 %174, label %180, label %175

; <label>:175:                                    ; preds = %167
  %176 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %177 = load i64, i64* %176, align 8, !tbaa !41
  %178 = icmp eq i64 %177, 0
  %179 = select i1 %178, i32 11, i32 10
  br label %180

; <label>:180:                                    ; preds = %175, %167
  %181 = phi i32 [ 10, %167 ], [ %179, %175 ]
  %182 = icmp eq i32 %168, 0
  br i1 %182, label %186, label %183

; <label>:183:                                    ; preds = %180
  %184 = trunc i32 %168 to i8
  %185 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 13
  store i8 %184, i8* %185, align 1, !tbaa !44
  br label %186

; <label>:186:                                    ; preds = %180, %183
  %187 = icmp eq i32 %171, 0
  br i1 %187, label %192, label %188

; <label>:188:                                    ; preds = %186
  %189 = sdiv i32 %171, 4
  %190 = trunc i32 %189 to i8
  %191 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 14
  store i8 %190, i8* %191, align 8, !tbaa !48
  br label %192

; <label>:192:                                    ; preds = %186, %188
  %193 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %194 = getelementptr inbounds %struct.global_State, %struct.global_State* %193, i64 0, i32 12
  %195 = load i8, i8* %194, align 2, !tbaa !40
  %196 = icmp eq i8 %195, 1
  br i1 %196, label %199, label %197

; <label>:197:                                    ; preds = %192
  %198 = call fastcc i64 @entergen(%struct.lua_State* nonnull %0, %struct.global_State* %193) #17
  br label %199

; <label>:199:                                    ; preds = %192, %197
  %200 = getelementptr inbounds %struct.global_State, %struct.global_State* %193, i64 0, i32 5
  store i64 0, i64* %200, align 8, !tbaa !41
  br label %288

; <label>:201:                                    ; preds = %2
  %202 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 0
  %203 = load i32, i32* %202, align 16
  %204 = icmp ult i32 %203, 41
  br i1 %204, label %211, label %205

; <label>:205:                                    ; preds = %201
  %206 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %207 = load i8*, i8** %206, align 8
  %208 = getelementptr i8, i8* %207, i64 8
  store i8* %208, i8** %206, align 8
  %209 = bitcast i8* %207 to i32*
  %210 = load i32, i32* %209, align 4
  br label %220

; <label>:211:                                    ; preds = %201
  %212 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %213 = load i8*, i8** %212, align 16
  %214 = sext i32 %203 to i64
  %215 = getelementptr i8, i8* %213, i64 %214
  %216 = add i32 %203, 8
  store i32 %216, i32* %202, align 16
  %217 = bitcast i8* %215 to i32*
  %218 = load i32, i32* %217, align 4
  %219 = icmp ult i32 %216, 41
  br i1 %219, label %227, label %220

; <label>:220:                                    ; preds = %211, %205
  %221 = phi i32 [ %210, %205 ], [ %218, %211 ]
  %222 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %223 = load i8*, i8** %222, align 8
  %224 = getelementptr i8, i8* %223, i64 8
  store i8* %224, i8** %222, align 8
  %225 = bitcast i8* %223 to i32*
  %226 = load i32, i32* %225, align 4
  br label %242

; <label>:227:                                    ; preds = %211
  %228 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %229 = load i8*, i8** %228, align 16
  %230 = sext i32 %216 to i64
  %231 = getelementptr i8, i8* %229, i64 %230
  %232 = add i32 %203, 16
  store i32 %232, i32* %202, align 16
  %233 = bitcast i8* %231 to i32*
  %234 = load i32, i32* %233, align 4
  %235 = icmp ult i32 %232, 41
  br i1 %235, label %236, label %242

; <label>:236:                                    ; preds = %227
  %237 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 3
  %238 = load i8*, i8** %237, align 16
  %239 = sext i32 %232 to i64
  %240 = getelementptr i8, i8* %238, i64 %239
  %241 = add i32 %203, 24
  store i32 %241, i32* %202, align 16
  br label %248

; <label>:242:                                    ; preds = %220, %227
  %243 = phi i32 [ %226, %220 ], [ %234, %227 ]
  %244 = phi i32 [ %221, %220 ], [ %218, %227 ]
  %245 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0, i32 2
  %246 = load i8*, i8** %245, align 8
  %247 = getelementptr i8, i8* %246, i64 8
  store i8* %247, i8** %245, align 8
  br label %248

; <label>:248:                                    ; preds = %242, %236
  %249 = phi i32 [ %234, %236 ], [ %243, %242 ]
  %250 = phi i32 [ %218, %236 ], [ %244, %242 ]
  %251 = phi i8* [ %240, %236 ], [ %246, %242 ]
  %252 = bitcast i8* %251 to i32*
  %253 = load i32, i32* %252, align 4
  %254 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 12
  %255 = load i8, i8* %254, align 2, !tbaa !40
  %256 = icmp eq i8 %255, 1
  br i1 %256, label %262, label %257

; <label>:257:                                    ; preds = %248
  %258 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 5
  %259 = load i64, i64* %258, align 8, !tbaa !41
  %260 = icmp eq i64 %259, 0
  %261 = select i1 %260, i32 11, i32 10
  br label %262

; <label>:262:                                    ; preds = %257, %248
  %263 = phi i32 [ 10, %248 ], [ %261, %257 ]
  %264 = icmp eq i32 %250, 0
  br i1 %264, label %269, label %265

; <label>:265:                                    ; preds = %262
  %266 = sdiv i32 %250, 4
  %267 = trunc i32 %266 to i8
  %268 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 17
  store i8 %267, i8* %268, align 1, !tbaa !47
  br label %269

; <label>:269:                                    ; preds = %262, %265
  %270 = icmp eq i32 %249, 0
  br i1 %270, label %275, label %271

; <label>:271:                                    ; preds = %269
  %272 = sdiv i32 %249, 4
  %273 = trunc i32 %272 to i8
  %274 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 18
  store i8 %273, i8* %274, align 4, !tbaa !57
  br label %275

; <label>:275:                                    ; preds = %269, %271
  %276 = icmp eq i32 %253, 0
  br i1 %276, label %280, label %277

; <label>:277:                                    ; preds = %275
  %278 = trunc i32 %253 to i8
  %279 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 19
  store i8 %278, i8* %279, align 1, !tbaa !58
  br label %280

; <label>:280:                                    ; preds = %275, %277
  %281 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %282 = getelementptr inbounds %struct.global_State, %struct.global_State* %281, i64 0, i32 12
  %283 = load i8, i8* %282, align 2, !tbaa !40
  %284 = icmp eq i8 %283, 0
  br i1 %284, label %286, label %285

; <label>:285:                                    ; preds = %280
  call fastcc void @enterinc(%struct.global_State* %281) #17
  br label %286

; <label>:286:                                    ; preds = %280, %285
  %287 = getelementptr inbounds %struct.global_State, %struct.global_State* %281, i64 0, i32 5
  store i64 0, i64* %287, align 8, !tbaa !41
  br label %288

; <label>:288:                                    ; preds = %80, %2, %78, %286, %199, %133, %123, %99, %25, %17, %16, %9, %7
  %289 = phi i32 [ %263, %286 ], [ %181, %199 ], [ %136, %133 ], [ %130, %123 ], [ %106, %99 ], [ %32, %25 ], [ %24, %17 ], [ 0, %16 ], [ 0, %9 ], [ 0, %7 ], [ 0, %78 ], [ %84, %80 ], [ -1, %2 ]
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i32 %289
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaC_fullgc(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = trunc i32 %1 to i8
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 16
  store i8 %5, i8* %6, align 2, !tbaa !81
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 12
  %8 = load i8, i8* %7, align 2, !tbaa !40
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %79

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %12 = load i8, i8* %11, align 1, !tbaa !42
  %13 = icmp ult i8 %12, 3
  br i1 %13, label %14, label %24

; <label>:14:                                     ; preds = %10
  store i8 3, i8* %11, align 1, !tbaa !42
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 20
  br label %16

; <label>:16:                                     ; preds = %16, %14
  %17 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %15, i32 1, i32* null) #17
  %18 = icmp eq %struct.GCObject** %17, %15
  br i1 %18, label %16, label %19

; <label>:19:                                     ; preds = %16
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 21
  store %struct.GCObject** %17, %struct.GCObject*** %20, align 8, !tbaa !46
  %21 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 11
  %23 = load i8, i8* %22, align 1, !tbaa !42
  br label %24

; <label>:24:                                     ; preds = %19, %10
  %25 = phi i8* [ %22, %19 ], [ %11, %10 ]
  %26 = phi i8 [ %23, %19 ], [ %12, %10 ]
  %27 = icmp eq i8 %26, 8
  br i1 %27, label %38, label %28

; <label>:28:                                     ; preds = %24
  br label %29

; <label>:29:                                     ; preds = %28, %29
  %30 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %31 = load i8, i8* %25, align 1, !tbaa !42
  %32 = icmp eq i8 %31, 8
  br i1 %32, label %33, label %29

; <label>:33:                                     ; preds = %29
  %34 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %34, i64 0, i32 11
  %36 = load i8, i8* %35, align 1, !tbaa !42
  %37 = icmp eq i8 %36, 7
  br i1 %37, label %49, label %38

; <label>:38:                                     ; preds = %24, %33
  %39 = phi i8* [ %35, %33 ], [ %25, %24 ]
  br label %40

; <label>:40:                                     ; preds = %38, %40
  %41 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %42 = load i8, i8* %39, align 1, !tbaa !42
  %43 = icmp eq i8 %42, 7
  br i1 %43, label %44, label %40

; <label>:44:                                     ; preds = %40
  %45 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %46 = getelementptr inbounds %struct.global_State, %struct.global_State* %45, i64 0, i32 11
  %47 = load i8, i8* %46, align 1, !tbaa !42
  %48 = icmp eq i8 %47, 8
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %33, %44
  %50 = phi i8* [ %46, %44 ], [ %35, %33 ]
  br label %51

; <label>:51:                                     ; preds = %49, %51
  %52 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %53 = load i8, i8* %50, align 1, !tbaa !42
  %54 = icmp eq i8 %53, 8
  br i1 %54, label %55, label %51

; <label>:55:                                     ; preds = %51, %44
  %56 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 17
  %57 = load i8, i8* %56, align 1, !tbaa !47
  %58 = zext i8 %57 to i64
  %59 = shl nuw nsw i64 %58, 2
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 4
  %61 = load i64, i64* %60, align 8, !tbaa !45
  %62 = udiv i64 %61, 100
  %63 = udiv i64 9223372036854775807, %62
  %64 = icmp ult i64 %59, %63
  %65 = mul nsw i64 %62, %59
  %66 = select i1 %64, i64 %65, i64 9223372036854775807
  %67 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 2
  %68 = load i64, i64* %67, align 8, !tbaa !43
  %69 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 3
  %70 = load i64, i64* %69, align 8, !tbaa !11
  %71 = add nsw i64 %70, %68
  %72 = sub i64 %71, %66
  %73 = icmp slt i64 %72, 0
  %74 = select i1 %73, i64 %72, i64 0
  %75 = add nsw i64 %71, -9223372036854775807
  %76 = icmp sgt i64 %75, %74
  %77 = select i1 %76, i64 %75, i64 %74
  %78 = sub nsw i64 %71, %77
  store i64 %78, i64* %67, align 8, !tbaa !43
  store i64 %77, i64* %69, align 8, !tbaa !11
  br label %81

; <label>:79:                                     ; preds = %2
  tail call fastcc void @enterinc(%struct.global_State* %4) #17
  %80 = tail call fastcc i64 @entergen(%struct.lua_State* nonnull %0, %struct.global_State* %4) #17
  br label %81

; <label>:81:                                     ; preds = %79, %55
  store i8 0, i8* %6, align 2, !tbaa !81
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define i32 @lua_error(%struct.lua_State*) local_unnamed_addr #5 {
  tail call fastcc void @luaG_errormsg(%struct.lua_State* %0) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_errormsg(%struct.lua_State*) unnamed_addr #5 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  %3 = load i64, i64* %2, align 8, !tbaa !36
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %30, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !23
  %9 = getelementptr inbounds i8, i8* %8, i64 %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %13 = bitcast %struct.TValue* %12 to i64*
  %14 = bitcast %union.StackValue* %11 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  %21 = bitcast i8* %9 to i64*
  %22 = bitcast %struct.TValue* %20 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds i8, i8* %9, i64 8
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %10, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %29, i32 1) #16
  br label %30

; <label>:30:                                     ; preds = %1, %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 2) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define i32 @lua_next(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %4 = bitcast %struct.TValue* %3 to %struct.Table**
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1
  %9 = tail call fastcc i32 @luaH_realasize(%struct.Table* %5) #17
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = and i8 %12, 15
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %44, label %15

; <label>:15:                                     ; preds = %2
  %16 = icmp eq i8 %12, 35
  br i1 %16, label %17, label %24

; <label>:17:                                     ; preds = %15
  %18 = bitcast %union.StackValue* %8 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = add i64 %19, -1
  %21 = icmp ult i64 %20, 2147483648
  %22 = trunc i64 %19 to i32
  %23 = select i1 %21, i32 %22, i32 0
  br label %24

; <label>:24:                                     ; preds = %17, %15
  %25 = phi i32 [ %23, %17 ], [ 0, %15 ]
  %26 = add i32 %25, -1
  %27 = icmp ult i32 %26, %9
  br i1 %27, label %44, label %28

; <label>:28:                                     ; preds = %24
  %29 = tail call fastcc %struct.TValue* @getgeneric(%struct.Table* %5, %struct.TValue* nonnull %10) #17
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %29, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = icmp eq i8 %31, 32
  br i1 %32, label %33, label %34, !prof !61

; <label>:33:                                     ; preds = %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.280, i64 0, i64 0)) #19
  unreachable

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 7
  %36 = bitcast %union.Node** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !156
  %38 = ptrtoint %struct.TValue* %29 to i64
  %39 = sub i64 %38, %37
  %40 = sdiv exact i64 %39, 24
  %41 = trunc i64 %40 to i32
  %42 = add i32 %9, 1
  %43 = add i32 %42, %41
  br label %44

; <label>:44:                                     ; preds = %34, %24, %2
  %45 = phi i32 [ %43, %34 ], [ 0, %2 ], [ %25, %24 ]
  %46 = icmp ult i32 %45, %9
  br i1 %46, label %47, label %70

; <label>:47:                                     ; preds = %44
  %48 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 6
  %49 = load %struct.TValue*, %struct.TValue** %48, align 8, !tbaa !91
  br label %52

; <label>:50:                                     ; preds = %52
  %51 = icmp ult i32 %59, %9
  br i1 %51, label %52, label %70

; <label>:52:                                     ; preds = %50, %47
  %53 = phi i32 [ %45, %47 ], [ %59, %50 ]
  %54 = zext i32 %53 to i64
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 %54, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !22
  %57 = and i8 %56, 15
  %58 = icmp eq i8 %57, 0
  %59 = add i32 %53, 1
  br i1 %58, label %50, label %60

; <label>:60:                                     ; preds = %52
  %61 = zext i32 %53 to i64
  %62 = zext i32 %59 to i64
  %63 = bitcast %union.StackValue* %8 to i64*
  store i64 %62, i64* %63, align 8, !tbaa !21
  store i8 35, i8* %11, align 8, !tbaa !22
  %64 = load %struct.TValue*, %struct.TValue** %48, align 8, !tbaa !91
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %64, i64 %61
  %66 = bitcast %struct.TValue* %65 to i64*
  %67 = bitcast %union.StackValue* %7 to i64*
  %68 = load i64, i64* %66, align 8
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds %struct.TValue, %struct.TValue* %64, i64 %61, i32 1
  br label %103

; <label>:70:                                     ; preds = %50, %44
  %71 = phi i32 [ %45, %44 ], [ %59, %50 ]
  %72 = sub i32 %71, %9
  %73 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 4
  %74 = load i8, i8* %73, align 1, !tbaa !93
  %75 = zext i8 %74 to i32
  %76 = shl i32 1, %75
  %77 = icmp slt i32 %72, %76
  br i1 %77, label %78, label %107

; <label>:78:                                     ; preds = %70
  %79 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 7
  %80 = load %union.Node*, %union.Node** %79, align 8, !tbaa !156
  br label %83

; <label>:81:                                     ; preds = %83
  %82 = icmp slt i32 %90, %76
  br i1 %82, label %83, label %107

; <label>:83:                                     ; preds = %81, %78
  %84 = phi i32 [ %72, %78 ], [ %90, %81 ]
  %85 = zext i32 %84 to i64
  %86 = getelementptr inbounds %union.Node, %union.Node* %80, i64 %85, i32 0, i32 1
  %87 = load i8, i8* %86, align 8, !tbaa !21
  %88 = and i8 %87, 15
  %89 = icmp eq i8 %88, 0
  %90 = add nsw i32 %84, 1
  br i1 %89, label %81, label %91

; <label>:91:                                     ; preds = %83
  %92 = zext i32 %84 to i64
  %93 = getelementptr inbounds %union.Node, %union.Node* %80, i64 %92, i32 0, i32 4
  %94 = bitcast %union.Value* %93 to i64*
  %95 = bitcast %union.StackValue* %8 to i64*
  %96 = load i64, i64* %94, align 8
  store i64 %96, i64* %95, align 8
  %97 = getelementptr inbounds %union.Node, %union.Node* %80, i64 %92, i32 0, i32 2
  %98 = load i8, i8* %97, align 1, !tbaa !21
  store i8 %98, i8* %11, align 8, !tbaa !22
  %99 = getelementptr inbounds %union.Node, %union.Node* %80, i64 %92, i32 0, i32 0
  %100 = bitcast %union.Value* %99 to i64*
  %101 = bitcast %union.StackValue* %7 to i64*
  %102 = load i64, i64* %100, align 8
  store i64 %102, i64* %101, align 8
  br label %103

; <label>:103:                                    ; preds = %60, %91
  %104 = phi i8* [ %69, %60 ], [ %86, %91 ]
  %105 = load i8, i8* %104, align 8, !tbaa !22
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0, i32 1
  store i8 %105, i8* %106, align 8, !tbaa !22
  br label %107

; <label>:107:                                    ; preds = %81, %70, %103
  %108 = phi i64 [ 1, %103 ], [ -1, %70 ], [ -1, %81 ]
  %109 = phi i32 [ 1, %103 ], [ 0, %70 ], [ 0, %81 ]
  %110 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %111 = getelementptr inbounds %union.StackValue, %union.StackValue* %110, i64 %108
  store %union.StackValue* %111, %union.StackValue** %6, align 8, !tbaa !20
  ret i32 %109
}

; Function Attrs: nounwind optsize uwtable
define void @lua_toclose(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 %9
  br label %18

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = sext i32 %1 to i64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 %14
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %17 = load %struct.CallInfo*, %struct.CallInfo** %16, align 8, !tbaa !24
  br label %18

; <label>:18:                                     ; preds = %4, %11
  %19 = phi %struct.CallInfo** [ %5, %4 ], [ %16, %11 ]
  %20 = phi %struct.CallInfo* [ %6, %4 ], [ %17, %11 ]
  %21 = phi %union.StackValue* [ %10, %4 ], [ %15, %11 ]
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 6
  %23 = load i16, i16* %22, align 4, !tbaa !65
  tail call fastcc void @luaF_newtbcupval(%struct.lua_State* nonnull %0, %union.StackValue* %21) #16
  %24 = icmp slt i16 %23, -1
  br i1 %24, label %29, label %25

; <label>:25:                                     ; preds = %18
  %26 = sub i16 -3, %23
  %27 = load %struct.CallInfo*, %struct.CallInfo** %19, align 8, !tbaa !24
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %27, i64 0, i32 6
  store i16 %26, i16* %28, align 4, !tbaa !65
  br label %29

; <label>:29:                                     ; preds = %25, %18
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaF_newtbcupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = bitcast %union.StackValue* %1 to i8*
  %4 = tail call fastcc i32 @luaD_rawrunprotected(%struct.lua_State* %0, void (%struct.lua_State*, i8*)* nonnull @trynewtbcupval, i8* %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %27, label %6, !prof !73

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %9, i64 0, i32 39
  %11 = load %struct.TString*, %struct.TString** %10, align 8, !tbaa !74
  %12 = bitcast %union.StackValue* %7 to %struct.TString**
  store %struct.TString* %11, %struct.TString** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !75
  %15 = or i8 %14, 64
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 1, i32 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 2
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %17, %union.StackValue** %18, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  %21 = tail call fastcc i32 @prepclosingmethod(%struct.lua_State* %0, %struct.TValue* %19, %struct.TValue* nonnull %20) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %26, label %23

; <label>:23:                                     ; preds = %6
  %24 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %25, i32 0) #17
  br label %26

; <label>:26:                                     ; preds = %6, %23
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:27:                                     ; preds = %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_concat(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = icmp sgt i32 %1, 1
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %1) #16
  br label %19

; <label>:5:                                      ; preds = %2
  %6 = icmp eq i32 %1, 0
  br i1 %6, label %7, label %19

; <label>:7:                                      ; preds = %5
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64 0) #16
  %12 = bitcast %struct.TValue* %10 to %struct.TString**
  store %struct.TString* %11, %struct.TString** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %11, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !75
  %15 = or i8 %14, 64
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %8, align 8, !tbaa !20
  br label %19

; <label>:19:                                     ; preds = %5, %7, %4
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = icmp sgt i64 %23, 0
  br i1 %24, label %25, label %26

; <label>:25:                                     ; preds = %19
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %26

; <label>:26:                                     ; preds = %25, %19
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaV_concat(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [50 x i8], align 16
  %4 = alloca [40 x i8], align 16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = getelementptr inbounds [50 x i8], [50 x i8]* %3, i64 0, i64 0
  %7 = getelementptr inbounds [40 x i8], [40 x i8]* %4, i64 0, i64 0
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  br label %10

; <label>:10:                                     ; preds = %224, %2
  %11 = phi %union.StackValue* [ %9, %2 ], [ %231, %224 ]
  %12 = phi i32 [ %1, %2 ], [ %227, %224 ]
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -2
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 0, i32 0
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -2, i32 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !21
  %17 = and i8 %16, 15
  %18 = add nsw i8 %17, -3
  %19 = icmp ult i8 %18, 2
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  br i1 %19, label %21, label %32

; <label>:21:                                     ; preds = %10
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !21
  %24 = trunc i8 %23 to i4
  switch i4 %24, label %32 [
    i4 4, label %33
    i4 3, label %25
  ]

; <label>:25:                                     ; preds = %21
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %6) #7
  %26 = call fastcc i64 @tostringbuff(%struct.TValue* nonnull %20, i8* nonnull %6) #17
  %27 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %6, i64 %26) #17
  %28 = bitcast %struct.TValue* %20 to %struct.TString**
  store %struct.TString* %27, %struct.TString** %28, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.TString, %struct.TString* %27, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !75
  %31 = or i8 %30, 64
  store i8 %31, i8* %22, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %6) #7
  br label %33

; <label>:32:                                     ; preds = %10, %21
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %14, %struct.TValue* nonnull %20, %union.StackValue* nonnull %13, i32 22) #16
  br label %224

; <label>:33:                                     ; preds = %21, %25
  %34 = phi i8 [ %23, %21 ], [ %31, %25 ]
  %35 = icmp eq i8 %34, 84
  br i1 %35, label %36, label %53

; <label>:36:                                     ; preds = %33
  %37 = bitcast %struct.TValue* %20 to %struct.TString**
  %38 = load %struct.TString*, %struct.TString** %37, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TString, %struct.TString* %38, i64 0, i32 4
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %42, label %53

; <label>:42:                                     ; preds = %36
  %43 = load i8, i8* %15, align 8, !tbaa !21
  %44 = and i8 %43, 15
  %45 = icmp eq i8 %44, 3
  br i1 %45, label %46, label %224

; <label>:46:                                     ; preds = %42
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %6) #7
  %47 = call fastcc i64 @tostringbuff(%struct.TValue* nonnull %14, i8* nonnull %6) #17
  %48 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %6, i64 %47) #17
  %49 = bitcast %union.StackValue* %13 to %struct.TString**
  store %struct.TString* %48, %struct.TString** %49, align 8, !tbaa !21
  %50 = getelementptr inbounds %struct.TString, %struct.TString* %48, i64 0, i32 1
  %51 = load i8, i8* %50, align 8, !tbaa !75
  %52 = or i8 %51, 64
  store i8 %52, i8* %15, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %6) #7
  br label %224

; <label>:53:                                     ; preds = %36, %33
  %54 = load i8, i8* %15, align 8, !tbaa !21
  %55 = icmp eq i8 %54, 84
  br i1 %55, label %56, label %66

; <label>:56:                                     ; preds = %53
  %57 = bitcast %union.StackValue* %13 to %struct.TString**
  %58 = load %struct.TString*, %struct.TString** %57, align 8, !tbaa !21
  %59 = getelementptr inbounds %struct.TString, %struct.TString* %58, i64 0, i32 4
  %60 = load i8, i8* %59, align 1, !tbaa !21
  %61 = icmp eq i8 %60, 0
  br i1 %61, label %62, label %66

; <label>:62:                                     ; preds = %56
  %63 = bitcast %struct.TValue* %20 to i64*
  %64 = bitcast %union.StackValue* %13 to i64*
  %65 = load i64, i64* %63, align 8
  store i64 %65, i64* %64, align 8
  store i8 %34, i8* %15, align 8, !tbaa !22
  br label %224

; <label>:66:                                     ; preds = %56, %53
  %67 = bitcast %struct.TValue* %20 to %struct.TString**
  %68 = load %struct.TString*, %struct.TString** %67, align 8, !tbaa !21
  %69 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 1
  %70 = load i8, i8* %69, align 8, !tbaa !21
  %71 = icmp eq i8 %70, 20
  br i1 %71, label %72, label %76

; <label>:72:                                     ; preds = %66
  %73 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 4
  %74 = load i8, i8* %73, align 1, !tbaa !21
  %75 = zext i8 %74 to i64
  br label %79

; <label>:76:                                     ; preds = %66
  %77 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 6, i32 0
  %78 = load i64, i64* %77, align 8, !tbaa !21
  br label %79

; <label>:79:                                     ; preds = %76, %72
  %80 = phi i64 [ %75, %72 ], [ %78, %76 ]
  %81 = icmp sgt i32 %12, 1
  br i1 %81, label %82, label %130

; <label>:82:                                     ; preds = %79
  %83 = sext i32 %12 to i64
  br label %84

; <label>:84:                                     ; preds = %82, %123
  %85 = phi i64 [ 1, %82 ], [ %125, %123 ]
  %86 = phi i32 [ 1, %82 ], [ %126, %123 ]
  %87 = phi i64 [ %80, %82 ], [ %124, %123 ]
  %88 = sub nsw i64 0, %85
  %89 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %88
  %90 = getelementptr inbounds %union.StackValue, %union.StackValue* %89, i64 -1
  %91 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 0, i32 0, i32 1
  %92 = load i8, i8* %91, align 8, !tbaa !21
  %93 = trunc i8 %92 to i4
  switch i4 %93, label %128 [
    i4 4, label %94
    i4 3, label %98
  ]

; <label>:94:                                     ; preds = %84
  %95 = bitcast %union.StackValue* %90 to %struct.TString**
  %96 = load %struct.TString*, %struct.TString** %95, align 8, !tbaa !21
  %97 = getelementptr inbounds %struct.TString, %struct.TString* %96, i64 0, i32 1
  br label %106

; <label>:98:                                     ; preds = %84
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 0, i32 0
  call void @llvm.lifetime.start.p0i8(i64 50, i8* nonnull %6) #7
  %100 = call fastcc i64 @tostringbuff(%struct.TValue* nonnull %99, i8* nonnull %6) #17
  %101 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %6, i64 %100) #17
  %102 = bitcast %union.StackValue* %90 to %struct.TString**
  store %struct.TString* %101, %struct.TString** %102, align 8, !tbaa !21
  %103 = getelementptr inbounds %struct.TString, %struct.TString* %101, i64 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !75
  %105 = or i8 %104, 64
  store i8 %105, i8* %91, align 8, !tbaa !22
  call void @llvm.lifetime.end.p0i8(i64 50, i8* nonnull %6) #7
  br label %106

; <label>:106:                                    ; preds = %94, %98
  %107 = phi i8* [ %97, %94 ], [ %103, %98 ]
  %108 = phi %struct.TString* [ %96, %94 ], [ %101, %98 ]
  %109 = load i8, i8* %107, align 8, !tbaa !21
  %110 = icmp eq i8 %109, 20
  br i1 %110, label %111, label %115

; <label>:111:                                    ; preds = %106
  %112 = getelementptr inbounds %struct.TString, %struct.TString* %108, i64 0, i32 4
  %113 = load i8, i8* %112, align 1, !tbaa !21
  %114 = zext i8 %113 to i64
  br label %118

; <label>:115:                                    ; preds = %106
  %116 = getelementptr inbounds %struct.TString, %struct.TString* %108, i64 0, i32 6, i32 0
  %117 = load i64, i64* %116, align 8, !tbaa !21
  br label %118

; <label>:118:                                    ; preds = %115, %111
  %119 = phi i64 [ %114, %111 ], [ %117, %115 ]
  %120 = sub i64 9223372036854775807, %87
  %121 = icmp ult i64 %119, %120
  br i1 %121, label %123, label %122, !prof !73

; <label>:122:                                    ; preds = %118
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.281, i64 0, i64 0)) #18
  unreachable

; <label>:123:                                    ; preds = %118
  %124 = add i64 %119, %87
  %125 = add nuw nsw i64 %85, 1
  %126 = add nuw nsw i32 %86, 1
  %127 = icmp slt i64 %125, %83
  br i1 %127, label %84, label %130

; <label>:128:                                    ; preds = %84
  %129 = trunc i64 %85 to i32
  br label %130

; <label>:130:                                    ; preds = %123, %128, %79
  %131 = phi i64 [ %80, %79 ], [ %87, %128 ], [ %124, %123 ]
  %132 = phi i32 [ 1, %79 ], [ %129, %128 ], [ %126, %123 ]
  %133 = icmp ult i64 %131, 41
  br i1 %133, label %134, label %163

; <label>:134:                                    ; preds = %130
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %7) #7
  %135 = zext i32 %132 to i64
  br label %136

; <label>:136:                                    ; preds = %153, %134
  %137 = phi i64 [ %159, %153 ], [ %135, %134 ]
  %138 = phi i64 [ %158, %153 ], [ 0, %134 ]
  %139 = sub nsw i64 0, %137
  %140 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %139, i32 0, i32 0, i32 0
  %141 = bitcast %struct.GCObject** %140 to %struct.TString**
  %142 = load %struct.TString*, %struct.TString** %141, align 8, !tbaa !21
  %143 = getelementptr inbounds %struct.TString, %struct.TString* %142, i64 0, i32 1
  %144 = load i8, i8* %143, align 8, !tbaa !21
  %145 = icmp eq i8 %144, 20
  br i1 %145, label %146, label %150

; <label>:146:                                    ; preds = %136
  %147 = getelementptr inbounds %struct.TString, %struct.TString* %142, i64 0, i32 4
  %148 = load i8, i8* %147, align 1, !tbaa !21
  %149 = zext i8 %148 to i64
  br label %153

; <label>:150:                                    ; preds = %136
  %151 = getelementptr inbounds %struct.TString, %struct.TString* %142, i64 0, i32 6, i32 0
  %152 = load i64, i64* %151, align 8, !tbaa !21
  br label %153

; <label>:153:                                    ; preds = %150, %146
  %154 = phi i64 [ %149, %146 ], [ %152, %150 ]
  %155 = getelementptr inbounds [40 x i8], [40 x i8]* %4, i64 0, i64 %138
  %156 = getelementptr inbounds %struct.TString, %struct.TString* %142, i64 1
  %157 = bitcast %struct.TString* %156 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %155, i8* nonnull %157, i64 %154, i32 1, i1 false) #7
  %158 = add i64 %154, %138
  %159 = add nsw i64 %137, -1
  %160 = icmp sgt i64 %137, 1
  br i1 %160, label %136, label %161

; <label>:161:                                    ; preds = %153
  %162 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %0, i8* nonnull %7, i64 %131) #16
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %7) #7
  br label %214

; <label>:163:                                    ; preds = %130
  %164 = load %struct.global_State*, %struct.global_State** %8, align 8, !tbaa !2
  %165 = getelementptr inbounds %struct.global_State, %struct.global_State* %164, i64 0, i32 9
  %166 = load i32, i32* %165, align 8, !tbaa !78
  %167 = add i64 %131, 25
  %168 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %167, i32 4) #17
  %169 = getelementptr inbounds %struct.global_State, %struct.global_State* %164, i64 0, i32 10
  %170 = load i8, i8* %169, align 4, !tbaa !15
  %171 = and i8 %170, 24
  %172 = getelementptr inbounds i8, i8* %168, i64 9
  store i8 %171, i8* %172, align 1, !tbaa !70
  %173 = getelementptr inbounds i8, i8* %168, i64 8
  store i8 36, i8* %173, align 8, !tbaa !86
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %164, i64 0, i32 20
  %175 = bitcast %struct.GCObject** %174 to i64*
  %176 = load i64, i64* %175, align 8, !tbaa !18
  %177 = bitcast i8* %168 to i64*
  store i64 %176, i64* %177, align 8, !tbaa !87
  %178 = bitcast %struct.GCObject** %174 to i8**
  store i8* %168, i8** %178, align 8, !tbaa !18
  %179 = getelementptr inbounds i8, i8* %168, i64 12
  %180 = bitcast i8* %179 to i32*
  store i32 %166, i32* %180, align 4, !tbaa !150
  %181 = getelementptr inbounds i8, i8* %168, i64 10
  store i8 0, i8* %181, align 2, !tbaa !99
  %182 = getelementptr inbounds i8, i8* %168, i64 24
  %183 = getelementptr inbounds i8, i8* %182, i64 %131
  store i8 0, i8* %183, align 1, !tbaa !21
  %184 = getelementptr inbounds i8, i8* %168, i64 16
  %185 = bitcast i8* %184 to i64*
  store i64 %131, i64* %185, align 8, !tbaa !21
  %186 = zext i32 %132 to i64
  br label %187

; <label>:187:                                    ; preds = %204, %163
  %188 = phi i64 [ %210, %204 ], [ %186, %163 ]
  %189 = phi i64 [ %209, %204 ], [ 0, %163 ]
  %190 = sub nsw i64 0, %188
  %191 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %190, i32 0, i32 0, i32 0
  %192 = bitcast %struct.GCObject** %191 to %struct.TString**
  %193 = load %struct.TString*, %struct.TString** %192, align 8, !tbaa !21
  %194 = getelementptr inbounds %struct.TString, %struct.TString* %193, i64 0, i32 1
  %195 = load i8, i8* %194, align 8, !tbaa !21
  %196 = icmp eq i8 %195, 20
  br i1 %196, label %197, label %201

; <label>:197:                                    ; preds = %187
  %198 = getelementptr inbounds %struct.TString, %struct.TString* %193, i64 0, i32 4
  %199 = load i8, i8* %198, align 1, !tbaa !21
  %200 = zext i8 %199 to i64
  br label %204

; <label>:201:                                    ; preds = %187
  %202 = getelementptr inbounds %struct.TString, %struct.TString* %193, i64 0, i32 6, i32 0
  %203 = load i64, i64* %202, align 8, !tbaa !21
  br label %204

; <label>:204:                                    ; preds = %201, %197
  %205 = phi i64 [ %200, %197 ], [ %203, %201 ]
  %206 = getelementptr inbounds i8, i8* %182, i64 %189
  %207 = getelementptr inbounds %struct.TString, %struct.TString* %193, i64 1
  %208 = bitcast %struct.TString* %207 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %206, i8* nonnull %208, i64 %205, i32 1, i1 false) #7
  %209 = add i64 %205, %189
  %210 = add nsw i64 %188, -1
  %211 = icmp sgt i64 %188, 1
  br i1 %211, label %187, label %212

; <label>:212:                                    ; preds = %204
  %213 = bitcast i8* %168 to %struct.TString*
  br label %214

; <label>:214:                                    ; preds = %212, %161
  %215 = phi i64 [ %186, %212 ], [ %135, %161 ]
  %216 = phi %struct.TString* [ %213, %212 ], [ %162, %161 ]
  %217 = sub nsw i64 0, %215
  %218 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %217, i32 0
  %219 = bitcast %struct.TValue* %218 to %struct.TString**
  store %struct.TString* %216, %struct.TString** %219, align 8, !tbaa !21
  %220 = getelementptr inbounds %struct.TString, %struct.TString* %216, i64 0, i32 1
  %221 = load i8, i8* %220, align 8, !tbaa !75
  %222 = or i8 %221, 64
  %223 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 %217, i32 0, i32 1
  store i8 %222, i8* %223, align 8, !tbaa !22
  br label %224

; <label>:224:                                    ; preds = %42, %46, %214, %62, %32
  %225 = phi i32 [ 2, %62 ], [ %132, %214 ], [ 2, %32 ], [ 2, %42 ], [ 2, %46 ]
  %226 = add nsw i32 %225, -1
  %227 = sub nsw i32 %12, %226
  %228 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %229 = sext i32 %226 to i64
  %230 = sub nsw i64 0, %229
  %231 = getelementptr inbounds %union.StackValue, %union.StackValue* %228, i64 %230
  store %union.StackValue* %231, %union.StackValue** %5, align 8, !tbaa !20
  %232 = icmp sgt i32 %227, 1
  br i1 %232, label %10, label %233

; <label>:233:                                    ; preds = %224
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  tail call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %5, %struct.TValue* %3) #16
  %6 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  store %union.StackValue* %7, %union.StackValue** %4, align 8, !tbaa !20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaV_objlen(%struct.lua_State*, %union.StackValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i6
  switch i6 %6, label %51 [
    i6 5, label %7
    i6 20, label %36
    i6 -28, label %44
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %2 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !88
  %12 = icmp eq %struct.Table* %11, null
  br i1 %12, label %32, label %13

; <label>:13:                                     ; preds = %7
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %11, i64 0, i32 3
  %15 = load i8, i8* %14, align 2, !tbaa !90
  %16 = and i8 %15, 16
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %18, label %32

; <label>:18:                                     ; preds = %13
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %20 = load %struct.global_State*, %struct.global_State** %19, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 40, i64 4
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !54
  %23 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %11, %struct.TString* %22) #17
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = and i8 %25, 15
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %18
  %29 = or i8 %15, 16
  store i8 %29, i8* %14, align 2, !tbaa !90
  br label %32

; <label>:30:                                     ; preds = %18
  %31 = icmp eq %struct.TValue* %23, null
  br i1 %31, label %32, label %58

; <label>:32:                                     ; preds = %28, %13, %7, %30
  %33 = tail call fastcc i64 @luaH_getn(%struct.Table* %9) #16
  %34 = bitcast %union.StackValue* %1 to i64*
  store i64 %33, i64* %34, align 8, !tbaa !21
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %35, align 8, !tbaa !22
  br label %60

; <label>:36:                                     ; preds = %3
  %37 = bitcast %struct.TValue* %2 to %struct.TString**
  %38 = load %struct.TString*, %struct.TString** %37, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TString, %struct.TString* %38, i64 0, i32 4
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = zext i8 %40 to i64
  %42 = bitcast %union.StackValue* %1 to i64*
  store i64 %41, i64* %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %43, align 8, !tbaa !22
  br label %60

; <label>:44:                                     ; preds = %3
  %45 = bitcast %struct.TValue* %2 to %struct.TString**
  %46 = load %struct.TString*, %struct.TString** %45, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.TString, %struct.TString* %46, i64 0, i32 6, i32 0
  %48 = load i64, i64* %47, align 8, !tbaa !21
  %49 = bitcast %union.StackValue* %1 to i64*
  store i64 %48, i64* %49, align 8, !tbaa !21
  %50 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 35, i8* %50, align 8, !tbaa !22
  br label %60

; <label>:51:                                     ; preds = %3
  %52 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* nonnull %2, i32 4) #16
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %52, i64 0, i32 1
  %54 = load i8, i8* %53, align 8, !tbaa !22
  %55 = and i8 %54, 15
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %57, label %58, !prof !61

; <label>:57:                                     ; preds = %51
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* nonnull %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.282, i64 0, i64 0)) #18
  unreachable

; <label>:58:                                     ; preds = %30, %51
  %59 = phi %struct.TValue* [ %52, %51 ], [ %23, %30 ]
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %59, %struct.TValue* nonnull %2, %struct.TValue* nonnull %2, %union.StackValue* %1) #16
  br label %60

; <label>:60:                                     ; preds = %32, %58, %44, %36
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define i8* (i8*, i8*, i64, i64)* @lua_getallocf(%struct.lua_State* nocapture readonly, i8**) local_unnamed_addr #2 {
  %3 = icmp eq i8** %1, null
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br i1 %3, label %11, label %5

; <label>:5:                                      ; preds = %2
  %6 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %8 = bitcast i8** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !60
  %10 = bitcast i8** %1 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !54
  br label %11

; <label>:11:                                     ; preds = %2, %5
  %12 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 0
  %14 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %13, align 8, !tbaa !59
  ret i8* (i8*, i8*, i64, i64)* %14
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_setallocf(%struct.lua_State* nocapture readonly, i8* (i8*, i8*, i64, i64)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  store i8* %2, i8** %6, align 8, !tbaa !60
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  store i8* (i8*, i8*, i64, i64)* %1, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !59
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @lua_setwarnf(%struct.lua_State* nocapture readonly, void (i8*, i8*, i32)*, i8*) local_unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  store i8* %2, i8** %6, align 8, !tbaa !191
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  store void (i8*, i8*, i32)* %1, void (i8*, i8*, i32)** %7, align 8, !tbaa !192
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @lua_warning(%struct.lua_State* nocapture readonly, i8*, i32) local_unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 43
  %7 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %6, align 8, !tbaa !192
  %8 = icmp eq void (i8*, i8*, i32)* %7, null
  br i1 %8, label %12, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 44
  %11 = load i8*, i8** %10, align 8, !tbaa !191
  tail call void %7(i8* %11, i8* %1, i32 %2) #17
  br label %12

; <label>:12:                                     ; preds = %3, %9
  ret void
}

; Function Attrs: nounwind optsize uwtable
define nonnull i8* @lua_newuserdatauv(%struct.lua_State*, i64, i32) local_unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %3
  %6 = sext i32 %2 to i64
  %7 = shl nsw i64 %6, 4
  %8 = sub i64 9223372036854775767, %7
  br label %9

; <label>:9:                                      ; preds = %5, %3
  %10 = phi i64 [ %8, %5 ], [ 9223372036854775775, %3 ]
  %11 = icmp ult i64 %10, %1
  br i1 %11, label %12, label %13, !prof !61

; <label>:12:                                     ; preds = %9
  tail call fastcc void @luaM_toobig(%struct.lua_State* %0) #19
  unreachable

; <label>:13:                                     ; preds = %9
  br i1 %4, label %18, label %14

; <label>:14:                                     ; preds = %13
  %15 = sext i32 %2 to i64
  %16 = shl nsw i64 %15, 4
  %17 = add nsw i64 %16, 40
  br label %18

; <label>:18:                                     ; preds = %14, %13
  %19 = phi i64 [ %17, %14 ], [ 32, %13 ]
  %20 = add i64 %19, %1
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %20, i32 7) #17
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 10
  %25 = load i8, i8* %24, align 4, !tbaa !15
  %26 = and i8 %25, 24
  %27 = getelementptr inbounds i8, i8* %23, i64 9
  store i8 %26, i8* %27, align 1, !tbaa !70
  %28 = getelementptr inbounds i8, i8* %23, i64 8
  store i8 7, i8* %28, align 8, !tbaa !86
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 20
  %30 = bitcast %struct.GCObject** %29 to i64*
  %31 = load i64, i64* %30, align 8, !tbaa !18
  %32 = bitcast i8* %23 to i64*
  store i64 %31, i64* %32, align 8, !tbaa !87
  %33 = bitcast %struct.GCObject** %29 to i8**
  store i8* %23, i8** %33, align 8, !tbaa !18
  %34 = getelementptr inbounds i8, i8* %23, i64 16
  %35 = bitcast i8* %34 to i64*
  store i64 %1, i64* %35, align 8, !tbaa !193
  %36 = trunc i32 %2 to i16
  %37 = getelementptr inbounds i8, i8* %23, i64 10
  %38 = bitcast i8* %37 to i16*
  store i16 %36, i16* %38, align 2, !tbaa !195
  %39 = getelementptr inbounds i8, i8* %23, i64 24
  %40 = bitcast i8* %39 to %struct.Table**
  store %struct.Table* null, %struct.Table** %40, align 8, !tbaa !196
  %41 = icmp sgt i32 %2, 0
  br i1 %41, label %42, label %51

; <label>:42:                                     ; preds = %18
  %43 = getelementptr inbounds i8, i8* %23, i64 40
  %44 = bitcast i8* %43 to [1 x %union.UValue]*
  %45 = zext i32 %2 to i64
  br label %46

; <label>:46:                                     ; preds = %46, %42
  %47 = phi i64 [ 0, %42 ], [ %49, %46 ]
  %48 = getelementptr inbounds [1 x %union.UValue], [1 x %union.UValue]* %44, i64 0, i64 %47, i32 0, i32 1
  store i8 0, i8* %48, align 8, !tbaa !21
  %49 = add nuw nsw i64 %47, 1
  %50 = icmp eq i64 %49, %45
  br i1 %50, label %51, label %46

; <label>:51:                                     ; preds = %46, %18
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %53 = bitcast %union.StackValue** %52 to %struct.TValue**
  %54 = load %struct.TValue*, %struct.TValue** %53, align 8, !tbaa !20
  %55 = bitcast %struct.TValue* %54 to i8**
  store i8* %23, i8** %55, align 8, !tbaa !21
  %56 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 0, i32 1
  store i8 71, i8* %56, align 8, !tbaa !22
  %57 = load %union.StackValue*, %union.StackValue** %52, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 1
  store %union.StackValue* %58, %union.StackValue** %52, align 8, !tbaa !20
  %59 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %59, i64 0, i32 3
  %61 = load i64, i64* %60, align 8, !tbaa !11
  %62 = icmp sgt i64 %61, 0
  br i1 %62, label %63, label %64

; <label>:63:                                     ; preds = %51
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %64

; <label>:64:                                     ; preds = %63, %51
  %65 = load i16, i16* %38, align 2, !tbaa !195
  %66 = icmp eq i16 %65, 0
  %67 = zext i16 %65 to i64
  %68 = shl nuw nsw i64 %67, 4
  %69 = add nuw nsw i64 %68, 40
  %70 = select i1 %66, i64 32, i64 %69
  %71 = getelementptr inbounds i8, i8* %23, i64 %70
  ret i8* %71
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_getupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !54
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %7 = call fastcc i8* @aux_upvalue(%struct.TValue* %6, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** null) #16
  %8 = icmp eq i8* %7, null
  br i1 %8, label %22, label %9

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !54
  %14 = bitcast %struct.TValue* %13 to i64*
  %15 = bitcast %struct.TValue* %12 to i64*
  %16 = load i64, i64* %14, align 8
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %18, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %10, align 8, !tbaa !20
  br label %22

; <label>:22:                                     ; preds = %3, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i8* %7
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i8* @aux_upvalue(%struct.TValue* nocapture readonly, i32, %struct.TValue** nocapture, %struct.GCObject**) unnamed_addr #2 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %53 [
    i6 -10, label %8
    i6 22, label %22
  ]

; <label>:8:                                      ; preds = %4
  %9 = bitcast %struct.TValue* %0 to %struct.CClosure**
  %10 = load %struct.CClosure*, %struct.CClosure** %9, align 8, !tbaa !21
  %11 = add i32 %1, -1
  %12 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 3
  %13 = load i8, i8* %12, align 2, !tbaa !138
  %14 = zext i8 %13 to i32
  %15 = icmp ult i32 %11, %14
  br i1 %15, label %16, label %53

; <label>:16:                                     ; preds = %8
  %17 = sext i32 %11 to i64
  %18 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %10, i64 0, i32 6, i64 %17
  store %struct.TValue* %18, %struct.TValue** %2, align 8, !tbaa !54
  %19 = icmp eq %struct.GCObject** %3, null
  br i1 %19, label %53, label %20

; <label>:20:                                     ; preds = %16
  %21 = bitcast %struct.GCObject** %3 to %struct.CClosure**
  store %struct.CClosure* %10, %struct.CClosure** %21, align 8, !tbaa !54
  br label %53

; <label>:22:                                     ; preds = %4
  %23 = bitcast %struct.TValue* %0 to %struct.LClosure**
  %24 = load %struct.LClosure*, %struct.LClosure** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 5
  %26 = load %struct.Proto*, %struct.Proto** %25, align 8, !tbaa !197
  %27 = add i32 %1, -1
  %28 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 6
  %29 = load i32, i32* %28, align 8, !tbaa !190
  %30 = icmp ult i32 %27, %29
  br i1 %30, label %31, label %53

; <label>:31:                                     ; preds = %22
  %32 = sext i32 %27 to i64
  %33 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %24, i64 0, i32 6, i64 %32
  %34 = load %struct.UpVal*, %struct.UpVal** %33, align 8, !tbaa !54
  %35 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %34, i64 0, i32 3
  %36 = bitcast %struct.TValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !67
  %38 = bitcast %struct.TValue** %2 to i64*
  store i64 %37, i64* %38, align 8, !tbaa !54
  %39 = icmp eq %struct.GCObject** %3, null
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %31
  %41 = bitcast %struct.UpVal** %33 to i64*
  %42 = load i64, i64* %41, align 8, !tbaa !54
  %43 = bitcast %struct.GCObject** %3 to i64*
  store i64 %42, i64* %43, align 8, !tbaa !54
  br label %44

; <label>:44:                                     ; preds = %31, %40
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %26, i64 0, i32 18
  %46 = load %struct.Upvaldesc*, %struct.Upvaldesc** %45, align 8, !tbaa !198
  %47 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %46, i64 %32, i32 0
  %48 = load %struct.TString*, %struct.TString** %47, align 8, !tbaa !199
  %49 = icmp eq %struct.TString* %48, null
  %50 = getelementptr inbounds %struct.TString, %struct.TString* %48, i64 1
  %51 = bitcast %struct.TString* %50 to i8*
  %52 = select i1 %49, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.283, i64 0, i64 0), i8* %51
  br label %53

; <label>:53:                                     ; preds = %4, %44, %22, %8, %16, %20
  %54 = phi i8* [ null, %8 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %16 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %20 ], [ %52, %44 ], [ null, %22 ], [ null, %4 ]
  ret i8* %54
}

; Function Attrs: nounwind optsize uwtable
define i8* @lua_setupvalue(%struct.lua_State* nocapture, i32, i32) local_unnamed_addr #0 {
  %4 = alloca %struct.TValue*, align 8
  %5 = alloca %struct.GCObject*, align 8
  %6 = bitcast %struct.TValue** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  store %struct.TValue* null, %struct.TValue** %4, align 8, !tbaa !54
  %7 = bitcast %struct.GCObject** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  store %struct.GCObject* null, %struct.GCObject** %5, align 8, !tbaa !54
  %8 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %9 = call fastcc i8* @aux_upvalue(%struct.TValue* %8, i32 %2, %struct.TValue** nonnull %4, %struct.GCObject** nonnull %5) #16
  %10 = icmp eq i8* %9, null
  br i1 %10, label %37, label %11

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1
  store %union.StackValue* %14, %union.StackValue** %12, align 8, !tbaa !20
  %15 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !54
  %16 = bitcast %union.StackValue* %14 to i64*
  %17 = bitcast %struct.TValue* %15 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = and i8 %20, 64
  %23 = icmp eq i8 %22, 0
  %24 = inttoptr i64 %18 to %struct.GCObject*
  br i1 %23, label %37, label %25

; <label>:25:                                     ; preds = %11
  %26 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !54
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !70
  %29 = and i8 %28, 32
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %37, label %31

; <label>:31:                                     ; preds = %25
  %32 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %24, i64 0, i32 2
  %33 = load i8, i8* %32, align 1, !tbaa !70
  %34 = and i8 %33, 24
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %37, label %36

; <label>:36:                                     ; preds = %31
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %26, %struct.GCObject* nonnull %24) #16
  br label %37

; <label>:37:                                     ; preds = %31, %25, %11, %3, %36
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i8* %9
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define i8* @lua_upvalueid(%struct.lua_State* nocapture readonly, i32, i32) local_unnamed_addr #3 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = trunc i8 %6 to i6
  switch i6 %7, label %24 [
    i6 22, label %8
    i6 -10, label %17
  ]

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %10 = bitcast %struct.TValue* %9 to %struct.LClosure**
  %11 = load %struct.LClosure*, %struct.LClosure** %10, align 8, !tbaa !21
  %12 = add nsw i32 %2, -1
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %11, i64 0, i32 6, i64 %13
  %15 = bitcast %struct.UpVal** %14 to i8**
  %16 = load i8*, i8** %15, align 8, !tbaa !54
  br label %24

; <label>:17:                                     ; preds = %3
  %18 = bitcast %struct.TValue* %4 to %struct.CClosure**
  %19 = load %struct.CClosure*, %struct.CClosure** %18, align 8, !tbaa !21
  %20 = add nsw i32 %2, -1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %19, i64 0, i32 6, i64 %21
  %23 = bitcast %struct.TValue* %22 to i8*
  br label %24

; <label>:24:                                     ; preds = %3, %17, %8
  %25 = phi i8* [ %23, %17 ], [ %16, %8 ], [ null, %3 ]
  ret i8* %25
}

; Function Attrs: nounwind optsize uwtable
define void @lua_upvaluejoin(%struct.lua_State* nocapture readonly, i32, i32, i32, i32) local_unnamed_addr #0 {
  %6 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %7 = bitcast %struct.TValue* %6 to %struct.LClosure**
  %8 = load %struct.LClosure*, %struct.LClosure** %7, align 8, !tbaa !21
  %9 = add nsw i32 %2, -1
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %8, i64 0, i32 6, i64 %10
  %12 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %3) #17
  %13 = bitcast %struct.TValue* %12 to %struct.LClosure**
  %14 = load %struct.LClosure*, %struct.LClosure** %13, align 8, !tbaa !21
  %15 = add nsw i32 %4, -1
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 6, i64 %16
  %18 = load %struct.UpVal*, %struct.UpVal** %17, align 8, !tbaa !54
  store %struct.UpVal* %18, %struct.UpVal** %11, align 8, !tbaa !54
  %19 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %8, i64 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !201
  %21 = and i8 %20, 32
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %31, label %23

; <label>:23:                                     ; preds = %5
  %24 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %18, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !69
  %26 = and i8 %25, 24
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %31, label %28

; <label>:28:                                     ; preds = %23
  %29 = bitcast %struct.LClosure* %8 to %struct.GCObject*
  %30 = bitcast %struct.UpVal* %18 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %29, %struct.GCObject* %30) #16
  br label %31

; <label>:31:                                     ; preds = %23, %5, %28
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_traceback(%struct.lua_State*, %struct.lua_State*, i8*, i32) local_unnamed_addr #0 {
  %5 = alloca %struct.lua_Debug, align 8
  %6 = bitcast %struct.lua_Debug* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !24
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 0
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  %15 = ptrtoint %union.StackValue* %14 to i64
  %16 = sub i64 %9, %15
  %17 = lshr exact i64 %16, 4
  %18 = trunc i64 %17 to i32
  %19 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 8
  %20 = load %struct.CallInfo*, %struct.CallInfo** %19, align 8, !tbaa !54
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 16
  %22 = icmp ne %struct.CallInfo* %20, %21
  br label %23

; <label>:23:                                     ; preds = %44, %4
  %24 = phi i32 [ 1, %4 ], [ %25, %44 ]
  %25 = phi i32 [ 1, %4 ], [ %45, %44 ]
  %26 = icmp ne i32 %25, 0
  %27 = and i1 %22, %26
  br i1 %27, label %28, label %38

; <label>:28:                                     ; preds = %23
  br label %29

; <label>:29:                                     ; preds = %28, %29
  %30 = phi %struct.CallInfo* [ %34, %29 ], [ %20, %28 ]
  %31 = phi i32 [ %32, %29 ], [ %25, %28 ]
  %32 = add nsw i32 %31, -1
  %33 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %30, i64 0, i32 2
  %34 = load %struct.CallInfo*, %struct.CallInfo** %33, align 8, !tbaa !54
  %35 = icmp sgt i32 %31, 1
  %36 = icmp ne %struct.CallInfo* %34, %21
  %37 = and i1 %35, %36
  br i1 %37, label %29, label %38

; <label>:38:                                     ; preds = %29, %23
  %39 = phi i32 [ %25, %23 ], [ %32, %29 ]
  %40 = phi %struct.CallInfo* [ %20, %23 ], [ %34, %29 ]
  %41 = icmp ne i32 %39, 0
  %42 = icmp eq %struct.CallInfo* %40, %21
  %43 = or i1 %41, %42
  br i1 %43, label %47, label %44

; <label>:44:                                     ; preds = %38
  %45 = shl nsw i32 %25, 1
  %46 = icmp slt i32 %25, 0
  br i1 %46, label %47, label %23

; <label>:47:                                     ; preds = %44, %38
  %48 = phi i32 [ %45, %44 ], [ %25, %38 ]
  %49 = phi i32 [ %25, %44 ], [ %24, %38 ]
  %50 = icmp slt i32 %49, %48
  br i1 %50, label %51, label %86

; <label>:51:                                     ; preds = %47
  br label %52

; <label>:52:                                     ; preds = %51, %79
  %53 = phi i32 [ %84, %79 ], [ %49, %51 ]
  %54 = phi i32 [ %83, %79 ], [ %48, %51 ]
  %55 = add nsw i32 %54, %53
  %56 = sdiv i32 %55, 2
  %57 = icmp slt i32 %55, -1
  br i1 %57, label %79, label %58

; <label>:58:                                     ; preds = %52
  %59 = add i32 %55, 1
  %60 = icmp ugt i32 %59, 2
  %61 = and i1 %22, %60
  br i1 %61, label %62, label %72

; <label>:62:                                     ; preds = %58
  br label %63

; <label>:63:                                     ; preds = %62, %63
  %64 = phi %struct.CallInfo* [ %68, %63 ], [ %20, %62 ]
  %65 = phi i32 [ %66, %63 ], [ %56, %62 ]
  %66 = add nsw i32 %65, -1
  %67 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %64, i64 0, i32 2
  %68 = load %struct.CallInfo*, %struct.CallInfo** %67, align 8, !tbaa !54
  %69 = icmp sgt i32 %65, 1
  %70 = icmp ne %struct.CallInfo* %68, %21
  %71 = and i1 %69, %70
  br i1 %71, label %63, label %72

; <label>:72:                                     ; preds = %63, %58
  %73 = phi i32 [ %56, %58 ], [ %66, %63 ]
  %74 = phi %struct.CallInfo* [ %20, %58 ], [ %68, %63 ]
  %75 = icmp eq i32 %73, 0
  %76 = icmp ne %struct.CallInfo* %74, %21
  %77 = and i1 %75, %76
  %78 = zext i1 %77 to i32
  br label %79

; <label>:79:                                     ; preds = %72, %52
  %80 = phi i32 [ 0, %52 ], [ %78, %72 ]
  %81 = icmp eq i32 %80, 0
  %82 = add nsw i32 %56, 1
  %83 = select i1 %81, i32 %56, i32 %54
  %84 = select i1 %81, i32 %53, i32 %82
  %85 = icmp slt i32 %84, %83
  br i1 %85, label %52, label %86

; <label>:86:                                     ; preds = %79, %47
  %87 = phi i32 [ %48, %47 ], [ %83, %79 ]
  %88 = xor i32 %3, -1
  %89 = add i32 %87, %88
  %90 = icmp sgt i32 %89, 21
  %91 = select i1 %90, i32 10, i32 -1
  %92 = icmp eq i8* %2, null
  br i1 %92, label %95, label %93

; <label>:93:                                     ; preds = %86
  %94 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* nonnull %2) #16
  br label %95

; <label>:95:                                     ; preds = %86, %93
  %96 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 10) #17
  %97 = icmp eq i32 %96, 0
  br i1 %97, label %98, label %100

; <label>:98:                                     ; preds = %95
  %99 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #17
  unreachable

; <label>:100:                                    ; preds = %95
  %101 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.8, i64 0, i64 0)) #16
  %102 = icmp slt i32 %3, 0
  br i1 %102, label %195, label %103

; <label>:103:                                    ; preds = %100
  %104 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 16
  %105 = add nsw i32 %87, -12
  %106 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 15, i64 0
  %107 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 6
  %108 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 2
  %109 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 12
  %110 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 3
  %111 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 1
  %112 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %5, i64 0, i32 7
  br label %113

; <label>:113:                                    ; preds = %103, %191
  %114 = phi i32 [ %91, %103 ], [ %137, %191 ]
  %115 = phi i32 [ %3, %103 ], [ %193, %191 ]
  %116 = load %struct.CallInfo*, %struct.CallInfo** %19, align 8, !tbaa !54
  %117 = icmp ne i32 %115, 0
  %118 = icmp ne %struct.CallInfo* %116, %21
  %119 = and i1 %117, %118
  br i1 %119, label %120, label %130

; <label>:120:                                    ; preds = %113
  br label %121

; <label>:121:                                    ; preds = %120, %121
  %122 = phi %struct.CallInfo* [ %126, %121 ], [ %116, %120 ]
  %123 = phi i32 [ %124, %121 ], [ %115, %120 ]
  %124 = add nsw i32 %123, -1
  %125 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %122, i64 0, i32 2
  %126 = load %struct.CallInfo*, %struct.CallInfo** %125, align 8, !tbaa !54
  %127 = icmp sgt i32 %123, 1
  %128 = icmp ne %struct.CallInfo* %126, %21
  %129 = and i1 %127, %128
  br i1 %129, label %121, label %130

; <label>:130:                                    ; preds = %121, %113
  %131 = phi i32 [ %115, %113 ], [ %124, %121 ]
  %132 = phi %struct.CallInfo* [ %116, %113 ], [ %126, %121 ]
  %133 = icmp ne i32 %131, 0
  %134 = icmp eq %struct.CallInfo* %132, %21
  %135 = or i1 %133, %134
  br i1 %135, label %195, label %136

; <label>:136:                                    ; preds = %130
  store %struct.CallInfo* %132, %struct.CallInfo** %104, align 8, !tbaa !106
  %137 = add nsw i32 %114, -1
  %138 = icmp eq i32 %114, 0
  br i1 %138, label %139, label %141

; <label>:139:                                    ; preds = %136
  %140 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i64 0, i64 0)) #16
  br label %191

; <label>:141:                                    ; preds = %136
  %142 = call i32 @lua_getinfo(%struct.lua_State* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i64 0, i64 0), %struct.lua_Debug* nonnull %5) #16
  %143 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i64 0, i64 0), i8* nonnull %106) #16
  %144 = load i32, i32* %107, align 8, !tbaa !127
  %145 = icmp sgt i32 %144, 0
  br i1 %145, label %146, label %148

; <label>:146:                                    ; preds = %141
  %147 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i64 0, i64 0), i32 %144) #16
  br label %148

; <label>:148:                                    ; preds = %146, %141
  %149 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i64 0, i64 0)) #16
  %150 = call fastcc i32 @pushglobalfuncname(%struct.lua_State* %0, %struct.lua_Debug* nonnull %5) #17
  %151 = icmp eq i32 %150, 0
  br i1 %151, label %158, label %152

; <label>:152:                                    ; preds = %148
  %153 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %154 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.284, i64 0, i64 0), i8* %153) #17
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #17
  %155 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %156 = getelementptr inbounds %union.StackValue, %union.StackValue* %155, i64 -1
  store %union.StackValue* %156, %union.StackValue** %7, align 8, !tbaa !20
  %157 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %156, i32 0) #17
  br label %175

; <label>:158:                                    ; preds = %148
  %159 = load i8*, i8** %108, align 8, !tbaa !133
  %160 = load i8, i8* %159, align 1, !tbaa !21
  %161 = icmp eq i8 %160, 0
  br i1 %161, label %165, label %162

; <label>:162:                                    ; preds = %158
  %163 = load i8*, i8** %111, align 8, !tbaa !202
  %164 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.285, i64 0, i64 0), i8* %159, i8* %163) #17
  br label %175

; <label>:165:                                    ; preds = %158
  %166 = load i8*, i8** %110, align 8, !tbaa !126
  %167 = load i8, i8* %166, align 1, !tbaa !21
  switch i8 %167, label %170 [
    i8 109, label %168
    i8 67, label %173
  ]

; <label>:168:                                    ; preds = %165
  %169 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.286, i64 0, i64 0)) #17
  br label %175

; <label>:170:                                    ; preds = %165
  %171 = load i32, i32* %112, align 4, !tbaa !120
  %172 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.287, i64 0, i64 0), i8* nonnull %106, i32 %171) #17
  br label %175

; <label>:173:                                    ; preds = %165
  %174 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0)) #17
  br label %175

; <label>:175:                                    ; preds = %152, %162, %168, %170, %173
  %176 = load i8, i8* %109, align 1, !tbaa !132
  %177 = icmp eq i8 %176, 0
  br i1 %177, label %180, label %178

; <label>:178:                                    ; preds = %175
  %179 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.14, i64 0, i64 0)) #16
  br label %180

; <label>:180:                                    ; preds = %175, %178
  %181 = load i64, i64* %8, align 8, !tbaa !20
  %182 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !24
  %183 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %182, i64 0, i32 0
  %184 = load %union.StackValue*, %union.StackValue** %183, align 8, !tbaa !64
  %185 = getelementptr inbounds %union.StackValue, %union.StackValue* %184, i64 1
  %186 = ptrtoint %union.StackValue* %185 to i64
  %187 = sub i64 %181, %186
  %188 = lshr exact i64 %187, 4
  %189 = trunc i64 %188 to i32
  %190 = sub nsw i32 %189, %18
  call void @lua_concat(%struct.lua_State* %0, i32 %190) #16
  br label %191

; <label>:191:                                    ; preds = %180, %139
  %192 = phi i32 [ %105, %139 ], [ %115, %180 ]
  %193 = add nsw i32 %192, 1
  %194 = icmp slt i32 %192, -1
  br i1 %194, label %195, label %113

; <label>:195:                                    ; preds = %130, %191, %100
  %196 = load i64, i64* %8, align 8, !tbaa !20
  %197 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !24
  %198 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %197, i64 0, i32 0
  %199 = load %union.StackValue*, %union.StackValue** %198, align 8, !tbaa !64
  %200 = getelementptr inbounds %union.StackValue, %union.StackValue* %199, i64 1
  %201 = ptrtoint %union.StackValue* %200 to i64
  %202 = sub i64 %196, %201
  %203 = lshr exact i64 %202, 4
  %204 = trunc i64 %203 to i32
  %205 = sub nsw i32 %204, %18
  call void @lua_concat(%struct.lua_State* %0, i32 %205) #16
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_checkstack(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i8* %2, null
  br i1 %7, label %10, label %8

; <label>:8:                                      ; preds = %6
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i64 0, i64 0), i8* nonnull %2) #16
  unreachable

; <label>:10:                                     ; preds = %6
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_argerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.lua_Debug, align 8
  %5 = bitcast %struct.lua_Debug* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !54
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %9 = icmp eq %struct.CallInfo* %7, %8
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %3
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.15, i64 0, i64 0), i32 %1, i8* %2) #16
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 16
  store %struct.CallInfo* %7, %struct.CallInfo** %13, align 8, !tbaa !106
  %14 = call i32 @lua_getinfo(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0), %struct.lua_Debug* nonnull %4) #16
  %15 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 2
  %16 = load i8*, i8** %15, align 8, !tbaa !133
  %17 = call i32 @strcmp(i8* %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0)) #21
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %26

; <label>:19:                                     ; preds = %12
  %20 = add nsw i32 %1, -1
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %26

; <label>:22:                                     ; preds = %19
  %23 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %24 = load i8*, i8** %23, align 8, !tbaa !202
  %25 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.18, i64 0, i64 0), i8* %24, i8* %2) #16
  unreachable

; <label>:26:                                     ; preds = %19, %12
  %27 = phi i32 [ %20, %19 ], [ %1, %12 ]
  %28 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %4, i64 0, i32 1
  %29 = load i8*, i8** %28, align 8, !tbaa !202
  %30 = icmp eq i8* %29, null
  br i1 %30, label %31, label %38

; <label>:31:                                     ; preds = %26
  %32 = call fastcc i32 @pushglobalfuncname(%struct.lua_State* nonnull %0, %struct.lua_Debug* nonnull %4) #16
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %31
  %35 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  br label %36

; <label>:36:                                     ; preds = %31, %34
  %37 = phi i8* [ %35, %34 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %31 ]
  store i8* %37, i8** %28, align 8, !tbaa !202
  br label %38

; <label>:38:                                     ; preds = %36, %26
  %39 = phi i8* [ %37, %36 ], [ %29, %26 ]
  %40 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.19, i64 0, i64 0), i32 %27, i8* %39, i8* %2) #16
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define i32 @luaL_error(%struct.lua_State*, i8*, ...) local_unnamed_addr #5 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  call void @luaL_where(%struct.lua_State* %0, i32 1) #16
  %6 = call i8* @lua_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  call void @lua_concat(%struct.lua_State* %0, i32 2) #16
  %7 = call i32 @lua_error(%struct.lua_State* %0) #16
  unreachable
}

; Function Attrs: nounwind optsize readonly
declare i32 @strcmp(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @pushglobalfuncname(%struct.lua_State*, %struct.lua_Debug*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = tail call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.288, i64 0, i64 0), %struct.lua_Debug* %1) #16
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %17 = load %struct.global_State*, %struct.global_State** %16, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 7
  %19 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %18, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #17
  %20 = add nsw i32 %14, 1
  %21 = tail call fastcc i32 @findfield(%struct.lua_State* %0, i32 %20, i32 2) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %37, label %23

; <label>:23:                                     ; preds = %2
  %24 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  %25 = tail call i32 @strncmp(i8* %24, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.289, i64 0, i64 0), i64 3) #21
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %27, label %33

; <label>:27:                                     ; preds = %23
  %28 = getelementptr inbounds i8, i8* %24, i64 3
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* nonnull %28) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 -1) #16
  %30 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1
  store %union.StackValue* %31, %union.StackValue** %3, align 8, !tbaa !20
  %32 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %31, i32 0) #17
  br label %33

; <label>:33:                                     ; preds = %27, %23
  tail call void @lua_copy(%struct.lua_State* nonnull %0, i32 -1, i32 %20) #16
  %34 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 -2
  store %union.StackValue* %35, %union.StackValue** %3, align 8, !tbaa !20
  %36 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %35, i32 0) #17
  br label %38

; <label>:37:                                     ; preds = %2
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 %14) #16
  br label %38

; <label>:38:                                     ; preds = %37, %33
  %39 = phi i32 [ 1, %33 ], [ 0, %37 ]
  ret i32 %39
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_typeerror(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %5 = icmp eq i32 %4, 4
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  br label %33

; <label>:8:                                      ; preds = %3
  %9 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = and i8 %11, 15
  %13 = trunc i8 %11 to i4
  switch i4 %13, label %26 [
    i4 0, label %14
    i4 2, label %33
  ]

; <label>:14:                                     ; preds = %8
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  %18 = icmp eq %struct.TValue* %9, %17
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 8
  br label %23

; <label>:23:                                     ; preds = %19, %14
  %24 = phi %struct.TValue* [ %22, %19 ], [ %17, %14 ]
  %25 = icmp eq %struct.TValue* %9, %24
  br i1 %25, label %29, label %26

; <label>:26:                                     ; preds = %8, %23
  %27 = add nuw nsw i8 %12, 1
  %28 = zext i8 %27 to i64
  br label %29

; <label>:29:                                     ; preds = %23, %26
  %30 = phi i64 [ %28, %26 ], [ 0, %23 ]
  %31 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %30
  %32 = load i8*, i8** %31, align 8, !tbaa !54
  br label %33

; <label>:33:                                     ; preds = %8, %29, %6
  %34 = phi i8* [ %7, %6 ], [ %32, %29 ], [ getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i64 0, i64 0), %8 ]
  %35 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.22, i64 0, i64 0), i8* %2, i8* %34) #16
  %36 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %35) #16
  ret i32 %36
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_getmetafield(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %20, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2) #16
  %8 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 -2
  store %union.StackValue* %13, %union.StackValue** %11, align 8, !tbaa !20
  %14 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %13, i32 0) #17
  br label %20

; <label>:15:                                     ; preds = %6
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1
  store %union.StackValue* %18, %union.StackValue** %16, align 8, !tbaa !20
  %19 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %18, i32 0) #17
  br label %20

; <label>:20:                                     ; preds = %10, %15, %3
  %21 = phi i32 [ 0, %3 ], [ %8, %15 ], [ 0, %10 ]
  ret i32 %21
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_where(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca %struct.lua_Debug, align 8
  %4 = bitcast %struct.lua_Debug* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %4) #7
  %5 = icmp slt i32 %1, 0
  br i1 %5, label %38, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !54
  %9 = icmp ne i32 %1, 0
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %11 = icmp ne %struct.CallInfo* %8, %10
  %12 = and i1 %9, %11
  br i1 %12, label %13, label %23

; <label>:13:                                     ; preds = %6
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi %struct.CallInfo* [ %19, %14 ], [ %8, %13 ]
  %16 = phi i32 [ %17, %14 ], [ %1, %13 ]
  %17 = add nsw i32 %16, -1
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %15, i64 0, i32 2
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !54
  %20 = icmp sgt i32 %16, 1
  %21 = icmp ne %struct.CallInfo* %19, %10
  %22 = and i1 %20, %21
  br i1 %22, label %14, label %23

; <label>:23:                                     ; preds = %14, %6
  %24 = phi i32 [ %1, %6 ], [ %17, %14 ]
  %25 = phi %struct.CallInfo* [ %8, %6 ], [ %19, %14 ]
  %26 = icmp ne i32 %24, 0
  %27 = icmp eq %struct.CallInfo* %25, %10
  %28 = or i1 %26, %27
  br i1 %28, label %38, label %29

; <label>:29:                                     ; preds = %23
  %30 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 16
  store %struct.CallInfo* %25, %struct.CallInfo** %30, align 8, !tbaa !106
  %31 = call i32 @lua_getinfo(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.23, i64 0, i64 0), %struct.lua_Debug* nonnull %3) #16
  %32 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 6
  %33 = load i32, i32* %32, align 8, !tbaa !127
  %34 = icmp sgt i32 %33, 0
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %29
  %36 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %3, i64 0, i32 15, i64 0
  %37 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.24, i64 0, i64 0), i8* nonnull %36, i32 %33) #16
  br label %40

; <label>:38:                                     ; preds = %23, %2, %29
  %39 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %40

; <label>:40:                                     ; preds = %38, %35
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_fileresult(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #22
  %5 = load i32, i32* %4, align 4, !tbaa !77
  %6 = icmp eq i32 %1, 0
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  br i1 %6, label %12, label %10

; <label>:10:                                     ; preds = %3
  %11 = bitcast %struct.TValue* %9 to i32*
  store i32 1, i32* %11, align 8, !tbaa !21
  br label %26

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %7, align 8, !tbaa !20
  %16 = icmp eq i8* %2, null
  %17 = tail call i8* @strerror(i32 %5) #17
  br i1 %16, label %20, label %18

; <label>:18:                                     ; preds = %12
  %19 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25, i64 0, i64 0), i8* nonnull %2, i8* %17) #16
  br label %22

; <label>:20:                                     ; preds = %12
  %21 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %17) #16
  br label %22

; <label>:22:                                     ; preds = %20, %18
  %23 = sext i32 %5 to i64
  %24 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i64*
  store i64 %23, i64* %25, align 8, !tbaa !21
  br label %26

; <label>:26:                                     ; preds = %22, %10
  %27 = phi %struct.TValue* [ %24, %22 ], [ %9, %10 ]
  %28 = phi i8 [ 35, %22 ], [ 1, %10 ]
  %29 = phi i32 [ 3, %22 ], [ 1, %10 ]
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  store i8 %28, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 %29
}

; Function Attrs: nounwind optsize readnone
declare i32* @__errno_location() local_unnamed_addr #8

; Function Attrs: nounwind optsize
declare i8* @strerror(i32) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_execresult(%struct.lua_State*, i32) local_unnamed_addr #0 {
  switch i32 %1, label %10 [
    i32 -1, label %3
    i32 0, label %5
  ]

; <label>:3:                                      ; preds = %2
  %4 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %29

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32*
  store i32 1, i32* %9, align 8, !tbaa !21
  br label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = bitcast %union.StackValue** %11 to %struct.TValue**
  %13 = load %struct.TValue*, %struct.TValue** %12, align 8, !tbaa !20
  br label %14

; <label>:14:                                     ; preds = %10, %5
  %15 = phi %struct.TValue* [ %13, %10 ], [ %8, %5 ]
  %16 = phi i8 [ 0, %10 ], [ 1, %5 ]
  %17 = phi %union.StackValue** [ %11, %10 ], [ %6, %5 ]
  %18 = phi %struct.TValue** [ %12, %10 ], [ %7, %5 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 %16, i8* %19, align 8, !tbaa !21
  %20 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %17, align 8, !tbaa !20
  %22 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i64 0, i64 0)) #16
  %23 = sext i32 %1 to i64
  %24 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i64*
  store i64 %23, i64* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 35, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %17, align 8, !tbaa !20
  br label %29

; <label>:29:                                     ; preds = %14, %3
  %30 = phi i32 [ %4, %3 ], [ 3, %14 ]
  ret i32 %30
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_newmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7
  %6 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %5, i8* %1) #17
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %29

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1
  store %union.StackValue* %11, %union.StackValue** %9, align 8, !tbaa !20
  %12 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %11, i32 0) #17
  tail call void @lua_createtable(%struct.lua_State* nonnull %0, i32 0, i32 2) #16
  %13 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %1) #16
  %14 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %15, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #17
  %16 = bitcast %union.StackValue** %9 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !20
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 -1
  %19 = bitcast %struct.TValue* %18 to i64*
  %20 = bitcast %struct.TValue* %17 to i64*
  %21 = load i64, i64* %19, align 8
  store i64 %21, i64* %20, align 8
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 -1, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 %23, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %9, align 8, !tbaa !20
  %27 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 7
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %28, i8* %1) #17
  br label %29

; <label>:29:                                     ; preds = %2, %8
  %30 = phi i32 [ 1, %8 ], [ 0, %2 ]
  ret i32 %30
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_setmetatable(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7
  %6 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %5, i8* %1) #17
  %7 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_testudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %21, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %21, label %9

; <label>:9:                                      ; preds = %6
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 7
  %13 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %12, i8* %2) #17
  %14 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %15 = icmp eq i32 %14, 0
  %16 = select i1 %15, i8* null, i8* %4
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 -2
  store %union.StackValue* %19, %union.StackValue** %17, align 8, !tbaa !20
  %20 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %19, i32 0) #17
  br label %21

; <label>:21:                                     ; preds = %3, %6, %9
  %22 = phi i8* [ %16, %9 ], [ null, %6 ], [ null, %3 ]
  ret i8* %22
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_checkudata(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 %1, i8* %2) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %2) #16
  br label %8

; <label>:8:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_checkoption(%struct.lua_State*, i32, i8*, i8** nocapture readonly) local_unnamed_addr #0 {
  %5 = icmp eq i8* %2, null
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 %1, i8* nonnull %2, i64* null) #16
  br label %10

; <label>:8:                                      ; preds = %4
  %9 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* null) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  %12 = load i8*, i8** %3, align 8, !tbaa !54
  %13 = icmp eq i8* %12, null
  br i1 %13, label %25, label %14

; <label>:14:                                     ; preds = %10
  br label %15

; <label>:15:                                     ; preds = %14, %20
  %16 = phi i64 [ %21, %20 ], [ 0, %14 ]
  %17 = phi i8* [ %23, %20 ], [ %12, %14 ]
  %18 = tail call i32 @strcmp(i8* nonnull %17, i8* %11) #21
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %15
  %21 = add nuw i64 %16, 1
  %22 = getelementptr inbounds i8*, i8** %3, i64 %21
  %23 = load i8*, i8** %22, align 8, !tbaa !54
  %24 = icmp eq i8* %23, null
  br i1 %24, label %25, label %15

; <label>:25:                                     ; preds = %20, %10
  %26 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.27, i64 0, i64 0), i8* %11) #16
  %27 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* nonnull %26) #16
  br label %30

; <label>:28:                                     ; preds = %15
  %29 = trunc i64 %16 to i32
  br label %30

; <label>:30:                                     ; preds = %28, %25
  %31 = phi i32 [ %27, %25 ], [ %29, %28 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_optlstring(%struct.lua_State*, i32, i8* readonly, i64*) local_unnamed_addr #0 {
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  br i1 %9, label %10, label %18

; <label>:10:                                     ; preds = %4
  %11 = icmp eq i64* %3, null
  br i1 %11, label %20, label %12

; <label>:12:                                     ; preds = %10
  %13 = icmp eq i8* %2, null
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %12
  %15 = tail call i64 @strlen(i8* nonnull %2) #21
  br label %16

; <label>:16:                                     ; preds = %12, %14
  %17 = phi i64 [ %15, %14 ], [ 0, %12 ]
  store i64 %17, i64* %3, align 8, !tbaa !82
  br label %20

; <label>:18:                                     ; preds = %4
  %19 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %1, i64* %3) #16
  br label %20

; <label>:20:                                     ; preds = %16, %10, %18
  %21 = phi i8* [ %19, %18 ], [ %2, %10 ], [ %2, %16 ]
  ret i8* %21
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_checklstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* %2) #16
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %3
  %7 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i64 0, i64 0)) #17
  br label %8

; <label>:8:                                      ; preds = %3, %6
  ret i8* %4
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_checktype(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %9, label %14

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 8
  %13 = icmp eq %struct.TValue* %4, %12
  br i1 %13, label %16, label %14

; <label>:14:                                     ; preds = %9, %3
  %15 = zext i8 %7 to i32
  br label %16

; <label>:16:                                     ; preds = %9, %14
  %17 = phi i32 [ %15, %14 ], [ -1, %9 ]
  %18 = icmp eq i32 %17, %2
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %16
  %20 = add nsw i32 %2, 1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %21
  %23 = load i8*, i8** %22, align 8, !tbaa !54
  %24 = tail call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* %23) #17
  br label %25

; <label>:25:                                     ; preds = %16, %19
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_checkany(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 8
  %12 = icmp eq %struct.TValue* %3, %11
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %8
  %14 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 %1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %15

; <label>:15:                                     ; preds = %2, %8, %13
  ret void
}

; Function Attrs: argmemonly nounwind optsize readonly
declare i64 @strlen(i8* nocapture) local_unnamed_addr #10

; Function Attrs: nounwind optsize uwtable
define double @luaL_checknumber(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* nonnull %3) #16
  %6 = load i32, i32* %3, align 4, !tbaa !77
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %2
  %9 = call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.183, i64 0, i64 0)) #17
  br label %10

; <label>:10:                                     ; preds = %2, %8
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret double %5
}

; Function Attrs: nounwind optsize uwtable
define double @luaL_optnumber(%struct.lua_State*, i32, double) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %11, label %9

; <label>:9:                                      ; preds = %3
  %10 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 %1) #16
  br label %11

; <label>:11:                                     ; preds = %3, %9
  %12 = phi double [ %10, %9 ], [ %2, %3 ]
  ret double %12
}

; Function Attrs: nounwind optsize uwtable
define i64 @luaL_checkinteger(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* nonnull %3) #16
  %6 = load i32, i32* %3, align 4, !tbaa !77
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %2
  %9 = call i32 @lua_isnumber(%struct.lua_State* %0, i32 %1) #17
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %13, label %11

; <label>:11:                                     ; preds = %8
  %12 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.291, i64 0, i64 0)) #17
  br label %15

; <label>:13:                                     ; preds = %8
  %14 = call i32 @luaL_typeerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.183, i64 0, i64 0)) #17
  br label %15

; <label>:15:                                     ; preds = %13, %11, %2
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %5
}

; Function Attrs: nounwind optsize uwtable
define i64 @luaL_optinteger(%struct.lua_State*, i32, i64) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %11, label %9

; <label>:9:                                      ; preds = %3
  %10 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1) #16
  br label %11

; <label>:11:                                     ; preds = %3, %9
  %12 = phi i64 [ %10, %9 ], [ %2, %3 ]
  ret i64 %12
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_prepbuffsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %1, i32 -1) #16
  ret i8* %3
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @prepbuffsize(%struct.luaL_Buffer*, i64, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 1
  %5 = load i64, i64* %4, align 8, !tbaa !203
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !205
  %8 = sub i64 %5, %7
  %9 = icmp ult i64 %8, %1
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %12 = load i8*, i8** %11, align 8, !tbaa !206
  %13 = getelementptr inbounds i8, i8* %12, i64 %7
  br label %54

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %16 = load %struct.lua_State*, %struct.lua_State** %15, align 8, !tbaa !207
  %17 = shl i64 %5, 1
  %18 = xor i64 %1, -1
  %19 = icmp ugt i64 %7, %18
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %14
  %21 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %16, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.292, i64 0, i64 0)) #17
  unreachable

; <label>:22:                                     ; preds = %14
  %23 = add i64 %7, %1
  %24 = icmp ult i64 %17, %23
  %25 = select i1 %24, i64 %23, i64 %17
  %26 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %27 = load i8*, i8** %26, align 8, !tbaa !206
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %29 = bitcast %union.anon.6* %28 to i8*
  %30 = icmp eq i8* %27, %29
  br i1 %30, label %33, label %31

; <label>:31:                                     ; preds = %22
  %32 = tail call fastcc i8* @resizebox(%struct.lua_State* %16, i32 %2, i64 %25) #16
  br label %50

; <label>:33:                                     ; preds = %22
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %16, i64 0, i32 6
  %35 = bitcast %union.StackValue** %34 to %struct.TValue**
  %36 = load %struct.TValue*, %struct.TValue** %35, align 8, !tbaa !20
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  store i8 0, i8* %37, align 8, !tbaa !21
  %38 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 1
  store %union.StackValue* %39, %union.StackValue** %34, align 8, !tbaa !20
  %40 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %16, i64 16, i32 0) #17
  tail call void @llvm.memset.p0i8.i64(i8* nonnull %40, i8 0, i64 16, i32 8, i1 false) #7
  %41 = tail call i32 @luaL_newmetatable(%struct.lua_State* %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.294, i64 0, i64 0)) #17
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %44, label %43

; <label>:43:                                     ; preds = %33
  tail call void @luaL_setfuncs(%struct.lua_State* nonnull %16, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @boxmt, i64 0, i64 0), i32 0) #17
  br label %44

; <label>:44:                                     ; preds = %33, %43
  %45 = tail call i32 @lua_setmetatable(%struct.lua_State* nonnull %16, i32 -2) #17
  %46 = add nsw i32 %2, -1
  tail call void @lua_rotate(%struct.lua_State* nonnull %16, i32 %46, i32 2) #16
  tail call void @lua_toclose(%struct.lua_State* nonnull %16, i32 %2) #16
  %47 = tail call fastcc i8* @resizebox(%struct.lua_State* nonnull %16, i32 %2, i64 %25) #16
  %48 = load i8*, i8** %26, align 8, !tbaa !206
  %49 = load i64, i64* %6, align 8, !tbaa !205
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 %49, i32 1, i1 false)
  br label %50

; <label>:50:                                     ; preds = %44, %31
  %51 = phi i8* [ %32, %31 ], [ %47, %44 ]
  store i8* %51, i8** %26, align 8, !tbaa !206
  store i64 %25, i64* %4, align 8, !tbaa !203
  %52 = load i64, i64* %6, align 8, !tbaa !205
  %53 = getelementptr inbounds i8, i8* %51, i64 %52
  br label %54

; <label>:54:                                     ; preds = %50, %10
  %55 = phi i8* [ %13, %10 ], [ %53, %50 ]
  ret i8* %55
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_addlstring(%struct.luaL_Buffer*, i8* nocapture readonly, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %2, i32 -1) #16
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %1, i64 %2, i32 1, i1 false)
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %8 = load i64, i64* %7, align 8, !tbaa !205
  %9 = add i64 %8, %2
  store i64 %9, i64* %7, align 8, !tbaa !205
  br label %10

; <label>:10:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_addstring(%struct.luaL_Buffer*, i8* nocapture readonly) local_unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %1) #21
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %3, i32 -1) #17
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %1, i64 %3, i32 1, i1 false) #7
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %8 = load i64, i64* %7, align 8, !tbaa !205
  %9 = add i64 %8, %3
  store i64 %9, i64* %7, align 8, !tbaa !205
  br label %10

; <label>:10:                                     ; preds = %2, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_pushresult(%struct.luaL_Buffer* readonly) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !207
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 0
  %5 = load i8*, i8** %4, align 8, !tbaa !206
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8, !tbaa !205
  %8 = tail call i8* @lua_pushlstring(%struct.lua_State* %3, i8* %5, i64 %7) #16
  %9 = load i8*, i8** %4, align 8, !tbaa !206
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 4
  %11 = bitcast %union.anon.6* %10 to i8*
  %12 = icmp eq i8* %9, %11
  br i1 %12, label %27, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %3, i64 0, i32 6
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1, i32 0
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -3, i32 0
  %18 = bitcast %struct.TValue* %16 to i64*
  %19 = bitcast %struct.TValue* %17 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1, i32 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -3, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -2
  store %union.StackValue* %25, %union.StackValue** %14, align 8, !tbaa !20
  %26 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %3, %union.StackValue* nonnull %25, i32 0) #17
  br label %27

; <label>:27:                                     ; preds = %1, %13
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_pushresultsize(%struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %4 = load i64, i64* %3, align 8, !tbaa !205
  %5 = add i64 %4, %1
  store i64 %5, i64* %3, align 8, !tbaa !205
  tail call void @luaL_pushresult(%struct.luaL_Buffer* %0) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_addvalue(%struct.luaL_Buffer*) local_unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 3
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !207
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @lua_tolstring(%struct.lua_State* %4, i32 -1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !82
  %8 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %7, i32 -2) #16
  %9 = load i64, i64* %2, align 8, !tbaa !82
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %6, i64 %9, i32 1, i1 false)
  %10 = load i64, i64* %2, align 8, !tbaa !82
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %12 = load i64, i64* %11, align 8, !tbaa !205
  %13 = add i64 %12, %10
  store i64 %13, i64* %11, align 8, !tbaa !205
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %4, i64 0, i32 6
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 -1
  store %union.StackValue* %16, %union.StackValue** %14, align 8, !tbaa !20
  %17 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %4, %union.StackValue* nonnull %16, i32 0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define void @luaL_buffinit(%struct.lua_State*, %struct.luaL_Buffer*) local_unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %3, align 8, !tbaa !207
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 4
  %5 = bitcast %struct.luaL_Buffer* %1 to %union.anon.6**
  store %union.anon.6* %4, %union.anon.6** %5, align 8, !tbaa !206
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  %7 = bitcast i64* %6 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %7, align 8, !tbaa !82
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_buffinitsize(%struct.lua_State*, %struct.luaL_Buffer*, i64) local_unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %4, align 8, !tbaa !207
  %5 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 4
  %6 = bitcast %struct.luaL_Buffer* %1 to %union.anon.6**
  store %union.anon.6* %5, %union.anon.6** %6, align 8, !tbaa !206
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %1, i64 0, i32 1
  %8 = bitcast i64* %7 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %8, align 8, !tbaa !82
  %9 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %1, i64 %2, i32 -1) #16
  ret i8* %9
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_ref(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !22
  %8 = and i8 %7, 15
  %9 = icmp eq i8 %8, 0
  %10 = ptrtoint %union.StackValue* %5 to i64
  br i1 %9, label %11, label %20

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1, i32 0
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  %16 = icmp eq %struct.TValue* %12, %15
  br i1 %16, label %20, label %17

; <label>:17:                                     ; preds = %11
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 -1
  store %union.StackValue* %18, %union.StackValue** %4, align 8, !tbaa !20
  %19 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %18, i32 0) #17
  br label %51

; <label>:20:                                     ; preds = %2, %11
  %21 = add i32 %1, 1000999
  %22 = icmp ugt i32 %21, 1000999
  br i1 %22, label %31, label %23

; <label>:23:                                     ; preds = %20
  %24 = bitcast %struct.CallInfo** %3 to i64**
  %25 = load i64*, i64** %24, align 8, !tbaa !24
  %26 = load i64, i64* %25, align 8, !tbaa !64
  %27 = sub i64 %10, %26
  %28 = lshr exact i64 %27, 4
  %29 = trunc i64 %28 to i32
  %30 = add nsw i32 %29, %1
  br label %31

; <label>:31:                                     ; preds = %20, %23
  %32 = phi i32 [ %30, %23 ], [ %1, %20 ]
  %33 = tail call i32 @lua_rawgeti(%struct.lua_State* nonnull %0, i32 %32, i64 0) #16
  %34 = tail call i64 @lua_tointegerx(%struct.lua_State* nonnull %0, i32 -1, i32* null) #16
  %35 = trunc i64 %34 to i32
  %36 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 -1
  store %union.StackValue* %37, %union.StackValue** %4, align 8, !tbaa !20
  %38 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %37, i32 0) #17
  %39 = icmp eq i32 %35, 0
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %31
  %41 = shl i64 %34, 32
  %42 = ashr exact i64 %41, 32
  %43 = tail call i32 @lua_rawgeti(%struct.lua_State* nonnull %0, i32 %32, i64 %42) #16
  tail call void @lua_rawseti(%struct.lua_State* nonnull %0, i32 %32, i64 0) #16
  br label %48

; <label>:44:                                     ; preds = %31
  %45 = tail call i64 @lua_rawlen(%struct.lua_State* nonnull %0, i32 %32) #16
  %46 = trunc i64 %45 to i32
  %47 = add nsw i32 %46, 1
  br label %48

; <label>:48:                                     ; preds = %44, %40
  %49 = phi i32 [ %35, %40 ], [ %47, %44 ]
  %50 = sext i32 %49 to i64
  tail call void @lua_rawseti(%struct.lua_State* nonnull %0, i32 %32, i64 %50) #16
  br label %51

; <label>:51:                                     ; preds = %48, %17
  %52 = phi i32 [ -1, %17 ], [ %49, %48 ]
  ret i32 %52
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_unref(%struct.lua_State*, i32, i32) local_unnamed_addr #0 {
  %4 = icmp sgt i32 %2, -1
  br i1 %4, label %5, label %30

; <label>:5:                                      ; preds = %3
  %6 = add i32 %1, 1000999
  %7 = icmp ugt i32 %6, 1000999
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %7, label %20, label %9

; <label>:9:                                      ; preds = %5
  %10 = bitcast %union.StackValue** %8 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %13 = bitcast %struct.CallInfo** %12 to i64**
  %14 = load i64*, i64** %13, align 8, !tbaa !24
  %15 = load i64, i64* %14, align 8, !tbaa !64
  %16 = sub i64 %11, %15
  %17 = lshr exact i64 %16, 4
  %18 = trunc i64 %17 to i32
  %19 = add nsw i32 %18, %1
  br label %20

; <label>:20:                                     ; preds = %5, %9
  %21 = phi i32 [ %19, %9 ], [ %1, %5 ]
  %22 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %21, i64 0) #16
  %23 = sext i32 %2 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %21, i64 %23) #16
  %24 = bitcast %union.StackValue** %8 to %struct.TValue**
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !20
  %26 = bitcast %struct.TValue* %25 to i64*
  store i64 %23, i64* %26, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  store i8 35, i8* %27, align 8, !tbaa !22
  %28 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  store %union.StackValue* %29, %union.StackValue** %8, align 8, !tbaa !20
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 %21, i64 0) #16
  br label %30

; <label>:30:                                     ; preds = %20, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_loadfilex(%struct.lua_State*, i8*, i8*) local_unnamed_addr #0 {
  %4 = alloca %struct.LoadF, align 8
  %5 = alloca i32, align 4
  %6 = bitcast %struct.LoadF* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8208, i8* nonnull %6) #7
  %7 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, 1
  %21 = icmp eq i8* %1, null
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %3
  %23 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0)) #16
  %24 = load i64, i64* bitcast (%struct._IO_FILE** @stdin to i64*), align 8, !tbaa !54
  %25 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %26 = bitcast %struct._IO_FILE** %25 to i64*
  store i64 %24, i64* %26, align 8, !tbaa !208
  br label %33

; <label>:27:                                     ; preds = %3
  %28 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.32, i64 0, i64 0), i8* nonnull %1) #16
  %29 = tail call %struct._IO_FILE* @fopen64(i8* nonnull %1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  %30 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  store %struct._IO_FILE* %29, %struct._IO_FILE** %30, align 8, !tbaa !208
  %31 = icmp eq %struct._IO_FILE* %29, null
  br i1 %31, label %32, label %33

; <label>:32:                                     ; preds = %27
  tail call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i64 0, i64 0), i32 %20) #16
  br label %81

; <label>:33:                                     ; preds = %27, %22
  %34 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5) #16
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %42, label %36

; <label>:36:                                     ; preds = %33
  %37 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %38 = load i32, i32* %37, align 8, !tbaa !210
  %39 = add nsw i32 %38, 1
  store i32 %39, i32* %37, align 8, !tbaa !210
  %40 = sext i32 %38 to i64
  %41 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %40
  store i8 10, i8* %41, align 1, !tbaa !21
  br label %42

; <label>:42:                                     ; preds = %33, %36
  %43 = load i32, i32* %5, align 4, !tbaa !77
  %44 = icmp eq i32 %43, 27
  %45 = icmp ne i8* %1, null
  %46 = and i1 %45, %44
  br i1 %46, label %47, label %56

; <label>:47:                                     ; preds = %42
  %48 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %49 = load %struct._IO_FILE*, %struct._IO_FILE** %48, align 8, !tbaa !208
  %50 = tail call %struct._IO_FILE* @freopen64(i8* nonnull %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.36, i64 0, i64 0), %struct._IO_FILE* %49) #17
  store %struct._IO_FILE* %50, %struct._IO_FILE** %48, align 8, !tbaa !208
  %51 = icmp eq %struct._IO_FILE* %50, null
  br i1 %51, label %52, label %53

; <label>:52:                                     ; preds = %47
  tail call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.37, i64 0, i64 0), i32 %20) #16
  br label %81

; <label>:53:                                     ; preds = %47
  %54 = call fastcc i32 @skipcomment(%struct.LoadF* nonnull %4, i32* nonnull %5) #16
  %55 = load i32, i32* %5, align 4, !tbaa !77
  br label %56

; <label>:56:                                     ; preds = %53, %42
  %57 = phi i32 [ %55, %53 ], [ %43, %42 ]
  %58 = icmp eq i32 %57, -1
  br i1 %58, label %66, label %59

; <label>:59:                                     ; preds = %56
  %60 = trunc i32 %57 to i8
  %61 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 0
  %62 = load i32, i32* %61, align 8, !tbaa !210
  %63 = add nsw i32 %62, 1
  store i32 %63, i32* %61, align 8, !tbaa !210
  %64 = sext i32 %62 to i64
  %65 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 2, i64 %64
  store i8 %60, i8* %65, align 1, !tbaa !21
  br label %66

; <label>:66:                                     ; preds = %56, %59
  %67 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  %68 = call i32 @lua_load(%struct.lua_State* nonnull %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getF, i8* nonnull %6, i8* %67, i8* %2) #16
  %69 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %4, i64 0, i32 1
  %70 = load %struct._IO_FILE*, %struct._IO_FILE** %69, align 8, !tbaa !208
  %71 = call i32 @ferror(%struct._IO_FILE* %70) #17
  br i1 %45, label %72, label %74

; <label>:72:                                     ; preds = %66
  %73 = call i32 @fclose(%struct._IO_FILE* %70) #16
  br label %74

; <label>:74:                                     ; preds = %72, %66
  %75 = icmp eq i32 %71, 0
  br i1 %75, label %77, label %76

; <label>:76:                                     ; preds = %74
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 %20) #16
  call fastcc void @errfile(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i64 0, i64 0), i32 %20) #16
  br label %81

; <label>:77:                                     ; preds = %74
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 %20, i32 -1) #16
  %78 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 -1
  store %union.StackValue* %79, %union.StackValue** %8, align 8, !tbaa !20
  %80 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %79, i32 0) #17
  br label %81

; <label>:81:                                     ; preds = %77, %76, %52, %32
  %82 = phi i32 [ 6, %52 ], [ 6, %76 ], [ %68, %77 ], [ 6, %32 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8208, i8* nonnull %6) #7
  ret i32 %82
}

; Function Attrs: nounwind optsize
declare noalias %struct._IO_FILE* @fopen64(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @errfile(%struct.lua_State*, i8*, i32) unnamed_addr #0 {
  %4 = tail call i32* @__errno_location() #22
  %5 = load i32, i32* %4, align 4, !tbaa !77
  %6 = tail call i8* @strerror(i32 %5) #17
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %2, i64* null) #16
  %8 = getelementptr inbounds i8, i8* %7, i64 1
  %9 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.295, i64 0, i64 0), i8* %1, i8* nonnull %8, i8* %6) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %2, i32 -1) #16
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1
  store %union.StackValue* %12, %union.StackValue** %10, align 8, !tbaa !20
  %13 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %12, i32 0) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @skipcomment(%struct.LoadF* nocapture, i32* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 0
  store i32 0, i32* %3, align 8, !tbaa !210
  %4 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 1
  br label %5

; <label>:5:                                      ; preds = %15, %2
  %6 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.296, i64 0, i64 0), %2 ], [ %11, %15 ]
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !208
  %8 = tail call i32 @_IO_getc(%struct._IO_FILE* %7) #17
  %9 = icmp eq i32 %8, -1
  br i1 %9, label %36, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds i8, i8* %6, i64 1
  %12 = load i8, i8* %6, align 1, !tbaa !21
  %13 = zext i8 %12 to i32
  %14 = icmp eq i32 %8, %13
  br i1 %14, label %15, label %26

; <label>:15:                                     ; preds = %10
  %16 = trunc i32 %8 to i8
  %17 = load i32, i32* %3, align 8, !tbaa !210
  %18 = add nsw i32 %17, 1
  store i32 %18, i32* %3, align 8, !tbaa !210
  %19 = sext i32 %17 to i64
  %20 = getelementptr inbounds %struct.LoadF, %struct.LoadF* %0, i64 0, i32 2, i64 %19
  store i8 %16, i8* %20, align 1, !tbaa !21
  %21 = load i8, i8* %11, align 1, !tbaa !21
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %5

; <label>:23:                                     ; preds = %15
  store i32 0, i32* %3, align 8, !tbaa !210
  %24 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !208
  %25 = tail call i32 @_IO_getc(%struct._IO_FILE* %24) #17
  br label %26

; <label>:26:                                     ; preds = %10, %23
  %27 = phi i32 [ %25, %23 ], [ %8, %10 ]
  store i32 %27, i32* %1, align 4, !tbaa !77
  %28 = icmp eq i32 %27, 35
  br i1 %28, label %29, label %39

; <label>:29:                                     ; preds = %26
  br label %30

; <label>:30:                                     ; preds = %29, %30
  %31 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !208
  %32 = tail call i32 @_IO_getc(%struct._IO_FILE* %31) #16
  switch i32 %32, label %30 [
    i32 -1, label %33
    i32 10, label %33
  ]

; <label>:33:                                     ; preds = %30, %30
  %34 = load %struct._IO_FILE*, %struct._IO_FILE** %4, align 8, !tbaa !208
  %35 = tail call i32 @_IO_getc(%struct._IO_FILE* %34) #16
  br label %36

; <label>:36:                                     ; preds = %5, %33
  %37 = phi i32 [ %35, %33 ], [ -1, %5 ]
  %38 = phi i32 [ 1, %33 ], [ 0, %5 ]
  store i32 %37, i32* %1, align 4, !tbaa !77
  br label %39

; <label>:39:                                     ; preds = %36, %26
  %40 = phi i32 [ 0, %26 ], [ %38, %36 ]
  ret i32 %40
}

; Function Attrs: optsize
declare %struct._IO_FILE* @freopen64(i8*, i8*, %struct._IO_FILE*) local_unnamed_addr #11

; Function Attrs: nounwind optsize uwtable
define internal i8* @getF(%struct.lua_State* nocapture readnone, i8*, i64* nocapture) #0 {
  %4 = bitcast i8* %1 to i32*
  %5 = load i32, i32* %4, align 8, !tbaa !210
  %6 = icmp sgt i32 %5, 0
  br i1 %6, label %7, label %10

; <label>:7:                                      ; preds = %3
  %8 = sext i32 %5 to i64
  store i64 %8, i64* %2, align 8, !tbaa !82
  store i32 0, i32* %4, align 8, !tbaa !210
  %9 = getelementptr inbounds i8, i8* %1, i64 16
  br label %20

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds i8, i8* %1, i64 8
  %12 = bitcast i8* %11 to %struct._IO_FILE**
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** %12, align 8, !tbaa !208
  %14 = tail call i32 @feof(%struct._IO_FILE* %13) #17
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds i8, i8* %1, i64 16
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** %12, align 8, !tbaa !208
  %19 = tail call i64 @fread(i8* nonnull %17, i64 1, i64 8192, %struct._IO_FILE* %18) #16
  store i64 %19, i64* %2, align 8, !tbaa !82
  br label %20

; <label>:20:                                     ; preds = %7, %16, %10
  %21 = phi i8* [ null, %10 ], [ %17, %16 ], [ %9, %7 ]
  ret i8* %21
}

; Function Attrs: nounwind optsize readonly
declare i32 @ferror(%struct._IO_FILE* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind optsize
declare i32 @fclose(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_loadbufferx(%struct.lua_State*, i8*, i64, i8*, i8*) local_unnamed_addr #0 {
  %6 = alloca %struct.LoadS, align 8
  %7 = bitcast %struct.LoadS* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 0
  store i8* %1, i8** %8, align 8, !tbaa !211
  %9 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 1
  store i64 %2, i64* %9, align 8, !tbaa !213
  %10 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %7, i8* %3, i8* %4) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %7) #7
  ret i32 %10
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal i8* @getS(%struct.lua_State* nocapture readnone, i8* nocapture, i64* nocapture) #2 {
  %4 = getelementptr inbounds i8, i8* %1, i64 8
  %5 = bitcast i8* %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !213
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %11, label %8

; <label>:8:                                      ; preds = %3
  store i64 %6, i64* %2, align 8, !tbaa !82
  store i64 0, i64* %5, align 8, !tbaa !213
  %9 = bitcast i8* %1 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !211
  br label %11

; <label>:11:                                     ; preds = %3, %8
  %12 = phi i8* [ %10, %8 ], [ null, %3 ]
  ret i8* %12
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_loadstring(%struct.lua_State*, i8*) local_unnamed_addr #0 {
  %3 = alloca %struct.LoadS, align 8
  %4 = tail call i64 @strlen(i8* %1) #21
  %5 = bitcast %struct.LoadS* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %3, i64 0, i32 0
  store i8* %1, i8** %6, align 8, !tbaa !211
  %7 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %3, i64 0, i32 1
  store i64 %4, i64* %7, align 8, !tbaa !213
  %8 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %5, i8* %1, i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_callmeta(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = add i32 %1, 1000999
  %5 = icmp ugt i32 %4, 1000999
  br i1 %5, label %18, label %6

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = bitcast %struct.CallInfo** %10 to i64**
  %12 = load i64*, i64** %11, align 8, !tbaa !24
  %13 = load i64, i64* %12, align 8, !tbaa !64
  %14 = sub i64 %9, %13
  %15 = lshr exact i64 %14, 4
  %16 = trunc i64 %15 to i32
  %17 = add nsw i32 %16, %1
  br label %18

; <label>:18:                                     ; preds = %3, %6
  %19 = phi i32 [ %17, %6 ], [ %1, %3 ]
  %20 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %19, i8* %2) #16
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %36, label %22

; <label>:22:                                     ; preds = %18
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %24 = bitcast %union.StackValue** %23 to %struct.TValue**
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !20
  %26 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %19) #17
  %27 = bitcast %struct.TValue* %26 to i64*
  %28 = bitcast %struct.TValue* %25 to i64*
  %29 = load i64, i64* %27, align 8
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %25, i64 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1
  store %union.StackValue* %34, %union.StackValue** %23, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %35, i32 1) #17
  br label %36

; <label>:36:                                     ; preds = %18, %22
  %37 = phi i32 [ 1, %22 ], [ 0, %18 ]
  ret i32 %37
}

; Function Attrs: nounwind optsize uwtable
define i64 @luaL_len(%struct.lua_State*, i32) local_unnamed_addr #0 {
  %3 = alloca i32, align 4
  %4 = bitcast i32* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %4) #7
  %5 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  tail call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %7, %struct.TValue* %5) #17
  %8 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %6, align 8, !tbaa !20
  %10 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %3) #16
  %11 = load i32, i32* %3, align 4, !tbaa !77
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %2
  %14 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.39, i64 0, i64 0)) #16
  unreachable

; <label>:15:                                     ; preds = %2
  %16 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1
  store %union.StackValue* %17, %union.StackValue** %6, align 8, !tbaa !20
  %18 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %17, i32 0) #17
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %4) #7
  ret i64 %10
}

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_tolstring(%struct.lua_State*, i32, i64*) local_unnamed_addr #0 {
  %4 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0)) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %16, label %6

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = add nsw i8 %11, -3
  %13 = icmp ugt i8 %12, 1
  br i1 %13, label %14, label %94

; <label>:14:                                     ; preds = %6
  %15 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.41, i64 0, i64 0)) #16
  unreachable

; <label>:16:                                     ; preds = %3
  %17 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 8
  %26 = icmp eq %struct.TValue* %17, %25
  br i1 %26, label %61, label %27

; <label>:27:                                     ; preds = %16, %22
  %28 = trunc i8 %19 to i4
  switch i4 %28, label %61 [
    i4 3, label %29
    i4 4, label %37
    i4 1, label %48
    i4 0, label %59
  ]

; <label>:29:                                     ; preds = %27
  %30 = icmp eq i8 %19, 35
  br i1 %30, label %31, label %34

; <label>:31:                                     ; preds = %29
  %32 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %1, i32* null) #16
  %33 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.42, i64 0, i64 0), i64 %32) #16
  br label %94

; <label>:34:                                     ; preds = %29
  %35 = tail call double @lua_tonumberx(%struct.lua_State* %0, i32 %1, i32* null) #16
  %36 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i64 0, i64 0), double %35) #16
  br label %94

; <label>:37:                                     ; preds = %27
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %39 = bitcast %union.StackValue** %38 to %struct.TValue**
  %40 = load %struct.TValue*, %struct.TValue** %39, align 8, !tbaa !20
  %41 = bitcast %struct.TValue* %17 to i64*
  %42 = bitcast %struct.TValue* %40 to i64*
  %43 = load i64, i64* %41, align 8
  store i64 %43, i64* %42, align 8
  %44 = load i8, i8* %18, align 8, !tbaa !22
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  store i8 %44, i8* %45, align 8, !tbaa !22
  %46 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 1
  store %union.StackValue* %47, %union.StackValue** %38, align 8, !tbaa !20
  br label %94

; <label>:48:                                     ; preds = %27
  br i1 %21, label %55, label %49

; <label>:49:                                     ; preds = %48
  %50 = icmp eq i8 %19, 1
  br i1 %50, label %51, label %56

; <label>:51:                                     ; preds = %49
  %52 = bitcast %struct.TValue* %17 to i32*
  %53 = load i32, i32* %52, align 8, !tbaa !21
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %55, label %56

; <label>:55:                                     ; preds = %48, %51
  br label %56

; <label>:56:                                     ; preds = %49, %51, %55
  %57 = phi i8* [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.45, i64 0, i64 0), %55 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0), %51 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.44, i64 0, i64 0), %49 ]
  %58 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %57) #16
  br label %94

; <label>:59:                                     ; preds = %27
  %60 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.46, i64 0, i64 0)) #16
  br label %94

; <label>:61:                                     ; preds = %22, %27
  %62 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %63 = icmp eq i32 %62, 4
  br i1 %63, label %64, label %66

; <label>:64:                                     ; preds = %61
  %65 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  br label %84

; <label>:66:                                     ; preds = %61
  %67 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %68 = getelementptr inbounds %struct.TValue, %struct.TValue* %67, i64 0, i32 1
  %69 = load i8, i8* %68, align 8, !tbaa !22
  %70 = and i8 %69, 15
  %71 = icmp eq i8 %70, 0
  br i1 %71, label %72, label %77

; <label>:72:                                     ; preds = %66
  %73 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %74 = load %struct.global_State*, %struct.global_State** %73, align 8, !tbaa !2
  %75 = getelementptr inbounds %struct.global_State, %struct.global_State* %74, i64 0, i32 8
  %76 = icmp eq %struct.TValue* %67, %75
  br i1 %76, label %80, label %77

; <label>:77:                                     ; preds = %72, %66
  %78 = add nuw nsw i8 %70, 1
  %79 = zext i8 %78 to i64
  br label %80

; <label>:80:                                     ; preds = %72, %77
  %81 = phi i64 [ %79, %77 ], [ 0, %72 ]
  %82 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %81
  %83 = load i8*, i8** %82, align 8, !tbaa !54
  br label %84

; <label>:84:                                     ; preds = %80, %64
  %85 = phi i8* [ %65, %64 ], [ %83, %80 ]
  %86 = tail call i8* @lua_topointer(%struct.lua_State* %0, i32 %1) #16
  %87 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i64 0, i64 0), i8* %85, i8* %86) #16
  %88 = icmp eq i32 %62, 0
  br i1 %88, label %94, label %89

; <label>:89:                                     ; preds = %84
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #16
  %90 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %91 = load %union.StackValue*, %union.StackValue** %90, align 8, !tbaa !20
  %92 = getelementptr inbounds %union.StackValue, %union.StackValue* %91, i64 -1
  store %union.StackValue* %92, %union.StackValue** %90, align 8, !tbaa !20
  %93 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %92, i32 0) #17
  br label %94

; <label>:94:                                     ; preds = %89, %84, %6, %37, %56, %59, %34, %31
  %95 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* %2) #16
  ret i8* %95
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_setfuncs(%struct.lua_State*, %struct.luaL_Reg* nocapture readonly, i32) local_unnamed_addr #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.48, i64 0, i64 0)) #16
  %4 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %1, i64 0, i32 0
  %5 = load i8*, i8** %4, align 8, !tbaa !214
  %6 = icmp eq i8* %5, null
  br i1 %6, label %41, label %7

; <label>:7:                                      ; preds = %3
  %8 = icmp sgt i32 %2, 0
  %9 = sub nsw i32 0, %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = sub i32 -2, %2
  br label %13

; <label>:13:                                     ; preds = %7, %32
  %14 = phi i8** [ %4, %7 ], [ %38, %32 ]
  br i1 %8, label %15, label %32

; <label>:15:                                     ; preds = %13
  %16 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %17, %15
  %18 = phi %struct.TValue* [ %16, %15 ], [ %31, %17 ]
  %19 = phi i32 [ 0, %15 ], [ %29, %17 ]
  %20 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %9) #17
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %18 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %10, align 8, !tbaa !20
  %29 = add nuw nsw i32 %19, 1
  %30 = icmp eq i32 %29, %2
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 0, i32 0
  br i1 %30, label %32, label %17

; <label>:32:                                     ; preds = %17, %13
  %33 = getelementptr inbounds i8*, i8** %14, i64 1
  %34 = bitcast i8** %33 to i32 (%struct.lua_State*)**
  %35 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %34, align 8, !tbaa !216
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* %35, i32 %2) #16
  %36 = load i8*, i8** %14, align 8, !tbaa !214
  %37 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %12) #17
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %37, i8* %36) #17
  %38 = getelementptr inbounds i8*, i8** %14, i64 2
  %39 = load i8*, i8** %38, align 8, !tbaa !214
  %40 = icmp eq i8* %39, null
  br i1 %40, label %41, label %13

; <label>:41:                                     ; preds = %32, %3
  %42 = xor i32 %2, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %42) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaL_getsubtable(%struct.lua_State*, i32, i8*) local_unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %4, i8* %2) #17
  %6 = icmp eq i32 %5, 5
  br i1 %6, label %39, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1
  store %union.StackValue* %10, %union.StackValue** %8, align 8, !tbaa !20
  %11 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %10, i32 0) #17
  %12 = add i32 %1, 1000999
  %13 = icmp ugt i32 %12, 1000999
  br i1 %13, label %25, label %14

; <label>:14:                                     ; preds = %7
  %15 = bitcast %union.StackValue** %8 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %18 = bitcast %struct.CallInfo** %17 to i64**
  %19 = load i64*, i64** %18, align 8, !tbaa !24
  %20 = load i64, i64* %19, align 8, !tbaa !64
  %21 = sub i64 %16, %20
  %22 = lshr exact i64 %21, 4
  %23 = trunc i64 %22 to i32
  %24 = add nsw i32 %23, %1
  br label %25

; <label>:25:                                     ; preds = %7, %14
  %26 = phi i32 [ %24, %14 ], [ %1, %7 ]
  tail call void @lua_createtable(%struct.lua_State* nonnull %0, i32 0, i32 0) #16
  %27 = bitcast %union.StackValue** %8 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 -1
  %30 = bitcast %struct.TValue* %29 to i64*
  %31 = bitcast %struct.TValue* %28 to i64*
  %32 = load i64, i64* %30, align 8
  store i64 %32, i64* %31, align 8
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 -1, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %34, i8* %35, align 8, !tbaa !22
  %36 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 1
  store %union.StackValue* %37, %union.StackValue** %8, align 8, !tbaa !20
  %38 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %26) #17
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* %38, i8* %2) #17
  br label %39

; <label>:39:                                     ; preds = %3, %25
  %40 = phi i32 [ 0, %25 ], [ 1, %3 ]
  ret i32 %40
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_requiref(%struct.lua_State*, i8*, i32 (%struct.lua_State*)*, i32) local_unnamed_addr #0 {
  %5 = tail call i32 @luaL_getsubtable(%struct.lua_State* %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0
  %9 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %8, i8* %1) #17
  %10 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !22
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %4
  %17 = icmp eq i8 %13, 1
  br i1 %17, label %18, label %45

; <label>:18:                                     ; preds = %16
  %19 = bitcast %struct.TValue* %11 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = icmp eq i32 %20, 0
  br i1 %21, label %22, label %45

; <label>:22:                                     ; preds = %4, %18
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1
  store %union.StackValue* %23, %union.StackValue** %6, align 8, !tbaa !20
  %24 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %23, i32 0) #17
  %25 = bitcast %union.StackValue** %6 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %27 = bitcast %struct.TValue* %26 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %2, i32 (%struct.lua_State*)** %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 38, i8* %28, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %6, align 8, !tbaa !20
  %31 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %1) #16
  %32 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %33, i32 1) #17
  %34 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 -1
  %36 = bitcast %struct.TValue* %35 to i64*
  %37 = bitcast %struct.TValue* %34 to i64*
  %38 = load i64, i64* %36, align 8
  store i64 %38, i64* %37, align 8
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 -1, i32 1
  %40 = load i8, i8* %39, align 8, !tbaa !22
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 0, i32 1
  store i8 %40, i8* %41, align 8, !tbaa !22
  %42 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 1
  store %union.StackValue* %43, %union.StackValue** %6, align 8, !tbaa !20
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %44, i8* %1) #17
  br label %45

; <label>:45:                                     ; preds = %16, %18, %22
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 -1) #16
  %46 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 -1
  store %union.StackValue* %47, %union.StackValue** %6, align 8, !tbaa !20
  %48 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %47, i32 0) #17
  %49 = icmp eq i32 %3, 0
  br i1 %49, label %68, label %50

; <label>:50:                                     ; preds = %45
  %51 = bitcast %union.StackValue** %6 to %struct.TValue**
  %52 = load %struct.TValue*, %struct.TValue** %51, align 8, !tbaa !20
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %52, i64 -1
  %54 = bitcast %struct.TValue* %53 to i64*
  %55 = bitcast %struct.TValue* %52 to i64*
  %56 = load i64, i64* %54, align 8
  store i64 %56, i64* %55, align 8
  %57 = getelementptr inbounds %struct.TValue, %struct.TValue* %52, i64 -1, i32 1
  %58 = load i8, i8* %57, align 8, !tbaa !22
  %59 = getelementptr inbounds %struct.TValue, %struct.TValue* %52, i64 0, i32 1
  store i8 %58, i8* %59, align 8, !tbaa !22
  %60 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %60, i64 1
  store %union.StackValue* %61, %union.StackValue** %6, align 8, !tbaa !20
  %62 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %63 = load %struct.global_State*, %struct.global_State** %62, align 8, !tbaa !2
  %64 = getelementptr inbounds %struct.global_State, %struct.global_State* %63, i64 0, i32 7, i32 0, i32 0
  %65 = bitcast %struct.GCObject** %64 to %struct.Table**
  %66 = load %struct.Table*, %struct.Table** %65, align 8, !tbaa !21
  %67 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %66, i64 2) #17
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* %67, i8* %1) #17
  br label %68

; <label>:68:                                     ; preds = %45, %50
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_addgsub(%struct.luaL_Buffer*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = tail call i64 @strlen(i8* %2) #21
  %6 = tail call i8* @strstr(i8* %1, i8* %2) #21
  %7 = icmp eq i8* %6, null
  br i1 %7, label %25, label %8

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  br label %10

; <label>:10:                                     ; preds = %8, %21
  %11 = phi i8* [ %6, %8 ], [ %23, %21 ]
  %12 = phi i8* [ %1, %8 ], [ %22, %21 ]
  %13 = ptrtoint i8* %11 to i64
  %14 = ptrtoint i8* %12 to i64
  %15 = sub i64 %13, %14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %21, label %17

; <label>:17:                                     ; preds = %10
  %18 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %15, i32 -1) #17
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %12, i64 %15, i32 1, i1 false) #7
  %19 = load i64, i64* %9, align 8, !tbaa !205
  %20 = add i64 %19, %15
  store i64 %20, i64* %9, align 8, !tbaa !205
  br label %21

; <label>:21:                                     ; preds = %10, %17
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %3) #16
  %22 = getelementptr inbounds i8, i8* %11, i64 %5
  %23 = tail call i8* @strstr(i8* %22, i8* %2) #21
  %24 = icmp eq i8* %23, null
  br i1 %24, label %25, label %10

; <label>:25:                                     ; preds = %21, %4
  %26 = phi i8* [ %1, %4 ], [ %22, %21 ]
  tail call void @luaL_addstring(%struct.luaL_Buffer* %0, i8* %26) #16
  ret void
}

; Function Attrs: nounwind optsize readonly
declare i8* @strstr(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define i8* @luaL_gsub(%struct.lua_State*, i8*, i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %7, align 8, !tbaa !207
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %9 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %8, %union.anon.6** %9, align 8, !tbaa !206
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %11 = bitcast i64* %10 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %11, align 8, !tbaa !82
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %5, i8* %1, i8* %2, i8* %3) #16
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  %12 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %6) #7
  ret i8* %12
}

; Function Attrs: nounwind optsize uwtable
define %struct.lua_State* @luaL_newstate() local_unnamed_addr #0 {
  %1 = tail call %struct.lua_State* @lua_newstate(i8* (i8*, i8*, i64, i64)* nonnull @l_alloc, i8* null) #16
  %2 = icmp eq %struct.lua_State* %1, null
  br i1 %2, label %13, label %3

; <label>:3:                                      ; preds = %0
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 37
  store i32 (%struct.lua_State*)* @panic, i32 (%struct.lua_State*)** %6, align 8, !tbaa !80
  %7 = tail call i8* @lua_newuserdatauv(%struct.lua_State* nonnull %1, i64 4, i32 0) #16
  %8 = bitcast i8* %7 to i32*
  %9 = tail call i32 @luaL_ref(%struct.lua_State* nonnull %1, i32 -1001000) #16
  store i32 0, i32* %8, align 4, !tbaa !77
  %10 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 44
  store i8* %7, i8** %11, align 8, !tbaa !191
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 43
  store void (i8*, i8*, i32)* @warnf, void (i8*, i8*, i32)** %12, align 8, !tbaa !192
  br label %13

; <label>:13:                                     ; preds = %0, %3
  ret %struct.lua_State* %1
}

; Function Attrs: nounwind optsize uwtable
define internal noalias i8* @l_alloc(i8* nocapture readnone, i8* nocapture, i64, i64) #0 {
  %5 = icmp eq i64 %3, 0
  br i1 %5, label %6, label %7

; <label>:6:                                      ; preds = %4
  tail call void @free(i8* %1) #17
  br label %9

; <label>:7:                                      ; preds = %4
  %8 = tail call i8* @realloc(i8* %1, i64 %3) #17
  br label %9

; <label>:9:                                      ; preds = %7, %6
  %10 = phi i8* [ null, %6 ], [ %8, %7 ]
  ret i8* %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @panic(%struct.lua_State*) #0 {
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %3 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %4 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %2, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.297, i64 0, i64 0), i8* %3) #23
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal void @warnf(i8* nocapture, i8* nocapture readonly, i32) #0 {
  %4 = bitcast i8* %0 to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !77
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %12

; <label>:7:                                      ; preds = %3
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %9 = tail call i32 @fputs(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.299, i64 0, i64 0), %struct._IO_FILE* %8) #24
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %11 = tail call i32 @fflush(%struct._IO_FILE* %10) #16
  br label %12

; <label>:12:                                     ; preds = %3, %7
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %14 = tail call i32 @fputs(i8* %1, %struct._IO_FILE* %13) #24
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %16 = tail call i32 @fflush(%struct._IO_FILE* %15) #16
  %17 = icmp eq i32 %2, 0
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %12
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %20 = tail call i32 @fputs(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.300, i64 0, i64 0), %struct._IO_FILE* %19) #24
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %22 = tail call i32 @fflush(%struct._IO_FILE* %21) #16
  br label %23

; <label>:23:                                     ; preds = %12, %18
  store i32 %2, i32* %4, align 4, !tbaa !77
  ret void
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_checkversion_(%struct.lua_State*, double, i64) local_unnamed_addr #0 {
  %4 = icmp eq i64 %2, 136
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.50, i64 0, i64 0)) #16
  unreachable

; <label>:7:                                      ; preds = %3
  %8 = fcmp une double %1, 5.040000e+02
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %7
  %10 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.51, i64 0, i64 0), double %1, double 5.040000e+02) #16
  unreachable

; <label>:11:                                     ; preds = %7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_base(%struct.lua_State*) #0 {
  %2 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 -1001000, i64 2) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([26 x %struct.luaL_Reg], [26 x %struct.luaL_Reg]* @base_funcs, i64 0, i64 0), i32 0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -1
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -1, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %15, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i64 0, i64 0)) #17
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.53, i64 0, i64 0)) #16
  %17 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %18, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i64 0, i64 0)) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_coroutine(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 8) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([9 x %struct.luaL_Reg], [9 x %struct.luaL_Reg]* @co_funcs, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_debug(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 16) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([17 x %struct.luaL_Reg], [17 x %struct.luaL_Reg]* @dblib, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_io(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @iolib, i64 0, i64 0), i32 0) #16
  %2 = tail call i32 @luaL_newmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -1
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -1, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %15, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0)) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @flib, i64 0, i64 0), i32 0) #17
  %16 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1
  store %union.StackValue* %17, %union.StackValue** %3, align 8, !tbaa !20
  %18 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %17, i32 0) #17
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !54
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %19, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i64 0, i64 0)) #16
  %20 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  tail call fastcc void @createstdfile(%struct.lua_State* %0, %struct._IO_FILE* %20, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.58, i64 0, i64 0)) #16
  %21 = load i64, i64* bitcast (%struct._IO_FILE** @stderr to i64*), align 8, !tbaa !54
  %22 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #17
  %23 = getelementptr inbounds i8, i8* %22, i64 8
  %24 = bitcast i8* %23 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %24, align 8, !tbaa !217
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 7
  %28 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %27, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %29 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  %30 = bitcast i8* %22 to i64*
  store i64 %21, i64* %30, align 8, !tbaa !219
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %24, align 8, !tbaa !217
  %31 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %32, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i64 0, i64 0)) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @createstdfile(%struct.lua_State*, %struct._IO_FILE*, i8*, i8*) unnamed_addr #0 {
  %5 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0) #16
  %6 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 0
  store %struct._IO_FILE* %1, %struct._IO_FILE** %6, align 8, !tbaa !219
  %7 = getelementptr inbounds %struct.luaL_Stream, %struct.luaL_Stream* %5, i64 0, i32 1
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %7, align 8, !tbaa !217
  %8 = icmp eq i8* %2, null
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %8, label %25, label %10

; <label>:10:                                     ; preds = %4
  %11 = bitcast %union.StackValue** %9 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 -1
  %14 = bitcast %struct.TValue* %13 to i64*
  %15 = bitcast %struct.TValue* %12 to i64*
  %16 = load i64, i64* %14, align 8
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 -1, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %18, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %9, align 8, !tbaa !20
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 7
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %24, i8* nonnull %2) #17
  br label %25

; <label>:25:                                     ; preds = %4, %10
  %26 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %27, i8* %3) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_math(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 27) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([28 x %struct.luaL_Reg], [28 x %struct.luaL_Reg]* @mathlib, i64 0, i64 0), i32 0) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to double*
  store double 0x400921FB54442D18, double* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.60, i64 0, i64 0)) #17
  %10 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %11 = bitcast %struct.TValue* %10 to double*
  store double 0x7FF0000000000000, double* %11, align 8, !tbaa !21
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 19, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %2, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %15, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i64 0, i64 0)) #17
  %16 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %17 = bitcast %struct.TValue* %16 to i64*
  store i64 9223372036854775807, i64* %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 35, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %2, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %21, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.62, i64 0, i64 0)) #17
  %22 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %23 = bitcast %struct.TValue* %22 to i64*
  store i64 -9223372036854775808, i64* %23, align 8, !tbaa !21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %22, i64 0, i32 1
  store i8 35, i8* %24, align 8, !tbaa !22
  %25 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %2, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %27, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.63, i64 0, i64 0)) #17
  %28 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 32, i32 0) #17
  %29 = bitcast i8* %28 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* %0, %struct.RanState* nonnull %29) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([3 x %struct.luaL_Reg], [3 x %struct.luaL_Reg]* @randfuncs, i64 0, i64 0), i32 1) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_package(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0) #17
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 1) #17
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @gctm, i32 (%struct.lua_State*)** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 38, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i64 0, i64 0)) #17
  %10 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  tail call void @lua_rawsetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*)) #17
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @pk_funcs, i64 0, i64 0), i32 0) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 4, i32 0) #17
  br label %11

; <label>:11:                                     ; preds = %11, %1
  %12 = phi i64 [ 0, %1 ], [ %25, %11 ]
  %13 = getelementptr inbounds [5 x i32 (%struct.lua_State*)*], [5 x i32 (%struct.lua_State*)*]* @createsearcherstable.searchers, i64 0, i64 %12
  %14 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 -2
  %16 = bitcast %struct.TValue* %15 to i64*
  %17 = bitcast %struct.TValue* %14 to i64*
  %18 = load i64, i64* %16, align 8
  store i64 %18, i64* %17, align 8
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 -2, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %2, align 8, !tbaa !20
  %24 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !54
  tail call void @lua_pushcclosure(%struct.lua_State* nonnull %0, i32 (%struct.lua_State*)* %24, i32 1) #17
  %25 = add nuw nsw i64 %12, 1
  tail call void @lua_rawseti(%struct.lua_State* nonnull %0, i32 -2, i64 %25) #17
  %26 = icmp eq i64 %25, 4
  br i1 %26, label %27, label %11

; <label>:27:                                     ; preds = %11
  %28 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %29, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0)) #17
  tail call fastcc void @setpath(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.65, i64 0, i64 0), i8* getelementptr inbounds ([151 x i8], [151 x i8]* @.str.66, i64 0, i64 0)) #16
  tail call fastcc void @setpath(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.68, i64 0, i64 0), i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.69, i64 0, i64 0)) #16
  %30 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.70, i64 0, i64 0)) #16
  %31 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %32, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.71, i64 0, i64 0)) #17
  %33 = tail call i32 @luaL_getsubtable(%struct.lua_State* nonnull %0, i32 -1001000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #16
  %34 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %35, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i64 0, i64 0)) #17
  %36 = tail call i32 @luaL_getsubtable(%struct.lua_State* nonnull %0, i32 -1001000, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0)) #16
  %37 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %38, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i64 0, i64 0)) #17
  %39 = tail call i32 @lua_rawgeti(%struct.lua_State* nonnull %0, i32 -1001000, i64 2) #16
  %40 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 -2
  %42 = bitcast %struct.TValue* %41 to i64*
  %43 = bitcast %struct.TValue* %40 to i64*
  %44 = load i64, i64* %42, align 8
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 -2, i32 1
  %46 = load i8, i8* %45, align 8, !tbaa !22
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  store i8 %46, i8* %47, align 8, !tbaa !22
  %48 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1
  store %union.StackValue* %49, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @luaL_setfuncs(%struct.lua_State* nonnull %0, %struct.luaL_Reg* getelementptr inbounds ([2 x %struct.luaL_Reg], [2 x %struct.luaL_Reg]* @ll_funcs, i64 0, i64 0), i32 1) #16
  %50 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %50, i64 -1
  store %union.StackValue* %51, %union.StackValue** %2, align 8, !tbaa !20
  %52 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %51, i32 0) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @setpath(%struct.lua_State*, i8*, i8*, i8*) unnamed_addr #0 {
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.484, i64 0, i64 0), i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.485, i64 0, i64 0)) #16
  %7 = tail call i8* @getenv(i8* nonnull %6) #17
  %8 = icmp eq i8* %7, null
  br i1 %8, label %9, label %14

; <label>:9:                                      ; preds = %4
  %10 = tail call i8* @getenv(i8* %2) #17
  %11 = icmp eq i8* %10, null
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %9
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %38

; <label>:14:                                     ; preds = %4, %9
  %15 = phi i8* [ %10, %9 ], [ %7, %4 ]
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %17 = load %struct.global_State*, %struct.global_State** %16, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 7
  %19 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %18, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0)) #17
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1, i32 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = and i8 %24, 15
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %41, label %27

; <label>:27:                                     ; preds = %14
  %28 = icmp eq i8 %24, 1
  br i1 %28, label %29, label %35

; <label>:29:                                     ; preds = %27
  %30 = bitcast %struct.TValue* %22 to i32*
  %31 = load i32, i32* %30, align 8, !tbaa !21
  %32 = icmp eq i32 %31, 0
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1
  store %union.StackValue* %33, %union.StackValue** %20, align 8, !tbaa !20
  %34 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %33, i32 0) #17
  br i1 %32, label %44, label %38

; <label>:35:                                     ; preds = %27
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1
  store %union.StackValue* %36, %union.StackValue** %20, align 8, !tbaa !20
  %37 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %36, i32 0) #17
  br label %38

; <label>:38:                                     ; preds = %12, %35, %29
  %39 = phi %union.StackValue** [ %13, %12 ], [ %20, %35 ], [ %20, %29 ]
  %40 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3) #16
  br label %106

; <label>:41:                                     ; preds = %14
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -1
  store %union.StackValue* %42, %union.StackValue** %20, align 8, !tbaa !20
  %43 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %42, i32 0) #17
  br label %44

; <label>:44:                                     ; preds = %41, %29
  %45 = tail call i8* @strstr(i8* nonnull %15, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.486, i64 0, i64 0)) #21
  %46 = icmp eq i8* %45, null
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %44
  %48 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* nonnull %15) #16
  br label %106

; <label>:49:                                     ; preds = %44
  %50 = tail call i64 @strlen(i8* nonnull %15) #21
  %51 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %51) #7
  %52 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %52, align 8, !tbaa !207
  %53 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %54 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %53, %union.anon.6** %54, align 8, !tbaa !206
  %55 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %56 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %57 = bitcast i64* %56 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %57, align 8, !tbaa !82
  %58 = icmp ult i8* %15, %45
  br i1 %58, label %59, label %79

; <label>:59:                                     ; preds = %49
  %60 = ptrtoint i8* %45 to i64
  %61 = ptrtoint i8* %15 to i64
  %62 = sub i64 %60, %61
  %63 = icmp eq i64 %62, 0
  br i1 %63, label %73, label %64

; <label>:64:                                     ; preds = %59
  %65 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 %62, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* nonnull %15, i64 %62, i32 1, i1 false) #7
  %66 = load i64, i64* %55, align 8, !tbaa !205
  %67 = add i64 %66, %62
  store i64 %67, i64* %55, align 8, !tbaa !205
  %68 = load i64, i64* %56, align 8, !tbaa !203
  %69 = icmp ult i64 %67, %68
  br i1 %69, label %73, label %70

; <label>:70:                                     ; preds = %64
  %71 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %72 = load i64, i64* %55, align 8, !tbaa !205
  br label %73

; <label>:73:                                     ; preds = %59, %70, %64
  %74 = phi i64 [ %72, %70 ], [ %67, %64 ], [ 0, %59 ]
  %75 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %76 = load i8*, i8** %75, align 8, !tbaa !206
  %77 = add i64 %74, 1
  store i64 %77, i64* %55, align 8, !tbaa !205
  %78 = getelementptr inbounds i8, i8* %76, i64 %74
  store i8 59, i8* %78, align 1, !tbaa !21
  br label %79

; <label>:79:                                     ; preds = %73, %49
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %5, i8* %3) #16
  %80 = getelementptr inbounds i8, i8* %15, i64 %50
  %81 = getelementptr inbounds i8, i8* %80, i64 -2
  %82 = icmp ult i8* %45, %81
  br i1 %82, label %83, label %105

; <label>:83:                                     ; preds = %79
  %84 = load i64, i64* %55, align 8, !tbaa !205
  %85 = load i64, i64* %56, align 8, !tbaa !203
  %86 = icmp ult i64 %84, %85
  br i1 %86, label %90, label %87

; <label>:87:                                     ; preds = %83
  %88 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %89 = load i64, i64* %55, align 8, !tbaa !205
  br label %90

; <label>:90:                                     ; preds = %87, %83
  %91 = phi i64 [ %89, %87 ], [ %84, %83 ]
  %92 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %93 = load i8*, i8** %92, align 8, !tbaa !206
  %94 = add i64 %91, 1
  store i64 %94, i64* %55, align 8, !tbaa !205
  %95 = getelementptr inbounds i8, i8* %93, i64 %91
  store i8 59, i8* %95, align 1, !tbaa !21
  %96 = ptrtoint i8* %81 to i64
  %97 = ptrtoint i8* %45 to i64
  %98 = sub i64 %96, %97
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %105, label %100

; <label>:100:                                    ; preds = %90
  %101 = getelementptr inbounds i8, i8* %45, i64 2
  %102 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 %98, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %102, i8* nonnull %101, i64 %98, i32 1, i1 false) #7
  %103 = load i64, i64* %55, align 8, !tbaa !205
  %104 = add i64 %103, %98
  store i64 %104, i64* %55, align 8, !tbaa !205
  br label %105

; <label>:105:                                    ; preds = %100, %90, %79
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %51) #7
  br label %106

; <label>:106:                                    ; preds = %47, %105, %38
  %107 = phi %union.StackValue** [ %20, %47 ], [ %20, %105 ], [ %39, %38 ]
  %108 = load %union.StackValue*, %union.StackValue** %107, align 8, !tbaa !20
  %109 = getelementptr inbounds %union.StackValue, %union.StackValue* %108, i64 -3, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %109, i8* %1) #17
  %110 = load %union.StackValue*, %union.StackValue** %107, align 8, !tbaa !20
  %111 = getelementptr inbounds %union.StackValue, %union.StackValue* %110, i64 -1
  store %union.StackValue* %111, %union.StackValue** %107, align 8, !tbaa !20
  %112 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %111, i32 0) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_os(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 11) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([12 x %struct.luaL_Reg], [12 x %struct.luaL_Reg]* @syslib, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_string(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 17) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([18 x %struct.luaL_Reg], [18 x %struct.luaL_Reg]* @strlib, i64 0, i64 0), i32 0) #16
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 9) #17
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([10 x %struct.luaL_Reg], [10 x %struct.luaL_Reg]* @stringmetamethods, i64 0, i64 0), i32 0) #17
  %2 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #17
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -2
  %7 = bitcast %struct.TValue* %6 to i64*
  %8 = bitcast %struct.TValue* %5 to i64*
  %9 = load i64, i64* %7, align 8
  store i64 %9, i64* %8, align 8
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 -2, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %11, i8* %12, align 8, !tbaa !22
  %13 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %3, align 8, !tbaa !20
  %15 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  %16 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1
  store %union.StackValue* %17, %union.StackValue** %3, align 8, !tbaa !20
  %18 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %17, i32 0) #17
  %19 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 -2
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %19 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 -2, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %3, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %29, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0)) #17
  %30 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1
  store %union.StackValue* %31, %union.StackValue** %3, align 8, !tbaa !20
  %32 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %31, i32 0) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_table(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 7) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([8 x %struct.luaL_Reg], [8 x %struct.luaL_Reg]* @tab_funcs, i64 0, i64 0), i32 0) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define i32 @luaopen_utf8(%struct.lua_State*) #0 {
  tail call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 6) #16
  tail call void @luaL_setfuncs(%struct.lua_State* %0, %struct.luaL_Reg* getelementptr inbounds ([7 x %struct.luaL_Reg], [7 x %struct.luaL_Reg]* @funcs, i64 0, i64 0), i32 0) #16
  %2 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.75, i64 0, i64 0), i64 14) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %5, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.76, i64 0, i64 0)) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define void @luaL_openlibs(%struct.lua_State*) local_unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %3

; <label>:3:                                      ; preds = %1, %3
  %4 = phi i32 (%struct.lua_State*)* [ @luaopen_base, %1 ], [ %13, %3 ]
  %5 = phi %struct.luaL_Reg* [ getelementptr inbounds ([11 x %struct.luaL_Reg], [11 x %struct.luaL_Reg]* @loadedlibs, i64 0, i64 0), %1 ], [ %11, %3 ]
  %6 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %5, i64 0, i32 0
  %7 = load i8*, i8** %6, align 8, !tbaa !214
  tail call void @luaL_requiref(%struct.lua_State* %0, i8* %7, i32 (%struct.lua_State*)* nonnull %4, i32 1) #16
  %8 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1
  store %union.StackValue* %9, %union.StackValue** %2, align 8, !tbaa !20
  %10 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %9, i32 0) #17
  %11 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %5, i64 1
  %12 = getelementptr inbounds %struct.luaL_Reg, %struct.luaL_Reg* %5, i64 1, i32 1
  %13 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %12, align 8, !tbaa !216
  %14 = icmp eq i32 (%struct.lua_State*)* %13, null
  br i1 %14, label %15, label %3

; <label>:15:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define i32 @main(i32, i8**) local_unnamed_addr #0 {
  %3 = alloca %struct.CallS, align 8
  %4 = tail call %struct.lua_State* @luaL_newstate() #16
  %5 = icmp eq %struct.lua_State* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %2
  %7 = load i8*, i8** %1, align 8, !tbaa !54
  tail call fastcc void @l_message(i8* %7, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.77, i64 0, i64 0)) #16
  br label %57

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %4, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = bitcast %struct.TValue* %11 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @pmain, i32 (%struct.lua_State*)** %12, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 38, i8* %13, align 8, !tbaa !22
  %14 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %9, align 8, !tbaa !20
  %16 = sext i32 %0 to i64
  %17 = bitcast %union.StackValue* %15 to i64*
  store i64 %16, i64* %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1, i32 0, i32 1
  store i8 35, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %9, align 8, !tbaa !20
  %21 = bitcast %union.StackValue* %20 to i8***
  store i8** %1, i8*** %21, align 8, !tbaa !21
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1, i32 0, i32 1
  store i8 2, i8* %22, align 8, !tbaa !22
  %23 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %9, align 8, !tbaa !20
  %25 = bitcast %struct.CallS* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %25) #7
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 -2
  %27 = getelementptr inbounds %struct.CallS, %struct.CallS* %3, i64 0, i32 0
  store %union.StackValue* %26, %union.StackValue** %27, align 8, !tbaa !159
  %28 = ptrtoint %union.StackValue* %26 to i64
  %29 = getelementptr inbounds %struct.CallS, %struct.CallS* %3, i64 0, i32 1
  store i32 1, i32* %29, align 8, !tbaa !161
  %30 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %4, i64 0, i32 11
  %31 = bitcast %union.StackValue** %30 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !23
  %33 = sub i64 %28, %32
  %34 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %4, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %25, i64 %33, i64 0) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %25) #7
  %35 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 -1, i32 0
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 -1, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = and i8 %38, 15
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %47, label %41

; <label>:41:                                     ; preds = %8
  %42 = icmp eq i8 %38, 1
  br i1 %42, label %43, label %47

; <label>:43:                                     ; preds = %41
  %44 = bitcast %struct.TValue* %36 to i32*
  %45 = load i32, i32* %44, align 8, !tbaa !21
  %46 = icmp eq i32 %45, 0
  br label %47

; <label>:47:                                     ; preds = %8, %41, %43
  %48 = phi i1 [ true, %8 ], [ false, %41 ], [ %46, %43 ]
  %49 = call fastcc i32 @report(%struct.lua_State* nonnull %4, i32 %34) #16
  %50 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %4, i64 0, i32 7
  %51 = load %struct.global_State*, %struct.global_State** %50, align 8, !tbaa !2
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %51, i64 0, i32 38
  %53 = load %struct.lua_State*, %struct.lua_State** %52, align 8, !tbaa !38
  call fastcc void @close_state(%struct.lua_State* %53) #17
  %54 = icmp ne i32 %34, 0
  %55 = or i1 %54, %48
  %56 = zext i1 %55 to i32
  br label %57

; <label>:57:                                     ; preds = %47, %6
  %58 = phi i32 [ 1, %6 ], [ %56, %47 ]
  ret i32 %58
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @l_message(i8*, i8*) unnamed_addr #0 {
  %3 = icmp eq i8* %0, null
  br i1 %3, label %9, label %4

; <label>:4:                                      ; preds = %2
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %6 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* nonnull %0) #23
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %8 = tail call i32 @fflush(%struct._IO_FILE* %7) #16
  br label %9

; <label>:9:                                      ; preds = %2, %4
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %11 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %1) #23
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %13 = tail call i32 @fflush(%struct._IO_FILE* %12) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @pmain(%struct.lua_State*) #0 {
  %2 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* null) #16
  %3 = trunc i64 %2 to i32
  %4 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 2) #16
  %5 = bitcast i8* %4 to i8**
  %6 = getelementptr inbounds i8, i8* %4, i64 8
  %7 = bitcast i8* %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !54
  %9 = icmp eq i8* %8, null
  br i1 %9, label %68, label %10

; <label>:10:                                     ; preds = %1
  br label %11

; <label>:11:                                     ; preds = %10, %59
  %12 = phi i32 [ %62, %59 ], [ 1, %10 ]
  %13 = phi i8* [ %65, %59 ], [ %8, %10 ]
  %14 = phi i32 [ %60, %59 ], [ 0, %10 ]
  %15 = load i8, i8* %13, align 1, !tbaa !21
  %16 = icmp eq i8 %15, 45
  br i1 %16, label %17, label %68

; <label>:17:                                     ; preds = %11
  %18 = getelementptr inbounds i8, i8* %13, i64 1
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = sext i8 %19 to i32
  switch i32 %20, label %67 [
    i32 45, label %21
    i32 0, label %68
    i32 69, label %28
    i32 105, label %34
    i32 118, label %36
    i32 101, label %43
    i32 108, label %45
  ]

; <label>:21:                                     ; preds = %17
  %22 = getelementptr inbounds i8, i8* %13, i64 2
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = icmp eq i8 %23, 0
  %25 = zext i1 %24 to i32
  %26 = add nsw i32 %12, %25
  %27 = select i1 %24, i32 %14, i32 1
  br label %68

; <label>:28:                                     ; preds = %17
  %29 = getelementptr inbounds i8, i8* %13, i64 2
  %30 = load i8, i8* %29, align 1, !tbaa !21
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %68

; <label>:32:                                     ; preds = %28
  %33 = or i32 %14, 16
  br label %59

; <label>:34:                                     ; preds = %17
  %35 = or i32 %14, 2
  br label %36

; <label>:36:                                     ; preds = %34, %17
  %37 = phi i32 [ %14, %17 ], [ %35, %34 ]
  %38 = getelementptr inbounds i8, i8* %13, i64 2
  %39 = load i8, i8* %38, align 1, !tbaa !21
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %41, label %68

; <label>:41:                                     ; preds = %36
  %42 = or i32 %37, 4
  br label %59

; <label>:43:                                     ; preds = %17
  %44 = or i32 %14, 8
  br label %45

; <label>:45:                                     ; preds = %43, %17
  %46 = phi i32 [ %14, %17 ], [ %44, %43 ]
  %47 = getelementptr inbounds i8, i8* %13, i64 2
  %48 = load i8, i8* %47, align 1, !tbaa !21
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %50, label %59

; <label>:50:                                     ; preds = %45
  %51 = add nsw i32 %12, 1
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds i8*, i8** %5, i64 %52
  %54 = load i8*, i8** %53, align 8, !tbaa !54
  %55 = icmp eq i8* %54, null
  br i1 %55, label %68, label %56

; <label>:56:                                     ; preds = %50
  %57 = load i8, i8* %54, align 1, !tbaa !21
  %58 = icmp eq i8 %57, 45
  br i1 %58, label %68, label %59

; <label>:59:                                     ; preds = %56, %45, %41, %32
  %60 = phi i32 [ %46, %56 ], [ %46, %45 ], [ %42, %41 ], [ %33, %32 ]
  %61 = phi i32 [ %51, %56 ], [ %12, %45 ], [ %12, %41 ], [ %12, %32 ]
  %62 = add nsw i32 %61, 1
  %63 = sext i32 %62 to i64
  %64 = getelementptr inbounds i8*, i8** %5, i64 %63
  %65 = load i8*, i8** %64, align 8, !tbaa !54
  %66 = icmp eq i8* %65, null
  br i1 %66, label %68, label %11

; <label>:67:                                     ; preds = %17
  br label %68

; <label>:68:                                     ; preds = %11, %17, %28, %36, %50, %56, %59, %67, %21, %1
  %69 = phi i32 [ 1, %1 ], [ %26, %21 ], [ %12, %67 ], [ %12, %50 ], [ %12, %56 ], [ %62, %59 ], [ %12, %36 ], [ %12, %28 ], [ %12, %17 ], [ %12, %11 ]
  %70 = phi i32 [ 0, %1 ], [ %27, %21 ], [ 1, %67 ], [ 1, %50 ], [ 1, %56 ], [ %60, %59 ], [ 1, %36 ], [ 1, %28 ], [ %14, %17 ], [ %14, %11 ]
  %71 = load i8*, i8** %5, align 8, !tbaa !54
  %72 = icmp eq i8* %71, null
  br i1 %72, label %77, label %73

; <label>:73:                                     ; preds = %68
  %74 = load i8, i8* %71, align 1, !tbaa !21
  %75 = icmp eq i8 %74, 0
  br i1 %75, label %77, label %76

; <label>:76:                                     ; preds = %73
  store i8* %71, i8** @progname, align 8, !tbaa !54
  br label %77

; <label>:77:                                     ; preds = %73, %68, %76
  %78 = icmp eq i32 %70, 1
  br i1 %78, label %79, label %106

; <label>:79:                                     ; preds = %77
  %80 = sext i32 %69 to i64
  %81 = getelementptr inbounds i8*, i8** %5, i64 %80
  %82 = load i8*, i8** %81, align 8, !tbaa !54
  %83 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %84 = load i8*, i8** @progname, align 8, !tbaa !54
  %85 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %83, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.616, i64 0, i64 0), i8* %84) #25
  %86 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %87 = tail call i32 @fflush(%struct._IO_FILE* %86) #17
  %88 = getelementptr inbounds i8, i8* %82, i64 1
  %89 = load i8, i8* %88, align 1, !tbaa !21
  switch i8 %89, label %95 [
    i8 101, label %90
    i8 108, label %90
  ]

; <label>:90:                                     ; preds = %79, %79
  %91 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %92 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %91, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.618, i64 0, i64 0), i8* nonnull %82) #25
  %93 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %94 = tail call i32 @fflush(%struct._IO_FILE* %93) #17
  br label %100

; <label>:95:                                     ; preds = %79
  %96 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %97 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %96, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.619, i64 0, i64 0), i8* nonnull %82) #25
  %98 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %99 = tail call i32 @fflush(%struct._IO_FILE* %98) #17
  br label %100

; <label>:100:                                    ; preds = %90, %95
  %101 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %102 = load i8*, i8** @progname, align 8, !tbaa !54
  %103 = tail call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %101, i8* getelementptr inbounds ([365 x i8], [365 x i8]* @.str.620, i64 0, i64 0), i8* %102) #25
  %104 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %105 = tail call i32 @fflush(%struct._IO_FILE* %104) #17
  br label %274

; <label>:106:                                    ; preds = %77
  %107 = and i32 %70, 4
  %108 = icmp eq i32 %107, 0
  br i1 %108, label %110, label %109

; <label>:109:                                    ; preds = %106
  tail call fastcc void @print_version() #16
  br label %110

; <label>:110:                                    ; preds = %106, %109
  %111 = and i32 %70, 16
  %112 = icmp eq i32 %111, 0
  br i1 %112, label %125, label %113

; <label>:113:                                    ; preds = %110
  %114 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %115 = bitcast %union.StackValue** %114 to %struct.TValue**
  %116 = load %struct.TValue*, %struct.TValue** %115, align 8, !tbaa !20
  %117 = bitcast %struct.TValue* %116 to i32*
  store i32 1, i32* %117, align 8, !tbaa !21
  %118 = getelementptr inbounds %struct.TValue, %struct.TValue* %116, i64 0, i32 1
  store i8 1, i8* %118, align 8, !tbaa !22
  %119 = load %union.StackValue*, %union.StackValue** %114, align 8, !tbaa !20
  %120 = getelementptr inbounds %union.StackValue, %union.StackValue* %119, i64 1
  store %union.StackValue* %120, %union.StackValue** %114, align 8, !tbaa !20
  %121 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %122 = load %struct.global_State*, %struct.global_State** %121, align 8, !tbaa !2
  %123 = getelementptr inbounds %struct.global_State, %struct.global_State* %122, i64 0, i32 7
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %123, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.487, i64 0, i64 0)) #17
  tail call void @luaL_openlibs(%struct.lua_State* %0) #16
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** nonnull %5, i32 %3, i32 %69) #16
  %124 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0) #16
  br label %146

; <label>:125:                                    ; preds = %110
  tail call void @luaL_openlibs(%struct.lua_State* %0) #16
  tail call fastcc void @createargtable(%struct.lua_State* %0, i8** nonnull %5, i32 %3, i32 %69) #16
  %126 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 0, i32 0) #16
  %127 = tail call i8* @getenv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 1)) #17
  %128 = icmp eq i8* %127, null
  br i1 %128, label %129, label %132

; <label>:129:                                    ; preds = %125
  %130 = tail call i8* @getenv(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 1)) #17
  %131 = icmp eq i8* %130, null
  br i1 %131, label %146, label %132

; <label>:132:                                    ; preds = %129, %125
  %133 = phi i8* [ %130, %129 ], [ %127, %125 ]
  %134 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.624, i64 0, i64 0), %129 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.623, i64 0, i64 0), %125 ]
  %135 = load i8, i8* %133, align 1, !tbaa !21
  %136 = icmp eq i8 %135, 64
  br i1 %136, label %137, label %141

; <label>:137:                                    ; preds = %132
  %138 = getelementptr inbounds i8, i8* %133, i64 1
  %139 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* nonnull %138, i8* null) #17
  %140 = tail call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %139) #17
  br label %143

; <label>:141:                                    ; preds = %132
  %142 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* nonnull %133, i8* %134) #17
  br label %143

; <label>:143:                                    ; preds = %137, %141
  %144 = phi i32 [ %140, %137 ], [ %142, %141 ]
  %145 = icmp eq i32 %144, 0
  br i1 %145, label %146, label %274

; <label>:146:                                    ; preds = %129, %113, %143
  %147 = icmp sgt i32 %69, 1
  br i1 %147, label %148, label %197

; <label>:148:                                    ; preds = %146
  %149 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %150

; <label>:150:                                    ; preds = %193, %148
  %151 = phi i32 [ 1, %148 ], [ %195, %193 ]
  %152 = sext i32 %151 to i64
  %153 = getelementptr inbounds i8*, i8** %5, i64 %152
  %154 = load i8*, i8** %153, align 8, !tbaa !54
  %155 = getelementptr inbounds i8, i8* %154, i64 1
  %156 = load i8, i8* %155, align 1, !tbaa !21
  %157 = icmp eq i8 %156, 101
  switch i8 %156, label %193 [
    i8 108, label %158
    i8 101, label %158
  ]

; <label>:158:                                    ; preds = %150, %150
  %159 = getelementptr inbounds i8, i8* %154, i64 2
  %160 = load i8, i8* %159, align 1, !tbaa !21
  %161 = icmp eq i8 %160, 0
  br i1 %161, label %162, label %167

; <label>:162:                                    ; preds = %158
  %163 = add nsw i32 %151, 1
  %164 = sext i32 %163 to i64
  %165 = getelementptr inbounds i8*, i8** %5, i64 %164
  %166 = load i8*, i8** %165, align 8, !tbaa !54
  br label %167

; <label>:167:                                    ; preds = %162, %158
  %168 = phi i32 [ %163, %162 ], [ %151, %158 ]
  %169 = phi i8* [ %166, %162 ], [ %159, %158 ]
  br i1 %157, label %170, label %172

; <label>:170:                                    ; preds = %167
  %171 = tail call fastcc i32 @dostring(%struct.lua_State* %0, i8* %169, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.627, i64 0, i64 0)) #17
  br label %190

; <label>:172:                                    ; preds = %167
  %173 = load %struct.global_State*, %struct.global_State** %149, align 8, !tbaa !2
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %173, i64 0, i32 7, i32 0, i32 0
  %175 = bitcast %struct.GCObject** %174 to %struct.Table**
  %176 = load %struct.Table*, %struct.Table** %175, align 8, !tbaa !21
  %177 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %176, i64 2) #17
  %178 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %177, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.488, i64 0, i64 0)) #17
  %179 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %169) #17
  %180 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 1, i32 1) #17
  %181 = icmp eq i32 %180, 0
  br i1 %181, label %182, label %188

; <label>:182:                                    ; preds = %172
  %183 = load %struct.global_State*, %struct.global_State** %149, align 8, !tbaa !2
  %184 = getelementptr inbounds %struct.global_State, %struct.global_State* %183, i64 0, i32 7, i32 0, i32 0
  %185 = bitcast %struct.GCObject** %184 to %struct.Table**
  %186 = load %struct.Table*, %struct.Table** %185, align 8, !tbaa !21
  %187 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %186, i64 2) #17
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* %187, i8* %169) #17
  br label %188

; <label>:188:                                    ; preds = %182, %172
  %189 = tail call fastcc i32 @report(%struct.lua_State* nonnull %0, i32 %180) #17
  br label %190

; <label>:190:                                    ; preds = %188, %170
  %191 = phi i32 [ %171, %170 ], [ %189, %188 ]
  %192 = icmp eq i32 %191, 0
  br i1 %192, label %193, label %274

; <label>:193:                                    ; preds = %190, %150
  %194 = phi i32 [ %168, %190 ], [ %151, %150 ]
  %195 = add nsw i32 %194, 1
  %196 = icmp slt i32 %195, %69
  br i1 %196, label %150, label %197

; <label>:197:                                    ; preds = %193, %146
  %198 = icmp slt i32 %69, %3
  br i1 %198, label %199, label %256

; <label>:199:                                    ; preds = %197
  %200 = sext i32 %69 to i64
  %201 = getelementptr inbounds i8*, i8** %5, i64 %200
  %202 = load i8*, i8** %201, align 8, !tbaa !54
  %203 = tail call i32 @strcmp(i8* %202, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.481, i64 0, i64 0)) #21
  %204 = icmp eq i32 %203, 0
  br i1 %204, label %205, label %211

; <label>:205:                                    ; preds = %199
  %206 = getelementptr inbounds i8*, i8** %201, i64 -1
  %207 = load i8*, i8** %206, align 8, !tbaa !54
  %208 = tail call i32 @strcmp(i8* %207, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.628, i64 0, i64 0)) #21
  %209 = icmp eq i32 %208, 0
  %210 = select i1 %209, i8* %202, i8* null
  br label %211

; <label>:211:                                    ; preds = %205, %199
  %212 = phi i8* [ %202, %199 ], [ %210, %205 ]
  %213 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %212, i8* null) #17
  %214 = icmp eq i32 %213, 0
  br i1 %214, label %215, label %252

; <label>:215:                                    ; preds = %211
  %216 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %217 = load %struct.global_State*, %struct.global_State** %216, align 8, !tbaa !2
  %218 = getelementptr inbounds %struct.global_State, %struct.global_State* %217, i64 0, i32 7, i32 0, i32 0
  %219 = bitcast %struct.GCObject** %218 to %struct.Table**
  %220 = load %struct.Table*, %struct.Table** %219, align 8, !tbaa !21
  %221 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %220, i64 2) #17
  %222 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %221, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0)) #17
  %223 = icmp eq i32 %222, 5
  br i1 %223, label %226, label %224

; <label>:224:                                    ; preds = %215
  %225 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.629, i64 0, i64 0)) #17
  unreachable

; <label>:226:                                    ; preds = %215
  %227 = tail call i64 @luaL_len(%struct.lua_State* nonnull %0, i32 -1) #17
  %228 = trunc i64 %227 to i32
  %229 = add nsw i32 %228, 3
  tail call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 %229, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.630, i64 0, i64 0)) #17
  %230 = icmp slt i32 %228, 1
  br i1 %230, label %245, label %231

; <label>:231:                                    ; preds = %226
  %232 = add i64 %227, 1
  %233 = and i64 %232, 4294967295
  br label %234

; <label>:234:                                    ; preds = %234, %231
  %235 = phi i64 [ %239, %234 ], [ 1, %231 ]
  %236 = phi i32 [ %241, %234 ], [ -1, %231 ]
  %237 = phi i32 [ %240, %234 ], [ 1, %231 ]
  %238 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 %236, i64 %235) #17
  %239 = add nuw nsw i64 %235, 1
  %240 = add nuw nsw i32 %237, 1
  %241 = xor i32 %237, -1
  %242 = icmp eq i64 %239, %233
  br i1 %242, label %243, label %234

; <label>:243:                                    ; preds = %234
  %244 = xor i32 %228, -1
  br label %245

; <label>:245:                                    ; preds = %243, %226
  %246 = phi i32 [ -1, %226 ], [ %244, %243 ]
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %246, i32 -1) #17
  %247 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %248 = load %union.StackValue*, %union.StackValue** %247, align 8, !tbaa !20
  %249 = getelementptr inbounds %union.StackValue, %union.StackValue* %248, i64 -1
  store %union.StackValue* %249, %union.StackValue** %247, align 8, !tbaa !20
  %250 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %249, i32 0) #17
  %251 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 %228, i32 -1) #17
  br label %252

; <label>:252:                                    ; preds = %211, %245
  %253 = phi i32 [ %251, %245 ], [ %213, %211 ]
  %254 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %253) #17
  %255 = icmp eq i32 %254, 0
  br i1 %255, label %256, label %274

; <label>:256:                                    ; preds = %252, %197
  %257 = and i32 %70, 2
  %258 = icmp eq i32 %257, 0
  br i1 %258, label %260, label %259

; <label>:259:                                    ; preds = %256
  tail call fastcc void @doREPL(%struct.lua_State* %0) #16
  br label %266

; <label>:260:                                    ; preds = %256
  %261 = icmp eq i32 %69, %3
  %262 = and i32 %70, 12
  %263 = icmp eq i32 %262, 0
  %264 = and i1 %261, %263
  br i1 %264, label %265, label %266

; <label>:265:                                    ; preds = %260
  tail call fastcc void @print_version() #16
  tail call fastcc void @doREPL(%struct.lua_State* %0) #16
  br label %266

; <label>:266:                                    ; preds = %260, %265, %259
  %267 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %268 = bitcast %union.StackValue** %267 to %struct.TValue**
  %269 = load %struct.TValue*, %struct.TValue** %268, align 8, !tbaa !20
  %270 = bitcast %struct.TValue* %269 to i32*
  store i32 1, i32* %270, align 8, !tbaa !21
  %271 = getelementptr inbounds %struct.TValue, %struct.TValue* %269, i64 0, i32 1
  store i8 1, i8* %271, align 8, !tbaa !22
  %272 = load %union.StackValue*, %union.StackValue** %267, align 8, !tbaa !20
  %273 = getelementptr inbounds %union.StackValue, %union.StackValue* %272, i64 1
  store %union.StackValue* %273, %union.StackValue** %267, align 8, !tbaa !20
  br label %274

; <label>:274:                                    ; preds = %190, %252, %143, %266, %100
  %275 = phi i32 [ 0, %100 ], [ 1, %266 ], [ 0, %143 ], [ 0, %252 ], [ 0, %190 ]
  ret i32 %275
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @report(%struct.lua_State*, i32 returned) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %11, label %4

; <label>:4:                                      ; preds = %2
  %5 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %6 = load i8*, i8** @progname, align 8, !tbaa !54
  tail call fastcc void @l_message(i8* %6, i8* %5) #16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1
  store %union.StackValue* %9, %union.StackValue** %7, align 8, !tbaa !20
  %10 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %9, i32 0) #17
  br label %11

; <label>:11:                                     ; preds = %2, %4
  ret i32 %1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @tryagain(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 8, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !100
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %4
  tail call fastcc void @luaC_fullgc(%struct.lua_State* nonnull %0, i32 1) #16
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %13 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %12, align 8, !tbaa !59
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !60
  %16 = tail call i8* %13(i8* %15, i8* %1, i64 %2, i64 %3) #17
  br label %17

; <label>:17:                                     ; preds = %4, %11
  %18 = phi i8* [ %16, %11 ], [ null, %4 ]
  ret i8* %18
}

; Function Attrs: nounwind optsize
declare i64 @time(i64*) local_unnamed_addr #9

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @tablerehash(%struct.TString** nocapture, i32, i32) unnamed_addr #2 {
  %4 = icmp slt i32 %1, %2
  br i1 %4, label %5, label %14

; <label>:5:                                      ; preds = %3
  %6 = sext i32 %1 to i64
  %7 = getelementptr %struct.TString*, %struct.TString** %0, i64 %6
  %8 = bitcast %struct.TString** %7 to i8*
  %9 = add i32 %2, -1
  %10 = sub i32 %9, %1
  %11 = zext i32 %10 to i64
  %12 = shl nuw nsw i64 %11, 3
  %13 = add nuw nsw i64 %12, 8
  call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 %13, i32 8, i1 false)
  br label %14

; <label>:14:                                     ; preds = %5, %3
  %15 = icmp sgt i32 %1, 0
  br i1 %15, label %16, label %42

; <label>:16:                                     ; preds = %14
  %17 = add nsw i32 %2, -1
  %18 = zext i32 %1 to i64
  br label %19

; <label>:19:                                     ; preds = %39, %16
  %20 = phi i64 [ 0, %16 ], [ %40, %39 ]
  %21 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %20
  %22 = load %struct.TString*, %struct.TString** %21, align 8, !tbaa !54
  store %struct.TString* null, %struct.TString** %21, align 8, !tbaa !54
  %23 = icmp eq %struct.TString* %22, null
  br i1 %23, label %39, label %24

; <label>:24:                                     ; preds = %19
  br label %25

; <label>:25:                                     ; preds = %24, %25
  %26 = phi %struct.TString* [ %29, %25 ], [ %22, %24 ]
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %26, i64 0, i32 6
  %28 = bitcast %union.anon* %27 to %struct.TString**
  %29 = load %struct.TString*, %struct.TString** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TString, %struct.TString* %26, i64 0, i32 5
  %31 = load i32, i32* %30, align 4, !tbaa !150
  %32 = and i32 %31, %17
  %33 = zext i32 %32 to i64
  %34 = getelementptr inbounds %struct.TString*, %struct.TString** %0, i64 %33
  %35 = bitcast %struct.TString** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !54
  %37 = getelementptr inbounds %union.anon, %union.anon* %27, i64 0, i32 0
  store i64 %36, i64* %37, align 8, !tbaa !21
  store %struct.TString* %26, %struct.TString** %34, align 8, !tbaa !54
  %38 = icmp eq %struct.TString* %29, null
  br i1 %38, label %39, label %25

; <label>:39:                                     ; preds = %25, %19
  %40 = add nuw nsw i64 %20, 1
  %41 = icmp eq i64 %40, %18
  br i1 %41, label %42, label %19

; <label>:42:                                     ; preds = %39, %14
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @freestack(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !23
  %4 = icmp eq %union.StackValue* %3, null
  br i1 %4, label %24, label %5

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  store %struct.CallInfo* %6, %struct.CallInfo** %7, align 8, !tbaa !24
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  %8 = bitcast %union.StackValue** %2 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !23
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %11 = load i32, i32* %10, align 4, !tbaa !26
  %12 = sext i32 %11 to i64
  %13 = shl nsw i64 %12, 4
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %15 = load %struct.global_State*, %struct.global_State** %14, align 8, !tbaa !2
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 0
  %17 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %16, align 8, !tbaa !59
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 1
  %19 = load i8*, i8** %18, align 8, !tbaa !60
  %20 = tail call i8* %17(i8* %19, i8* %9, i64 %13, i64 0) #17
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 3
  %22 = load i64, i64* %21, align 8, !tbaa !11
  %23 = sub i64 %22, %13
  store i64 %23, i64* %21, align 8, !tbaa !11
  br label %24

; <label>:24:                                     ; preds = %1, %5
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @separatetobefnz(%struct.global_State* nocapture, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  br label %4

; <label>:4:                                      ; preds = %4, %2
  %5 = phi %struct.GCObject** [ %3, %2 ], [ %8, %4 ]
  %6 = load %struct.GCObject*, %struct.GCObject** %5, align 8, !tbaa !54
  %7 = icmp eq %struct.GCObject* %6, null
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 0
  br i1 %7, label %9, label %4

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %11 = load %struct.GCObject*, %struct.GCObject** %10, align 8, !tbaa !54
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 34
  %13 = load %struct.GCObject*, %struct.GCObject** %12, align 8, !tbaa !56
  %14 = icmp eq %struct.GCObject* %11, %13
  br i1 %14, label %49, label %15

; <label>:15:                                     ; preds = %9
  %16 = icmp ne i32 %1, 0
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %18 = bitcast %struct.GCObject** %17 to i64*
  br label %19

; <label>:19:                                     ; preds = %15, %43
  %20 = phi %struct.GCObject* [ %13, %15 ], [ %44, %43 ]
  %21 = phi %struct.GCObject* [ %11, %15 ], [ %47, %43 ]
  %22 = phi %struct.GCObject** [ %5, %15 ], [ %46, %43 ]
  %23 = phi %struct.GCObject** [ %10, %15 ], [ %45, %43 ]
  %24 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %25 = load i8, i8* %24, align 1, !tbaa !70
  %26 = and i8 %25, 24
  %27 = icmp ne i8 %26, 0
  %28 = or i1 %16, %27
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %19
  %30 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 0
  br label %43

; <label>:31:                                     ; preds = %19
  %32 = load %struct.GCObject*, %struct.GCObject** %17, align 8, !tbaa !55
  %33 = icmp eq %struct.GCObject* %21, %32
  %34 = bitcast %struct.GCObject* %21 to i64*
  %35 = load i64, i64* %34, align 8, !tbaa !87
  br i1 %33, label %36, label %37

; <label>:36:                                     ; preds = %31
  store i64 %35, i64* %18, align 8, !tbaa !55
  br label %37

; <label>:37:                                     ; preds = %31, %36
  %38 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 0
  %39 = bitcast %struct.GCObject** %23 to i64*
  store i64 %35, i64* %39, align 8, !tbaa !54
  %40 = bitcast %struct.GCObject** %22 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !54
  store i64 %41, i64* %34, align 8, !tbaa !87
  store %struct.GCObject* %21, %struct.GCObject** %22, align 8, !tbaa !54
  %42 = load %struct.GCObject*, %struct.GCObject** %12, align 8, !tbaa !56
  br label %43

; <label>:43:                                     ; preds = %37, %29
  %44 = phi %struct.GCObject* [ %42, %37 ], [ %20, %29 ]
  %45 = phi %struct.GCObject** [ %23, %37 ], [ %30, %29 ]
  %46 = phi %struct.GCObject** [ %38, %37 ], [ %22, %29 ]
  %47 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !54
  %48 = icmp eq %struct.GCObject* %47, %44
  br i1 %48, label %49, label %19

; <label>:49:                                     ; preds = %43, %9
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @GCTM(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca %struct.TValue, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = bitcast %struct.TValue* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 28
  %7 = load %struct.GCObject*, %struct.GCObject** %6, align 8, !tbaa !101
  %8 = bitcast %struct.GCObject* %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !87
  %10 = bitcast %struct.GCObject** %6 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !101
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 20
  %12 = bitcast %struct.GCObject** %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !18
  store i64 %13, i64* %8, align 8, !tbaa !87
  store %struct.GCObject* %7, %struct.GCObject** %11, align 8, !tbaa !18
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %15 = load i8, i8* %14, align 1, !tbaa !70
  %16 = and i8 %15, -65
  store i8 %16, i8* %14, align 1, !tbaa !70
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %18 = load i8, i8* %17, align 1, !tbaa !42
  %19 = add i8 %18, -3
  %20 = icmp ult i8 %19, 4
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %1
  %22 = and i8 %15, -128
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 10
  %24 = load i8, i8* %23, align 4, !tbaa !15
  %25 = and i8 %24, 24
  %26 = or i8 %25, %22
  store i8 %26, i8* %14, align 1, !tbaa !70
  br label %27

; <label>:27:                                     ; preds = %1, %21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  store %struct.GCObject* %7, %struct.GCObject** %28, align 8, !tbaa !21
  %29 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !86
  %31 = or i8 %30, 64
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %2, i32 2) #16
  %34 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  %35 = load i8, i8* %34, align 8, !tbaa !22
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %108, label %38

; <label>:38:                                     ; preds = %27
  %39 = ptrtoint %struct.GCObject* %7 to i64
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %41 = load i8, i8* %40, align 1, !tbaa !33
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 15
  %43 = load i8, i8* %42, align 1, !tbaa !39
  store i8 0, i8* %40, align 1, !tbaa !33
  store i8 0, i8* %42, align 1, !tbaa !39
  %44 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %45 = bitcast %union.StackValue** %44 to %struct.TValue**
  %46 = load %struct.TValue*, %struct.TValue** %45, align 8, !tbaa !20
  %47 = bitcast %struct.TValue* %33 to i64*
  %48 = bitcast %struct.TValue* %46 to i64*
  %49 = load i64, i64* %47, align 8
  store i64 %49, i64* %48, align 8
  %50 = load i8, i8* %34, align 8, !tbaa !22
  %51 = getelementptr inbounds %struct.TValue, %struct.TValue* %46, i64 0, i32 1
  store i8 %50, i8* %51, align 8, !tbaa !22
  %52 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1, i32 0
  %54 = bitcast %struct.TValue* %53 to i64*
  store i64 %39, i64* %54, align 8
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1, i32 0, i32 1
  store i8 %31, i8* %55, align 8, !tbaa !22
  %56 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 2
  store %union.StackValue* %57, %union.StackValue** %44, align 8, !tbaa !20
  %58 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %59 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !24
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 7
  %61 = load i16, i16* %60, align 2, !tbaa !63
  %62 = or i16 %61, 64
  store i16 %62, i16* %60, align 2, !tbaa !63
  %63 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %64 = bitcast %union.StackValue** %63 to i64*
  %65 = load i64, i64* %64, align 8, !tbaa !23
  %66 = ptrtoint %union.StackValue* %56 to i64
  %67 = sub i64 %66, %65
  %68 = tail call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @dothecall, i8* null, i64 %67, i64 0) #16
  %69 = load %struct.CallInfo*, %struct.CallInfo** %58, align 8, !tbaa !24
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %69, i64 0, i32 7
  %71 = load i16, i16* %70, align 2, !tbaa !63
  %72 = and i16 %71, -65
  store i16 %72, i16* %70, align 2, !tbaa !63
  store i8 %41, i8* %40, align 1, !tbaa !33
  store i8 %43, i8* %42, align 1, !tbaa !39
  %73 = icmp eq i32 %68, 0
  br i1 %73, label %108, label %74

; <label>:74:                                     ; preds = %38
  %75 = load %union.StackValue*, %union.StackValue** %44, align 8, !tbaa !20
  %76 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 -1, i32 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !21
  %78 = and i8 %77, 15
  %79 = icmp eq i8 %78, 4
  br i1 %79, label %80, label %85

; <label>:80:                                     ; preds = %74
  %81 = getelementptr inbounds %union.StackValue, %union.StackValue* %75, i64 -1, i32 0, i32 0, i32 0
  %82 = bitcast %struct.GCObject** %81 to i8**
  %83 = load i8*, i8** %82, align 8, !tbaa !21
  %84 = getelementptr inbounds i8, i8* %83, i64 24
  br label %85

; <label>:85:                                     ; preds = %74, %80
  %86 = phi i8* [ %84, %80 ], [ getelementptr inbounds ([29 x i8], [29 x i8]* @.str.139, i64 0, i64 0), %74 ]
  %87 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %88 = getelementptr inbounds %struct.global_State, %struct.global_State* %87, i64 0, i32 43
  %89 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %88, align 8, !tbaa !192
  %90 = icmp eq void (i8*, i8*, i32)* %89, null
  br i1 %90, label %108, label %91

; <label>:91:                                     ; preds = %85
  %92 = getelementptr inbounds %struct.global_State, %struct.global_State* %87, i64 0, i32 44
  %93 = load i8*, i8** %92, align 8, !tbaa !191
  tail call void %89(i8* %93, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.140, i64 0, i64 0), i32 1) #17
  %94 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %95 = getelementptr inbounds %struct.global_State, %struct.global_State* %94, i64 0, i32 43
  %96 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %95, align 8, !tbaa !192
  %97 = icmp eq void (i8*, i8*, i32)* %96, null
  br i1 %97, label %108, label %98

; <label>:98:                                     ; preds = %91
  %99 = getelementptr inbounds %struct.global_State, %struct.global_State* %94, i64 0, i32 44
  %100 = load i8*, i8** %99, align 8, !tbaa !191
  tail call void %96(i8* %100, i8* %86, i32 1) #17
  %101 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %102 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 43
  %103 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %102, align 8, !tbaa !192
  %104 = icmp eq void (i8*, i8*, i32)* %103, null
  br i1 %104, label %108, label %105

; <label>:105:                                    ; preds = %98
  %106 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 44
  %107 = load i8*, i8** %106, align 8, !tbaa !191
  tail call void %103(i8* %107, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.141, i64 0, i64 0), i32 0) #17
  br label %108

; <label>:108:                                    ; preds = %85, %91, %105, %98, %38, %27
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %5) #7
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* nocapture readonly, %struct.TValue* nocapture readonly, i32) unnamed_addr #3 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = trunc i8 %5 to i4
  switch i4 %6, label %15 [
    i4 5, label %7
    i4 7, label %11
  ]

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %1 to %struct.Table**
  %9 = load %struct.Table*, %struct.Table** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %9, i64 0, i32 9
  br label %21

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %1 to %struct.Udata**
  %13 = load %struct.Udata*, %struct.Udata** %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.Udata, %struct.Udata* %13, i64 0, i32 5
  br label %21

; <label>:15:                                     ; preds = %3
  %16 = and i8 %5, 15
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = zext i8 %16 to i64
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 41, i64 %19
  br label %21

; <label>:21:                                     ; preds = %15, %11, %7
  %22 = phi %struct.Table** [ %20, %15 ], [ %14, %11 ], [ %10, %7 ]
  %23 = load %struct.Table*, %struct.Table** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.Table* %23, null
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  br i1 %24, label %32, label %27

; <label>:27:                                     ; preds = %21
  %28 = zext i32 %2 to i64
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 40, i64 %28
  %30 = load %struct.TString*, %struct.TString** %29, align 8, !tbaa !54
  %31 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %23, %struct.TString* %30) #16
  br label %34

; <label>:32:                                     ; preds = %21
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %34

; <label>:34:                                     ; preds = %32, %27
  %35 = phi %struct.TValue* [ %31, %27 ], [ %33, %32 ]
  ret %struct.TValue* %35
}

; Function Attrs: nounwind optsize uwtable
define internal void @dothecall(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0) #16
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nocapture readonly, %struct.TString* readonly) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !156
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !150
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %8 = load i8, i8* %7, align 1, !tbaa !93
  %9 = zext i8 %8 to i32
  %10 = shl i32 1, %9
  %11 = add nsw i32 %10, -1
  %12 = and i32 %11, %6
  br label %13

; <label>:13:                                     ; preds = %28, %2
  %14 = phi i32 [ %12, %2 ], [ %30, %28 ]
  %15 = phi %union.Node* [ %4, %2 ], [ %17, %28 ]
  %16 = sext i32 %14 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16
  %18 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = icmp eq i8 %19, 84
  br i1 %20, label %21, label %28

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 4, i32 0
  %23 = bitcast %struct.GCObject** %22 to %struct.TString**
  %24 = load %struct.TString*, %struct.TString** %23, align 8, !tbaa !21
  %25 = icmp eq %struct.TString* %24, %1
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %21
  %27 = bitcast %union.Node* %17 to %struct.TValue*
  br label %32

; <label>:28:                                     ; preds = %21, %13
  %29 = getelementptr inbounds %union.Node, %union.Node* %15, i64 %16, i32 0, i32 3
  %30 = load i32, i32* %29, align 4, !tbaa !21
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %32, label %13

; <label>:32:                                     ; preds = %28, %26
  %33 = phi %struct.TValue* [ %27, %26 ], [ @absentkey, %28 ]
  ret %struct.TValue* %33
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @freeobj(%struct.lua_State* nocapture readonly, %struct.GCObject*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !86
  switch i8 %4, label %335 [
    i8 10, label %5
    i8 9, label %133
    i8 25, label %133
    i8 22, label %166
    i8 54, label %184
    i8 5, label %202
    i8 8, label %230
    i8 7, label %247
    i8 20, label %271
    i8 36, label %319
  ]

; <label>:5:                                      ; preds = %2
  %6 = bitcast %struct.GCObject* %1 to %struct.Proto*
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 4
  %8 = bitcast %struct.GCObject* %7 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !116
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1, i32 1
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !220
  %13 = sext i32 %12 to i64
  %14 = shl nsw i64 %13, 2
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 0
  %18 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %17, align 8, !tbaa !59
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 1
  %20 = load i8*, i8** %19, align 8, !tbaa !60
  %21 = tail call i8* %18(i8* %20, i8* %9, i64 %14, i64 0) #17
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = sub i64 %23, %14
  store i64 %24, i64* %22, align 8, !tbaa !11
  %25 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 4, i32 1
  %26 = bitcast i8* %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !221
  %28 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 2
  %29 = bitcast %struct.GCObject* %28 to i32*
  %30 = load i32, i32* %29, align 8, !tbaa !222
  %31 = sext i32 %30 to i64
  %32 = shl nsw i64 %31, 3
  %33 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 0
  %35 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %34, align 8, !tbaa !59
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 1
  %37 = load i8*, i8** %36, align 8, !tbaa !60
  %38 = tail call i8* %35(i8* %37, i8* %27, i64 %32, i64 0) #17
  %39 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 3
  %40 = load i64, i64* %39, align 8, !tbaa !11
  %41 = sub i64 %40, %32
  store i64 %41, i64* %39, align 8, !tbaa !11
  %42 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 3, i32 1
  %43 = bitcast i8* %42 to i8**
  %44 = load i8*, i8** %43, align 8, !tbaa !223
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 7
  %46 = load i32, i32* %45, align 4, !tbaa !224
  %47 = sext i32 %46 to i64
  %48 = shl nsw i64 %47, 4
  %49 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %50 = getelementptr inbounds %struct.global_State, %struct.global_State* %49, i64 0, i32 0
  %51 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %50, align 8, !tbaa !59
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %49, i64 0, i32 1
  %53 = load i8*, i8** %52, align 8, !tbaa !60
  %54 = tail call i8* %51(i8* %53, i8* %44, i64 %48, i64 0) #17
  %55 = getelementptr inbounds %struct.global_State, %struct.global_State* %49, i64 0, i32 3
  %56 = load i64, i64* %55, align 8, !tbaa !11
  %57 = sub i64 %56, %48
  store i64 %57, i64* %55, align 8, !tbaa !11
  %58 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 5, i32 1
  %59 = bitcast i8* %58 to i8**
  %60 = load i8*, i8** %59, align 8, !tbaa !137
  %61 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 9
  %62 = load i32, i32* %61, align 4, !tbaa !136
  %63 = sext i32 %62 to i64
  %64 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %65 = getelementptr inbounds %struct.global_State, %struct.global_State* %64, i64 0, i32 0
  %66 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %65, align 8, !tbaa !59
  %67 = getelementptr inbounds %struct.global_State, %struct.global_State* %64, i64 0, i32 1
  %68 = load i8*, i8** %67, align 8, !tbaa !60
  %69 = tail call i8* %66(i8* %68, i8* %60, i64 %63, i64 0) #17
  %70 = getelementptr inbounds %struct.global_State, %struct.global_State* %64, i64 0, i32 3
  %71 = load i64, i64* %70, align 8, !tbaa !11
  %72 = sub i64 %71, %63
  store i64 %72, i64* %70, align 8, !tbaa !11
  %73 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 6
  %74 = bitcast %struct.GCObject* %73 to i8**
  %75 = load i8*, i8** %74, align 8, !tbaa !225
  %76 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 2, i32 1
  %77 = bitcast i8* %76 to i32*
  %78 = load i32, i32* %77, align 8, !tbaa !226
  %79 = sext i32 %78 to i64
  %80 = shl nsw i64 %79, 3
  %81 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %82 = getelementptr inbounds %struct.global_State, %struct.global_State* %81, i64 0, i32 0
  %83 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %82, align 8, !tbaa !59
  %84 = getelementptr inbounds %struct.global_State, %struct.global_State* %81, i64 0, i32 1
  %85 = load i8*, i8** %84, align 8, !tbaa !60
  %86 = tail call i8* %83(i8* %85, i8* %75, i64 %80, i64 0) #17
  %87 = getelementptr inbounds %struct.global_State, %struct.global_State* %81, i64 0, i32 3
  %88 = load i64, i64* %87, align 8, !tbaa !11
  %89 = sub i64 %88, %80
  store i64 %89, i64* %87, align 8, !tbaa !11
  %90 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 6, i32 1
  %91 = bitcast i8* %90 to i8**
  %92 = load i8*, i8** %91, align 8, !tbaa !110
  %93 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 11
  %94 = load i32, i32* %93, align 4, !tbaa !108
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %98 = getelementptr inbounds %struct.global_State, %struct.global_State* %97, i64 0, i32 0
  %99 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %98, align 8, !tbaa !59
  %100 = getelementptr inbounds %struct.global_State, %struct.global_State* %97, i64 0, i32 1
  %101 = load i8*, i8** %100, align 8, !tbaa !60
  %102 = tail call i8* %99(i8* %101, i8* %92, i64 %96, i64 0) #17
  %103 = getelementptr inbounds %struct.global_State, %struct.global_State* %97, i64 0, i32 3
  %104 = load i64, i64* %103, align 8, !tbaa !11
  %105 = sub i64 %104, %96
  store i64 %105, i64* %103, align 8, !tbaa !11
  %106 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 5
  %107 = bitcast %struct.GCObject* %106 to i8**
  %108 = load i8*, i8** %107, align 8, !tbaa !198
  %109 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %110 = bitcast %struct.GCObject* %109 to i32*
  %111 = load i32, i32* %110, align 8, !tbaa !190
  %112 = sext i32 %111 to i64
  %113 = shl nsw i64 %112, 4
  %114 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %115 = getelementptr inbounds %struct.global_State, %struct.global_State* %114, i64 0, i32 0
  %116 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %115, align 8, !tbaa !59
  %117 = getelementptr inbounds %struct.global_State, %struct.global_State* %114, i64 0, i32 1
  %118 = load i8*, i8** %117, align 8, !tbaa !60
  %119 = tail call i8* %116(i8* %118, i8* %108, i64 %113, i64 0) #17
  %120 = getelementptr inbounds %struct.global_State, %struct.global_State* %114, i64 0, i32 3
  %121 = load i64, i64* %120, align 8, !tbaa !11
  %122 = sub i64 %121, %113
  store i64 %122, i64* %120, align 8, !tbaa !11
  %123 = bitcast %struct.GCObject* %1 to i8*
  %124 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %125 = getelementptr inbounds %struct.global_State, %struct.global_State* %124, i64 0, i32 0
  %126 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %125, align 8, !tbaa !59
  %127 = getelementptr inbounds %struct.global_State, %struct.global_State* %124, i64 0, i32 1
  %128 = load i8*, i8** %127, align 8, !tbaa !60
  %129 = tail call i8* %126(i8* %128, i8* %123, i64 128, i64 0) #17
  %130 = getelementptr inbounds %struct.global_State, %struct.global_State* %124, i64 0, i32 3
  %131 = load i64, i64* %130, align 8, !tbaa !11
  %132 = add i64 %131, -128
  store i64 %132, i64* %130, align 8, !tbaa !11
  br label %335

; <label>:133:                                    ; preds = %2, %2
  %134 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %135 = bitcast %struct.GCObject* %134 to %struct.TValue**
  %136 = load %struct.TValue*, %struct.TValue** %135, align 8, !tbaa !67
  %137 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1, i32 1
  %138 = bitcast i8* %137 to %struct.TValue*
  %139 = icmp eq %struct.TValue* %136, %138
  br i1 %139, label %154, label %140

; <label>:140:                                    ; preds = %133
  %141 = bitcast i8* %137 to %struct.UpVal**
  %142 = bitcast i8* %137 to i64*
  %143 = load i64, i64* %142, align 8, !tbaa !21
  %144 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 2
  %145 = bitcast %struct.GCObject* %144 to i64**
  %146 = load i64*, i64** %145, align 8, !tbaa !21
  store i64 %143, i64* %146, align 8, !tbaa !54
  %147 = load %struct.UpVal*, %struct.UpVal** %141, align 8, !tbaa !21
  %148 = icmp eq %struct.UpVal* %147, null
  br i1 %148, label %154, label %149

; <label>:149:                                    ; preds = %140
  %150 = bitcast %struct.GCObject* %144 to i64*
  %151 = load i64, i64* %150, align 8, !tbaa !21
  %152 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %147, i64 0, i32 4, i32 0, i32 1
  %153 = bitcast %struct.UpVal*** %152 to i64*
  store i64 %151, i64* %153, align 8, !tbaa !21
  br label %154

; <label>:154:                                    ; preds = %133, %140, %149
  %155 = bitcast %struct.GCObject* %1 to i8*
  %156 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %157 = load %struct.global_State*, %struct.global_State** %156, align 8, !tbaa !2
  %158 = getelementptr inbounds %struct.global_State, %struct.global_State* %157, i64 0, i32 0
  %159 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %158, align 8, !tbaa !59
  %160 = getelementptr inbounds %struct.global_State, %struct.global_State* %157, i64 0, i32 1
  %161 = load i8*, i8** %160, align 8, !tbaa !60
  %162 = tail call i8* %159(i8* %161, i8* %155, i64 40, i64 0) #17
  %163 = getelementptr inbounds %struct.global_State, %struct.global_State* %157, i64 0, i32 3
  %164 = load i64, i64* %163, align 8, !tbaa !11
  %165 = add i64 %164, -40
  store i64 %165, i64* %163, align 8, !tbaa !11
  br label %335

; <label>:166:                                    ; preds = %2
  %167 = bitcast %struct.GCObject* %1 to i8*
  %168 = bitcast %struct.GCObject* %1 to %struct.LClosure*
  %169 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %168, i64 0, i32 3
  %170 = load i8, i8* %169, align 2, !tbaa !21
  %171 = zext i8 %170 to i64
  %172 = shl nuw nsw i64 %171, 3
  %173 = add nuw nsw i64 %172, 32
  %174 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %175 = load %struct.global_State*, %struct.global_State** %174, align 8, !tbaa !2
  %176 = getelementptr inbounds %struct.global_State, %struct.global_State* %175, i64 0, i32 0
  %177 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %176, align 8, !tbaa !59
  %178 = getelementptr inbounds %struct.global_State, %struct.global_State* %175, i64 0, i32 1
  %179 = load i8*, i8** %178, align 8, !tbaa !60
  %180 = tail call i8* %177(i8* %179, i8* %167, i64 %173, i64 0) #17
  %181 = getelementptr inbounds %struct.global_State, %struct.global_State* %175, i64 0, i32 3
  %182 = load i64, i64* %181, align 8, !tbaa !11
  %183 = sub i64 %182, %173
  store i64 %183, i64* %181, align 8, !tbaa !11
  br label %335

; <label>:184:                                    ; preds = %2
  %185 = bitcast %struct.GCObject* %1 to i8*
  %186 = bitcast %struct.GCObject* %1 to %struct.CClosure*
  %187 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %186, i64 0, i32 3
  %188 = load i8, i8* %187, align 2, !tbaa !21
  %189 = zext i8 %188 to i64
  %190 = shl nuw nsw i64 %189, 4
  %191 = add nuw nsw i64 %190, 32
  %192 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %193 = load %struct.global_State*, %struct.global_State** %192, align 8, !tbaa !2
  %194 = getelementptr inbounds %struct.global_State, %struct.global_State* %193, i64 0, i32 0
  %195 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %194, align 8, !tbaa !59
  %196 = getelementptr inbounds %struct.global_State, %struct.global_State* %193, i64 0, i32 1
  %197 = load i8*, i8** %196, align 8, !tbaa !60
  %198 = tail call i8* %195(i8* %197, i8* %185, i64 %191, i64 0) #17
  %199 = getelementptr inbounds %struct.global_State, %struct.global_State* %193, i64 0, i32 3
  %200 = load i64, i64* %199, align 8, !tbaa !11
  %201 = sub i64 %200, %191
  store i64 %201, i64* %199, align 8, !tbaa !11
  br label %335

; <label>:202:                                    ; preds = %2
  %203 = bitcast %struct.GCObject* %1 to %struct.Table*
  tail call fastcc void @freehash(%struct.lua_State* %0, %struct.Table* %203) #17
  %204 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %205 = bitcast %struct.GCObject* %204 to i8**
  %206 = load i8*, i8** %205, align 8, !tbaa !91
  %207 = tail call fastcc i32 @luaH_realasize(%struct.Table* %203) #17
  %208 = zext i32 %207 to i64
  %209 = shl nuw nsw i64 %208, 4
  %210 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %211 = load %struct.global_State*, %struct.global_State** %210, align 8, !tbaa !2
  %212 = getelementptr inbounds %struct.global_State, %struct.global_State* %211, i64 0, i32 0
  %213 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %212, align 8, !tbaa !59
  %214 = getelementptr inbounds %struct.global_State, %struct.global_State* %211, i64 0, i32 1
  %215 = load i8*, i8** %214, align 8, !tbaa !60
  %216 = tail call i8* %213(i8* %215, i8* %206, i64 %209, i64 0) #17
  %217 = getelementptr inbounds %struct.global_State, %struct.global_State* %211, i64 0, i32 3
  %218 = load i64, i64* %217, align 8, !tbaa !11
  %219 = sub i64 %218, %209
  store i64 %219, i64* %217, align 8, !tbaa !11
  %220 = bitcast %struct.GCObject* %1 to i8*
  %221 = load %struct.global_State*, %struct.global_State** %210, align 8, !tbaa !2
  %222 = getelementptr inbounds %struct.global_State, %struct.global_State* %221, i64 0, i32 0
  %223 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %222, align 8, !tbaa !59
  %224 = getelementptr inbounds %struct.global_State, %struct.global_State* %221, i64 0, i32 1
  %225 = load i8*, i8** %224, align 8, !tbaa !60
  %226 = tail call i8* %223(i8* %225, i8* %220, i64 56, i64 0) #17
  %227 = getelementptr inbounds %struct.global_State, %struct.global_State* %221, i64 0, i32 3
  %228 = load i64, i64* %227, align 8, !tbaa !11
  %229 = add i64 %228, -56
  store i64 %229, i64* %227, align 8, !tbaa !11
  br label %335

; <label>:230:                                    ; preds = %2
  %231 = bitcast %struct.GCObject* %1 to %struct.lua_State*
  %232 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 -1, i32 1
  %233 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 3, i32 1
  %234 = bitcast i8* %233 to %union.StackValue**
  %235 = load %union.StackValue*, %union.StackValue** %234, align 8, !tbaa !23
  %236 = tail call fastcc i32 @luaF_close(%struct.lua_State* %231, %union.StackValue* %235, i32 -1) #17
  tail call fastcc void @freestack(%struct.lua_State* %231) #17
  %237 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %238 = load %struct.global_State*, %struct.global_State** %237, align 8, !tbaa !2
  %239 = getelementptr inbounds %struct.global_State, %struct.global_State* %238, i64 0, i32 0
  %240 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %239, align 8, !tbaa !59
  %241 = getelementptr inbounds %struct.global_State, %struct.global_State* %238, i64 0, i32 1
  %242 = load i8*, i8** %241, align 8, !tbaa !60
  %243 = tail call i8* %240(i8* %242, i8* nonnull %232, i64 208, i64 0) #17
  %244 = getelementptr inbounds %struct.global_State, %struct.global_State* %238, i64 0, i32 3
  %245 = load i64, i64* %244, align 8, !tbaa !11
  %246 = add i64 %245, -208
  store i64 %246, i64* %244, align 8, !tbaa !11
  br label %335

; <label>:247:                                    ; preds = %2
  %248 = bitcast %struct.GCObject* %1 to %struct.Udata*
  %249 = bitcast %struct.GCObject* %1 to i8*
  %250 = getelementptr inbounds %struct.Udata, %struct.Udata* %248, i64 0, i32 3
  %251 = load i16, i16* %250, align 2, !tbaa !195
  %252 = icmp eq i16 %251, 0
  %253 = zext i16 %251 to i64
  %254 = shl nuw nsw i64 %253, 4
  %255 = add nuw nsw i64 %254, 40
  %256 = select i1 %252, i64 32, i64 %255
  %257 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %258 = bitcast %struct.GCObject* %257 to i64*
  %259 = load i64, i64* %258, align 8, !tbaa !193
  %260 = add i64 %256, %259
  %261 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %262 = load %struct.global_State*, %struct.global_State** %261, align 8, !tbaa !2
  %263 = getelementptr inbounds %struct.global_State, %struct.global_State* %262, i64 0, i32 0
  %264 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %263, align 8, !tbaa !59
  %265 = getelementptr inbounds %struct.global_State, %struct.global_State* %262, i64 0, i32 1
  %266 = load i8*, i8** %265, align 8, !tbaa !60
  %267 = tail call i8* %264(i8* %266, i8* %249, i64 %260, i64 0) #17
  %268 = getelementptr inbounds %struct.global_State, %struct.global_State* %262, i64 0, i32 3
  %269 = load i64, i64* %268, align 8, !tbaa !11
  %270 = sub i64 %269, %260
  store i64 %270, i64* %268, align 8, !tbaa !11
  br label %335

; <label>:271:                                    ; preds = %2
  %272 = bitcast %struct.GCObject* %1 to %struct.TString*
  %273 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %274 = load %struct.global_State*, %struct.global_State** %273, align 8, !tbaa !2
  %275 = getelementptr inbounds %struct.global_State, %struct.global_State* %274, i64 0, i32 6, i32 0
  %276 = load %struct.TString**, %struct.TString*** %275, align 8, !tbaa !94
  %277 = getelementptr inbounds %struct.TString, %struct.TString* %272, i64 0, i32 5
  %278 = load i32, i32* %277, align 4, !tbaa !150
  %279 = getelementptr inbounds %struct.global_State, %struct.global_State* %274, i64 0, i32 6, i32 2
  %280 = load i32, i32* %279, align 4, !tbaa !95
  %281 = add nsw i32 %280, -1
  %282 = and i32 %281, %278
  %283 = sext i32 %282 to i64
  %284 = getelementptr inbounds %struct.TString*, %struct.TString** %276, i64 %283
  %285 = load %struct.TString*, %struct.TString** %284, align 8, !tbaa !54
  %286 = icmp eq %struct.TString* %285, %272
  br i1 %286, label %296, label %287

; <label>:287:                                    ; preds = %271
  br label %288

; <label>:288:                                    ; preds = %287, %288
  %289 = phi %struct.TString* [ %292, %288 ], [ %285, %287 ]
  %290 = getelementptr inbounds %struct.TString, %struct.TString* %289, i64 0, i32 6
  %291 = bitcast %union.anon* %290 to %struct.TString**
  %292 = load %struct.TString*, %struct.TString** %291, align 8, !tbaa !54
  %293 = icmp eq %struct.TString* %292, %272
  br i1 %293, label %294, label %288

; <label>:294:                                    ; preds = %288
  %295 = bitcast %union.anon* %290 to %struct.TString**
  br label %296

; <label>:296:                                    ; preds = %294, %271
  %297 = phi %struct.TString** [ %284, %271 ], [ %295, %294 ]
  %298 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %299 = bitcast %struct.GCObject* %298 to i64*
  %300 = load i64, i64* %299, align 8, !tbaa !21
  %301 = bitcast %struct.TString** %297 to i64*
  store i64 %300, i64* %301, align 8, !tbaa !54
  %302 = getelementptr inbounds %struct.global_State, %struct.global_State* %274, i64 0, i32 6, i32 1
  %303 = load i32, i32* %302, align 8, !tbaa !149
  %304 = add nsw i32 %303, -1
  store i32 %304, i32* %302, align 8, !tbaa !149
  %305 = bitcast %struct.GCObject* %1 to i8*
  %306 = getelementptr inbounds %struct.TString, %struct.TString* %272, i64 0, i32 4
  %307 = load i8, i8* %306, align 1, !tbaa !21
  %308 = zext i8 %307 to i64
  %309 = add nuw nsw i64 %308, 25
  %310 = load %struct.global_State*, %struct.global_State** %273, align 8, !tbaa !2
  %311 = getelementptr inbounds %struct.global_State, %struct.global_State* %310, i64 0, i32 0
  %312 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %311, align 8, !tbaa !59
  %313 = getelementptr inbounds %struct.global_State, %struct.global_State* %310, i64 0, i32 1
  %314 = load i8*, i8** %313, align 8, !tbaa !60
  %315 = tail call i8* %312(i8* %314, i8* %305, i64 %309, i64 0) #17
  %316 = getelementptr inbounds %struct.global_State, %struct.global_State* %310, i64 0, i32 3
  %317 = load i64, i64* %316, align 8, !tbaa !11
  %318 = sub i64 %317, %309
  store i64 %318, i64* %316, align 8, !tbaa !11
  br label %335

; <label>:319:                                    ; preds = %2
  %320 = bitcast %struct.GCObject* %1 to i8*
  %321 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 1
  %322 = bitcast %struct.GCObject* %321 to i64*
  %323 = load i64, i64* %322, align 8, !tbaa !21
  %324 = add i64 %323, 25
  %325 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %326 = load %struct.global_State*, %struct.global_State** %325, align 8, !tbaa !2
  %327 = getelementptr inbounds %struct.global_State, %struct.global_State* %326, i64 0, i32 0
  %328 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %327, align 8, !tbaa !59
  %329 = getelementptr inbounds %struct.global_State, %struct.global_State* %326, i64 0, i32 1
  %330 = load i8*, i8** %329, align 8, !tbaa !60
  %331 = tail call i8* %328(i8* %330, i8* %320, i64 %324, i64 0) #17
  %332 = getelementptr inbounds %struct.global_State, %struct.global_State* %326, i64 0, i32 3
  %333 = load i64, i64* %332, align 8, !tbaa !11
  %334 = sub i64 %333, %324
  store i64 %334, i64* %332, align 8, !tbaa !11
  br label %335

; <label>:335:                                    ; preds = %2, %319, %296, %247, %230, %202, %184, %166, %154, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @freehash(%struct.lua_State* nocapture readonly, %struct.Table* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !147
  %5 = icmp eq %union.Node* %4, null
  br i1 %5, label %26, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %8 = bitcast %union.Node** %7 to i8**
  %9 = load i8*, i8** %8, align 8, !tbaa !156
  %10 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !93
  %12 = zext i8 %11 to i32
  %13 = shl i32 1, %12
  %14 = sext i32 %13 to i64
  %15 = mul nsw i64 %14, 24
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %17 = load %struct.global_State*, %struct.global_State** %16, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 0
  %19 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %18, align 8, !tbaa !59
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 1
  %21 = load i8*, i8** %20, align 8, !tbaa !60
  %22 = tail call i8* %19(i8* %21, i8* %9, i64 %15, i64 0) #17
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 3
  %24 = load i64, i64* %23, align 8, !tbaa !11
  %25 = sub i64 %24, %15
  store i64 %25, i64* %23, align 8, !tbaa !11
  br label %26

; <label>:26:                                     ; preds = %6, %2
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @luaH_realasize(%struct.Table* nocapture readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 2
  %3 = load i8, i8* %2, align 1, !tbaa !146
  %4 = icmp slt i8 %3, 0
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 5
  %6 = load i32, i32* %5, align 4, !tbaa !92
  br i1 %4, label %7, label %23

; <label>:7:                                      ; preds = %1
  %8 = add i32 %6, -1
  %9 = and i32 %8, %6
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %23, label %11

; <label>:11:                                     ; preds = %7
  %12 = lshr i32 %6, 1
  %13 = or i32 %12, %6
  %14 = lshr i32 %13, 2
  %15 = or i32 %14, %13
  %16 = lshr i32 %15, 4
  %17 = or i32 %16, %15
  %18 = lshr i32 %17, 8
  %19 = or i32 %18, %17
  %20 = lshr i32 %19, 16
  %21 = or i32 %20, %19
  %22 = add i32 %21, 1
  br label %23

; <label>:23:                                     ; preds = %1, %7, %11
  %24 = phi i32 [ %22, %11 ], [ %6, %7 ], [ %6, %1 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaE_freeCI(%struct.lua_State* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 3
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !117
  store %struct.CallInfo* null, %struct.CallInfo** %4, align 8, !tbaa !117
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %7 = load i16, i16* %6, align 4, !tbaa !25
  %8 = zext i16 %7 to i32
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %10 = load i32, i32* %9, align 8, !tbaa !29
  %11 = sub i32 %10, %8
  store i32 %11, i32* %9, align 8, !tbaa !29
  %12 = icmp eq %struct.CallInfo* %5, null
  br i1 %12, label %35, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %15

; <label>:15:                                     ; preds = %13, %15
  %16 = phi %struct.CallInfo* [ %5, %13 ], [ %19, %15 ]
  %17 = bitcast %struct.CallInfo* %16 to i8*
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 3
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !117
  %20 = load %struct.global_State*, %struct.global_State** %14, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 0
  %22 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %21, align 8, !tbaa !59
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 1
  %24 = load i8*, i8** %23, align 8, !tbaa !60
  %25 = tail call i8* %22(i8* %24, i8* %17, i64 64, i64 0) #17
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 3
  %27 = load i64, i64* %26, align 8, !tbaa !11
  %28 = add i64 %27, -64
  store i64 %28, i64* %26, align 8, !tbaa !11
  %29 = load i16, i16* %6, align 4, !tbaa !25
  %30 = add i16 %29, -1
  store i16 %30, i16* %6, align 4, !tbaa !25
  %31 = icmp eq %struct.CallInfo* %19, null
  br i1 %31, label %32, label %15

; <label>:32:                                     ; preds = %15
  %33 = load i32, i32* %9, align 8, !tbaa !29
  %34 = zext i16 %30 to i32
  br label %35

; <label>:35:                                     ; preds = %32, %1
  %36 = phi i32 [ %34, %32 ], [ %8, %1 ]
  %37 = phi i32 [ %33, %32 ], [ %11, %1 ]
  %38 = add i32 %37, %36
  store i32 %38, i32* %9, align 8, !tbaa !29
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @enterinc(%struct.global_State* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 20
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !18
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 10
  %5 = load i8, i8* %4, align 4, !tbaa !15
  %6 = and i8 %5, 24
  %7 = icmp eq %struct.GCObject* %3, null
  br i1 %7, label %18, label %8

; <label>:8:                                      ; preds = %1
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = phi %struct.GCObject* [ %16, %9 ], [ %3, %8 ]
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %10, i64 0, i32 2
  %12 = load i8, i8* %11, align 1, !tbaa !70
  %13 = and i8 %12, -64
  %14 = or i8 %13, %6
  store i8 %14, i8* %11, align 1, !tbaa !70
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %10, i64 0, i32 0
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !87
  %17 = icmp eq %struct.GCObject* %16, null
  br i1 %17, label %18, label %9

; <label>:18:                                     ; preds = %9, %1
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 30
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 22
  %21 = bitcast %struct.GCObject** %19 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %21, i8 0, i64 24, i32 8, i1 false)
  %22 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !51
  %23 = icmp eq %struct.GCObject* %22, null
  br i1 %23, label %34, label %24

; <label>:24:                                     ; preds = %18
  br label %25

; <label>:25:                                     ; preds = %24, %25
  %26 = phi %struct.GCObject* [ %32, %25 ], [ %22, %24 ]
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !70
  %29 = and i8 %28, -64
  %30 = or i8 %29, %6
  store i8 %30, i8* %27, align 1, !tbaa !70
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 0
  %32 = load %struct.GCObject*, %struct.GCObject** %31, align 8, !tbaa !87
  %33 = icmp eq %struct.GCObject* %32, null
  br i1 %33, label %34, label %25

; <label>:34:                                     ; preds = %25, %18
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %36 = load %struct.GCObject*, %struct.GCObject** %35, align 8, !tbaa !101
  %37 = icmp eq %struct.GCObject* %36, null
  br i1 %37, label %48, label %38

; <label>:38:                                     ; preds = %34
  br label %39

; <label>:39:                                     ; preds = %38, %39
  %40 = phi %struct.GCObject* [ %46, %39 ], [ %36, %38 ]
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %40, i64 0, i32 2
  %42 = load i8, i8* %41, align 1, !tbaa !70
  %43 = and i8 %42, -64
  %44 = or i8 %43, %6
  store i8 %44, i8* %41, align 1, !tbaa !70
  %45 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %40, i64 0, i32 0
  %46 = load %struct.GCObject*, %struct.GCObject** %45, align 8, !tbaa !87
  %47 = icmp eq %struct.GCObject* %46, null
  br i1 %47, label %48, label %39

; <label>:48:                                     ; preds = %39, %34
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 33
  %50 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %51 = bitcast %struct.GCObject** %49 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %51, i8 0, i64 24, i32 8, i1 false)
  store i8 8, i8* %50, align 1, !tbaa !42
  %52 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  store i8 0, i8* %52, align 2, !tbaa !40
  %53 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 5
  store i64 0, i64* %53, align 8, !tbaa !41
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @atomic(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 24
  %5 = bitcast %struct.GCObject** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !157
  store %struct.GCObject* null, %struct.GCObject** %4, align 8, !tbaa !157
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  store i8 2, i8* %7, align 1, !tbaa !42
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !16
  %10 = and i8 %9, 24
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %1
  %13 = bitcast %struct.lua_State* %0 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %3, %struct.GCObject* %13) #16
  br label %14

; <label>:14:                                     ; preds = %1, %12
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !79
  %17 = and i8 %16, 64
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %27, label %19

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 0, i32 0
  %21 = load %struct.GCObject*, %struct.GCObject** %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %21, i64 0, i32 2
  %23 = load i8, i8* %22, align 1, !tbaa !70
  %24 = and i8 %23, 24
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %27, label %26

; <label>:26:                                     ; preds = %19
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %21) #16
  br label %27

; <label>:27:                                     ; preds = %19, %14, %26
  tail call fastcc void @markmt(%struct.global_State* nonnull %3) #16
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %29 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %30 = icmp eq %struct.GCObject* %29, null
  br i1 %30, label %38, label %31

; <label>:31:                                     ; preds = %27
  br label %32

; <label>:32:                                     ; preds = %31, %32
  %33 = phi i64 [ %35, %32 ], [ 0, %31 ]
  %34 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #17
  %35 = add i64 %34, %33
  %36 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %37 = icmp eq %struct.GCObject* %36, null
  br i1 %37, label %38, label %32

; <label>:38:                                     ; preds = %32, %27
  %39 = phi i64 [ 0, %27 ], [ %35, %32 ]
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 36
  %41 = load %struct.lua_State*, %struct.lua_State** %40, align 8, !tbaa !54
  %42 = icmp eq %struct.lua_State* %41, null
  br i1 %42, label %111, label %43

; <label>:43:                                     ; preds = %38
  br label %44

; <label>:44:                                     ; preds = %43, %94
  %45 = phi %struct.lua_State* [ %97, %94 ], [ %41, %43 ]
  %46 = phi i32 [ %96, %94 ], [ 0, %43 ]
  %47 = phi %struct.lua_State** [ %95, %94 ], [ %40, %43 ]
  %48 = add nsw i32 %46, 1
  %49 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %45, i64 0, i32 2
  %50 = load i8, i8* %49, align 1, !tbaa !16
  %51 = and i8 %50, 56
  %52 = icmp eq i8 %51, 0
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %45, i64 0, i32 12
  br i1 %52, label %54, label %59

; <label>:54:                                     ; preds = %44
  %55 = load %struct.UpVal*, %struct.UpVal** %53, align 8, !tbaa !34
  %56 = icmp eq %struct.UpVal* %55, null
  br i1 %56, label %59, label %57

; <label>:57:                                     ; preds = %54
  %58 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %45, i64 0, i32 14
  br label %94

; <label>:59:                                     ; preds = %54, %44
  %60 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %45, i64 0, i32 14
  %61 = bitcast %struct.lua_State** %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !27
  %63 = bitcast %struct.lua_State** %47 to i64*
  store i64 %62, i64* %63, align 8, !tbaa !54
  store %struct.lua_State* %45, %struct.lua_State** %60, align 8, !tbaa !27
  %64 = load %struct.UpVal*, %struct.UpVal** %53, align 8, !tbaa !21
  %65 = icmp eq %struct.UpVal* %64, null
  br i1 %65, label %94, label %66

; <label>:66:                                     ; preds = %59
  br label %67

; <label>:67:                                     ; preds = %66, %90
  %68 = phi %struct.UpVal* [ %92, %90 ], [ %64, %66 ]
  %69 = phi i32 [ %70, %90 ], [ %48, %66 ]
  %70 = add nsw i32 %69, 1
  %71 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %68, i64 0, i32 2
  %72 = load i8, i8* %71, align 1, !tbaa !69
  %73 = and i8 %72, 24
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %75, label %90

; <label>:75:                                     ; preds = %67
  %76 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %68, i64 0, i32 3
  %77 = load %struct.TValue*, %struct.TValue** %76, align 8, !tbaa !67
  %78 = getelementptr inbounds %struct.TValue, %struct.TValue* %77, i64 0, i32 1
  %79 = load i8, i8* %78, align 8, !tbaa !22
  %80 = and i8 %79, 64
  %81 = icmp eq i8 %80, 0
  br i1 %81, label %90, label %82

; <label>:82:                                     ; preds = %75
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %77, i64 0, i32 0, i32 0
  %84 = load %struct.GCObject*, %struct.GCObject** %83, align 8, !tbaa !21
  %85 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %84, i64 0, i32 2
  %86 = load i8, i8* %85, align 1, !tbaa !70
  %87 = and i8 %86, 24
  %88 = icmp eq i8 %87, 0
  br i1 %88, label %90, label %89

; <label>:89:                                     ; preds = %82
  tail call fastcc void @reallymarkobject(%struct.global_State* %3, %struct.GCObject* %84) #17
  br label %90

; <label>:90:                                     ; preds = %89, %82, %75, %67
  %91 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %68, i64 0, i32 4, i32 0, i32 0
  %92 = load %struct.UpVal*, %struct.UpVal** %91, align 8, !tbaa !21
  %93 = icmp eq %struct.UpVal* %92, null
  br i1 %93, label %94, label %67

; <label>:94:                                     ; preds = %90, %59, %57
  %95 = phi %struct.lua_State** [ %58, %57 ], [ %47, %59 ], [ %47, %90 ]
  %96 = phi i32 [ %48, %57 ], [ %48, %59 ], [ %70, %90 ]
  %97 = load %struct.lua_State*, %struct.lua_State** %95, align 8, !tbaa !54
  %98 = icmp eq %struct.lua_State* %97, null
  br i1 %98, label %99, label %44

; <label>:99:                                     ; preds = %94
  %100 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %101 = icmp eq %struct.GCObject* %100, null
  %102 = sext i32 %96 to i64
  %103 = add i64 %39, %102
  br i1 %101, label %111, label %104

; <label>:104:                                    ; preds = %99
  br label %105

; <label>:105:                                    ; preds = %104, %105
  %106 = phi i64 [ %108, %105 ], [ 0, %104 ]
  %107 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #17
  %108 = add i64 %107, %106
  %109 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %110 = icmp eq %struct.GCObject* %109, null
  br i1 %110, label %111, label %105

; <label>:111:                                    ; preds = %105, %38, %99
  %112 = phi i64 [ %103, %99 ], [ %39, %38 ], [ %103, %105 ]
  %113 = phi i64 [ 0, %99 ], [ 0, %38 ], [ %108, %105 ]
  %114 = add i64 %112, %113
  %115 = bitcast %struct.GCObject** %28 to i64*
  store i64 %6, i64* %115, align 8, !tbaa !227
  %116 = icmp eq i64 %6, 0
  br i1 %116, label %124, label %117

; <label>:117:                                    ; preds = %111
  br label %118

; <label>:118:                                    ; preds = %117, %118
  %119 = phi i64 [ %121, %118 ], [ 0, %117 ]
  %120 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #17
  %121 = add i64 %120, %119
  %122 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %123 = icmp eq %struct.GCObject* %122, null
  br i1 %123, label %124, label %118

; <label>:124:                                    ; preds = %118, %111
  %125 = phi i64 [ 0, %111 ], [ %121, %118 ]
  %126 = add i64 %114, %125
  tail call fastcc void @convergeephemerons(%struct.global_State* nonnull %3) #16
  %127 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 25
  %128 = load %struct.GCObject*, %struct.GCObject** %127, align 8, !tbaa !228
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %128, %struct.GCObject* null) #16
  %129 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 27
  %130 = load %struct.GCObject*, %struct.GCObject** %129, align 8, !tbaa !229
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %130, %struct.GCObject* null) #16
  %131 = load %struct.GCObject*, %struct.GCObject** %127, align 8, !tbaa !228
  %132 = load %struct.GCObject*, %struct.GCObject** %129, align 8, !tbaa !229
  tail call fastcc void @separatetobefnz(%struct.global_State* nonnull %3, i32 0) #16
  %133 = tail call fastcc i64 @markbeingfnz(%struct.global_State* nonnull %3) #16
  %134 = add i64 %126, %133
  %135 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %136 = icmp eq %struct.GCObject* %135, null
  br i1 %136, label %144, label %137

; <label>:137:                                    ; preds = %124
  br label %138

; <label>:138:                                    ; preds = %137, %138
  %139 = phi i64 [ %141, %138 ], [ 0, %137 ]
  %140 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #17
  %141 = add i64 %140, %139
  %142 = load %struct.GCObject*, %struct.GCObject** %28, align 8, !tbaa !227
  %143 = icmp eq %struct.GCObject* %142, null
  br i1 %143, label %144, label %138

; <label>:144:                                    ; preds = %138, %124
  %145 = phi i64 [ 0, %124 ], [ %141, %138 ]
  tail call fastcc void @convergeephemerons(%struct.global_State* nonnull %3) #16
  %146 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 26
  %147 = load %struct.GCObject*, %struct.GCObject** %146, align 8, !tbaa !230
  tail call fastcc void @clearbykeys(%struct.global_State* nonnull %3, %struct.GCObject* %147) #16
  %148 = load %struct.GCObject*, %struct.GCObject** %129, align 8, !tbaa !229
  tail call fastcc void @clearbykeys(%struct.global_State* nonnull %3, %struct.GCObject* %148) #16
  %149 = load %struct.GCObject*, %struct.GCObject** %127, align 8, !tbaa !228
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %149, %struct.GCObject* %131) #16
  %150 = load %struct.GCObject*, %struct.GCObject** %129, align 8, !tbaa !229
  tail call fastcc void @clearbyvalues(%struct.global_State* nonnull %3, %struct.GCObject* %150, %struct.GCObject* %132) #16
  %151 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 39
  %152 = bitcast %struct.TString** %151 to i64*
  br label %153

; <label>:153:                                    ; preds = %169, %144
  %154 = phi i64 [ 0, %144 ], [ %170, %169 ]
  br label %155

; <label>:155:                                    ; preds = %166, %153
  %156 = phi i64 [ 0, %153 ], [ %167, %166 ]
  %157 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 42, i64 %154, i64 %156
  %158 = load %struct.TString*, %struct.TString** %157, align 8, !tbaa !54
  %159 = getelementptr inbounds %struct.TString, %struct.TString* %158, i64 0, i32 2
  %160 = load i8, i8* %159, align 1, !tbaa !148
  %161 = and i8 %160, 24
  %162 = icmp eq i8 %161, 0
  br i1 %162, label %166, label %163

; <label>:163:                                    ; preds = %155
  %164 = load i64, i64* %152, align 8, !tbaa !74
  %165 = bitcast %struct.TString** %157 to i64*
  store i64 %164, i64* %165, align 8, !tbaa !54
  br label %166

; <label>:166:                                    ; preds = %163, %155
  %167 = add nuw nsw i64 %156, 1
  %168 = icmp eq i64 %167, 2
  br i1 %168, label %169, label %155

; <label>:169:                                    ; preds = %166
  %170 = add nuw nsw i64 %154, 1
  %171 = icmp eq i64 %170, 53
  br i1 %171, label %172, label %153

; <label>:172:                                    ; preds = %169
  %173 = add i64 %134, %145
  %174 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %175 = load i8, i8* %174, align 4, !tbaa !15
  %176 = xor i8 %175, 24
  store i8 %176, i8* %174, align 4, !tbaa !15
  ret i64 %173
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @atomic2gen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 20
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %3) #16
  %4 = bitcast %struct.GCObject** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !18
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 30
  %7 = bitcast %struct.GCObject** %6 to i64*
  store i64 %5, i64* %7, align 8, !tbaa !49
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 31
  %9 = bitcast %struct.GCObject** %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !53
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 32
  %11 = bitcast %struct.GCObject** %10 to i64*
  store i64 %5, i64* %11, align 8, !tbaa !50
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 22
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %12) #16
  %13 = bitcast %struct.GCObject** %12 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !51
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 33
  %16 = bitcast %struct.GCObject** %15 to i64*
  store i64 %14, i64* %16, align 8, !tbaa !55
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 34
  %18 = bitcast %struct.GCObject** %17 to i64*
  store i64 %14, i64* %18, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 35
  %20 = bitcast %struct.GCObject** %19 to i64*
  store i64 %14, i64* %20, align 8, !tbaa !52
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 28
  tail call fastcc void @sweep2old(%struct.lua_State* %0, %struct.GCObject** nonnull %21) #16
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 12
  store i8 1, i8* %22, align 2, !tbaa !40
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 5
  store i64 0, i64* %23, align 8, !tbaa !41
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 2
  %25 = load i64, i64* %24, align 8, !tbaa !43
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %27 = load i64, i64* %26, align 8, !tbaa !11
  %28 = add nsw i64 %27, %25
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  store i64 %28, i64* %29, align 8, !tbaa !45
  tail call fastcc void @finishgencycle(%struct.lua_State* %0, %struct.global_State* %1) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @singlestep(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 11
  %5 = load i8, i8* %4, align 1, !tbaa !42
  switch i8 %5, label %87 [
    i8 8, label %6
    i8 0, label %32
    i8 1, label %39
    i8 3, label %55
    i8 4, label %59
    i8 5, label %63
    i8 6, label %66
    i8 7, label %67
  ]

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 38
  %9 = bitcast %struct.GCObject** %7 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull %9, i8 0, i64 40, i32 8, i1 false) #7
  %10 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !38
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %10, i64 0, i32 2
  %12 = load i8, i8* %11, align 1, !tbaa !16
  %13 = and i8 %12, 24
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %6
  %16 = bitcast %struct.lua_State* %10 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %16) #17
  br label %17

; <label>:17:                                     ; preds = %15, %6
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !79
  %20 = and i8 %19, 64
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %30, label %22

; <label>:22:                                     ; preds = %17
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 7, i32 0, i32 0
  %24 = load %struct.GCObject*, %struct.GCObject** %23, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %24, i64 0, i32 2
  %26 = load i8, i8* %25, align 1, !tbaa !70
  %27 = and i8 %26, 24
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %30, label %29

; <label>:29:                                     ; preds = %22
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %3, %struct.GCObject* %24) #17
  br label %30

; <label>:30:                                     ; preds = %17, %22, %29
  tail call fastcc void @markmt(%struct.global_State* nonnull %3) #17
  %31 = tail call fastcc i64 @markbeingfnz(%struct.global_State* nonnull %3) #17
  store i8 0, i8* %4, align 1, !tbaa !42
  br label %87

; <label>:32:                                     ; preds = %1
  %33 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 23
  %34 = load %struct.GCObject*, %struct.GCObject** %33, align 8, !tbaa !227
  %35 = icmp eq %struct.GCObject* %34, null
  br i1 %35, label %36, label %37

; <label>:36:                                     ; preds = %32
  store i8 1, i8* %4, align 1, !tbaa !42
  br label %87

; <label>:37:                                     ; preds = %32
  %38 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %3) #16
  br label %87

; <label>:39:                                     ; preds = %1
  %40 = tail call fastcc i64 @atomic(%struct.lua_State* nonnull %0) #16
  %41 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %41, i64 0, i32 11
  store i8 3, i8* %42, align 1, !tbaa !42
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %41, i64 0, i32 20
  br label %44

; <label>:44:                                     ; preds = %44, %39
  %45 = tail call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %43, i32 1, i32* null) #17
  %46 = icmp eq %struct.GCObject** %45, %43
  br i1 %46, label %44, label %47

; <label>:47:                                     ; preds = %44
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %41, i64 0, i32 21
  store %struct.GCObject** %45, %struct.GCObject*** %48, align 8, !tbaa !46
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 2
  %50 = load i64, i64* %49, align 8, !tbaa !43
  %51 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 3
  %52 = load i64, i64* %51, align 8, !tbaa !11
  %53 = add nsw i64 %52, %50
  %54 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 4
  store i64 %53, i64* %54, align 8, !tbaa !45
  br label %87

; <label>:55:                                     ; preds = %1
  %56 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 22
  %57 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 4, %struct.GCObject** nonnull %56) #16
  %58 = sext i32 %57 to i64
  br label %87

; <label>:59:                                     ; preds = %1
  %60 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %61 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 5, %struct.GCObject** nonnull %60) #16
  %62 = sext i32 %61 to i64
  br label %87

; <label>:63:                                     ; preds = %1
  %64 = tail call fastcc i32 @sweepstep(%struct.lua_State* nonnull %0, %struct.global_State* %3, i32 6, %struct.GCObject** null) #16
  %65 = sext i32 %64 to i64
  br label %87

; <label>:66:                                     ; preds = %1
  tail call fastcc void @checkSizes(%struct.lua_State* nonnull %0, %struct.global_State* %3) #16
  store i8 7, i8* %4, align 1, !tbaa !42
  br label %87

; <label>:67:                                     ; preds = %1
  %68 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 28
  %69 = load %struct.GCObject*, %struct.GCObject** %68, align 8, !tbaa !101
  %70 = icmp eq %struct.GCObject* %69, null
  br i1 %70, label %86, label %71

; <label>:71:                                     ; preds = %67
  %72 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 16
  %73 = load i8, i8* %72, align 2, !tbaa !81
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %75, label %86

; <label>:75:                                     ; preds = %71
  br label %76

; <label>:76:                                     ; preds = %75, %80
  %77 = phi i32 [ %78, %80 ], [ 0, %75 ]
  tail call fastcc void @GCTM(%struct.lua_State* %0) #17
  %78 = add nuw nsw i32 %77, 1
  %79 = icmp ult i32 %78, 10
  br i1 %79, label %80, label %87

; <label>:80:                                     ; preds = %76
  %81 = load %struct.GCObject*, %struct.GCObject** %68, align 8, !tbaa !101
  %82 = icmp eq %struct.GCObject* %81, null
  br i1 %82, label %83, label %76

; <label>:83:                                     ; preds = %80
  %84 = mul i32 %78, 50
  %85 = zext i32 %84 to i64
  br label %87

; <label>:86:                                     ; preds = %71, %67
  store i8 8, i8* %4, align 1, !tbaa !42
  br label %87

; <label>:87:                                     ; preds = %76, %83, %1, %86, %66, %63, %59, %55, %47, %37, %36, %30
  %88 = phi i64 [ 0, %86 ], [ 0, %66 ], [ %65, %63 ], [ %62, %59 ], [ %58, %55 ], [ %40, %47 ], [ 0, %36 ], [ %38, %37 ], [ 1, %30 ], [ 0, %1 ], [ %85, %83 ], [ 500, %76 ]
  ret i64 %88
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @propagatemark(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !227
  %4 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 2
  %5 = load i8, i8* %4, align 1, !tbaa !70
  %6 = or i8 %5, 32
  store i8 %6, i8* %4, align 1, !tbaa !70
  %7 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* %3) #16
  %8 = bitcast %struct.GCObject** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !54
  %10 = bitcast %struct.GCObject** %2 to i64*
  store i64 %9, i64* %10, align 8, !tbaa !227
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !86
  switch i8 %12, label %632 [
    i8 5, label %13
    i8 7, label %265
    i8 22, label %320
    i8 54, label %361
    i8 10, label %392
    i8 8, label %530
  ]

; <label>:13:                                     ; preds = %1
  %14 = bitcast %struct.GCObject* %3 to %struct.Table*
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2, i32 1
  %16 = bitcast i8* %15 to %struct.Table**
  %17 = load %struct.Table*, %struct.Table** %16, align 8, !tbaa !88
  %18 = icmp eq %struct.Table* %17, null
  br i1 %18, label %152, label %19

; <label>:19:                                     ; preds = %13
  %20 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 3
  %21 = load i8, i8* %20, align 2, !tbaa !90
  %22 = and i8 %21, 8
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %34

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 40, i64 3
  %26 = load %struct.TString*, %struct.TString** %25, align 8, !tbaa !54
  %27 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %17, %struct.TString* %26) #17
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = and i8 %29, 15
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %24
  %33 = or i8 %21, 8
  store i8 %33, i8* %20, align 2, !tbaa !90
  br label %34

; <label>:34:                                     ; preds = %32, %24, %19
  %35 = phi %struct.TValue* [ %27, %24 ], [ null, %32 ], [ null, %19 ]
  %36 = getelementptr inbounds %struct.Table, %struct.Table* %17, i64 0, i32 2
  %37 = load i8, i8* %36, align 1, !tbaa !146
  %38 = and i8 %37, 24
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %42, label %40

; <label>:40:                                     ; preds = %34
  %41 = bitcast %struct.Table* %17 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %41) #17
  br label %42

; <label>:42:                                     ; preds = %40, %34
  %43 = icmp eq %struct.TValue* %35, null
  br i1 %43, label %152, label %44

; <label>:44:                                     ; preds = %42
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %35, i64 0, i32 1
  %46 = load i8, i8* %45, align 8, !tbaa !22
  %47 = and i8 %46, 15
  %48 = icmp eq i8 %47, 4
  br i1 %48, label %49, label %152

; <label>:49:                                     ; preds = %44
  %50 = bitcast %struct.TValue* %35 to i8**
  %51 = load i8*, i8** %50, align 8, !tbaa !21
  %52 = getelementptr inbounds i8, i8* %51, i64 24
  %53 = tail call i8* @strchr(i8* nonnull %52, i32 107) #21
  %54 = tail call i8* @strchr(i8* nonnull %52, i32 118) #21
  %55 = icmp ne i8* %53, null
  %56 = icmp ne i8* %54, null
  %57 = or i1 %55, %56
  br i1 %57, label %58, label %152

; <label>:58:                                     ; preds = %49
  %59 = load i8, i8* %4, align 1, !tbaa !146
  %60 = and i8 %59, -33
  store i8 %60, i8* %4, align 1, !tbaa !146
  br i1 %55, label %143, label %61

; <label>:61:                                     ; preds = %58
  %62 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %63 = bitcast i8* %62 to %union.Node**
  %64 = load %union.Node*, %union.Node** %63, align 8, !tbaa !156
  %65 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %66 = load i8, i8* %65, align 1, !tbaa !93
  %67 = zext i8 %66 to i32
  %68 = shl i32 1, %67
  %69 = sext i32 %68 to i64
  %70 = getelementptr inbounds %union.Node, %union.Node* %64, i64 %69
  %71 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 5
  %72 = load i32, i32* %71, align 4, !tbaa !92
  %73 = icmp ne i32 %72, 0
  %74 = zext i1 %73 to i32
  %75 = icmp eq i8 %66, 31
  br i1 %75, label %124, label %76

; <label>:76:                                     ; preds = %61
  br label %77

; <label>:77:                                     ; preds = %76, %120
  %78 = phi i32 [ %121, %120 ], [ %74, %76 ]
  %79 = phi %union.Node* [ %122, %120 ], [ %64, %76 ]
  %80 = getelementptr inbounds %union.Node, %union.Node* %79, i64 0, i32 0, i32 1
  %81 = load i8, i8* %80, align 8, !tbaa !21
  %82 = and i8 %81, 15
  %83 = icmp eq i8 %82, 0
  %84 = getelementptr inbounds %union.Node, %union.Node* %79, i64 0, i32 0, i32 2
  %85 = load i8, i8* %84, align 1, !tbaa !21
  %86 = and i8 %85, 64
  %87 = icmp eq i8 %86, 0
  br i1 %83, label %88, label %97

; <label>:88:                                     ; preds = %77
  br i1 %87, label %120, label %89

; <label>:89:                                     ; preds = %88
  %90 = getelementptr inbounds %union.Node, %union.Node* %79, i64 0, i32 0, i32 4, i32 0
  %91 = load %struct.GCObject*, %struct.GCObject** %90, align 8, !tbaa !21
  %92 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %91, i64 0, i32 2
  %93 = load i8, i8* %92, align 1, !tbaa !70
  %94 = and i8 %93, 24
  %95 = icmp eq i8 %94, 0
  br i1 %95, label %120, label %96

; <label>:96:                                     ; preds = %89
  store i8 5, i8* %84, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %90, align 8, !tbaa !21
  br label %120

; <label>:97:                                     ; preds = %77
  br i1 %87, label %106, label %98

; <label>:98:                                     ; preds = %97
  %99 = getelementptr inbounds %union.Node, %union.Node* %79, i64 0, i32 0, i32 4, i32 0
  %100 = load %struct.GCObject*, %struct.GCObject** %99, align 8, !tbaa !21
  %101 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %100, i64 0, i32 2
  %102 = load i8, i8* %101, align 1, !tbaa !70
  %103 = and i8 %102, 24
  %104 = icmp eq i8 %103, 0
  br i1 %104, label %106, label %105

; <label>:105:                                    ; preds = %98
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %100) #17
  br label %106

; <label>:106:                                    ; preds = %105, %98, %97
  %107 = icmp eq i32 %78, 0
  br i1 %107, label %108, label %120

; <label>:108:                                    ; preds = %106
  %109 = load i8, i8* %80, align 8, !tbaa !21
  %110 = and i8 %109, 64
  %111 = icmp eq i8 %110, 0
  br i1 %111, label %115, label %112

; <label>:112:                                    ; preds = %108
  %113 = getelementptr inbounds %union.Node, %union.Node* %79, i64 0, i32 0, i32 0, i32 0
  %114 = load %struct.GCObject*, %struct.GCObject** %113, align 8, !tbaa !21
  br label %115

; <label>:115:                                    ; preds = %112, %108
  %116 = phi %struct.GCObject* [ %114, %112 ], [ null, %108 ]
  %117 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %116) #17
  %118 = icmp ne i32 %117, 0
  %119 = zext i1 %118 to i32
  br label %120

; <label>:120:                                    ; preds = %115, %106, %96, %89, %88
  %121 = phi i32 [ %78, %106 ], [ %119, %115 ], [ %78, %88 ], [ %78, %89 ], [ %78, %96 ]
  %122 = getelementptr inbounds %union.Node, %union.Node* %79, i64 1
  %123 = icmp ult %union.Node* %122, %70
  br i1 %123, label %77, label %124

; <label>:124:                                    ; preds = %120, %61
  %125 = phi i32 [ %74, %61 ], [ %121, %120 ]
  %126 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %127 = load i8, i8* %126, align 1, !tbaa !42
  %128 = icmp eq i8 %127, 2
  %129 = icmp ne i32 %125, 0
  %130 = and i1 %129, %128
  br i1 %130, label %131, label %137

; <label>:131:                                    ; preds = %124
  %132 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 25
  %133 = bitcast %struct.GCObject** %132 to i64*
  %134 = load i64, i64* %133, align 8, !tbaa !228
  %135 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %136 = bitcast %struct.GCObject** %135 to i64*
  store i64 %134, i64* %136, align 8, !tbaa !231
  store %struct.GCObject* %3, %struct.GCObject** %132, align 8, !tbaa !228
  br label %248

; <label>:137:                                    ; preds = %124
  %138 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %139 = bitcast %struct.GCObject** %138 to i64*
  %140 = load i64, i64* %139, align 8, !tbaa !157
  %141 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %142 = bitcast %struct.GCObject** %141 to i64*
  store i64 %140, i64* %142, align 8, !tbaa !231
  store %struct.GCObject* %3, %struct.GCObject** %138, align 8, !tbaa !157
  br label %248

; <label>:143:                                    ; preds = %58
  br i1 %56, label %146, label %144

; <label>:144:                                    ; preds = %143
  %145 = tail call fastcc i32 @traverseephemeron(%struct.global_State* nonnull %0, %struct.Table* nonnull %14) #17
  br label %248

; <label>:146:                                    ; preds = %143
  %147 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %148 = bitcast %struct.GCObject** %147 to i64*
  %149 = load i64, i64* %148, align 8, !tbaa !229
  %150 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %151 = bitcast %struct.GCObject** %150 to i64*
  store i64 %149, i64* %151, align 8, !tbaa !231
  store %struct.GCObject* %3, %struct.GCObject** %147, align 8, !tbaa !229
  br label %248

; <label>:152:                                    ; preds = %49, %44, %42, %13
  %153 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %154 = bitcast i8* %153 to %union.Node**
  %155 = load %union.Node*, %union.Node** %154, align 8, !tbaa !156
  %156 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %157 = load i8, i8* %156, align 1, !tbaa !93
  %158 = zext i8 %157 to i32
  %159 = shl i32 1, %158
  %160 = sext i32 %159 to i64
  %161 = getelementptr inbounds %union.Node, %union.Node* %155, i64 %160
  %162 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %14) #17
  %163 = icmp eq i32 %162, 0
  br i1 %163, label %188, label %164

; <label>:164:                                    ; preds = %152
  %165 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %166 = bitcast %struct.GCObject* %165 to %struct.TValue**
  %167 = zext i32 %162 to i64
  br label %168

; <label>:168:                                    ; preds = %183, %164
  %169 = phi i64 [ 0, %164 ], [ %184, %183 ]
  %170 = load %struct.TValue*, %struct.TValue** %166, align 8, !tbaa !91
  %171 = getelementptr inbounds %struct.TValue, %struct.TValue* %170, i64 %169, i32 1
  %172 = load i8, i8* %171, align 8, !tbaa !22
  %173 = and i8 %172, 64
  %174 = icmp eq i8 %173, 0
  br i1 %174, label %183, label %175

; <label>:175:                                    ; preds = %168
  %176 = getelementptr inbounds %struct.TValue, %struct.TValue* %170, i64 %169, i32 0, i32 0
  %177 = load %struct.GCObject*, %struct.GCObject** %176, align 8, !tbaa !21
  %178 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %177, i64 0, i32 2
  %179 = load i8, i8* %178, align 1, !tbaa !70
  %180 = and i8 %179, 24
  %181 = icmp eq i8 %180, 0
  br i1 %181, label %183, label %182

; <label>:182:                                    ; preds = %175
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %177) #17
  br label %183

; <label>:183:                                    ; preds = %182, %175, %168
  %184 = add nuw nsw i64 %169, 1
  %185 = icmp eq i64 %184, %167
  br i1 %185, label %186, label %168

; <label>:186:                                    ; preds = %183
  %187 = load %union.Node*, %union.Node** %154, align 8, !tbaa !156
  br label %188

; <label>:188:                                    ; preds = %186, %152
  %189 = phi %union.Node* [ %187, %186 ], [ %155, %152 ]
  %190 = icmp ult %union.Node* %189, %161
  br i1 %190, label %191, label %236

; <label>:191:                                    ; preds = %188
  br label %192

; <label>:192:                                    ; preds = %191, %233
  %193 = phi %union.Node* [ %234, %233 ], [ %189, %191 ]
  %194 = getelementptr inbounds %union.Node, %union.Node* %193, i64 0, i32 0, i32 1
  %195 = load i8, i8* %194, align 8, !tbaa !21
  %196 = and i8 %195, 15
  %197 = icmp eq i8 %196, 0
  %198 = getelementptr inbounds %union.Node, %union.Node* %193, i64 0, i32 0, i32 2
  %199 = load i8, i8* %198, align 1, !tbaa !21
  %200 = and i8 %199, 64
  %201 = icmp eq i8 %200, 0
  br i1 %197, label %202, label %211

; <label>:202:                                    ; preds = %192
  br i1 %201, label %233, label %203

; <label>:203:                                    ; preds = %202
  %204 = getelementptr inbounds %union.Node, %union.Node* %193, i64 0, i32 0, i32 4, i32 0
  %205 = load %struct.GCObject*, %struct.GCObject** %204, align 8, !tbaa !21
  %206 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %205, i64 0, i32 2
  %207 = load i8, i8* %206, align 1, !tbaa !70
  %208 = and i8 %207, 24
  %209 = icmp eq i8 %208, 0
  br i1 %209, label %233, label %210

; <label>:210:                                    ; preds = %203
  store i8 5, i8* %198, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %204, align 8, !tbaa !21
  br label %233

; <label>:211:                                    ; preds = %192
  br i1 %201, label %221, label %212

; <label>:212:                                    ; preds = %211
  %213 = getelementptr inbounds %union.Node, %union.Node* %193, i64 0, i32 0, i32 4, i32 0
  %214 = load %struct.GCObject*, %struct.GCObject** %213, align 8, !tbaa !21
  %215 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %214, i64 0, i32 2
  %216 = load i8, i8* %215, align 1, !tbaa !70
  %217 = and i8 %216, 24
  %218 = icmp eq i8 %217, 0
  br i1 %218, label %221, label %219

; <label>:219:                                    ; preds = %212
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %214) #17
  %220 = load i8, i8* %194, align 8, !tbaa !21
  br label %221

; <label>:221:                                    ; preds = %219, %212, %211
  %222 = phi i8 [ %195, %212 ], [ %195, %211 ], [ %220, %219 ]
  %223 = and i8 %222, 64
  %224 = icmp eq i8 %223, 0
  br i1 %224, label %233, label %225

; <label>:225:                                    ; preds = %221
  %226 = getelementptr inbounds %union.Node, %union.Node* %193, i64 0, i32 0, i32 0, i32 0
  %227 = load %struct.GCObject*, %struct.GCObject** %226, align 8, !tbaa !21
  %228 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %227, i64 0, i32 2
  %229 = load i8, i8* %228, align 1, !tbaa !70
  %230 = and i8 %229, 24
  %231 = icmp eq i8 %230, 0
  br i1 %231, label %233, label %232

; <label>:232:                                    ; preds = %225
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %227) #17
  br label %233

; <label>:233:                                    ; preds = %232, %225, %221, %210, %203, %202
  %234 = getelementptr inbounds %union.Node, %union.Node* %193, i64 1
  %235 = icmp ult %union.Node* %234, %161
  br i1 %235, label %192, label %236

; <label>:236:                                    ; preds = %233, %188
  %237 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %238 = load i8, i8* %237, align 2, !tbaa !40
  %239 = icmp eq i8 %238, 1
  br i1 %239, label %240, label %248

; <label>:240:                                    ; preds = %236
  %241 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %242 = bitcast %struct.GCObject** %241 to i64*
  %243 = load i64, i64* %242, align 8, !tbaa !157
  %244 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 0
  %245 = bitcast %struct.GCObject** %244 to i64*
  store i64 %243, i64* %245, align 8, !tbaa !231
  store %struct.GCObject* %3, %struct.GCObject** %241, align 8, !tbaa !157
  %246 = load i8, i8* %4, align 1, !tbaa !146
  %247 = and i8 %246, -33
  store i8 %247, i8* %4, align 1, !tbaa !146
  br label %248

; <label>:248:                                    ; preds = %240, %236, %146, %144, %137, %131
  %249 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 5
  %250 = load i32, i32* %249, align 4, !tbaa !92
  %251 = add i32 %250, 1
  %252 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2
  %253 = bitcast %struct.GCObject* %252 to %union.Node**
  %254 = load %union.Node*, %union.Node** %253, align 8, !tbaa !147
  %255 = icmp eq %union.Node* %254, null
  br i1 %255, label %261, label %256

; <label>:256:                                    ; preds = %248
  %257 = getelementptr inbounds %struct.Table, %struct.Table* %14, i64 0, i32 4
  %258 = load i8, i8* %257, align 1, !tbaa !93
  %259 = zext i8 %258 to i32
  %260 = shl i32 2, %259
  br label %261

; <label>:261:                                    ; preds = %248, %256
  %262 = phi i32 [ %260, %256 ], [ 0, %248 ]
  %263 = add i32 %251, %262
  %264 = zext i32 %263 to i64
  br label %632

; <label>:265:                                    ; preds = %1
  %266 = bitcast %struct.GCObject* %3 to %struct.Udata*
  %267 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %268 = bitcast i8* %267 to %struct.Table**
  %269 = load %struct.Table*, %struct.Table** %268, align 8, !tbaa !196
  %270 = icmp eq %struct.Table* %269, null
  br i1 %270, label %278, label %271

; <label>:271:                                    ; preds = %265
  %272 = getelementptr inbounds %struct.Table, %struct.Table* %269, i64 0, i32 2
  %273 = load i8, i8* %272, align 1, !tbaa !146
  %274 = and i8 %273, 24
  %275 = icmp eq i8 %274, 0
  br i1 %275, label %278, label %276

; <label>:276:                                    ; preds = %271
  %277 = bitcast %struct.Table* %269 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %277) #17
  br label %278

; <label>:278:                                    ; preds = %276, %271, %265
  %279 = getelementptr inbounds %struct.Udata, %struct.Udata* %266, i64 0, i32 3
  %280 = load i16, i16* %279, align 2, !tbaa !195
  %281 = icmp eq i16 %280, 0
  br i1 %281, label %304, label %282

; <label>:282:                                    ; preds = %278
  br label %283

; <label>:283:                                    ; preds = %282, %299
  %284 = phi i16 [ %300, %299 ], [ %280, %282 ]
  %285 = phi i64 [ %301, %299 ], [ 0, %282 ]
  %286 = getelementptr inbounds %struct.Udata, %struct.Udata* %266, i64 0, i32 7, i64 %285, i32 0, i32 1
  %287 = load i8, i8* %286, align 8, !tbaa !21
  %288 = and i8 %287, 64
  %289 = icmp eq i8 %288, 0
  br i1 %289, label %299, label %290

; <label>:290:                                    ; preds = %283
  %291 = getelementptr inbounds %struct.Udata, %struct.Udata* %266, i64 0, i32 7, i64 %285, i32 0, i32 0, i32 0
  %292 = load %struct.GCObject*, %struct.GCObject** %291, align 8, !tbaa !21
  %293 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %292, i64 0, i32 2
  %294 = load i8, i8* %293, align 1, !tbaa !70
  %295 = and i8 %294, 24
  %296 = icmp eq i8 %295, 0
  br i1 %296, label %299, label %297

; <label>:297:                                    ; preds = %290
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %292) #17
  %298 = load i16, i16* %279, align 2, !tbaa !195
  br label %299

; <label>:299:                                    ; preds = %297, %290, %283
  %300 = phi i16 [ %284, %290 ], [ %284, %283 ], [ %298, %297 ]
  %301 = add nuw nsw i64 %285, 1
  %302 = zext i16 %300 to i64
  %303 = icmp ult i64 %301, %302
  br i1 %303, label %283, label %304

; <label>:304:                                    ; preds = %299, %278
  %305 = phi i16 [ 0, %278 ], [ %300, %299 ]
  %306 = zext i16 %305 to i64
  %307 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %308 = load i8, i8* %307, align 2, !tbaa !40
  %309 = icmp eq i8 %308, 1
  br i1 %309, label %310, label %318

; <label>:310:                                    ; preds = %304
  %311 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %312 = bitcast %struct.GCObject** %311 to i64*
  %313 = load i64, i64* %312, align 8, !tbaa !157
  %314 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2, i32 0
  %315 = bitcast %struct.GCObject** %314 to i64*
  store i64 %313, i64* %315, align 8, !tbaa !232
  store %struct.GCObject* %3, %struct.GCObject** %311, align 8, !tbaa !157
  %316 = load i8, i8* %4, align 1, !tbaa !233
  %317 = and i8 %316, -33
  store i8 %317, i8* %4, align 1, !tbaa !233
  br label %318

; <label>:318:                                    ; preds = %304, %310
  %319 = add nuw nsw i64 %306, 1
  br label %632

; <label>:320:                                    ; preds = %1
  %321 = bitcast %struct.GCObject* %3 to %struct.LClosure*
  %322 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1, i32 1
  %323 = bitcast i8* %322 to %struct.Proto**
  %324 = load %struct.Proto*, %struct.Proto** %323, align 8, !tbaa !197
  %325 = icmp eq %struct.Proto* %324, null
  br i1 %325, label %333, label %326

; <label>:326:                                    ; preds = %320
  %327 = getelementptr inbounds %struct.Proto, %struct.Proto* %324, i64 0, i32 2
  %328 = load i8, i8* %327, align 1, !tbaa !234
  %329 = and i8 %328, 24
  %330 = icmp eq i8 %329, 0
  br i1 %330, label %333, label %331

; <label>:331:                                    ; preds = %326
  %332 = bitcast %struct.Proto* %324 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %332) #17
  br label %333

; <label>:333:                                    ; preds = %331, %326, %320
  %334 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %321, i64 0, i32 3
  %335 = load i8, i8* %334, align 2, !tbaa !182
  %336 = icmp eq i8 %335, 0
  br i1 %336, label %357, label %337

; <label>:337:                                    ; preds = %333
  br label %338

; <label>:338:                                    ; preds = %337, %352
  %339 = phi i8 [ %353, %352 ], [ %335, %337 ]
  %340 = phi i64 [ %354, %352 ], [ 0, %337 ]
  %341 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %321, i64 0, i32 6, i64 %340
  %342 = load %struct.UpVal*, %struct.UpVal** %341, align 8, !tbaa !54
  %343 = icmp eq %struct.UpVal* %342, null
  br i1 %343, label %352, label %344

; <label>:344:                                    ; preds = %338
  %345 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %342, i64 0, i32 2
  %346 = load i8, i8* %345, align 1, !tbaa !69
  %347 = and i8 %346, 24
  %348 = icmp eq i8 %347, 0
  br i1 %348, label %352, label %349

; <label>:349:                                    ; preds = %344
  %350 = bitcast %struct.UpVal* %342 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %350) #17
  %351 = load i8, i8* %334, align 2, !tbaa !182
  br label %352

; <label>:352:                                    ; preds = %349, %344, %338
  %353 = phi i8 [ %339, %344 ], [ %339, %338 ], [ %351, %349 ]
  %354 = add nuw nsw i64 %340, 1
  %355 = zext i8 %353 to i64
  %356 = icmp ult i64 %354, %355
  br i1 %356, label %338, label %357

; <label>:357:                                    ; preds = %352, %333
  %358 = phi i8 [ 0, %333 ], [ %353, %352 ]
  %359 = zext i8 %358 to i64
  %360 = add nuw nsw i64 %359, 1
  br label %632

; <label>:361:                                    ; preds = %1
  %362 = bitcast %struct.GCObject* %3 to %struct.CClosure*
  %363 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %362, i64 0, i32 3
  %364 = load i8, i8* %363, align 2, !tbaa !138
  %365 = icmp eq i8 %364, 0
  br i1 %365, label %388, label %366

; <label>:366:                                    ; preds = %361
  br label %367

; <label>:367:                                    ; preds = %366, %383
  %368 = phi i8 [ %384, %383 ], [ %364, %366 ]
  %369 = phi i64 [ %385, %383 ], [ 0, %366 ]
  %370 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %362, i64 0, i32 6, i64 %369, i32 1
  %371 = load i8, i8* %370, align 8, !tbaa !22
  %372 = and i8 %371, 64
  %373 = icmp eq i8 %372, 0
  br i1 %373, label %383, label %374

; <label>:374:                                    ; preds = %367
  %375 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %362, i64 0, i32 6, i64 %369, i32 0, i32 0
  %376 = load %struct.GCObject*, %struct.GCObject** %375, align 8, !tbaa !21
  %377 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %376, i64 0, i32 2
  %378 = load i8, i8* %377, align 1, !tbaa !70
  %379 = and i8 %378, 24
  %380 = icmp eq i8 %379, 0
  br i1 %380, label %383, label %381

; <label>:381:                                    ; preds = %374
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %376) #17
  %382 = load i8, i8* %363, align 2, !tbaa !138
  br label %383

; <label>:383:                                    ; preds = %381, %374, %367
  %384 = phi i8 [ %368, %374 ], [ %368, %367 ], [ %382, %381 ]
  %385 = add nuw nsw i64 %369, 1
  %386 = zext i8 %384 to i64
  %387 = icmp ult i64 %385, %386
  br i1 %387, label %367, label %388

; <label>:388:                                    ; preds = %383, %361
  %389 = phi i8 [ 0, %361 ], [ %384, %383 ]
  %390 = zext i8 %389 to i64
  %391 = add nuw nsw i64 %390, 1
  br label %632

; <label>:392:                                    ; preds = %1
  %393 = bitcast %struct.GCObject* %3 to %struct.Proto*
  %394 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 7
  %395 = bitcast %struct.GCObject* %394 to %struct.TString**
  %396 = load %struct.TString*, %struct.TString** %395, align 8, !tbaa !122
  %397 = icmp eq %struct.TString* %396, null
  br i1 %397, label %405, label %398

; <label>:398:                                    ; preds = %392
  %399 = getelementptr inbounds %struct.TString, %struct.TString* %396, i64 0, i32 2
  %400 = load i8, i8* %399, align 1, !tbaa !148
  %401 = and i8 %400, 24
  %402 = icmp eq i8 %401, 0
  br i1 %402, label %405, label %403

; <label>:403:                                    ; preds = %398
  %404 = bitcast %struct.TString* %396 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %404) #17
  br label %405

; <label>:405:                                    ; preds = %403, %398, %392
  %406 = getelementptr inbounds %struct.Proto, %struct.Proto* %393, i64 0, i32 7
  %407 = load i32, i32* %406, align 4, !tbaa !224
  %408 = icmp sgt i32 %407, 0
  br i1 %408, label %409, label %434

; <label>:409:                                    ; preds = %405
  %410 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 1
  %411 = bitcast i8* %410 to %struct.TValue**
  br label %412

; <label>:412:                                    ; preds = %429, %409
  %413 = phi i32 [ %407, %409 ], [ %430, %429 ]
  %414 = phi i64 [ 0, %409 ], [ %431, %429 ]
  %415 = load %struct.TValue*, %struct.TValue** %411, align 8, !tbaa !223
  %416 = getelementptr inbounds %struct.TValue, %struct.TValue* %415, i64 %414, i32 1
  %417 = load i8, i8* %416, align 8, !tbaa !22
  %418 = and i8 %417, 64
  %419 = icmp eq i8 %418, 0
  br i1 %419, label %429, label %420

; <label>:420:                                    ; preds = %412
  %421 = getelementptr inbounds %struct.TValue, %struct.TValue* %415, i64 %414, i32 0, i32 0
  %422 = load %struct.GCObject*, %struct.GCObject** %421, align 8, !tbaa !21
  %423 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %422, i64 0, i32 2
  %424 = load i8, i8* %423, align 1, !tbaa !70
  %425 = and i8 %424, 24
  %426 = icmp eq i8 %425, 0
  br i1 %426, label %429, label %427

; <label>:427:                                    ; preds = %420
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %422) #17
  %428 = load i32, i32* %406, align 4, !tbaa !224
  br label %429

; <label>:429:                                    ; preds = %427, %420, %412
  %430 = phi i32 [ %413, %420 ], [ %413, %412 ], [ %428, %427 ]
  %431 = add nuw nsw i64 %414, 1
  %432 = sext i32 %430 to i64
  %433 = icmp slt i64 %431, %432
  br i1 %433, label %412, label %434

; <label>:434:                                    ; preds = %429, %405
  %435 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %436 = bitcast %struct.GCObject* %435 to i32*
  %437 = load i32, i32* %436, align 8, !tbaa !190
  %438 = icmp sgt i32 %437, 0
  br i1 %438, label %439, label %462

; <label>:439:                                    ; preds = %434
  %440 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 5
  %441 = bitcast %struct.GCObject* %440 to %struct.Upvaldesc**
  br label %442

; <label>:442:                                    ; preds = %457, %439
  %443 = phi i32 [ %437, %439 ], [ %458, %457 ]
  %444 = phi i64 [ 0, %439 ], [ %459, %457 ]
  %445 = load %struct.Upvaldesc*, %struct.Upvaldesc** %441, align 8, !tbaa !198
  %446 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %445, i64 %444, i32 0
  %447 = load %struct.TString*, %struct.TString** %446, align 8, !tbaa !199
  %448 = icmp eq %struct.TString* %447, null
  br i1 %448, label %457, label %449

; <label>:449:                                    ; preds = %442
  %450 = getelementptr inbounds %struct.TString, %struct.TString* %447, i64 0, i32 2
  %451 = load i8, i8* %450, align 1, !tbaa !148
  %452 = and i8 %451, 24
  %453 = icmp eq i8 %452, 0
  br i1 %453, label %457, label %454

; <label>:454:                                    ; preds = %449
  %455 = bitcast %struct.TString* %447 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %455) #17
  %456 = load i32, i32* %436, align 8, !tbaa !190
  br label %457

; <label>:457:                                    ; preds = %454, %449, %442
  %458 = phi i32 [ %443, %449 ], [ %443, %442 ], [ %456, %454 ]
  %459 = add nuw nsw i64 %444, 1
  %460 = sext i32 %458 to i64
  %461 = icmp slt i64 %459, %460
  br i1 %461, label %442, label %462

; <label>:462:                                    ; preds = %457, %434
  %463 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 2
  %464 = bitcast %struct.GCObject* %463 to i32*
  %465 = load i32, i32* %464, align 8, !tbaa !222
  %466 = icmp sgt i32 %465, 0
  br i1 %466, label %467, label %490

; <label>:467:                                    ; preds = %462
  %468 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4, i32 1
  %469 = bitcast i8* %468 to %struct.Proto***
  br label %470

; <label>:470:                                    ; preds = %485, %467
  %471 = phi i32 [ %465, %467 ], [ %486, %485 ]
  %472 = phi i64 [ 0, %467 ], [ %487, %485 ]
  %473 = load %struct.Proto**, %struct.Proto*** %469, align 8, !tbaa !221
  %474 = getelementptr inbounds %struct.Proto*, %struct.Proto** %473, i64 %472
  %475 = load %struct.Proto*, %struct.Proto** %474, align 8, !tbaa !54
  %476 = icmp eq %struct.Proto* %475, null
  br i1 %476, label %485, label %477

; <label>:477:                                    ; preds = %470
  %478 = getelementptr inbounds %struct.Proto, %struct.Proto* %475, i64 0, i32 2
  %479 = load i8, i8* %478, align 1, !tbaa !234
  %480 = and i8 %479, 24
  %481 = icmp eq i8 %480, 0
  br i1 %481, label %485, label %482

; <label>:482:                                    ; preds = %477
  %483 = bitcast %struct.Proto* %475 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %483) #17
  %484 = load i32, i32* %464, align 8, !tbaa !222
  br label %485

; <label>:485:                                    ; preds = %482, %477, %470
  %486 = phi i32 [ %471, %477 ], [ %471, %470 ], [ %484, %482 ]
  %487 = add nuw nsw i64 %472, 1
  %488 = sext i32 %486 to i64
  %489 = icmp slt i64 %487, %488
  br i1 %489, label %470, label %490

; <label>:490:                                    ; preds = %485, %462
  %491 = phi i32 [ %465, %462 ], [ %486, %485 ]
  %492 = getelementptr inbounds %struct.Proto, %struct.Proto* %393, i64 0, i32 11
  %493 = load i32, i32* %492, align 4, !tbaa !108
  %494 = icmp sgt i32 %493, 0
  br i1 %494, label %495, label %520

; <label>:495:                                    ; preds = %490
  %496 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 6, i32 1
  %497 = bitcast i8* %496 to %struct.LocVar**
  br label %498

; <label>:498:                                    ; preds = %513, %495
  %499 = phi i32 [ %493, %495 ], [ %514, %513 ]
  %500 = phi i64 [ 0, %495 ], [ %515, %513 ]
  %501 = load %struct.LocVar*, %struct.LocVar** %497, align 8, !tbaa !110
  %502 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %501, i64 %500, i32 0
  %503 = load %struct.TString*, %struct.TString** %502, align 8, !tbaa !114
  %504 = icmp eq %struct.TString* %503, null
  br i1 %504, label %513, label %505

; <label>:505:                                    ; preds = %498
  %506 = getelementptr inbounds %struct.TString, %struct.TString* %503, i64 0, i32 2
  %507 = load i8, i8* %506, align 1, !tbaa !148
  %508 = and i8 %507, 24
  %509 = icmp eq i8 %508, 0
  br i1 %509, label %513, label %510

; <label>:510:                                    ; preds = %505
  %511 = bitcast %struct.TString* %503 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %511) #17
  %512 = load i32, i32* %492, align 4, !tbaa !108
  br label %513

; <label>:513:                                    ; preds = %510, %505, %498
  %514 = phi i32 [ %499, %505 ], [ %499, %498 ], [ %512, %510 ]
  %515 = add nuw nsw i64 %500, 1
  %516 = sext i32 %514 to i64
  %517 = icmp slt i64 %515, %516
  br i1 %517, label %498, label %518

; <label>:518:                                    ; preds = %513
  %519 = load i32, i32* %464, align 8, !tbaa !222
  br label %520

; <label>:520:                                    ; preds = %490, %518
  %521 = phi i32 [ %491, %490 ], [ %519, %518 ]
  %522 = phi i32 [ %493, %490 ], [ %514, %518 ]
  %523 = load i32, i32* %406, align 4, !tbaa !224
  %524 = load i32, i32* %436, align 8, !tbaa !190
  %525 = add i32 %521, 1
  %526 = add i32 %525, %522
  %527 = add i32 %526, %523
  %528 = add i32 %527, %524
  %529 = sext i32 %528 to i64
  br label %632

; <label>:530:                                    ; preds = %1
  %531 = bitcast %struct.GCObject* %3 to %struct.lua_State*
  %532 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %533 = bitcast %struct.GCObject** %532 to i64*
  %534 = load i64, i64* %533, align 8, !tbaa !157
  %535 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4, i32 1
  %536 = bitcast i8* %535 to i64*
  store i64 %534, i64* %536, align 8, !tbaa !235
  store %struct.GCObject* %3, %struct.GCObject** %532, align 8, !tbaa !157
  %537 = and i8 %5, -33
  store i8 %537, i8* %4, align 1, !tbaa !70
  %538 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 3, i32 1
  %539 = bitcast i8* %538 to %union.StackValue**
  %540 = load %union.StackValue*, %union.StackValue** %539, align 8, !tbaa !23
  %541 = icmp eq %union.StackValue* %540, null
  br i1 %541, label %632, label %542

; <label>:542:                                    ; preds = %530
  %543 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 1
  %544 = bitcast %struct.GCObject* %543 to %union.StackValue**
  %545 = load %union.StackValue*, %union.StackValue** %544, align 8, !tbaa !20
  %546 = icmp ult %union.StackValue* %540, %545
  br i1 %546, label %547, label %568

; <label>:547:                                    ; preds = %542
  br label %548

; <label>:548:                                    ; preds = %547, %564
  %549 = phi %union.StackValue* [ %565, %564 ], [ %545, %547 ]
  %550 = phi %union.StackValue* [ %566, %564 ], [ %540, %547 ]
  %551 = getelementptr inbounds %union.StackValue, %union.StackValue* %550, i64 0, i32 0, i32 1
  %552 = load i8, i8* %551, align 8, !tbaa !21
  %553 = and i8 %552, 64
  %554 = icmp eq i8 %553, 0
  br i1 %554, label %564, label %555

; <label>:555:                                    ; preds = %548
  %556 = getelementptr inbounds %union.StackValue, %union.StackValue* %550, i64 0, i32 0, i32 0, i32 0
  %557 = load %struct.GCObject*, %struct.GCObject** %556, align 8, !tbaa !21
  %558 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %557, i64 0, i32 2
  %559 = load i8, i8* %558, align 1, !tbaa !70
  %560 = and i8 %559, 24
  %561 = icmp eq i8 %560, 0
  br i1 %561, label %564, label %562

; <label>:562:                                    ; preds = %555
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %557) #17
  %563 = load %union.StackValue*, %union.StackValue** %544, align 8, !tbaa !20
  br label %564

; <label>:564:                                    ; preds = %562, %555, %548
  %565 = phi %union.StackValue* [ %563, %562 ], [ %549, %555 ], [ %549, %548 ]
  %566 = getelementptr inbounds %union.StackValue, %union.StackValue* %550, i64 1
  %567 = icmp ult %union.StackValue* %566, %565
  br i1 %567, label %548, label %568

; <label>:568:                                    ; preds = %564, %542
  %569 = phi %union.StackValue* [ %540, %542 ], [ %566, %564 ]
  %570 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 4
  %571 = bitcast %struct.GCObject* %570 to %struct.UpVal**
  %572 = load %struct.UpVal*, %struct.UpVal** %571, align 8, !tbaa !21
  %573 = icmp eq %struct.UpVal* %572, null
  br i1 %573, label %591, label %574

; <label>:574:                                    ; preds = %568
  br label %575

; <label>:575:                                    ; preds = %574, %587
  %576 = phi %struct.UpVal* [ %589, %587 ], [ %572, %574 ]
  %577 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %576, i64 0, i32 1
  %578 = load i8, i8* %577, align 8, !tbaa !72
  %579 = icmp eq i8 %578, 25
  br i1 %579, label %580, label %587

; <label>:580:                                    ; preds = %575
  %581 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %576, i64 0, i32 2
  %582 = load i8, i8* %581, align 1, !tbaa !69
  %583 = and i8 %582, 24
  %584 = icmp eq i8 %583, 0
  br i1 %584, label %587, label %585

; <label>:585:                                    ; preds = %580
  %586 = bitcast %struct.UpVal* %576 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %586) #17
  br label %587

; <label>:587:                                    ; preds = %585, %580, %575
  %588 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %576, i64 0, i32 4, i32 0, i32 0
  %589 = load %struct.UpVal*, %struct.UpVal** %588, align 8, !tbaa !21
  %590 = icmp eq %struct.UpVal* %589, null
  br i1 %590, label %591, label %575

; <label>:591:                                    ; preds = %587, %568
  %592 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %593 = load i8, i8* %592, align 1, !tbaa !42
  %594 = icmp eq i8 %593, 2
  br i1 %594, label %595, label %622

; <label>:595:                                    ; preds = %591
  %596 = load %union.StackValue*, %union.StackValue** %539, align 8, !tbaa !23
  %597 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %531, i64 0, i32 20
  %598 = load i32, i32* %597, align 4, !tbaa !26
  %599 = sext i32 %598 to i64
  %600 = getelementptr inbounds %union.StackValue, %union.StackValue* %596, i64 %599
  %601 = icmp ult %union.StackValue* %569, %600
  br i1 %601, label %602, label %608

; <label>:602:                                    ; preds = %595
  br label %603

; <label>:603:                                    ; preds = %602, %603
  %604 = phi %union.StackValue* [ %606, %603 ], [ %569, %602 ]
  %605 = getelementptr inbounds %union.StackValue, %union.StackValue* %604, i64 0, i32 0, i32 1
  store i8 0, i8* %605, align 8, !tbaa !21
  %606 = getelementptr inbounds %union.StackValue, %union.StackValue* %604, i64 1
  %607 = icmp ult %union.StackValue* %606, %600
  br i1 %607, label %603, label %608

; <label>:608:                                    ; preds = %603, %595
  %609 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3, i64 5
  %610 = bitcast %struct.GCObject* %609 to %struct.lua_State**
  %611 = load %struct.lua_State*, %struct.lua_State** %610, align 8, !tbaa !27
  %612 = icmp eq %struct.lua_State* %611, %531
  br i1 %612, label %613, label %627

; <label>:613:                                    ; preds = %608
  %614 = load %struct.UpVal*, %struct.UpVal** %571, align 8, !tbaa !34
  %615 = icmp eq %struct.UpVal* %614, null
  br i1 %615, label %627, label %616

; <label>:616:                                    ; preds = %613
  %617 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 36
  %618 = bitcast %struct.lua_State** %617 to i64*
  %619 = load i64, i64* %618, align 8, !tbaa !236
  %620 = bitcast %struct.GCObject* %609 to i64*
  store i64 %619, i64* %620, align 8, !tbaa !27
  %621 = bitcast %struct.lua_State** %617 to %struct.GCObject**
  store %struct.GCObject* %3, %struct.GCObject** %621, align 8, !tbaa !236
  br label %627

; <label>:622:                                    ; preds = %591
  %623 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 16
  %624 = load i8, i8* %623, align 2, !tbaa !81
  %625 = icmp eq i8 %624, 0
  br i1 %625, label %626, label %627

; <label>:626:                                    ; preds = %622
  tail call fastcc void @luaD_shrinkstack(%struct.lua_State* %531) #17
  br label %627

; <label>:627:                                    ; preds = %626, %622, %616, %613, %608
  %628 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %531, i64 0, i32 20
  %629 = load i32, i32* %628, align 4, !tbaa !26
  %630 = add nsw i32 %629, 1
  %631 = sext i32 %630 to i64
  br label %632

; <label>:632:                                    ; preds = %627, %530, %1, %520, %388, %357, %318, %261
  %633 = phi i64 [ %529, %520 ], [ %391, %388 ], [ %360, %357 ], [ %319, %318 ], [ %264, %261 ], [ 0, %1 ], [ %631, %627 ], [ 1, %530 ]
  ret i64 %633
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @sweepstep(%struct.lua_State*, %struct.global_State* nocapture, i32, %struct.GCObject**) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 21
  %7 = load %struct.GCObject**, %struct.GCObject*** %6, align 8, !tbaa !46
  %8 = icmp eq %struct.GCObject** %7, null
  br i1 %8, label %20, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %11 = load i64, i64* %10, align 8, !tbaa !11
  %12 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #7
  %13 = call fastcc %struct.GCObject** @sweeplist(%struct.lua_State* %0, %struct.GCObject** nonnull %7, i32 100, i32* nonnull %5) #16
  store %struct.GCObject** %13, %struct.GCObject*** %6, align 8, !tbaa !46
  %14 = load i64, i64* %10, align 8, !tbaa !11
  %15 = sub i64 %14, %11
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %17 = load i64, i64* %16, align 8, !tbaa !45
  %18 = add i64 %15, %17
  store i64 %18, i64* %16, align 8, !tbaa !45
  %19 = load i32, i32* %5, align 4, !tbaa !77
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #7
  br label %23

; <label>:20:                                     ; preds = %4
  %21 = trunc i32 %2 to i8
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 %21, i8* %22, align 1, !tbaa !42
  store %struct.GCObject** %3, %struct.GCObject*** %6, align 8, !tbaa !46
  br label %23

; <label>:23:                                     ; preds = %20, %9
  %24 = phi i32 [ %19, %9 ], [ 0, %20 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checkSizes(%struct.lua_State*, %struct.global_State* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %4 = load i8, i8* %3, align 2, !tbaa !81
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %6, label %24

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 3
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 1
  %10 = load i32, i32* %9, align 8, !tbaa !237
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 6, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !103
  %13 = sdiv i32 %12, 4
  %14 = icmp slt i32 %10, %13
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %6
  %16 = sdiv i32 %12, 2
  tail call fastcc void @luaS_resize(%struct.lua_State* %0, i32 %16) #16
  %17 = load i64, i64* %7, align 8, !tbaa !11
  br label %18

; <label>:18:                                     ; preds = %15, %6
  %19 = phi i64 [ %17, %15 ], [ %8, %6 ]
  %20 = sub i64 %19, %8
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 4
  %22 = load i64, i64* %21, align 8, !tbaa !45
  %23 = add i64 %20, %22
  store i64 %23, i64* %21, align 8, !tbaa !45
  br label %24

; <label>:24:                                     ; preds = %2, %18
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @reallymarkobject(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %4 = load i8, i8* %3, align 1, !tbaa !70
  br label %5

; <label>:5:                                      ; preds = %28, %2
  %6 = phi i8 [ %4, %2 ], [ %32, %28 ]
  %7 = phi %struct.GCObject* [ %1, %2 ], [ %30, %28 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %9 = and i8 %6, -25
  store i8 %9, i8* %8, align 1, !tbaa !70
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !86
  switch i8 %11, label %62 [
    i8 20, label %12
    i8 36, label %12
    i8 9, label %14
    i8 25, label %14
    i8 7, label %35
    i8 22, label %56
    i8 54, label %56
    i8 5, label %56
    i8 8, label %56
    i8 10, label %56
  ]

; <label>:12:                                     ; preds = %5, %5
  %13 = or i8 %9, 32
  store i8 %13, i8* %8, align 1, !tbaa !70
  br label %62

; <label>:14:                                     ; preds = %5, %5
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1
  %16 = bitcast %struct.GCObject* %15 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !67
  %18 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %19 = bitcast i8* %18 to %struct.TValue*
  %20 = icmp eq %struct.TValue* %17, %19
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %14
  %22 = or i8 %9, 32
  store i8 %22, i8* %8, align 1, !tbaa !70
  br label %23

; <label>:23:                                     ; preds = %14, %21
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = and i8 %25, 64
  %27 = icmp eq i8 %26, 0
  br i1 %27, label %62, label %28

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 0, i32 0
  %30 = load %struct.GCObject*, %struct.GCObject** %29, align 8, !tbaa !21
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %30, i64 0, i32 2
  %32 = load i8, i8* %31, align 1, !tbaa !70
  %33 = and i8 %32, 24
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %62, label %5

; <label>:35:                                     ; preds = %5
  %36 = bitcast %struct.GCObject* %7 to %struct.Udata*
  %37 = getelementptr inbounds %struct.Udata, %struct.Udata* %36, i64 0, i32 3
  %38 = load i16, i16* %37, align 2, !tbaa !195
  %39 = icmp eq i16 %38, 0
  br i1 %39, label %40, label %56

; <label>:40:                                     ; preds = %35
  %41 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %42 = bitcast i8* %41 to %struct.Table**
  %43 = load %struct.Table*, %struct.Table** %42, align 8, !tbaa !196
  %44 = icmp eq %struct.Table* %43, null
  br i1 %44, label %53, label %45

; <label>:45:                                     ; preds = %40
  %46 = getelementptr inbounds %struct.Table, %struct.Table* %43, i64 0, i32 2
  %47 = load i8, i8* %46, align 1, !tbaa !146
  %48 = and i8 %47, 24
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %53, label %50

; <label>:50:                                     ; preds = %45
  %51 = bitcast %struct.Table* %43 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %51) #16
  %52 = load i8, i8* %8, align 1, !tbaa !70
  br label %53

; <label>:53:                                     ; preds = %45, %40, %50
  %54 = phi i8 [ %9, %45 ], [ %9, %40 ], [ %52, %50 ]
  %55 = or i8 %54, 32
  store i8 %55, i8* %8, align 1, !tbaa !70
  br label %62

; <label>:56:                                     ; preds = %5, %5, %5, %5, %5, %35
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  %58 = bitcast %struct.GCObject** %57 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !227
  %60 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %7) #16
  %61 = bitcast %struct.GCObject** %60 to i64*
  store i64 %59, i64* %61, align 8, !tbaa !54
  store %struct.GCObject* %7, %struct.GCObject** %57, align 8, !tbaa !227
  br label %62

; <label>:62:                                     ; preds = %23, %28, %5, %53, %56, %12
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @markmt(%struct.global_State*) unnamed_addr #0 {
  br label %2

; <label>:2:                                      ; preds = %14, %1
  %3 = phi i64 [ 0, %1 ], [ %15, %14 ]
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 41, i64 %3
  %5 = load %struct.Table*, %struct.Table** %4, align 8, !tbaa !54
  %6 = icmp eq %struct.Table* %5, null
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.Table, %struct.Table* %5, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !146
  %10 = and i8 %9, 24
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %14, label %12

; <label>:12:                                     ; preds = %7
  %13 = bitcast %struct.Table* %5 to %struct.GCObject*
  tail call fastcc void @reallymarkobject(%struct.global_State* nonnull %0, %struct.GCObject* %13) #16
  br label %14

; <label>:14:                                     ; preds = %7, %2, %12
  %15 = add nuw nsw i64 %3, 1
  %16 = icmp eq i64 %15, 9
  br i1 %16, label %17, label %2

; <label>:17:                                     ; preds = %14
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @markbeingfnz(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 28
  %3 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !54
  %4 = icmp eq %struct.GCObject* %3, null
  br i1 %4, label %19, label %5

; <label>:5:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %5, %15
  %7 = phi %struct.GCObject* [ %17, %15 ], [ %3, %5 ]
  %8 = phi i64 [ %9, %15 ], [ 0, %5 ]
  %9 = add i64 %8, 1
  %10 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %11 = load i8, i8* %10, align 1, !tbaa !70
  %12 = and i8 %11, 24
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %15, label %14

; <label>:14:                                     ; preds = %6
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %7) #16
  br label %15

; <label>:15:                                     ; preds = %6, %14
  %16 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %17 = load %struct.GCObject*, %struct.GCObject** %16, align 8, !tbaa !54
  %18 = icmp eq %struct.GCObject* %17, null
  br i1 %18, label %19, label %6

; <label>:19:                                     ; preds = %15, %1
  %20 = phi i64 [ 0, %1 ], [ %9, %15 ]
  ret i64 %20
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.GCObject** @getgclist(%struct.GCObject* readonly) unnamed_addr #3 {
  %2 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 0, i32 1
  %3 = load i8, i8* %2, align 8, !tbaa !86
  switch i8 %3, label %18 [
    i8 5, label %4
    i8 22, label %6
    i8 54, label %8
    i8 8, label %10
    i8 10, label %13
    i8 7, label %16
  ]

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 3, i32 0
  br label %18

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 1, i32 0
  br label %18

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 4, i32 1
  %12 = bitcast i8* %11 to %struct.GCObject**
  br label %18

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 7, i32 1
  %15 = bitcast i8* %14 to %struct.GCObject**
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %0, i64 2, i32 0
  br label %18

; <label>:18:                                     ; preds = %1, %16, %13, %10, %8, %6, %4
  %19 = phi %struct.GCObject** [ %17, %16 ], [ %15, %13 ], [ %12, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ null, %1 ]
  ret %struct.GCObject** %19
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @traverseephemeron(%struct.global_State*, %struct.Table*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %4 = load %union.Node*, %union.Node** %3, align 8, !tbaa !156
  %5 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %6 = load i8, i8* %5, align 1, !tbaa !93
  %7 = zext i8 %6 to i32
  %8 = shl i32 1, %7
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds %union.Node, %union.Node* %4, i64 %9
  %11 = tail call fastcc i32 @luaH_realasize(%struct.Table* %1) #16
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %38, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  %15 = zext i32 %11 to i64
  br label %16

; <label>:16:                                     ; preds = %32, %13
  %17 = phi i64 [ 0, %13 ], [ %34, %32 ]
  %18 = phi i32 [ 0, %13 ], [ %33, %32 ]
  %19 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !91
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %17, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 64
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %32, label %24

; <label>:24:                                     ; preds = %16
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 %17, i32 0, i32 0
  %26 = load %struct.GCObject*, %struct.GCObject** %25, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %26, i64 0, i32 2
  %28 = load i8, i8* %27, align 1, !tbaa !70
  %29 = and i8 %28, 24
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %32, label %31

; <label>:31:                                     ; preds = %24
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %26) #16
  br label %32

; <label>:32:                                     ; preds = %24, %16, %31
  %33 = phi i32 [ 1, %31 ], [ %18, %24 ], [ %18, %16 ]
  %34 = add nuw nsw i64 %17, 1
  %35 = icmp eq i64 %34, %15
  br i1 %35, label %36, label %16

; <label>:36:                                     ; preds = %32
  %37 = load %union.Node*, %union.Node** %3, align 8, !tbaa !156
  br label %38

; <label>:38:                                     ; preds = %36, %2
  %39 = phi %union.Node* [ %4, %2 ], [ %37, %36 ]
  %40 = phi i32 [ 0, %2 ], [ %33, %36 ]
  %41 = icmp ult %union.Node* %39, %10
  br i1 %41, label %42, label %100

; <label>:42:                                     ; preds = %38
  br label %43

; <label>:43:                                     ; preds = %42, %94
  %44 = phi i32 [ %97, %94 ], [ %40, %42 ]
  %45 = phi i32 [ %96, %94 ], [ 0, %42 ]
  %46 = phi %union.Node* [ %98, %94 ], [ %39, %42 ]
  %47 = phi i32 [ %95, %94 ], [ 0, %42 ]
  %48 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 1
  %49 = load i8, i8* %48, align 8, !tbaa !21
  %50 = and i8 %49, 15
  %51 = icmp eq i8 %50, 0
  %52 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !21
  %54 = and i8 %53, 64
  %55 = icmp eq i8 %54, 0
  br i1 %51, label %56, label %65

; <label>:56:                                     ; preds = %43
  br i1 %55, label %94, label %57

; <label>:57:                                     ; preds = %56
  %58 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 4, i32 0
  %59 = load %struct.GCObject*, %struct.GCObject** %58, align 8, !tbaa !21
  %60 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %59, i64 0, i32 2
  %61 = load i8, i8* %60, align 1, !tbaa !70
  %62 = and i8 %61, 24
  %63 = icmp eq i8 %62, 0
  br i1 %63, label %94, label %64

; <label>:64:                                     ; preds = %57
  store i8 5, i8* %52, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %58, align 8, !tbaa !21
  br label %94

; <label>:65:                                     ; preds = %43
  br i1 %55, label %69, label %66

; <label>:66:                                     ; preds = %65
  %67 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 4, i32 0
  %68 = load %struct.GCObject*, %struct.GCObject** %67, align 8, !tbaa !21
  br label %69

; <label>:69:                                     ; preds = %65, %66
  %70 = phi %struct.GCObject* [ %68, %66 ], [ null, %65 ]
  %71 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %70) #16
  %72 = icmp eq i32 %71, 0
  %73 = load i8, i8* %48, align 8, !tbaa !21
  %74 = and i8 %73, 64
  %75 = icmp eq i8 %74, 0
  br i1 %72, label %85, label %76

; <label>:76:                                     ; preds = %69
  br i1 %75, label %94, label %77

; <label>:77:                                     ; preds = %76
  %78 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 0, i32 0
  %79 = load %struct.GCObject*, %struct.GCObject** %78, align 8, !tbaa !21
  %80 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %79, i64 0, i32 2
  %81 = load i8, i8* %80, align 1, !tbaa !70
  %82 = and i8 %81, 24
  %83 = icmp eq i8 %82, 0
  %84 = select i1 %83, i32 %47, i32 1
  br label %94

; <label>:85:                                     ; preds = %69
  br i1 %75, label %94, label %86

; <label>:86:                                     ; preds = %85
  %87 = getelementptr inbounds %union.Node, %union.Node* %46, i64 0, i32 0, i32 0, i32 0
  %88 = load %struct.GCObject*, %struct.GCObject** %87, align 8, !tbaa !21
  %89 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %88, i64 0, i32 2
  %90 = load i8, i8* %89, align 1, !tbaa !70
  %91 = and i8 %90, 24
  %92 = icmp eq i8 %91, 0
  br i1 %92, label %94, label %93

; <label>:93:                                     ; preds = %86
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* %88) #16
  br label %94

; <label>:94:                                     ; preds = %64, %57, %56, %77, %76, %86, %85, %93
  %95 = phi i32 [ %47, %76 ], [ %47, %93 ], [ %47, %86 ], [ %47, %85 ], [ %84, %77 ], [ %47, %56 ], [ %47, %57 ], [ %47, %64 ]
  %96 = phi i32 [ 1, %76 ], [ %45, %93 ], [ %45, %86 ], [ %45, %85 ], [ 1, %77 ], [ %45, %56 ], [ %45, %57 ], [ %45, %64 ]
  %97 = phi i32 [ %44, %76 ], [ 1, %93 ], [ %44, %86 ], [ %44, %85 ], [ %44, %77 ], [ %44, %56 ], [ %44, %57 ], [ %44, %64 ]
  %98 = getelementptr inbounds %union.Node, %union.Node* %46, i64 1
  %99 = icmp ult %union.Node* %98, %10
  br i1 %99, label %43, label %100

; <label>:100:                                    ; preds = %94, %38
  %101 = phi i32 [ 0, %38 ], [ %95, %94 ]
  %102 = phi i32 [ 0, %38 ], [ %96, %94 ]
  %103 = phi i32 [ %40, %38 ], [ %97, %94 ]
  %104 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 11
  %105 = load i8, i8* %104, align 1, !tbaa !42
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %107, label %114

; <label>:107:                                    ; preds = %100
  %108 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %109 = bitcast %struct.GCObject** %108 to i64*
  %110 = load i64, i64* %109, align 8, !tbaa !157
  %111 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %112 = bitcast %struct.GCObject** %111 to i64*
  store i64 %110, i64* %112, align 8, !tbaa !231
  %113 = bitcast %struct.GCObject** %108 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %113, align 8, !tbaa !157
  br label %147

; <label>:114:                                    ; preds = %100
  %115 = icmp eq i32 %101, 0
  br i1 %115, label %123, label %116

; <label>:116:                                    ; preds = %114
  %117 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  %118 = bitcast %struct.GCObject** %117 to i64*
  %119 = load i64, i64* %118, align 8, !tbaa !230
  %120 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %121 = bitcast %struct.GCObject** %120 to i64*
  store i64 %119, i64* %121, align 8, !tbaa !231
  %122 = bitcast %struct.GCObject** %117 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %122, align 8, !tbaa !230
  br label %147

; <label>:123:                                    ; preds = %114
  %124 = icmp eq i32 %102, 0
  br i1 %124, label %132, label %125

; <label>:125:                                    ; preds = %123
  %126 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 27
  %127 = bitcast %struct.GCObject** %126 to i64*
  %128 = load i64, i64* %127, align 8, !tbaa !229
  %129 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %130 = bitcast %struct.GCObject** %129 to i64*
  store i64 %128, i64* %130, align 8, !tbaa !231
  %131 = bitcast %struct.GCObject** %126 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %131, align 8, !tbaa !229
  br label %147

; <label>:132:                                    ; preds = %123
  %133 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 12
  %134 = load i8, i8* %133, align 2, !tbaa !40
  %135 = icmp eq i8 %134, 1
  br i1 %135, label %136, label %143

; <label>:136:                                    ; preds = %132
  %137 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 24
  %138 = bitcast %struct.GCObject** %137 to i64*
  %139 = load i64, i64* %138, align 8, !tbaa !157
  %140 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 10
  %141 = bitcast %struct.GCObject** %140 to i64*
  store i64 %139, i64* %141, align 8, !tbaa !231
  %142 = bitcast %struct.GCObject** %137 to %struct.Table**
  store %struct.Table* %1, %struct.Table** %142, align 8, !tbaa !157
  br label %147

; <label>:143:                                    ; preds = %132
  %144 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %145 = load i8, i8* %144, align 1, !tbaa !146
  %146 = or i8 %145, 32
  store i8 %146, i8* %144, align 1, !tbaa !146
  br label %147

; <label>:147:                                    ; preds = %116, %136, %143, %125, %107
  ret i32 %103
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @iscleared(%struct.global_State*, %struct.GCObject*) unnamed_addr #0 {
  %3 = icmp eq %struct.GCObject* %1, null
  br i1 %3, label %17, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !86
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 4
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %1, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !70
  %11 = and i8 %10, 24
  br i1 %8, label %12, label %15

; <label>:12:                                     ; preds = %4
  %13 = icmp eq i8 %11, 0
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %12
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %1) #16
  br label %17

; <label>:15:                                     ; preds = %4
  %16 = zext i8 %11 to i32
  br label %17

; <label>:17:                                     ; preds = %14, %12, %2, %15
  %18 = phi i32 [ %16, %15 ], [ 0, %2 ], [ 0, %12 ], [ 0, %14 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_shrinkstack(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !54
  %6 = icmp eq %struct.CallInfo* %5, null
  br i1 %6, label %18, label %7

; <label>:7:                                      ; preds = %1
  br label %8

; <label>:8:                                      ; preds = %7, %8
  %9 = phi %struct.CallInfo* [ %16, %8 ], [ %5, %7 ]
  %10 = phi %union.StackValue* [ %14, %8 ], [ %3, %7 ]
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 1
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !66
  %13 = icmp ult %union.StackValue* %10, %12
  %14 = select i1 %13, %union.StackValue* %12, %union.StackValue* %10
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 2
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !54
  %17 = icmp eq %struct.CallInfo* %16, null
  br i1 %17, label %18, label %8

; <label>:18:                                     ; preds = %8, %1
  %19 = phi %union.StackValue* [ %3, %1 ], [ %14, %8 ]
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !23
  %23 = ptrtoint %union.StackValue* %19 to i64
  %24 = sub i64 %23, %22
  %25 = lshr exact i64 %24, 4
  %26 = trunc i64 %25 to i32
  %27 = add nsw i32 %26, 1
  %28 = sdiv i32 %27, 8
  %29 = add i32 %26, 11
  %30 = add i32 %29, %28
  %31 = icmp slt i32 %30, 1000000
  %32 = select i1 %31, i32 %30, i32 1000000
  %33 = icmp slt i32 %26, 999995
  br i1 %33, label %34, label %41

; <label>:34:                                     ; preds = %18
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %36 = load i32, i32* %35, align 4, !tbaa !26
  %37 = icmp slt i32 %32, %36
  br i1 %37, label %38, label %41

; <label>:38:                                     ; preds = %34
  %39 = tail call fastcc i32 @luaD_reallocstack(%struct.lua_State* nonnull %0, i32 %32, i32 0) #16
  %40 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  br label %41

; <label>:41:                                     ; preds = %18, %34, %38
  %42 = phi %struct.CallInfo* [ %5, %18 ], [ %5, %34 ], [ %40, %38 ]
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %44 = load i16, i16* %43, align 4, !tbaa !25
  %45 = zext i16 %44 to i32
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %47 = load i32, i32* %46, align 8, !tbaa !29
  %48 = sub i32 %47, %45
  store i32 %48, i32* %46, align 8, !tbaa !29
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 3
  %50 = load %struct.CallInfo*, %struct.CallInfo** %49, align 8, !tbaa !117
  %51 = icmp eq %struct.CallInfo* %50, null
  br i1 %51, label %84, label %52

; <label>:52:                                     ; preds = %41
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %54

; <label>:54:                                     ; preds = %62, %52
  %55 = phi i16 [ %44, %52 ], [ %75, %62 ]
  %56 = phi %struct.CallInfo* [ %50, %52 ], [ %78, %62 ]
  %57 = phi %struct.CallInfo** [ %49, %52 ], [ %77, %62 ]
  %58 = phi %struct.CallInfo* [ %42, %52 ], [ %60, %62 ]
  %59 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %56, i64 0, i32 3
  %60 = load %struct.CallInfo*, %struct.CallInfo** %59, align 8, !tbaa !117
  %61 = icmp eq %struct.CallInfo* %60, null
  br i1 %61, label %80, label %62

; <label>:62:                                     ; preds = %54
  %63 = bitcast %struct.CallInfo** %57 to i8**
  %64 = load i8*, i8** %63, align 8, !tbaa !117
  %65 = load %struct.global_State*, %struct.global_State** %53, align 8, !tbaa !2
  %66 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 0
  %67 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %66, align 8, !tbaa !59
  %68 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 1
  %69 = load i8*, i8** %68, align 8, !tbaa !60
  %70 = tail call i8* %67(i8* %69, i8* %64, i64 64, i64 0) #17
  %71 = getelementptr inbounds %struct.global_State, %struct.global_State* %65, i64 0, i32 3
  %72 = load i64, i64* %71, align 8, !tbaa !11
  %73 = add i64 %72, -64
  store i64 %73, i64* %71, align 8, !tbaa !11
  %74 = load i16, i16* %43, align 4, !tbaa !25
  %75 = add i16 %74, -1
  store i16 %75, i16* %43, align 4, !tbaa !25
  store %struct.CallInfo* %60, %struct.CallInfo** %57, align 8, !tbaa !117
  %76 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %60, i64 0, i32 2
  store %struct.CallInfo* %58, %struct.CallInfo** %76, align 8, !tbaa !105
  %77 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %60, i64 0, i32 3
  %78 = load %struct.CallInfo*, %struct.CallInfo** %77, align 8, !tbaa !117
  %79 = icmp eq %struct.CallInfo* %78, null
  br i1 %79, label %80, label %54

; <label>:80:                                     ; preds = %62, %54
  %81 = phi i16 [ %55, %54 ], [ %75, %62 ]
  %82 = load i32, i32* %46, align 8, !tbaa !29
  %83 = zext i16 %81 to i32
  br label %84

; <label>:84:                                     ; preds = %41, %80
  %85 = phi i32 [ %83, %80 ], [ %45, %41 ]
  %86 = phi i32 [ %82, %80 ], [ %48, %41 ]
  %87 = add i32 %86, %85
  store i32 %87, i32* %46, align 8, !tbaa !29
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaD_reallocstack(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 20
  %5 = load i32, i32* %4, align 4, !tbaa !26
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !23
  %9 = sext i32 %5 to i64
  %10 = shl nsw i64 %9, 4
  %11 = sext i32 %1 to i64
  %12 = shl nsw i64 %11, 4
  %13 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %8, i64 %10, i64 %12) #16
  %14 = bitcast i8* %13 to %union.StackValue*
  %15 = icmp eq i8* %13, null
  br i1 %15, label %16, label %19, !prof !61

; <label>:16:                                     ; preds = %3
  %17 = icmp eq i32 %2, 0
  br i1 %17, label %87, label %18

; <label>:18:                                     ; preds = %16
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:19:                                     ; preds = %3
  %20 = icmp slt i32 %5, %1
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %19
  br label %22

; <label>:22:                                     ; preds = %21, %22
  %23 = phi i64 [ %25, %22 ], [ %9, %21 ]
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %23, i32 0, i32 1
  store i8 0, i8* %24, align 8, !tbaa !21
  %25 = add nsw i64 %23, 1
  %26 = icmp eq i64 %25, %11
  br i1 %26, label %27, label %22

; <label>:27:                                     ; preds = %22, %19
  %28 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !23
  %29 = icmp eq %union.StackValue* %28, %14
  br i1 %29, label %83, label %30

; <label>:30:                                     ; preds = %27
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = bitcast %union.StackValue** %31 to i64*
  %33 = load i64, i64* %32, align 8, !tbaa !20
  %34 = ptrtoint %union.StackValue* %28 to i64
  %35 = sub i64 %33, %34
  %36 = ashr exact i64 %35, 4
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %36
  store %union.StackValue* %37, %union.StackValue** %31, align 8, !tbaa !20
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %39 = load %struct.UpVal*, %struct.UpVal** %38, align 8, !tbaa !21
  %40 = icmp eq %struct.UpVal* %39, null
  br i1 %40, label %53, label %41

; <label>:41:                                     ; preds = %30
  br label %42

; <label>:42:                                     ; preds = %41, %42
  %43 = phi %struct.UpVal* [ %51, %42 ], [ %39, %41 ]
  %44 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %43, i64 0, i32 3
  %45 = bitcast %struct.TValue** %44 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !67
  %47 = sub i64 %46, %34
  %48 = ashr exact i64 %47, 4
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %48, i32 0
  store %struct.TValue* %49, %struct.TValue** %44, align 8, !tbaa !67
  %50 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %43, i64 0, i32 4, i32 0, i32 0
  %51 = load %struct.UpVal*, %struct.UpVal** %50, align 8, !tbaa !21
  %52 = icmp eq %struct.UpVal* %51, null
  br i1 %52, label %53, label %42

; <label>:53:                                     ; preds = %42, %30
  %54 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %55 = load %struct.CallInfo*, %struct.CallInfo** %54, align 8, !tbaa !54
  %56 = icmp eq %struct.CallInfo* %55, null
  br i1 %56, label %83, label %57

; <label>:57:                                     ; preds = %53
  br label %58

; <label>:58:                                     ; preds = %57, %79
  %59 = phi %struct.CallInfo* [ %81, %79 ], [ %55, %57 ]
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 1
  %61 = bitcast %union.StackValue** %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !66
  %63 = sub i64 %62, %34
  %64 = ashr exact i64 %63, 4
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %64
  store %union.StackValue* %65, %union.StackValue** %60, align 8, !tbaa !66
  %66 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 0
  %67 = bitcast %struct.CallInfo* %59 to i64*
  %68 = load i64, i64* %67, align 8, !tbaa !64
  %69 = sub i64 %68, %34
  %70 = ashr exact i64 %69, 4
  %71 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %70
  store %union.StackValue* %71, %union.StackValue** %66, align 8, !tbaa !64
  %72 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 7
  %73 = load i16, i16* %72, align 2, !tbaa !63
  %74 = and i16 %73, 2
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %76, label %79

; <label>:76:                                     ; preds = %58
  %77 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 4, i32 0, i32 1
  %78 = bitcast i64* %77 to i32*
  store i32 1, i32* %78, align 8, !tbaa !21
  br label %79

; <label>:79:                                     ; preds = %76, %58
  %80 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %59, i64 0, i32 2
  %81 = load %struct.CallInfo*, %struct.CallInfo** %80, align 8, !tbaa !54
  %82 = icmp eq %struct.CallInfo* %81, null
  br i1 %82, label %83, label %58

; <label>:83:                                     ; preds = %79, %27, %53
  store i8* %13, i8** %7, align 8, !tbaa !23
  store i32 %1, i32* %4, align 4, !tbaa !26
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 %11
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 -5
  %86 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  store %union.StackValue* %85, %union.StackValue** %86, align 8, !tbaa !62
  br label %87

; <label>:87:                                     ; preds = %16, %83
  %88 = phi i32 [ 1, %83 ], [ 0, %16 ]
  ret i32 %88
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaM_realloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 0
  %8 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %7, align 8, !tbaa !59
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !60
  %11 = tail call i8* %8(i8* %10, i8* %1, i64 %2, i64 %3) #17
  %12 = icmp eq i8* %11, null
  %13 = icmp ne i64 %3, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %20, !prof !61

; <label>:15:                                     ; preds = %4
  %16 = icmp ugt i64 %3, %2
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %15
  %18 = tail call fastcc i8* @tryagain(%struct.lua_State* nonnull %0, i8* %1, i64 %2, i64 %3) #16
  %19 = icmp eq i8* %18, null
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %17, %4
  %21 = phi i8* [ %18, %17 ], [ %11, %4 ]
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 3
  %23 = load i64, i64* %22, align 8, !tbaa !11
  %24 = sub i64 %3, %2
  %25 = add i64 %24, %23
  store i64 %25, i64* %22, align 8, !tbaa !11
  br label %26

; <label>:26:                                     ; preds = %15, %17, %20
  %27 = phi i8* [ %21, %20 ], [ null, %17 ], [ null, %15 ]
  ret i8* %27
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.GCObject** @sweeplist(%struct.lua_State* nocapture readonly, %struct.GCObject**, i32, i32*) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 10
  %8 = load i8, i8* %7, align 4, !tbaa !15
  %9 = xor i8 %8, 24
  %10 = and i8 %8, 24
  %11 = load %struct.GCObject*, %struct.GCObject** %1, align 8, !tbaa !54
  %12 = icmp ne %struct.GCObject* %11, null
  %13 = icmp sgt i32 %2, 0
  %14 = and i1 %13, %12
  br i1 %14, label %15, label %39

; <label>:15:                                     ; preds = %4
  br label %16

; <label>:16:                                     ; preds = %15, %32
  %17 = phi %struct.GCObject* [ %35, %32 ], [ %11, %15 ]
  %18 = phi %struct.GCObject** [ %33, %32 ], [ %1, %15 ]
  %19 = phi i32 [ %34, %32 ], [ 0, %15 ]
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %17, i64 0, i32 2
  %21 = load i8, i8* %20, align 1, !tbaa !70
  %22 = and i8 %21, %9
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %16
  %25 = bitcast %struct.GCObject* %17 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !87
  %27 = bitcast %struct.GCObject** %18 to i64*
  store i64 %26, i64* %27, align 8, !tbaa !54
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %17) #16
  br label %32

; <label>:28:                                     ; preds = %16
  %29 = and i8 %21, -64
  %30 = or i8 %29, %10
  store i8 %30, i8* %20, align 1, !tbaa !70
  %31 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %17, i64 0, i32 0
  br label %32

; <label>:32:                                     ; preds = %28, %24
  %33 = phi %struct.GCObject** [ %18, %24 ], [ %31, %28 ]
  %34 = add nuw nsw i32 %19, 1
  %35 = load %struct.GCObject*, %struct.GCObject** %33, align 8, !tbaa !54
  %36 = icmp ne %struct.GCObject* %35, null
  %37 = icmp slt i32 %34, %2
  %38 = and i1 %37, %36
  br i1 %38, label %16, label %39

; <label>:39:                                     ; preds = %32, %4
  %40 = phi i32 [ 0, %4 ], [ %34, %32 ]
  %41 = phi %struct.GCObject** [ %1, %4 ], [ %33, %32 ]
  %42 = phi %struct.GCObject* [ %11, %4 ], [ %35, %32 ]
  %43 = icmp eq i32* %3, null
  br i1 %43, label %45, label %44

; <label>:44:                                     ; preds = %39
  store i32 %40, i32* %3, align 4, !tbaa !77
  br label %45

; <label>:45:                                     ; preds = %39, %44
  %46 = icmp eq %struct.GCObject* %42, null
  %47 = select i1 %46, %struct.GCObject** null, %struct.GCObject** %41
  ret %struct.GCObject** %47
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaS_resize(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 6, i32 2
  %7 = load i32, i32* %6, align 4, !tbaa !95
  %8 = icmp sgt i32 %7, %1
  %9 = getelementptr inbounds %struct.stringtable, %struct.stringtable* %5, i64 0, i32 0
  br i1 %8, label %10, label %12

; <label>:10:                                     ; preds = %2
  %11 = load %struct.TString**, %struct.TString*** %9, align 8, !tbaa !94
  tail call fastcc void @tablerehash(%struct.TString** %11, i32 %7, i32 %1) #16
  br label %12

; <label>:12:                                     ; preds = %2, %10
  %13 = bitcast %struct.stringtable* %5 to i8**
  %14 = load i8*, i8** %13, align 8, !tbaa !94
  %15 = sext i32 %7 to i64
  %16 = shl nsw i64 %15, 3
  %17 = sext i32 %1 to i64
  %18 = shl nsw i64 %17, 3
  %19 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* nonnull %0, i8* %14, i64 %16, i64 %18) #16
  %20 = bitcast i8* %19 to %struct.TString**
  %21 = icmp eq i8* %19, null
  br i1 %21, label %22, label %25, !prof !61

; <label>:22:                                     ; preds = %12
  br i1 %8, label %23, label %28

; <label>:23:                                     ; preds = %22
  %24 = load %struct.TString**, %struct.TString*** %9, align 8, !tbaa !94
  tail call fastcc void @tablerehash(%struct.TString** %24, i32 %1, i32 %7) #16
  br label %28

; <label>:25:                                     ; preds = %12
  store i8* %19, i8** %13, align 8, !tbaa !94
  store i32 %1, i32* %6, align 4, !tbaa !95
  %26 = icmp slt i32 %7, %1
  br i1 %26, label %27, label %28

; <label>:27:                                     ; preds = %25
  tail call fastcc void @tablerehash(%struct.TString** %20, i32 %7, i32 %1) #16
  br label %28

; <label>:28:                                     ; preds = %25, %27, %22, %23
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @convergeephemerons(%struct.global_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 26
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %0, i64 0, i32 23
  br label %4

; <label>:4:                                      ; preds = %27, %1
  %5 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !230
  store %struct.GCObject* null, %struct.GCObject** %2, align 8, !tbaa !230
  %6 = icmp eq %struct.GCObject* %5, null
  br i1 %6, label %29, label %7

; <label>:7:                                      ; preds = %4
  br label %8

; <label>:8:                                      ; preds = %7, %24
  %9 = phi %struct.GCObject* [ %13, %24 ], [ %5, %7 ]
  %10 = phi i32 [ %25, %24 ], [ 0, %7 ]
  %11 = bitcast %struct.GCObject* %9 to %struct.Table*
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %9, i64 3, i32 0
  %13 = load %struct.GCObject*, %struct.GCObject** %12, align 8, !tbaa !21
  %14 = tail call fastcc i32 @traverseephemeron(%struct.global_State* %0, %struct.Table* %11) #16
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %24, label %16

; <label>:16:                                     ; preds = %8
  %17 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !227
  %18 = icmp eq %struct.GCObject* %17, null
  br i1 %18, label %24, label %19

; <label>:19:                                     ; preds = %16
  br label %20

; <label>:20:                                     ; preds = %19, %20
  %21 = tail call fastcc i64 @propagatemark(%struct.global_State* nonnull %0) #17
  %22 = load %struct.GCObject*, %struct.GCObject** %3, align 8, !tbaa !227
  %23 = icmp eq %struct.GCObject* %22, null
  br i1 %23, label %24, label %20

; <label>:24:                                     ; preds = %20, %16, %8
  %25 = phi i32 [ %10, %8 ], [ 1, %16 ], [ 1, %20 ]
  %26 = icmp eq %struct.GCObject* %13, null
  br i1 %26, label %27, label %8

; <label>:27:                                     ; preds = %24
  %28 = icmp eq i32 %25, 0
  br i1 %28, label %29, label %4

; <label>:29:                                     ; preds = %4, %27
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @clearbyvalues(%struct.global_State*, %struct.GCObject* readonly, %struct.GCObject* readnone) unnamed_addr #0 {
  %4 = icmp eq %struct.GCObject* %1, %2
  br i1 %4, label %86, label %5

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %82
  %7 = phi %struct.GCObject* [ %84, %82 ], [ %1, %5 ]
  %8 = bitcast %struct.GCObject* %7 to %struct.Table*
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1, i32 1
  %10 = bitcast i8* %9 to %union.Node**
  %11 = load %union.Node*, %union.Node** %10, align 8, !tbaa !156
  %12 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 4
  %13 = load i8, i8* %12, align 1, !tbaa !93
  %14 = zext i8 %13 to i32
  %15 = shl i32 1, %14
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds %union.Node, %union.Node* %11, i64 %16
  %18 = tail call fastcc i32 @luaH_realasize(%struct.Table* %8) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %44, label %20

; <label>:20:                                     ; preds = %6
  %21 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 1
  %22 = bitcast %struct.GCObject* %21 to %struct.TValue**
  %23 = zext i32 %18 to i64
  br label %24

; <label>:24:                                     ; preds = %39, %20
  %25 = phi i64 [ 0, %20 ], [ %40, %39 ]
  %26 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !91
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 %25, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = and i8 %28, 64
  %30 = icmp eq i8 %29, 0
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %24
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 %25, i32 0, i32 0
  %33 = load %struct.GCObject*, %struct.GCObject** %32, align 8, !tbaa !21
  br label %34

; <label>:34:                                     ; preds = %24, %31
  %35 = phi %struct.GCObject* [ %33, %31 ], [ null, %24 ]
  %36 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %35) #16
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %39, label %38

; <label>:38:                                     ; preds = %34
  store i8 16, i8* %27, align 8, !tbaa !22
  br label %39

; <label>:39:                                     ; preds = %34, %38
  %40 = add nuw nsw i64 %25, 1
  %41 = icmp eq i64 %40, %23
  br i1 %41, label %42, label %24

; <label>:42:                                     ; preds = %39
  %43 = load %union.Node*, %union.Node** %10, align 8, !tbaa !156
  br label %44

; <label>:44:                                     ; preds = %42, %6
  %45 = phi %union.Node* [ %43, %42 ], [ %11, %6 ]
  %46 = icmp ult %union.Node* %45, %17
  br i1 %46, label %47, label %82

; <label>:47:                                     ; preds = %44
  br label %48

; <label>:48:                                     ; preds = %47, %79
  %49 = phi %union.Node* [ %80, %79 ], [ %45, %47 ]
  %50 = getelementptr inbounds %union.Node, %union.Node* %49, i64 0, i32 0, i32 1
  %51 = load i8, i8* %50, align 8, !tbaa !21
  %52 = and i8 %51, 64
  %53 = icmp eq i8 %52, 0
  br i1 %53, label %57, label %54

; <label>:54:                                     ; preds = %48
  %55 = getelementptr inbounds %union.Node, %union.Node* %49, i64 0, i32 0, i32 0, i32 0
  %56 = load %struct.GCObject*, %struct.GCObject** %55, align 8, !tbaa !21
  br label %57

; <label>:57:                                     ; preds = %48, %54
  %58 = phi %struct.GCObject* [ %56, %54 ], [ null, %48 ]
  %59 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %58) #16
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %62, label %61

; <label>:61:                                     ; preds = %57
  store i8 16, i8* %50, align 8, !tbaa !21
  br label %66

; <label>:62:                                     ; preds = %57
  %63 = load i8, i8* %50, align 8, !tbaa !21
  %64 = and i8 %63, 15
  %65 = icmp eq i8 %64, 0
  br i1 %65, label %66, label %79

; <label>:66:                                     ; preds = %61, %62
  %67 = getelementptr inbounds %union.Node, %union.Node* %49, i64 0, i32 0, i32 2
  %68 = load i8, i8* %67, align 1, !tbaa !21
  %69 = and i8 %68, 64
  %70 = icmp eq i8 %69, 0
  br i1 %70, label %79, label %71

; <label>:71:                                     ; preds = %66
  %72 = getelementptr inbounds %union.Node, %union.Node* %49, i64 0, i32 0, i32 4, i32 0
  %73 = load %struct.GCObject*, %struct.GCObject** %72, align 8, !tbaa !21
  %74 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %73, i64 0, i32 2
  %75 = load i8, i8* %74, align 1, !tbaa !70
  %76 = and i8 %75, 24
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %79, label %78

; <label>:78:                                     ; preds = %71
  store i8 5, i8* %67, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %72, align 8, !tbaa !21
  br label %79

; <label>:79:                                     ; preds = %78, %71, %66, %62
  %80 = getelementptr inbounds %union.Node, %union.Node* %49, i64 1
  %81 = icmp ult %union.Node* %80, %17
  br i1 %81, label %48, label %82

; <label>:82:                                     ; preds = %79, %44
  %83 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 3, i32 0
  %84 = load %struct.GCObject*, %struct.GCObject** %83, align 8, !tbaa !21
  %85 = icmp eq %struct.GCObject* %84, %2
  br i1 %85, label %86, label %6

; <label>:86:                                     ; preds = %82, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @clearbykeys(%struct.global_State*, %struct.GCObject* readonly) unnamed_addr #0 {
  %3 = icmp eq %struct.GCObject* %1, null
  br i1 %3, label %57, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %53
  %6 = phi %struct.GCObject* [ %55, %53 ], [ %1, %4 ]
  %7 = bitcast %struct.GCObject* %6 to %struct.Table*
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 1, i32 1
  %9 = bitcast i8* %8 to %union.Node**
  %10 = load %union.Node*, %union.Node** %9, align 8, !tbaa !156
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %7, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !93
  %13 = zext i8 %12 to i32
  %14 = shl i32 1, %13
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds %union.Node, %union.Node* %10, i64 %15
  %17 = icmp eq i8 %12, 31
  br i1 %17, label %53, label %18

; <label>:18:                                     ; preds = %5
  br label %19

; <label>:19:                                     ; preds = %18, %50
  %20 = phi %union.Node* [ %51, %50 ], [ %10, %18 ]
  %21 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 2
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = and i8 %22, 64
  %24 = icmp eq i8 %23, 0
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %19
  %26 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 4, i32 0
  %27 = load %struct.GCObject*, %struct.GCObject** %26, align 8, !tbaa !21
  br label %28

; <label>:28:                                     ; preds = %19, %25
  %29 = phi %struct.GCObject* [ %27, %25 ], [ null, %19 ]
  %30 = tail call fastcc i32 @iscleared(%struct.global_State* %0, %struct.GCObject* %29) #16
  %31 = icmp eq i32 %30, 0
  %32 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 1
  br i1 %31, label %34, label %33

; <label>:33:                                     ; preds = %28
  store i8 16, i8* %32, align 8, !tbaa !21
  br label %38

; <label>:34:                                     ; preds = %28
  %35 = load i8, i8* %32, align 8, !tbaa !21
  %36 = and i8 %35, 15
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %50

; <label>:38:                                     ; preds = %33, %34
  %39 = load i8, i8* %21, align 1, !tbaa !21
  %40 = and i8 %39, 64
  %41 = icmp eq i8 %40, 0
  br i1 %41, label %50, label %42

; <label>:42:                                     ; preds = %38
  %43 = getelementptr inbounds %union.Node, %union.Node* %20, i64 0, i32 0, i32 4, i32 0
  %44 = load %struct.GCObject*, %struct.GCObject** %43, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %44, i64 0, i32 2
  %46 = load i8, i8* %45, align 1, !tbaa !70
  %47 = and i8 %46, 24
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %50, label %49

; <label>:49:                                     ; preds = %42
  store i8 5, i8* %21, align 1, !tbaa !21
  store %struct.GCObject* null, %struct.GCObject** %43, align 8, !tbaa !21
  br label %50

; <label>:50:                                     ; preds = %49, %42, %38, %34
  %51 = getelementptr inbounds %union.Node, %union.Node* %20, i64 1
  %52 = icmp ult %union.Node* %51, %16
  br i1 %52, label %19, label %53

; <label>:53:                                     ; preds = %50, %5
  %54 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 3, i32 0
  %55 = load %struct.GCObject*, %struct.GCObject** %54, align 8, !tbaa !21
  %56 = icmp eq %struct.GCObject* %55, null
  br i1 %56, label %57, label %5

; <label>:57:                                     ; preds = %53, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @sweep2old(%struct.lua_State*, %struct.GCObject** nocapture) unnamed_addr #0 {
  %3 = load %struct.GCObject*, %struct.GCObject** %1, align 8, !tbaa !54
  %4 = icmp eq %struct.GCObject* %3, null
  br i1 %4, label %25, label %5

; <label>:5:                                      ; preds = %2
  br label %6

; <label>:6:                                      ; preds = %5, %21
  %7 = phi %struct.GCObject* [ %23, %21 ], [ %3, %5 ]
  %8 = phi %struct.GCObject** [ %22, %21 ], [ %1, %5 ]
  %9 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %10 = load i8, i8* %9, align 1, !tbaa !70
  %11 = and i8 %10, 24
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %6
  %14 = bitcast %struct.GCObject* %7 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !87
  %16 = bitcast %struct.GCObject** %8 to i64*
  store i64 %15, i64* %16, align 8, !tbaa !54
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %7) #16
  br label %21

; <label>:17:                                     ; preds = %6
  %18 = and i8 %10, -8
  %19 = or i8 %18, 4
  store i8 %19, i8* %9, align 1, !tbaa !70
  %20 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  br label %21

; <label>:21:                                     ; preds = %17, %13
  %22 = phi %struct.GCObject** [ %8, %13 ], [ %20, %17 ]
  %23 = load %struct.GCObject*, %struct.GCObject** %22, align 8, !tbaa !54
  %24 = icmp eq %struct.GCObject* %23, null
  br i1 %24, label %25, label %6

; <label>:25:                                     ; preds = %21, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @finishgencycle(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 24
  %4 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** nonnull %3) #17
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 25
  %6 = bitcast %struct.GCObject** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !228
  %8 = bitcast %struct.GCObject** %4 to i64*
  store i64 %7, i64* %8, align 8, !tbaa !54
  store %struct.GCObject* null, %struct.GCObject** %5, align 8, !tbaa !228
  %9 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %4) #17
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 27
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !229
  %13 = bitcast %struct.GCObject** %9 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !54
  store %struct.GCObject* null, %struct.GCObject** %10, align 8, !tbaa !229
  %14 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %9) #17
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 26
  %16 = bitcast %struct.GCObject** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !230
  %18 = bitcast %struct.GCObject** %14 to i64*
  store i64 %17, i64* %18, align 8, !tbaa !54
  store %struct.GCObject* null, %struct.GCObject** %15, align 8, !tbaa !230
  %19 = tail call fastcc %struct.GCObject** @correctgraylist(%struct.GCObject** %14) #17
  tail call fastcc void @checkSizes(%struct.lua_State* %0, %struct.global_State* %1) #16
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 11
  store i8 0, i8* %20, align 1, !tbaa !42
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 16
  %22 = load i8, i8* %21, align 2, !tbaa !81
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %34

; <label>:24:                                     ; preds = %2
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 28
  %28 = load %struct.GCObject*, %struct.GCObject** %27, align 8, !tbaa !101
  %29 = icmp eq %struct.GCObject* %28, null
  br i1 %29, label %34, label %30

; <label>:30:                                     ; preds = %24
  br label %31

; <label>:31:                                     ; preds = %30, %31
  tail call fastcc void @GCTM(%struct.lua_State* %0) #17
  %32 = load %struct.GCObject*, %struct.GCObject** %27, align 8, !tbaa !101
  %33 = icmp eq %struct.GCObject* %32, null
  br i1 %33, label %34, label %31

; <label>:34:                                     ; preds = %31, %24, %2
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc %struct.GCObject** @correctgraylist(%struct.GCObject**) unnamed_addr #2 {
  %2 = load %struct.GCObject*, %struct.GCObject** %0, align 8, !tbaa !54
  %3 = icmp eq %struct.GCObject* %2, null
  br i1 %3, label %55, label %4

; <label>:4:                                      ; preds = %1
  br label %5

; <label>:5:                                      ; preds = %4, %51
  %6 = phi %struct.GCObject* [ %52, %51 ], [ %2, %4 ]
  %7 = phi %struct.GCObject** [ %53, %51 ], [ %0, %4 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !86
  switch i8 %9, label %48 [
    i8 5, label %10
    i8 7, label %10
    i8 8, label %35
  ]

; <label>:10:                                     ; preds = %5, %5
  %11 = tail call fastcc %struct.GCObject** @getgclist(%struct.GCObject* nonnull %6) #16
  %12 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 2
  %13 = load i8, i8* %12, align 1, !tbaa !70
  %14 = zext i8 %13 to i32
  %15 = and i32 %14, 7
  %16 = icmp eq i32 %15, 5
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %10
  %18 = or i8 %13, 32
  %19 = xor i8 %18, 3
  store i8 %19, i8* %12, align 1, !tbaa !70
  br label %48

; <label>:20:                                     ; preds = %10
  %21 = and i32 %14, 24
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %30

; <label>:23:                                     ; preds = %20
  %24 = icmp eq i32 %15, 6
  br i1 %24, label %25, label %27

; <label>:25:                                     ; preds = %23
  %26 = xor i8 %13, 2
  store i8 %26, i8* %12, align 1, !tbaa !70
  br label %27

; <label>:27:                                     ; preds = %25, %23
  %28 = phi i8 [ %26, %25 ], [ %13, %23 ]
  %29 = or i8 %28, 32
  store i8 %29, i8* %12, align 1, !tbaa !70
  br label %30

; <label>:30:                                     ; preds = %20, %27
  %31 = bitcast %struct.GCObject** %11 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !54
  %33 = bitcast %struct.GCObject** %7 to i64*
  store i64 %32, i64* %33, align 8, !tbaa !54
  %34 = inttoptr i64 %32 to %struct.GCObject*
  br label %51

; <label>:35:                                     ; preds = %5
  %36 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 0, i32 2
  %37 = load i8, i8* %36, align 1, !tbaa !16
  %38 = and i8 %37, 24
  %39 = icmp eq i8 %38, 0
  %40 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %6, i64 4, i32 1
  br i1 %39, label %46, label %41

; <label>:41:                                     ; preds = %35
  %42 = bitcast i8* %40 to i64*
  %43 = load i64, i64* %42, align 8, !tbaa !235
  %44 = bitcast %struct.GCObject** %7 to i64*
  store i64 %43, i64* %44, align 8, !tbaa !54
  %45 = inttoptr i64 %43 to %struct.GCObject*
  br label %51

; <label>:46:                                     ; preds = %35
  %47 = bitcast i8* %40 to %struct.GCObject**
  br label %48

; <label>:48:                                     ; preds = %5, %17, %46
  %49 = phi %struct.GCObject** [ %47, %46 ], [ %11, %17 ], [ %7, %5 ]
  %50 = load %struct.GCObject*, %struct.GCObject** %49, align 8, !tbaa !54
  br label %51

; <label>:51:                                     ; preds = %48, %41, %30
  %52 = phi %struct.GCObject* [ %50, %48 ], [ %45, %41 ], [ %34, %30 ]
  %53 = phi %struct.GCObject** [ %49, %48 ], [ %7, %41 ], [ %7, %30 ]
  %54 = icmp eq %struct.GCObject* %52, null
  br i1 %54, label %55, label %5

; <label>:55:                                     ; preds = %51, %1
  %56 = phi %struct.GCObject** [ %0, %1 ], [ %53, %51 ]
  ret %struct.GCObject** %56
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @entergen(%struct.lua_State*, %struct.global_State*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 11
  %6 = load i8, i8* %5, align 1, !tbaa !42
  %7 = icmp eq i8 %6, 8
  br i1 %7, label %18, label %8

; <label>:8:                                      ; preds = %2
  br label %9

; <label>:9:                                      ; preds = %8, %9
  %10 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %11 = load i8, i8* %5, align 1, !tbaa !42
  %12 = icmp eq i8 %11, 8
  br i1 %12, label %13, label %9

; <label>:13:                                     ; preds = %9
  %14 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 11
  %16 = load i8, i8* %15, align 1, !tbaa !42
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %24, label %18

; <label>:18:                                     ; preds = %2, %13
  %19 = phi i8* [ %15, %13 ], [ %5, %2 ]
  br label %20

; <label>:20:                                     ; preds = %18, %20
  %21 = tail call fastcc i64 @singlestep(%struct.lua_State* %0) #17
  %22 = load i8, i8* %19, align 1, !tbaa !42
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %20

; <label>:24:                                     ; preds = %20, %13
  %25 = tail call fastcc i64 @atomic(%struct.lua_State* %0) #16
  tail call fastcc void @atomic2gen(%struct.lua_State* %0, %struct.global_State* %1) #16
  ret i64 %25
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @markold(%struct.global_State*, %struct.GCObject*, %struct.GCObject* readnone) unnamed_addr #0 {
  %4 = icmp eq %struct.GCObject* %1, %2
  br i1 %4, label %18, label %5

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %14
  %7 = phi %struct.GCObject* [ %16, %14 ], [ %1, %5 ]
  %8 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 2
  %9 = load i8, i8* %8, align 1, !tbaa !70
  %10 = and i8 %9, 39
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %6
  %13 = and i8 %9, -33
  store i8 %13, i8* %8, align 1, !tbaa !70
  tail call fastcc void @reallymarkobject(%struct.global_State* %0, %struct.GCObject* nonnull %7) #16
  br label %14

; <label>:14:                                     ; preds = %6, %12
  %15 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %7, i64 0, i32 0
  %16 = load %struct.GCObject*, %struct.GCObject** %15, align 8, !tbaa !87
  %17 = icmp eq %struct.GCObject* %16, %2
  br i1 %17, label %18, label %6

; <label>:18:                                     ; preds = %14, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.GCObject** @sweepgen(%struct.lua_State*, %struct.global_State* nocapture readonly, %struct.GCObject**, %struct.GCObject* readnone) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %1, i64 0, i32 10
  %6 = load i8, i8* %5, align 4, !tbaa !15
  %7 = and i8 %6, 24
  %8 = load %struct.GCObject*, %struct.GCObject** %2, align 8, !tbaa !54
  %9 = icmp eq %struct.GCObject* %8, %3
  br i1 %9, label %42, label %10

; <label>:10:                                     ; preds = %4
  br label %11

; <label>:11:                                     ; preds = %10, %38
  %12 = phi %struct.GCObject* [ %40, %38 ], [ %8, %10 ]
  %13 = phi %struct.GCObject** [ %39, %38 ], [ %2, %10 ]
  %14 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 2
  %15 = load i8, i8* %14, align 1, !tbaa !70
  %16 = zext i8 %15 to i32
  %17 = and i32 %16, 24
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %11
  %20 = bitcast %struct.GCObject* %12 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !87
  %22 = bitcast %struct.GCObject** %13 to i64*
  store i64 %21, i64* %22, align 8, !tbaa !54
  tail call fastcc void @freeobj(%struct.lua_State* %0, %struct.GCObject* nonnull %12) #16
  br label %38

; <label>:23:                                     ; preds = %11
  %24 = and i32 %16, 7
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %23
  %27 = and i8 %15, -57
  %28 = or i8 %27, %7
  store i8 %28, i8* %14, align 1, !tbaa !70
  br label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = phi i8 [ %28, %26 ], [ %15, %23 ]
  %31 = and i8 %30, -8
  %32 = and i8 %30, 7
  %33 = zext i8 %32 to i64
  %34 = getelementptr inbounds [7 x i8], [7 x i8]* @sweepgen.nextage, i64 0, i64 %33
  %35 = load i8, i8* %34, align 1, !tbaa !21
  %36 = or i8 %31, %35
  store i8 %36, i8* %14, align 1, !tbaa !70
  %37 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %12, i64 0, i32 0
  br label %38

; <label>:38:                                     ; preds = %29, %19
  %39 = phi %struct.GCObject** [ %13, %19 ], [ %37, %29 ]
  %40 = load %struct.GCObject*, %struct.GCObject** %39, align 8, !tbaa !54
  %41 = icmp eq %struct.GCObject* %40, %3
  br i1 %41, label %42, label %11

; <label>:42:                                     ; preds = %38, %4
  %43 = phi %struct.GCObject** [ %2, %4 ], [ %39, %38 ]
  ret %struct.GCObject** %43
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaO_chunkid(i8* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = load i8, i8* %1, align 1, !tbaa !21
  switch i8 %4, label %20 [
    i8 61, label %5
    i8 64, label %11
  ]

; <label>:5:                                      ; preds = %3
  %6 = icmp ult i64 %2, 61
  %7 = getelementptr inbounds i8, i8* %1, i64 1
  br i1 %6, label %8, label %9

; <label>:8:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 %2, i32 1, i1 false)
  br label %39

; <label>:9:                                      ; preds = %5
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %7, i64 59, i32 1, i1 false)
  %10 = getelementptr inbounds i8, i8* %0, i64 59
  store i8 0, i8* %10, align 1, !tbaa !21
  br label %39

; <label>:11:                                     ; preds = %3
  %12 = icmp ult i64 %2, 61
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds i8, i8* %1, i64 1
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* nonnull %14, i64 %2, i32 1, i1 false)
  br label %39

; <label>:15:                                     ; preds = %11
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %16 = getelementptr inbounds i8, i8* %0, i64 3
  %17 = getelementptr inbounds i8, i8* %1, i64 1
  %18 = getelementptr inbounds i8, i8* %17, i64 %2
  %19 = getelementptr inbounds i8, i8* %18, i64 -57
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %16, i8* nonnull %19, i64 57, i32 1, i1 false)
  br label %39

; <label>:20:                                     ; preds = %3
  %21 = tail call i8* @strchr(i8* nonnull %1, i32 10) #21
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.150, i64 0, i64 0), i64 9, i32 1, i1 false)
  %22 = getelementptr inbounds i8, i8* %0, i64 9
  %23 = icmp ult i64 %2, 45
  %24 = icmp eq i8* %21, null
  %25 = and i1 %23, %24
  br i1 %25, label %26, label %28

; <label>:26:                                     ; preds = %20
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %2, i32 1, i1 false)
  %27 = getelementptr inbounds i8, i8* %22, i64 %2
  br label %37

; <label>:28:                                     ; preds = %20
  %29 = ptrtoint i8* %21 to i64
  %30 = ptrtoint i8* %1 to i64
  %31 = sub i64 %29, %30
  %32 = select i1 %24, i64 %2, i64 %31
  %33 = icmp ult i64 %32, 45
  %34 = select i1 %33, i64 %32, i64 45
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %22, i8* nonnull %1, i64 %34, i32 1, i1 false)
  %35 = getelementptr inbounds i8, i8* %22, i64 %34
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %35, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.126, i64 0, i64 0), i64 3, i32 1, i1 false)
  %36 = getelementptr inbounds i8, i8* %35, i64 3
  br label %37

; <label>:37:                                     ; preds = %28, %26
  %38 = phi i8* [ %27, %26 ], [ %36, %28 ]
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %38, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.151, i64 0, i64 0), i64 3, i32 1, i1 false)
  br label %39

; <label>:39:                                     ; preds = %37, %15, %13, %8, %9
  ret void
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @luaG_getfuncline(%struct.Proto* nocapture readonly, i32) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %4 = load i8*, i8** %3, align 8, !tbaa !137
  %5 = icmp eq i8* %4, null
  br i1 %5, label %63, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %8 = load i32, i32* %7, align 8, !tbaa !226
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %12 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %11, align 8, !tbaa !225
  %13 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 0, i32 0
  %14 = load i32, i32* %13, align 4, !tbaa !238
  %15 = icmp sgt i32 %14, %1
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %10, %6
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  br label %46

; <label>:18:                                     ; preds = %10
  %19 = add nsw i32 %8, -1
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %20, i32 0
  %22 = load i32, i32* %21, align 4, !tbaa !238
  %23 = icmp sgt i32 %22, %1
  br i1 %23, label %24, label %40

; <label>:24:                                     ; preds = %18
  %25 = icmp eq i32 %8, 2
  br i1 %25, label %40, label %26

; <label>:26:                                     ; preds = %24
  br label %27

; <label>:27:                                     ; preds = %26, %27
  %28 = phi i32 [ %37, %27 ], [ %19, %26 ]
  %29 = phi i32 [ %36, %27 ], [ 0, %26 ]
  %30 = add i32 %29, %28
  %31 = lshr i32 %30, 1
  %32 = zext i32 %31 to i64
  %33 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %32, i32 0
  %34 = load i32, i32* %33, align 4, !tbaa !238
  %35 = icmp sgt i32 %34, %1
  %36 = select i1 %35, i32 %29, i32 %31
  %37 = select i1 %35, i32 %31, i32 %28
  %38 = add i32 %37, -1
  %39 = icmp ult i32 %36, %38
  br i1 %39, label %27, label %40

; <label>:40:                                     ; preds = %27, %24, %18
  %41 = phi i32 [ %19, %18 ], [ 0, %24 ], [ %36, %27 ]
  %42 = zext i32 %41 to i64
  %43 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %42, i32 0
  %44 = load i32, i32* %43, align 4, !tbaa !238
  %45 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %12, i64 %42, i32 1
  br label %46

; <label>:46:                                     ; preds = %16, %40
  %47 = phi i32 [ -1, %16 ], [ %44, %40 ]
  %48 = phi i32* [ %17, %16 ], [ %45, %40 ]
  %49 = load i32, i32* %48, align 4, !tbaa !77
  %50 = icmp slt i32 %47, %1
  br i1 %50, label %51, label %63

; <label>:51:                                     ; preds = %46
  %52 = sext i32 %47 to i64
  %53 = sext i32 %1 to i64
  br label %54

; <label>:54:                                     ; preds = %54, %51
  %55 = phi i64 [ %52, %51 ], [ %57, %54 ]
  %56 = phi i32 [ %49, %51 ], [ %61, %54 ]
  %57 = add nsw i64 %55, 1
  %58 = getelementptr inbounds i8, i8* %4, i64 %57
  %59 = load i8, i8* %58, align 1, !tbaa !21
  %60 = sext i8 %59 to i32
  %61 = add nsw i32 %56, %60
  %62 = icmp eq i64 %57, %53
  br i1 %62, label %63, label %54

; <label>:63:                                     ; preds = %54, %46, %2
  %64 = phi i32 [ -1, %2 ], [ %49, %46 ], [ %61, %54 ]
  ret i32 %64
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @getobjname(%struct.Proto* nocapture readonly, i32, i32, i8**) unnamed_addr #0 {
  %5 = add nsw i32 %2, 1
  %6 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %0, i32 %5, i32 %1) #16
  store i8* %6, i8** %3, align 8, !tbaa !54
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %190

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  br label %14

; <label>:10:                                     ; preds = %76
  %11 = add nuw nsw i32 %78, 1
  %12 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %0, i32 %11, i32 %66) #16
  store i8* %12, i8** %3, align 8, !tbaa !54
  %13 = icmp eq i8* %12, null
  br i1 %13, label %14, label %190

; <label>:14:                                     ; preds = %8, %10
  %15 = phi i32 [ %2, %8 ], [ %78, %10 ]
  %16 = phi i32 [ %1, %8 ], [ %66, %10 ]
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %18, label %190

; <label>:18:                                     ; preds = %14
  %19 = load i32*, i32** %9, align 8, !tbaa !116
  %20 = zext i32 %16 to i64
  br label %21

; <label>:21:                                     ; preds = %64, %18
  %22 = phi i64 [ 0, %18 ], [ %67, %64 ]
  %23 = phi i32 [ -1, %18 ], [ %66, %64 ]
  %24 = phi i32 [ 0, %18 ], [ %65, %64 ]
  %25 = getelementptr inbounds i32, i32* %19, i64 %22
  %26 = load i32, i32* %25, align 4, !tbaa !77
  %27 = lshr i32 %26, 7
  %28 = and i32 %27, 255
  %29 = trunc i32 %26 to i7
  switch i7 %29, label %45 [
    i7 6, label %30
    i7 -51, label %32
    i7 -59, label %35
    i7 -58, label %35
    i7 57, label %37
  ]

; <label>:30:                                     ; preds = %21
  %31 = icmp sgt i32 %28, %15
  br i1 %31, label %64, label %54

; <label>:32:                                     ; preds = %21
  %33 = add nuw nsw i32 %28, 2
  %34 = icmp sgt i32 %33, %15
  br i1 %34, label %64, label %59

; <label>:35:                                     ; preds = %21, %21
  %36 = icmp sgt i32 %28, %15
  br i1 %36, label %64, label %59

; <label>:37:                                     ; preds = %21
  %38 = trunc i64 %22 to i32
  %39 = add i32 %38, -16777214
  %40 = add i32 %39, %27
  %41 = icmp sle i32 %40, %16
  %42 = icmp sgt i32 %40, %24
  %43 = and i1 %41, %42
  %44 = select i1 %43, i32 %40, i32 %24
  br label %64

; <label>:45:                                     ; preds = %21
  %46 = and i32 %26, 127
  %47 = zext i32 %46 to i64
  %48 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %47
  %49 = load i8, i8* %48, align 1, !tbaa !21
  %50 = and i8 %49, 8
  %51 = icmp ne i8 %50, 0
  %52 = icmp eq i32 %28, %15
  %53 = and i1 %52, %51
  br i1 %53, label %59, label %64

; <label>:54:                                     ; preds = %30
  %55 = lshr i32 %26, 16
  %56 = and i32 %55, 255
  %57 = add nuw nsw i32 %28, %56
  %58 = icmp slt i32 %57, %15
  br i1 %58, label %64, label %59

; <label>:59:                                     ; preds = %54, %45, %35, %32
  %60 = sext i32 %24 to i64
  %61 = icmp slt i64 %22, %60
  %62 = trunc i64 %22 to i32
  %63 = select i1 %61, i32 -1, i32 %62
  br label %64

; <label>:64:                                     ; preds = %59, %54, %45, %37, %35, %32, %30
  %65 = phi i32 [ %24, %59 ], [ %24, %54 ], [ %24, %45 ], [ %24, %35 ], [ %24, %32 ], [ %44, %37 ], [ %24, %30 ]
  %66 = phi i32 [ %63, %59 ], [ %23, %54 ], [ %23, %45 ], [ %23, %35 ], [ %23, %32 ], [ %23, %37 ], [ %23, %30 ]
  %67 = add nuw nsw i64 %22, 1
  %68 = icmp eq i64 %67, %20
  br i1 %68, label %69, label %21

; <label>:69:                                     ; preds = %64
  %70 = icmp eq i32 %66, -1
  br i1 %70, label %190, label %71

; <label>:71:                                     ; preds = %69
  %72 = sext i32 %66 to i64
  %73 = getelementptr inbounds i32, i32* %19, i64 %72
  %74 = load i32, i32* %73, align 4, !tbaa !77
  %75 = trunc i32 %74 to i7
  switch i7 %75, label %190 [
    i7 0, label %76
    i7 9, label %82
    i7 10, label %99
    i7 11, label %109
    i7 12, label %110
    i7 7, label %127
    i7 3, label %139
    i7 4, label %139
    i7 18, label %164
  ]

; <label>:76:                                     ; preds = %71
  %77 = lshr i32 %74, 16
  %78 = and i32 %77, 255
  %79 = lshr i32 %74, 7
  %80 = and i32 %79, 255
  %81 = icmp ult i32 %78, %80
  br i1 %81, label %10, label %190

; <label>:82:                                     ; preds = %71
  %83 = lshr i32 %74, 24
  %84 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %85 = load %struct.TValue*, %struct.TValue** %84, align 8, !tbaa !223
  %86 = zext i32 %83 to i64
  %87 = getelementptr inbounds %struct.TValue, %struct.TValue* %85, i64 %86, i32 1
  %88 = load i8, i8* %87, align 8, !tbaa !22
  %89 = and i8 %88, 15
  %90 = icmp eq i8 %89, 4
  br i1 %90, label %91, label %96

; <label>:91:                                     ; preds = %82
  %92 = getelementptr inbounds %struct.TValue, %struct.TValue* %85, i64 %86, i32 0, i32 0
  %93 = bitcast %struct.GCObject** %92 to i8**
  %94 = load i8*, i8** %93, align 8, !tbaa !21
  %95 = getelementptr inbounds i8, i8* %94, i64 24
  br label %96

; <label>:96:                                     ; preds = %82, %91
  %97 = phi i8* [ %95, %91 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %82 ]
  store i8* %97, i8** %3, align 8, !tbaa !54
  %98 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %66, i32 %74, i32 1) #16
  br label %190

; <label>:99:                                     ; preds = %71
  %100 = lshr i32 %74, 24
  %101 = tail call fastcc i8* @getobjname(%struct.Proto* nonnull %0, i32 %66, i32 %100, i8** %3) #17
  %102 = icmp eq i8* %101, null
  br i1 %102, label %106, label %103

; <label>:103:                                    ; preds = %99
  %104 = load i8, i8* %101, align 1, !tbaa !21
  %105 = icmp eq i8 %104, 99
  br i1 %105, label %107, label %106

; <label>:106:                                    ; preds = %103, %99
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8** %3, align 8, !tbaa !54
  br label %107

; <label>:107:                                    ; preds = %103, %106
  %108 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %66, i32 %74, i32 0) #16
  br label %190

; <label>:109:                                    ; preds = %71
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.157, i64 0, i64 0), i8** %3, align 8, !tbaa !54
  br label %190

; <label>:110:                                    ; preds = %71
  %111 = lshr i32 %74, 24
  %112 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %113 = load %struct.TValue*, %struct.TValue** %112, align 8, !tbaa !223
  %114 = zext i32 %111 to i64
  %115 = getelementptr inbounds %struct.TValue, %struct.TValue* %113, i64 %114, i32 1
  %116 = load i8, i8* %115, align 8, !tbaa !22
  %117 = and i8 %116, 15
  %118 = icmp eq i8 %117, 4
  br i1 %118, label %119, label %124

; <label>:119:                                    ; preds = %110
  %120 = getelementptr inbounds %struct.TValue, %struct.TValue* %113, i64 %114, i32 0, i32 0
  %121 = bitcast %struct.GCObject** %120 to i8**
  %122 = load i8*, i8** %121, align 8, !tbaa !21
  %123 = getelementptr inbounds i8, i8* %122, i64 24
  br label %124

; <label>:124:                                    ; preds = %110, %119
  %125 = phi i8* [ %123, %119 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %110 ]
  store i8* %125, i8** %3, align 8, !tbaa !54
  %126 = tail call fastcc i8* @gxf(%struct.Proto* nonnull %0, i32 %66, i32 %74, i32 0) #16
  br label %190

; <label>:127:                                    ; preds = %71
  %128 = lshr i32 %74, 16
  %129 = and i32 %128, 255
  %130 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %131 = load %struct.Upvaldesc*, %struct.Upvaldesc** %130, align 8, !tbaa !198
  %132 = zext i32 %129 to i64
  %133 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %131, i64 %132, i32 0
  %134 = load %struct.TString*, %struct.TString** %133, align 8, !tbaa !199
  %135 = icmp eq %struct.TString* %134, null
  %136 = getelementptr inbounds %struct.TString, %struct.TString* %134, i64 1
  %137 = bitcast %struct.TString* %136 to i8*
  %138 = select i1 %135, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %137
  store i8* %138, i8** %3, align 8, !tbaa !54
  br label %190

; <label>:139:                                    ; preds = %71, %71
  %140 = and i32 %74, 127
  %141 = icmp eq i32 %140, 3
  br i1 %141, label %142, label %144

; <label>:142:                                    ; preds = %139
  %143 = lshr i32 %74, 15
  br label %150

; <label>:144:                                    ; preds = %139
  %145 = add nsw i32 %66, 1
  %146 = sext i32 %145 to i64
  %147 = getelementptr inbounds i32, i32* %19, i64 %146
  %148 = load i32, i32* %147, align 4, !tbaa !77
  %149 = lshr i32 %148, 7
  br label %150

; <label>:150:                                    ; preds = %144, %142
  %151 = phi i32 [ %143, %142 ], [ %149, %144 ]
  %152 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %153 = load %struct.TValue*, %struct.TValue** %152, align 8, !tbaa !223
  %154 = zext i32 %151 to i64
  %155 = getelementptr inbounds %struct.TValue, %struct.TValue* %153, i64 %154, i32 1
  %156 = load i8, i8* %155, align 8, !tbaa !22
  %157 = and i8 %156, 15
  %158 = icmp eq i8 %157, 4
  br i1 %158, label %159, label %190

; <label>:159:                                    ; preds = %150
  %160 = getelementptr inbounds %struct.TValue, %struct.TValue* %153, i64 %154, i32 0, i32 0
  %161 = bitcast %struct.GCObject** %160 to i8**
  %162 = load i8*, i8** %161, align 8, !tbaa !21
  %163 = getelementptr inbounds i8, i8* %162, i64 24
  store i8* %163, i8** %3, align 8, !tbaa !54
  br label %190

; <label>:164:                                    ; preds = %71
  %165 = lshr i32 %74, 24
  %166 = trunc i32 %74 to i16
  %167 = icmp slt i16 %166, 0
  br i1 %167, label %168, label %183

; <label>:168:                                    ; preds = %164
  %169 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %170 = load %struct.TValue*, %struct.TValue** %169, align 8, !tbaa !223
  %171 = zext i32 %165 to i64
  %172 = getelementptr inbounds %struct.TValue, %struct.TValue* %170, i64 %171, i32 1
  %173 = load i8, i8* %172, align 8, !tbaa !22
  %174 = and i8 %173, 15
  %175 = icmp eq i8 %174, 4
  br i1 %175, label %176, label %181

; <label>:176:                                    ; preds = %168
  %177 = getelementptr inbounds %struct.TValue, %struct.TValue* %170, i64 %171, i32 0, i32 0
  %178 = bitcast %struct.GCObject** %177 to i8**
  %179 = load i8*, i8** %178, align 8, !tbaa !21
  %180 = getelementptr inbounds i8, i8* %179, i64 24
  br label %181

; <label>:181:                                    ; preds = %176, %168
  %182 = phi i8* [ %180, %176 ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), %168 ]
  store i8* %182, i8** %3, align 8, !tbaa !54
  br label %190

; <label>:183:                                    ; preds = %164
  %184 = tail call fastcc i8* @getobjname(%struct.Proto* nonnull %0, i32 %66, i32 %165, i8** %3) #17
  %185 = icmp eq i8* %184, null
  br i1 %185, label %189, label %186

; <label>:186:                                    ; preds = %183
  %187 = load i8, i8* %184, align 1, !tbaa !21
  %188 = icmp eq i8 %187, 99
  br i1 %188, label %190, label %189

; <label>:189:                                    ; preds = %186, %183
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8** %3, align 8, !tbaa !54
  br label %190

; <label>:190:                                    ; preds = %10, %71, %69, %14, %76, %4, %181, %186, %189, %159, %96, %107, %109, %124, %127, %150
  %191 = phi i8* [ null, %150 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %181 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %186 ], [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.17, i64 0, i64 0), %189 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.160, i64 0, i64 0), %159 ], [ %98, %96 ], [ %108, %107 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %109 ], [ %126, %124 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %127 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i64 0, i64 0), %4 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i64 0, i64 0), %10 ], [ null, %71 ], [ null, %69 ], [ null, %14 ], [ null, %76 ]
  ret i8* %191
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @gxf(%struct.Proto* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = lshr i32 %2, 16
  %7 = and i32 %6, 255
  %8 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = icmp eq i32 %3, 0
  br i1 %9, label %20, label %10

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %12 = load %struct.Upvaldesc*, %struct.Upvaldesc** %11, align 8, !tbaa !198
  %13 = zext i32 %7 to i64
  %14 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %12, i64 %13, i32 0
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !199
  %16 = icmp eq %struct.TString* %15, null
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %15, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = select i1 %16, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %18
  store i8* %19, i8** %5, align 8, !tbaa !54
  br label %24

; <label>:20:                                     ; preds = %4
  %21 = call fastcc i8* @getobjname(%struct.Proto* %0, i32 %1, i32 %7, i8** nonnull %5) #16
  %22 = load i8*, i8** %5, align 8, !tbaa !54
  %23 = icmp eq i8* %22, null
  br i1 %23, label %29, label %24

; <label>:24:                                     ; preds = %10, %20
  %25 = phi i8* [ %19, %10 ], [ %22, %20 ]
  %26 = call i32 @strcmp(i8* nonnull %25, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0)) #21
  %27 = icmp eq i32 %26, 0
  %28 = select i1 %27, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.161, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0)
  br label %29

; <label>:29:                                     ; preds = %20, %24
  %30 = phi i8* [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.158, i64 0, i64 0), %20 ], [ %28, %24 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  ret i8* %30
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i32 @prepclosingmethod(%struct.lua_State* nocapture, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 24) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %32, label %11

; <label>:11:                                     ; preds = %3
  %12 = bitcast %struct.TValue* %6 to i64*
  %13 = bitcast %union.StackValue* %5 to i64*
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %13, align 8
  %15 = load i8, i8* %7, align 8, !tbaa !22
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 0, i32 0, i32 1
  store i8 %15, i8* %16, align 8, !tbaa !22
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0
  %18 = bitcast %struct.TValue* %1 to i64*
  %19 = bitcast %struct.TValue* %17 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0
  %25 = bitcast %struct.TValue* %2 to i64*
  %26 = bitcast %struct.TValue* %24 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !22
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 3
  store %union.StackValue* %31, %union.StackValue** %4, align 8, !tbaa !20
  br label %32

; <label>:32:                                     ; preds = %3, %11
  %33 = phi i32 [ 1, %11 ], [ 0, %3 ]
  ret i32 %33
}

; Function Attrs: nounwind optsize uwtable
define internal void @callclose(%struct.lua_State*, i8* nocapture readnone) #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %union.StackValue, %union.StackValue* %4, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* %0, %union.StackValue* nonnull %5, i32 0) #16
  ret void
}

; Function Attrs: nounwind optsize returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) local_unnamed_addr #13

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaV_execute(%struct.lua_State*, %struct.CallInfo*) #0 {
  %3 = alloca double, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = alloca %struct.TValue, align 8
  %10 = alloca %struct.TValue, align 8
  %11 = alloca %struct.TValue, align 8
  %12 = alloca %struct.TValue, align 8
  %13 = alloca %struct.TValue, align 8
  %14 = alloca %struct.TValue, align 8
  %15 = alloca %struct.TValue, align 8
  %16 = alloca %struct.TValue, align 8
  %17 = alloca %struct.TValue, align 8
  %18 = alloca %struct.TValue, align 8
  %19 = alloca %struct.TValue, align 8
  %20 = alloca %struct.TValue, align 8
  %21 = alloca %struct.TValue, align 8
  %22 = alloca i64, align 8
  %23 = alloca double, align 8
  %24 = alloca double, align 8
  %25 = alloca double, align 8
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %28 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %30 = bitcast %union.anon.0* %29 to %struct.anon*
  %31 = bitcast %union.anon.0* %29 to i32**
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %33 = bitcast %union.StackValue** %32 to i64*
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %35 = bitcast %union.StackValue** %34 to i64*
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4, i32 0, i32 1
  %38 = bitcast i64* %37 to i32*
  %39 = getelementptr inbounds %struct.anon, %struct.anon* %30, i64 0, i32 2
  %40 = bitcast %struct.CallInfo* %1 to i64*
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %42 = bitcast %union.StackValue** %41 to i64*
  %43 = bitcast %struct.TValue* %20 to i64*
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %45 = bitcast %struct.TValue* %21 to i64*
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  %47 = bitcast %struct.TValue* %19 to i8*
  %48 = bitcast %struct.TValue* %19 to i64*
  %49 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %50 = bitcast %struct.TValue* %18 to i8*
  %51 = bitcast %struct.TValue* %18 to i64*
  %52 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %53 = bitcast %struct.TValue* %17 to i8*
  %54 = bitcast %struct.TValue* %17 to i64*
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %56 = bitcast %struct.TValue* %16 to i8*
  %57 = bitcast %struct.TValue* %16 to i64*
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  %59 = bitcast %struct.TValue* %15 to i8*
  %60 = bitcast %struct.TValue* %15 to i64*
  %61 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  %62 = bitcast %struct.TValue* %14 to i8*
  %63 = bitcast %struct.TValue* %14 to i64*
  %64 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  %65 = bitcast %struct.TValue* %13 to i8*
  %66 = bitcast %struct.TValue* %13 to i64*
  %67 = getelementptr inbounds %struct.TValue, %struct.TValue* %13, i64 0, i32 1
  %68 = bitcast %struct.TValue* %7 to i8*
  %69 = bitcast %struct.TValue* %6 to i8*
  %70 = bitcast %struct.TValue* %5 to i8*
  %71 = bitcast %struct.TValue* %4 to i8*
  %72 = bitcast %struct.CallInfo* %1 to %struct.TValue**
  %73 = bitcast %struct.TValue* %12 to i8*
  %74 = bitcast %struct.TValue* %12 to i64*
  %75 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %76 = bitcast %struct.TValue* %11 to i8*
  %77 = bitcast %struct.TValue* %11 to i64*
  %78 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %79 = bitcast %struct.TValue* %10 to i8*
  %80 = bitcast %struct.TValue* %10 to i64*
  %81 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  %82 = bitcast %struct.TValue* %9 to i8*
  %83 = bitcast %struct.TValue* %9 to i64*
  %84 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  %85 = bitcast %struct.TValue* %8 to i8*
  %86 = bitcast %struct.TValue* %8 to i64*
  %87 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  %88 = bitcast %struct.TValue* %7 to i64*
  %89 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %90 = bitcast %struct.TValue* %7 to double*
  %91 = bitcast %struct.TValue* %6 to i64*
  %92 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %93 = bitcast %struct.TValue* %6 to double*
  %94 = bitcast %struct.TValue* %5 to i64*
  %95 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %96 = bitcast %struct.TValue* %5 to double*
  %97 = bitcast %struct.TValue* %4 to i64*
  %98 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %99 = bitcast %struct.TValue* %4 to double*
  %100 = bitcast double* %24 to i64*
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %102 = bitcast %union.StackValue** %101 to i64*
  %103 = bitcast double* %25 to i64*
  %104 = bitcast %union.StackValue** %101 to i8**
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %106 = bitcast double* %3 to i8*
  %107 = bitcast double* %23 to i64*
  %108 = bitcast double* %3 to i64*
  %109 = bitcast %union.anon.0* %29 to i64*
  %110 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  br label %111

; <label>:111:                                    ; preds = %3580, %2
  %112 = load i32, i32* %26, align 8, !tbaa !31
  %113 = load %struct.LClosure**, %struct.LClosure*** %28, align 8, !tbaa !64
  %114 = load %struct.LClosure*, %struct.LClosure** %113, align 8, !tbaa !21
  %115 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 5
  %116 = load %struct.Proto*, %struct.Proto** %115, align 8, !tbaa !197
  %117 = getelementptr inbounds %struct.Proto, %struct.Proto* %116, i64 0, i32 15
  %118 = load %struct.TValue*, %struct.TValue** %117, align 8, !tbaa !223
  %119 = load i32*, i32** %31, align 8, !tbaa !21
  %120 = icmp eq i32 %112, 0
  %121 = bitcast %struct.LClosure** %113 to %union.StackValue*
  br i1 %120, label %135, label %122

; <label>:122:                                    ; preds = %111
  %123 = getelementptr inbounds %struct.Proto, %struct.Proto* %116, i64 0, i32 4
  %124 = load i8, i8* %123, align 1, !tbaa !115
  %125 = icmp eq i8 %124, 0
  br i1 %125, label %126, label %131

; <label>:126:                                    ; preds = %122
  %127 = getelementptr inbounds %struct.Proto, %struct.Proto* %116, i64 0, i32 16
  %128 = load i32*, i32** %127, align 8, !tbaa !116
  %129 = icmp eq i32* %119, %128
  br i1 %129, label %130, label %132

; <label>:130:                                    ; preds = %126
  call fastcc void @luaD_hookcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1) #16
  br label %132

; <label>:131:                                    ; preds = %122
  store i32 1, i32* %38, align 8, !tbaa !21
  br label %135

; <label>:132:                                    ; preds = %130, %126
  store i32 1, i32* %38, align 8, !tbaa !21
  %133 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %119) #16
  %134 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  br label %135

; <label>:135:                                    ; preds = %111, %131, %132
  %136 = phi %union.StackValue* [ %134, %132 ], [ %121, %131 ], [ %121, %111 ]
  %137 = phi i32 [ %133, %132 ], [ 0, %131 ], [ 0, %111 ]
  %138 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 1
  %139 = getelementptr inbounds i32, i32* %119, i64 1
  %140 = load i32, i32* %119, align 4, !tbaa !77
  br label %4306

; <label>:141:                                    ; preds = %4306
  %142 = lshr i32 %4307, 16
  %143 = and i32 %142, 255
  %144 = zext i32 %143 to i64
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %144, i32 0
  %146 = bitcast %struct.TValue* %145 to i64*
  %147 = bitcast %union.StackValue* %4314 to i64*
  %148 = load i64, i64* %146, align 8
  store i64 %148, i64* %147, align 8
  %149 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %144, i32 0, i32 1
  %150 = load i8, i8* %149, align 8, !tbaa !22
  %151 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %150, i8* %151, align 8, !tbaa !22
  %152 = icmp eq i32 %4309, 0
  br i1 %152, label %157, label %153

; <label>:153:                                    ; preds = %141
  %154 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %155 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %156 = getelementptr inbounds %union.StackValue, %union.StackValue* %155, i64 1
  br label %157

; <label>:157:                                    ; preds = %141, %153
  %158 = phi i32 [ %154, %153 ], [ 0, %141 ]
  %159 = phi %union.StackValue* [ %156, %153 ], [ %4308, %141 ]
  %160 = getelementptr inbounds i32, i32* %4310, i64 1
  %161 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:162:                                    ; preds = %157, %182, %198, %214, %236, %254, %275, %299, %341, %387, %460, %514, %557, %629, %725, %802, %868, %939, %992, %1033, %1072, %1113, %1163, %1201, %1239, %1279, %1340, %1399, %1460, %1530, %1578, %1626, %1686, %1745, %1804, %1863, %1933, %1981, %2029, %2089, %2136, %2183, %2230, %2292, %2354, %2416, %2480, %2536, %2609, %2682, %2716, %2757, %2787, %2804, %2826, %2840, %2851, %2867, %2897, %2961, %3025, %3057, %3103, %3161, %3219, %3277, %3335, %3377, %3428, %3449, %3740, %3892, %3960, %4054, %4129, %4210, %4288, %4300
  %163 = phi i32 [ %161, %157 ], [ %186, %182 ], [ %202, %198 ], [ %218, %214 ], [ %240, %236 ], [ %258, %254 ], [ %279, %275 ], [ %303, %299 ], [ %345, %341 ], [ %391, %387 ], [ %464, %460 ], [ %518, %514 ], [ %561, %557 ], [ %633, %629 ], [ %729, %725 ], [ %806, %802 ], [ %872, %868 ], [ %943, %939 ], [ %996, %992 ], [ %1037, %1033 ], [ %1076, %1072 ], [ %1117, %1113 ], [ %1167, %1163 ], [ %1205, %1201 ], [ %1243, %1239 ], [ %1283, %1279 ], [ %1344, %1340 ], [ %1403, %1399 ], [ %1464, %1460 ], [ %1534, %1530 ], [ %1582, %1578 ], [ %1630, %1626 ], [ %1690, %1686 ], [ %1749, %1745 ], [ %1808, %1804 ], [ %1867, %1863 ], [ %1937, %1933 ], [ %1985, %1981 ], [ %2033, %2029 ], [ %2093, %2089 ], [ %2140, %2136 ], [ %2187, %2183 ], [ %2234, %2230 ], [ %2296, %2292 ], [ %2358, %2354 ], [ %2420, %2416 ], [ %2484, %2480 ], [ %2540, %2536 ], [ %2613, %2609 ], [ %2686, %2682 ], [ %2720, %2716 ], [ %2761, %2757 ], [ %2791, %2787 ], [ %2808, %2804 ], [ %2830, %2826 ], [ %2844, %2840 ], [ %2855, %2851 ], [ %2871, %2867 ], [ %2901, %2897 ], [ %2965, %2961 ], [ %3029, %3025 ], [ %3061, %3057 ], [ %3107, %3103 ], [ %3165, %3161 ], [ %3223, %3219 ], [ %3281, %3277 ], [ %3339, %3335 ], [ %3381, %3377 ], [ %3432, %3428 ], [ %3453, %3449 ], [ %3744, %3740 ], [ %3896, %3892 ], [ %3964, %3960 ], [ %4058, %4054 ], [ %4133, %4129 ], [ %4214, %4210 ], [ %4293, %4288 ], [ %4304, %4300 ]
  %164 = phi %union.StackValue* [ %159, %157 ], [ %184, %182 ], [ %200, %198 ], [ %216, %214 ], [ %238, %236 ], [ %256, %254 ], [ %277, %275 ], [ %301, %299 ], [ %343, %341 ], [ %389, %387 ], [ %462, %460 ], [ %516, %514 ], [ %559, %557 ], [ %631, %629 ], [ %727, %725 ], [ %804, %802 ], [ %870, %868 ], [ %941, %939 ], [ %994, %992 ], [ %1035, %1033 ], [ %1074, %1072 ], [ %1115, %1113 ], [ %1165, %1163 ], [ %1203, %1201 ], [ %1241, %1239 ], [ %1281, %1279 ], [ %1342, %1340 ], [ %1401, %1399 ], [ %1462, %1460 ], [ %1532, %1530 ], [ %1580, %1578 ], [ %1628, %1626 ], [ %1688, %1686 ], [ %1747, %1745 ], [ %1806, %1804 ], [ %1865, %1863 ], [ %1935, %1933 ], [ %1983, %1981 ], [ %2031, %2029 ], [ %2091, %2089 ], [ %2138, %2136 ], [ %2185, %2183 ], [ %2232, %2230 ], [ %2294, %2292 ], [ %2356, %2354 ], [ %2418, %2416 ], [ %2482, %2480 ], [ %2538, %2536 ], [ %2611, %2609 ], [ %2684, %2682 ], [ %2718, %2716 ], [ %2759, %2757 ], [ %2789, %2787 ], [ %2806, %2804 ], [ %2828, %2826 ], [ %2842, %2840 ], [ %2853, %2851 ], [ %2869, %2867 ], [ %2899, %2897 ], [ %2963, %2961 ], [ %3027, %3025 ], [ %3059, %3057 ], [ %3105, %3103 ], [ %3163, %3161 ], [ %3221, %3219 ], [ %3279, %3277 ], [ %3337, %3335 ], [ %3379, %3377 ], [ %3430, %3428 ], [ %3451, %3449 ], [ %3742, %3740 ], [ %3894, %3892 ], [ %3962, %3960 ], [ %4056, %4054 ], [ %4131, %4129 ], [ %4212, %4210 ], [ %4292, %4288 ], [ %4302, %4300 ]
  %165 = phi i32 [ %158, %157 ], [ %183, %182 ], [ %199, %198 ], [ %215, %214 ], [ %237, %236 ], [ %255, %254 ], [ %276, %275 ], [ %300, %299 ], [ %342, %341 ], [ %388, %387 ], [ %461, %460 ], [ %515, %514 ], [ %558, %557 ], [ %630, %629 ], [ %726, %725 ], [ %803, %802 ], [ %869, %868 ], [ %940, %939 ], [ %993, %992 ], [ %1034, %1033 ], [ %1073, %1072 ], [ %1114, %1113 ], [ %1164, %1163 ], [ %1202, %1201 ], [ %1240, %1239 ], [ %1280, %1279 ], [ %1341, %1340 ], [ %1400, %1399 ], [ %1461, %1460 ], [ %1531, %1530 ], [ %1579, %1578 ], [ %1627, %1626 ], [ %1687, %1686 ], [ %1746, %1745 ], [ %1805, %1804 ], [ %1864, %1863 ], [ %1934, %1933 ], [ %1982, %1981 ], [ %2030, %2029 ], [ %2090, %2089 ], [ %2137, %2136 ], [ %2184, %2183 ], [ %2231, %2230 ], [ %2293, %2292 ], [ %2355, %2354 ], [ %2417, %2416 ], [ %2481, %2480 ], [ %2537, %2536 ], [ %2610, %2609 ], [ %2683, %2682 ], [ %2717, %2716 ], [ %2758, %2757 ], [ %2788, %2787 ], [ %2805, %2804 ], [ %2827, %2826 ], [ %2841, %2840 ], [ %2852, %2851 ], [ %2868, %2867 ], [ %2898, %2897 ], [ %2962, %2961 ], [ %3026, %3025 ], [ %3058, %3057 ], [ %3104, %3103 ], [ %3162, %3161 ], [ %3220, %3219 ], [ %3278, %3277 ], [ %3336, %3335 ], [ %3378, %3377 ], [ %3429, %3428 ], [ %3450, %3449 ], [ %3741, %3740 ], [ %3893, %3892 ], [ %3961, %3960 ], [ %4055, %4054 ], [ %4130, %4129 ], [ %4211, %4210 ], [ %4291, %4288 ], [ %4301, %4300 ]
  %166 = phi i32* [ %160, %157 ], [ %185, %182 ], [ %201, %198 ], [ %217, %214 ], [ %239, %236 ], [ %257, %254 ], [ %278, %275 ], [ %302, %299 ], [ %344, %341 ], [ %390, %387 ], [ %463, %460 ], [ %517, %514 ], [ %560, %557 ], [ %632, %629 ], [ %728, %725 ], [ %805, %802 ], [ %871, %868 ], [ %942, %939 ], [ %995, %992 ], [ %1036, %1033 ], [ %1075, %1072 ], [ %1116, %1113 ], [ %1166, %1163 ], [ %1204, %1201 ], [ %1242, %1239 ], [ %1282, %1279 ], [ %1343, %1340 ], [ %1402, %1399 ], [ %1463, %1460 ], [ %1533, %1530 ], [ %1581, %1578 ], [ %1629, %1626 ], [ %1689, %1686 ], [ %1748, %1745 ], [ %1807, %1804 ], [ %1866, %1863 ], [ %1936, %1933 ], [ %1984, %1981 ], [ %2032, %2029 ], [ %2092, %2089 ], [ %2139, %2136 ], [ %2186, %2183 ], [ %2233, %2230 ], [ %2295, %2292 ], [ %2357, %2354 ], [ %2419, %2416 ], [ %2483, %2480 ], [ %2539, %2536 ], [ %2612, %2609 ], [ %2685, %2682 ], [ %2719, %2716 ], [ %2760, %2757 ], [ %2790, %2787 ], [ %2807, %2804 ], [ %2829, %2826 ], [ %2843, %2840 ], [ %2854, %2851 ], [ %2870, %2867 ], [ %2900, %2897 ], [ %2964, %2961 ], [ %3028, %3025 ], [ %3060, %3057 ], [ %3106, %3103 ], [ %3164, %3161 ], [ %3222, %3219 ], [ %3280, %3277 ], [ %3338, %3335 ], [ %3380, %3377 ], [ %3431, %3428 ], [ %3452, %3449 ], [ %3743, %3740 ], [ %3895, %3892 ], [ %3963, %3960 ], [ %4057, %4054 ], [ %4132, %4129 ], [ %4213, %4210 ], [ %4289, %4288 ], [ %4303, %4300 ]
  br label %4306

; <label>:167:                                    ; preds = %4306
  %168 = lshr i32 %4307, 15
  %169 = zext i32 %168 to i64
  %170 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %169
  %171 = bitcast %struct.TValue* %170 to i64*
  %172 = bitcast %union.StackValue* %4314 to i64*
  %173 = load i64, i64* %171, align 8
  store i64 %173, i64* %172, align 8
  %174 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %169, i32 1
  %175 = load i8, i8* %174, align 8, !tbaa !22
  %176 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %175, i8* %176, align 8, !tbaa !22
  %177 = icmp eq i32 %4309, 0
  br i1 %177, label %182, label %178

; <label>:178:                                    ; preds = %167
  %179 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %180 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %181 = getelementptr inbounds %union.StackValue, %union.StackValue* %180, i64 1
  br label %182

; <label>:182:                                    ; preds = %167, %178
  %183 = phi i32 [ %179, %178 ], [ 0, %167 ]
  %184 = phi %union.StackValue* [ %181, %178 ], [ %4308, %167 ]
  %185 = getelementptr inbounds i32, i32* %4310, i64 1
  %186 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:187:                                    ; preds = %4306
  %188 = lshr i32 %4307, 15
  %189 = add nsw i32 %188, -65535
  %190 = sext i32 %189 to i64
  %191 = bitcast %union.StackValue* %4314 to i64*
  store i64 %190, i64* %191, align 8, !tbaa !21
  %192 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %192, align 8, !tbaa !22
  %193 = icmp eq i32 %4309, 0
  br i1 %193, label %198, label %194

; <label>:194:                                    ; preds = %187
  %195 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %196 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %197 = getelementptr inbounds %union.StackValue, %union.StackValue* %196, i64 1
  br label %198

; <label>:198:                                    ; preds = %187, %194
  %199 = phi i32 [ %195, %194 ], [ 0, %187 ]
  %200 = phi %union.StackValue* [ %197, %194 ], [ %4308, %187 ]
  %201 = getelementptr inbounds i32, i32* %4310, i64 1
  %202 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:203:                                    ; preds = %4306
  %204 = lshr i32 %4307, 15
  %205 = add nsw i32 %204, -65535
  %206 = sitofp i32 %205 to double
  %207 = bitcast %union.StackValue* %4314 to double*
  store double %206, double* %207, align 8, !tbaa !21
  %208 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %208, align 8, !tbaa !22
  %209 = icmp eq i32 %4309, 0
  br i1 %209, label %214, label %210

; <label>:210:                                    ; preds = %203
  %211 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %212 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %213 = getelementptr inbounds %union.StackValue, %union.StackValue* %212, i64 1
  br label %214

; <label>:214:                                    ; preds = %203, %210
  %215 = phi i32 [ %211, %210 ], [ 0, %203 ]
  %216 = phi %union.StackValue* [ %213, %210 ], [ %4308, %203 ]
  %217 = getelementptr inbounds i32, i32* %4310, i64 1
  %218 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:219:                                    ; preds = %4306
  %220 = load i32, i32* %4310, align 4, !tbaa !77
  %221 = lshr i32 %220, 7
  %222 = zext i32 %221 to i64
  %223 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %222
  %224 = getelementptr inbounds i32, i32* %4310, i64 1
  %225 = bitcast %struct.TValue* %223 to i64*
  %226 = bitcast %union.StackValue* %4314 to i64*
  %227 = load i64, i64* %225, align 8
  store i64 %227, i64* %226, align 8
  %228 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %222, i32 1
  %229 = load i8, i8* %228, align 8, !tbaa !22
  %230 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %229, i8* %230, align 8, !tbaa !22
  %231 = icmp eq i32 %4309, 0
  br i1 %231, label %236, label %232

; <label>:232:                                    ; preds = %219
  %233 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %224) #16
  %234 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %235 = getelementptr inbounds %union.StackValue, %union.StackValue* %234, i64 1
  br label %236

; <label>:236:                                    ; preds = %219, %232
  %237 = phi i32 [ %233, %232 ], [ 0, %219 ]
  %238 = phi %union.StackValue* [ %235, %232 ], [ %4308, %219 ]
  %239 = getelementptr inbounds i32, i32* %4310, i64 2
  %240 = load i32, i32* %224, align 4, !tbaa !77
  br label %162

; <label>:241:                                    ; preds = %4306
  %242 = lshr i32 %4307, 16
  %243 = and i32 %242, 255
  %244 = bitcast %union.StackValue* %4314 to i32*
  store i32 %243, i32* %244, align 8, !tbaa !21
  %245 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 1, i8* %245, align 8, !tbaa !22
  %246 = icmp ugt i32 %4307, 16777215
  %247 = getelementptr inbounds i32, i32* %4310, i64 1
  %248 = select i1 %246, i32* %247, i32* %4310
  %249 = icmp eq i32 %4309, 0
  br i1 %249, label %254, label %250

; <label>:250:                                    ; preds = %241
  %251 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %248) #16
  %252 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %253 = getelementptr inbounds %union.StackValue, %union.StackValue* %252, i64 1
  br label %254

; <label>:254:                                    ; preds = %241, %250
  %255 = phi i32 [ %251, %250 ], [ 0, %241 ]
  %256 = phi %union.StackValue* [ %253, %250 ], [ %4308, %241 ]
  %257 = getelementptr inbounds i32, i32* %248, i64 1
  %258 = load i32, i32* %248, align 4, !tbaa !77
  br label %162

; <label>:259:                                    ; preds = %4306
  %260 = lshr i32 %4307, 16
  %261 = and i32 %260, 255
  br label %262

; <label>:262:                                    ; preds = %262, %259
  %263 = phi i32 [ %261, %259 ], [ %267, %262 ]
  %264 = phi %union.StackValue* [ %4314, %259 ], [ %265, %262 ]
  %265 = getelementptr inbounds %union.StackValue, %union.StackValue* %264, i64 1
  %266 = getelementptr inbounds %union.StackValue, %union.StackValue* %264, i64 0, i32 0, i32 1
  store i8 0, i8* %266, align 8, !tbaa !21
  %267 = add nsw i32 %263, -1
  %268 = icmp eq i32 %263, 0
  br i1 %268, label %269, label %262

; <label>:269:                                    ; preds = %262
  %270 = icmp eq i32 %4309, 0
  br i1 %270, label %275, label %271

; <label>:271:                                    ; preds = %269
  %272 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %4310) #16
  %273 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %274 = getelementptr inbounds %union.StackValue, %union.StackValue* %273, i64 1
  br label %275

; <label>:275:                                    ; preds = %269, %271
  %276 = phi i32 [ %272, %271 ], [ 0, %269 ]
  %277 = phi %union.StackValue* [ %274, %271 ], [ %4308, %269 ]
  %278 = getelementptr inbounds i32, i32* %4310, i64 1
  %279 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:280:                                    ; preds = %4306
  %281 = lshr i32 %4307, 16
  %282 = and i32 %281, 255
  %283 = zext i32 %282 to i64
  %284 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 6, i64 %283
  %285 = load %struct.UpVal*, %struct.UpVal** %284, align 8, !tbaa !54
  %286 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %285, i64 0, i32 3
  %287 = load %struct.TValue*, %struct.TValue** %286, align 8, !tbaa !67
  %288 = bitcast %struct.TValue* %287 to i64*
  %289 = bitcast %union.StackValue* %4314 to i64*
  %290 = load i64, i64* %288, align 8
  store i64 %290, i64* %289, align 8
  %291 = getelementptr inbounds %struct.TValue, %struct.TValue* %287, i64 0, i32 1
  %292 = load i8, i8* %291, align 8, !tbaa !22
  %293 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %292, i8* %293, align 8, !tbaa !22
  %294 = icmp eq i32 %4309, 0
  br i1 %294, label %299, label %295

; <label>:295:                                    ; preds = %280
  %296 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %297 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %298 = getelementptr inbounds %union.StackValue, %union.StackValue* %297, i64 1
  br label %299

; <label>:299:                                    ; preds = %280, %295
  %300 = phi i32 [ %296, %295 ], [ 0, %280 ]
  %301 = phi %union.StackValue* [ %298, %295 ], [ %4308, %280 ]
  %302 = getelementptr inbounds i32, i32* %4310, i64 1
  %303 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:304:                                    ; preds = %4306
  %305 = lshr i32 %4307, 16
  %306 = and i32 %305, 255
  %307 = zext i32 %306 to i64
  %308 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 6, i64 %307
  %309 = load %struct.UpVal*, %struct.UpVal** %308, align 8, !tbaa !54
  %310 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %309, i64 0, i32 3
  %311 = load %struct.TValue*, %struct.TValue** %310, align 8, !tbaa !67
  %312 = bitcast %union.StackValue* %4314 to i64*
  %313 = bitcast %struct.TValue* %311 to i64*
  %314 = load i64, i64* %312, align 8
  store i64 %314, i64* %313, align 8
  %315 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %316 = load i8, i8* %315, align 8, !tbaa !22
  %317 = getelementptr inbounds %struct.TValue, %struct.TValue* %311, i64 0, i32 1
  store i8 %316, i8* %317, align 8, !tbaa !22
  %318 = load i8, i8* %315, align 8, !tbaa !21
  %319 = and i8 %318, 64
  %320 = icmp eq i8 %319, 0
  br i1 %320, label %335, label %321

; <label>:321:                                    ; preds = %304
  %322 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %309, i64 0, i32 2
  %323 = load i8, i8* %322, align 1, !tbaa !69
  %324 = and i8 %323, 32
  %325 = icmp eq i8 %324, 0
  br i1 %325, label %335, label %326

; <label>:326:                                    ; preds = %321
  %327 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0, i32 0, i32 0
  %328 = load %struct.GCObject*, %struct.GCObject** %327, align 8, !tbaa !21
  %329 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %328, i64 0, i32 2
  %330 = load i8, i8* %329, align 1, !tbaa !70
  %331 = and i8 %330, 24
  %332 = icmp eq i8 %331, 0
  br i1 %332, label %335, label %333

; <label>:333:                                    ; preds = %326
  %334 = bitcast %struct.UpVal* %309 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* %334, %struct.GCObject* %328) #16
  br label %335

; <label>:335:                                    ; preds = %326, %321, %304, %333
  %336 = icmp eq i32 %4309, 0
  br i1 %336, label %341, label %337

; <label>:337:                                    ; preds = %335
  %338 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %339 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %340 = getelementptr inbounds %union.StackValue, %union.StackValue* %339, i64 1
  br label %341

; <label>:341:                                    ; preds = %335, %337
  %342 = phi i32 [ %338, %337 ], [ 0, %335 ]
  %343 = phi %union.StackValue* [ %340, %337 ], [ %4308, %335 ]
  %344 = getelementptr inbounds i32, i32* %4310, i64 1
  %345 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:346:                                    ; preds = %4306
  %347 = lshr i32 %4307, 16
  %348 = and i32 %347, 255
  %349 = zext i32 %348 to i64
  %350 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 6, i64 %349
  %351 = load %struct.UpVal*, %struct.UpVal** %350, align 8, !tbaa !54
  %352 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %351, i64 0, i32 3
  %353 = load %struct.TValue*, %struct.TValue** %352, align 8, !tbaa !67
  %354 = lshr i32 %4307, 24
  %355 = zext i32 %354 to i64
  %356 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %355
  %357 = getelementptr inbounds %struct.TValue, %struct.TValue* %353, i64 0, i32 1
  %358 = load i8, i8* %357, align 8, !tbaa !22
  %359 = icmp eq i8 %358, 69
  br i1 %359, label %360, label %376

; <label>:360:                                    ; preds = %346
  %361 = bitcast %struct.TValue* %356 to %struct.TString**
  %362 = load %struct.TString*, %struct.TString** %361, align 8, !tbaa !21
  %363 = bitcast %struct.TValue* %353 to %struct.Table**
  %364 = load %struct.Table*, %struct.Table** %363, align 8, !tbaa !21
  %365 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %364, %struct.TString* %362) #16
  %366 = getelementptr inbounds %struct.TValue, %struct.TValue* %365, i64 0, i32 1
  %367 = load i8, i8* %366, align 8, !tbaa !22
  %368 = and i8 %367, 15
  %369 = icmp eq i8 %368, 0
  br i1 %369, label %376, label %370

; <label>:370:                                    ; preds = %360
  %371 = bitcast %struct.TValue* %365 to i64*
  %372 = bitcast %union.StackValue* %4314 to i64*
  %373 = load i64, i64* %371, align 8
  store i64 %373, i64* %372, align 8
  %374 = load i8, i8* %366, align 8, !tbaa !22
  %375 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %374, i8* %375, align 8, !tbaa !22
  br label %380

; <label>:376:                                    ; preds = %346, %360
  %377 = phi %struct.TValue* [ %365, %360 ], [ null, %346 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %378 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %378, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %353, %struct.TValue* %356, %union.StackValue* %4314, %struct.TValue* %377) #16
  %379 = load i32, i32* %38, align 8, !tbaa !21
  br label %380

; <label>:380:                                    ; preds = %376, %370
  %381 = phi i32 [ %4309, %370 ], [ %379, %376 ]
  %382 = icmp eq i32 %381, 0
  br i1 %382, label %387, label %383

; <label>:383:                                    ; preds = %380
  %384 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %385 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %386 = getelementptr inbounds %union.StackValue, %union.StackValue* %385, i64 1
  br label %387

; <label>:387:                                    ; preds = %380, %383
  %388 = phi i32 [ %384, %383 ], [ 0, %380 ]
  %389 = phi %union.StackValue* [ %386, %383 ], [ %4308, %380 ]
  %390 = getelementptr inbounds i32, i32* %4310, i64 1
  %391 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:392:                                    ; preds = %4306
  %393 = lshr i32 %4307, 16
  %394 = and i32 %393, 255
  %395 = zext i32 %394 to i64
  %396 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %395, i32 0
  %397 = lshr i32 %4307, 24
  %398 = zext i32 %397 to i64
  %399 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %398, i32 0
  %400 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %398, i32 0, i32 1
  %401 = load i8, i8* %400, align 8, !tbaa !22
  %402 = icmp eq i8 %401, 35
  br i1 %402, label %403, label %429

; <label>:403:                                    ; preds = %392
  %404 = bitcast %struct.TValue* %399 to i64*
  %405 = load i64, i64* %404, align 8, !tbaa !21
  %406 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %395, i32 0, i32 1
  %407 = load i8, i8* %406, align 8, !tbaa !22
  %408 = icmp eq i8 %407, 69
  br i1 %408, label %409, label %449

; <label>:409:                                    ; preds = %403
  %410 = add i64 %405, -1
  %411 = bitcast %struct.TValue* %396 to %struct.Table**
  %412 = load %struct.Table*, %struct.Table** %411, align 8, !tbaa !21
  %413 = getelementptr inbounds %struct.Table, %struct.Table* %412, i64 0, i32 5
  %414 = load i32, i32* %413, align 4, !tbaa !21
  %415 = zext i32 %414 to i64
  %416 = icmp ult i64 %410, %415
  br i1 %416, label %417, label %421

; <label>:417:                                    ; preds = %409
  %418 = getelementptr inbounds %struct.Table, %struct.Table* %412, i64 0, i32 6
  %419 = load %struct.TValue*, %struct.TValue** %418, align 8, !tbaa !21
  %420 = getelementptr inbounds %struct.TValue, %struct.TValue* %419, i64 %410
  br label %423

; <label>:421:                                    ; preds = %409
  %422 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %412, i64 %405) #16
  br label %423

; <label>:423:                                    ; preds = %417, %421
  %424 = phi %struct.TValue* [ %420, %417 ], [ %422, %421 ]
  %425 = getelementptr inbounds %struct.TValue, %struct.TValue* %424, i64 0, i32 1
  %426 = load i8, i8* %425, align 8, !tbaa !22
  %427 = and i8 %426, 15
  %428 = icmp eq i8 %427, 0
  br i1 %428, label %449, label %441

; <label>:429:                                    ; preds = %392
  %430 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %395, i32 0, i32 1
  %431 = load i8, i8* %430, align 8, !tbaa !22
  %432 = icmp eq i8 %431, 69
  br i1 %432, label %433, label %449

; <label>:433:                                    ; preds = %429
  %434 = bitcast %struct.TValue* %396 to %struct.Table**
  %435 = load %struct.Table*, %struct.Table** %434, align 8, !tbaa !21
  %436 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %435, %struct.TValue* nonnull %399) #16
  %437 = getelementptr inbounds %struct.TValue, %struct.TValue* %436, i64 0, i32 1
  %438 = load i8, i8* %437, align 8, !tbaa !22
  %439 = and i8 %438, 15
  %440 = icmp eq i8 %439, 0
  br i1 %440, label %449, label %441

; <label>:441:                                    ; preds = %423, %433
  %442 = phi i8* [ %425, %423 ], [ %437, %433 ]
  %443 = phi %struct.TValue* [ %424, %423 ], [ %436, %433 ]
  %444 = bitcast %struct.TValue* %443 to i64*
  %445 = bitcast %union.StackValue* %4314 to i64*
  %446 = load i64, i64* %444, align 8
  store i64 %446, i64* %445, align 8
  %447 = load i8, i8* %442, align 8, !tbaa !22
  %448 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %447, i8* %448, align 8, !tbaa !22
  br label %453

; <label>:449:                                    ; preds = %403, %429, %423, %433
  %450 = phi %struct.TValue* [ %424, %423 ], [ %436, %433 ], [ null, %429 ], [ null, %403 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %451 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %451, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* nonnull %396, %struct.TValue* nonnull %399, %union.StackValue* %4314, %struct.TValue* %450) #16
  %452 = load i32, i32* %38, align 8, !tbaa !21
  br label %453

; <label>:453:                                    ; preds = %449, %441
  %454 = phi i32 [ %4309, %441 ], [ %452, %449 ]
  %455 = icmp eq i32 %454, 0
  br i1 %455, label %460, label %456

; <label>:456:                                    ; preds = %453
  %457 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %458 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %459 = getelementptr inbounds %union.StackValue, %union.StackValue* %458, i64 1
  br label %460

; <label>:460:                                    ; preds = %453, %456
  %461 = phi i32 [ %457, %456 ], [ 0, %453 ]
  %462 = phi %union.StackValue* [ %459, %456 ], [ %4308, %453 ]
  %463 = getelementptr inbounds i32, i32* %4310, i64 1
  %464 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:465:                                    ; preds = %4306
  %466 = lshr i32 %4307, 16
  %467 = and i32 %466, 255
  %468 = zext i32 %467 to i64
  %469 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %468, i32 0
  %470 = lshr i32 %4307, 24
  %471 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %468, i32 0, i32 1
  %472 = load i8, i8* %471, align 8, !tbaa !22
  %473 = icmp eq i8 %472, 69
  %474 = zext i32 %470 to i64
  br i1 %473, label %475, label %503

; <label>:475:                                    ; preds = %465
  %476 = add nsw i64 %474, -1
  %477 = bitcast %struct.TValue* %469 to %struct.Table**
  %478 = load %struct.Table*, %struct.Table** %477, align 8, !tbaa !21
  %479 = getelementptr inbounds %struct.Table, %struct.Table* %478, i64 0, i32 5
  %480 = load i32, i32* %479, align 4, !tbaa !21
  %481 = zext i32 %480 to i64
  %482 = icmp ult i64 %476, %481
  br i1 %482, label %483, label %489

; <label>:483:                                    ; preds = %475
  %484 = getelementptr inbounds %struct.Table, %struct.Table* %478, i64 0, i32 6
  %485 = load %struct.TValue*, %struct.TValue** %484, align 8, !tbaa !21
  %486 = add nsw i32 %470, -1
  %487 = sext i32 %486 to i64
  %488 = getelementptr inbounds %struct.TValue, %struct.TValue* %485, i64 %487
  br label %491

; <label>:489:                                    ; preds = %475
  %490 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %478, i64 %474) #16
  br label %491

; <label>:491:                                    ; preds = %489, %483
  %492 = phi %struct.TValue* [ %488, %483 ], [ %490, %489 ]
  %493 = getelementptr inbounds %struct.TValue, %struct.TValue* %492, i64 0, i32 1
  %494 = load i8, i8* %493, align 8, !tbaa !22
  %495 = and i8 %494, 15
  %496 = icmp eq i8 %495, 0
  br i1 %496, label %503, label %497

; <label>:497:                                    ; preds = %491
  %498 = bitcast %struct.TValue* %492 to i64*
  %499 = bitcast %union.StackValue* %4314 to i64*
  %500 = load i64, i64* %498, align 8
  store i64 %500, i64* %499, align 8
  %501 = load i8, i8* %493, align 8, !tbaa !22
  %502 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %501, i8* %502, align 8, !tbaa !22
  br label %507

; <label>:503:                                    ; preds = %465, %491
  %504 = phi %struct.TValue* [ %492, %491 ], [ null, %465 ]
  store i64 %474, i64* %43, align 8, !tbaa !21
  store i8 35, i8* %44, align 8, !tbaa !22
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %505 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %505, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %469, %struct.TValue* nonnull %20, %union.StackValue* %4314, %struct.TValue* %504) #16
  %506 = load i32, i32* %38, align 8, !tbaa !21
  br label %507

; <label>:507:                                    ; preds = %503, %497
  %508 = phi i32 [ %4309, %497 ], [ %506, %503 ]
  %509 = icmp eq i32 %508, 0
  br i1 %509, label %514, label %510

; <label>:510:                                    ; preds = %507
  %511 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %512 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %513 = getelementptr inbounds %union.StackValue, %union.StackValue* %512, i64 1
  br label %514

; <label>:514:                                    ; preds = %507, %510
  %515 = phi i32 [ %511, %510 ], [ 0, %507 ]
  %516 = phi %union.StackValue* [ %513, %510 ], [ %4308, %507 ]
  %517 = getelementptr inbounds i32, i32* %4310, i64 1
  %518 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:519:                                    ; preds = %4306
  %520 = lshr i32 %4307, 16
  %521 = and i32 %520, 255
  %522 = zext i32 %521 to i64
  %523 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %522, i32 0
  %524 = lshr i32 %4307, 24
  %525 = zext i32 %524 to i64
  %526 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %525
  %527 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %522, i32 0, i32 1
  %528 = load i8, i8* %527, align 8, !tbaa !22
  %529 = icmp eq i8 %528, 69
  br i1 %529, label %530, label %546

; <label>:530:                                    ; preds = %519
  %531 = bitcast %struct.TValue* %526 to %struct.TString**
  %532 = load %struct.TString*, %struct.TString** %531, align 8, !tbaa !21
  %533 = bitcast %struct.TValue* %523 to %struct.Table**
  %534 = load %struct.Table*, %struct.Table** %533, align 8, !tbaa !21
  %535 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %534, %struct.TString* %532) #16
  %536 = getelementptr inbounds %struct.TValue, %struct.TValue* %535, i64 0, i32 1
  %537 = load i8, i8* %536, align 8, !tbaa !22
  %538 = and i8 %537, 15
  %539 = icmp eq i8 %538, 0
  br i1 %539, label %546, label %540

; <label>:540:                                    ; preds = %530
  %541 = bitcast %struct.TValue* %535 to i64*
  %542 = bitcast %union.StackValue* %4314 to i64*
  %543 = load i64, i64* %541, align 8
  store i64 %543, i64* %542, align 8
  %544 = load i8, i8* %536, align 8, !tbaa !22
  %545 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %544, i8* %545, align 8, !tbaa !22
  br label %550

; <label>:546:                                    ; preds = %519, %530
  %547 = phi %struct.TValue* [ %535, %530 ], [ null, %519 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %548 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %548, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %523, %struct.TValue* %526, %union.StackValue* %4314, %struct.TValue* %547) #16
  %549 = load i32, i32* %38, align 8, !tbaa !21
  br label %550

; <label>:550:                                    ; preds = %546, %540
  %551 = phi i32 [ %4309, %540 ], [ %549, %546 ]
  %552 = icmp eq i32 %551, 0
  br i1 %552, label %557, label %553

; <label>:553:                                    ; preds = %550
  %554 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %555 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %556 = getelementptr inbounds %union.StackValue, %union.StackValue* %555, i64 1
  br label %557

; <label>:557:                                    ; preds = %550, %553
  %558 = phi i32 [ %554, %553 ], [ 0, %550 ]
  %559 = phi %union.StackValue* [ %556, %553 ], [ %4308, %550 ]
  %560 = getelementptr inbounds i32, i32* %4310, i64 1
  %561 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:562:                                    ; preds = %4306
  %563 = lshr i32 %4307, 7
  %564 = and i32 %563, 255
  %565 = zext i32 %564 to i64
  %566 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 6, i64 %565
  %567 = load %struct.UpVal*, %struct.UpVal** %566, align 8, !tbaa !54
  %568 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %567, i64 0, i32 3
  %569 = load %struct.TValue*, %struct.TValue** %568, align 8, !tbaa !67
  %570 = lshr i32 %4307, 16
  %571 = and i32 %570, 255
  %572 = zext i32 %571 to i64
  %573 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %572
  %574 = trunc i32 %4307 to i16
  %575 = icmp slt i16 %574, 0
  %576 = lshr i32 %4307, 24
  %577 = zext i32 %576 to i64
  %578 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %577
  %579 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %577, i32 0
  %580 = select i1 %575, %struct.TValue* %578, %struct.TValue* %579
  %581 = getelementptr inbounds %struct.TValue, %struct.TValue* %569, i64 0, i32 1
  %582 = load i8, i8* %581, align 8, !tbaa !22
  %583 = icmp eq i8 %582, 69
  br i1 %583, label %584, label %618

; <label>:584:                                    ; preds = %562
  %585 = bitcast %struct.TValue* %573 to %struct.TString**
  %586 = load %struct.TString*, %struct.TString** %585, align 8, !tbaa !21
  %587 = getelementptr inbounds %struct.TValue, %struct.TValue* %569, i64 0, i32 0, i32 0
  %588 = bitcast %struct.TValue* %569 to %struct.Table**
  %589 = load %struct.Table*, %struct.Table** %588, align 8, !tbaa !21
  %590 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %589, %struct.TString* %586) #16
  %591 = getelementptr inbounds %struct.TValue, %struct.TValue* %590, i64 0, i32 1
  %592 = load i8, i8* %591, align 8, !tbaa !22
  %593 = and i8 %592, 15
  %594 = icmp eq i8 %593, 0
  br i1 %594, label %618, label %595

; <label>:595:                                    ; preds = %584
  %596 = bitcast %struct.TValue* %580 to i64*
  %597 = bitcast %struct.TValue* %590 to i64*
  %598 = load i64, i64* %596, align 8
  store i64 %598, i64* %597, align 8
  %599 = getelementptr inbounds %struct.TValue, %struct.TValue* %580, i64 0, i32 1
  %600 = load i8, i8* %599, align 8, !tbaa !22
  store i8 %600, i8* %591, align 8, !tbaa !22
  %601 = load i8, i8* %599, align 8, !tbaa !22
  %602 = and i8 %601, 64
  %603 = icmp eq i8 %602, 0
  br i1 %603, label %622, label %604

; <label>:604:                                    ; preds = %595
  %605 = load %struct.GCObject*, %struct.GCObject** %587, align 8, !tbaa !21
  %606 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %605, i64 0, i32 2
  %607 = load i8, i8* %606, align 1, !tbaa !70
  %608 = and i8 %607, 32
  %609 = icmp eq i8 %608, 0
  br i1 %609, label %622, label %610

; <label>:610:                                    ; preds = %604
  %611 = getelementptr inbounds %struct.TValue, %struct.TValue* %580, i64 0, i32 0, i32 0
  %612 = load %struct.GCObject*, %struct.GCObject** %611, align 8, !tbaa !21
  %613 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %612, i64 0, i32 2
  %614 = load i8, i8* %613, align 1, !tbaa !70
  %615 = and i8 %614, 24
  %616 = icmp eq i8 %615, 0
  br i1 %616, label %622, label %617

; <label>:617:                                    ; preds = %610
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %605) #16
  br label %622

; <label>:618:                                    ; preds = %562, %584
  %619 = phi %struct.TValue* [ %590, %584 ], [ null, %562 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %620 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %620, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %569, %struct.TValue* %573, %struct.TValue* %580, %struct.TValue* %619) #16
  %621 = load i32, i32* %38, align 8, !tbaa !21
  br label %622

; <label>:622:                                    ; preds = %610, %604, %595, %617, %618
  %623 = phi i32 [ %4309, %617 ], [ %4309, %610 ], [ %4309, %604 ], [ %4309, %595 ], [ %621, %618 ]
  %624 = icmp eq i32 %623, 0
  br i1 %624, label %629, label %625

; <label>:625:                                    ; preds = %622
  %626 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %627 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %628 = getelementptr inbounds %union.StackValue, %union.StackValue* %627, i64 1
  br label %629

; <label>:629:                                    ; preds = %622, %625
  %630 = phi i32 [ %626, %625 ], [ 0, %622 ]
  %631 = phi %union.StackValue* [ %628, %625 ], [ %4308, %622 ]
  %632 = getelementptr inbounds i32, i32* %4310, i64 1
  %633 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:634:                                    ; preds = %4306
  %635 = lshr i32 %4307, 16
  %636 = and i32 %635, 255
  %637 = zext i32 %636 to i64
  %638 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %637, i32 0
  %639 = trunc i32 %4307 to i16
  %640 = icmp slt i16 %639, 0
  %641 = lshr i32 %4307, 24
  %642 = zext i32 %641 to i64
  %643 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %642
  %644 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %642, i32 0
  %645 = select i1 %640, %struct.TValue* %643, %struct.TValue* %644
  %646 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %637, i32 0, i32 1
  %647 = load i8, i8* %646, align 8, !tbaa !22
  %648 = icmp eq i8 %647, 35
  br i1 %648, label %649, label %675

; <label>:649:                                    ; preds = %634
  %650 = bitcast %struct.TValue* %638 to i64*
  %651 = load i64, i64* %650, align 8, !tbaa !21
  %652 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %653 = load i8, i8* %652, align 8, !tbaa !21
  %654 = icmp eq i8 %653, 69
  br i1 %654, label %655, label %713

; <label>:655:                                    ; preds = %649
  %656 = add i64 %651, -1
  %657 = bitcast %union.StackValue* %4314 to %struct.Table**
  %658 = load %struct.Table*, %struct.Table** %657, align 8, !tbaa !21
  %659 = getelementptr inbounds %struct.Table, %struct.Table* %658, i64 0, i32 5
  %660 = load i32, i32* %659, align 4, !tbaa !21
  %661 = zext i32 %660 to i64
  %662 = icmp ult i64 %656, %661
  br i1 %662, label %663, label %667

; <label>:663:                                    ; preds = %655
  %664 = getelementptr inbounds %struct.Table, %struct.Table* %658, i64 0, i32 6
  %665 = load %struct.TValue*, %struct.TValue** %664, align 8, !tbaa !21
  %666 = getelementptr inbounds %struct.TValue, %struct.TValue* %665, i64 %656
  br label %669

; <label>:667:                                    ; preds = %655
  %668 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %658, i64 %651) #16
  br label %669

; <label>:669:                                    ; preds = %663, %667
  %670 = phi %struct.TValue* [ %666, %663 ], [ %668, %667 ]
  %671 = getelementptr inbounds %struct.TValue, %struct.TValue* %670, i64 0, i32 1
  %672 = load i8, i8* %671, align 8, !tbaa !22
  %673 = and i8 %672, 15
  %674 = icmp eq i8 %673, 0
  br i1 %674, label %713, label %687

; <label>:675:                                    ; preds = %634
  %676 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %677 = load i8, i8* %676, align 8, !tbaa !21
  %678 = icmp eq i8 %677, 69
  br i1 %678, label %679, label %713

; <label>:679:                                    ; preds = %675
  %680 = bitcast %union.StackValue* %4314 to %struct.Table**
  %681 = load %struct.Table*, %struct.Table** %680, align 8, !tbaa !21
  %682 = call fastcc %struct.TValue* @luaH_get(%struct.Table* %681, %struct.TValue* %638) #16
  %683 = getelementptr inbounds %struct.TValue, %struct.TValue* %682, i64 0, i32 1
  %684 = load i8, i8* %683, align 8, !tbaa !22
  %685 = and i8 %684, 15
  %686 = icmp eq i8 %685, 0
  br i1 %686, label %713, label %687

; <label>:687:                                    ; preds = %669, %679
  %688 = phi i8* [ %671, %669 ], [ %683, %679 ]
  %689 = phi %struct.TValue* [ %670, %669 ], [ %682, %679 ]
  %690 = bitcast %struct.TValue* %645 to i64*
  %691 = bitcast %struct.TValue* %689 to i64*
  %692 = load i64, i64* %690, align 8
  store i64 %692, i64* %691, align 8
  %693 = getelementptr inbounds %struct.TValue, %struct.TValue* %645, i64 0, i32 1
  %694 = load i8, i8* %693, align 8, !tbaa !22
  store i8 %694, i8* %688, align 8, !tbaa !22
  %695 = load i8, i8* %693, align 8, !tbaa !22
  %696 = and i8 %695, 64
  %697 = icmp eq i8 %696, 0
  br i1 %697, label %718, label %698

; <label>:698:                                    ; preds = %687
  %699 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0, i32 0, i32 0
  %700 = load %struct.GCObject*, %struct.GCObject** %699, align 8, !tbaa !21
  %701 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %700, i64 0, i32 2
  %702 = load i8, i8* %701, align 1, !tbaa !70
  %703 = and i8 %702, 32
  %704 = icmp eq i8 %703, 0
  br i1 %704, label %718, label %705

; <label>:705:                                    ; preds = %698
  %706 = getelementptr inbounds %struct.TValue, %struct.TValue* %645, i64 0, i32 0, i32 0
  %707 = load %struct.GCObject*, %struct.GCObject** %706, align 8, !tbaa !21
  %708 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %707, i64 0, i32 2
  %709 = load i8, i8* %708, align 1, !tbaa !70
  %710 = and i8 %709, 24
  %711 = icmp eq i8 %710, 0
  br i1 %711, label %718, label %712

; <label>:712:                                    ; preds = %705
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %700) #16
  br label %718

; <label>:713:                                    ; preds = %649, %675, %669, %679
  %714 = phi %struct.TValue* [ %670, %669 ], [ %682, %679 ], [ null, %675 ], [ null, %649 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %715 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %715, i64* %35, align 8, !tbaa !20
  %716 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %716, %struct.TValue* %638, %struct.TValue* %645, %struct.TValue* %714) #16
  %717 = load i32, i32* %38, align 8, !tbaa !21
  br label %718

; <label>:718:                                    ; preds = %705, %698, %687, %712, %713
  %719 = phi i32 [ %4309, %712 ], [ %4309, %705 ], [ %4309, %698 ], [ %4309, %687 ], [ %717, %713 ]
  %720 = icmp eq i32 %719, 0
  br i1 %720, label %725, label %721

; <label>:721:                                    ; preds = %718
  %722 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %723 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %724 = getelementptr inbounds %union.StackValue, %union.StackValue* %723, i64 1
  br label %725

; <label>:725:                                    ; preds = %718, %721
  %726 = phi i32 [ %722, %721 ], [ 0, %718 ]
  %727 = phi %union.StackValue* [ %724, %721 ], [ %4308, %718 ]
  %728 = getelementptr inbounds i32, i32* %4310, i64 1
  %729 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:730:                                    ; preds = %4306
  %731 = lshr i32 %4307, 16
  %732 = and i32 %731, 255
  %733 = trunc i32 %4307 to i16
  %734 = icmp slt i16 %733, 0
  %735 = lshr i32 %4307, 24
  %736 = zext i32 %735 to i64
  %737 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %736
  %738 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %736, i32 0
  %739 = select i1 %734, %struct.TValue* %737, %struct.TValue* %738
  %740 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %741 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %742 = load i8, i8* %741, align 8, !tbaa !21
  %743 = icmp eq i8 %742, 69
  %744 = zext i32 %732 to i64
  br i1 %743, label %745, label %791

; <label>:745:                                    ; preds = %730
  %746 = add nsw i64 %744, -1
  %747 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0, i32 0, i32 0
  %748 = bitcast %union.StackValue* %4314 to %struct.Table**
  %749 = load %struct.Table*, %struct.Table** %748, align 8, !tbaa !21
  %750 = getelementptr inbounds %struct.Table, %struct.Table* %749, i64 0, i32 5
  %751 = load i32, i32* %750, align 4, !tbaa !21
  %752 = zext i32 %751 to i64
  %753 = icmp ult i64 %746, %752
  br i1 %753, label %754, label %760

; <label>:754:                                    ; preds = %745
  %755 = getelementptr inbounds %struct.Table, %struct.Table* %749, i64 0, i32 6
  %756 = load %struct.TValue*, %struct.TValue** %755, align 8, !tbaa !21
  %757 = add nsw i32 %732, -1
  %758 = sext i32 %757 to i64
  %759 = getelementptr inbounds %struct.TValue, %struct.TValue* %756, i64 %758
  br label %762

; <label>:760:                                    ; preds = %745
  %761 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %749, i64 %744) #16
  br label %762

; <label>:762:                                    ; preds = %760, %754
  %763 = phi %struct.TValue* [ %759, %754 ], [ %761, %760 ]
  %764 = getelementptr inbounds %struct.TValue, %struct.TValue* %763, i64 0, i32 1
  %765 = load i8, i8* %764, align 8, !tbaa !22
  %766 = and i8 %765, 15
  %767 = icmp eq i8 %766, 0
  br i1 %767, label %791, label %768

; <label>:768:                                    ; preds = %762
  %769 = bitcast %struct.TValue* %739 to i64*
  %770 = bitcast %struct.TValue* %763 to i64*
  %771 = load i64, i64* %769, align 8
  store i64 %771, i64* %770, align 8
  %772 = getelementptr inbounds %struct.TValue, %struct.TValue* %739, i64 0, i32 1
  %773 = load i8, i8* %772, align 8, !tbaa !22
  store i8 %773, i8* %764, align 8, !tbaa !22
  %774 = load i8, i8* %772, align 8, !tbaa !22
  %775 = and i8 %774, 64
  %776 = icmp eq i8 %775, 0
  br i1 %776, label %795, label %777

; <label>:777:                                    ; preds = %768
  %778 = load %struct.GCObject*, %struct.GCObject** %747, align 8, !tbaa !21
  %779 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %778, i64 0, i32 2
  %780 = load i8, i8* %779, align 1, !tbaa !70
  %781 = and i8 %780, 32
  %782 = icmp eq i8 %781, 0
  br i1 %782, label %795, label %783

; <label>:783:                                    ; preds = %777
  %784 = getelementptr inbounds %struct.TValue, %struct.TValue* %739, i64 0, i32 0, i32 0
  %785 = load %struct.GCObject*, %struct.GCObject** %784, align 8, !tbaa !21
  %786 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %785, i64 0, i32 2
  %787 = load i8, i8* %786, align 1, !tbaa !70
  %788 = and i8 %787, 24
  %789 = icmp eq i8 %788, 0
  br i1 %789, label %795, label %790

; <label>:790:                                    ; preds = %783
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %778) #16
  br label %795

; <label>:791:                                    ; preds = %730, %762
  %792 = phi %struct.TValue* [ %763, %762 ], [ null, %730 ]
  store i64 %744, i64* %45, align 8, !tbaa !21
  store i8 35, i8* %46, align 8, !tbaa !22
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %793 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %793, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %740, %struct.TValue* nonnull %21, %struct.TValue* %739, %struct.TValue* %792) #16
  %794 = load i32, i32* %38, align 8, !tbaa !21
  br label %795

; <label>:795:                                    ; preds = %783, %777, %768, %790, %791
  %796 = phi i32 [ %4309, %790 ], [ %4309, %783 ], [ %4309, %777 ], [ %4309, %768 ], [ %794, %791 ]
  %797 = icmp eq i32 %796, 0
  br i1 %797, label %802, label %798

; <label>:798:                                    ; preds = %795
  %799 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %800 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %801 = getelementptr inbounds %union.StackValue, %union.StackValue* %800, i64 1
  br label %802

; <label>:802:                                    ; preds = %795, %798
  %803 = phi i32 [ %799, %798 ], [ 0, %795 ]
  %804 = phi %union.StackValue* [ %801, %798 ], [ %4308, %795 ]
  %805 = getelementptr inbounds i32, i32* %4310, i64 1
  %806 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:807:                                    ; preds = %4306
  %808 = lshr i32 %4307, 16
  %809 = and i32 %808, 255
  %810 = zext i32 %809 to i64
  %811 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %810
  %812 = trunc i32 %4307 to i16
  %813 = icmp slt i16 %812, 0
  %814 = lshr i32 %4307, 24
  %815 = zext i32 %814 to i64
  %816 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %815
  %817 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %815, i32 0
  %818 = select i1 %813, %struct.TValue* %816, %struct.TValue* %817
  %819 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %820 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %821 = load i8, i8* %820, align 8, !tbaa !21
  %822 = icmp eq i8 %821, 69
  br i1 %822, label %823, label %857

; <label>:823:                                    ; preds = %807
  %824 = bitcast %struct.TValue* %811 to %struct.TString**
  %825 = load %struct.TString*, %struct.TString** %824, align 8, !tbaa !21
  %826 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0, i32 0, i32 0
  %827 = bitcast %union.StackValue* %4314 to %struct.Table**
  %828 = load %struct.Table*, %struct.Table** %827, align 8, !tbaa !21
  %829 = call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %828, %struct.TString* %825) #16
  %830 = getelementptr inbounds %struct.TValue, %struct.TValue* %829, i64 0, i32 1
  %831 = load i8, i8* %830, align 8, !tbaa !22
  %832 = and i8 %831, 15
  %833 = icmp eq i8 %832, 0
  br i1 %833, label %857, label %834

; <label>:834:                                    ; preds = %823
  %835 = bitcast %struct.TValue* %818 to i64*
  %836 = bitcast %struct.TValue* %829 to i64*
  %837 = load i64, i64* %835, align 8
  store i64 %837, i64* %836, align 8
  %838 = getelementptr inbounds %struct.TValue, %struct.TValue* %818, i64 0, i32 1
  %839 = load i8, i8* %838, align 8, !tbaa !22
  store i8 %839, i8* %830, align 8, !tbaa !22
  %840 = load i8, i8* %838, align 8, !tbaa !22
  %841 = and i8 %840, 64
  %842 = icmp eq i8 %841, 0
  br i1 %842, label %861, label %843

; <label>:843:                                    ; preds = %834
  %844 = load %struct.GCObject*, %struct.GCObject** %826, align 8, !tbaa !21
  %845 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %844, i64 0, i32 2
  %846 = load i8, i8* %845, align 1, !tbaa !70
  %847 = and i8 %846, 32
  %848 = icmp eq i8 %847, 0
  br i1 %848, label %861, label %849

; <label>:849:                                    ; preds = %843
  %850 = getelementptr inbounds %struct.TValue, %struct.TValue* %818, i64 0, i32 0, i32 0
  %851 = load %struct.GCObject*, %struct.GCObject** %850, align 8, !tbaa !21
  %852 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %851, i64 0, i32 2
  %853 = load i8, i8* %852, align 1, !tbaa !70
  %854 = and i8 %853, 24
  %855 = icmp eq i8 %854, 0
  br i1 %855, label %861, label %856

; <label>:856:                                    ; preds = %849
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %844) #16
  br label %861

; <label>:857:                                    ; preds = %807, %823
  %858 = phi %struct.TValue* [ %829, %823 ], [ null, %807 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %859 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %859, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishset(%struct.lua_State* %0, %struct.TValue* %819, %struct.TValue* %811, %struct.TValue* %818, %struct.TValue* %858) #16
  %860 = load i32, i32* %38, align 8, !tbaa !21
  br label %861

; <label>:861:                                    ; preds = %849, %843, %834, %856, %857
  %862 = phi i32 [ %4309, %856 ], [ %4309, %849 ], [ %4309, %843 ], [ %4309, %834 ], [ %860, %857 ]
  %863 = icmp eq i32 %862, 0
  br i1 %863, label %868, label %864

; <label>:864:                                    ; preds = %861
  %865 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %866 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %867 = getelementptr inbounds %union.StackValue, %union.StackValue* %866, i64 1
  br label %868

; <label>:868:                                    ; preds = %861, %864
  %869 = phi i32 [ %865, %864 ], [ 0, %861 ]
  %870 = phi %union.StackValue* [ %867, %864 ], [ %4308, %861 ]
  %871 = getelementptr inbounds i32, i32* %4310, i64 1
  %872 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:873:                                    ; preds = %4306
  %874 = lshr i32 %4307, 16
  %875 = and i32 %874, 255
  %876 = lshr i32 %4307, 24
  %877 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %877, i64* %35, align 8, !tbaa !20
  %878 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %879 = call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 56, i32 5) #17
  %880 = getelementptr inbounds %struct.global_State, %struct.global_State* %878, i64 0, i32 10
  %881 = load i8, i8* %880, align 4, !tbaa !15
  %882 = and i8 %881, 24
  %883 = getelementptr inbounds i8, i8* %879, i64 9
  store i8 %882, i8* %883, align 1, !tbaa !70
  %884 = getelementptr inbounds i8, i8* %879, i64 8
  store i8 5, i8* %884, align 8, !tbaa !86
  %885 = getelementptr inbounds %struct.global_State, %struct.global_State* %878, i64 0, i32 20
  %886 = bitcast %struct.GCObject** %885 to i64*
  %887 = load i64, i64* %886, align 8, !tbaa !18
  %888 = bitcast i8* %879 to i64*
  store i64 %887, i64* %888, align 8, !tbaa !87
  %889 = bitcast %struct.GCObject** %885 to i8**
  store i8* %879, i8** %889, align 8, !tbaa !18
  %890 = bitcast i8* %879 to %struct.Table*
  %891 = getelementptr inbounds i8, i8* %879, i64 40
  %892 = bitcast i8* %891 to %struct.Table**
  store %struct.Table* null, %struct.Table** %892, align 8, !tbaa !88
  %893 = getelementptr inbounds i8, i8* %879, i64 10
  store i8 -1, i8* %893, align 2, !tbaa !90
  %894 = getelementptr inbounds i8, i8* %879, i64 16
  %895 = bitcast i8* %894 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %895, align 8, !tbaa !91
  %896 = getelementptr inbounds i8, i8* %879, i64 12
  %897 = bitcast i8* %896 to i32*
  store i32 0, i32* %897, align 4, !tbaa !92
  %898 = getelementptr inbounds i8, i8* %879, i64 24
  %899 = getelementptr inbounds i8, i8* %879, i64 11
  store i8 0, i8* %899, align 1, !tbaa !93
  %900 = bitcast i8* %898 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %900, align 8, !tbaa !54
  %901 = bitcast %union.StackValue* %4314 to i8**
  store i8* %879, i8** %901, align 8, !tbaa !21
  %902 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 69, i8* %902, align 8, !tbaa !22
  %903 = or i32 %875, %876
  %904 = icmp eq i32 %903, 0
  br i1 %904, label %924, label %905

; <label>:905:                                    ; preds = %873
  %906 = icmp ult i32 %875, 8
  br i1 %906, label %913, label %907

; <label>:907:                                    ; preds = %905
  %908 = and i32 %874, 7
  %909 = or i32 %908, 8
  %910 = lshr i32 %875, 3
  %911 = add nsw i32 %910, -1
  %912 = shl i32 %909, %911
  br label %913

; <label>:913:                                    ; preds = %905, %907
  %914 = phi i32 [ %912, %907 ], [ %875, %905 ]
  %915 = icmp ult i32 %4307, 134217728
  br i1 %915, label %922, label %916

; <label>:916:                                    ; preds = %913
  %917 = and i32 %876, 7
  %918 = or i32 %917, 8
  %919 = lshr i32 %4307, 27
  %920 = add nsw i32 %919, -1
  %921 = shl i32 %918, %920
  br label %922

; <label>:922:                                    ; preds = %913, %916
  %923 = phi i32 [ %921, %916 ], [ %876, %913 ]
  call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* %890, i32 %914, i32 %923) #16
  br label %924

; <label>:924:                                    ; preds = %873, %922
  %925 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %926 = getelementptr inbounds %struct.global_State, %struct.global_State* %925, i64 0, i32 3
  %927 = load i64, i64* %926, align 8, !tbaa !11
  %928 = icmp sgt i64 %927, 0
  br i1 %928, label %929, label %932

; <label>:929:                                    ; preds = %924
  %930 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1
  store %union.StackValue* %930, %union.StackValue** %34, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  %931 = load i32, i32* %38, align 8, !tbaa !21
  br label %932

; <label>:932:                                    ; preds = %929, %924
  %933 = phi i32 [ %931, %929 ], [ %4309, %924 ]
  %934 = icmp eq i32 %933, 0
  br i1 %934, label %939, label %935

; <label>:935:                                    ; preds = %932
  %936 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4310) #16
  %937 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %938 = getelementptr inbounds %union.StackValue, %union.StackValue* %937, i64 1
  br label %939

; <label>:939:                                    ; preds = %932, %935
  %940 = phi i32 [ %936, %935 ], [ 0, %932 ]
  %941 = phi %union.StackValue* [ %938, %935 ], [ %4308, %932 ]
  %942 = getelementptr inbounds i32, i32* %4310, i64 1
  %943 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:944:                                    ; preds = %4306
  %945 = lshr i32 %4307, 16
  %946 = and i32 %945, 255
  %947 = zext i32 %946 to i64
  %948 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %947, i32 0
  %949 = trunc i32 %4307 to i16
  %950 = icmp slt i16 %949, 0
  %951 = lshr i32 %4307, 24
  %952 = zext i32 %951 to i64
  %953 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %952
  %954 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %952, i32 0
  %955 = select i1 %950, %struct.TValue* %953, %struct.TValue* %954
  %956 = bitcast %struct.TValue* %955 to %struct.TString**
  %957 = load %struct.TString*, %struct.TString** %956, align 8, !tbaa !21
  %958 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0
  %959 = bitcast %struct.TValue* %948 to i64*
  %960 = bitcast %struct.TValue* %958 to i64*
  %961 = load i64, i64* %959, align 8
  store i64 %961, i64* %960, align 8
  %962 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %947, i32 0, i32 1
  %963 = load i8, i8* %962, align 8, !tbaa !22
  %964 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 1
  store i8 %963, i8* %964, align 8, !tbaa !22
  %965 = load i8, i8* %962, align 8, !tbaa !22
  %966 = icmp eq i8 %965, 69
  br i1 %966, label %967, label %981

; <label>:967:                                    ; preds = %944
  %968 = bitcast %struct.TValue* %948 to %struct.Table**
  %969 = load %struct.Table*, %struct.Table** %968, align 8, !tbaa !21
  %970 = call fastcc %struct.TValue* @luaH_getstr(%struct.Table* %969, %struct.TString* %957) #16
  %971 = getelementptr inbounds %struct.TValue, %struct.TValue* %970, i64 0, i32 1
  %972 = load i8, i8* %971, align 8, !tbaa !22
  %973 = and i8 %972, 15
  %974 = icmp eq i8 %973, 0
  br i1 %974, label %981, label %975

; <label>:975:                                    ; preds = %967
  %976 = bitcast %struct.TValue* %970 to i64*
  %977 = bitcast %union.StackValue* %4314 to i64*
  %978 = load i64, i64* %976, align 8
  store i64 %978, i64* %977, align 8
  %979 = load i8, i8* %971, align 8, !tbaa !22
  %980 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %979, i8* %980, align 8, !tbaa !22
  br label %985

; <label>:981:                                    ; preds = %944, %967
  %982 = phi %struct.TValue* [ %970, %967 ], [ null, %944 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %983 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %983, i64* %35, align 8, !tbaa !20
  call fastcc void @luaV_finishget(%struct.lua_State* %0, %struct.TValue* %948, %struct.TValue* %955, %union.StackValue* nonnull %4314, %struct.TValue* %982) #16
  %984 = load i32, i32* %38, align 8, !tbaa !21
  br label %985

; <label>:985:                                    ; preds = %981, %975
  %986 = phi i32 [ %4309, %975 ], [ %984, %981 ]
  %987 = icmp eq i32 %986, 0
  br i1 %987, label %992, label %988

; <label>:988:                                    ; preds = %985
  %989 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %990 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %991 = getelementptr inbounds %union.StackValue, %union.StackValue* %990, i64 1
  br label %992

; <label>:992:                                    ; preds = %985, %988
  %993 = phi i32 [ %989, %988 ], [ 0, %985 ]
  %994 = phi %union.StackValue* [ %991, %988 ], [ %4308, %985 ]
  %995 = getelementptr inbounds i32, i32* %4310, i64 1
  %996 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:997:                                    ; preds = %4306
  %998 = lshr i32 %4307, 16
  %999 = and i32 %998, 255
  %1000 = zext i32 %999 to i64
  %1001 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1000, i32 0
  %1002 = lshr i32 %4307, 24
  %1003 = add nsw i32 %1002, -127
  %1004 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1000, i32 0, i32 1
  %1005 = load i8, i8* %1004, align 8, !tbaa !22
  switch i8 %1005, label %1020 [
    i8 35, label %1006
    i8 19, label %1013
  ]

; <label>:1006:                                   ; preds = %997
  %1007 = bitcast %struct.TValue* %1001 to i64*
  %1008 = load i64, i64* %1007, align 8, !tbaa !21
  %1009 = sext i32 %1003 to i64
  %1010 = add i64 %1008, %1009
  %1011 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1010, i64* %1011, align 8, !tbaa !21
  %1012 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1012, align 8, !tbaa !22
  br label %1026

; <label>:1013:                                   ; preds = %997
  %1014 = bitcast %struct.TValue* %1001 to double*
  %1015 = load double, double* %1014, align 8, !tbaa !21
  %1016 = sitofp i32 %1003 to double
  %1017 = fadd double %1015, %1016
  %1018 = bitcast %union.StackValue* %4314 to double*
  store double %1017, double* %1018, align 8, !tbaa !21
  %1019 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1019, align 8, !tbaa !22
  br label %1026

; <label>:1020:                                   ; preds = %997
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1021 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1021, i64* %35, align 8, !tbaa !20
  %1022 = sext i32 %1003 to i64
  %1023 = lshr i32 %4307, 15
  %1024 = and i32 %1023, 1
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %47) #7
  store i64 %1022, i64* %48, align 8, !tbaa !21
  store i8 35, i8* %49, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1001, %struct.TValue* nonnull %19, %union.StackValue* %4314, i32 %1024, i32 6) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %47) #7
  %1025 = load i32, i32* %38, align 8, !tbaa !21
  br label %1026

; <label>:1026:                                   ; preds = %1013, %1020, %1006
  %1027 = phi i32 [ %4309, %1006 ], [ %4309, %1013 ], [ %1025, %1020 ]
  %1028 = icmp eq i32 %1027, 0
  br i1 %1028, label %1033, label %1029

; <label>:1029:                                   ; preds = %1026
  %1030 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1031 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1032 = getelementptr inbounds %union.StackValue, %union.StackValue* %1031, i64 1
  br label %1033

; <label>:1033:                                   ; preds = %1026, %1029
  %1034 = phi i32 [ %1030, %1029 ], [ 0, %1026 ]
  %1035 = phi %union.StackValue* [ %1032, %1029 ], [ %4308, %1026 ]
  %1036 = getelementptr inbounds i32, i32* %4310, i64 1
  %1037 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1038:                                   ; preds = %4306
  %1039 = lshr i32 %4307, 16
  %1040 = and i32 %1039, 255
  %1041 = zext i32 %1040 to i64
  %1042 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1041, i32 0
  %1043 = lshr i32 %4307, 24
  %1044 = add nsw i32 %1043, -127
  %1045 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1041, i32 0, i32 1
  %1046 = load i8, i8* %1045, align 8, !tbaa !22
  switch i8 %1046, label %1061 [
    i8 35, label %1047
    i8 19, label %1054
  ]

; <label>:1047:                                   ; preds = %1038
  %1048 = bitcast %struct.TValue* %1042 to i64*
  %1049 = load i64, i64* %1048, align 8, !tbaa !21
  %1050 = sext i32 %1044 to i64
  %1051 = sub i64 %1049, %1050
  %1052 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1051, i64* %1052, align 8, !tbaa !21
  %1053 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1053, align 8, !tbaa !22
  br label %1065

; <label>:1054:                                   ; preds = %1038
  %1055 = bitcast %struct.TValue* %1042 to double*
  %1056 = load double, double* %1055, align 8, !tbaa !21
  %1057 = sitofp i32 %1044 to double
  %1058 = fsub double %1056, %1057
  %1059 = bitcast %union.StackValue* %4314 to double*
  store double %1058, double* %1059, align 8, !tbaa !21
  %1060 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1060, align 8, !tbaa !22
  br label %1065

; <label>:1061:                                   ; preds = %1038
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1062 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1062, i64* %35, align 8, !tbaa !20
  %1063 = sext i32 %1044 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %50) #7
  store i64 %1063, i64* %51, align 8, !tbaa !21
  store i8 35, i8* %52, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1042, %struct.TValue* nonnull %18, %union.StackValue* %4314, i32 7) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %50) #7
  %1064 = load i32, i32* %38, align 8, !tbaa !21
  br label %1065

; <label>:1065:                                   ; preds = %1054, %1061, %1047
  %1066 = phi i32 [ %4309, %1047 ], [ %4309, %1054 ], [ %1064, %1061 ]
  %1067 = icmp eq i32 %1066, 0
  br i1 %1067, label %1072, label %1068

; <label>:1068:                                   ; preds = %1065
  %1069 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1070 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1071 = getelementptr inbounds %union.StackValue, %union.StackValue* %1070, i64 1
  br label %1072

; <label>:1072:                                   ; preds = %1065, %1068
  %1073 = phi i32 [ %1069, %1068 ], [ 0, %1065 ]
  %1074 = phi %union.StackValue* [ %1071, %1068 ], [ %4308, %1065 ]
  %1075 = getelementptr inbounds i32, i32* %4310, i64 1
  %1076 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1077:                                   ; preds = %4306
  %1078 = lshr i32 %4307, 16
  %1079 = and i32 %1078, 255
  %1080 = zext i32 %1079 to i64
  %1081 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1080, i32 0
  %1082 = lshr i32 %4307, 24
  %1083 = add nsw i32 %1082, -127
  %1084 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1080, i32 0, i32 1
  %1085 = load i8, i8* %1084, align 8, !tbaa !22
  switch i8 %1085, label %1100 [
    i8 35, label %1086
    i8 19, label %1093
  ]

; <label>:1086:                                   ; preds = %1077
  %1087 = bitcast %struct.TValue* %1081 to i64*
  %1088 = load i64, i64* %1087, align 8, !tbaa !21
  %1089 = sext i32 %1083 to i64
  %1090 = mul i64 %1088, %1089
  %1091 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1090, i64* %1091, align 8, !tbaa !21
  %1092 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1092, align 8, !tbaa !22
  br label %1106

; <label>:1093:                                   ; preds = %1077
  %1094 = bitcast %struct.TValue* %1081 to double*
  %1095 = load double, double* %1094, align 8, !tbaa !21
  %1096 = sitofp i32 %1083 to double
  %1097 = fmul double %1095, %1096
  %1098 = bitcast %union.StackValue* %4314 to double*
  store double %1097, double* %1098, align 8, !tbaa !21
  %1099 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1099, align 8, !tbaa !22
  br label %1106

; <label>:1100:                                   ; preds = %1077
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1101 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1101, i64* %35, align 8, !tbaa !20
  %1102 = sext i32 %1083 to i64
  %1103 = lshr i32 %4307, 15
  %1104 = and i32 %1103, 1
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %53) #7
  store i64 %1102, i64* %54, align 8, !tbaa !21
  store i8 35, i8* %55, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1081, %struct.TValue* nonnull %17, %union.StackValue* %4314, i32 %1104, i32 8) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %53) #7
  %1105 = load i32, i32* %38, align 8, !tbaa !21
  br label %1106

; <label>:1106:                                   ; preds = %1093, %1100, %1086
  %1107 = phi i32 [ %4309, %1086 ], [ %4309, %1093 ], [ %1105, %1100 ]
  %1108 = icmp eq i32 %1107, 0
  br i1 %1108, label %1113, label %1109

; <label>:1109:                                   ; preds = %1106
  %1110 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1111 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1112 = getelementptr inbounds %union.StackValue, %union.StackValue* %1111, i64 1
  br label %1113

; <label>:1113:                                   ; preds = %1106, %1109
  %1114 = phi i32 [ %1110, %1109 ], [ 0, %1106 ]
  %1115 = phi %union.StackValue* [ %1112, %1109 ], [ %4308, %1106 ]
  %1116 = getelementptr inbounds i32, i32* %4310, i64 1
  %1117 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1118:                                   ; preds = %4306
  %1119 = lshr i32 %4307, 16
  %1120 = and i32 %1119, 255
  %1121 = zext i32 %1120 to i64
  %1122 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1121, i32 0
  %1123 = lshr i32 %4307, 24
  %1124 = add nsw i32 %1123, -127
  %1125 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1121, i32 0, i32 1
  %1126 = load i8, i8* %1125, align 8, !tbaa !22
  switch i8 %1126, label %1152 [
    i8 35, label %1127
    i8 19, label %1134
  ]

; <label>:1127:                                   ; preds = %1118
  %1128 = bitcast %struct.TValue* %1122 to i64*
  %1129 = load i64, i64* %1128, align 8, !tbaa !21
  %1130 = sext i32 %1124 to i64
  %1131 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1129, i64 %1130) #16
  %1132 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1131, i64* %1132, align 8, !tbaa !21
  %1133 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1133, align 8, !tbaa !22
  br label %1156

; <label>:1134:                                   ; preds = %1118
  %1135 = bitcast %struct.TValue* %1122 to double*
  %1136 = load double, double* %1135, align 8, !tbaa !21
  %1137 = sitofp i32 %1124 to double
  %1138 = call double @fmod(double %1136, double %1137) #17
  %1139 = fcmp ogt double %1138, 0.000000e+00
  br i1 %1139, label %1140, label %1142

; <label>:1140:                                   ; preds = %1134
  %1141 = icmp ult i32 %4307, 2130706432
  br i1 %1141, label %1146, label %1148

; <label>:1142:                                   ; preds = %1134
  %1143 = fcmp olt double %1138, 0.000000e+00
  %1144 = icmp slt i32 %4307, 0
  %1145 = and i1 %1144, %1143
  br i1 %1145, label %1146, label %1148

; <label>:1146:                                   ; preds = %1142, %1140
  %1147 = fadd double %1138, %1137
  br label %1148

; <label>:1148:                                   ; preds = %1140, %1142, %1146
  %1149 = phi double [ %1147, %1146 ], [ %1138, %1140 ], [ %1138, %1142 ]
  %1150 = bitcast %union.StackValue* %4314 to double*
  store double %1149, double* %1150, align 8, !tbaa !21
  %1151 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1151, align 8, !tbaa !22
  br label %1156

; <label>:1152:                                   ; preds = %1118
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1153 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1153, i64* %35, align 8, !tbaa !20
  %1154 = sext i32 %1124 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %56) #7
  store i64 %1154, i64* %57, align 8, !tbaa !21
  store i8 35, i8* %58, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1122, %struct.TValue* nonnull %16, %union.StackValue* %4314, i32 9) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %56) #7
  %1155 = load i32, i32* %38, align 8, !tbaa !21
  br label %1156

; <label>:1156:                                   ; preds = %1148, %1152, %1127
  %1157 = phi i32 [ %4309, %1127 ], [ %4309, %1148 ], [ %1155, %1152 ]
  %1158 = icmp eq i32 %1157, 0
  br i1 %1158, label %1163, label %1159

; <label>:1159:                                   ; preds = %1156
  %1160 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1161 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1162 = getelementptr inbounds %union.StackValue, %union.StackValue* %1161, i64 1
  br label %1163

; <label>:1163:                                   ; preds = %1156, %1159
  %1164 = phi i32 [ %1160, %1159 ], [ 0, %1156 ]
  %1165 = phi %union.StackValue* [ %1162, %1159 ], [ %4308, %1156 ]
  %1166 = getelementptr inbounds i32, i32* %4310, i64 1
  %1167 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1168:                                   ; preds = %4306
  %1169 = lshr i32 %4307, 16
  %1170 = and i32 %1169, 255
  %1171 = zext i32 %1170 to i64
  %1172 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1171, i32 0
  %1173 = lshr i32 %4307, 24
  %1174 = add nsw i32 %1173, -127
  %1175 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1171, i32 0, i32 1
  %1176 = load i8, i8* %1175, align 8, !tbaa !22
  switch i8 %1176, label %1190 [
    i8 19, label %1177
    i8 35, label %1180
  ]

; <label>:1177:                                   ; preds = %1168
  %1178 = bitcast %struct.TValue* %1172 to double*
  %1179 = load double, double* %1178, align 8, !tbaa !21
  br label %1184

; <label>:1180:                                   ; preds = %1168
  %1181 = bitcast %struct.TValue* %1172 to i64*
  %1182 = load i64, i64* %1181, align 8, !tbaa !21
  %1183 = sitofp i64 %1182 to double
  br label %1184

; <label>:1184:                                   ; preds = %1177, %1180
  %1185 = phi double [ %1179, %1177 ], [ %1183, %1180 ]
  %1186 = sitofp i32 %1174 to double
  %1187 = call double @pow(double %1185, double %1186) #17
  %1188 = bitcast %union.StackValue* %4314 to double*
  store double %1187, double* %1188, align 8, !tbaa !21
  %1189 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1189, align 8, !tbaa !22
  br label %1194

; <label>:1190:                                   ; preds = %1168
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1191 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1191, i64* %35, align 8, !tbaa !20
  %1192 = sext i32 %1174 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %59) #7
  store i64 %1192, i64* %60, align 8, !tbaa !21
  store i8 35, i8* %61, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1172, %struct.TValue* nonnull %15, %union.StackValue* %4314, i32 10) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %59) #7
  %1193 = load i32, i32* %38, align 8, !tbaa !21
  br label %1194

; <label>:1194:                                   ; preds = %1190, %1184
  %1195 = phi i32 [ %4309, %1184 ], [ %1193, %1190 ]
  %1196 = icmp eq i32 %1195, 0
  br i1 %1196, label %1201, label %1197

; <label>:1197:                                   ; preds = %1194
  %1198 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1199 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1200 = getelementptr inbounds %union.StackValue, %union.StackValue* %1199, i64 1
  br label %1201

; <label>:1201:                                   ; preds = %1194, %1197
  %1202 = phi i32 [ %1198, %1197 ], [ 0, %1194 ]
  %1203 = phi %union.StackValue* [ %1200, %1197 ], [ %4308, %1194 ]
  %1204 = getelementptr inbounds i32, i32* %4310, i64 1
  %1205 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1206:                                   ; preds = %4306
  %1207 = lshr i32 %4307, 16
  %1208 = and i32 %1207, 255
  %1209 = zext i32 %1208 to i64
  %1210 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1209, i32 0
  %1211 = lshr i32 %4307, 24
  %1212 = add nsw i32 %1211, -127
  %1213 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1209, i32 0, i32 1
  %1214 = load i8, i8* %1213, align 8, !tbaa !22
  switch i8 %1214, label %1228 [
    i8 19, label %1215
    i8 35, label %1218
  ]

; <label>:1215:                                   ; preds = %1206
  %1216 = bitcast %struct.TValue* %1210 to double*
  %1217 = load double, double* %1216, align 8, !tbaa !21
  br label %1222

; <label>:1218:                                   ; preds = %1206
  %1219 = bitcast %struct.TValue* %1210 to i64*
  %1220 = load i64, i64* %1219, align 8, !tbaa !21
  %1221 = sitofp i64 %1220 to double
  br label %1222

; <label>:1222:                                   ; preds = %1215, %1218
  %1223 = phi double [ %1217, %1215 ], [ %1221, %1218 ]
  %1224 = sitofp i32 %1212 to double
  %1225 = fdiv double %1223, %1224
  %1226 = bitcast %union.StackValue* %4314 to double*
  store double %1225, double* %1226, align 8, !tbaa !21
  %1227 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1227, align 8, !tbaa !22
  br label %1232

; <label>:1228:                                   ; preds = %1206
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1229 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1229, i64* %35, align 8, !tbaa !20
  %1230 = sext i32 %1212 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %62) #7
  store i64 %1230, i64* %63, align 8, !tbaa !21
  store i8 35, i8* %64, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1210, %struct.TValue* nonnull %14, %union.StackValue* %4314, i32 11) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %62) #7
  %1231 = load i32, i32* %38, align 8, !tbaa !21
  br label %1232

; <label>:1232:                                   ; preds = %1228, %1222
  %1233 = phi i32 [ %4309, %1222 ], [ %1231, %1228 ]
  %1234 = icmp eq i32 %1233, 0
  br i1 %1234, label %1239, label %1235

; <label>:1235:                                   ; preds = %1232
  %1236 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1237 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1238 = getelementptr inbounds %union.StackValue, %union.StackValue* %1237, i64 1
  br label %1239

; <label>:1239:                                   ; preds = %1232, %1235
  %1240 = phi i32 [ %1236, %1235 ], [ 0, %1232 ]
  %1241 = phi %union.StackValue* [ %1238, %1235 ], [ %4308, %1232 ]
  %1242 = getelementptr inbounds i32, i32* %4310, i64 1
  %1243 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1244:                                   ; preds = %4306
  %1245 = lshr i32 %4307, 16
  %1246 = and i32 %1245, 255
  %1247 = zext i32 %1246 to i64
  %1248 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1247, i32 0
  %1249 = lshr i32 %4307, 24
  %1250 = add nsw i32 %1249, -127
  %1251 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1247, i32 0, i32 1
  %1252 = load i8, i8* %1251, align 8, !tbaa !22
  switch i8 %1252, label %1268 [
    i8 35, label %1253
    i8 19, label %1260
  ]

; <label>:1253:                                   ; preds = %1244
  %1254 = bitcast %struct.TValue* %1248 to i64*
  %1255 = load i64, i64* %1254, align 8, !tbaa !21
  %1256 = sext i32 %1250 to i64
  %1257 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1255, i64 %1256) #16
  %1258 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1257, i64* %1258, align 8, !tbaa !21
  %1259 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1259, align 8, !tbaa !22
  br label %1272

; <label>:1260:                                   ; preds = %1244
  %1261 = bitcast %struct.TValue* %1248 to double*
  %1262 = load double, double* %1261, align 8, !tbaa !21
  %1263 = sitofp i32 %1250 to double
  %1264 = fdiv double %1262, %1263
  %1265 = call double @llvm.floor.f64(double %1264)
  %1266 = bitcast %union.StackValue* %4314 to double*
  store double %1265, double* %1266, align 8, !tbaa !21
  %1267 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1267, align 8, !tbaa !22
  br label %1272

; <label>:1268:                                   ; preds = %1244
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1269 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1269, i64* %35, align 8, !tbaa !20
  %1270 = sext i32 %1250 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %65) #7
  store i64 %1270, i64* %66, align 8, !tbaa !21
  store i8 35, i8* %67, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1248, %struct.TValue* nonnull %13, %union.StackValue* %4314, i32 12) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %65) #7
  %1271 = load i32, i32* %38, align 8, !tbaa !21
  br label %1272

; <label>:1272:                                   ; preds = %1260, %1268, %1253
  %1273 = phi i32 [ %4309, %1253 ], [ %4309, %1260 ], [ %1271, %1268 ]
  %1274 = icmp eq i32 %1273, 0
  br i1 %1274, label %1279, label %1275

; <label>:1275:                                   ; preds = %1272
  %1276 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1277 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1278 = getelementptr inbounds %union.StackValue, %union.StackValue* %1277, i64 1
  br label %1279

; <label>:1279:                                   ; preds = %1272, %1275
  %1280 = phi i32 [ %1276, %1275 ], [ 0, %1272 ]
  %1281 = phi %union.StackValue* [ %1278, %1275 ], [ %4308, %1272 ]
  %1282 = getelementptr inbounds i32, i32* %4310, i64 1
  %1283 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1284:                                   ; preds = %4306
  %1285 = lshr i32 %4307, 16
  %1286 = and i32 %1285, 255
  %1287 = zext i32 %1286 to i64
  %1288 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1287, i32 0
  %1289 = lshr i32 %4307, 24
  %1290 = zext i32 %1289 to i64
  %1291 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1290
  %1292 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1287, i32 0, i32 1
  %1293 = load i8, i8* %1292, align 8, !tbaa !22
  switch i8 %1293, label %1328 [
    i8 35, label %1294
    i8 19, label %1306
  ]

; <label>:1294:                                   ; preds = %1284
  %1295 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1290, i32 1
  %1296 = load i8, i8* %1295, align 8, !tbaa !22
  %1297 = icmp eq i8 %1296, 35
  %1298 = bitcast %struct.TValue* %1288 to i64*
  %1299 = load i64, i64* %1298, align 8, !tbaa !21
  br i1 %1297, label %1300, label %1311

; <label>:1300:                                   ; preds = %1294
  %1301 = bitcast %struct.TValue* %1291 to i64*
  %1302 = load i64, i64* %1301, align 8, !tbaa !21
  %1303 = add i64 %1302, %1299
  %1304 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1303, i64* %1304, align 8, !tbaa !21
  %1305 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1305, align 8, !tbaa !22
  br label %1333

; <label>:1306:                                   ; preds = %1284
  %1307 = bitcast %struct.TValue* %1288 to double*
  %1308 = load double, double* %1307, align 8, !tbaa !21
  %1309 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1290, i32 1
  %1310 = load i8, i8* %1309, align 8, !tbaa !22
  br label %1313

; <label>:1311:                                   ; preds = %1294
  %1312 = sitofp i64 %1299 to double
  br label %1313

; <label>:1313:                                   ; preds = %1306, %1311
  %1314 = phi i8 [ %1310, %1306 ], [ %1296, %1311 ]
  %1315 = phi double [ %1308, %1306 ], [ %1312, %1311 ]
  switch i8 %1314, label %1328 [
    i8 19, label %1316
    i8 35, label %1319
  ]

; <label>:1316:                                   ; preds = %1313
  %1317 = bitcast %struct.TValue* %1291 to double*
  %1318 = load double, double* %1317, align 8, !tbaa !21
  br label %1323

; <label>:1319:                                   ; preds = %1313
  %1320 = bitcast %struct.TValue* %1291 to i64*
  %1321 = load i64, i64* %1320, align 8, !tbaa !21
  %1322 = sitofp i64 %1321 to double
  br label %1323

; <label>:1323:                                   ; preds = %1316, %1319
  %1324 = phi double [ %1318, %1316 ], [ %1322, %1319 ]
  %1325 = fadd double %1315, %1324
  %1326 = bitcast %union.StackValue* %4314 to double*
  store double %1325, double* %1326, align 8, !tbaa !21
  %1327 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1327, align 8, !tbaa !22
  br label %1333

; <label>:1328:                                   ; preds = %1284, %1313
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1329 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1329, i64* %35, align 8, !tbaa !20
  %1330 = lshr i32 %4307, 15
  %1331 = and i32 %1330, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1288, %struct.TValue* %1291, %union.StackValue* %4314, i32 %1331, i32 6) #16
  %1332 = load i32, i32* %38, align 8, !tbaa !21
  br label %1333

; <label>:1333:                                   ; preds = %1323, %1328, %1300
  %1334 = phi i32 [ %4309, %1300 ], [ %4309, %1323 ], [ %1332, %1328 ]
  %1335 = icmp eq i32 %1334, 0
  br i1 %1335, label %1340, label %1336

; <label>:1336:                                   ; preds = %1333
  %1337 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1338 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1339 = getelementptr inbounds %union.StackValue, %union.StackValue* %1338, i64 1
  br label %1340

; <label>:1340:                                   ; preds = %1333, %1336
  %1341 = phi i32 [ %1337, %1336 ], [ 0, %1333 ]
  %1342 = phi %union.StackValue* [ %1339, %1336 ], [ %4308, %1333 ]
  %1343 = getelementptr inbounds i32, i32* %4310, i64 1
  %1344 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1345:                                   ; preds = %4306
  %1346 = lshr i32 %4307, 16
  %1347 = and i32 %1346, 255
  %1348 = zext i32 %1347 to i64
  %1349 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1348, i32 0
  %1350 = lshr i32 %4307, 24
  %1351 = zext i32 %1350 to i64
  %1352 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1351
  %1353 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1348, i32 0, i32 1
  %1354 = load i8, i8* %1353, align 8, !tbaa !22
  switch i8 %1354, label %1389 [
    i8 35, label %1355
    i8 19, label %1367
  ]

; <label>:1355:                                   ; preds = %1345
  %1356 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1351, i32 1
  %1357 = load i8, i8* %1356, align 8, !tbaa !22
  %1358 = icmp eq i8 %1357, 35
  %1359 = bitcast %struct.TValue* %1349 to i64*
  %1360 = load i64, i64* %1359, align 8, !tbaa !21
  br i1 %1358, label %1361, label %1372

; <label>:1361:                                   ; preds = %1355
  %1362 = bitcast %struct.TValue* %1352 to i64*
  %1363 = load i64, i64* %1362, align 8, !tbaa !21
  %1364 = sub i64 %1360, %1363
  %1365 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1364, i64* %1365, align 8, !tbaa !21
  %1366 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1366, align 8, !tbaa !22
  br label %1392

; <label>:1367:                                   ; preds = %1345
  %1368 = bitcast %struct.TValue* %1349 to double*
  %1369 = load double, double* %1368, align 8, !tbaa !21
  %1370 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1351, i32 1
  %1371 = load i8, i8* %1370, align 8, !tbaa !22
  br label %1374

; <label>:1372:                                   ; preds = %1355
  %1373 = sitofp i64 %1360 to double
  br label %1374

; <label>:1374:                                   ; preds = %1367, %1372
  %1375 = phi i8 [ %1371, %1367 ], [ %1357, %1372 ]
  %1376 = phi double [ %1369, %1367 ], [ %1373, %1372 ]
  switch i8 %1375, label %1389 [
    i8 19, label %1377
    i8 35, label %1380
  ]

; <label>:1377:                                   ; preds = %1374
  %1378 = bitcast %struct.TValue* %1352 to double*
  %1379 = load double, double* %1378, align 8, !tbaa !21
  br label %1384

; <label>:1380:                                   ; preds = %1374
  %1381 = bitcast %struct.TValue* %1352 to i64*
  %1382 = load i64, i64* %1381, align 8, !tbaa !21
  %1383 = sitofp i64 %1382 to double
  br label %1384

; <label>:1384:                                   ; preds = %1377, %1380
  %1385 = phi double [ %1379, %1377 ], [ %1383, %1380 ]
  %1386 = fsub double %1376, %1385
  %1387 = bitcast %union.StackValue* %4314 to double*
  store double %1386, double* %1387, align 8, !tbaa !21
  %1388 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1388, align 8, !tbaa !22
  br label %1392

; <label>:1389:                                   ; preds = %1345, %1374
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1390 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1390, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1349, %struct.TValue* %1352, %union.StackValue* %4314, i32 7) #17
  %1391 = load i32, i32* %38, align 8, !tbaa !21
  br label %1392

; <label>:1392:                                   ; preds = %1384, %1389, %1361
  %1393 = phi i32 [ %4309, %1361 ], [ %4309, %1384 ], [ %1391, %1389 ]
  %1394 = icmp eq i32 %1393, 0
  br i1 %1394, label %1399, label %1395

; <label>:1395:                                   ; preds = %1392
  %1396 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1397 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1398 = getelementptr inbounds %union.StackValue, %union.StackValue* %1397, i64 1
  br label %1399

; <label>:1399:                                   ; preds = %1392, %1395
  %1400 = phi i32 [ %1396, %1395 ], [ 0, %1392 ]
  %1401 = phi %union.StackValue* [ %1398, %1395 ], [ %4308, %1392 ]
  %1402 = getelementptr inbounds i32, i32* %4310, i64 1
  %1403 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1404:                                   ; preds = %4306
  %1405 = lshr i32 %4307, 16
  %1406 = and i32 %1405, 255
  %1407 = zext i32 %1406 to i64
  %1408 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1407, i32 0
  %1409 = lshr i32 %4307, 24
  %1410 = zext i32 %1409 to i64
  %1411 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1410
  %1412 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1407, i32 0, i32 1
  %1413 = load i8, i8* %1412, align 8, !tbaa !22
  switch i8 %1413, label %1448 [
    i8 35, label %1414
    i8 19, label %1426
  ]

; <label>:1414:                                   ; preds = %1404
  %1415 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1410, i32 1
  %1416 = load i8, i8* %1415, align 8, !tbaa !22
  %1417 = icmp eq i8 %1416, 35
  %1418 = bitcast %struct.TValue* %1408 to i64*
  %1419 = load i64, i64* %1418, align 8, !tbaa !21
  br i1 %1417, label %1420, label %1431

; <label>:1420:                                   ; preds = %1414
  %1421 = bitcast %struct.TValue* %1411 to i64*
  %1422 = load i64, i64* %1421, align 8, !tbaa !21
  %1423 = mul i64 %1422, %1419
  %1424 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1423, i64* %1424, align 8, !tbaa !21
  %1425 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1425, align 8, !tbaa !22
  br label %1453

; <label>:1426:                                   ; preds = %1404
  %1427 = bitcast %struct.TValue* %1408 to double*
  %1428 = load double, double* %1427, align 8, !tbaa !21
  %1429 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1410, i32 1
  %1430 = load i8, i8* %1429, align 8, !tbaa !22
  br label %1433

; <label>:1431:                                   ; preds = %1414
  %1432 = sitofp i64 %1419 to double
  br label %1433

; <label>:1433:                                   ; preds = %1426, %1431
  %1434 = phi i8 [ %1430, %1426 ], [ %1416, %1431 ]
  %1435 = phi double [ %1428, %1426 ], [ %1432, %1431 ]
  switch i8 %1434, label %1448 [
    i8 19, label %1436
    i8 35, label %1439
  ]

; <label>:1436:                                   ; preds = %1433
  %1437 = bitcast %struct.TValue* %1411 to double*
  %1438 = load double, double* %1437, align 8, !tbaa !21
  br label %1443

; <label>:1439:                                   ; preds = %1433
  %1440 = bitcast %struct.TValue* %1411 to i64*
  %1441 = load i64, i64* %1440, align 8, !tbaa !21
  %1442 = sitofp i64 %1441 to double
  br label %1443

; <label>:1443:                                   ; preds = %1436, %1439
  %1444 = phi double [ %1438, %1436 ], [ %1442, %1439 ]
  %1445 = fmul double %1435, %1444
  %1446 = bitcast %union.StackValue* %4314 to double*
  store double %1445, double* %1446, align 8, !tbaa !21
  %1447 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1447, align 8, !tbaa !22
  br label %1453

; <label>:1448:                                   ; preds = %1404, %1433
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1449 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1449, i64* %35, align 8, !tbaa !20
  %1450 = lshr i32 %4307, 15
  %1451 = and i32 %1450, 1
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* %1408, %struct.TValue* %1411, %union.StackValue* %4314, i32 %1451, i32 8) #16
  %1452 = load i32, i32* %38, align 8, !tbaa !21
  br label %1453

; <label>:1453:                                   ; preds = %1443, %1448, %1420
  %1454 = phi i32 [ %4309, %1420 ], [ %4309, %1443 ], [ %1452, %1448 ]
  %1455 = icmp eq i32 %1454, 0
  br i1 %1455, label %1460, label %1456

; <label>:1456:                                   ; preds = %1453
  %1457 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1458 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1459 = getelementptr inbounds %union.StackValue, %union.StackValue* %1458, i64 1
  br label %1460

; <label>:1460:                                   ; preds = %1453, %1456
  %1461 = phi i32 [ %1457, %1456 ], [ 0, %1453 ]
  %1462 = phi %union.StackValue* [ %1459, %1456 ], [ %4308, %1453 ]
  %1463 = getelementptr inbounds i32, i32* %4310, i64 1
  %1464 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1465:                                   ; preds = %4306
  %1466 = lshr i32 %4307, 16
  %1467 = and i32 %1466, 255
  %1468 = zext i32 %1467 to i64
  %1469 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1468, i32 0
  %1470 = lshr i32 %4307, 24
  %1471 = zext i32 %1470 to i64
  %1472 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1471
  %1473 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1468, i32 0, i32 1
  %1474 = load i8, i8* %1473, align 8, !tbaa !22
  switch i8 %1474, label %1520 [
    i8 35, label %1475
    i8 19, label %1487
  ]

; <label>:1475:                                   ; preds = %1465
  %1476 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1471, i32 1
  %1477 = load i8, i8* %1476, align 8, !tbaa !22
  %1478 = icmp eq i8 %1477, 35
  %1479 = bitcast %struct.TValue* %1469 to i64*
  %1480 = load i64, i64* %1479, align 8, !tbaa !21
  br i1 %1478, label %1481, label %1492

; <label>:1481:                                   ; preds = %1475
  %1482 = bitcast %struct.TValue* %1472 to i64*
  %1483 = load i64, i64* %1482, align 8, !tbaa !21
  %1484 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1480, i64 %1483) #16
  %1485 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1484, i64* %1485, align 8, !tbaa !21
  %1486 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1486, align 8, !tbaa !22
  br label %1523

; <label>:1487:                                   ; preds = %1465
  %1488 = bitcast %struct.TValue* %1469 to double*
  %1489 = load double, double* %1488, align 8, !tbaa !21
  %1490 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1471, i32 1
  %1491 = load i8, i8* %1490, align 8, !tbaa !22
  br label %1494

; <label>:1492:                                   ; preds = %1475
  %1493 = sitofp i64 %1480 to double
  br label %1494

; <label>:1494:                                   ; preds = %1487, %1492
  %1495 = phi i8 [ %1491, %1487 ], [ %1477, %1492 ]
  %1496 = phi double [ %1489, %1487 ], [ %1493, %1492 ]
  switch i8 %1495, label %1520 [
    i8 19, label %1497
    i8 35, label %1500
  ]

; <label>:1497:                                   ; preds = %1494
  %1498 = bitcast %struct.TValue* %1472 to double*
  %1499 = load double, double* %1498, align 8, !tbaa !21
  br label %1504

; <label>:1500:                                   ; preds = %1494
  %1501 = bitcast %struct.TValue* %1472 to i64*
  %1502 = load i64, i64* %1501, align 8, !tbaa !21
  %1503 = sitofp i64 %1502 to double
  br label %1504

; <label>:1504:                                   ; preds = %1497, %1500
  %1505 = phi double [ %1499, %1497 ], [ %1503, %1500 ]
  %1506 = call double @fmod(double %1496, double %1505) #17
  %1507 = fcmp ogt double %1506, 0.000000e+00
  br i1 %1507, label %1508, label %1510

; <label>:1508:                                   ; preds = %1504
  %1509 = fcmp olt double %1505, 0.000000e+00
  br i1 %1509, label %1514, label %1516

; <label>:1510:                                   ; preds = %1504
  %1511 = fcmp olt double %1506, 0.000000e+00
  %1512 = fcmp ogt double %1505, 0.000000e+00
  %1513 = and i1 %1512, %1511
  br i1 %1513, label %1514, label %1516

; <label>:1514:                                   ; preds = %1510, %1508
  %1515 = fadd double %1505, %1506
  br label %1516

; <label>:1516:                                   ; preds = %1508, %1510, %1514
  %1517 = phi double [ %1515, %1514 ], [ %1506, %1508 ], [ %1506, %1510 ]
  %1518 = bitcast %union.StackValue* %4314 to double*
  store double %1517, double* %1518, align 8, !tbaa !21
  %1519 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1519, align 8, !tbaa !22
  br label %1523

; <label>:1520:                                   ; preds = %1465, %1494
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1521 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1521, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1469, %struct.TValue* %1472, %union.StackValue* %4314, i32 9) #17
  %1522 = load i32, i32* %38, align 8, !tbaa !21
  br label %1523

; <label>:1523:                                   ; preds = %1516, %1520, %1481
  %1524 = phi i32 [ %4309, %1481 ], [ %4309, %1516 ], [ %1522, %1520 ]
  %1525 = icmp eq i32 %1524, 0
  br i1 %1525, label %1530, label %1526

; <label>:1526:                                   ; preds = %1523
  %1527 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1528 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1529 = getelementptr inbounds %union.StackValue, %union.StackValue* %1528, i64 1
  br label %1530

; <label>:1530:                                   ; preds = %1523, %1526
  %1531 = phi i32 [ %1527, %1526 ], [ 0, %1523 ]
  %1532 = phi %union.StackValue* [ %1529, %1526 ], [ %4308, %1523 ]
  %1533 = getelementptr inbounds i32, i32* %4310, i64 1
  %1534 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1535:                                   ; preds = %4306
  %1536 = lshr i32 %4307, 16
  %1537 = and i32 %1536, 255
  %1538 = zext i32 %1537 to i64
  %1539 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1538, i32 0
  %1540 = lshr i32 %4307, 24
  %1541 = zext i32 %1540 to i64
  %1542 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1541
  %1543 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1538, i32 0, i32 1
  %1544 = load i8, i8* %1543, align 8, !tbaa !22
  switch i8 %1544, label %1568 [
    i8 19, label %1545
    i8 35, label %1548
  ]

; <label>:1545:                                   ; preds = %1535
  %1546 = bitcast %struct.TValue* %1539 to double*
  %1547 = load double, double* %1546, align 8, !tbaa !21
  br label %1552

; <label>:1548:                                   ; preds = %1535
  %1549 = bitcast %struct.TValue* %1539 to i64*
  %1550 = load i64, i64* %1549, align 8, !tbaa !21
  %1551 = sitofp i64 %1550 to double
  br label %1552

; <label>:1552:                                   ; preds = %1545, %1548
  %1553 = phi double [ %1547, %1545 ], [ %1551, %1548 ]
  %1554 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1541, i32 1
  %1555 = load i8, i8* %1554, align 8, !tbaa !22
  switch i8 %1555, label %1568 [
    i8 19, label %1556
    i8 35, label %1559
  ]

; <label>:1556:                                   ; preds = %1552
  %1557 = bitcast %struct.TValue* %1542 to double*
  %1558 = load double, double* %1557, align 8, !tbaa !21
  br label %1563

; <label>:1559:                                   ; preds = %1552
  %1560 = bitcast %struct.TValue* %1542 to i64*
  %1561 = load i64, i64* %1560, align 8, !tbaa !21
  %1562 = sitofp i64 %1561 to double
  br label %1563

; <label>:1563:                                   ; preds = %1556, %1559
  %1564 = phi double [ %1558, %1556 ], [ %1562, %1559 ]
  %1565 = call double @pow(double %1553, double %1564) #17
  %1566 = bitcast %union.StackValue* %4314 to double*
  store double %1565, double* %1566, align 8, !tbaa !21
  %1567 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1567, align 8, !tbaa !22
  br label %1571

; <label>:1568:                                   ; preds = %1552, %1535
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1569 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1569, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1539, %struct.TValue* %1542, %union.StackValue* %4314, i32 10) #16
  %1570 = load i32, i32* %38, align 8, !tbaa !21
  br label %1571

; <label>:1571:                                   ; preds = %1568, %1563
  %1572 = phi i32 [ %4309, %1563 ], [ %1570, %1568 ]
  %1573 = icmp eq i32 %1572, 0
  br i1 %1573, label %1578, label %1574

; <label>:1574:                                   ; preds = %1571
  %1575 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1576 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1577 = getelementptr inbounds %union.StackValue, %union.StackValue* %1576, i64 1
  br label %1578

; <label>:1578:                                   ; preds = %1571, %1574
  %1579 = phi i32 [ %1575, %1574 ], [ 0, %1571 ]
  %1580 = phi %union.StackValue* [ %1577, %1574 ], [ %4308, %1571 ]
  %1581 = getelementptr inbounds i32, i32* %4310, i64 1
  %1582 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1583:                                   ; preds = %4306
  %1584 = lshr i32 %4307, 16
  %1585 = and i32 %1584, 255
  %1586 = zext i32 %1585 to i64
  %1587 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1586, i32 0
  %1588 = lshr i32 %4307, 24
  %1589 = zext i32 %1588 to i64
  %1590 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1589
  %1591 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1586, i32 0, i32 1
  %1592 = load i8, i8* %1591, align 8, !tbaa !22
  switch i8 %1592, label %1616 [
    i8 19, label %1593
    i8 35, label %1596
  ]

; <label>:1593:                                   ; preds = %1583
  %1594 = bitcast %struct.TValue* %1587 to double*
  %1595 = load double, double* %1594, align 8, !tbaa !21
  br label %1600

; <label>:1596:                                   ; preds = %1583
  %1597 = bitcast %struct.TValue* %1587 to i64*
  %1598 = load i64, i64* %1597, align 8, !tbaa !21
  %1599 = sitofp i64 %1598 to double
  br label %1600

; <label>:1600:                                   ; preds = %1593, %1596
  %1601 = phi double [ %1595, %1593 ], [ %1599, %1596 ]
  %1602 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1589, i32 1
  %1603 = load i8, i8* %1602, align 8, !tbaa !22
  switch i8 %1603, label %1616 [
    i8 19, label %1604
    i8 35, label %1607
  ]

; <label>:1604:                                   ; preds = %1600
  %1605 = bitcast %struct.TValue* %1590 to double*
  %1606 = load double, double* %1605, align 8, !tbaa !21
  br label %1611

; <label>:1607:                                   ; preds = %1600
  %1608 = bitcast %struct.TValue* %1590 to i64*
  %1609 = load i64, i64* %1608, align 8, !tbaa !21
  %1610 = sitofp i64 %1609 to double
  br label %1611

; <label>:1611:                                   ; preds = %1604, %1607
  %1612 = phi double [ %1606, %1604 ], [ %1610, %1607 ]
  %1613 = fdiv double %1601, %1612
  %1614 = bitcast %union.StackValue* %4314 to double*
  store double %1613, double* %1614, align 8, !tbaa !21
  %1615 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1615, align 8, !tbaa !22
  br label %1619

; <label>:1616:                                   ; preds = %1600, %1583
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1617 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1617, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1587, %struct.TValue* %1590, %union.StackValue* %4314, i32 11) #16
  %1618 = load i32, i32* %38, align 8, !tbaa !21
  br label %1619

; <label>:1619:                                   ; preds = %1616, %1611
  %1620 = phi i32 [ %4309, %1611 ], [ %1618, %1616 ]
  %1621 = icmp eq i32 %1620, 0
  br i1 %1621, label %1626, label %1622

; <label>:1622:                                   ; preds = %1619
  %1623 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1624 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1625 = getelementptr inbounds %union.StackValue, %union.StackValue* %1624, i64 1
  br label %1626

; <label>:1626:                                   ; preds = %1619, %1622
  %1627 = phi i32 [ %1623, %1622 ], [ 0, %1619 ]
  %1628 = phi %union.StackValue* [ %1625, %1622 ], [ %4308, %1619 ]
  %1629 = getelementptr inbounds i32, i32* %4310, i64 1
  %1630 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1631:                                   ; preds = %4306
  %1632 = lshr i32 %4307, 16
  %1633 = and i32 %1632, 255
  %1634 = zext i32 %1633 to i64
  %1635 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1634, i32 0
  %1636 = lshr i32 %4307, 24
  %1637 = zext i32 %1636 to i64
  %1638 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1637
  %1639 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1634, i32 0, i32 1
  %1640 = load i8, i8* %1639, align 8, !tbaa !22
  switch i8 %1640, label %1676 [
    i8 35, label %1641
    i8 19, label %1653
  ]

; <label>:1641:                                   ; preds = %1631
  %1642 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1637, i32 1
  %1643 = load i8, i8* %1642, align 8, !tbaa !22
  %1644 = icmp eq i8 %1643, 35
  %1645 = bitcast %struct.TValue* %1635 to i64*
  %1646 = load i64, i64* %1645, align 8, !tbaa !21
  br i1 %1644, label %1647, label %1658

; <label>:1647:                                   ; preds = %1641
  %1648 = bitcast %struct.TValue* %1638 to i64*
  %1649 = load i64, i64* %1648, align 8, !tbaa !21
  %1650 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %1646, i64 %1649) #16
  %1651 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1650, i64* %1651, align 8, !tbaa !21
  %1652 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1652, align 8, !tbaa !22
  br label %1679

; <label>:1653:                                   ; preds = %1631
  %1654 = bitcast %struct.TValue* %1635 to double*
  %1655 = load double, double* %1654, align 8, !tbaa !21
  %1656 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %1637, i32 1
  %1657 = load i8, i8* %1656, align 8, !tbaa !22
  br label %1660

; <label>:1658:                                   ; preds = %1641
  %1659 = sitofp i64 %1646 to double
  br label %1660

; <label>:1660:                                   ; preds = %1653, %1658
  %1661 = phi i8 [ %1657, %1653 ], [ %1643, %1658 ]
  %1662 = phi double [ %1655, %1653 ], [ %1659, %1658 ]
  switch i8 %1661, label %1676 [
    i8 19, label %1663
    i8 35, label %1666
  ]

; <label>:1663:                                   ; preds = %1660
  %1664 = bitcast %struct.TValue* %1638 to double*
  %1665 = load double, double* %1664, align 8, !tbaa !21
  br label %1670

; <label>:1666:                                   ; preds = %1660
  %1667 = bitcast %struct.TValue* %1638 to i64*
  %1668 = load i64, i64* %1667, align 8, !tbaa !21
  %1669 = sitofp i64 %1668 to double
  br label %1670

; <label>:1670:                                   ; preds = %1663, %1666
  %1671 = phi double [ %1665, %1663 ], [ %1669, %1666 ]
  %1672 = fdiv double %1662, %1671
  %1673 = call double @llvm.floor.f64(double %1672)
  %1674 = bitcast %union.StackValue* %4314 to double*
  store double %1673, double* %1674, align 8, !tbaa !21
  %1675 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1675, align 8, !tbaa !22
  br label %1679

; <label>:1676:                                   ; preds = %1631, %1660
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1677 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1677, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1635, %struct.TValue* %1638, %union.StackValue* %4314, i32 12) #17
  %1678 = load i32, i32* %38, align 8, !tbaa !21
  br label %1679

; <label>:1679:                                   ; preds = %1670, %1676, %1647
  %1680 = phi i32 [ %4309, %1647 ], [ %4309, %1670 ], [ %1678, %1676 ]
  %1681 = icmp eq i32 %1680, 0
  br i1 %1681, label %1686, label %1682

; <label>:1682:                                   ; preds = %1679
  %1683 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1684 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1685 = getelementptr inbounds %union.StackValue, %union.StackValue* %1684, i64 1
  br label %1686

; <label>:1686:                                   ; preds = %1679, %1682
  %1687 = phi i32 [ %1683, %1682 ], [ 0, %1679 ]
  %1688 = phi %union.StackValue* [ %1685, %1682 ], [ %4308, %1679 ]
  %1689 = getelementptr inbounds i32, i32* %4310, i64 1
  %1690 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1691:                                   ; preds = %4306
  %1692 = lshr i32 %4307, 16
  %1693 = and i32 %1692, 255
  %1694 = zext i32 %1693 to i64
  %1695 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1694, i32 0
  %1696 = lshr i32 %4307, 24
  %1697 = zext i32 %1696 to i64
  %1698 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1697, i32 0
  %1699 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1694, i32 0, i32 1
  %1700 = load i8, i8* %1699, align 8, !tbaa !22
  switch i8 %1700, label %1735 [
    i8 35, label %1701
    i8 19, label %1713
  ]

; <label>:1701:                                   ; preds = %1691
  %1702 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1697, i32 0, i32 1
  %1703 = load i8, i8* %1702, align 8, !tbaa !22
  %1704 = icmp eq i8 %1703, 35
  %1705 = bitcast %struct.TValue* %1695 to i64*
  %1706 = load i64, i64* %1705, align 8, !tbaa !21
  br i1 %1704, label %1707, label %1718

; <label>:1707:                                   ; preds = %1701
  %1708 = bitcast %struct.TValue* %1698 to i64*
  %1709 = load i64, i64* %1708, align 8, !tbaa !21
  %1710 = add i64 %1709, %1706
  %1711 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1710, i64* %1711, align 8, !tbaa !21
  %1712 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1712, align 8, !tbaa !22
  br label %1738

; <label>:1713:                                   ; preds = %1691
  %1714 = bitcast %struct.TValue* %1695 to double*
  %1715 = load double, double* %1714, align 8, !tbaa !21
  %1716 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1697, i32 0, i32 1
  %1717 = load i8, i8* %1716, align 8, !tbaa !22
  br label %1720

; <label>:1718:                                   ; preds = %1701
  %1719 = sitofp i64 %1706 to double
  br label %1720

; <label>:1720:                                   ; preds = %1713, %1718
  %1721 = phi i8 [ %1717, %1713 ], [ %1703, %1718 ]
  %1722 = phi double [ %1715, %1713 ], [ %1719, %1718 ]
  switch i8 %1721, label %1735 [
    i8 19, label %1723
    i8 35, label %1726
  ]

; <label>:1723:                                   ; preds = %1720
  %1724 = bitcast %struct.TValue* %1698 to double*
  %1725 = load double, double* %1724, align 8, !tbaa !21
  br label %1730

; <label>:1726:                                   ; preds = %1720
  %1727 = bitcast %struct.TValue* %1698 to i64*
  %1728 = load i64, i64* %1727, align 8, !tbaa !21
  %1729 = sitofp i64 %1728 to double
  br label %1730

; <label>:1730:                                   ; preds = %1723, %1726
  %1731 = phi double [ %1725, %1723 ], [ %1729, %1726 ]
  %1732 = fadd double %1722, %1731
  %1733 = bitcast %union.StackValue* %4314 to double*
  store double %1732, double* %1733, align 8, !tbaa !21
  %1734 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1734, align 8, !tbaa !22
  br label %1738

; <label>:1735:                                   ; preds = %1691, %1720
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1736 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1736, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1695, %struct.TValue* %1698, %union.StackValue* %4314, i32 6) #16
  %1737 = load i32, i32* %38, align 8, !tbaa !21
  br label %1738

; <label>:1738:                                   ; preds = %1730, %1735, %1707
  %1739 = phi i32 [ %4309, %1707 ], [ %4309, %1730 ], [ %1737, %1735 ]
  %1740 = icmp eq i32 %1739, 0
  br i1 %1740, label %1745, label %1741

; <label>:1741:                                   ; preds = %1738
  %1742 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1743 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1744 = getelementptr inbounds %union.StackValue, %union.StackValue* %1743, i64 1
  br label %1745

; <label>:1745:                                   ; preds = %1738, %1741
  %1746 = phi i32 [ %1742, %1741 ], [ 0, %1738 ]
  %1747 = phi %union.StackValue* [ %1744, %1741 ], [ %4308, %1738 ]
  %1748 = getelementptr inbounds i32, i32* %4310, i64 1
  %1749 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1750:                                   ; preds = %4306
  %1751 = lshr i32 %4307, 16
  %1752 = and i32 %1751, 255
  %1753 = zext i32 %1752 to i64
  %1754 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1753, i32 0
  %1755 = lshr i32 %4307, 24
  %1756 = zext i32 %1755 to i64
  %1757 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1756, i32 0
  %1758 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1753, i32 0, i32 1
  %1759 = load i8, i8* %1758, align 8, !tbaa !22
  switch i8 %1759, label %1794 [
    i8 35, label %1760
    i8 19, label %1772
  ]

; <label>:1760:                                   ; preds = %1750
  %1761 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1756, i32 0, i32 1
  %1762 = load i8, i8* %1761, align 8, !tbaa !22
  %1763 = icmp eq i8 %1762, 35
  %1764 = bitcast %struct.TValue* %1754 to i64*
  %1765 = load i64, i64* %1764, align 8, !tbaa !21
  br i1 %1763, label %1766, label %1777

; <label>:1766:                                   ; preds = %1760
  %1767 = bitcast %struct.TValue* %1757 to i64*
  %1768 = load i64, i64* %1767, align 8, !tbaa !21
  %1769 = sub i64 %1765, %1768
  %1770 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1769, i64* %1770, align 8, !tbaa !21
  %1771 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1771, align 8, !tbaa !22
  br label %1797

; <label>:1772:                                   ; preds = %1750
  %1773 = bitcast %struct.TValue* %1754 to double*
  %1774 = load double, double* %1773, align 8, !tbaa !21
  %1775 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1756, i32 0, i32 1
  %1776 = load i8, i8* %1775, align 8, !tbaa !22
  br label %1779

; <label>:1777:                                   ; preds = %1760
  %1778 = sitofp i64 %1765 to double
  br label %1779

; <label>:1779:                                   ; preds = %1772, %1777
  %1780 = phi i8 [ %1776, %1772 ], [ %1762, %1777 ]
  %1781 = phi double [ %1774, %1772 ], [ %1778, %1777 ]
  switch i8 %1780, label %1794 [
    i8 19, label %1782
    i8 35, label %1785
  ]

; <label>:1782:                                   ; preds = %1779
  %1783 = bitcast %struct.TValue* %1757 to double*
  %1784 = load double, double* %1783, align 8, !tbaa !21
  br label %1789

; <label>:1785:                                   ; preds = %1779
  %1786 = bitcast %struct.TValue* %1757 to i64*
  %1787 = load i64, i64* %1786, align 8, !tbaa !21
  %1788 = sitofp i64 %1787 to double
  br label %1789

; <label>:1789:                                   ; preds = %1782, %1785
  %1790 = phi double [ %1784, %1782 ], [ %1788, %1785 ]
  %1791 = fsub double %1781, %1790
  %1792 = bitcast %union.StackValue* %4314 to double*
  store double %1791, double* %1792, align 8, !tbaa !21
  %1793 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1793, align 8, !tbaa !22
  br label %1797

; <label>:1794:                                   ; preds = %1750, %1779
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1795 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1795, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1754, %struct.TValue* %1757, %union.StackValue* %4314, i32 7) #16
  %1796 = load i32, i32* %38, align 8, !tbaa !21
  br label %1797

; <label>:1797:                                   ; preds = %1789, %1794, %1766
  %1798 = phi i32 [ %4309, %1766 ], [ %4309, %1789 ], [ %1796, %1794 ]
  %1799 = icmp eq i32 %1798, 0
  br i1 %1799, label %1804, label %1800

; <label>:1800:                                   ; preds = %1797
  %1801 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1802 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1803 = getelementptr inbounds %union.StackValue, %union.StackValue* %1802, i64 1
  br label %1804

; <label>:1804:                                   ; preds = %1797, %1800
  %1805 = phi i32 [ %1801, %1800 ], [ 0, %1797 ]
  %1806 = phi %union.StackValue* [ %1803, %1800 ], [ %4308, %1797 ]
  %1807 = getelementptr inbounds i32, i32* %4310, i64 1
  %1808 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1809:                                   ; preds = %4306
  %1810 = lshr i32 %4307, 16
  %1811 = and i32 %1810, 255
  %1812 = zext i32 %1811 to i64
  %1813 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1812, i32 0
  %1814 = lshr i32 %4307, 24
  %1815 = zext i32 %1814 to i64
  %1816 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1815, i32 0
  %1817 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1812, i32 0, i32 1
  %1818 = load i8, i8* %1817, align 8, !tbaa !22
  switch i8 %1818, label %1853 [
    i8 35, label %1819
    i8 19, label %1831
  ]

; <label>:1819:                                   ; preds = %1809
  %1820 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1815, i32 0, i32 1
  %1821 = load i8, i8* %1820, align 8, !tbaa !22
  %1822 = icmp eq i8 %1821, 35
  %1823 = bitcast %struct.TValue* %1813 to i64*
  %1824 = load i64, i64* %1823, align 8, !tbaa !21
  br i1 %1822, label %1825, label %1836

; <label>:1825:                                   ; preds = %1819
  %1826 = bitcast %struct.TValue* %1816 to i64*
  %1827 = load i64, i64* %1826, align 8, !tbaa !21
  %1828 = mul i64 %1827, %1824
  %1829 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1828, i64* %1829, align 8, !tbaa !21
  %1830 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1830, align 8, !tbaa !22
  br label %1856

; <label>:1831:                                   ; preds = %1809
  %1832 = bitcast %struct.TValue* %1813 to double*
  %1833 = load double, double* %1832, align 8, !tbaa !21
  %1834 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1815, i32 0, i32 1
  %1835 = load i8, i8* %1834, align 8, !tbaa !22
  br label %1838

; <label>:1836:                                   ; preds = %1819
  %1837 = sitofp i64 %1824 to double
  br label %1838

; <label>:1838:                                   ; preds = %1831, %1836
  %1839 = phi i8 [ %1835, %1831 ], [ %1821, %1836 ]
  %1840 = phi double [ %1833, %1831 ], [ %1837, %1836 ]
  switch i8 %1839, label %1853 [
    i8 19, label %1841
    i8 35, label %1844
  ]

; <label>:1841:                                   ; preds = %1838
  %1842 = bitcast %struct.TValue* %1816 to double*
  %1843 = load double, double* %1842, align 8, !tbaa !21
  br label %1848

; <label>:1844:                                   ; preds = %1838
  %1845 = bitcast %struct.TValue* %1816 to i64*
  %1846 = load i64, i64* %1845, align 8, !tbaa !21
  %1847 = sitofp i64 %1846 to double
  br label %1848

; <label>:1848:                                   ; preds = %1841, %1844
  %1849 = phi double [ %1843, %1841 ], [ %1847, %1844 ]
  %1850 = fmul double %1840, %1849
  %1851 = bitcast %union.StackValue* %4314 to double*
  store double %1850, double* %1851, align 8, !tbaa !21
  %1852 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1852, align 8, !tbaa !22
  br label %1856

; <label>:1853:                                   ; preds = %1809, %1838
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1854 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1854, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1813, %struct.TValue* %1816, %union.StackValue* %4314, i32 8) #16
  %1855 = load i32, i32* %38, align 8, !tbaa !21
  br label %1856

; <label>:1856:                                   ; preds = %1848, %1853, %1825
  %1857 = phi i32 [ %4309, %1825 ], [ %4309, %1848 ], [ %1855, %1853 ]
  %1858 = icmp eq i32 %1857, 0
  br i1 %1858, label %1863, label %1859

; <label>:1859:                                   ; preds = %1856
  %1860 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1861 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1862 = getelementptr inbounds %union.StackValue, %union.StackValue* %1861, i64 1
  br label %1863

; <label>:1863:                                   ; preds = %1856, %1859
  %1864 = phi i32 [ %1860, %1859 ], [ 0, %1856 ]
  %1865 = phi %union.StackValue* [ %1862, %1859 ], [ %4308, %1856 ]
  %1866 = getelementptr inbounds i32, i32* %4310, i64 1
  %1867 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1868:                                   ; preds = %4306
  %1869 = lshr i32 %4307, 16
  %1870 = and i32 %1869, 255
  %1871 = zext i32 %1870 to i64
  %1872 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1871, i32 0
  %1873 = lshr i32 %4307, 24
  %1874 = zext i32 %1873 to i64
  %1875 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1874, i32 0
  %1876 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1871, i32 0, i32 1
  %1877 = load i8, i8* %1876, align 8, !tbaa !22
  switch i8 %1877, label %1923 [
    i8 35, label %1878
    i8 19, label %1890
  ]

; <label>:1878:                                   ; preds = %1868
  %1879 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1874, i32 0, i32 1
  %1880 = load i8, i8* %1879, align 8, !tbaa !22
  %1881 = icmp eq i8 %1880, 35
  %1882 = bitcast %struct.TValue* %1872 to i64*
  %1883 = load i64, i64* %1882, align 8, !tbaa !21
  br i1 %1881, label %1884, label %1895

; <label>:1884:                                   ; preds = %1878
  %1885 = bitcast %struct.TValue* %1875 to i64*
  %1886 = load i64, i64* %1885, align 8, !tbaa !21
  %1887 = call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %1883, i64 %1886) #16
  %1888 = bitcast %union.StackValue* %4314 to i64*
  store i64 %1887, i64* %1888, align 8, !tbaa !21
  %1889 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %1889, align 8, !tbaa !22
  br label %1926

; <label>:1890:                                   ; preds = %1868
  %1891 = bitcast %struct.TValue* %1872 to double*
  %1892 = load double, double* %1891, align 8, !tbaa !21
  %1893 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1874, i32 0, i32 1
  %1894 = load i8, i8* %1893, align 8, !tbaa !22
  br label %1897

; <label>:1895:                                   ; preds = %1878
  %1896 = sitofp i64 %1883 to double
  br label %1897

; <label>:1897:                                   ; preds = %1890, %1895
  %1898 = phi i8 [ %1894, %1890 ], [ %1880, %1895 ]
  %1899 = phi double [ %1892, %1890 ], [ %1896, %1895 ]
  switch i8 %1898, label %1923 [
    i8 19, label %1900
    i8 35, label %1903
  ]

; <label>:1900:                                   ; preds = %1897
  %1901 = bitcast %struct.TValue* %1875 to double*
  %1902 = load double, double* %1901, align 8, !tbaa !21
  br label %1907

; <label>:1903:                                   ; preds = %1897
  %1904 = bitcast %struct.TValue* %1875 to i64*
  %1905 = load i64, i64* %1904, align 8, !tbaa !21
  %1906 = sitofp i64 %1905 to double
  br label %1907

; <label>:1907:                                   ; preds = %1900, %1903
  %1908 = phi double [ %1902, %1900 ], [ %1906, %1903 ]
  %1909 = call double @fmod(double %1899, double %1908) #17
  %1910 = fcmp ogt double %1909, 0.000000e+00
  br i1 %1910, label %1911, label %1913

; <label>:1911:                                   ; preds = %1907
  %1912 = fcmp olt double %1908, 0.000000e+00
  br i1 %1912, label %1917, label %1919

; <label>:1913:                                   ; preds = %1907
  %1914 = fcmp olt double %1909, 0.000000e+00
  %1915 = fcmp ogt double %1908, 0.000000e+00
  %1916 = and i1 %1915, %1914
  br i1 %1916, label %1917, label %1919

; <label>:1917:                                   ; preds = %1913, %1911
  %1918 = fadd double %1908, %1909
  br label %1919

; <label>:1919:                                   ; preds = %1911, %1913, %1917
  %1920 = phi double [ %1918, %1917 ], [ %1909, %1911 ], [ %1909, %1913 ]
  %1921 = bitcast %union.StackValue* %4314 to double*
  store double %1920, double* %1921, align 8, !tbaa !21
  %1922 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1922, align 8, !tbaa !22
  br label %1926

; <label>:1923:                                   ; preds = %1868, %1897
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1924 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1924, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1872, %struct.TValue* %1875, %union.StackValue* %4314, i32 9) #16
  %1925 = load i32, i32* %38, align 8, !tbaa !21
  br label %1926

; <label>:1926:                                   ; preds = %1919, %1923, %1884
  %1927 = phi i32 [ %4309, %1884 ], [ %4309, %1919 ], [ %1925, %1923 ]
  %1928 = icmp eq i32 %1927, 0
  br i1 %1928, label %1933, label %1929

; <label>:1929:                                   ; preds = %1926
  %1930 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1931 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1932 = getelementptr inbounds %union.StackValue, %union.StackValue* %1931, i64 1
  br label %1933

; <label>:1933:                                   ; preds = %1926, %1929
  %1934 = phi i32 [ %1930, %1929 ], [ 0, %1926 ]
  %1935 = phi %union.StackValue* [ %1932, %1929 ], [ %4308, %1926 ]
  %1936 = getelementptr inbounds i32, i32* %4310, i64 1
  %1937 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1938:                                   ; preds = %4306
  %1939 = lshr i32 %4307, 16
  %1940 = and i32 %1939, 255
  %1941 = zext i32 %1940 to i64
  %1942 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1941, i32 0
  %1943 = lshr i32 %4307, 24
  %1944 = zext i32 %1943 to i64
  %1945 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1944, i32 0
  %1946 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1941, i32 0, i32 1
  %1947 = load i8, i8* %1946, align 8, !tbaa !22
  switch i8 %1947, label %1971 [
    i8 19, label %1948
    i8 35, label %1951
  ]

; <label>:1948:                                   ; preds = %1938
  %1949 = bitcast %struct.TValue* %1942 to double*
  %1950 = load double, double* %1949, align 8, !tbaa !21
  br label %1955

; <label>:1951:                                   ; preds = %1938
  %1952 = bitcast %struct.TValue* %1942 to i64*
  %1953 = load i64, i64* %1952, align 8, !tbaa !21
  %1954 = sitofp i64 %1953 to double
  br label %1955

; <label>:1955:                                   ; preds = %1948, %1951
  %1956 = phi double [ %1950, %1948 ], [ %1954, %1951 ]
  %1957 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1944, i32 0, i32 1
  %1958 = load i8, i8* %1957, align 8, !tbaa !22
  switch i8 %1958, label %1971 [
    i8 19, label %1959
    i8 35, label %1962
  ]

; <label>:1959:                                   ; preds = %1955
  %1960 = bitcast %struct.TValue* %1945 to double*
  %1961 = load double, double* %1960, align 8, !tbaa !21
  br label %1966

; <label>:1962:                                   ; preds = %1955
  %1963 = bitcast %struct.TValue* %1945 to i64*
  %1964 = load i64, i64* %1963, align 8, !tbaa !21
  %1965 = sitofp i64 %1964 to double
  br label %1966

; <label>:1966:                                   ; preds = %1959, %1962
  %1967 = phi double [ %1961, %1959 ], [ %1965, %1962 ]
  %1968 = call double @pow(double %1956, double %1967) #17
  %1969 = bitcast %union.StackValue* %4314 to double*
  store double %1968, double* %1969, align 8, !tbaa !21
  %1970 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %1970, align 8, !tbaa !22
  br label %1974

; <label>:1971:                                   ; preds = %1955, %1938
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %1972 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %1972, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1942, %struct.TValue* %1945, %union.StackValue* %4314, i32 10) #16
  %1973 = load i32, i32* %38, align 8, !tbaa !21
  br label %1974

; <label>:1974:                                   ; preds = %1971, %1966
  %1975 = phi i32 [ %4309, %1966 ], [ %1973, %1971 ]
  %1976 = icmp eq i32 %1975, 0
  br i1 %1976, label %1981, label %1977

; <label>:1977:                                   ; preds = %1974
  %1978 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %1979 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %1980 = getelementptr inbounds %union.StackValue, %union.StackValue* %1979, i64 1
  br label %1981

; <label>:1981:                                   ; preds = %1974, %1977
  %1982 = phi i32 [ %1978, %1977 ], [ 0, %1974 ]
  %1983 = phi %union.StackValue* [ %1980, %1977 ], [ %4308, %1974 ]
  %1984 = getelementptr inbounds i32, i32* %4310, i64 1
  %1985 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:1986:                                   ; preds = %4306
  %1987 = lshr i32 %4307, 16
  %1988 = and i32 %1987, 255
  %1989 = zext i32 %1988 to i64
  %1990 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1989, i32 0
  %1991 = lshr i32 %4307, 24
  %1992 = zext i32 %1991 to i64
  %1993 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1992, i32 0
  %1994 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1989, i32 0, i32 1
  %1995 = load i8, i8* %1994, align 8, !tbaa !22
  switch i8 %1995, label %2019 [
    i8 19, label %1996
    i8 35, label %1999
  ]

; <label>:1996:                                   ; preds = %1986
  %1997 = bitcast %struct.TValue* %1990 to double*
  %1998 = load double, double* %1997, align 8, !tbaa !21
  br label %2003

; <label>:1999:                                   ; preds = %1986
  %2000 = bitcast %struct.TValue* %1990 to i64*
  %2001 = load i64, i64* %2000, align 8, !tbaa !21
  %2002 = sitofp i64 %2001 to double
  br label %2003

; <label>:2003:                                   ; preds = %1996, %1999
  %2004 = phi double [ %1998, %1996 ], [ %2002, %1999 ]
  %2005 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %1992, i32 0, i32 1
  %2006 = load i8, i8* %2005, align 8, !tbaa !22
  switch i8 %2006, label %2019 [
    i8 19, label %2007
    i8 35, label %2010
  ]

; <label>:2007:                                   ; preds = %2003
  %2008 = bitcast %struct.TValue* %1993 to double*
  %2009 = load double, double* %2008, align 8, !tbaa !21
  br label %2014

; <label>:2010:                                   ; preds = %2003
  %2011 = bitcast %struct.TValue* %1993 to i64*
  %2012 = load i64, i64* %2011, align 8, !tbaa !21
  %2013 = sitofp i64 %2012 to double
  br label %2014

; <label>:2014:                                   ; preds = %2007, %2010
  %2015 = phi double [ %2009, %2007 ], [ %2013, %2010 ]
  %2016 = fdiv double %2004, %2015
  %2017 = bitcast %union.StackValue* %4314 to double*
  store double %2016, double* %2017, align 8, !tbaa !21
  %2018 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %2018, align 8, !tbaa !22
  br label %2022

; <label>:2019:                                   ; preds = %2003, %1986
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2020 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2020, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1990, %struct.TValue* %1993, %union.StackValue* %4314, i32 11) #16
  %2021 = load i32, i32* %38, align 8, !tbaa !21
  br label %2022

; <label>:2022:                                   ; preds = %2019, %2014
  %2023 = phi i32 [ %4309, %2014 ], [ %2021, %2019 ]
  %2024 = icmp eq i32 %2023, 0
  br i1 %2024, label %2029, label %2025

; <label>:2025:                                   ; preds = %2022
  %2026 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2027 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2028 = getelementptr inbounds %union.StackValue, %union.StackValue* %2027, i64 1
  br label %2029

; <label>:2029:                                   ; preds = %2022, %2025
  %2030 = phi i32 [ %2026, %2025 ], [ 0, %2022 ]
  %2031 = phi %union.StackValue* [ %2028, %2025 ], [ %4308, %2022 ]
  %2032 = getelementptr inbounds i32, i32* %4310, i64 1
  %2033 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2034:                                   ; preds = %4306
  %2035 = lshr i32 %4307, 16
  %2036 = and i32 %2035, 255
  %2037 = zext i32 %2036 to i64
  %2038 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2037, i32 0
  %2039 = lshr i32 %4307, 24
  %2040 = zext i32 %2039 to i64
  %2041 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2040, i32 0
  %2042 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2037, i32 0, i32 1
  %2043 = load i8, i8* %2042, align 8, !tbaa !22
  switch i8 %2043, label %2079 [
    i8 35, label %2044
    i8 19, label %2056
  ]

; <label>:2044:                                   ; preds = %2034
  %2045 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2040, i32 0, i32 1
  %2046 = load i8, i8* %2045, align 8, !tbaa !22
  %2047 = icmp eq i8 %2046, 35
  %2048 = bitcast %struct.TValue* %2038 to i64*
  %2049 = load i64, i64* %2048, align 8, !tbaa !21
  br i1 %2047, label %2050, label %2061

; <label>:2050:                                   ; preds = %2044
  %2051 = bitcast %struct.TValue* %2041 to i64*
  %2052 = load i64, i64* %2051, align 8, !tbaa !21
  %2053 = call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %2049, i64 %2052) #16
  %2054 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2053, i64* %2054, align 8, !tbaa !21
  %2055 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2055, align 8, !tbaa !22
  br label %2082

; <label>:2056:                                   ; preds = %2034
  %2057 = bitcast %struct.TValue* %2038 to double*
  %2058 = load double, double* %2057, align 8, !tbaa !21
  %2059 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2040, i32 0, i32 1
  %2060 = load i8, i8* %2059, align 8, !tbaa !22
  br label %2063

; <label>:2061:                                   ; preds = %2044
  %2062 = sitofp i64 %2049 to double
  br label %2063

; <label>:2063:                                   ; preds = %2056, %2061
  %2064 = phi i8 [ %2060, %2056 ], [ %2046, %2061 ]
  %2065 = phi double [ %2058, %2056 ], [ %2062, %2061 ]
  switch i8 %2064, label %2079 [
    i8 19, label %2066
    i8 35, label %2069
  ]

; <label>:2066:                                   ; preds = %2063
  %2067 = bitcast %struct.TValue* %2041 to double*
  %2068 = load double, double* %2067, align 8, !tbaa !21
  br label %2073

; <label>:2069:                                   ; preds = %2063
  %2070 = bitcast %struct.TValue* %2041 to i64*
  %2071 = load i64, i64* %2070, align 8, !tbaa !21
  %2072 = sitofp i64 %2071 to double
  br label %2073

; <label>:2073:                                   ; preds = %2066, %2069
  %2074 = phi double [ %2068, %2066 ], [ %2072, %2069 ]
  %2075 = fdiv double %2065, %2074
  %2076 = call double @llvm.floor.f64(double %2075)
  %2077 = bitcast %union.StackValue* %4314 to double*
  store double %2076, double* %2077, align 8, !tbaa !21
  %2078 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %2078, align 8, !tbaa !22
  br label %2082

; <label>:2079:                                   ; preds = %2034, %2063
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2080 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2080, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2038, %struct.TValue* %2041, %union.StackValue* %4314, i32 12) #16
  %2081 = load i32, i32* %38, align 8, !tbaa !21
  br label %2082

; <label>:2082:                                   ; preds = %2073, %2079, %2050
  %2083 = phi i32 [ %4309, %2050 ], [ %4309, %2073 ], [ %2081, %2079 ]
  %2084 = icmp eq i32 %2083, 0
  br i1 %2084, label %2089, label %2085

; <label>:2085:                                   ; preds = %2082
  %2086 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2087 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2088 = getelementptr inbounds %union.StackValue, %union.StackValue* %2087, i64 1
  br label %2089

; <label>:2089:                                   ; preds = %2082, %2085
  %2090 = phi i32 [ %2086, %2085 ], [ 0, %2082 ]
  %2091 = phi %union.StackValue* [ %2088, %2085 ], [ %4308, %2082 ]
  %2092 = getelementptr inbounds i32, i32* %4310, i64 1
  %2093 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2094:                                   ; preds = %4306
  %2095 = lshr i32 %4307, 16
  %2096 = and i32 %2095, 255
  %2097 = zext i32 %2096 to i64
  %2098 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2097, i32 0
  %2099 = lshr i32 %4307, 24
  %2100 = zext i32 %2099 to i64
  %2101 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %2100, i32 0
  %2102 = bitcast %union.Value* %2101 to i64*
  %2103 = load i64, i64* %2102, align 8, !tbaa !21
  %2104 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2097, i32 0, i32 1
  %2105 = load i8, i8* %2104, align 8, !tbaa !22
  switch i8 %2105, label %2125 [
    i8 35, label %2106
    i8 19, label %2109
  ]

; <label>:2106:                                   ; preds = %2094
  %2107 = bitcast %struct.TValue* %2098 to i64*
  %2108 = load i64, i64* %2107, align 8, !tbaa !21
  br label %2120

; <label>:2109:                                   ; preds = %2094
  %2110 = bitcast %struct.TValue* %2098 to double*
  %2111 = load double, double* %2110, align 8, !tbaa !21
  %2112 = call double @llvm.floor.f64(double %2111) #7
  %2113 = fcmp une double %2112, %2111
  br i1 %2113, label %2125, label %2114

; <label>:2114:                                   ; preds = %2109
  %2115 = fcmp oge double %2112, 0xC3E0000000000000
  %2116 = fcmp olt double %2112, 0x43E0000000000000
  %2117 = and i1 %2115, %2116
  br i1 %2117, label %2118, label %2125

; <label>:2118:                                   ; preds = %2114
  %2119 = fptosi double %2112 to i64
  br label %2120

; <label>:2120:                                   ; preds = %2118, %2106
  %2121 = phi i64 [ %2108, %2106 ], [ %2119, %2118 ]
  %2122 = and i64 %2121, %2103
  %2123 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2122, i64* %2123, align 8, !tbaa !21
  %2124 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2124, align 8, !tbaa !22
  br label %2129

; <label>:2125:                                   ; preds = %2094, %2114, %2109
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2126 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2126, i64* %35, align 8, !tbaa !20
  %2127 = and i32 %4307, 32768
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %73) #7
  store i64 %2103, i64* %74, align 8, !tbaa !21
  store i8 35, i8* %75, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* nonnull %2098, %struct.TValue* nonnull %12, %union.StackValue* %4314, i32 %2127, i32 13) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %73) #7
  %2128 = load i32, i32* %38, align 8, !tbaa !21
  br label %2129

; <label>:2129:                                   ; preds = %2125, %2120
  %2130 = phi i32 [ %4309, %2120 ], [ %2128, %2125 ]
  %2131 = icmp eq i32 %2130, 0
  br i1 %2131, label %2136, label %2132

; <label>:2132:                                   ; preds = %2129
  %2133 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2134 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2135 = getelementptr inbounds %union.StackValue, %union.StackValue* %2134, i64 1
  br label %2136

; <label>:2136:                                   ; preds = %2129, %2132
  %2137 = phi i32 [ %2133, %2132 ], [ 0, %2129 ]
  %2138 = phi %union.StackValue* [ %2135, %2132 ], [ %4308, %2129 ]
  %2139 = getelementptr inbounds i32, i32* %4310, i64 1
  %2140 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2141:                                   ; preds = %4306
  %2142 = lshr i32 %4307, 16
  %2143 = and i32 %2142, 255
  %2144 = zext i32 %2143 to i64
  %2145 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2144, i32 0
  %2146 = lshr i32 %4307, 24
  %2147 = zext i32 %2146 to i64
  %2148 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %2147, i32 0
  %2149 = bitcast %union.Value* %2148 to i64*
  %2150 = load i64, i64* %2149, align 8, !tbaa !21
  %2151 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2144, i32 0, i32 1
  %2152 = load i8, i8* %2151, align 8, !tbaa !22
  switch i8 %2152, label %2172 [
    i8 35, label %2153
    i8 19, label %2156
  ]

; <label>:2153:                                   ; preds = %2141
  %2154 = bitcast %struct.TValue* %2145 to i64*
  %2155 = load i64, i64* %2154, align 8, !tbaa !21
  br label %2167

; <label>:2156:                                   ; preds = %2141
  %2157 = bitcast %struct.TValue* %2145 to double*
  %2158 = load double, double* %2157, align 8, !tbaa !21
  %2159 = call double @llvm.floor.f64(double %2158) #7
  %2160 = fcmp une double %2159, %2158
  br i1 %2160, label %2172, label %2161

; <label>:2161:                                   ; preds = %2156
  %2162 = fcmp oge double %2159, 0xC3E0000000000000
  %2163 = fcmp olt double %2159, 0x43E0000000000000
  %2164 = and i1 %2162, %2163
  br i1 %2164, label %2165, label %2172

; <label>:2165:                                   ; preds = %2161
  %2166 = fptosi double %2159 to i64
  br label %2167

; <label>:2167:                                   ; preds = %2165, %2153
  %2168 = phi i64 [ %2155, %2153 ], [ %2166, %2165 ]
  %2169 = or i64 %2168, %2150
  %2170 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2169, i64* %2170, align 8, !tbaa !21
  %2171 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2171, align 8, !tbaa !22
  br label %2176

; <label>:2172:                                   ; preds = %2141, %2161, %2156
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2173 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2173, i64* %35, align 8, !tbaa !20
  %2174 = and i32 %4307, 32768
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %76) #7
  store i64 %2150, i64* %77, align 8, !tbaa !21
  store i8 35, i8* %78, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* nonnull %2145, %struct.TValue* nonnull %11, %union.StackValue* %4314, i32 %2174, i32 14) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %76) #7
  %2175 = load i32, i32* %38, align 8, !tbaa !21
  br label %2176

; <label>:2176:                                   ; preds = %2172, %2167
  %2177 = phi i32 [ %4309, %2167 ], [ %2175, %2172 ]
  %2178 = icmp eq i32 %2177, 0
  br i1 %2178, label %2183, label %2179

; <label>:2179:                                   ; preds = %2176
  %2180 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2181 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2182 = getelementptr inbounds %union.StackValue, %union.StackValue* %2181, i64 1
  br label %2183

; <label>:2183:                                   ; preds = %2176, %2179
  %2184 = phi i32 [ %2180, %2179 ], [ 0, %2176 ]
  %2185 = phi %union.StackValue* [ %2182, %2179 ], [ %4308, %2176 ]
  %2186 = getelementptr inbounds i32, i32* %4310, i64 1
  %2187 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2188:                                   ; preds = %4306
  %2189 = lshr i32 %4307, 16
  %2190 = and i32 %2189, 255
  %2191 = zext i32 %2190 to i64
  %2192 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2191, i32 0
  %2193 = lshr i32 %4307, 24
  %2194 = zext i32 %2193 to i64
  %2195 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %2194, i32 0
  %2196 = bitcast %union.Value* %2195 to i64*
  %2197 = load i64, i64* %2196, align 8, !tbaa !21
  %2198 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2191, i32 0, i32 1
  %2199 = load i8, i8* %2198, align 8, !tbaa !22
  switch i8 %2199, label %2219 [
    i8 35, label %2200
    i8 19, label %2203
  ]

; <label>:2200:                                   ; preds = %2188
  %2201 = bitcast %struct.TValue* %2192 to i64*
  %2202 = load i64, i64* %2201, align 8, !tbaa !21
  br label %2214

; <label>:2203:                                   ; preds = %2188
  %2204 = bitcast %struct.TValue* %2192 to double*
  %2205 = load double, double* %2204, align 8, !tbaa !21
  %2206 = call double @llvm.floor.f64(double %2205) #7
  %2207 = fcmp une double %2206, %2205
  br i1 %2207, label %2219, label %2208

; <label>:2208:                                   ; preds = %2203
  %2209 = fcmp oge double %2206, 0xC3E0000000000000
  %2210 = fcmp olt double %2206, 0x43E0000000000000
  %2211 = and i1 %2209, %2210
  br i1 %2211, label %2212, label %2219

; <label>:2212:                                   ; preds = %2208
  %2213 = fptosi double %2206 to i64
  br label %2214

; <label>:2214:                                   ; preds = %2212, %2200
  %2215 = phi i64 [ %2202, %2200 ], [ %2213, %2212 ]
  %2216 = xor i64 %2215, %2197
  %2217 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2216, i64* %2217, align 8, !tbaa !21
  %2218 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2218, align 8, !tbaa !22
  br label %2223

; <label>:2219:                                   ; preds = %2188, %2208, %2203
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2220 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2220, i64* %35, align 8, !tbaa !20
  %2221 = and i32 %4307, 32768
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %79) #7
  store i64 %2197, i64* %80, align 8, !tbaa !21
  store i8 35, i8* %81, align 8, !tbaa !22
  call fastcc void @luaT_trybinassocTM(%struct.lua_State* %0, %struct.TValue* nonnull %2192, %struct.TValue* nonnull %10, %union.StackValue* %4314, i32 %2221, i32 15) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %79) #7
  %2222 = load i32, i32* %38, align 8, !tbaa !21
  br label %2223

; <label>:2223:                                   ; preds = %2219, %2214
  %2224 = phi i32 [ %4309, %2214 ], [ %2222, %2219 ]
  %2225 = icmp eq i32 %2224, 0
  br i1 %2225, label %2230, label %2226

; <label>:2226:                                   ; preds = %2223
  %2227 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2228 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2229 = getelementptr inbounds %union.StackValue, %union.StackValue* %2228, i64 1
  br label %2230

; <label>:2230:                                   ; preds = %2223, %2226
  %2231 = phi i32 [ %2227, %2226 ], [ 0, %2223 ]
  %2232 = phi %union.StackValue* [ %2229, %2226 ], [ %4308, %2223 ]
  %2233 = getelementptr inbounds i32, i32* %4310, i64 1
  %2234 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2235:                                   ; preds = %4306
  %2236 = lshr i32 %4307, 16
  %2237 = and i32 %2236, 255
  %2238 = zext i32 %2237 to i64
  %2239 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2238, i32 0
  %2240 = lshr i32 %4307, 24
  %2241 = zext i32 %2240 to i64
  %2242 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2241, i32 0
  %2243 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2238, i32 0, i32 1
  %2244 = load i8, i8* %2243, align 8, !tbaa !22
  switch i8 %2244, label %2282 [
    i8 35, label %2245
    i8 19, label %2248
  ]

; <label>:2245:                                   ; preds = %2235
  %2246 = bitcast %struct.TValue* %2239 to i64*
  %2247 = load i64, i64* %2246, align 8, !tbaa !21
  br label %2259

; <label>:2248:                                   ; preds = %2235
  %2249 = bitcast %struct.TValue* %2239 to double*
  %2250 = load double, double* %2249, align 8, !tbaa !21
  %2251 = call double @llvm.floor.f64(double %2250) #7
  %2252 = fcmp une double %2251, %2250
  br i1 %2252, label %2282, label %2253

; <label>:2253:                                   ; preds = %2248
  %2254 = fcmp oge double %2251, 0xC3E0000000000000
  %2255 = fcmp olt double %2251, 0x43E0000000000000
  %2256 = and i1 %2254, %2255
  br i1 %2256, label %2257, label %2282

; <label>:2257:                                   ; preds = %2253
  %2258 = fptosi double %2251 to i64
  br label %2259

; <label>:2259:                                   ; preds = %2257, %2245
  %2260 = phi i64 [ %2247, %2245 ], [ %2258, %2257 ]
  %2261 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2241, i32 0, i32 1
  %2262 = load i8, i8* %2261, align 8, !tbaa !22
  switch i8 %2262, label %2282 [
    i8 35, label %2263
    i8 19, label %2266
  ]

; <label>:2263:                                   ; preds = %2259
  %2264 = bitcast %struct.TValue* %2242 to i64*
  %2265 = load i64, i64* %2264, align 8, !tbaa !21
  br label %2277

; <label>:2266:                                   ; preds = %2259
  %2267 = bitcast %struct.TValue* %2242 to double*
  %2268 = load double, double* %2267, align 8, !tbaa !21
  %2269 = call double @llvm.floor.f64(double %2268) #7
  %2270 = fcmp une double %2269, %2268
  br i1 %2270, label %2282, label %2271

; <label>:2271:                                   ; preds = %2266
  %2272 = fcmp oge double %2269, 0xC3E0000000000000
  %2273 = fcmp olt double %2269, 0x43E0000000000000
  %2274 = and i1 %2272, %2273
  br i1 %2274, label %2275, label %2282

; <label>:2275:                                   ; preds = %2271
  %2276 = fptosi double %2269 to i64
  br label %2277

; <label>:2277:                                   ; preds = %2275, %2263
  %2278 = phi i64 [ %2265, %2263 ], [ %2276, %2275 ]
  %2279 = and i64 %2278, %2260
  %2280 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2279, i64* %2280, align 8, !tbaa !21
  %2281 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2281, align 8, !tbaa !22
  br label %2285

; <label>:2282:                                   ; preds = %2259, %2235, %2266, %2271, %2248, %2253
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2283 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2283, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2239, %struct.TValue* nonnull %2242, %union.StackValue* %4314, i32 13) #16
  %2284 = load i32, i32* %38, align 8, !tbaa !21
  br label %2285

; <label>:2285:                                   ; preds = %2282, %2277
  %2286 = phi i32 [ %4309, %2277 ], [ %2284, %2282 ]
  %2287 = icmp eq i32 %2286, 0
  br i1 %2287, label %2292, label %2288

; <label>:2288:                                   ; preds = %2285
  %2289 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2290 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2291 = getelementptr inbounds %union.StackValue, %union.StackValue* %2290, i64 1
  br label %2292

; <label>:2292:                                   ; preds = %2285, %2288
  %2293 = phi i32 [ %2289, %2288 ], [ 0, %2285 ]
  %2294 = phi %union.StackValue* [ %2291, %2288 ], [ %4308, %2285 ]
  %2295 = getelementptr inbounds i32, i32* %4310, i64 1
  %2296 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2297:                                   ; preds = %4306
  %2298 = lshr i32 %4307, 16
  %2299 = and i32 %2298, 255
  %2300 = zext i32 %2299 to i64
  %2301 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2300, i32 0
  %2302 = lshr i32 %4307, 24
  %2303 = zext i32 %2302 to i64
  %2304 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2303, i32 0
  %2305 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2300, i32 0, i32 1
  %2306 = load i8, i8* %2305, align 8, !tbaa !22
  switch i8 %2306, label %2344 [
    i8 35, label %2307
    i8 19, label %2310
  ]

; <label>:2307:                                   ; preds = %2297
  %2308 = bitcast %struct.TValue* %2301 to i64*
  %2309 = load i64, i64* %2308, align 8, !tbaa !21
  br label %2321

; <label>:2310:                                   ; preds = %2297
  %2311 = bitcast %struct.TValue* %2301 to double*
  %2312 = load double, double* %2311, align 8, !tbaa !21
  %2313 = call double @llvm.floor.f64(double %2312) #7
  %2314 = fcmp une double %2313, %2312
  br i1 %2314, label %2344, label %2315

; <label>:2315:                                   ; preds = %2310
  %2316 = fcmp oge double %2313, 0xC3E0000000000000
  %2317 = fcmp olt double %2313, 0x43E0000000000000
  %2318 = and i1 %2316, %2317
  br i1 %2318, label %2319, label %2344

; <label>:2319:                                   ; preds = %2315
  %2320 = fptosi double %2313 to i64
  br label %2321

; <label>:2321:                                   ; preds = %2319, %2307
  %2322 = phi i64 [ %2309, %2307 ], [ %2320, %2319 ]
  %2323 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2303, i32 0, i32 1
  %2324 = load i8, i8* %2323, align 8, !tbaa !22
  switch i8 %2324, label %2344 [
    i8 35, label %2325
    i8 19, label %2328
  ]

; <label>:2325:                                   ; preds = %2321
  %2326 = bitcast %struct.TValue* %2304 to i64*
  %2327 = load i64, i64* %2326, align 8, !tbaa !21
  br label %2339

; <label>:2328:                                   ; preds = %2321
  %2329 = bitcast %struct.TValue* %2304 to double*
  %2330 = load double, double* %2329, align 8, !tbaa !21
  %2331 = call double @llvm.floor.f64(double %2330) #7
  %2332 = fcmp une double %2331, %2330
  br i1 %2332, label %2344, label %2333

; <label>:2333:                                   ; preds = %2328
  %2334 = fcmp oge double %2331, 0xC3E0000000000000
  %2335 = fcmp olt double %2331, 0x43E0000000000000
  %2336 = and i1 %2334, %2335
  br i1 %2336, label %2337, label %2344

; <label>:2337:                                   ; preds = %2333
  %2338 = fptosi double %2331 to i64
  br label %2339

; <label>:2339:                                   ; preds = %2337, %2325
  %2340 = phi i64 [ %2327, %2325 ], [ %2338, %2337 ]
  %2341 = or i64 %2340, %2322
  %2342 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2341, i64* %2342, align 8, !tbaa !21
  %2343 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2343, align 8, !tbaa !22
  br label %2347

; <label>:2344:                                   ; preds = %2321, %2297, %2328, %2333, %2310, %2315
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2345 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2345, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2301, %struct.TValue* nonnull %2304, %union.StackValue* %4314, i32 14) #16
  %2346 = load i32, i32* %38, align 8, !tbaa !21
  br label %2347

; <label>:2347:                                   ; preds = %2344, %2339
  %2348 = phi i32 [ %4309, %2339 ], [ %2346, %2344 ]
  %2349 = icmp eq i32 %2348, 0
  br i1 %2349, label %2354, label %2350

; <label>:2350:                                   ; preds = %2347
  %2351 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2352 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2353 = getelementptr inbounds %union.StackValue, %union.StackValue* %2352, i64 1
  br label %2354

; <label>:2354:                                   ; preds = %2347, %2350
  %2355 = phi i32 [ %2351, %2350 ], [ 0, %2347 ]
  %2356 = phi %union.StackValue* [ %2353, %2350 ], [ %4308, %2347 ]
  %2357 = getelementptr inbounds i32, i32* %4310, i64 1
  %2358 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2359:                                   ; preds = %4306
  %2360 = lshr i32 %4307, 16
  %2361 = and i32 %2360, 255
  %2362 = zext i32 %2361 to i64
  %2363 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2362, i32 0
  %2364 = lshr i32 %4307, 24
  %2365 = zext i32 %2364 to i64
  %2366 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2365, i32 0
  %2367 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2362, i32 0, i32 1
  %2368 = load i8, i8* %2367, align 8, !tbaa !22
  switch i8 %2368, label %2406 [
    i8 35, label %2369
    i8 19, label %2372
  ]

; <label>:2369:                                   ; preds = %2359
  %2370 = bitcast %struct.TValue* %2363 to i64*
  %2371 = load i64, i64* %2370, align 8, !tbaa !21
  br label %2383

; <label>:2372:                                   ; preds = %2359
  %2373 = bitcast %struct.TValue* %2363 to double*
  %2374 = load double, double* %2373, align 8, !tbaa !21
  %2375 = call double @llvm.floor.f64(double %2374) #7
  %2376 = fcmp une double %2375, %2374
  br i1 %2376, label %2406, label %2377

; <label>:2377:                                   ; preds = %2372
  %2378 = fcmp oge double %2375, 0xC3E0000000000000
  %2379 = fcmp olt double %2375, 0x43E0000000000000
  %2380 = and i1 %2378, %2379
  br i1 %2380, label %2381, label %2406

; <label>:2381:                                   ; preds = %2377
  %2382 = fptosi double %2375 to i64
  br label %2383

; <label>:2383:                                   ; preds = %2381, %2369
  %2384 = phi i64 [ %2371, %2369 ], [ %2382, %2381 ]
  %2385 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2365, i32 0, i32 1
  %2386 = load i8, i8* %2385, align 8, !tbaa !22
  switch i8 %2386, label %2406 [
    i8 35, label %2387
    i8 19, label %2390
  ]

; <label>:2387:                                   ; preds = %2383
  %2388 = bitcast %struct.TValue* %2366 to i64*
  %2389 = load i64, i64* %2388, align 8, !tbaa !21
  br label %2401

; <label>:2390:                                   ; preds = %2383
  %2391 = bitcast %struct.TValue* %2366 to double*
  %2392 = load double, double* %2391, align 8, !tbaa !21
  %2393 = call double @llvm.floor.f64(double %2392) #7
  %2394 = fcmp une double %2393, %2392
  br i1 %2394, label %2406, label %2395

; <label>:2395:                                   ; preds = %2390
  %2396 = fcmp oge double %2393, 0xC3E0000000000000
  %2397 = fcmp olt double %2393, 0x43E0000000000000
  %2398 = and i1 %2396, %2397
  br i1 %2398, label %2399, label %2406

; <label>:2399:                                   ; preds = %2395
  %2400 = fptosi double %2393 to i64
  br label %2401

; <label>:2401:                                   ; preds = %2399, %2387
  %2402 = phi i64 [ %2389, %2387 ], [ %2400, %2399 ]
  %2403 = xor i64 %2402, %2384
  %2404 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2403, i64* %2404, align 8, !tbaa !21
  %2405 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2405, align 8, !tbaa !22
  br label %2409

; <label>:2406:                                   ; preds = %2383, %2359, %2390, %2395, %2372, %2377
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2407 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2407, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2363, %struct.TValue* nonnull %2366, %union.StackValue* %4314, i32 15) #16
  %2408 = load i32, i32* %38, align 8, !tbaa !21
  br label %2409

; <label>:2409:                                   ; preds = %2406, %2401
  %2410 = phi i32 [ %4309, %2401 ], [ %2408, %2406 ]
  %2411 = icmp eq i32 %2410, 0
  br i1 %2411, label %2416, label %2412

; <label>:2412:                                   ; preds = %2409
  %2413 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2414 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2415 = getelementptr inbounds %union.StackValue, %union.StackValue* %2414, i64 1
  br label %2416

; <label>:2416:                                   ; preds = %2409, %2412
  %2417 = phi i32 [ %2413, %2412 ], [ 0, %2409 ]
  %2418 = phi %union.StackValue* [ %2415, %2412 ], [ %4308, %2409 ]
  %2419 = getelementptr inbounds i32, i32* %4310, i64 1
  %2420 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2421:                                   ; preds = %4306
  %2422 = lshr i32 %4307, 16
  %2423 = and i32 %2422, 255
  %2424 = zext i32 %2423 to i64
  %2425 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2424, i32 0
  %2426 = lshr i32 %4307, 24
  %2427 = add nsw i32 %2426, -127
  %2428 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2424, i32 0, i32 1
  %2429 = load i8, i8* %2428, align 8, !tbaa !22
  switch i8 %2429, label %2462 [
    i8 35, label %2430
    i8 19, label %2433
  ]

; <label>:2430:                                   ; preds = %2421
  %2431 = bitcast %struct.TValue* %2425 to i64*
  %2432 = load i64, i64* %2431, align 8, !tbaa !21
  br label %2444

; <label>:2433:                                   ; preds = %2421
  %2434 = bitcast %struct.TValue* %2425 to double*
  %2435 = load double, double* %2434, align 8, !tbaa !21
  %2436 = call double @llvm.floor.f64(double %2435) #7
  %2437 = fcmp une double %2436, %2435
  br i1 %2437, label %2462, label %2438

; <label>:2438:                                   ; preds = %2433
  %2439 = fcmp oge double %2436, 0xC3E0000000000000
  %2440 = fcmp olt double %2436, 0x43E0000000000000
  %2441 = and i1 %2439, %2440
  br i1 %2441, label %2442, label %2462

; <label>:2442:                                   ; preds = %2438
  %2443 = fptosi double %2436 to i64
  br label %2444

; <label>:2444:                                   ; preds = %2442, %2430
  %2445 = phi i64 [ %2432, %2430 ], [ %2443, %2442 ]
  %2446 = sub nsw i32 127, %2426
  %2447 = sext i32 %2446 to i64
  %2448 = icmp slt i32 %2446, 0
  br i1 %2448, label %2449, label %2454

; <label>:2449:                                   ; preds = %2444
  %2450 = icmp slt i32 %2446, -63
  %2451 = sub nsw i64 0, %2447
  %2452 = lshr i64 %2445, %2451
  %2453 = select i1 %2450, i64 0, i64 %2452
  br label %2458

; <label>:2454:                                   ; preds = %2444
  %2455 = icmp sgt i32 %2446, 63
  %2456 = shl i64 %2445, %2447
  %2457 = select i1 %2455, i64 0, i64 %2456
  br label %2458

; <label>:2458:                                   ; preds = %2454, %2449
  %2459 = phi i64 [ %2453, %2449 ], [ %2457, %2454 ]
  %2460 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2459, i64* %2460, align 8, !tbaa !21
  %2461 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2461, align 8, !tbaa !22
  br label %2473

; <label>:2462:                                   ; preds = %2421, %2438, %2433
  %2463 = trunc i32 %4307 to i16
  %2464 = icmp slt i16 %2463, 0
  %2465 = sub nsw i32 127, %2426
  %2466 = lshr i32 %4307, 15
  %2467 = and i32 %2466, 1
  %2468 = sub nsw i32 17, %2467
  %2469 = select i1 %2464, i32 %2465, i32 %2427
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2470 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2470, i64* %35, align 8, !tbaa !20
  %2471 = sext i32 %2469 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %82) #7
  store i64 %2471, i64* %83, align 8, !tbaa !21
  store i8 35, i8* %84, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2425, %struct.TValue* nonnull %9, %union.StackValue* %4314, i32 %2468) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %82) #7
  %2472 = load i32, i32* %38, align 8, !tbaa !21
  br label %2473

; <label>:2473:                                   ; preds = %2462, %2458
  %2474 = phi i32 [ %4309, %2458 ], [ %2472, %2462 ]
  %2475 = icmp eq i32 %2474, 0
  br i1 %2475, label %2480, label %2476

; <label>:2476:                                   ; preds = %2473
  %2477 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2478 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2479 = getelementptr inbounds %union.StackValue, %union.StackValue* %2478, i64 1
  br label %2480

; <label>:2480:                                   ; preds = %2473, %2476
  %2481 = phi i32 [ %2477, %2476 ], [ 0, %2473 ]
  %2482 = phi %union.StackValue* [ %2479, %2476 ], [ %4308, %2473 ]
  %2483 = getelementptr inbounds i32, i32* %4310, i64 1
  %2484 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2485:                                   ; preds = %4306
  %2486 = lshr i32 %4307, 16
  %2487 = and i32 %2486, 255
  %2488 = zext i32 %2487 to i64
  %2489 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2488, i32 0
  %2490 = lshr i32 %4307, 24
  %2491 = add nsw i32 %2490, -127
  %2492 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2488, i32 0, i32 1
  %2493 = load i8, i8* %2492, align 8, !tbaa !22
  switch i8 %2493, label %2525 [
    i8 35, label %2494
    i8 19, label %2497
  ]

; <label>:2494:                                   ; preds = %2485
  %2495 = bitcast %struct.TValue* %2489 to i64*
  %2496 = load i64, i64* %2495, align 8, !tbaa !21
  br label %2508

; <label>:2497:                                   ; preds = %2485
  %2498 = bitcast %struct.TValue* %2489 to double*
  %2499 = load double, double* %2498, align 8, !tbaa !21
  %2500 = call double @llvm.floor.f64(double %2499) #7
  %2501 = fcmp une double %2500, %2499
  br i1 %2501, label %2525, label %2502

; <label>:2502:                                   ; preds = %2497
  %2503 = fcmp oge double %2500, 0xC3E0000000000000
  %2504 = fcmp olt double %2500, 0x43E0000000000000
  %2505 = and i1 %2503, %2504
  br i1 %2505, label %2506, label %2525

; <label>:2506:                                   ; preds = %2502
  %2507 = fptosi double %2500 to i64
  br label %2508

; <label>:2508:                                   ; preds = %2506, %2494
  %2509 = phi i64 [ %2496, %2494 ], [ %2507, %2506 ]
  %2510 = sext i32 %2491 to i64
  %2511 = icmp slt i64 %2509, 0
  br i1 %2511, label %2512, label %2517

; <label>:2512:                                   ; preds = %2508
  %2513 = icmp slt i64 %2509, -63
  %2514 = sub nsw i64 0, %2509
  %2515 = lshr i64 %2510, %2514
  %2516 = select i1 %2513, i64 0, i64 %2515
  br label %2521

; <label>:2517:                                   ; preds = %2508
  %2518 = icmp sgt i64 %2509, 63
  %2519 = shl i64 %2510, %2509
  %2520 = select i1 %2518, i64 0, i64 %2519
  br label %2521

; <label>:2521:                                   ; preds = %2517, %2512
  %2522 = phi i64 [ %2516, %2512 ], [ %2520, %2517 ]
  %2523 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2522, i64* %2523, align 8, !tbaa !21
  %2524 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2524, align 8, !tbaa !22
  br label %2529

; <label>:2525:                                   ; preds = %2485, %2502, %2497
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2526 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2526, i64* %35, align 8, !tbaa !20
  %2527 = sext i32 %2491 to i64
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %85) #7
  store i64 %2527, i64* %86, align 8, !tbaa !21
  store i8 35, i8* %87, align 8, !tbaa !22
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %8, %struct.TValue* nonnull %2489, %union.StackValue* %4314, i32 16) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %85) #7
  %2528 = load i32, i32* %38, align 8, !tbaa !21
  br label %2529

; <label>:2529:                                   ; preds = %2525, %2521
  %2530 = phi i32 [ %4309, %2521 ], [ %2528, %2525 ]
  %2531 = icmp eq i32 %2530, 0
  br i1 %2531, label %2536, label %2532

; <label>:2532:                                   ; preds = %2529
  %2533 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2534 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2535 = getelementptr inbounds %union.StackValue, %union.StackValue* %2534, i64 1
  br label %2536

; <label>:2536:                                   ; preds = %2529, %2532
  %2537 = phi i32 [ %2533, %2532 ], [ 0, %2529 ]
  %2538 = phi %union.StackValue* [ %2535, %2532 ], [ %4308, %2529 ]
  %2539 = getelementptr inbounds i32, i32* %4310, i64 1
  %2540 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2541:                                   ; preds = %4306
  %2542 = lshr i32 %4307, 16
  %2543 = and i32 %2542, 255
  %2544 = zext i32 %2543 to i64
  %2545 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2544, i32 0
  %2546 = lshr i32 %4307, 24
  %2547 = zext i32 %2546 to i64
  %2548 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2547, i32 0
  %2549 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2544, i32 0, i32 1
  %2550 = load i8, i8* %2549, align 8, !tbaa !22
  switch i8 %2550, label %2599 [
    i8 35, label %2551
    i8 19, label %2554
  ]

; <label>:2551:                                   ; preds = %2541
  %2552 = bitcast %struct.TValue* %2545 to i64*
  %2553 = load i64, i64* %2552, align 8, !tbaa !21
  br label %2565

; <label>:2554:                                   ; preds = %2541
  %2555 = bitcast %struct.TValue* %2545 to double*
  %2556 = load double, double* %2555, align 8, !tbaa !21
  %2557 = call double @llvm.floor.f64(double %2556) #7
  %2558 = fcmp une double %2557, %2556
  br i1 %2558, label %2599, label %2559

; <label>:2559:                                   ; preds = %2554
  %2560 = fcmp oge double %2557, 0xC3E0000000000000
  %2561 = fcmp olt double %2557, 0x43E0000000000000
  %2562 = and i1 %2560, %2561
  br i1 %2562, label %2563, label %2599

; <label>:2563:                                   ; preds = %2559
  %2564 = fptosi double %2557 to i64
  br label %2565

; <label>:2565:                                   ; preds = %2563, %2551
  %2566 = phi i64 [ %2553, %2551 ], [ %2564, %2563 ]
  %2567 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2547, i32 0, i32 1
  %2568 = load i8, i8* %2567, align 8, !tbaa !22
  switch i8 %2568, label %2599 [
    i8 35, label %2569
    i8 19, label %2572
  ]

; <label>:2569:                                   ; preds = %2565
  %2570 = bitcast %struct.TValue* %2548 to i64*
  %2571 = load i64, i64* %2570, align 8, !tbaa !21
  br label %2583

; <label>:2572:                                   ; preds = %2565
  %2573 = bitcast %struct.TValue* %2548 to double*
  %2574 = load double, double* %2573, align 8, !tbaa !21
  %2575 = call double @llvm.floor.f64(double %2574) #7
  %2576 = fcmp une double %2575, %2574
  br i1 %2576, label %2599, label %2577

; <label>:2577:                                   ; preds = %2572
  %2578 = fcmp oge double %2575, 0xC3E0000000000000
  %2579 = fcmp olt double %2575, 0x43E0000000000000
  %2580 = and i1 %2578, %2579
  br i1 %2580, label %2581, label %2599

; <label>:2581:                                   ; preds = %2577
  %2582 = fptosi double %2575 to i64
  br label %2583

; <label>:2583:                                   ; preds = %2581, %2569
  %2584 = phi i64 [ %2571, %2569 ], [ %2582, %2581 ]
  %2585 = icmp sgt i64 %2584, 0
  br i1 %2585, label %2586, label %2590

; <label>:2586:                                   ; preds = %2583
  %2587 = icmp sgt i64 %2584, 63
  %2588 = lshr i64 %2566, %2584
  %2589 = select i1 %2587, i64 0, i64 %2588
  br label %2595

; <label>:2590:                                   ; preds = %2583
  %2591 = sub nsw i64 0, %2584
  %2592 = icmp slt i64 %2584, -63
  %2593 = shl i64 %2566, %2591
  %2594 = select i1 %2592, i64 0, i64 %2593
  br label %2595

; <label>:2595:                                   ; preds = %2590, %2586
  %2596 = phi i64 [ %2589, %2586 ], [ %2594, %2590 ]
  %2597 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2596, i64* %2597, align 8, !tbaa !21
  %2598 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2598, align 8, !tbaa !22
  br label %2602

; <label>:2599:                                   ; preds = %2565, %2541, %2572, %2577, %2554, %2559
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2600 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2600, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2545, %struct.TValue* nonnull %2548, %union.StackValue* %4314, i32 17) #16
  %2601 = load i32, i32* %38, align 8, !tbaa !21
  br label %2602

; <label>:2602:                                   ; preds = %2599, %2595
  %2603 = phi i32 [ %4309, %2595 ], [ %2601, %2599 ]
  %2604 = icmp eq i32 %2603, 0
  br i1 %2604, label %2609, label %2605

; <label>:2605:                                   ; preds = %2602
  %2606 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2607 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2608 = getelementptr inbounds %union.StackValue, %union.StackValue* %2607, i64 1
  br label %2609

; <label>:2609:                                   ; preds = %2602, %2605
  %2610 = phi i32 [ %2606, %2605 ], [ 0, %2602 ]
  %2611 = phi %union.StackValue* [ %2608, %2605 ], [ %4308, %2602 ]
  %2612 = getelementptr inbounds i32, i32* %4310, i64 1
  %2613 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2614:                                   ; preds = %4306
  %2615 = lshr i32 %4307, 16
  %2616 = and i32 %2615, 255
  %2617 = zext i32 %2616 to i64
  %2618 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2617, i32 0
  %2619 = lshr i32 %4307, 24
  %2620 = zext i32 %2619 to i64
  %2621 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2620, i32 0
  %2622 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2617, i32 0, i32 1
  %2623 = load i8, i8* %2622, align 8, !tbaa !22
  switch i8 %2623, label %2672 [
    i8 35, label %2624
    i8 19, label %2627
  ]

; <label>:2624:                                   ; preds = %2614
  %2625 = bitcast %struct.TValue* %2618 to i64*
  %2626 = load i64, i64* %2625, align 8, !tbaa !21
  br label %2638

; <label>:2627:                                   ; preds = %2614
  %2628 = bitcast %struct.TValue* %2618 to double*
  %2629 = load double, double* %2628, align 8, !tbaa !21
  %2630 = call double @llvm.floor.f64(double %2629) #7
  %2631 = fcmp une double %2630, %2629
  br i1 %2631, label %2672, label %2632

; <label>:2632:                                   ; preds = %2627
  %2633 = fcmp oge double %2630, 0xC3E0000000000000
  %2634 = fcmp olt double %2630, 0x43E0000000000000
  %2635 = and i1 %2633, %2634
  br i1 %2635, label %2636, label %2672

; <label>:2636:                                   ; preds = %2632
  %2637 = fptosi double %2630 to i64
  br label %2638

; <label>:2638:                                   ; preds = %2636, %2624
  %2639 = phi i64 [ %2626, %2624 ], [ %2637, %2636 ]
  %2640 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2620, i32 0, i32 1
  %2641 = load i8, i8* %2640, align 8, !tbaa !22
  switch i8 %2641, label %2672 [
    i8 35, label %2642
    i8 19, label %2645
  ]

; <label>:2642:                                   ; preds = %2638
  %2643 = bitcast %struct.TValue* %2621 to i64*
  %2644 = load i64, i64* %2643, align 8, !tbaa !21
  br label %2656

; <label>:2645:                                   ; preds = %2638
  %2646 = bitcast %struct.TValue* %2621 to double*
  %2647 = load double, double* %2646, align 8, !tbaa !21
  %2648 = call double @llvm.floor.f64(double %2647) #7
  %2649 = fcmp une double %2648, %2647
  br i1 %2649, label %2672, label %2650

; <label>:2650:                                   ; preds = %2645
  %2651 = fcmp oge double %2648, 0xC3E0000000000000
  %2652 = fcmp olt double %2648, 0x43E0000000000000
  %2653 = and i1 %2651, %2652
  br i1 %2653, label %2654, label %2672

; <label>:2654:                                   ; preds = %2650
  %2655 = fptosi double %2648 to i64
  br label %2656

; <label>:2656:                                   ; preds = %2654, %2642
  %2657 = phi i64 [ %2644, %2642 ], [ %2655, %2654 ]
  %2658 = icmp slt i64 %2657, 0
  br i1 %2658, label %2659, label %2664

; <label>:2659:                                   ; preds = %2656
  %2660 = icmp slt i64 %2657, -63
  %2661 = sub nsw i64 0, %2657
  %2662 = lshr i64 %2639, %2661
  %2663 = select i1 %2660, i64 0, i64 %2662
  br label %2668

; <label>:2664:                                   ; preds = %2656
  %2665 = icmp sgt i64 %2657, 63
  %2666 = shl i64 %2639, %2657
  %2667 = select i1 %2665, i64 0, i64 %2666
  br label %2668

; <label>:2668:                                   ; preds = %2664, %2659
  %2669 = phi i64 [ %2663, %2659 ], [ %2667, %2664 ]
  %2670 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2669, i64* %2670, align 8, !tbaa !21
  %2671 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2671, align 8, !tbaa !22
  br label %2675

; <label>:2672:                                   ; preds = %2638, %2614, %2645, %2650, %2627, %2632
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2673 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2673, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2618, %struct.TValue* nonnull %2621, %union.StackValue* %4314, i32 16) #16
  %2674 = load i32, i32* %38, align 8, !tbaa !21
  br label %2675

; <label>:2675:                                   ; preds = %2672, %2668
  %2676 = phi i32 [ %4309, %2668 ], [ %2674, %2672 ]
  %2677 = icmp eq i32 %2676, 0
  br i1 %2677, label %2682, label %2678

; <label>:2678:                                   ; preds = %2675
  %2679 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2680 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2681 = getelementptr inbounds %union.StackValue, %union.StackValue* %2680, i64 1
  br label %2682

; <label>:2682:                                   ; preds = %2675, %2678
  %2683 = phi i32 [ %2679, %2678 ], [ 0, %2675 ]
  %2684 = phi %union.StackValue* [ %2681, %2678 ], [ %4308, %2675 ]
  %2685 = getelementptr inbounds i32, i32* %4310, i64 1
  %2686 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2687:                                   ; preds = %4306
  %2688 = lshr i32 %4307, 16
  %2689 = and i32 %2688, 255
  %2690 = zext i32 %2689 to i64
  %2691 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2690, i32 0
  %2692 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2690, i32 0, i32 1
  %2693 = load i8, i8* %2692, align 8, !tbaa !22
  switch i8 %2693, label %2706 [
    i8 35, label %2694
    i8 19, label %2700
  ]

; <label>:2694:                                   ; preds = %2687
  %2695 = bitcast %struct.TValue* %2691 to i64*
  %2696 = load i64, i64* %2695, align 8, !tbaa !21
  %2697 = sub i64 0, %2696
  %2698 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2697, i64* %2698, align 8, !tbaa !21
  %2699 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2699, align 8, !tbaa !22
  br label %2709

; <label>:2700:                                   ; preds = %2687
  %2701 = bitcast %struct.TValue* %2691 to double*
  %2702 = load double, double* %2701, align 8, !tbaa !21
  %2703 = fsub double -0.000000e+00, %2702
  %2704 = bitcast %union.StackValue* %4314 to double*
  store double %2703, double* %2704, align 8, !tbaa !21
  %2705 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 19, i8* %2705, align 8, !tbaa !22
  br label %2709

; <label>:2706:                                   ; preds = %2687
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2707 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2707, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2691, %struct.TValue* %2691, %union.StackValue* %4314, i32 18) #16
  %2708 = load i32, i32* %38, align 8, !tbaa !21
  br label %2709

; <label>:2709:                                   ; preds = %2700, %2706, %2694
  %2710 = phi i32 [ %4309, %2694 ], [ %4309, %2700 ], [ %2708, %2706 ]
  %2711 = icmp eq i32 %2710, 0
  br i1 %2711, label %2716, label %2712

; <label>:2712:                                   ; preds = %2709
  %2713 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2714 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2715 = getelementptr inbounds %union.StackValue, %union.StackValue* %2714, i64 1
  br label %2716

; <label>:2716:                                   ; preds = %2709, %2712
  %2717 = phi i32 [ %2713, %2712 ], [ 0, %2709 ]
  %2718 = phi %union.StackValue* [ %2715, %2712 ], [ %4308, %2709 ]
  %2719 = getelementptr inbounds i32, i32* %4310, i64 1
  %2720 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2721:                                   ; preds = %4306
  %2722 = lshr i32 %4307, 16
  %2723 = and i32 %2722, 255
  %2724 = zext i32 %2723 to i64
  %2725 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2724, i32 0
  %2726 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2724, i32 0, i32 1
  %2727 = load i8, i8* %2726, align 8, !tbaa !22
  switch i8 %2727, label %2747 [
    i8 35, label %2728
    i8 19, label %2731
  ]

; <label>:2728:                                   ; preds = %2721
  %2729 = bitcast %struct.TValue* %2725 to i64*
  %2730 = load i64, i64* %2729, align 8, !tbaa !21
  br label %2742

; <label>:2731:                                   ; preds = %2721
  %2732 = bitcast %struct.TValue* %2725 to double*
  %2733 = load double, double* %2732, align 8, !tbaa !21
  %2734 = call double @llvm.floor.f64(double %2733) #7
  %2735 = fcmp une double %2734, %2733
  br i1 %2735, label %2747, label %2736

; <label>:2736:                                   ; preds = %2731
  %2737 = fcmp oge double %2734, 0xC3E0000000000000
  %2738 = fcmp olt double %2734, 0x43E0000000000000
  %2739 = and i1 %2737, %2738
  br i1 %2739, label %2740, label %2747

; <label>:2740:                                   ; preds = %2736
  %2741 = fptosi double %2734 to i64
  br label %2742

; <label>:2742:                                   ; preds = %2740, %2728
  %2743 = phi i64 [ %2730, %2728 ], [ %2741, %2740 ]
  %2744 = xor i64 %2743, -1
  %2745 = bitcast %union.StackValue* %4314 to i64*
  store i64 %2744, i64* %2745, align 8, !tbaa !21
  %2746 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 35, i8* %2746, align 8, !tbaa !22
  br label %2750

; <label>:2747:                                   ; preds = %2721, %2736, %2731
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2748 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2748, i64* %35, align 8, !tbaa !20
  call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* nonnull %2725, %struct.TValue* nonnull %2725, %union.StackValue* %4314, i32 19) #16
  %2749 = load i32, i32* %38, align 8, !tbaa !21
  br label %2750

; <label>:2750:                                   ; preds = %2747, %2742
  %2751 = phi i32 [ %4309, %2742 ], [ %2749, %2747 ]
  %2752 = icmp eq i32 %2751, 0
  br i1 %2752, label %2757, label %2753

; <label>:2753:                                   ; preds = %2750
  %2754 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2755 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2756 = getelementptr inbounds %union.StackValue, %union.StackValue* %2755, i64 1
  br label %2757

; <label>:2757:                                   ; preds = %2750, %2753
  %2758 = phi i32 [ %2754, %2753 ], [ 0, %2750 ]
  %2759 = phi %union.StackValue* [ %2756, %2753 ], [ %4308, %2750 ]
  %2760 = getelementptr inbounds i32, i32* %4310, i64 1
  %2761 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2762:                                   ; preds = %4306
  %2763 = lshr i32 %4307, 16
  %2764 = and i32 %2763, 255
  %2765 = zext i32 %2764 to i64
  %2766 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2765, i32 0, i32 1
  %2767 = load i8, i8* %2766, align 8, !tbaa !22
  %2768 = and i8 %2767, 15
  %2769 = icmp eq i8 %2768, 0
  br i1 %2769, label %2777, label %2770

; <label>:2770:                                   ; preds = %2762
  %2771 = icmp eq i8 %2767, 1
  br i1 %2771, label %2772, label %2777

; <label>:2772:                                   ; preds = %2770
  %2773 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2765, i32 0, i32 0
  %2774 = bitcast %union.Value* %2773 to i32*
  %2775 = load i32, i32* %2774, align 8, !tbaa !21
  %2776 = icmp eq i32 %2775, 0
  br label %2777

; <label>:2777:                                   ; preds = %2770, %2772, %2762
  %2778 = phi i1 [ true, %2762 ], [ false, %2770 ], [ %2776, %2772 ]
  %2779 = zext i1 %2778 to i32
  %2780 = bitcast %union.StackValue* %4314 to i32*
  store i32 %2779, i32* %2780, align 8, !tbaa !21
  %2781 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 1, i8* %2781, align 8, !tbaa !22
  %2782 = icmp eq i32 %4309, 0
  br i1 %2782, label %2787, label %2783

; <label>:2783:                                   ; preds = %2777
  %2784 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2785 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2786 = getelementptr inbounds %union.StackValue, %union.StackValue* %2785, i64 1
  br label %2787

; <label>:2787:                                   ; preds = %2777, %2783
  %2788 = phi i32 [ %2784, %2783 ], [ 0, %2777 ]
  %2789 = phi %union.StackValue* [ %2786, %2783 ], [ %4308, %2777 ]
  %2790 = getelementptr inbounds i32, i32* %4310, i64 1
  %2791 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2792:                                   ; preds = %4306
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2793 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2793, i64* %35, align 8, !tbaa !20
  %2794 = lshr i32 %4307, 16
  %2795 = and i32 %2794, 255
  %2796 = zext i32 %2795 to i64
  %2797 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2796, i32 0
  call fastcc void @luaV_objlen(%struct.lua_State* %0, %union.StackValue* %4314, %struct.TValue* %2797) #16
  %2798 = load i32, i32* %38, align 8, !tbaa !21
  %2799 = icmp eq i32 %2798, 0
  br i1 %2799, label %2804, label %2800

; <label>:2800:                                   ; preds = %2792
  %2801 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4310) #16
  %2802 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2803 = getelementptr inbounds %union.StackValue, %union.StackValue* %2802, i64 1
  br label %2804

; <label>:2804:                                   ; preds = %2792, %2800
  %2805 = phi i32 [ %2801, %2800 ], [ 0, %2792 ]
  %2806 = phi %union.StackValue* [ %2803, %2800 ], [ %4308, %2792 ]
  %2807 = getelementptr inbounds i32, i32* %4310, i64 1
  %2808 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2809:                                   ; preds = %4306
  %2810 = lshr i32 %4307, 16
  %2811 = and i32 %2810, 255
  %2812 = zext i32 %2811 to i64
  %2813 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %2812
  store %union.StackValue* %2813, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaV_concat(%struct.lua_State* %0, i32 %2811) #16
  %2814 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %2815 = getelementptr inbounds %struct.global_State, %struct.global_State* %2814, i64 0, i32 3
  %2816 = load i64, i64* %2815, align 8, !tbaa !11
  %2817 = icmp sgt i64 %2816, 0
  br i1 %2817, label %2818, label %2819

; <label>:2818:                                   ; preds = %2809
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  br label %2819

; <label>:2819:                                   ; preds = %2818, %2809
  %2820 = load i32, i32* %38, align 8, !tbaa !21
  %2821 = icmp eq i32 %2820, 0
  br i1 %2821, label %2826, label %2822

; <label>:2822:                                   ; preds = %2819
  %2823 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4310) #16
  %2824 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2825 = getelementptr inbounds %union.StackValue, %union.StackValue* %2824, i64 1
  br label %2826

; <label>:2826:                                   ; preds = %2819, %2822
  %2827 = phi i32 [ %2823, %2822 ], [ 0, %2819 ]
  %2828 = phi %union.StackValue* [ %2825, %2822 ], [ %4308, %2819 ]
  %2829 = getelementptr inbounds i32, i32* %4310, i64 1
  %2830 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2831:                                   ; preds = %4306
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2832 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2832, i64* %35, align 8, !tbaa !20
  %2833 = call fastcc i32 @luaF_close(%struct.lua_State* %0, %union.StackValue* %4314, i32 0) #16
  %2834 = load i32, i32* %38, align 8, !tbaa !21
  %2835 = icmp eq i32 %2834, 0
  br i1 %2835, label %2840, label %2836

; <label>:2836:                                   ; preds = %2831
  %2837 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %4310) #16
  %2838 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2839 = getelementptr inbounds %union.StackValue, %union.StackValue* %2838, i64 1
  br label %2840

; <label>:2840:                                   ; preds = %2831, %2836
  %2841 = phi i32 [ %2837, %2836 ], [ 0, %2831 ]
  %2842 = phi %union.StackValue* [ %2839, %2836 ], [ %4308, %2831 ]
  %2843 = getelementptr inbounds i32, i32* %4310, i64 1
  %2844 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2845:                                   ; preds = %4306
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* %4314) #16
  %2846 = icmp eq i32 %4309, 0
  br i1 %2846, label %2851, label %2847

; <label>:2847:                                   ; preds = %2845
  %2848 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %2849 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2850 = getelementptr inbounds %union.StackValue, %union.StackValue* %2849, i64 1
  br label %2851

; <label>:2851:                                   ; preds = %2845, %2847
  %2852 = phi i32 [ %2848, %2847 ], [ 0, %2845 ]
  %2853 = phi %union.StackValue* [ %2850, %2847 ], [ %4308, %2845 ]
  %2854 = getelementptr inbounds i32, i32* %4310, i64 1
  %2855 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:2856:                                   ; preds = %4306
  %2857 = lshr i32 %4307, 7
  %2858 = add nsw i32 %2857, -16777215
  %2859 = sext i32 %2858 to i64
  %2860 = getelementptr inbounds i32, i32* %4310, i64 %2859
  %2861 = load i32, i32* %38, align 8, !tbaa !21
  %2862 = icmp eq i32 %2861, 0
  br i1 %2862, label %2867, label %2863

; <label>:2863:                                   ; preds = %2856
  %2864 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2860) #16
  %2865 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2866 = getelementptr inbounds %union.StackValue, %union.StackValue* %2865, i64 1
  br label %2867

; <label>:2867:                                   ; preds = %2856, %2863
  %2868 = phi i32 [ %2864, %2863 ], [ 0, %2856 ]
  %2869 = phi %union.StackValue* [ %2866, %2863 ], [ %4308, %2856 ]
  %2870 = getelementptr inbounds i32, i32* %2860, i64 1
  %2871 = load i32, i32* %2860, align 4, !tbaa !77
  br label %162

; <label>:2872:                                   ; preds = %4306
  %2873 = lshr i32 %4307, 16
  %2874 = and i32 %2873, 255
  %2875 = zext i32 %2874 to i64
  %2876 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2875, i32 0
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2877 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2877, i64* %35, align 8, !tbaa !20
  %2878 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %2879 = call fastcc i32 @luaV_equalobj(%struct.lua_State* %0, %struct.TValue* %2878, %struct.TValue* %2876) #16
  %2880 = load i32, i32* %38, align 8, !tbaa !21
  %2881 = lshr i32 %4307, 15
  %2882 = and i32 %2881, 1
  %2883 = icmp eq i32 %2879, %2882
  br i1 %2883, label %2884, label %2889

; <label>:2884:                                   ; preds = %2872
  %2885 = load i32, i32* %4310, align 4, !tbaa !77
  %2886 = lshr i32 %2885, 7
  %2887 = add nsw i32 %2886, -16777214
  %2888 = sext i32 %2887 to i64
  br label %2889

; <label>:2889:                                   ; preds = %2872, %2884
  %2890 = phi i64 [ %2888, %2884 ], [ 1, %2872 ]
  %2891 = getelementptr inbounds i32, i32* %4310, i64 %2890
  %2892 = icmp eq i32 %2880, 0
  br i1 %2892, label %2897, label %2893

; <label>:2893:                                   ; preds = %2889
  %2894 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %2891) #16
  %2895 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2896 = getelementptr inbounds %union.StackValue, %union.StackValue* %2895, i64 1
  br label %2897

; <label>:2897:                                   ; preds = %2889, %2893
  %2898 = phi i32 [ %2894, %2893 ], [ 0, %2889 ]
  %2899 = phi %union.StackValue* [ %2896, %2893 ], [ %4308, %2889 ]
  %2900 = getelementptr inbounds i32, i32* %2891, i64 1
  %2901 = load i32, i32* %2891, align 4, !tbaa !77
  br label %162

; <label>:2902:                                   ; preds = %4306
  %2903 = lshr i32 %4307, 16
  %2904 = and i32 %2903, 255
  %2905 = zext i32 %2904 to i64
  %2906 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2905, i32 0
  %2907 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %2908 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %2909 = load i8, i8* %2908, align 8, !tbaa !21
  %2910 = icmp eq i8 %2909, 35
  br i1 %2910, label %2911, label %2922

; <label>:2911:                                   ; preds = %2902
  %2912 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2905, i32 0, i32 1
  %2913 = load i8, i8* %2912, align 8, !tbaa !22
  %2914 = icmp eq i8 %2913, 35
  br i1 %2914, label %2915, label %2928

; <label>:2915:                                   ; preds = %2911
  %2916 = bitcast %union.StackValue* %4314 to i64*
  %2917 = load i64, i64* %2916, align 8, !tbaa !21
  %2918 = bitcast %struct.TValue* %2906 to i64*
  %2919 = load i64, i64* %2918, align 8, !tbaa !21
  %2920 = icmp slt i64 %2917, %2919
  %2921 = zext i1 %2920 to i32
  br label %2938

; <label>:2922:                                   ; preds = %2902
  %2923 = and i8 %2909, 15
  %2924 = icmp eq i8 %2923, 3
  br i1 %2924, label %2925, label %2934

; <label>:2925:                                   ; preds = %2922
  %2926 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2905, i32 0, i32 1
  %2927 = load i8, i8* %2926, align 8, !tbaa !22
  br label %2928

; <label>:2928:                                   ; preds = %2925, %2911
  %2929 = phi i8 [ %2927, %2925 ], [ %2913, %2911 ]
  %2930 = and i8 %2929, 15
  %2931 = icmp eq i8 %2930, 3
  br i1 %2931, label %2932, label %2934

; <label>:2932:                                   ; preds = %2928
  %2933 = call fastcc i32 @LTnum(%struct.TValue* %2907, %struct.TValue* nonnull %2906) #16
  br label %2938

; <label>:2934:                                   ; preds = %2928, %2922
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2935 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2935, i64* %35, align 8, !tbaa !20
  %2936 = call fastcc i32 @lessthanothers(%struct.lua_State* %0, %struct.TValue* %2907, %struct.TValue* %2906) #16
  %2937 = load i32, i32* %38, align 8, !tbaa !21
  br label %2938

; <label>:2938:                                   ; preds = %2932, %2934, %2915
  %2939 = phi i32 [ %2921, %2915 ], [ %2933, %2932 ], [ %2936, %2934 ]
  %2940 = phi i32 [ %4309, %2915 ], [ %4309, %2932 ], [ %2937, %2934 ]
  %2941 = lshr i32 %4307, 15
  %2942 = and i32 %2941, 1
  %2943 = icmp eq i32 %2939, %2942
  br i1 %2943, label %2946, label %2944

; <label>:2944:                                   ; preds = %2938
  %2945 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %2953

; <label>:2946:                                   ; preds = %2938
  %2947 = load i32, i32* %4310, align 4, !tbaa !77
  %2948 = lshr i32 %2947, 7
  %2949 = add nsw i32 %2948, -16777214
  %2950 = sext i32 %2949 to i64
  %2951 = getelementptr inbounds i32, i32* %4310, i64 %2950
  %2952 = load i32, i32* %38, align 8, !tbaa !21
  br label %2953

; <label>:2953:                                   ; preds = %2946, %2944
  %2954 = phi i32 [ %2940, %2944 ], [ %2952, %2946 ]
  %2955 = phi i32* [ %2945, %2944 ], [ %2951, %2946 ]
  %2956 = icmp eq i32 %2954, 0
  br i1 %2956, label %2961, label %2957

; <label>:2957:                                   ; preds = %2953
  %2958 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %2955) #16
  %2959 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %2960 = getelementptr inbounds %union.StackValue, %union.StackValue* %2959, i64 1
  br label %2961

; <label>:2961:                                   ; preds = %2953, %2957
  %2962 = phi i32 [ %2958, %2957 ], [ 0, %2953 ]
  %2963 = phi %union.StackValue* [ %2960, %2957 ], [ %4308, %2953 ]
  %2964 = getelementptr inbounds i32, i32* %2955, i64 1
  %2965 = load i32, i32* %2955, align 4, !tbaa !77
  br label %162

; <label>:2966:                                   ; preds = %4306
  %2967 = lshr i32 %4307, 16
  %2968 = and i32 %2967, 255
  %2969 = zext i32 %2968 to i64
  %2970 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2969, i32 0
  %2971 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %2972 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %2973 = load i8, i8* %2972, align 8, !tbaa !21
  %2974 = icmp eq i8 %2973, 35
  br i1 %2974, label %2975, label %2986

; <label>:2975:                                   ; preds = %2966
  %2976 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2969, i32 0, i32 1
  %2977 = load i8, i8* %2976, align 8, !tbaa !22
  %2978 = icmp eq i8 %2977, 35
  br i1 %2978, label %2979, label %2992

; <label>:2979:                                   ; preds = %2975
  %2980 = bitcast %union.StackValue* %4314 to i64*
  %2981 = load i64, i64* %2980, align 8, !tbaa !21
  %2982 = bitcast %struct.TValue* %2970 to i64*
  %2983 = load i64, i64* %2982, align 8, !tbaa !21
  %2984 = icmp sle i64 %2981, %2983
  %2985 = zext i1 %2984 to i32
  br label %3002

; <label>:2986:                                   ; preds = %2966
  %2987 = and i8 %2973, 15
  %2988 = icmp eq i8 %2987, 3
  br i1 %2988, label %2989, label %2998

; <label>:2989:                                   ; preds = %2986
  %2990 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %2969, i32 0, i32 1
  %2991 = load i8, i8* %2990, align 8, !tbaa !22
  br label %2992

; <label>:2992:                                   ; preds = %2989, %2975
  %2993 = phi i8 [ %2991, %2989 ], [ %2977, %2975 ]
  %2994 = and i8 %2993, 15
  %2995 = icmp eq i8 %2994, 3
  br i1 %2995, label %2996, label %2998

; <label>:2996:                                   ; preds = %2992
  %2997 = call fastcc i32 @LEnum(%struct.TValue* %2971, %struct.TValue* nonnull %2970) #16
  br label %3002

; <label>:2998:                                   ; preds = %2992, %2986
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %2999 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %2999, i64* %35, align 8, !tbaa !20
  %3000 = call fastcc i32 @lessequalothers(%struct.lua_State* %0, %struct.TValue* %2971, %struct.TValue* %2970) #16
  %3001 = load i32, i32* %38, align 8, !tbaa !21
  br label %3002

; <label>:3002:                                   ; preds = %2996, %2998, %2979
  %3003 = phi i32 [ %2985, %2979 ], [ %2997, %2996 ], [ %3000, %2998 ]
  %3004 = phi i32 [ %4309, %2979 ], [ %4309, %2996 ], [ %3001, %2998 ]
  %3005 = lshr i32 %4307, 15
  %3006 = and i32 %3005, 1
  %3007 = icmp eq i32 %3003, %3006
  br i1 %3007, label %3010, label %3008

; <label>:3008:                                   ; preds = %3002
  %3009 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3017

; <label>:3010:                                   ; preds = %3002
  %3011 = load i32, i32* %4310, align 4, !tbaa !77
  %3012 = lshr i32 %3011, 7
  %3013 = add nsw i32 %3012, -16777214
  %3014 = sext i32 %3013 to i64
  %3015 = getelementptr inbounds i32, i32* %4310, i64 %3014
  %3016 = load i32, i32* %38, align 8, !tbaa !21
  br label %3017

; <label>:3017:                                   ; preds = %3010, %3008
  %3018 = phi i32 [ %3004, %3008 ], [ %3016, %3010 ]
  %3019 = phi i32* [ %3009, %3008 ], [ %3015, %3010 ]
  %3020 = icmp eq i32 %3018, 0
  br i1 %3020, label %3025, label %3021

; <label>:3021:                                   ; preds = %3017
  %3022 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3019) #16
  %3023 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3024 = getelementptr inbounds %union.StackValue, %union.StackValue* %3023, i64 1
  br label %3025

; <label>:3025:                                   ; preds = %3017, %3021
  %3026 = phi i32 [ %3022, %3021 ], [ 0, %3017 ]
  %3027 = phi %union.StackValue* [ %3024, %3021 ], [ %4308, %3017 ]
  %3028 = getelementptr inbounds i32, i32* %3019, i64 1
  %3029 = load i32, i32* %3019, align 4, !tbaa !77
  br label %162

; <label>:3030:                                   ; preds = %4306
  %3031 = lshr i32 %4307, 16
  %3032 = and i32 %3031, 255
  %3033 = zext i32 %3032 to i64
  %3034 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 %3033
  %3035 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3036 = call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %3035, %struct.TValue* %3034) #16
  %3037 = lshr i32 %4307, 15
  %3038 = and i32 %3037, 1
  %3039 = icmp eq i32 %3036, %3038
  br i1 %3039, label %3042, label %3040

; <label>:3040:                                   ; preds = %3030
  %3041 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3049

; <label>:3042:                                   ; preds = %3030
  %3043 = load i32, i32* %4310, align 4, !tbaa !77
  %3044 = lshr i32 %3043, 7
  %3045 = add nsw i32 %3044, -16777214
  %3046 = sext i32 %3045 to i64
  %3047 = getelementptr inbounds i32, i32* %4310, i64 %3046
  %3048 = load i32, i32* %38, align 8, !tbaa !21
  br label %3049

; <label>:3049:                                   ; preds = %3042, %3040
  %3050 = phi i32 [ %4309, %3040 ], [ %3048, %3042 ]
  %3051 = phi i32* [ %3041, %3040 ], [ %3047, %3042 ]
  %3052 = icmp eq i32 %3050, 0
  br i1 %3052, label %3057, label %3053

; <label>:3053:                                   ; preds = %3049
  %3054 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3051) #16
  %3055 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3056 = getelementptr inbounds %union.StackValue, %union.StackValue* %3055, i64 1
  br label %3057

; <label>:3057:                                   ; preds = %3049, %3053
  %3058 = phi i32 [ %3054, %3053 ], [ 0, %3049 ]
  %3059 = phi %union.StackValue* [ %3056, %3053 ], [ %4308, %3049 ]
  %3060 = getelementptr inbounds i32, i32* %3051, i64 1
  %3061 = load i32, i32* %3051, align 4, !tbaa !77
  br label %162

; <label>:3062:                                   ; preds = %4306
  %3063 = lshr i32 %4307, 16
  %3064 = and i32 %3063, 255
  %3065 = add nsw i32 %3064, -127
  %3066 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3067 = load i8, i8* %3066, align 8, !tbaa !21
  switch i8 %3067, label %3068 [
    i8 35, label %3071
    i8 19, label %3076
  ]

; <label>:3068:                                   ; preds = %3062
  %3069 = trunc i32 %4307 to i16
  %3070 = icmp slt i16 %3069, 0
  br i1 %3070, label %3086, label %3088

; <label>:3071:                                   ; preds = %3062
  %3072 = bitcast %union.StackValue* %4314 to i64*
  %3073 = load i64, i64* %3072, align 8, !tbaa !21
  %3074 = sext i32 %3065 to i64
  %3075 = icmp eq i64 %3073, %3074
  br label %3081

; <label>:3076:                                   ; preds = %3062
  %3077 = bitcast %union.StackValue* %4314 to double*
  %3078 = load double, double* %3077, align 8, !tbaa !21
  %3079 = sitofp i32 %3065 to double
  %3080 = fcmp oeq double %3078, %3079
  br label %3081

; <label>:3081:                                   ; preds = %3076, %3071
  %3082 = phi i1 [ %3075, %3071 ], [ %3080, %3076 ]
  %3083 = trunc i32 %4307 to i16
  %3084 = icmp slt i16 %3083, 0
  %3085 = xor i1 %3084, %3082
  br i1 %3085, label %3086, label %3088

; <label>:3086:                                   ; preds = %3068, %3081
  %3087 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3095

; <label>:3088:                                   ; preds = %3068, %3081
  %3089 = load i32, i32* %4310, align 4, !tbaa !77
  %3090 = lshr i32 %3089, 7
  %3091 = add nsw i32 %3090, -16777214
  %3092 = sext i32 %3091 to i64
  %3093 = getelementptr inbounds i32, i32* %4310, i64 %3092
  %3094 = load i32, i32* %38, align 8, !tbaa !21
  br label %3095

; <label>:3095:                                   ; preds = %3088, %3086
  %3096 = phi i32 [ %4309, %3086 ], [ %3094, %3088 ]
  %3097 = phi i32* [ %3087, %3086 ], [ %3093, %3088 ]
  %3098 = icmp eq i32 %3096, 0
  br i1 %3098, label %3103, label %3099

; <label>:3099:                                   ; preds = %3095
  %3100 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3097) #16
  %3101 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3102 = getelementptr inbounds %union.StackValue, %union.StackValue* %3101, i64 1
  br label %3103

; <label>:3103:                                   ; preds = %3095, %3099
  %3104 = phi i32 [ %3100, %3099 ], [ 0, %3095 ]
  %3105 = phi %union.StackValue* [ %3102, %3099 ], [ %4308, %3095 ]
  %3106 = getelementptr inbounds i32, i32* %3097, i64 1
  %3107 = load i32, i32* %3097, align 4, !tbaa !77
  br label %162

; <label>:3108:                                   ; preds = %4306
  %3109 = lshr i32 %4307, 16
  %3110 = and i32 %3109, 255
  %3111 = add nsw i32 %3110, -127
  %3112 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3113 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3114 = load i8, i8* %3113, align 8, !tbaa !21
  switch i8 %3114, label %3127 [
    i8 35, label %3115
    i8 19, label %3121
  ]

; <label>:3115:                                   ; preds = %3108
  %3116 = bitcast %union.StackValue* %4314 to i64*
  %3117 = load i64, i64* %3116, align 8, !tbaa !21
  %3118 = sext i32 %3111 to i64
  %3119 = icmp slt i64 %3117, %3118
  %3120 = zext i1 %3119 to i32
  br label %3138

; <label>:3121:                                   ; preds = %3108
  %3122 = bitcast %union.StackValue* %4314 to double*
  %3123 = load double, double* %3122, align 8, !tbaa !21
  %3124 = sitofp i32 %3111 to double
  %3125 = fcmp olt double %3123, %3124
  %3126 = zext i1 %3125 to i32
  br label %3138

; <label>:3127:                                   ; preds = %3108
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3128 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3128, i64* %35, align 8, !tbaa !20
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %68) #7
  %3129 = icmp ult i32 %4307, 16777216
  br i1 %3129, label %3132, label %3130

; <label>:3130:                                   ; preds = %3127
  %3131 = sitofp i32 %3111 to double
  store double %3131, double* %90, align 8, !tbaa !21
  br label %3134

; <label>:3132:                                   ; preds = %3127
  %3133 = sext i32 %3111 to i64
  store i64 %3133, i64* %88, align 8, !tbaa !21
  br label %3134

; <label>:3134:                                   ; preds = %3130, %3132
  %3135 = phi i8 [ 19, %3130 ], [ 35, %3132 ]
  store i8 %3135, i8* %89, align 8, !tbaa !22
  %3136 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* nonnull %0, %struct.TValue* %3112, %struct.TValue* nonnull %7, i32 20) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %68) #7
  %3137 = load i32, i32* %38, align 8, !tbaa !21
  br label %3138

; <label>:3138:                                   ; preds = %3121, %3134, %3115
  %3139 = phi i32 [ %3120, %3115 ], [ %3126, %3121 ], [ %3136, %3134 ]
  %3140 = phi i32 [ %4309, %3115 ], [ %4309, %3121 ], [ %3137, %3134 ]
  %3141 = lshr i32 %4307, 15
  %3142 = and i32 %3141, 1
  %3143 = icmp eq i32 %3139, %3142
  br i1 %3143, label %3146, label %3144

; <label>:3144:                                   ; preds = %3138
  %3145 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3153

; <label>:3146:                                   ; preds = %3138
  %3147 = load i32, i32* %4310, align 4, !tbaa !77
  %3148 = lshr i32 %3147, 7
  %3149 = add nsw i32 %3148, -16777214
  %3150 = sext i32 %3149 to i64
  %3151 = getelementptr inbounds i32, i32* %4310, i64 %3150
  %3152 = load i32, i32* %38, align 8, !tbaa !21
  br label %3153

; <label>:3153:                                   ; preds = %3146, %3144
  %3154 = phi i32 [ %3140, %3144 ], [ %3152, %3146 ]
  %3155 = phi i32* [ %3145, %3144 ], [ %3151, %3146 ]
  %3156 = icmp eq i32 %3154, 0
  br i1 %3156, label %3161, label %3157

; <label>:3157:                                   ; preds = %3153
  %3158 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3155) #16
  %3159 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3160 = getelementptr inbounds %union.StackValue, %union.StackValue* %3159, i64 1
  br label %3161

; <label>:3161:                                   ; preds = %3153, %3157
  %3162 = phi i32 [ %3158, %3157 ], [ 0, %3153 ]
  %3163 = phi %union.StackValue* [ %3160, %3157 ], [ %4308, %3153 ]
  %3164 = getelementptr inbounds i32, i32* %3155, i64 1
  %3165 = load i32, i32* %3155, align 4, !tbaa !77
  br label %162

; <label>:3166:                                   ; preds = %4306
  %3167 = lshr i32 %4307, 16
  %3168 = and i32 %3167, 255
  %3169 = add nsw i32 %3168, -127
  %3170 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3171 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3172 = load i8, i8* %3171, align 8, !tbaa !21
  switch i8 %3172, label %3185 [
    i8 35, label %3173
    i8 19, label %3179
  ]

; <label>:3173:                                   ; preds = %3166
  %3174 = bitcast %union.StackValue* %4314 to i64*
  %3175 = load i64, i64* %3174, align 8, !tbaa !21
  %3176 = sext i32 %3169 to i64
  %3177 = icmp sle i64 %3175, %3176
  %3178 = zext i1 %3177 to i32
  br label %3196

; <label>:3179:                                   ; preds = %3166
  %3180 = bitcast %union.StackValue* %4314 to double*
  %3181 = load double, double* %3180, align 8, !tbaa !21
  %3182 = sitofp i32 %3169 to double
  %3183 = fcmp ole double %3181, %3182
  %3184 = zext i1 %3183 to i32
  br label %3196

; <label>:3185:                                   ; preds = %3166
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3186 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3186, i64* %35, align 8, !tbaa !20
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %69) #7
  %3187 = icmp ult i32 %4307, 16777216
  br i1 %3187, label %3190, label %3188

; <label>:3188:                                   ; preds = %3185
  %3189 = sitofp i32 %3169 to double
  store double %3189, double* %93, align 8, !tbaa !21
  br label %3192

; <label>:3190:                                   ; preds = %3185
  %3191 = sext i32 %3169 to i64
  store i64 %3191, i64* %91, align 8, !tbaa !21
  br label %3192

; <label>:3192:                                   ; preds = %3188, %3190
  %3193 = phi i8 [ 19, %3188 ], [ 35, %3190 ]
  store i8 %3193, i8* %92, align 8, !tbaa !22
  %3194 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* nonnull %0, %struct.TValue* %3170, %struct.TValue* nonnull %6, i32 21) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %69) #7
  %3195 = load i32, i32* %38, align 8, !tbaa !21
  br label %3196

; <label>:3196:                                   ; preds = %3179, %3192, %3173
  %3197 = phi i32 [ %3178, %3173 ], [ %3184, %3179 ], [ %3194, %3192 ]
  %3198 = phi i32 [ %4309, %3173 ], [ %4309, %3179 ], [ %3195, %3192 ]
  %3199 = lshr i32 %4307, 15
  %3200 = and i32 %3199, 1
  %3201 = icmp eq i32 %3197, %3200
  br i1 %3201, label %3204, label %3202

; <label>:3202:                                   ; preds = %3196
  %3203 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3211

; <label>:3204:                                   ; preds = %3196
  %3205 = load i32, i32* %4310, align 4, !tbaa !77
  %3206 = lshr i32 %3205, 7
  %3207 = add nsw i32 %3206, -16777214
  %3208 = sext i32 %3207 to i64
  %3209 = getelementptr inbounds i32, i32* %4310, i64 %3208
  %3210 = load i32, i32* %38, align 8, !tbaa !21
  br label %3211

; <label>:3211:                                   ; preds = %3204, %3202
  %3212 = phi i32 [ %3198, %3202 ], [ %3210, %3204 ]
  %3213 = phi i32* [ %3203, %3202 ], [ %3209, %3204 ]
  %3214 = icmp eq i32 %3212, 0
  br i1 %3214, label %3219, label %3215

; <label>:3215:                                   ; preds = %3211
  %3216 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3213) #16
  %3217 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3218 = getelementptr inbounds %union.StackValue, %union.StackValue* %3217, i64 1
  br label %3219

; <label>:3219:                                   ; preds = %3211, %3215
  %3220 = phi i32 [ %3216, %3215 ], [ 0, %3211 ]
  %3221 = phi %union.StackValue* [ %3218, %3215 ], [ %4308, %3211 ]
  %3222 = getelementptr inbounds i32, i32* %3213, i64 1
  %3223 = load i32, i32* %3213, align 4, !tbaa !77
  br label %162

; <label>:3224:                                   ; preds = %4306
  %3225 = lshr i32 %4307, 16
  %3226 = and i32 %3225, 255
  %3227 = add nsw i32 %3226, -127
  %3228 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3229 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3230 = load i8, i8* %3229, align 8, !tbaa !21
  switch i8 %3230, label %3243 [
    i8 35, label %3231
    i8 19, label %3237
  ]

; <label>:3231:                                   ; preds = %3224
  %3232 = bitcast %union.StackValue* %4314 to i64*
  %3233 = load i64, i64* %3232, align 8, !tbaa !21
  %3234 = sext i32 %3227 to i64
  %3235 = icmp sgt i64 %3233, %3234
  %3236 = zext i1 %3235 to i32
  br label %3254

; <label>:3237:                                   ; preds = %3224
  %3238 = bitcast %union.StackValue* %4314 to double*
  %3239 = load double, double* %3238, align 8, !tbaa !21
  %3240 = sitofp i32 %3227 to double
  %3241 = fcmp ogt double %3239, %3240
  %3242 = zext i1 %3241 to i32
  br label %3254

; <label>:3243:                                   ; preds = %3224
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3244 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3244, i64* %35, align 8, !tbaa !20
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %70) #7
  %3245 = icmp ult i32 %4307, 16777216
  br i1 %3245, label %3248, label %3246

; <label>:3246:                                   ; preds = %3243
  %3247 = sitofp i32 %3227 to double
  store double %3247, double* %96, align 8, !tbaa !21
  br label %3250

; <label>:3248:                                   ; preds = %3243
  %3249 = sext i32 %3227 to i64
  store i64 %3249, i64* %94, align 8, !tbaa !21
  br label %3250

; <label>:3250:                                   ; preds = %3246, %3248
  %3251 = phi i8 [ 19, %3246 ], [ 35, %3248 ]
  store i8 %3251, i8* %95, align 8, !tbaa !22
  %3252 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %5, %struct.TValue* %3228, i32 20) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %70) #7
  %3253 = load i32, i32* %38, align 8, !tbaa !21
  br label %3254

; <label>:3254:                                   ; preds = %3237, %3250, %3231
  %3255 = phi i32 [ %3236, %3231 ], [ %3242, %3237 ], [ %3252, %3250 ]
  %3256 = phi i32 [ %4309, %3231 ], [ %4309, %3237 ], [ %3253, %3250 ]
  %3257 = lshr i32 %4307, 15
  %3258 = and i32 %3257, 1
  %3259 = icmp eq i32 %3255, %3258
  br i1 %3259, label %3262, label %3260

; <label>:3260:                                   ; preds = %3254
  %3261 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3269

; <label>:3262:                                   ; preds = %3254
  %3263 = load i32, i32* %4310, align 4, !tbaa !77
  %3264 = lshr i32 %3263, 7
  %3265 = add nsw i32 %3264, -16777214
  %3266 = sext i32 %3265 to i64
  %3267 = getelementptr inbounds i32, i32* %4310, i64 %3266
  %3268 = load i32, i32* %38, align 8, !tbaa !21
  br label %3269

; <label>:3269:                                   ; preds = %3262, %3260
  %3270 = phi i32 [ %3256, %3260 ], [ %3268, %3262 ]
  %3271 = phi i32* [ %3261, %3260 ], [ %3267, %3262 ]
  %3272 = icmp eq i32 %3270, 0
  br i1 %3272, label %3277, label %3273

; <label>:3273:                                   ; preds = %3269
  %3274 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3271) #16
  %3275 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3276 = getelementptr inbounds %union.StackValue, %union.StackValue* %3275, i64 1
  br label %3277

; <label>:3277:                                   ; preds = %3269, %3273
  %3278 = phi i32 [ %3274, %3273 ], [ 0, %3269 ]
  %3279 = phi %union.StackValue* [ %3276, %3273 ], [ %4308, %3269 ]
  %3280 = getelementptr inbounds i32, i32* %3271, i64 1
  %3281 = load i32, i32* %3271, align 4, !tbaa !77
  br label %162

; <label>:3282:                                   ; preds = %4306
  %3283 = lshr i32 %4307, 16
  %3284 = and i32 %3283, 255
  %3285 = add nsw i32 %3284, -127
  %3286 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3287 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3288 = load i8, i8* %3287, align 8, !tbaa !21
  switch i8 %3288, label %3301 [
    i8 35, label %3289
    i8 19, label %3295
  ]

; <label>:3289:                                   ; preds = %3282
  %3290 = bitcast %union.StackValue* %4314 to i64*
  %3291 = load i64, i64* %3290, align 8, !tbaa !21
  %3292 = sext i32 %3285 to i64
  %3293 = icmp sge i64 %3291, %3292
  %3294 = zext i1 %3293 to i32
  br label %3312

; <label>:3295:                                   ; preds = %3282
  %3296 = bitcast %union.StackValue* %4314 to double*
  %3297 = load double, double* %3296, align 8, !tbaa !21
  %3298 = sitofp i32 %3285 to double
  %3299 = fcmp oge double %3297, %3298
  %3300 = zext i1 %3299 to i32
  br label %3312

; <label>:3301:                                   ; preds = %3282
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3302 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3302, i64* %35, align 8, !tbaa !20
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %71) #7
  %3303 = icmp ult i32 %4307, 16777216
  br i1 %3303, label %3306, label %3304

; <label>:3304:                                   ; preds = %3301
  %3305 = sitofp i32 %3285 to double
  store double %3305, double* %99, align 8, !tbaa !21
  br label %3308

; <label>:3306:                                   ; preds = %3301
  %3307 = sext i32 %3285 to i64
  store i64 %3307, i64* %97, align 8, !tbaa !21
  br label %3308

; <label>:3308:                                   ; preds = %3304, %3306
  %3309 = phi i8 [ 19, %3304 ], [ 35, %3306 ]
  store i8 %3309, i8* %98, align 8, !tbaa !22
  %3310 = call fastcc i32 @luaT_callorderTM(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %4, %struct.TValue* %3286, i32 21) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %71) #7
  %3311 = load i32, i32* %38, align 8, !tbaa !21
  br label %3312

; <label>:3312:                                   ; preds = %3295, %3308, %3289
  %3313 = phi i32 [ %3294, %3289 ], [ %3300, %3295 ], [ %3310, %3308 ]
  %3314 = phi i32 [ %4309, %3289 ], [ %4309, %3295 ], [ %3311, %3308 ]
  %3315 = lshr i32 %4307, 15
  %3316 = and i32 %3315, 1
  %3317 = icmp eq i32 %3313, %3316
  br i1 %3317, label %3320, label %3318

; <label>:3318:                                   ; preds = %3312
  %3319 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3327

; <label>:3320:                                   ; preds = %3312
  %3321 = load i32, i32* %4310, align 4, !tbaa !77
  %3322 = lshr i32 %3321, 7
  %3323 = add nsw i32 %3322, -16777214
  %3324 = sext i32 %3323 to i64
  %3325 = getelementptr inbounds i32, i32* %4310, i64 %3324
  %3326 = load i32, i32* %38, align 8, !tbaa !21
  br label %3327

; <label>:3327:                                   ; preds = %3320, %3318
  %3328 = phi i32 [ %3314, %3318 ], [ %3326, %3320 ]
  %3329 = phi i32* [ %3319, %3318 ], [ %3325, %3320 ]
  %3330 = icmp eq i32 %3328, 0
  br i1 %3330, label %3335, label %3331

; <label>:3331:                                   ; preds = %3327
  %3332 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3329) #16
  %3333 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3334 = getelementptr inbounds %union.StackValue, %union.StackValue* %3333, i64 1
  br label %3335

; <label>:3335:                                   ; preds = %3327, %3331
  %3336 = phi i32 [ %3332, %3331 ], [ 0, %3327 ]
  %3337 = phi %union.StackValue* [ %3334, %3331 ], [ %4308, %3327 ]
  %3338 = getelementptr inbounds i32, i32* %3329, i64 1
  %3339 = load i32, i32* %3329, align 4, !tbaa !77
  br label %162

; <label>:3340:                                   ; preds = %4306
  %3341 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3342 = load i8, i8* %3341, align 8, !tbaa !21
  %3343 = and i8 %3342, 15
  %3344 = icmp eq i8 %3343, 0
  br i1 %3344, label %3345, label %3348

; <label>:3345:                                   ; preds = %3340
  %3346 = trunc i32 %4307 to i16
  %3347 = icmp slt i16 %3346, 0
  br i1 %3347, label %3360, label %3362

; <label>:3348:                                   ; preds = %3340
  %3349 = icmp eq i8 %3342, 1
  br i1 %3349, label %3353, label %3350

; <label>:3350:                                   ; preds = %3348
  %3351 = trunc i32 %4307 to i16
  %3352 = icmp sgt i16 %3351, -1
  br i1 %3352, label %3360, label %3362

; <label>:3353:                                   ; preds = %3348
  %3354 = bitcast %union.StackValue* %4314 to i32*
  %3355 = load i32, i32* %3354, align 8, !tbaa !21
  %3356 = icmp ne i32 %3355, 0
  %3357 = trunc i32 %4307 to i16
  %3358 = icmp slt i16 %3357, 0
  %3359 = xor i1 %3358, %3356
  br i1 %3359, label %3360, label %3362

; <label>:3360:                                   ; preds = %3350, %3345, %3353
  %3361 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3369

; <label>:3362:                                   ; preds = %3350, %3345, %3353
  %3363 = load i32, i32* %4310, align 4, !tbaa !77
  %3364 = lshr i32 %3363, 7
  %3365 = add nsw i32 %3364, -16777214
  %3366 = sext i32 %3365 to i64
  %3367 = getelementptr inbounds i32, i32* %4310, i64 %3366
  %3368 = load i32, i32* %38, align 8, !tbaa !21
  br label %3369

; <label>:3369:                                   ; preds = %3362, %3360
  %3370 = phi i32 [ %4309, %3360 ], [ %3368, %3362 ]
  %3371 = phi i32* [ %3361, %3360 ], [ %3367, %3362 ]
  %3372 = icmp eq i32 %3370, 0
  br i1 %3372, label %3377, label %3373

; <label>:3373:                                   ; preds = %3369
  %3374 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3371) #16
  %3375 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3376 = getelementptr inbounds %union.StackValue, %union.StackValue* %3375, i64 1
  br label %3377

; <label>:3377:                                   ; preds = %3369, %3373
  %3378 = phi i32 [ %3374, %3373 ], [ 0, %3369 ]
  %3379 = phi %union.StackValue* [ %3376, %3373 ], [ %4308, %3369 ]
  %3380 = getelementptr inbounds i32, i32* %3371, i64 1
  %3381 = load i32, i32* %3371, align 4, !tbaa !77
  br label %162

; <label>:3382:                                   ; preds = %4306
  %3383 = lshr i32 %4307, 16
  %3384 = and i32 %3383, 255
  %3385 = zext i32 %3384 to i64
  %3386 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %3385, i32 0
  %3387 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %3385, i32 0, i32 1
  %3388 = load i8, i8* %3387, align 8, !tbaa !22
  %3389 = and i8 %3388, 15
  %3390 = icmp eq i8 %3389, 0
  br i1 %3390, label %3391, label %3394

; <label>:3391:                                   ; preds = %3382
  %3392 = trunc i32 %4307 to i16
  %3393 = icmp sgt i16 %3392, -1
  br i1 %3393, label %3408, label %3406

; <label>:3394:                                   ; preds = %3382
  %3395 = icmp eq i8 %3388, 1
  br i1 %3395, label %3399, label %3396

; <label>:3396:                                   ; preds = %3394
  %3397 = trunc i32 %4307 to i16
  %3398 = icmp slt i16 %3397, 0
  br i1 %3398, label %3408, label %3406

; <label>:3399:                                   ; preds = %3394
  %3400 = bitcast %struct.TValue* %3386 to i32*
  %3401 = load i32, i32* %3400, align 8, !tbaa !21
  %3402 = icmp eq i32 %3401, 0
  %3403 = trunc i32 %4307 to i16
  %3404 = icmp slt i16 %3403, 0
  %3405 = xor i1 %3404, %3402
  br i1 %3405, label %3408, label %3406

; <label>:3406:                                   ; preds = %3391, %3396, %3399
  %3407 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3420

; <label>:3408:                                   ; preds = %3391, %3396, %3399
  %3409 = bitcast %struct.TValue* %3386 to i64*
  %3410 = bitcast %union.StackValue* %4314 to i64*
  %3411 = load i64, i64* %3409, align 8
  store i64 %3411, i64* %3410, align 8
  %3412 = load i8, i8* %3387, align 8, !tbaa !22
  %3413 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 %3412, i8* %3413, align 8, !tbaa !22
  %3414 = load i32, i32* %4310, align 4, !tbaa !77
  %3415 = lshr i32 %3414, 7
  %3416 = add nsw i32 %3415, -16777214
  %3417 = sext i32 %3416 to i64
  %3418 = getelementptr inbounds i32, i32* %4310, i64 %3417
  %3419 = load i32, i32* %38, align 8, !tbaa !21
  br label %3420

; <label>:3420:                                   ; preds = %3408, %3406
  %3421 = phi i32 [ %4309, %3406 ], [ %3419, %3408 ]
  %3422 = phi i32* [ %3407, %3406 ], [ %3418, %3408 ]
  %3423 = icmp eq i32 %3421, 0
  br i1 %3423, label %3428, label %3424

; <label>:3424:                                   ; preds = %3420
  %3425 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3422) #16
  %3426 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3427 = getelementptr inbounds %union.StackValue, %union.StackValue* %3426, i64 1
  br label %3428

; <label>:3428:                                   ; preds = %3420, %3424
  %3429 = phi i32 [ %3425, %3424 ], [ 0, %3420 ]
  %3430 = phi %union.StackValue* [ %3427, %3424 ], [ %4308, %3420 ]
  %3431 = getelementptr inbounds i32, i32* %3422, i64 1
  %3432 = load i32, i32* %3422, align 4, !tbaa !77
  br label %162

; <label>:3433:                                   ; preds = %4306
  %3434 = lshr i32 %4307, 16
  %3435 = and i32 %3434, 255
  %3436 = lshr i32 %4307, 24
  %3437 = add nsw i32 %3436, -1
  %3438 = icmp eq i32 %3435, 0
  br i1 %3438, label %3442, label %3439

; <label>:3439:                                   ; preds = %3433
  %3440 = zext i32 %3435 to i64
  %3441 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %3440
  store %union.StackValue* %3441, %union.StackValue** %34, align 8, !tbaa !20
  br label %3442

; <label>:3442:                                   ; preds = %3433, %3439
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* %4314, i32 %3437) #16
  %3443 = load i32, i32* %38, align 8, !tbaa !21
  %3444 = icmp eq i32 %3443, 0
  br i1 %3444, label %3449, label %3445

; <label>:3445:                                   ; preds = %3442
  %3446 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %3447 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3448 = getelementptr inbounds %union.StackValue, %union.StackValue* %3447, i64 1
  br label %3449

; <label>:3449:                                   ; preds = %3442, %3445
  %3450 = phi i32 [ %3446, %3445 ], [ 0, %3442 ]
  %3451 = phi %union.StackValue* [ %3448, %3445 ], [ %4308, %3442 ]
  %3452 = getelementptr inbounds i32, i32* %4310, i64 1
  %3453 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:3454:                                   ; preds = %4306
  %3455 = zext i32 %4312 to i64
  %3456 = lshr i32 %4307, 16
  %3457 = and i32 %3456, 255
  %3458 = icmp eq i32 %3457, 0
  br i1 %3458, label %3462, label %3459

; <label>:3459:                                   ; preds = %3454
  %3460 = zext i32 %3457 to i64
  %3461 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %3460
  store %union.StackValue* %3461, %union.StackValue** %34, align 8, !tbaa !20
  br label %3468

; <label>:3462:                                   ; preds = %3454
  %3463 = load i64, i64* %35, align 8, !tbaa !20
  %3464 = ptrtoint %union.StackValue* %4314 to i64
  %3465 = sub i64 %3463, %3464
  %3466 = lshr exact i64 %3465, 4
  %3467 = trunc i64 %3466 to i32
  br label %3468

; <label>:3468:                                   ; preds = %3462, %3459
  %3469 = phi i32 [ %3457, %3459 ], [ %3467, %3462 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3470 = trunc i32 %4307 to i16
  %3471 = icmp slt i16 %3470, 0
  br i1 %3471, label %3472, label %3481

; <label>:3472:                                   ; preds = %3468
  %3473 = lshr i32 %4307, 24
  %3474 = icmp eq i32 %3473, 0
  br i1 %3474, label %3478, label %3475

; <label>:3475:                                   ; preds = %3472
  %3476 = load i32, i32* %39, align 4, !tbaa !21
  %3477 = add nsw i32 %3476, %3473
  br label %3478

; <label>:3478:                                   ; preds = %3472, %3475
  %3479 = phi i32 [ %3477, %3475 ], [ 0, %3472 ]
  %3480 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4308, i32 -1) #16
  br label %3481

; <label>:3481:                                   ; preds = %3478, %3468
  %3482 = phi i32 [ %3479, %3478 ], [ 0, %3468 ]
  %3483 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %3455, i32 0, i32 1
  %3484 = load i8, i8* %3483, align 8, !tbaa !21
  %3485 = and i8 %3484, 15
  %3486 = icmp eq i8 %3485, 6
  br i1 %3486, label %3490, label %3487

; <label>:3487:                                   ; preds = %3481
  call fastcc void @luaD_tryfuncTM(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4314) #16
  %3488 = add nsw i32 %3469, 1
  %3489 = load i8, i8* %3483, align 8, !tbaa !21
  br label %3490

; <label>:3490:                                   ; preds = %3487, %3481
  %3491 = phi i8 [ %3489, %3487 ], [ %3484, %3481 ]
  %3492 = phi i32 [ %3488, %3487 ], [ %3469, %3481 ]
  %3493 = icmp eq i8 %3491, 86
  br i1 %3493, label %3514, label %3494

; <label>:3494:                                   ; preds = %3490
  call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %4314, i32 -1) #16
  %3495 = load i32, i32* %38, align 8, !tbaa !21
  %3496 = icmp eq i32 %3495, 0
  %3497 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  br i1 %3496, label %3504, label %3498

; <label>:3498:                                   ; preds = %3494
  %3499 = getelementptr inbounds %union.StackValue, %union.StackValue* %3497, i64 1
  %3500 = lshr i32 %4307, 7
  %3501 = and i32 %3500, 255
  %3502 = zext i32 %3501 to i64
  %3503 = getelementptr inbounds %union.StackValue, %union.StackValue* %3499, i64 %3502
  br label %3504

; <label>:3504:                                   ; preds = %3494, %3498
  %3505 = phi %union.StackValue* [ %3503, %3498 ], [ %4314, %3494 ]
  %3506 = sext i32 %3482 to i64
  %3507 = sub nsw i64 0, %3506
  %3508 = getelementptr inbounds %union.StackValue, %union.StackValue* %3497, i64 %3507
  store %union.StackValue* %3508, %union.StackValue** %27, align 8, !tbaa !64
  %3509 = load i64, i64* %35, align 8, !tbaa !20
  %3510 = ptrtoint %union.StackValue* %3505 to i64
  %3511 = sub i64 %3509, %3510
  %3512 = lshr exact i64 %3511, 4
  %3513 = trunc i64 %3512 to i32
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3513) #16
  br label %4305

; <label>:3514:                                   ; preds = %3490
  %3515 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3516 = sext i32 %3482 to i64
  %3517 = sub nsw i64 0, %3516
  %3518 = getelementptr inbounds %union.StackValue, %union.StackValue* %3515, i64 %3517
  store %union.StackValue* %3518, %union.StackValue** %27, align 8, !tbaa !64
  %3519 = bitcast %union.StackValue* %4314 to %struct.LClosure**
  %3520 = load %struct.LClosure*, %struct.LClosure** %3519, align 8, !tbaa !21
  %3521 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %3520, i64 0, i32 5
  %3522 = load %struct.Proto*, %struct.Proto** %3521, align 8, !tbaa !21
  %3523 = getelementptr inbounds %struct.Proto, %struct.Proto* %3522, i64 0, i32 5
  %3524 = load i8, i8* %3523, align 4, !tbaa !158
  %3525 = zext i8 %3524 to i32
  %3526 = getelementptr inbounds %struct.Proto, %struct.Proto* %3522, i64 0, i32 3
  %3527 = load i8, i8* %3526, align 2, !tbaa !131
  %3528 = zext i8 %3527 to i32
  %3529 = icmp sgt i32 %3492, 0
  br i1 %3529, label %3530, label %3553

; <label>:3530:                                   ; preds = %3514
  %3531 = zext i32 %3492 to i64
  %3532 = bitcast %union.StackValue* %4314 to i64*
  %3533 = bitcast %union.StackValue* %3518 to i64*
  %3534 = load i64, i64* %3532, align 8
  store i64 %3534, i64* %3533, align 8
  %3535 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %3455, i32 0, i32 1
  %3536 = load i8, i8* %3535, align 8, !tbaa !22
  %3537 = getelementptr inbounds %union.StackValue, %union.StackValue* %3515, i64 %3517, i32 0, i32 1
  store i8 %3536, i8* %3537, align 8, !tbaa !22
  %3538 = icmp eq i32 %3492, 1
  br i1 %3538, label %3553, label %3539

; <label>:3539:                                   ; preds = %3530
  br label %3540

; <label>:3540:                                   ; preds = %3539, %3540
  %3541 = phi i64 [ %3551, %3540 ], [ 1, %3539 ]
  %3542 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3543 = getelementptr inbounds %union.StackValue, %union.StackValue* %3542, i64 %3541, i32 0
  %3544 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %3541, i32 0
  %3545 = bitcast %struct.TValue* %3544 to i64*
  %3546 = bitcast %struct.TValue* %3543 to i64*
  %3547 = load i64, i64* %3545, align 8
  store i64 %3547, i64* %3546, align 8
  %3548 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %3541, i32 0, i32 1
  %3549 = load i8, i8* %3548, align 8, !tbaa !22
  %3550 = getelementptr inbounds %union.StackValue, %union.StackValue* %3542, i64 %3541, i32 0, i32 1
  store i8 %3549, i8* %3550, align 8, !tbaa !22
  %3551 = add nuw nsw i64 %3541, 1
  %3552 = icmp eq i64 %3551, %3531
  br i1 %3552, label %3553, label %3540

; <label>:3553:                                   ; preds = %3540, %3530, %3514
  %3554 = load i64, i64* %42, align 8, !tbaa !62
  %3555 = load i64, i64* %35, align 8, !tbaa !20
  %3556 = sub i64 %3554, %3555
  %3557 = ashr exact i64 %3556, 4
  %3558 = zext i8 %3524 to i64
  %3559 = icmp sgt i64 %3557, %3558
  br i1 %3559, label %3567, label %3560

; <label>:3560:                                   ; preds = %3553
  %3561 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %3525, i32 1) #17
  %3562 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %3563 = getelementptr inbounds %struct.global_State, %struct.global_State* %3562, i64 0, i32 3
  %3564 = load i64, i64* %3563, align 8, !tbaa !11
  %3565 = icmp sgt i64 %3564, 0
  br i1 %3565, label %3566, label %3567

; <label>:3566:                                   ; preds = %3560
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %3567

; <label>:3567:                                   ; preds = %3566, %3560, %3553
  %3568 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3569 = icmp sgt i32 %3492, %3528
  br i1 %3569, label %3580, label %3570

; <label>:3570:                                   ; preds = %3567
  %3571 = sext i32 %3492 to i64
  %3572 = zext i8 %3527 to i64
  br label %3573

; <label>:3573:                                   ; preds = %3573, %3570
  %3574 = phi i64 [ %3576, %3573 ], [ %3571, %3570 ]
  %3575 = getelementptr inbounds %union.StackValue, %union.StackValue* %3568, i64 %3574, i32 0, i32 1
  store i8 0, i8* %3575, align 8, !tbaa !21
  %3576 = add nsw i64 %3574, 1
  %3577 = icmp slt i64 %3574, %3572
  br i1 %3577, label %3573, label %3578

; <label>:3578:                                   ; preds = %3573
  %3579 = trunc i64 %3576 to i32
  br label %3580

; <label>:3580:                                   ; preds = %3578, %3567
  %3581 = phi i32 [ %3492, %3567 ], [ %3579, %3578 ]
  %3582 = getelementptr inbounds %union.StackValue, %union.StackValue* %3568, i64 1
  %3583 = getelementptr inbounds %union.StackValue, %union.StackValue* %3582, i64 %3558
  store %union.StackValue* %3583, %union.StackValue** %32, align 8, !tbaa !66
  %3584 = getelementptr inbounds %struct.Proto, %struct.Proto* %3522, i64 0, i32 16
  %3585 = bitcast i32** %3584 to i64*
  %3586 = load i64, i64* %3585, align 8, !tbaa !116
  store i64 %3586, i64* %109, align 8, !tbaa !21
  %3587 = load i16, i16* %110, align 2, !tbaa !63
  %3588 = or i16 %3587, 16
  store i16 %3588, i16* %110, align 2, !tbaa !63
  %3589 = sext i32 %3581 to i64
  %3590 = getelementptr inbounds %union.StackValue, %union.StackValue* %3568, i64 %3589
  store %union.StackValue* %3590, %union.StackValue** %34, align 8, !tbaa !20
  br label %111

; <label>:3591:                                   ; preds = %4306
  %3592 = lshr i32 %4307, 16
  %3593 = and i32 %3592, 255
  %3594 = add nsw i32 %3593, -1
  %3595 = icmp eq i32 %3593, 0
  br i1 %3595, label %3596, label %3602

; <label>:3596:                                   ; preds = %3591
  %3597 = load i64, i64* %35, align 8, !tbaa !20
  %3598 = ptrtoint %union.StackValue* %4314 to i64
  %3599 = sub i64 %3597, %3598
  %3600 = lshr exact i64 %3599, 4
  %3601 = trunc i64 %3600 to i32
  br label %3605

; <label>:3602:                                   ; preds = %3591
  %3603 = sext i32 %3594 to i64
  %3604 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %3603
  store %union.StackValue* %3604, %union.StackValue** %34, align 8, !tbaa !20
  br label %3605

; <label>:3605:                                   ; preds = %3602, %3596
  %3606 = phi i32 [ %3601, %3596 ], [ %3594, %3602 ]
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3607 = trunc i32 %4307 to i16
  %3608 = icmp slt i16 %3607, 0
  br i1 %3608, label %3609, label %3621

; <label>:3609:                                   ; preds = %3605
  %3610 = lshr i32 %4307, 24
  %3611 = icmp eq i32 %3610, 0
  br i1 %3611, label %3619, label %3612

; <label>:3612:                                   ; preds = %3609
  %3613 = load i32, i32* %39, align 4, !tbaa !21
  %3614 = add nsw i32 %3613, %3610
  %3615 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3616 = sext i32 %3614 to i64
  %3617 = sub nsw i64 0, %3616
  %3618 = getelementptr inbounds %union.StackValue, %union.StackValue* %3615, i64 %3617
  store %union.StackValue* %3618, %union.StackValue** %27, align 8, !tbaa !64
  br label %3619

; <label>:3619:                                   ; preds = %3609, %3612
  %3620 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %4308, i32 0) #16
  br label %3621

; <label>:3621:                                   ; preds = %3619, %3605
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1, i32 %3606) #16
  br label %4305

; <label>:3622:                                   ; preds = %4306
  %3623 = load i32, i32* %26, align 8, !tbaa !31
  %3624 = icmp eq i32 %3623, 0
  br i1 %3624, label %3626, label %3625

; <label>:3625:                                   ; preds = %3622
  store %union.StackValue* %4314, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 0) #16
  br label %4305

; <label>:3626:                                   ; preds = %3622
  %3627 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3628 = load i16, i16* %3627, align 4, !tbaa !65
  %3629 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3630 = bitcast %struct.CallInfo** %3629 to i64*
  %3631 = load i64, i64* %3630, align 8, !tbaa !105
  %3632 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3633 = bitcast %struct.CallInfo** %3632 to i64*
  store i64 %3631, i64* %3633, align 8, !tbaa !24
  %3634 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 -1
  store %union.StackValue* %3634, %union.StackValue** %34, align 8, !tbaa !20
  %3635 = icmp sgt i16 %3628, 0
  br i1 %3635, label %3636, label %4305

; <label>:3636:                                   ; preds = %3626
  store %union.StackValue* %4308, %union.StackValue** %34, align 8, !tbaa !20
  %3637 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 -1, i32 0, i32 1
  store i8 0, i8* %3637, align 8, !tbaa !21
  %3638 = icmp eq i16 %3628, 1
  br i1 %3638, label %4305, label %3639

; <label>:3639:                                   ; preds = %3636
  %3640 = sext i16 %3628 to i32
  br label %3641

; <label>:3641:                                   ; preds = %3639, %3641
  %3642 = phi i32 [ %3640, %3639 ], [ %3643, %3641 ]
  %3643 = add nsw i32 %3642, -1
  %3644 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3645 = getelementptr inbounds %union.StackValue, %union.StackValue* %3644, i64 1
  store %union.StackValue* %3645, %union.StackValue** %34, align 8, !tbaa !20
  %3646 = getelementptr inbounds %union.StackValue, %union.StackValue* %3644, i64 0, i32 0, i32 1
  store i8 0, i8* %3646, align 8, !tbaa !21
  %3647 = icmp sgt i32 %3642, 2
  br i1 %3647, label %3641, label %4305

; <label>:3648:                                   ; preds = %4306
  %3649 = zext i32 %4312 to i64
  %3650 = load i32, i32* %26, align 8, !tbaa !31
  %3651 = icmp eq i32 %3650, 0
  br i1 %3651, label %3654, label %3652

; <label>:3652:                                   ; preds = %3648
  %3653 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1
  store %union.StackValue* %3653, %union.StackValue** %34, align 8, !tbaa !20
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* %1, i32 1) #16
  br label %4305

; <label>:3654:                                   ; preds = %3648
  %3655 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %3656 = load i16, i16* %3655, align 4, !tbaa !65
  %3657 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %3658 = bitcast %struct.CallInfo** %3657 to i64*
  %3659 = load i64, i64* %3658, align 8, !tbaa !105
  %3660 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3661 = bitcast %struct.CallInfo** %3660 to i64*
  store i64 %3659, i64* %3661, align 8, !tbaa !24
  %3662 = icmp eq i16 %3656, 0
  %3663 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 -1
  br i1 %3662, label %3664, label %3665

; <label>:3664:                                   ; preds = %3654
  store %union.StackValue* %3663, %union.StackValue** %34, align 8, !tbaa !20
  br label %4305

; <label>:3665:                                   ; preds = %3654
  %3666 = bitcast %union.StackValue* %4314 to i64*
  %3667 = bitcast %union.StackValue* %3663 to i64*
  %3668 = load i64, i64* %3666, align 8
  store i64 %3668, i64* %3667, align 8
  %3669 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %3649, i32 0, i32 1
  %3670 = load i8, i8* %3669, align 8, !tbaa !22
  %3671 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 -1, i32 0, i32 1
  store i8 %3670, i8* %3671, align 8, !tbaa !22
  store %union.StackValue* %4308, %union.StackValue** %34, align 8, !tbaa !20
  %3672 = icmp sgt i16 %3656, 1
  br i1 %3672, label %3673, label %4305

; <label>:3673:                                   ; preds = %3665
  %3674 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 1
  store %union.StackValue* %3674, %union.StackValue** %34, align 8, !tbaa !20
  %3675 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 0, i32 0, i32 1
  store i8 0, i8* %3675, align 8, !tbaa !21
  %3676 = icmp eq i16 %3656, 2
  br i1 %3676, label %4305, label %3677

; <label>:3677:                                   ; preds = %3673
  %3678 = sext i16 %3656 to i32
  br label %3679

; <label>:3679:                                   ; preds = %3677, %3679
  %3680 = phi i32 [ %3678, %3677 ], [ %3681, %3679 ]
  %3681 = add nsw i32 %3680, -1
  %3682 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %3683 = getelementptr inbounds %union.StackValue, %union.StackValue* %3682, i64 1
  store %union.StackValue* %3683, %union.StackValue** %34, align 8, !tbaa !20
  %3684 = getelementptr inbounds %union.StackValue, %union.StackValue* %3682, i64 0, i32 0, i32 1
  store i8 0, i8* %3684, align 8, !tbaa !21
  %3685 = icmp sgt i32 %3680, 3
  br i1 %3685, label %3679, label %4305

; <label>:3686:                                   ; preds = %4306
  %3687 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 2, i32 0
  %3688 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 2, i32 0, i32 1
  %3689 = load i8, i8* %3688, align 8, !tbaa !21
  %3690 = icmp eq i8 %3689, 35
  br i1 %3690, label %3691, label %3710

; <label>:3691:                                   ; preds = %3686
  %3692 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 0
  %3693 = bitcast %union.Value* %3692 to i64*
  %3694 = load i64, i64* %3693, align 8, !tbaa !21
  %3695 = icmp eq i64 %3694, 0
  br i1 %3695, label %3732, label %3696

; <label>:3696:                                   ; preds = %3691
  %3697 = bitcast %struct.TValue* %3687 to i64*
  %3698 = load i64, i64* %3697, align 8, !tbaa !21
  %3699 = bitcast %union.StackValue* %4314 to i64*
  %3700 = load i64, i64* %3699, align 8, !tbaa !21
  %3701 = add i64 %3694, -1
  store i64 %3701, i64* %3693, align 8, !tbaa !21
  %3702 = add i64 %3700, %3698
  store i64 %3702, i64* %3699, align 8, !tbaa !21
  %3703 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0
  %3704 = bitcast %struct.TValue* %3703 to i64*
  store i64 %3702, i64* %3704, align 8, !tbaa !21
  %3705 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0, i32 1
  store i8 35, i8* %3705, align 8, !tbaa !22
  %3706 = lshr i32 %4307, 15
  %3707 = zext i32 %3706 to i64
  %3708 = sub nsw i64 0, %3707
  %3709 = getelementptr inbounds i32, i32* %4310, i64 %3708
  br label %3732

; <label>:3710:                                   ; preds = %3686
  %3711 = bitcast %struct.TValue* %3687 to double*
  %3712 = load double, double* %3711, align 8, !tbaa !21
  %3713 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 0
  %3714 = bitcast %union.Value* %3713 to double*
  %3715 = load double, double* %3714, align 8, !tbaa !21
  %3716 = bitcast %union.StackValue* %4314 to double*
  %3717 = load double, double* %3716, align 8, !tbaa !21
  %3718 = fadd double %3712, %3717
  %3719 = fcmp ogt double %3712, 0.000000e+00
  br i1 %3719, label %3720, label %3722

; <label>:3720:                                   ; preds = %3710
  %3721 = fcmp ugt double %3718, %3715
  br i1 %3721, label %3732, label %3724

; <label>:3722:                                   ; preds = %3710
  %3723 = fcmp ugt double %3715, %3718
  br i1 %3723, label %3732, label %3724

; <label>:3724:                                   ; preds = %3720, %3722
  store double %3718, double* %3716, align 8, !tbaa !21
  %3725 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0
  %3726 = bitcast %struct.TValue* %3725 to double*
  store double %3718, double* %3726, align 8, !tbaa !21
  %3727 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0, i32 1
  store i8 19, i8* %3727, align 8, !tbaa !22
  %3728 = lshr i32 %4307, 15
  %3729 = zext i32 %3728 to i64
  %3730 = sub nsw i64 0, %3729
  %3731 = getelementptr inbounds i32, i32* %4310, i64 %3730
  br label %3732

; <label>:3732:                                   ; preds = %3691, %3720, %3722, %3724, %3696
  %3733 = phi i32* [ %3709, %3696 ], [ %4310, %3691 ], [ %3731, %3724 ], [ %4310, %3720 ], [ %4310, %3722 ]
  %3734 = load i32, i32* %38, align 8, !tbaa !21
  %3735 = icmp eq i32 %3734, 0
  br i1 %3735, label %3740, label %3736

; <label>:3736:                                   ; preds = %3732
  %3737 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3733) #16
  %3738 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3739 = getelementptr inbounds %union.StackValue, %union.StackValue* %3738, i64 1
  br label %3740

; <label>:3740:                                   ; preds = %3732, %3736
  %3741 = phi i32 [ %3737, %3736 ], [ 0, %3732 ]
  %3742 = phi %union.StackValue* [ %3739, %3736 ], [ %4308, %3732 ]
  %3743 = getelementptr inbounds i32, i32* %3733, i64 1
  %3744 = load i32, i32* %3733, align 4, !tbaa !77
  br label %162

; <label>:3745:                                   ; preds = %4306
  %3746 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0
  %3747 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0
  %3748 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 2, i32 0
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %3749 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3749, i64* %35, align 8, !tbaa !20
  %3750 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  %3751 = load i8, i8* %3750, align 8, !tbaa !22
  %3752 = icmp eq i8 %3751, 35
  br i1 %3752, label %3753, label %3824

; <label>:3753:                                   ; preds = %3745
  %3754 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 2, i32 0, i32 1
  %3755 = load i8, i8* %3754, align 8, !tbaa !22
  %3756 = icmp eq i8 %3755, 35
  br i1 %3756, label %3757, label %3824

; <label>:3757:                                   ; preds = %3753
  %3758 = bitcast %union.StackValue* %4314 to i64*
  %3759 = load i64, i64* %3758, align 8, !tbaa !21
  %3760 = bitcast %struct.TValue* %3748 to i64*
  %3761 = load i64, i64* %3760, align 8, !tbaa !21
  %3762 = icmp eq i64 %3761, 0
  br i1 %3762, label %3763, label %3764

; <label>:3763:                                   ; preds = %3757
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #18
  unreachable

; <label>:3764:                                   ; preds = %3757
  %3765 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0
  %3766 = bitcast %struct.TValue* %3765 to i64*
  store i64 %3759, i64* %3766, align 8, !tbaa !21
  %3767 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0, i32 1
  store i8 35, i8* %3767, align 8, !tbaa !22
  %3768 = icmp slt i64 %3761, 0
  %3769 = lshr i64 %3761, 63
  %3770 = trunc i64 %3769 to i32
  %3771 = add nuw nsw i32 %3770, 1
  %3772 = call fastcc i32 @luaV_tointeger(%struct.TValue* nonnull %3747, i64* nonnull %22, i32 %3771) #17
  %3773 = icmp eq i32 %3772, 0
  br i1 %3773, label %3776, label %3774

; <label>:3774:                                   ; preds = %3764
  %3775 = load i64, i64* %22, align 8, !tbaa !144
  br label %3799

; <label>:3776:                                   ; preds = %3764
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %106) #7
  %3777 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 1
  %3778 = load i8, i8* %3777, align 8, !tbaa !22
  %3779 = icmp eq i8 %3778, 19
  br i1 %3779, label %3780, label %3784

; <label>:3780:                                   ; preds = %3776
  %3781 = bitcast %struct.TValue* %3747 to i64*
  %3782 = load i64, i64* %3781, align 8, !tbaa !21
  store i64 %3782, i64* %108, align 8, !tbaa !140
  %3783 = bitcast i64 %3782 to double
  br label %3790

; <label>:3784:                                   ; preds = %3776
  %3785 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3747, double* nonnull %3) #17
  %3786 = icmp eq i32 %3785, 0
  br i1 %3786, label %3787, label %3788

; <label>:3787:                                   ; preds = %3784
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3747, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #19
  unreachable

; <label>:3788:                                   ; preds = %3784
  %3789 = load double, double* %3, align 8, !tbaa !140
  br label %3790

; <label>:3790:                                   ; preds = %3788, %3780
  %3791 = phi double [ %3789, %3788 ], [ %3783, %3780 ]
  %3792 = fcmp ogt double %3791, 0.000000e+00
  br i1 %3792, label %3793, label %3794

; <label>:3793:                                   ; preds = %3790
  br i1 %3768, label %3798, label %3796

; <label>:3794:                                   ; preds = %3790
  %3795 = icmp sgt i64 %3761, 0
  br i1 %3795, label %3798, label %3796

; <label>:3796:                                   ; preds = %3794, %3793
  %3797 = phi i64 [ 9223372036854775807, %3793 ], [ -9223372036854775808, %3794 ]
  store i64 %3797, i64* %22, align 8, !tbaa !144
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  br label %3799

; <label>:3798:                                   ; preds = %3793, %3794
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  br label %3805

; <label>:3799:                                   ; preds = %3774, %3796
  %3800 = phi i64 [ %3775, %3774 ], [ %3797, %3796 ]
  %3801 = icmp sgt i64 %3761, 0
  %3802 = icmp slt i64 %3800, %3759
  %3803 = icmp sgt i64 %3800, %3759
  %3804 = select i1 %3801, i1 %3802, i1 %3803
  br i1 %3804, label %3805, label %3810

; <label>:3805:                                   ; preds = %3799, %3798
  %3806 = lshr i32 %4307, 15
  %3807 = add nuw nsw i32 %3806, 1
  %3808 = zext i32 %3807 to i64
  %3809 = getelementptr inbounds i32, i32* %4310, i64 %3808
  br label %3885

; <label>:3810:                                   ; preds = %3799
  br i1 %3801, label %3811, label %3816

; <label>:3811:                                   ; preds = %3810
  %3812 = sub i64 %3800, %3759
  %3813 = icmp eq i64 %3761, 1
  br i1 %3813, label %3820, label %3814

; <label>:3814:                                   ; preds = %3811
  %3815 = udiv i64 %3812, %3761
  br label %3820

; <label>:3816:                                   ; preds = %3810
  %3817 = sub i64 %3759, %3800
  %3818 = sub i64 0, %3761
  %3819 = udiv i64 %3817, %3818
  br label %3820

; <label>:3820:                                   ; preds = %3811, %3814, %3816
  %3821 = phi i64 [ %3815, %3814 ], [ %3812, %3811 ], [ %3819, %3816 ]
  %3822 = bitcast %struct.TValue* %3747 to i64*
  store i64 %3821, i64* %3822, align 8, !tbaa !21
  %3823 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 1
  store i8 35, i8* %3823, align 8, !tbaa !22
  br label %3885

; <label>:3824:                                   ; preds = %3753, %3745
  %3825 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1, i32 0, i32 1
  %3826 = load i8, i8* %3825, align 8, !tbaa !22
  %3827 = icmp eq i8 %3826, 19
  br i1 %3827, label %3828, label %3831

; <label>:3828:                                   ; preds = %3824
  %3829 = bitcast %struct.TValue* %3747 to i64*
  %3830 = load i64, i64* %3829, align 8, !tbaa !21
  store i64 %3830, i64* %100, align 8, !tbaa !140
  br label %3835

; <label>:3831:                                   ; preds = %3824
  %3832 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3747, double* nonnull %24) #16
  %3833 = icmp eq i32 %3832, 0
  br i1 %3833, label %3834, label %3835, !prof !61

; <label>:3834:                                   ; preds = %3831
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3747, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.165, i64 0, i64 0)) #18
  unreachable

; <label>:3835:                                   ; preds = %3828, %3831
  %3836 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 2, i32 0, i32 1
  %3837 = load i8, i8* %3836, align 8, !tbaa !22
  %3838 = icmp eq i8 %3837, 19
  br i1 %3838, label %3839, label %3842

; <label>:3839:                                   ; preds = %3835
  %3840 = bitcast %struct.TValue* %3748 to i64*
  %3841 = load i64, i64* %3840, align 8, !tbaa !21
  store i64 %3841, i64* %103, align 8, !tbaa !140
  br label %3846

; <label>:3842:                                   ; preds = %3835
  %3843 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3748, double* nonnull %25) #16
  %3844 = icmp eq i32 %3843, 0
  br i1 %3844, label %3845, label %3846, !prof !61

; <label>:3845:                                   ; preds = %3842
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3748, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.166, i64 0, i64 0)) #18
  unreachable

; <label>:3846:                                   ; preds = %3839, %3842
  %3847 = load i8, i8* %3750, align 8, !tbaa !22
  %3848 = icmp eq i8 %3847, 19
  br i1 %3848, label %3849, label %3852

; <label>:3849:                                   ; preds = %3846
  %3850 = bitcast %union.StackValue* %4314 to i64*
  %3851 = load i64, i64* %3850, align 8, !tbaa !21
  store i64 %3851, i64* %107, align 8, !tbaa !140
  br label %3856

; <label>:3852:                                   ; preds = %3846
  %3853 = call fastcc i32 @luaV_tonumber_(%struct.TValue* nonnull %3746, double* nonnull %23) #16
  %3854 = icmp eq i32 %3853, 0
  br i1 %3854, label %3855, label %3856, !prof !61

; <label>:3855:                                   ; preds = %3852
  call fastcc void @luaG_forerror(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %3746, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.167, i64 0, i64 0)) #18
  unreachable

; <label>:3856:                                   ; preds = %3849, %3852
  %3857 = load double, double* %25, align 8, !tbaa !140
  %3858 = fcmp oeq double %3857, 0.000000e+00
  br i1 %3858, label %3859, label %3860

; <label>:3859:                                   ; preds = %3856
  call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.164, i64 0, i64 0)) #18
  unreachable

; <label>:3860:                                   ; preds = %3856
  %3861 = fcmp ogt double %3857, 0.000000e+00
  br i1 %3861, label %3862, label %3866

; <label>:3862:                                   ; preds = %3860
  %3863 = load double, double* %24, align 8, !tbaa !140
  %3864 = load double, double* %23, align 8, !tbaa !140
  %3865 = fcmp olt double %3863, %3864
  br i1 %3865, label %3870, label %3875

; <label>:3866:                                   ; preds = %3860
  %3867 = load double, double* %23, align 8, !tbaa !140
  %3868 = load double, double* %24, align 8, !tbaa !140
  %3869 = fcmp olt double %3867, %3868
  br i1 %3869, label %3870, label %3875

; <label>:3870:                                   ; preds = %3866, %3862
  %3871 = lshr i32 %4307, 15
  %3872 = add nuw nsw i32 %3871, 1
  %3873 = zext i32 %3872 to i64
  %3874 = getelementptr inbounds i32, i32* %4310, i64 %3873
  br label %3885

; <label>:3875:                                   ; preds = %3866, %3862
  %3876 = phi double [ %3867, %3866 ], [ %3864, %3862 ]
  %3877 = phi double [ %3868, %3866 ], [ %3863, %3862 ]
  %3878 = bitcast %struct.TValue* %3747 to double*
  store double %3877, double* %3878, align 8, !tbaa !21
  store i8 19, i8* %3825, align 8, !tbaa !22
  %3879 = bitcast %struct.TValue* %3748 to double*
  store double %3857, double* %3879, align 8, !tbaa !21
  store i8 19, i8* %3836, align 8, !tbaa !22
  %3880 = bitcast %union.StackValue* %4314 to double*
  store double %3876, double* %3880, align 8, !tbaa !21
  store i8 19, i8* %3750, align 8, !tbaa !22
  %3881 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0
  %3882 = load i64, i64* %107, align 8, !tbaa !140
  %3883 = bitcast %struct.TValue* %3881 to i64*
  store i64 %3882, i64* %3883, align 8, !tbaa !21
  %3884 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0, i32 1
  store i8 19, i8* %3884, align 8, !tbaa !22
  br label %3885

; <label>:3885:                                   ; preds = %3870, %3875, %3805, %3820
  %3886 = phi i32* [ %3809, %3805 ], [ %4310, %3820 ], [ %3874, %3870 ], [ %4310, %3875 ]
  %3887 = icmp eq i32 %4309, 0
  br i1 %3887, label %3892, label %3888

; <label>:3888:                                   ; preds = %3885
  %3889 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* nonnull %3886) #16
  %3890 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3891 = getelementptr inbounds %union.StackValue, %union.StackValue* %3890, i64 1
  br label %3892

; <label>:3892:                                   ; preds = %3885, %3888
  %3893 = phi i32 [ %3889, %3888 ], [ 0, %3885 ]
  %3894 = phi %union.StackValue* [ %3891, %3888 ], [ %4308, %3885 ]
  %3895 = getelementptr inbounds i32, i32* %3886, i64 1
  %3896 = load i32, i32* %3886, align 4, !tbaa !77
  br label %162

; <label>:3897:                                   ; preds = %4306
  %3898 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3, i32 0, i32 1
  %3899 = load i8, i8* %3898, align 8, !tbaa !21
  %3900 = and i8 %3899, 15
  %3901 = icmp eq i8 %3900, 0
  br i1 %3901, label %3904, label %3902

; <label>:3902:                                   ; preds = %3897
  %3903 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 3
  store i32* %4310, i32** %31, align 8, !tbaa !21
  call fastcc void @luaF_newtbcupval(%struct.lua_State* %0, %union.StackValue* nonnull %3903) #16
  br label %3904

; <label>:3904:                                   ; preds = %3902, %3897
  %3905 = lshr i32 %4307, 15
  %3906 = zext i32 %3905 to i64
  %3907 = getelementptr inbounds i32, i32* %4310, i64 %3906
  %3908 = getelementptr inbounds i32, i32* %3907, i64 1
  %3909 = load i32, i32* %3907, align 4, !tbaa !77
  br label %3910

; <label>:3910:                                   ; preds = %4306, %3904
  %3911 = phi i32 [ %4307, %4306 ], [ %3909, %3904 ]
  %3912 = phi i32* [ %4310, %4306 ], [ %3908, %3904 ]
  %3913 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 4
  %3914 = bitcast %union.StackValue* %3913 to i8*
  %3915 = bitcast %union.StackValue* %4314 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %3914, i8* %3915, i64 48, i32 8, i1 false)
  store i32* %3912, i32** %31, align 8, !tbaa !21
  %3916 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3916, i64* %35, align 8, !tbaa !20
  %3917 = lshr i32 %3911, 24
  call fastcc void @luaD_call(%struct.lua_State* %0, %union.StackValue* nonnull %3913, i32 %3917) #16
  %3918 = load i32, i32* %38, align 8, !tbaa !21
  %3919 = icmp eq i32 %3918, 0
  br i1 %3919, label %3927, label %3920

; <label>:3920:                                   ; preds = %3910
  %3921 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3922 = getelementptr inbounds %union.StackValue, %union.StackValue* %3921, i64 1
  %3923 = lshr i32 %3911, 7
  %3924 = and i32 %3923, 255
  %3925 = zext i32 %3924 to i64
  %3926 = getelementptr inbounds %union.StackValue, %union.StackValue* %3922, i64 %3925
  br label %3927

; <label>:3927:                                   ; preds = %3910, %3920
  %3928 = phi %union.StackValue* [ %3926, %3920 ], [ %4314, %3910 ]
  %3929 = phi %union.StackValue* [ %3922, %3920 ], [ %4308, %3910 ]
  %3930 = getelementptr inbounds i32, i32* %3912, i64 1
  %3931 = load i32, i32* %3912, align 4, !tbaa !77
  %3932 = getelementptr inbounds %union.StackValue, %union.StackValue* %3928, i64 2
  br label %3933

; <label>:3933:                                   ; preds = %4306, %3927
  %3934 = phi %union.StackValue* [ %4314, %4306 ], [ %3932, %3927 ]
  %3935 = phi i32 [ %4307, %4306 ], [ %3931, %3927 ]
  %3936 = phi i32 [ %4309, %4306 ], [ %3918, %3927 ]
  %3937 = phi i32* [ %4310, %4306 ], [ %3930, %3927 ]
  %3938 = phi %union.StackValue* [ %4308, %4306 ], [ %3929, %3927 ]
  %3939 = getelementptr inbounds %union.StackValue, %union.StackValue* %3934, i64 2, i32 0, i32 1
  %3940 = load i8, i8* %3939, align 8, !tbaa !21
  %3941 = and i8 %3940, 15
  %3942 = icmp eq i8 %3941, 0
  br i1 %3942, label %3953, label %3943

; <label>:3943:                                   ; preds = %3933
  %3944 = getelementptr inbounds %union.StackValue, %union.StackValue* %3934, i64 2, i32 0, i32 0
  %3945 = bitcast %union.Value* %3944 to i64*
  %3946 = bitcast %union.StackValue* %3934 to i64*
  %3947 = load i64, i64* %3945, align 8
  store i64 %3947, i64* %3946, align 8
  %3948 = getelementptr inbounds %union.StackValue, %union.StackValue* %3934, i64 0, i32 0, i32 1
  store i8 %3940, i8* %3948, align 8, !tbaa !22
  %3949 = lshr i32 %3935, 15
  %3950 = zext i32 %3949 to i64
  %3951 = sub nsw i64 0, %3950
  %3952 = getelementptr inbounds i32, i32* %3937, i64 %3951
  br label %3953

; <label>:3953:                                   ; preds = %3943, %3933
  %3954 = phi i32* [ %3937, %3933 ], [ %3952, %3943 ]
  %3955 = icmp eq i32 %3936, 0
  br i1 %3955, label %3960, label %3956

; <label>:3956:                                   ; preds = %3953
  %3957 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3954) #16
  %3958 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %3959 = getelementptr inbounds %union.StackValue, %union.StackValue* %3958, i64 1
  br label %3960

; <label>:3960:                                   ; preds = %3953, %3956
  %3961 = phi i32 [ %3957, %3956 ], [ 0, %3953 ]
  %3962 = phi %union.StackValue* [ %3959, %3956 ], [ %3938, %3953 ]
  %3963 = getelementptr inbounds i32, i32* %3954, i64 1
  %3964 = load i32, i32* %3954, align 4, !tbaa !77
  br label %162

; <label>:3965:                                   ; preds = %4306
  %3966 = lshr i32 %4307, 16
  %3967 = and i32 %3966, 255
  %3968 = lshr i32 %4307, 24
  %3969 = icmp eq i32 %3967, 0
  br i1 %3969, label %3970, label %3977

; <label>:3970:                                   ; preds = %3965
  %3971 = load i64, i64* %35, align 8, !tbaa !20
  %3972 = ptrtoint %union.StackValue* %4314 to i64
  %3973 = sub i64 %3971, %3972
  %3974 = lshr exact i64 %3973, 4
  %3975 = trunc i64 %3974 to i32
  %3976 = add nsw i32 %3975, -1
  br label %3979

; <label>:3977:                                   ; preds = %3965
  %3978 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %3978, i64* %35, align 8, !tbaa !20
  br label %3979

; <label>:3979:                                   ; preds = %3977, %3970
  %3980 = phi i32 [ %3976, %3970 ], [ %3967, %3977 ]
  %3981 = icmp eq i32 %3968, 0
  br i1 %3981, label %3982, label %3986

; <label>:3982:                                   ; preds = %3979
  %3983 = load i32, i32* %4310, align 4, !tbaa !77
  %3984 = lshr i32 %3983, 7
  %3985 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %3986

; <label>:3986:                                   ; preds = %3982, %3979
  %3987 = phi i32 [ %3984, %3982 ], [ %3968, %3979 ]
  %3988 = phi i32* [ %3985, %3982 ], [ %4310, %3979 ]
  %3989 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 0, i32 0, i32 0, i32 0
  %3990 = load %struct.GCObject*, %struct.GCObject** %3989, align 8, !tbaa !21
  %3991 = bitcast %struct.GCObject* %3990 to %struct.Table*
  %3992 = mul nuw nsw i32 %3987, 50
  %3993 = add i32 %3980, -50
  %3994 = add i32 %3993, %3992
  %3995 = call fastcc i32 @luaH_realasize(%struct.Table* %3991) #16
  %3996 = icmp ugt i32 %3994, %3995
  br i1 %3996, label %3997, label %4009

; <label>:3997:                                   ; preds = %3986
  %3998 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3990, i64 2
  %3999 = bitcast %struct.GCObject* %3998 to %union.Node**
  %4000 = load %union.Node*, %union.Node** %3999, align 8, !tbaa !147
  %4001 = icmp eq %union.Node* %4000, null
  br i1 %4001, label %4007, label %4002

; <label>:4002:                                   ; preds = %3997
  %4003 = getelementptr inbounds %struct.Table, %struct.Table* %3991, i64 0, i32 4
  %4004 = load i8, i8* %4003, align 1, !tbaa !93
  %4005 = zext i8 %4004 to i32
  %4006 = shl i32 1, %4005
  br label %4007

; <label>:4007:                                   ; preds = %3997, %4002
  %4008 = phi i32 [ %4006, %4002 ], [ 0, %3997 ]
  call fastcc void @luaH_resize(%struct.lua_State* nonnull %0, %struct.Table* nonnull %3991, i32 %3994, i32 %4008) #17
  br label %4009

; <label>:4009:                                   ; preds = %4007, %3986
  %4010 = icmp sgt i32 %3980, 0
  br i1 %4010, label %4011, label %4048

; <label>:4011:                                   ; preds = %4009
  %4012 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3990, i64 1
  %4013 = bitcast %struct.GCObject* %4012 to %struct.TValue**
  %4014 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %3990, i64 0, i32 2
  %4015 = sext i32 %3980 to i64
  br label %4016

; <label>:4016:                                   ; preds = %4011, %4045
  %4017 = phi i64 [ %4015, %4011 ], [ %4046, %4045 ]
  %4018 = phi i32 [ %3994, %4011 ], [ %4021, %4045 ]
  %4019 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %4017, i32 0
  %4020 = load %struct.TValue*, %struct.TValue** %4013, align 8, !tbaa !91
  %4021 = add i32 %4018, -1
  %4022 = zext i32 %4021 to i64
  %4023 = getelementptr inbounds %struct.TValue, %struct.TValue* %4020, i64 %4022
  %4024 = bitcast %struct.TValue* %4019 to i64*
  %4025 = bitcast %struct.TValue* %4023 to i64*
  %4026 = load i64, i64* %4024, align 8
  store i64 %4026, i64* %4025, align 8
  %4027 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 %4017, i32 0, i32 1
  %4028 = load i8, i8* %4027, align 8, !tbaa !22
  %4029 = getelementptr inbounds %struct.TValue, %struct.TValue* %4020, i64 %4022, i32 1
  store i8 %4028, i8* %4029, align 8, !tbaa !22
  %4030 = load i8, i8* %4027, align 8, !tbaa !22
  %4031 = and i8 %4030, 64
  %4032 = icmp eq i8 %4031, 0
  br i1 %4032, label %4045, label %4033

; <label>:4033:                                   ; preds = %4016
  %4034 = load i8, i8* %4014, align 1, !tbaa !21
  %4035 = and i8 %4034, 32
  %4036 = icmp eq i8 %4035, 0
  br i1 %4036, label %4045, label %4037

; <label>:4037:                                   ; preds = %4033
  %4038 = getelementptr inbounds %struct.TValue, %struct.TValue* %4019, i64 0, i32 0, i32 0
  %4039 = load %struct.GCObject*, %struct.GCObject** %4038, align 8, !tbaa !21
  %4040 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %4039, i64 0, i32 2
  %4041 = load i8, i8* %4040, align 1, !tbaa !70
  %4042 = and i8 %4041, 24
  %4043 = icmp eq i8 %4042, 0
  br i1 %4043, label %4045, label %4044

; <label>:4044:                                   ; preds = %4037
  call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* nonnull %3990) #16
  br label %4045

; <label>:4045:                                   ; preds = %4037, %4033, %4016, %4044
  %4046 = add nsw i64 %4017, -1
  %4047 = icmp sgt i64 %4017, 1
  br i1 %4047, label %4016, label %4048

; <label>:4048:                                   ; preds = %4045, %4009
  %4049 = icmp eq i32 %4309, 0
  br i1 %4049, label %4054, label %4050

; <label>:4050:                                   ; preds = %4048
  %4051 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %3988) #16
  %4052 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4053 = getelementptr inbounds %union.StackValue, %union.StackValue* %4052, i64 1
  br label %4054

; <label>:4054:                                   ; preds = %4048, %4050
  %4055 = phi i32 [ %4051, %4050 ], [ 0, %4048 ]
  %4056 = phi %union.StackValue* [ %4053, %4050 ], [ %4308, %4048 ]
  %4057 = getelementptr inbounds i32, i32* %3988, i64 1
  %4058 = load i32, i32* %3988, align 4, !tbaa !77
  br label %162

; <label>:4059:                                   ; preds = %4306
  %4060 = load %struct.Proto*, %struct.Proto** %115, align 8, !tbaa !197
  %4061 = getelementptr inbounds %struct.Proto, %struct.Proto* %4060, i64 0, i32 17
  %4062 = load %struct.Proto**, %struct.Proto*** %4061, align 8, !tbaa !221
  %4063 = lshr i32 %4307, 15
  %4064 = zext i32 %4063 to i64
  %4065 = getelementptr inbounds %struct.Proto*, %struct.Proto** %4062, i64 %4064
  %4066 = load %struct.Proto*, %struct.Proto** %4065, align 8, !tbaa !54
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %4067 = getelementptr inbounds %struct.Proto, %struct.Proto* %4066, i64 0, i32 6
  %4068 = load i32, i32* %4067, align 8, !tbaa !190
  %4069 = getelementptr inbounds %struct.Proto, %struct.Proto* %4066, i64 0, i32 18
  %4070 = load %struct.Upvaldesc*, %struct.Upvaldesc** %4069, align 8, !tbaa !198
  %4071 = call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %4068) #17
  %4072 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4071, i64 0, i32 5
  store %struct.Proto* %4066, %struct.Proto** %4072, align 8, !tbaa !197
  %4073 = bitcast %struct.LClosure* %4071 to %struct.GCObject*
  %4074 = bitcast %union.StackValue* %4314 to %struct.LClosure**
  store %struct.LClosure* %4071, %struct.LClosure** %4074, align 8, !tbaa !21
  %4075 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313, i32 0, i32 1
  store i8 86, i8* %4075, align 8, !tbaa !22
  %4076 = icmp sgt i32 %4068, 0
  br i1 %4076, label %4077, label %4114

; <label>:4077:                                   ; preds = %4059
  %4078 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4071, i64 0, i32 2
  %4079 = zext i32 %4068 to i64
  br label %4080

; <label>:4080:                                   ; preds = %4111, %4077
  %4081 = phi i64 [ 0, %4077 ], [ %4112, %4111 ]
  %4082 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %4070, i64 %4081, i32 1
  %4083 = load i8, i8* %4082, align 8, !tbaa !240
  %4084 = icmp eq i8 %4083, 0
  %4085 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %4070, i64 %4081, i32 2
  %4086 = load i8, i8* %4085, align 1, !tbaa !241
  %4087 = zext i8 %4086 to i64
  br i1 %4084, label %4092, label %4088

; <label>:4088:                                   ; preds = %4080
  %4089 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4087
  %4090 = call fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State* %0, %union.StackValue* %4089) #17
  %4091 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4071, i64 0, i32 6, i64 %4081
  store %struct.UpVal* %4090, %struct.UpVal** %4091, align 8, !tbaa !54
  br label %4099

; <label>:4092:                                   ; preds = %4080
  %4093 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %114, i64 0, i32 6, i64 %4087
  %4094 = bitcast %struct.UpVal** %4093 to i64*
  %4095 = load i64, i64* %4094, align 8, !tbaa !54
  %4096 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %4071, i64 0, i32 6, i64 %4081
  %4097 = bitcast %struct.UpVal** %4096 to i64*
  store i64 %4095, i64* %4097, align 8, !tbaa !54
  %4098 = inttoptr i64 %4095 to %struct.UpVal*
  br label %4099

; <label>:4099:                                   ; preds = %4092, %4088
  %4100 = phi %struct.UpVal* [ %4098, %4092 ], [ %4090, %4088 ]
  %4101 = load i8, i8* %4078, align 1, !tbaa !201
  %4102 = and i8 %4101, 32
  %4103 = icmp eq i8 %4102, 0
  br i1 %4103, label %4111, label %4104

; <label>:4104:                                   ; preds = %4099
  %4105 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %4100, i64 0, i32 2
  %4106 = load i8, i8* %4105, align 1, !tbaa !69
  %4107 = and i8 %4106, 24
  %4108 = icmp eq i8 %4107, 0
  br i1 %4108, label %4111, label %4109

; <label>:4109:                                   ; preds = %4104
  %4110 = bitcast %struct.UpVal* %4100 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* %0, %struct.GCObject* nonnull %4073, %struct.GCObject* %4110) #17
  br label %4111

; <label>:4111:                                   ; preds = %4109, %4104, %4099
  %4112 = add nuw nsw i64 %4081, 1
  %4113 = icmp eq i64 %4112, %4079
  br i1 %4113, label %4114, label %4080

; <label>:4114:                                   ; preds = %4111, %4059
  %4115 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %4116 = getelementptr inbounds %struct.global_State, %struct.global_State* %4115, i64 0, i32 3
  %4117 = load i64, i64* %4116, align 8, !tbaa !11
  %4118 = icmp sgt i64 %4117, 0
  br i1 %4118, label %4119, label %4122

; <label>:4119:                                   ; preds = %4114
  %4120 = getelementptr inbounds %union.StackValue, %union.StackValue* %4314, i64 1
  store %union.StackValue* %4120, %union.StackValue** %34, align 8, !tbaa !20
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #16
  %4121 = load i32, i32* %38, align 8, !tbaa !21
  br label %4122

; <label>:4122:                                   ; preds = %4119, %4114
  %4123 = phi i32 [ %4121, %4119 ], [ %4309, %4114 ]
  %4124 = icmp eq i32 %4123, 0
  br i1 %4124, label %4129, label %4125

; <label>:4125:                                   ; preds = %4122
  %4126 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %4310) #16
  %4127 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4128 = getelementptr inbounds %union.StackValue, %union.StackValue* %4127, i64 1
  br label %4129

; <label>:4129:                                   ; preds = %4122, %4125
  %4130 = phi i32 [ %4126, %4125 ], [ 0, %4122 ]
  %4131 = phi %union.StackValue* [ %4128, %4125 ], [ %4308, %4122 ]
  %4132 = getelementptr inbounds i32, i32* %4310, i64 1
  %4133 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:4134:                                   ; preds = %4306
  %4135 = lshr i32 %4307, 24
  %4136 = add nsw i32 %4135, -1
  store i32* %4310, i32** %31, align 8, !tbaa !21
  %4137 = load i64, i64* %33, align 8, !tbaa !66
  store i64 %4137, i64* %35, align 8, !tbaa !20
  %4138 = load i32, i32* %39, align 4, !tbaa !21
  %4139 = icmp eq i32 %4135, 0
  br i1 %4139, label %4140, label %4163

; <label>:4140:                                   ; preds = %4134
  %4141 = load i64, i64* %42, align 8, !tbaa !62
  %4142 = sub i64 %4141, %4137
  %4143 = ashr exact i64 %4142, 4
  %4144 = sext i32 %4138 to i64
  %4145 = icmp sgt i64 %4143, %4144
  br i1 %4145, label %4160, label %4146

; <label>:4146:                                   ; preds = %4140
  %4147 = load i64, i64* %102, align 8, !tbaa !23
  %4148 = ptrtoint %union.StackValue* %4314 to i64
  %4149 = sub i64 %4148, %4147
  %4150 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %4151 = getelementptr inbounds %struct.global_State, %struct.global_State* %4150, i64 0, i32 3
  %4152 = load i64, i64* %4151, align 8, !tbaa !11
  %4153 = icmp sgt i64 %4152, 0
  br i1 %4153, label %4154, label %4155

; <label>:4154:                                   ; preds = %4146
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %4155

; <label>:4155:                                   ; preds = %4154, %4146
  %4156 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %4138, i32 1) #17
  %4157 = load i8*, i8** %104, align 8, !tbaa !23
  %4158 = getelementptr inbounds i8, i8* %4157, i64 %4149
  %4159 = bitcast i8* %4158 to %union.StackValue*
  br label %4160

; <label>:4160:                                   ; preds = %4155, %4140
  %4161 = phi %union.StackValue* [ %4159, %4155 ], [ %4314, %4140 ]
  %4162 = getelementptr inbounds %union.StackValue, %union.StackValue* %4161, i64 %4144
  store %union.StackValue* %4162, %union.StackValue** %34, align 8, !tbaa !20
  br label %4163

; <label>:4163:                                   ; preds = %4160, %4134
  %4164 = phi i32 [ %4138, %4160 ], [ %4136, %4134 ]
  %4165 = phi %union.StackValue* [ %4161, %4160 ], [ %4314, %4134 ]
  %4166 = icmp sgt i32 %4164, 0
  %4167 = icmp sgt i32 %4138, 0
  %4168 = and i1 %4166, %4167
  br i1 %4168, label %4169, label %4191

; <label>:4169:                                   ; preds = %4163
  %4170 = sext i32 %4138 to i64
  %4171 = sub nsw i64 0, %4170
  %4172 = sext i32 %4164 to i64
  br label %4173

; <label>:4173:                                   ; preds = %4169, %4173
  %4174 = phi i64 [ 0, %4169 ], [ %4185, %4173 ]
  %4175 = getelementptr inbounds %union.StackValue, %union.StackValue* %4165, i64 %4174, i32 0
  %4176 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4177 = getelementptr inbounds %union.StackValue, %union.StackValue* %4176, i64 %4171
  %4178 = getelementptr inbounds %union.StackValue, %union.StackValue* %4177, i64 %4174
  %4179 = bitcast %union.StackValue* %4178 to i64*
  %4180 = bitcast %struct.TValue* %4175 to i64*
  %4181 = load i64, i64* %4179, align 8
  store i64 %4181, i64* %4180, align 8
  %4182 = getelementptr inbounds %union.StackValue, %union.StackValue* %4178, i64 0, i32 0, i32 1
  %4183 = load i8, i8* %4182, align 8, !tbaa !22
  %4184 = getelementptr inbounds %union.StackValue, %union.StackValue* %4165, i64 %4174, i32 0, i32 1
  store i8 %4183, i8* %4184, align 8, !tbaa !22
  %4185 = add nuw nsw i64 %4174, 1
  %4186 = icmp slt i64 %4185, %4172
  %4187 = icmp slt i64 %4185, %4170
  %4188 = and i1 %4186, %4187
  br i1 %4188, label %4173, label %4189

; <label>:4189:                                   ; preds = %4173
  %4190 = trunc i64 %4185 to i32
  br label %4191

; <label>:4191:                                   ; preds = %4189, %4163
  %4192 = phi i32 [ 0, %4163 ], [ %4190, %4189 ]
  %4193 = icmp slt i32 %4192, %4164
  br i1 %4193, label %4194, label %4203

; <label>:4194:                                   ; preds = %4191
  %4195 = zext i32 %4192 to i64
  br label %4196

; <label>:4196:                                   ; preds = %4196, %4194
  %4197 = phi i64 [ %4195, %4194 ], [ %4200, %4196 ]
  %4198 = phi i32 [ %4192, %4194 ], [ %4201, %4196 ]
  %4199 = getelementptr inbounds %union.StackValue, %union.StackValue* %4165, i64 %4197, i32 0, i32 1
  store i8 0, i8* %4199, align 8, !tbaa !21
  %4200 = add nuw nsw i64 %4197, 1
  %4201 = add nuw nsw i32 %4198, 1
  %4202 = icmp eq i32 %4201, %4164
  br i1 %4202, label %4203, label %4196

; <label>:4203:                                   ; preds = %4196, %4191
  %4204 = load i32, i32* %38, align 8, !tbaa !21
  %4205 = icmp eq i32 %4204, 0
  br i1 %4205, label %4210, label %4206

; <label>:4206:                                   ; preds = %4203
  %4207 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* %4310) #16
  %4208 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4209 = getelementptr inbounds %union.StackValue, %union.StackValue* %4208, i64 1
  br label %4210

; <label>:4210:                                   ; preds = %4203, %4206
  %4211 = phi i32 [ %4207, %4206 ], [ 0, %4203 ]
  %4212 = phi %union.StackValue* [ %4209, %4206 ], [ %4308, %4203 ]
  %4213 = getelementptr inbounds i32, i32* %4310, i64 1
  %4214 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:4215:                                   ; preds = %4306
  %4216 = lshr i32 %4307, 7
  %4217 = and i32 %4216, 255
  %4218 = load %struct.Proto*, %struct.Proto** %115, align 8, !tbaa !197
  %4219 = load i64, i64* %35, align 8, !tbaa !20
  %4220 = load i64, i64* %40, align 8, !tbaa !64
  %4221 = sub i64 %4219, %4220
  %4222 = lshr exact i64 %4221, 4
  %4223 = trunc i64 %4222 to i32
  %4224 = xor i32 %4217, -1
  %4225 = add i32 %4224, %4223
  store i32 %4225, i32* %39, align 4, !tbaa !21
  %4226 = load i64, i64* %42, align 8, !tbaa !62
  %4227 = load i64, i64* %35, align 8, !tbaa !20
  %4228 = sub i64 %4226, %4227
  %4229 = ashr exact i64 %4228, 4
  %4230 = getelementptr inbounds %struct.Proto, %struct.Proto* %4218, i64 0, i32 5
  %4231 = load i8, i8* %4230, align 4, !tbaa !158
  %4232 = zext i8 %4231 to i32
  %4233 = add nuw nsw i32 %4232, 1
  %4234 = zext i32 %4233 to i64
  %4235 = icmp sgt i64 %4229, %4234
  br i1 %4235, label %4243, label %4236

; <label>:4236:                                   ; preds = %4215
  %4237 = call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 %4233, i32 1) #17
  %4238 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %4239 = getelementptr inbounds %struct.global_State, %struct.global_State* %4238, i64 0, i32 3
  %4240 = load i64, i64* %4239, align 8, !tbaa !11
  %4241 = icmp sgt i64 %4240, 0
  br i1 %4241, label %4242, label %4243

; <label>:4242:                                   ; preds = %4236
  call fastcc void @luaC_step(%struct.lua_State* nonnull %0) #17
  br label %4243

; <label>:4243:                                   ; preds = %4242, %4236, %4215
  %4244 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %4245 = getelementptr inbounds %union.StackValue, %union.StackValue* %4244, i64 1
  store %union.StackValue* %4245, %union.StackValue** %34, align 8, !tbaa !20
  %4246 = load %struct.TValue*, %struct.TValue** %72, align 8, !tbaa !64
  %4247 = bitcast %struct.TValue* %4246 to i64*
  %4248 = bitcast %union.StackValue* %4244 to i64*
  %4249 = load i64, i64* %4247, align 8
  store i64 %4249, i64* %4248, align 8
  %4250 = getelementptr inbounds %struct.TValue, %struct.TValue* %4246, i64 0, i32 1
  %4251 = load i8, i8* %4250, align 8, !tbaa !22
  %4252 = getelementptr inbounds %union.StackValue, %union.StackValue* %4244, i64 0, i32 0, i32 1
  store i8 %4251, i8* %4252, align 8, !tbaa !22
  %4253 = icmp eq i32 %4217, 0
  br i1 %4253, label %4273, label %4254

; <label>:4254:                                   ; preds = %4243
  %4255 = add nuw nsw i32 %4217, 1
  %4256 = zext i32 %4255 to i64
  br label %4257

; <label>:4257:                                   ; preds = %4257, %4254
  %4258 = phi i64 [ %4271, %4257 ], [ 1, %4254 ]
  %4259 = load %union.StackValue*, %union.StackValue** %34, align 8, !tbaa !20
  %4260 = getelementptr inbounds %union.StackValue, %union.StackValue* %4259, i64 1
  store %union.StackValue* %4260, %union.StackValue** %34, align 8, !tbaa !20
  %4261 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4262 = getelementptr inbounds %union.StackValue, %union.StackValue* %4261, i64 %4258, i32 0
  %4263 = bitcast %struct.TValue* %4262 to i64*
  %4264 = bitcast %union.StackValue* %4259 to i64*
  %4265 = load i64, i64* %4263, align 8
  store i64 %4265, i64* %4264, align 8
  %4266 = getelementptr inbounds %union.StackValue, %union.StackValue* %4261, i64 %4258, i32 0, i32 1
  %4267 = load i8, i8* %4266, align 8, !tbaa !22
  %4268 = getelementptr inbounds %union.StackValue, %union.StackValue* %4259, i64 0, i32 0, i32 1
  store i8 %4267, i8* %4268, align 8, !tbaa !22
  %4269 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4270 = getelementptr inbounds %union.StackValue, %union.StackValue* %4269, i64 %4258, i32 0, i32 1
  store i8 0, i8* %4270, align 8, !tbaa !21
  %4271 = add nuw nsw i64 %4258, 1
  %4272 = icmp eq i64 %4271, %4256
  br i1 %4272, label %4273, label %4257

; <label>:4273:                                   ; preds = %4257, %4243
  %4274 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4275 = shl i64 %4221, 28
  %4276 = ashr exact i64 %4275, 32
  %4277 = getelementptr inbounds %union.StackValue, %union.StackValue* %4274, i64 %4276
  store %union.StackValue* %4277, %union.StackValue** %27, align 8, !tbaa !64
  %4278 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !66
  %4279 = getelementptr inbounds %union.StackValue, %union.StackValue* %4278, i64 %4276
  store %union.StackValue* %4279, %union.StackValue** %32, align 8, !tbaa !66
  %4280 = load i32, i32* %38, align 8, !tbaa !21
  %4281 = icmp eq i32 %4280, 0
  br i1 %4281, label %4282, label %4284

; <label>:4282:                                   ; preds = %4273
  %4283 = getelementptr inbounds i32, i32* %4310, i64 1
  br label %4288

; <label>:4284:                                   ; preds = %4273
  call fastcc void @luaD_hookcall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %1) #16
  %4285 = getelementptr inbounds i32, i32* %4310, i64 1
  store i32* %4285, i32** %105, align 8, !tbaa !104
  %4286 = call fastcc i32 @luaG_traceexec(%struct.lua_State* nonnull %0, i32* %4310) #16
  %4287 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  br label %4288

; <label>:4288:                                   ; preds = %4282, %4284
  %4289 = phi i32* [ %4283, %4282 ], [ %4285, %4284 ]
  %4290 = phi %union.StackValue* [ %4277, %4282 ], [ %4287, %4284 ]
  %4291 = phi i32 [ 0, %4282 ], [ %4286, %4284 ]
  %4292 = getelementptr inbounds %union.StackValue, %union.StackValue* %4290, i64 1
  %4293 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:4294:                                   ; preds = %4306
  %4295 = icmp eq i32 %4309, 0
  br i1 %4295, label %4300, label %4296

; <label>:4296:                                   ; preds = %4294
  %4297 = call fastcc i32 @luaG_traceexec(%struct.lua_State* %0, i32* nonnull %4310) #16
  %4298 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %4299 = getelementptr inbounds %union.StackValue, %union.StackValue* %4298, i64 1
  br label %4300

; <label>:4300:                                   ; preds = %4294, %4296
  %4301 = phi i32 [ %4297, %4296 ], [ 0, %4294 ]
  %4302 = phi %union.StackValue* [ %4299, %4296 ], [ %4308, %4294 ]
  %4303 = getelementptr inbounds i32, i32* %4310, i64 1
  %4304 = load i32, i32* %4310, align 4, !tbaa !77
  br label %162

; <label>:4305:                                   ; preds = %3679, %3641, %3673, %3636, %3665, %3626, %3652, %3664, %3625, %3621, %3504
  ret void

; <label>:4306:                                   ; preds = %162, %135
  %4307 = phi i32 [ %140, %135 ], [ %163, %162 ]
  %4308 = phi %union.StackValue* [ %138, %135 ], [ %164, %162 ]
  %4309 = phi i32 [ %137, %135 ], [ %165, %162 ]
  %4310 = phi i32* [ %139, %135 ], [ %166, %162 ]
  %4311 = lshr i32 %4307, 7
  %4312 = and i32 %4311, 255
  %4313 = zext i32 %4312 to i64
  %4314 = getelementptr inbounds %union.StackValue, %union.StackValue* %4308, i64 %4313
  %4315 = and i32 %4307, 127
  %4316 = zext i32 %4315 to i64
  %4317 = getelementptr inbounds [84 x i8*], [84 x i8*]* @luaV_execute.disptab, i64 0, i64 %4316
  %4318 = load i8*, i8** %4317, align 8, !tbaa !54
  indirectbr i8* %4318, [label %141, label %187, label %203, label %167, label %219, label %241, label %259, label %280, label %304, label %346, label %392, label %465, label %519, label %562, label %634, label %730, label %807, label %873, label %944, label %997, label %1038, label %1077, label %1118, label %1168, label %1206, label %1244, label %1284, label %1345, label %1404, label %1465, label %1535, label %1583, label %1631, label %2094, label %2141, label %2188, label %2421, label %2485, label %1691, label %1750, label %1809, label %1868, label %1938, label %1986, label %2034, label %2235, label %2297, label %2359, label %2614, label %2541, label %2687, label %2721, label %2762, label %2792, label %2809, label %2831, label %2845, label %2856, label %2872, label %2902, label %2966, label %3030, label %3062, label %3108, label %3166, label %3224, label %3282, label %3340, label %3382, label %3433, label %3454, label %3591, label %3622, label %3648, label %3686, label %3745, label %3897, label %3910, label %3933, label %3965, label %4059, label %4134, label %4215, label %4294]
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_poscall(%struct.lua_State*, %struct.CallInfo* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %5 = load i32, i32* %4, align 8, !tbaa !31
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %11

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %9 = bitcast %struct.CallInfo** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !105
  br label %88

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = sext i32 %2 to i64
  %15 = sub nsw i64 0, %14
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 %15
  %17 = ptrtoint %union.StackValue* %13 to i64
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %19 = bitcast %union.StackValue** %18 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !23
  %21 = sub i64 %17, %20
  %22 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %23 = load i16, i16* %22, align 2, !tbaa !63
  %24 = and i16 %23, 6
  %25 = icmp eq i16 %24, 0
  br i1 %25, label %26, label %51

; <label>:26:                                     ; preds = %11
  %27 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %28 = load %struct.LClosure**, %struct.LClosure*** %27, align 8, !tbaa !64
  %29 = load %struct.LClosure*, %struct.LClosure** %28, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %29, i64 0, i32 5
  %31 = load %struct.Proto*, %struct.Proto** %30, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 4
  %33 = load i8, i8* %32, align 1, !tbaa !115
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %45, label %35

; <label>:35:                                     ; preds = %26
  %36 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %37 = bitcast %union.anon.0* %36 to %struct.anon*
  %38 = getelementptr inbounds %struct.anon, %struct.anon* %37, i64 0, i32 2
  %39 = load i32, i32* %38, align 4, !tbaa !21
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 3
  %41 = load i8, i8* %40, align 2, !tbaa !131
  %42 = zext i8 %41 to i32
  %43 = add i32 %39, 1
  %44 = add i32 %43, %42
  br label %45

; <label>:45:                                     ; preds = %35, %26
  %46 = phi i32 [ %44, %35 ], [ 0, %26 ]
  %47 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %48 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !66
  %49 = icmp ult %union.StackValue* %13, %48
  br i1 %49, label %50, label %51

; <label>:50:                                     ; preds = %45
  store %union.StackValue* %48, %union.StackValue** %12, align 8, !tbaa !20
  br label %51

; <label>:51:                                     ; preds = %50, %45, %11
  %52 = phi i32 [ 0, %11 ], [ %46, %50 ], [ %46, %45 ]
  %53 = and i32 %5, 2
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %69, label %55

; <label>:55:                                     ; preds = %51
  %56 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %57 = load %union.StackValue*, %union.StackValue** %56, align 8, !tbaa !64
  %58 = sext i32 %52 to i64
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 %58
  store %union.StackValue* %59, %union.StackValue** %56, align 8, !tbaa !64
  %60 = ptrtoint %union.StackValue* %16 to i64
  %61 = ptrtoint %union.StackValue* %59 to i64
  %62 = sub i64 %60, %61
  %63 = lshr exact i64 %62, 4
  %64 = trunc i64 %63 to i32
  %65 = and i32 %64, 65535
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 1, i32 -1, i32 %65, i32 %2) #17
  %66 = load %union.StackValue*, %union.StackValue** %56, align 8, !tbaa !64
  %67 = sub nsw i64 0, %58
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 %67
  store %union.StackValue* %68, %union.StackValue** %56, align 8, !tbaa !64
  br label %69

; <label>:69:                                     ; preds = %55, %51
  %70 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 2
  %71 = load %struct.CallInfo*, %struct.CallInfo** %70, align 8, !tbaa !105
  %72 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %71, i64 0, i32 7
  %73 = load i16, i16* %72, align 2, !tbaa !63
  %74 = and i16 %73, 2
  %75 = icmp eq i16 %74, 0
  %76 = ptrtoint %struct.CallInfo* %71 to i64
  br i1 %75, label %77, label %83

; <label>:77:                                     ; preds = %69
  %78 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %71, i64 0, i32 4
  %79 = bitcast %union.anon.0* %78 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !21
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  %82 = bitcast i32** %81 to i64*
  store i64 %80, i64* %82, align 8, !tbaa !104
  br label %83

; <label>:83:                                     ; preds = %69, %77
  %84 = bitcast %union.StackValue** %18 to i8**
  %85 = load i8*, i8** %84, align 8, !tbaa !23
  %86 = getelementptr inbounds i8, i8* %85, i64 %21
  %87 = bitcast %union.StackValue** %12 to i8**
  store i8* %86, i8** %87, align 8, !tbaa !20
  br label %88

; <label>:88:                                     ; preds = %7, %83
  %89 = phi i64 [ %10, %7 ], [ %76, %83 ]
  %90 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %91 = bitcast %struct.CallInfo** %90 to i64*
  store i64 %89, i64* %91, align 8, !tbaa !24
  %92 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 0
  %93 = load %union.StackValue*, %union.StackValue** %92, align 8, !tbaa !64
  %94 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 6
  %95 = load i16, i16* %94, align 4, !tbaa !65
  %96 = sext i16 %95 to i32
  switch i32 %96, label %116 [
    i32 0, label %97
    i32 1, label %99
    i32 -1, label %132
  ]

; <label>:97:                                     ; preds = %88
  %98 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  store %union.StackValue* %93, %union.StackValue** %98, align 8, !tbaa !20
  br label %175

; <label>:99:                                     ; preds = %88
  %100 = icmp eq i32 %2, 0
  %101 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %100, label %112, label %102

; <label>:102:                                    ; preds = %99
  %103 = load %union.StackValue*, %union.StackValue** %101, align 8, !tbaa !20
  %104 = sext i32 %2 to i64
  %105 = sub nsw i64 0, %104
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 %105, i32 0
  %107 = bitcast %struct.TValue* %106 to i64*
  %108 = bitcast %union.StackValue* %93 to i64*
  %109 = load i64, i64* %107, align 8
  store i64 %109, i64* %108, align 8
  %110 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 %105, i32 0, i32 1
  %111 = load i8, i8* %110, align 8, !tbaa !22
  br label %112

; <label>:112:                                    ; preds = %99, %102
  %113 = phi i8 [ %111, %102 ], [ 0, %99 ]
  %114 = getelementptr inbounds %union.StackValue, %union.StackValue* %93, i64 0, i32 0, i32 1
  store i8 %113, i8* %114, align 8
  %115 = getelementptr inbounds %union.StackValue, %union.StackValue* %93, i64 1
  store %union.StackValue* %115, %union.StackValue** %101, align 8, !tbaa !20
  br label %175

; <label>:116:                                    ; preds = %88
  %117 = icmp slt i16 %95, -1
  br i1 %117, label %118, label %132

; <label>:118:                                    ; preds = %116
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %120 = bitcast %union.StackValue** %119 to i64*
  %121 = load i64, i64* %120, align 8, !tbaa !23
  %122 = ptrtoint %union.StackValue* %93 to i64
  %123 = sub i64 %122, %121
  %124 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* %93, i32 0) #17
  %125 = bitcast %union.StackValue** %119 to i8**
  %126 = load i8*, i8** %125, align 8, !tbaa !23
  %127 = getelementptr inbounds i8, i8* %126, i64 %123
  %128 = bitcast i8* %127 to %union.StackValue*
  %129 = sub nsw i32 -3, %96
  %130 = icmp eq i32 %129, -1
  %131 = select i1 %130, i32 %2, i32 %129
  br label %132

; <label>:132:                                    ; preds = %118, %116, %88
  %133 = phi i32 [ %131, %118 ], [ %96, %116 ], [ %2, %88 ]
  %134 = phi %union.StackValue* [ %128, %118 ], [ %93, %116 ], [ %93, %88 ]
  %135 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %136 = load %union.StackValue*, %union.StackValue** %135, align 8, !tbaa !20
  %137 = sext i32 %2 to i64
  %138 = sub nsw i64 0, %137
  %139 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 %138
  %140 = icmp sgt i32 %2, 0
  %141 = icmp sgt i32 %133, 0
  %142 = and i1 %140, %141
  br i1 %142, label %143, label %161

; <label>:143:                                    ; preds = %132
  %144 = sext i32 %133 to i64
  br label %145

; <label>:145:                                    ; preds = %143, %145
  %146 = phi i64 [ 0, %143 ], [ %155, %145 ]
  %147 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %146, i32 0
  %148 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 %146
  %149 = bitcast %union.StackValue* %148 to i64*
  %150 = bitcast %struct.TValue* %147 to i64*
  %151 = load i64, i64* %149, align 8
  store i64 %151, i64* %150, align 8
  %152 = getelementptr inbounds %union.StackValue, %union.StackValue* %148, i64 0, i32 0, i32 1
  %153 = load i8, i8* %152, align 8, !tbaa !22
  %154 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %146, i32 0, i32 1
  store i8 %153, i8* %154, align 8, !tbaa !22
  %155 = add nuw nsw i64 %146, 1
  %156 = icmp slt i64 %155, %137
  %157 = icmp slt i64 %155, %144
  %158 = and i1 %156, %157
  br i1 %158, label %145, label %159

; <label>:159:                                    ; preds = %145
  %160 = trunc i64 %155 to i32
  br label %161

; <label>:161:                                    ; preds = %159, %132
  %162 = phi i32 [ 0, %132 ], [ %160, %159 ]
  %163 = icmp slt i32 %162, %133
  br i1 %163, label %164, label %172

; <label>:164:                                    ; preds = %161
  %165 = zext i32 %162 to i64
  br label %166

; <label>:166:                                    ; preds = %166, %164
  %167 = phi i64 [ %165, %164 ], [ %169, %166 ]
  %168 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %167, i32 0, i32 1
  store i8 0, i8* %168, align 8, !tbaa !21
  %169 = add nuw nsw i64 %167, 1
  %170 = trunc i64 %169 to i32
  %171 = icmp eq i32 %133, %170
  br i1 %171, label %172, label %166

; <label>:172:                                    ; preds = %166, %161
  %173 = sext i32 %133 to i64
  %174 = getelementptr inbounds %union.StackValue, %union.StackValue* %134, i64 %173
  store %union.StackValue* %174, %union.StackValue** %135, align 8, !tbaa !20
  br label %175

; <label>:175:                                    ; preds = %97, %112, %172
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_hookcall(%struct.lua_State*, %struct.CallInfo* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %4 = load i32, i32* %3, align 8, !tbaa !31
  %5 = and i32 %4, 1
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %32, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 7
  %9 = load i16, i16* %8, align 2, !tbaa !63
  %10 = lshr i16 %9, 2
  %11 = and i16 %10, 4
  %12 = zext i16 %11 to i32
  %13 = bitcast %struct.CallInfo* %1 to %struct.LClosure***
  %14 = load %struct.LClosure**, %struct.LClosure*** %13, align 8, !tbaa !64
  %15 = load %struct.LClosure*, %struct.LClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %15, i64 0, i32 5
  %17 = load %struct.Proto*, %struct.Proto** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 1
  %19 = bitcast %union.StackValue** %18 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !66
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to i64*
  store i64 %20, i64* %22, align 8, !tbaa !20
  %23 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %1, i64 0, i32 4
  %24 = bitcast %union.anon.0* %23 to i32**
  %25 = load i32*, i32** %24, align 8, !tbaa !21
  %26 = getelementptr inbounds i32, i32* %25, i64 1
  store i32* %26, i32** %24, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %17, i64 0, i32 3
  %28 = load i8, i8* %27, align 2, !tbaa !131
  %29 = zext i8 %28 to i32
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 %12, i32 -1, i32 1, i32 %29) #16
  %30 = load i32*, i32** %24, align 8, !tbaa !21
  %31 = getelementptr inbounds i32, i32* %30, i64 -1
  store i32* %31, i32** %24, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %2, %7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaG_traceexec(%struct.lua_State*, i32*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 23
  %6 = load i32, i32* %5, align 8, !tbaa !31
  %7 = and i32 %6, 12
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %9, label %12

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %11 = bitcast i64* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !21
  br label %119

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds i32, i32* %1, i64 1
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4
  %15 = bitcast %union.anon.0* %14 to i32**
  store i32* %13, i32** %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 22
  %17 = load i32, i32* %16, align 4, !tbaa !37
  %18 = add nsw i32 %17, -1
  store i32 %18, i32* %16, align 4, !tbaa !37
  %19 = icmp eq i32 %18, 0
  %20 = and i32 %6, 8
  %21 = icmp ne i32 %20, 0
  %22 = and i1 %21, %19
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %12
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 21
  %25 = load i32, i32* %24, align 8, !tbaa !32
  store i32 %25, i32* %16, align 4, !tbaa !37
  br label %29

; <label>:26:                                     ; preds = %12
  %27 = and i32 %6, 4
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %119, label %29

; <label>:29:                                     ; preds = %26, %23
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %31 = load i16, i16* %30, align 2, !tbaa !63
  %32 = and i16 %31, 32
  %33 = icmp eq i16 %32, 0
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %29
  %35 = and i16 %31, -33
  store i16 %35, i16* %30, align 2, !tbaa !63
  br label %119

; <label>:36:                                     ; preds = %29
  %37 = load i32*, i32** %15, align 8, !tbaa !21
  %38 = getelementptr inbounds i32, i32* %37, i64 -1
  %39 = load i32, i32* %38, align 4, !tbaa !77
  %40 = and i32 %39, 127
  %41 = zext i32 %40 to i64
  %42 = getelementptr inbounds [84 x i8], [84 x i8]* @luaP_opmodes, i64 0, i64 %41
  %43 = load i8, i8* %42, align 1, !tbaa !21
  %44 = and i8 %43, 32
  %45 = icmp ne i8 %44, 0
  %46 = and i32 %39, 16711680
  %47 = icmp eq i32 %46, 0
  %48 = and i1 %47, %45
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %36
  %50 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %51 = bitcast %union.StackValue** %50 to i64*
  %52 = load i64, i64* %51, align 8, !tbaa !66
  %53 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %54 = bitcast %union.StackValue** %53 to i64*
  store i64 %52, i64* %54, align 8, !tbaa !20
  br label %55

; <label>:55:                                     ; preds = %36, %49
  br i1 %22, label %56, label %57

; <label>:56:                                     ; preds = %55
  tail call fastcc void @luaD_hook(%struct.lua_State* nonnull %0, i32 3, i32 -1, i32 0, i32 0) #16
  br label %57

; <label>:57:                                     ; preds = %56, %55
  %58 = and i32 %6, 4
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %108, label %60

; <label>:60:                                     ; preds = %57
  %61 = bitcast %struct.CallInfo* %4 to %struct.LClosure***
  %62 = load %struct.LClosure**, %struct.LClosure*** %61, align 8, !tbaa !64
  %63 = load %struct.LClosure*, %struct.LClosure** %62, align 8, !tbaa !21
  %64 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %63, i64 0, i32 5
  %65 = load %struct.Proto*, %struct.Proto** %64, align 8, !tbaa !21
  %66 = getelementptr inbounds %struct.Proto, %struct.Proto* %65, i64 0, i32 16
  %67 = bitcast i32** %66 to i64*
  %68 = load i64, i64* %67, align 8, !tbaa !116
  %69 = ptrtoint i32* %13 to i64
  %70 = sub i64 %69, %68
  %71 = lshr exact i64 %70, 2
  %72 = trunc i64 %71 to i32
  %73 = add nsw i32 %72, -1
  %74 = icmp eq i32 %73, 0
  %75 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 9
  br i1 %74, label %105, label %76

; <label>:76:                                     ; preds = %60
  %77 = load i32*, i32** %75, align 8, !tbaa !104
  %78 = icmp ugt i32* %13, %77
  br i1 %78, label %79, label %105

; <label>:79:                                     ; preds = %76
  %80 = ptrtoint i32* %77 to i64
  %81 = sub i64 %80, %68
  %82 = lshr exact i64 %81, 2
  %83 = trunc i64 %82 to i32
  %84 = add nsw i32 %83, -1
  %85 = icmp sgt i32 %72, %83
  br i1 %85, label %86, label %107

; <label>:86:                                     ; preds = %79
  %87 = getelementptr inbounds %struct.Proto, %struct.Proto* %65, i64 0, i32 19
  %88 = load i8*, i8** %87, align 8, !tbaa !137
  %89 = sext i32 %84 to i64
  %90 = sext i32 %73 to i64
  br label %94

; <label>:91:                                     ; preds = %94
  %92 = add nsw i32 %96, 1
  %93 = icmp slt i64 %97, %90
  br i1 %93, label %94, label %107

; <label>:94:                                     ; preds = %91, %86
  %95 = phi i64 [ %89, %86 ], [ %97, %91 ]
  %96 = phi i32 [ %84, %86 ], [ %92, %91 ]
  %97 = add nsw i64 %95, 1
  %98 = getelementptr inbounds i8, i8* %88, i64 %97
  %99 = load i8, i8* %98, align 1, !tbaa !21
  %100 = icmp eq i8 %99, 0
  br i1 %100, label %91, label %101

; <label>:101:                                    ; preds = %94
  %102 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %65, i32 %96) #17
  %103 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* nonnull %65, i32 %73) #17
  %104 = icmp eq i32 %102, %103
  br i1 %104, label %107, label %105

; <label>:105:                                    ; preds = %60, %101, %76
  %106 = tail call fastcc i32 @luaG_getfuncline(%struct.Proto* %65, i32 %73) #16
  tail call fastcc void @luaD_hook(%struct.lua_State* %0, i32 2, i32 %106, i32 0, i32 0) #16
  br label %107

; <label>:107:                                    ; preds = %91, %79, %101, %105
  store i32* %13, i32** %75, align 8, !tbaa !104
  br label %108

; <label>:108:                                    ; preds = %57, %107
  %109 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 3
  %110 = load i8, i8* %109, align 2, !tbaa !35
  %111 = icmp eq i8 %110, 1
  br i1 %111, label %112, label %119

; <label>:112:                                    ; preds = %108
  br i1 %22, label %113, label %114

; <label>:113:                                    ; preds = %112
  store i32 1, i32* %16, align 4, !tbaa !37
  br label %114

; <label>:114:                                    ; preds = %113, %112
  %115 = load i32*, i32** %15, align 8, !tbaa !21
  %116 = getelementptr inbounds i32, i32* %115, i64 -1
  store i32* %116, i32** %15, align 8, !tbaa !21
  %117 = load i16, i16* %30, align 2, !tbaa !63
  %118 = or i16 %117, 32
  store i16 %118, i16* %30, align 2, !tbaa !63
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 1) #18
  unreachable

; <label>:119:                                    ; preds = %108, %26, %34, %9
  %120 = phi i32 [ 1, %34 ], [ 0, %9 ], [ 1, %26 ], [ 1, %108 ]
  ret i32 %120
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_getstr(%struct.Table* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !75
  %6 = icmp eq i8 %5, 20
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %2
  %8 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* %0, %struct.TString* nonnull %1) #16
  br label %15

; <label>:9:                                      ; preds = %2
  %10 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %1, %struct.TString** %11, align 8, !tbaa !21
  %12 = or i8 %5, 64
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %12, i8* %13, align 8, !tbaa !22
  %14 = call fastcc %struct.TValue* @getgeneric(%struct.Table* %0, %struct.TValue* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  br label %15

; <label>:15:                                     ; preds = %9, %7
  %16 = phi %struct.TValue* [ %8, %7 ], [ %14, %9 ]
  ret %struct.TValue* %16
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @luaV_mod(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %9, !prof !61

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %17

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.168, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = srem i64 %1, %2
  %11 = icmp ne i64 %10, 0
  %12 = xor i64 %10, %2
  %13 = icmp slt i64 %12, 0
  %14 = and i1 %11, %13
  %15 = select i1 %14, i64 %2, i64 0
  %16 = add nsw i64 %15, %10
  br label %17

; <label>:17:                                     ; preds = %9, %6
  %18 = phi i64 [ 0, %6 ], [ %16, %9 ]
  ret i64 %18
}

; Function Attrs: nounwind optsize
declare double @pow(double, double) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @luaV_idiv(%struct.lua_State*, i64, i64) unnamed_addr #0 {
  %4 = add i64 %2, 1
  %5 = icmp ult i64 %4, 2
  br i1 %5, label %6, label %11, !prof !61

; <label>:6:                                      ; preds = %3
  %7 = icmp eq i64 %2, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %6
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.169, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %6
  %10 = sub i64 0, %1
  br label %20

; <label>:11:                                     ; preds = %3
  %12 = sdiv i64 %1, %2
  %13 = srem i64 %1, %2
  %14 = xor i64 %2, %1
  %15 = icmp slt i64 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %11
  %17 = icmp ne i64 %13, 0
  %18 = sext i1 %17 to i64
  %19 = add nsw i64 %12, %18
  ret i64 %19

; <label>:20:                                     ; preds = %11, %9
  %21 = phi i64 [ %10, %9 ], [ %12, %11 ]
  ret i64 %21
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.floor.f64(double) #14

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaT_trybinassocTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32, i32) unnamed_addr #0 {
  %7 = icmp eq i32 %4, 0
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %2, %struct.TValue* %1, %union.StackValue* %3, i32 %5) #16
  br label %10

; <label>:9:                                      ; preds = %6
  tail call fastcc void @luaT_trybinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %5) #16
  br label %10

; <label>:10:                                     ; preds = %9, %8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaT_trybinTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3, i32 %4) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %23

; <label>:8:                                      ; preds = %5
  switch i32 %4, label %22 [
    i32 22, label %9
    i32 13, label %10
    i32 14, label %10
    i32 15, label %10
    i32 16, label %10
    i32 17, label %10
    i32 19, label %10
  ]

; <label>:9:                                      ; preds = %8
  tail call fastcc void @luaG_concaterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2) #18
  unreachable

; <label>:10:                                     ; preds = %8, %8, %8, %8, %8, %8
  %11 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = and i8 %12, 15
  %14 = icmp eq i8 %13, 3
  br i1 %14, label %15, label %21

; <label>:15:                                     ; preds = %10
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = and i8 %17, 15
  %19 = icmp eq i8 %18, 3
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %15
  tail call fastcc void @luaG_tointerror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* nonnull %2) #18
  unreachable

; <label>:21:                                     ; preds = %15, %10
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.170, i64 0, i64 0)) #18
  unreachable

; <label>:22:                                     ; preds = %8
  tail call fastcc void @luaG_opinterror(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.171, i64 0, i64 0)) #18
  unreachable

; <label>:23:                                     ; preds = %5
  ret void
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @LTnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %37

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp slt i64 %8, %14
  br label %65

; <label>:16:                                     ; preds = %6
  %17 = bitcast %struct.TValue* %1 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  %19 = add i64 %8, 9007199254740992
  %20 = icmp ult i64 %19, 18014398509481985
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %16
  %22 = sitofp i64 %8 to double
  %23 = fcmp ogt double %18, %22
  br label %65

; <label>:24:                                     ; preds = %16
  %25 = tail call double @llvm.floor.f64(double %18) #7
  %26 = fcmp une double %25, %18
  %27 = fadd double %25, 1.000000e+00
  %28 = select i1 %26, double %27, double %25
  %29 = fcmp oge double %28, 0xC3E0000000000000
  %30 = fcmp olt double %28, 0x43E0000000000000
  %31 = and i1 %29, %30
  br i1 %31, label %32, label %35

; <label>:32:                                     ; preds = %24
  %33 = fptosi double %28 to i64
  %34 = icmp slt i64 %8, %33
  br label %65

; <label>:35:                                     ; preds = %24
  %36 = fcmp ogt double %18, 0.000000e+00
  br label %65

; <label>:37:                                     ; preds = %2
  %38 = bitcast %struct.TValue* %0 to double*
  %39 = load double, double* %38, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = icmp eq i8 %41, 19
  br i1 %42, label %43, label %47

; <label>:43:                                     ; preds = %37
  %44 = bitcast %struct.TValue* %1 to double*
  %45 = load double, double* %44, align 8, !tbaa !21
  %46 = fcmp olt double %39, %45
  br label %65

; <label>:47:                                     ; preds = %37
  %48 = bitcast %struct.TValue* %1 to i64*
  %49 = load i64, i64* %48, align 8, !tbaa !21
  %50 = add i64 %49, 9007199254740992
  %51 = icmp ult i64 %50, 18014398509481985
  br i1 %51, label %52, label %55

; <label>:52:                                     ; preds = %47
  %53 = sitofp i64 %49 to double
  %54 = fcmp olt double %39, %53
  br label %65

; <label>:55:                                     ; preds = %47
  %56 = tail call double @llvm.floor.f64(double %39) #7
  %57 = fcmp oge double %56, 0xC3E0000000000000
  %58 = fcmp olt double %56, 0x43E0000000000000
  %59 = and i1 %57, %58
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %55
  %61 = fptosi double %56 to i64
  %62 = icmp sgt i64 %49, %61
  br label %65

; <label>:63:                                     ; preds = %55
  %64 = fcmp olt double %39, 0.000000e+00
  br label %65

; <label>:65:                                     ; preds = %63, %60, %52, %35, %32, %21, %43, %12
  %66 = phi i1 [ %15, %12 ], [ %46, %43 ], [ %23, %21 ], [ %36, %35 ], [ %34, %32 ], [ %54, %52 ], [ %64, %63 ], [ %62, %60 ]
  %67 = zext i1 %66 to i32
  ret i32 %67
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @lessthanothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %20

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17) #16
  %19 = lshr i32 %18, 31
  br label %22

; <label>:20:                                     ; preds = %8, %3
  %21 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 20) #16
  br label %22

; <label>:22:                                     ; preds = %20, %13
  %23 = phi i32 [ %19, %13 ], [ %21, %20 ]
  ret i32 %23
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @LEnum(%struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %34

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = icmp eq i8 %10, 35
  br i1 %11, label %12, label %16

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = load i64, i64* %13, align 8, !tbaa !21
  %15 = icmp sle i64 %8, %14
  br label %65

; <label>:16:                                     ; preds = %6
  %17 = bitcast %struct.TValue* %1 to double*
  %18 = load double, double* %17, align 8, !tbaa !21
  %19 = add i64 %8, 9007199254740992
  %20 = icmp ult i64 %19, 18014398509481985
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %16
  %22 = sitofp i64 %8 to double
  %23 = fcmp oge double %18, %22
  br label %65

; <label>:24:                                     ; preds = %16
  %25 = tail call double @llvm.floor.f64(double %18) #7
  %26 = fcmp oge double %25, 0xC3E0000000000000
  %27 = fcmp olt double %25, 0x43E0000000000000
  %28 = and i1 %26, %27
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %24
  %30 = fptosi double %25 to i64
  %31 = icmp sle i64 %8, %30
  br label %65

; <label>:32:                                     ; preds = %24
  %33 = fcmp ogt double %18, 0.000000e+00
  br label %65

; <label>:34:                                     ; preds = %2
  %35 = bitcast %struct.TValue* %0 to double*
  %36 = load double, double* %35, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = icmp eq i8 %38, 19
  br i1 %39, label %40, label %44

; <label>:40:                                     ; preds = %34
  %41 = bitcast %struct.TValue* %1 to double*
  %42 = load double, double* %41, align 8, !tbaa !21
  %43 = fcmp ole double %36, %42
  br label %65

; <label>:44:                                     ; preds = %34
  %45 = bitcast %struct.TValue* %1 to i64*
  %46 = load i64, i64* %45, align 8, !tbaa !21
  %47 = add i64 %46, 9007199254740992
  %48 = icmp ult i64 %47, 18014398509481985
  br i1 %48, label %49, label %52

; <label>:49:                                     ; preds = %44
  %50 = sitofp i64 %46 to double
  %51 = fcmp ole double %36, %50
  br label %65

; <label>:52:                                     ; preds = %44
  %53 = tail call double @llvm.floor.f64(double %36) #7
  %54 = fcmp une double %53, %36
  %55 = fadd double %53, 1.000000e+00
  %56 = select i1 %54, double %55, double %53
  %57 = fcmp oge double %56, 0xC3E0000000000000
  %58 = fcmp olt double %56, 0x43E0000000000000
  %59 = and i1 %57, %58
  br i1 %59, label %60, label %63

; <label>:60:                                     ; preds = %52
  %61 = fptosi double %56 to i64
  %62 = icmp sge i64 %46, %61
  br label %65

; <label>:63:                                     ; preds = %52
  %64 = fcmp olt double %36, 0.000000e+00
  br label %65

; <label>:65:                                     ; preds = %63, %60, %49, %32, %29, %21, %40, %12
  %66 = phi i1 [ %15, %12 ], [ %43, %40 ], [ %23, %21 ], [ %33, %32 ], [ %31, %29 ], [ %51, %49 ], [ %64, %63 ], [ %62, %60 ]
  %67 = zext i1 %66 to i32
  ret i32 %67
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @lessequalothers(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = icmp eq i8 %6, 4
  br i1 %7, label %8, label %21

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %10 = load i8, i8* %9, align 8, !tbaa !22
  %11 = and i8 %10, 15
  %12 = icmp eq i8 %11, 4
  br i1 %12, label %13, label %21

; <label>:13:                                     ; preds = %8
  %14 = bitcast %struct.TValue* %1 to %struct.TString**
  %15 = load %struct.TString*, %struct.TString** %14, align 8, !tbaa !21
  %16 = bitcast %struct.TValue* %2 to %struct.TString**
  %17 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %18 = tail call fastcc i32 @l_strcmp(%struct.TString* %15, %struct.TString* %17) #16
  %19 = icmp slt i32 %18, 1
  %20 = zext i1 %19 to i32
  br label %23

; <label>:21:                                     ; preds = %8, %3
  %22 = tail call fastcc i32 @luaT_callorderTM(%struct.lua_State* %0, %struct.TValue* nonnull %1, %struct.TValue* %2, i32 21) #16
  br label %23

; <label>:23:                                     ; preds = %21, %13
  %24 = phi i32 [ %20, %13 ], [ %22, %21 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_tryfuncTM(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0
  %4 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %3, i32 23) #16
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 6
  br i1 %8, label %10, label %9, !prof !73

; <label>:9:                                      ; preds = %2
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.178, i64 0, i64 0)) #18
  unreachable

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = icmp ugt %union.StackValue* %12, %1
  br i1 %13, label %14, label %28

; <label>:14:                                     ; preds = %10
  br label %15

; <label>:15:                                     ; preds = %14, %15
  %16 = phi %union.StackValue* [ %24, %15 ], [ %12, %14 ]
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1, i32 0
  %18 = bitcast %struct.TValue* %17 to i64*
  %19 = bitcast %union.StackValue* %16 to i64*
  %20 = load i64, i64* %18, align 8
  store i64 %20, i64* %19, align 8
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1, i32 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 0, i32 0, i32 1
  store i8 %22, i8* %23, align 8, !tbaa !22
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 -1
  %25 = icmp ugt %union.StackValue* %24, %1
  br i1 %25, label %15, label %26

; <label>:26:                                     ; preds = %15
  %27 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  br label %28

; <label>:28:                                     ; preds = %26, %10
  %29 = phi %union.StackValue* [ %27, %26 ], [ %12, %10 ]
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %11, align 8, !tbaa !20
  %31 = bitcast %struct.TValue* %4 to i64*
  %32 = bitcast %union.StackValue* %1 to i64*
  %33 = load i64, i64* %31, align 8
  store i64 %33, i64* %32, align 8
  %34 = load i8, i8* %5, align 8, !tbaa !22
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %1, i64 0, i32 0, i32 1
  store i8 %34, i8* %35, align 8, !tbaa !22
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_forerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.179, i64 0, i64 0), i8* %2, i8* %4) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaD_hook(%struct.lua_State*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.lua_Debug, align 8
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 17
  %8 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %7, align 8, !tbaa !30
  %9 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %8, null
  br i1 %9, label %74, label %10

; <label>:10:                                     ; preds = %5
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !33
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %74, label %14

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !24
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = bitcast %union.StackValue** %17 to i64*
  %19 = load i64, i64* %18, align 8, !tbaa !20
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %21 = bitcast %union.StackValue** %20 to i64*
  %22 = load i64, i64* %21, align 8, !tbaa !23
  %23 = sub i64 %19, %22
  %24 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 1
  %25 = bitcast %union.StackValue** %24 to i64*
  %26 = load i64, i64* %25, align 8, !tbaa !66
  %27 = sub i64 %26, %22
  %28 = bitcast %struct.lua_Debug* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %28) #7
  %29 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 0
  store i32 %1, i32* %29, align 8, !tbaa !242
  %30 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 6
  store i32 %2, i32* %30, align 8, !tbaa !127
  %31 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %6, i64 0, i32 16
  store %struct.CallInfo* %16, %struct.CallInfo** %31, align 8, !tbaa !106
  %32 = icmp eq i32 %4, 0
  %33 = inttoptr i64 %26 to %union.StackValue*
  br i1 %32, label %42, label %34

; <label>:34:                                     ; preds = %14
  %35 = trunc i32 %3 to i16
  %36 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 5
  %37 = bitcast %union.anon.2* %36 to %struct.anon.3*
  %38 = bitcast %union.anon.2* %36 to i16*
  store i16 %35, i16* %38, align 8, !tbaa !21
  %39 = trunc i32 %4 to i16
  %40 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %37, i64 0, i32 1
  store i16 %39, i16* %40, align 2, !tbaa !21
  %41 = load i64, i64* %18, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %14, %34
  %43 = phi i64 [ %41, %34 ], [ %19, %14 ]
  %44 = phi i16 [ 132, %34 ], [ 4, %14 ]
  %45 = inttoptr i64 %43 to %union.StackValue*
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %47 = bitcast %union.StackValue** %46 to i64*
  %48 = load i64, i64* %47, align 8, !tbaa !62
  %49 = sub i64 %48, %43
  %50 = icmp slt i64 %49, 336
  br i1 %50, label %51, label %55

; <label>:51:                                     ; preds = %42
  %52 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 20, i32 1) #16
  %53 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %54 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !66
  br label %55

; <label>:55:                                     ; preds = %42, %51
  %56 = phi %union.StackValue* [ %33, %42 ], [ %54, %51 ]
  %57 = phi %union.StackValue* [ %45, %42 ], [ %53, %51 ]
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 20
  %59 = icmp ugt %union.StackValue* %58, %56
  br i1 %59, label %60, label %61

; <label>:60:                                     ; preds = %55
  store %union.StackValue* %58, %union.StackValue** %24, align 8, !tbaa !66
  br label %61

; <label>:61:                                     ; preds = %60, %55
  store i8 0, i8* %11, align 1, !tbaa !33
  %62 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 7
  %63 = load i16, i16* %62, align 2, !tbaa !63
  %64 = or i16 %63, %44
  store i16 %64, i16* %62, align 2, !tbaa !63
  call void %8(%struct.lua_State* nonnull %0, %struct.lua_Debug* nonnull %6) #17
  store i8 1, i8* %11, align 1, !tbaa !33
  %65 = bitcast %union.StackValue** %20 to i8**
  %66 = load i8*, i8** %65, align 8, !tbaa !23
  %67 = getelementptr inbounds i8, i8* %66, i64 %27
  %68 = bitcast %union.StackValue** %24 to i8**
  store i8* %67, i8** %68, align 8, !tbaa !66
  %69 = getelementptr inbounds i8, i8* %66, i64 %23
  %70 = bitcast %union.StackValue** %17 to i8**
  store i8* %69, i8** %70, align 8, !tbaa !20
  %71 = load i16, i16* %62, align 2, !tbaa !63
  %72 = xor i16 %44, -1
  %73 = and i16 %71, %72
  store i16 %73, i16* %62, align 2, !tbaa !63
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %28) #7
  br label %74

; <label>:74:                                     ; preds = %10, %5, %61
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TValue* @getgeneric(%struct.Table* nocapture readonly, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = zext i8 %4 to i32
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0
  %7 = tail call fastcc %union.Node* @mainposition(%struct.Table* %0, i32 %5, %union.Value* %6) #17
  %8 = load i8, i8* %3, align 8, !tbaa !22
  %9 = trunc i8 %8 to i6
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 0, i32 0
  %11 = bitcast %struct.TValue* %1 to i64*
  %12 = bitcast %struct.TValue* %1 to double*
  %13 = bitcast %struct.TValue* %1 to i32*
  %14 = bitcast %struct.TValue* %1 to i8**
  %15 = bitcast %struct.TValue* %1 to i32 (%struct.lua_State*)**
  %16 = bitcast %struct.TValue* %1 to %struct.TString**
  br label %17

; <label>:17:                                     ; preds = %83, %2
  %18 = phi %union.Node* [ %7, %2 ], [ %85, %83 ]
  %19 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 2
  %20 = load i8, i8* %19, align 1, !tbaa !21
  %21 = icmp eq i8 %8, %20
  br i1 %21, label %22, label %79

; <label>:22:                                     ; preds = %17
  switch i6 %9, label %65 [
    i6 0, label %77
    i6 -29, label %23
    i6 19, label %29
    i6 1, label %35
    i6 2, label %41
    i6 -26, label %47
    i6 -28, label %53
  ]

; <label>:23:                                     ; preds = %22
  %24 = load i64, i64* %11, align 8, !tbaa !21
  %25 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4
  %26 = bitcast %union.Value* %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !21
  %28 = icmp eq i64 %24, %27
  br i1 %28, label %77, label %79

; <label>:29:                                     ; preds = %22
  %30 = load double, double* %12, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4
  %32 = bitcast %union.Value* %31 to double*
  %33 = load double, double* %32, align 8, !tbaa !21
  %34 = fcmp oeq double %30, %33
  br i1 %34, label %77, label %79

; <label>:35:                                     ; preds = %22
  %36 = load i32, i32* %13, align 8, !tbaa !21
  %37 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4
  %38 = bitcast %union.Value* %37 to i32*
  %39 = load i32, i32* %38, align 8, !tbaa !21
  %40 = icmp eq i32 %36, %39
  br i1 %40, label %77, label %79

; <label>:41:                                     ; preds = %22
  %42 = load i8*, i8** %14, align 8, !tbaa !21
  %43 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4
  %44 = bitcast %union.Value* %43 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !21
  %46 = icmp eq i8* %42, %45
  br i1 %46, label %77, label %79

; <label>:47:                                     ; preds = %22
  %48 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %15, align 8, !tbaa !21
  %49 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4
  %50 = bitcast %union.Value* %49 to i32 (%struct.lua_State*)**
  %51 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %50, align 8, !tbaa !21
  %52 = icmp eq i32 (%struct.lua_State*)* %48, %51
  br i1 %52, label %77, label %79

; <label>:53:                                     ; preds = %22
  %54 = load %struct.TString*, %struct.TString** %16, align 8, !tbaa !21
  %55 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4, i32 0
  %56 = bitcast %struct.GCObject** %55 to %struct.TString**
  %57 = load %struct.TString*, %struct.TString** %56, align 8, !tbaa !21
  %58 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 0, i32 6, i32 0
  %59 = load i64, i64* %58, align 8, !tbaa !21
  %60 = icmp eq %struct.TString* %54, %57
  br i1 %60, label %77, label %61

; <label>:61:                                     ; preds = %53
  %62 = getelementptr inbounds %struct.TString, %struct.TString* %57, i64 0, i32 6, i32 0
  %63 = load i64, i64* %62, align 8, !tbaa !21
  %64 = icmp eq i64 %59, %63
  br i1 %64, label %70, label %79

; <label>:65:                                     ; preds = %22
  %66 = load %struct.GCObject*, %struct.GCObject** %10, align 8, !tbaa !21
  %67 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 4, i32 0
  %68 = load %struct.GCObject*, %struct.GCObject** %67, align 8, !tbaa !21
  %69 = icmp eq %struct.GCObject* %66, %68
  br i1 %69, label %77, label %79

; <label>:70:                                     ; preds = %61
  %71 = getelementptr inbounds %struct.TString, %struct.TString* %54, i64 1
  %72 = bitcast %struct.TString* %71 to i8*
  %73 = getelementptr inbounds %struct.TString, %struct.TString* %57, i64 1
  %74 = bitcast %struct.TString* %73 to i8*
  %75 = tail call i32 @memcmp(i8* nonnull %72, i8* nonnull %74, i64 %59) #21
  %76 = icmp eq i32 %75, 0
  br i1 %76, label %77, label %79

; <label>:77:                                     ; preds = %23, %29, %35, %41, %47, %65, %70, %53, %22
  %78 = bitcast %union.Node* %18 to %struct.TValue*
  br label %86

; <label>:79:                                     ; preds = %23, %29, %35, %41, %47, %65, %70, %61, %17
  %80 = getelementptr inbounds %union.Node, %union.Node* %18, i64 0, i32 0, i32 3
  %81 = load i32, i32* %80, align 4, !tbaa !21
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %86, label %83

; <label>:83:                                     ; preds = %79
  %84 = sext i32 %81 to i64
  %85 = getelementptr inbounds %union.Node, %union.Node* %18, i64 %84
  br label %17

; <label>:86:                                     ; preds = %79, %77
  %87 = phi %struct.TValue* [ %78, %77 ], [ @absentkey, %79 ]
  ret %struct.TValue* %87
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %union.Node* @mainposition(%struct.Table* nocapture readonly, i32, %union.Value* nocapture readonly) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = trunc i32 %1 to i6
  switch i6 %5, label %157 [
    i6 -29, label %6
    i6 19, label %20
    i6 20, label %49
    i6 -28, label %64
    i6 1, label %114
    i6 2, label %127
    i6 -26, label %142
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %8 = load %union.Node*, %union.Node** %7, align 8, !tbaa !156
  %9 = bitcast %union.Value* %2 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %12 = load i8, i8* %11, align 1, !tbaa !93
  %13 = zext i8 %12 to i32
  %14 = shl i32 1, %13
  %15 = add nsw i32 %14, -1
  %16 = trunc i64 %10 to i32
  %17 = and i32 %15, %16
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %union.Node, %union.Node* %8, i64 %18
  br label %172

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %22 = load %union.Node*, %union.Node** %21, align 8, !tbaa !156
  %23 = bitcast %union.Value* %2 to double*
  %24 = load double, double* %23, align 8, !tbaa !21
  %25 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %25) #7
  %26 = call double @frexp(double %24, i32* nonnull %4) #17
  %27 = fmul double %26, 0x41E0000000000000
  %28 = fcmp oge double %27, 0xC3E0000000000000
  %29 = fcmp olt double %27, 0x43E0000000000000
  %30 = and i1 %28, %29
  br i1 %30, label %31, label %38

; <label>:31:                                     ; preds = %20
  %32 = fptosi double %27 to i64
  %33 = load i32, i32* %4, align 4, !tbaa !77
  %34 = trunc i64 %32 to i32
  %35 = add i32 %33, %34
  %36 = ashr i32 %35, 31
  %37 = xor i32 %36, %35
  br label %38

; <label>:38:                                     ; preds = %20, %31
  %39 = phi i32 [ %37, %31 ], [ 0, %20 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %25) #7
  %40 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %41 = load i8, i8* %40, align 1, !tbaa !93
  %42 = zext i8 %41 to i32
  %43 = shl i32 1, %42
  %44 = add nsw i32 %43, -1
  %45 = or i32 %44, 1
  %46 = srem i32 %39, %45
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds %union.Node, %union.Node* %22, i64 %47
  br label %172

; <label>:49:                                     ; preds = %3
  %50 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %51 = load %union.Node*, %union.Node** %50, align 8, !tbaa !156
  %52 = bitcast %union.Value* %2 to %struct.TString**
  %53 = load %struct.TString*, %struct.TString** %52, align 8, !tbaa !21
  %54 = getelementptr inbounds %struct.TString, %struct.TString* %53, i64 0, i32 5
  %55 = load i32, i32* %54, align 4, !tbaa !21
  %56 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %57 = load i8, i8* %56, align 1, !tbaa !93
  %58 = zext i8 %57 to i32
  %59 = shl i32 1, %58
  %60 = add nsw i32 %59, -1
  %61 = and i32 %60, %55
  %62 = sext i32 %61 to i64
  %63 = getelementptr inbounds %union.Node, %union.Node* %51, i64 %62
  br label %172

; <label>:64:                                     ; preds = %3
  %65 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %66 = load %union.Node*, %union.Node** %65, align 8, !tbaa !156
  %67 = bitcast %union.Value* %2 to %struct.TString**
  %68 = load %struct.TString*, %struct.TString** %67, align 8, !tbaa !21
  %69 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 3
  %70 = load i8, i8* %69, align 2, !tbaa !99
  %71 = icmp eq i8 %70, 0
  br i1 %71, label %75, label %72

; <label>:72:                                     ; preds = %64
  %73 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 5
  %74 = load i32, i32* %73, align 4, !tbaa !150
  br label %104

; <label>:75:                                     ; preds = %64
  %76 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 1
  %77 = bitcast %struct.TString* %76 to i8*
  %78 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 6, i32 0
  %79 = load i64, i64* %78, align 8, !tbaa !21
  %80 = getelementptr inbounds %struct.TString, %struct.TString* %68, i64 0, i32 5
  %81 = load i32, i32* %80, align 4, !tbaa !150
  %82 = trunc i64 %79 to i32
  %83 = xor i32 %81, %82
  %84 = lshr i64 %79, 5
  %85 = icmp ult i64 %84, %79
  br i1 %85, label %86, label %102

; <label>:86:                                     ; preds = %75
  %87 = xor i64 %84, -1
  br label %88

; <label>:88:                                     ; preds = %88, %86
  %89 = phi i64 [ %79, %86 ], [ %100, %88 ]
  %90 = phi i32 [ %83, %86 ], [ %99, %88 ]
  %91 = shl i32 %90, 5
  %92 = lshr i32 %90, 2
  %93 = add i32 %91, %92
  %94 = add i64 %89, -1
  %95 = getelementptr inbounds i8, i8* %77, i64 %94
  %96 = load i8, i8* %95, align 1, !tbaa !21
  %97 = zext i8 %96 to i32
  %98 = add i32 %93, %97
  %99 = xor i32 %98, %90
  %100 = add i64 %89, %87
  %101 = icmp ugt i64 %100, %84
  br i1 %101, label %88, label %102

; <label>:102:                                    ; preds = %88, %75
  %103 = phi i32 [ %83, %75 ], [ %99, %88 ]
  store i32 %103, i32* %80, align 4, !tbaa !150
  store i8 1, i8* %69, align 2, !tbaa !99
  br label %104

; <label>:104:                                    ; preds = %72, %102
  %105 = phi i32 [ %74, %72 ], [ %103, %102 ]
  %106 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %107 = load i8, i8* %106, align 1, !tbaa !93
  %108 = zext i8 %107 to i32
  %109 = shl i32 1, %108
  %110 = add nsw i32 %109, -1
  %111 = and i32 %110, %105
  %112 = sext i32 %111 to i64
  %113 = getelementptr inbounds %union.Node, %union.Node* %66, i64 %112
  br label %172

; <label>:114:                                    ; preds = %3
  %115 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %116 = load %union.Node*, %union.Node** %115, align 8, !tbaa !156
  %117 = bitcast %union.Value* %2 to i32*
  %118 = load i32, i32* %117, align 8, !tbaa !21
  %119 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %120 = load i8, i8* %119, align 1, !tbaa !93
  %121 = zext i8 %120 to i32
  %122 = shl i32 1, %121
  %123 = add nsw i32 %122, -1
  %124 = and i32 %123, %118
  %125 = sext i32 %124 to i64
  %126 = getelementptr inbounds %union.Node, %union.Node* %116, i64 %125
  br label %172

; <label>:127:                                    ; preds = %3
  %128 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %129 = load %union.Node*, %union.Node** %128, align 8, !tbaa !156
  %130 = bitcast %union.Value* %2 to i64*
  %131 = load i64, i64* %130, align 8, !tbaa !21
  %132 = trunc i64 %131 to i32
  %133 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %134 = load i8, i8* %133, align 1, !tbaa !93
  %135 = zext i8 %134 to i32
  %136 = shl i32 1, %135
  %137 = add nsw i32 %136, -1
  %138 = or i32 %137, 1
  %139 = urem i32 %132, %138
  %140 = zext i32 %139 to i64
  %141 = getelementptr inbounds %union.Node, %union.Node* %129, i64 %140
  br label %172

; <label>:142:                                    ; preds = %3
  %143 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %144 = load %union.Node*, %union.Node** %143, align 8, !tbaa !156
  %145 = bitcast %union.Value* %2 to i64*
  %146 = load i64, i64* %145, align 8, !tbaa !21
  %147 = trunc i64 %146 to i32
  %148 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %149 = load i8, i8* %148, align 1, !tbaa !93
  %150 = zext i8 %149 to i32
  %151 = shl i32 1, %150
  %152 = add nsw i32 %151, -1
  %153 = or i32 %152, 1
  %154 = urem i32 %147, %153
  %155 = zext i32 %154 to i64
  %156 = getelementptr inbounds %union.Node, %union.Node* %144, i64 %155
  br label %172

; <label>:157:                                    ; preds = %3
  %158 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 7
  %159 = load %union.Node*, %union.Node** %158, align 8, !tbaa !156
  %160 = bitcast %union.Value* %2 to i64*
  %161 = load i64, i64* %160, align 8, !tbaa !21
  %162 = trunc i64 %161 to i32
  %163 = getelementptr inbounds %struct.Table, %struct.Table* %0, i64 0, i32 4
  %164 = load i8, i8* %163, align 1, !tbaa !93
  %165 = zext i8 %164 to i32
  %166 = shl i32 1, %165
  %167 = add nsw i32 %166, -1
  %168 = or i32 %167, 1
  %169 = urem i32 %162, %168
  %170 = zext i32 %169 to i64
  %171 = getelementptr inbounds %union.Node, %union.Node* %159, i64 %170
  br label %172

; <label>:172:                                    ; preds = %157, %142, %127, %114, %104, %49, %38, %6
  %173 = phi %union.Node* [ %171, %157 ], [ %156, %142 ], [ %141, %127 ], [ %126, %114 ], [ %113, %104 ], [ %63, %49 ], [ %48, %38 ], [ %19, %6 ]
  ret %union.Node* %173
}

; Function Attrs: nounwind optsize
declare double @frexp(double, i32* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: nounwind optsize
declare double @fmod(double, double) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @callbinTM(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*, i32) unnamed_addr #0 {
  %6 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %1, i32 %4) #16
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %5
  %12 = tail call fastcc %struct.TValue* @luaT_gettmbyobj(%struct.lua_State* %0, %struct.TValue* %2, i32 %4) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = and i8 %14, 15
  %16 = icmp eq i8 %15, 0
  br i1 %16, label %19, label %17

; <label>:17:                                     ; preds = %5, %11
  %18 = phi %struct.TValue* [ %12, %11 ], [ %6, %5 ]
  tail call fastcc void @luaT_callTMres(%struct.lua_State* %0, %struct.TValue* %18, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %3) #16
  br label %19

; <label>:19:                                     ; preds = %11, %17
  %20 = phi i32 [ 1, %17 ], [ 0, %11 ]
  ret i32 %20
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_concaterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  %6 = and i8 %5, 15
  %7 = add nsw i8 %6, -3
  %8 = icmp ult i8 %7, 2
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.172, i64 0, i64 0)) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_tointerror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %5 = load i8, i8* %4, align 8, !tbaa !22
  switch i8 %5, label %17 [
    i8 35, label %6
    i8 19, label %7
  ]

; <label>:6:                                      ; preds = %3
  br label %17

; <label>:7:                                      ; preds = %3
  %8 = bitcast %struct.TValue* %1 to double*
  %9 = load double, double* %8, align 8, !tbaa !21
  %10 = tail call double @llvm.floor.f64(double %9) #7
  %11 = fcmp une double %10, %9
  br i1 %11, label %17, label %12

; <label>:12:                                     ; preds = %7
  %13 = fcmp oge double %10, 0xC3E0000000000000
  %14 = fcmp olt double %10, 0x43E0000000000000
  %15 = and i1 %13, %14
  %16 = select i1 %15, %struct.TValue* %2, %struct.TValue* %1
  br label %17

; <label>:17:                                     ; preds = %12, %3, %7, %6
  %18 = phi %struct.TValue* [ %2, %6 ], [ %1, %7 ], [ %1, %3 ], [ %16, %12 ]
  %19 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %18) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.175, i64 0, i64 0), i8* %19) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_opinterror(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i8*) unnamed_addr #5 {
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 3
  %9 = select i1 %8, %struct.TValue* %2, %struct.TValue* %1
  tail call fastcc void @luaG_typeerror(%struct.lua_State* %0, %struct.TValue* %9, i8* %3) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaT_callTMres(%struct.lua_State*, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %union.StackValue*) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %7 = bitcast %union.StackValue** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !23
  %9 = ptrtoint %union.StackValue* %4 to i64
  %10 = sub i64 %9, %8
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %13 = bitcast %struct.TValue* %1 to i64*
  %14 = bitcast %union.StackValue* %12 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %17 = load i8, i8* %16, align 8, !tbaa !22
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0, i32 1
  store i8 %17, i8* %18, align 8, !tbaa !22
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0
  %20 = bitcast %struct.TValue* %2 to i64*
  %21 = bitcast %struct.TValue* %19 to i64*
  %22 = load i64, i64* %20, align 8
  store i64 %22, i64* %21, align 8
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0
  %27 = bitcast %struct.TValue* %3 to i64*
  %28 = bitcast %struct.TValue* %26 to i64*
  %29 = load i64, i64* %27, align 8
  store i64 %29, i64* %28, align 8
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %31 = load i8, i8* %30, align 8, !tbaa !22
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2, i32 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !22
  %33 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 3
  store %union.StackValue* %34, %union.StackValue** %11, align 8, !tbaa !20
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %36 = load %struct.CallInfo*, %struct.CallInfo** %35, align 8, !tbaa !24
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %36, i64 0, i32 7
  %38 = load i16, i16* %37, align 2, !tbaa !63
  %39 = and i16 %38, 6
  %40 = icmp eq i16 %39, 0
  br i1 %40, label %41, label %42

; <label>:41:                                     ; preds = %5
  tail call fastcc void @luaD_call(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1) #16
  br label %43

; <label>:42:                                     ; preds = %5
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* %12, i32 1) #16
  br label %43

; <label>:43:                                     ; preds = %42, %41
  %44 = bitcast %union.StackValue** %6 to i8**
  %45 = load i8*, i8** %44, align 8, !tbaa !23
  %46 = getelementptr inbounds i8, i8* %45, i64 %10
  %47 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1
  store %union.StackValue* %48, %union.StackValue** %11, align 8, !tbaa !20
  %49 = bitcast %union.StackValue* %48 to i64*
  %50 = bitcast i8* %46 to i64*
  %51 = load i64, i64* %49, align 8
  store i64 %51, i64* %50, align 8
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 -1, i32 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  %54 = getelementptr inbounds i8, i8* %46, i64 8
  store i8 %53, i8* %54, align 8, !tbaa !22
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_typeerror(%struct.lua_State*, %struct.TValue*, i8*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  %5 = tail call fastcc i8* @varinfo(%struct.lua_State* %0, %struct.TValue* %1) #16
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.173, i64 0, i64 0), i8* %2, i8* %4, i8* %5) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaT_objtypename(%struct.lua_State*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %1, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 69
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %1 to %struct.Table**
  %8 = load %struct.Table*, %struct.Table** %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.Table, %struct.Table* %8, i64 0, i32 9
  %10 = load %struct.Table*, %struct.Table** %9, align 8, !tbaa !21
  %11 = icmp eq %struct.Table* %10, null
  br i1 %11, label %35, label %21

; <label>:12:                                     ; preds = %2
  %13 = and i8 %4, 15
  %14 = icmp eq i8 %13, 7
  br i1 %14, label %15, label %35

; <label>:15:                                     ; preds = %12
  %16 = bitcast %struct.TValue* %1 to %struct.Udata**
  %17 = load %struct.Udata*, %struct.Udata** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.Udata, %struct.Udata* %17, i64 0, i32 5
  %19 = load %struct.Table*, %struct.Table** %18, align 8, !tbaa !21
  %20 = icmp eq %struct.Table* %19, null
  br i1 %20, label %35, label %21

; <label>:21:                                     ; preds = %6, %15
  %22 = phi %struct.Table* [ %10, %6 ], [ %19, %15 ]
  %23 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.20, i64 0, i64 0)) #16
  %24 = tail call fastcc %struct.TValue* @luaH_getshortstr(%struct.Table* nonnull %22, %struct.TString* %23) #16
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 4
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %21
  %30 = load i8, i8* %3, align 8, !tbaa !22
  br label %35

; <label>:31:                                     ; preds = %21
  %32 = bitcast %struct.TValue* %24 to i8**
  %33 = load i8*, i8** %32, align 8, !tbaa !21
  %34 = getelementptr inbounds i8, i8* %33, i64 24
  br label %42

; <label>:35:                                     ; preds = %29, %6, %15, %12
  %36 = phi i8 [ %30, %29 ], [ 69, %6 ], [ %4, %15 ], [ %4, %12 ]
  %37 = and i8 %36, 15
  %38 = add nuw nsw i8 %37, 1
  %39 = zext i8 %38 to i64
  %40 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %39
  %41 = load i8*, i8** %40, align 8, !tbaa !54
  br label %42

; <label>:42:                                     ; preds = %31, %35
  %43 = phi i8* [ %41, %35 ], [ %34, %31 ]
  ret i8* %43
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @varinfo(%struct.lua_State*, %struct.TValue*) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  store i8* null, i8** %3, align 8, !tbaa !54
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 7
  %8 = load i16, i16* %7, align 2, !tbaa !63
  %9 = and i16 %8, 2
  %10 = icmp eq i16 %9, 0
  br i1 %10, label %11, label %77

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.CallInfo* %6 to %struct.LClosure***
  %13 = load %struct.LClosure**, %struct.LClosure*** %12, align 8, !tbaa !64
  %14 = load %struct.LClosure*, %struct.LClosure** %13, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 3
  %16 = load i8, i8* %15, align 2, !tbaa !182
  %17 = icmp eq i8 %16, 0
  br i1 %17, label %42, label %18

; <label>:18:                                     ; preds = %11
  %19 = zext i8 %16 to i64
  br label %20

; <label>:20:                                     ; preds = %27, %18
  %21 = phi i64 [ 0, %18 ], [ %28, %27 ]
  %22 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 6, i64 %21
  %23 = load %struct.UpVal*, %struct.UpVal** %22, align 8, !tbaa !54
  %24 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %23, i64 0, i32 3
  %25 = load %struct.TValue*, %struct.TValue** %24, align 8, !tbaa !67
  %26 = icmp eq %struct.TValue* %25, %1
  br i1 %26, label %30, label %27

; <label>:27:                                     ; preds = %20
  %28 = add nuw nsw i64 %21, 1
  %29 = icmp ult i64 %28, %19
  br i1 %29, label %20, label %42

; <label>:30:                                     ; preds = %20
  %31 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 5
  %32 = load %struct.Proto*, %struct.Proto** %31, align 8, !tbaa !197
  %33 = getelementptr inbounds %struct.Proto, %struct.Proto* %32, i64 0, i32 18
  %34 = load %struct.Upvaldesc*, %struct.Upvaldesc** %33, align 8, !tbaa !198
  %35 = and i64 %21, 4294967295
  %36 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %34, i64 %35, i32 0
  %37 = load %struct.TString*, %struct.TString** %36, align 8, !tbaa !199
  %38 = icmp eq %struct.TString* %37, null
  %39 = getelementptr inbounds %struct.TString, %struct.TString* %37, i64 1
  %40 = bitcast %struct.TString* %39 to i8*
  %41 = select i1 %38, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %40
  store i8* %41, i8** %3, align 8, !tbaa !54
  br label %73

; <label>:42:                                     ; preds = %27, %11
  %43 = getelementptr inbounds %struct.LClosure*, %struct.LClosure** %13, i64 2
  %44 = ptrtoint %struct.TValue* %1 to i64
  %45 = ptrtoint %struct.LClosure** %43 to i64
  %46 = sub i64 %44, %45
  %47 = icmp sgt i64 %46, -16
  br i1 %47, label %48, label %77

; <label>:48:                                     ; preds = %42
  %49 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 1
  %50 = bitcast %union.StackValue** %49 to i64*
  %51 = load i64, i64* %50, align 8, !tbaa !66
  %52 = sub i64 %51, %45
  %53 = icmp slt i64 %46, %52
  br i1 %53, label %54, label %77

; <label>:54:                                     ; preds = %48
  %55 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %14, i64 0, i32 5
  %56 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !21
  %57 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 4
  %58 = bitcast %union.anon.0* %57 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !21
  %60 = getelementptr inbounds %struct.Proto, %struct.Proto* %56, i64 0, i32 16
  %61 = bitcast i32** %60 to i64*
  %62 = load i64, i64* %61, align 8, !tbaa !116
  %63 = sub i64 %59, %62
  %64 = lshr exact i64 %63, 2
  %65 = trunc i64 %64 to i32
  %66 = add nsw i32 %65, -1
  %67 = lshr exact i64 %46, 4
  %68 = trunc i64 %67 to i32
  %69 = call fastcc i8* @getobjname(%struct.Proto* %56, i32 %66, i32 %68, i8** nonnull %3) #16
  %70 = icmp eq i8* %69, null
  br i1 %70, label %77, label %71

; <label>:71:                                     ; preds = %54
  %72 = load i8*, i8** %3, align 8, !tbaa !54
  br label %73

; <label>:73:                                     ; preds = %71, %30
  %74 = phi i8* [ %41, %30 ], [ %72, %71 ]
  %75 = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.159, i64 0, i64 0), %30 ], [ %69, %71 ]
  %76 = call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.174, i64 0, i64 0), i8* nonnull %75, i8* %74) #16
  br label %77

; <label>:77:                                     ; preds = %48, %42, %2, %54, %73
  %78 = phi i8* [ %76, %73 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %54 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %2 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %48 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), %42 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %78
}

; Function Attrs: nounwind optsize uwtable
define internal i8* @luaO_pushfstring(%struct.lua_State*, i8*, ...) unnamed_addr #0 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #7
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  call void @llvm.va_start(i8* nonnull %4)
  %6 = call fastcc i8* @luaO_pushvfstring(%struct.lua_State* %0, i8* %1, %struct.__va_list_tag* nonnull %5) #16
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #7
  ret i8* %6
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @l_strcmp(%struct.TString* nocapture readonly, %struct.TString* nocapture readonly) unnamed_addr #12 {
  %3 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %4 = bitcast %struct.TString* %3 to i8*
  %5 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !75
  %7 = icmp eq i8 %6, 20
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %10 = load i8, i8* %9, align 1, !tbaa !123
  %11 = zext i8 %10 to i64
  br label %15

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %14 = load i64, i64* %13, align 8, !tbaa !21
  br label %15

; <label>:15:                                     ; preds = %12, %8
  %16 = phi i64 [ %11, %8 ], [ %14, %12 ]
  %17 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 1
  %18 = bitcast %struct.TString* %17 to i8*
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !75
  %21 = icmp eq i8 %20, 20
  br i1 %21, label %22, label %26

; <label>:22:                                     ; preds = %15
  %23 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 4
  %24 = load i8, i8* %23, align 1, !tbaa !123
  %25 = zext i8 %24 to i64
  br label %29

; <label>:26:                                     ; preds = %15
  %27 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 6, i32 0
  %28 = load i64, i64* %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %26, %22
  %30 = phi i64 [ %25, %22 ], [ %28, %26 ]
  %31 = tail call i32 @strcoll(i8* nonnull %4, i8* nonnull %18) #21
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %33, label %54

; <label>:33:                                     ; preds = %29
  br label %34

; <label>:34:                                     ; preds = %33, %46
  %35 = phi i64 [ %51, %46 ], [ %30, %33 ]
  %36 = phi i8* [ %50, %46 ], [ %18, %33 ]
  %37 = phi i64 [ %49, %46 ], [ %16, %33 ]
  %38 = phi i8* [ %48, %46 ], [ %4, %33 ]
  %39 = tail call i64 @strlen(i8* %38) #21
  %40 = icmp eq i64 %39, %35
  %41 = icmp eq i64 %39, %37
  br i1 %40, label %42, label %45

; <label>:42:                                     ; preds = %34
  %43 = xor i1 %41, true
  %44 = zext i1 %43 to i32
  br label %54

; <label>:45:                                     ; preds = %34
  br i1 %41, label %54, label %46

; <label>:46:                                     ; preds = %45
  %47 = add i64 %39, 1
  %48 = getelementptr inbounds i8, i8* %38, i64 %47
  %49 = sub i64 %37, %47
  %50 = getelementptr inbounds i8, i8* %36, i64 %47
  %51 = sub i64 %35, %47
  %52 = tail call i32 @strcoll(i8* %48, i8* %50) #21
  %53 = icmp eq i32 %52, 0
  br i1 %53, label %34, label %54

; <label>:54:                                     ; preds = %46, %45, %29, %42
  %55 = phi i32 [ %44, %42 ], [ %31, %29 ], [ %52, %46 ], [ -1, %45 ]
  ret i32 %55
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaT_callorderTM(%struct.lua_State*, %struct.TValue*, %struct.TValue*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = tail call fastcc i32 @callbinTM(%struct.lua_State* %0, %struct.TValue* %1, %struct.TValue* %2, %union.StackValue* %6, i32 %3) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %25, label %9

; <label>:9:                                      ; preds = %4
  %10 = bitcast %union.StackValue** %5 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %13 = load i8, i8* %12, align 8, !tbaa !21
  %14 = and i8 %13, 15
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %23, label %16

; <label>:16:                                     ; preds = %9
  %17 = icmp eq i8 %13, 1
  br i1 %17, label %18, label %23

; <label>:18:                                     ; preds = %16
  %19 = bitcast %struct.TValue* %11 to i32*
  %20 = load i32, i32* %19, align 8, !tbaa !21
  %21 = icmp ne i32 %20, 0
  %22 = zext i1 %21 to i32
  br label %23

; <label>:23:                                     ; preds = %16, %18, %9
  %24 = phi i32 [ 0, %9 ], [ 1, %16 ], [ %22, %18 ]
  ret i32 %24

; <label>:25:                                     ; preds = %4
  tail call fastcc void @luaG_ordererror(%struct.lua_State* nonnull %0, %struct.TValue* %1, %struct.TValue* %2) #18
  unreachable
}

; Function Attrs: nounwind optsize readonly
declare i32 @strcoll(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaG_ordererror(%struct.lua_State*, %struct.TValue*, %struct.TValue*) unnamed_addr #5 {
  %4 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %1) #16
  %5 = tail call fastcc i8* @luaT_objtypename(%struct.lua_State* %0, %struct.TValue* %2) #16
  %6 = tail call i32 @strcmp(i8* %4, i8* %5) #21
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.176, i64 0, i64 0), i8* %4) #18
  unreachable

; <label>:9:                                      ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.177, i64 0, i64 0), i8* %4, i8* %5) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = shl i32 %1, 3
  %4 = add nsw i32 %3, 32
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 %5, i32 6) #17
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 10
  %10 = load i8, i8* %9, align 4, !tbaa !15
  %11 = and i8 %10, 24
  %12 = getelementptr inbounds i8, i8* %8, i64 9
  store i8 %11, i8* %12, align 1, !tbaa !70
  %13 = getelementptr inbounds i8, i8* %8, i64 8
  store i8 22, i8* %13, align 8, !tbaa !86
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 20
  %15 = bitcast %struct.GCObject** %14 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !18
  %17 = bitcast i8* %8 to i64*
  store i64 %16, i64* %17, align 8, !tbaa !87
  %18 = bitcast %struct.GCObject** %14 to i8**
  store i8* %8, i8** %18, align 8, !tbaa !18
  %19 = bitcast i8* %8 to %struct.LClosure*
  %20 = getelementptr inbounds i8, i8* %8, i64 24
  %21 = bitcast i8* %20 to %struct.Proto**
  store %struct.Proto* null, %struct.Proto** %21, align 8, !tbaa !197
  %22 = trunc i32 %1 to i8
  %23 = getelementptr inbounds i8, i8* %8, i64 10
  store i8 %22, i8* %23, align 2, !tbaa !182
  %24 = icmp eq i32 %1, 0
  br i1 %24, label %36, label %25

; <label>:25:                                     ; preds = %2
  %26 = sext i32 %1 to i64
  %27 = shl nsw i64 %26, 3
  %28 = add nsw i64 %27, 24
  %29 = add i32 %1, -1
  %30 = zext i32 %29 to i64
  %31 = shl nuw nsw i64 %30, 3
  %32 = sub nsw i64 %28, %31
  %33 = getelementptr i8, i8* %8, i64 %32
  %34 = zext i32 %1 to i64
  %35 = shl nuw nsw i64 %34, 3
  call void @llvm.memset.p0i8.i64(i8* %33, i8 0, i64 %35, i32 8, i1 false)
  br label %36

; <label>:36:                                     ; preds = %25, %2
  ret %struct.LClosure* %19
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.UpVal* @luaF_findupval(%struct.lua_State*, %union.StackValue*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %4 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !54
  %5 = icmp eq %struct.UpVal* %4, null
  br i1 %5, label %30, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %8

; <label>:8:                                      ; preds = %6, %26
  %9 = phi %struct.UpVal* [ %4, %6 ], [ %28, %26 ]
  %10 = phi %struct.UpVal** [ %3, %6 ], [ %27, %26 ]
  %11 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 3
  %12 = bitcast %struct.TValue** %11 to %union.StackValue**
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !67
  %14 = icmp ult %union.StackValue* %13, %1
  br i1 %14, label %30, label %15

; <label>:15:                                     ; preds = %8
  %16 = icmp eq %union.StackValue* %13, %1
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %15
  %18 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 2
  %19 = load i8, i8* %18, align 1, !tbaa !69
  %20 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %21 = getelementptr inbounds %struct.global_State, %struct.global_State* %20, i64 0, i32 10
  %22 = load i8, i8* %21, align 4, !tbaa !15
  %23 = xor i8 %22, 24
  %24 = and i8 %23, %19
  %25 = icmp eq i8 %24, 0
  br i1 %25, label %33, label %26

; <label>:26:                                     ; preds = %17, %15
  %27 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %9, i64 0, i32 4, i32 0, i32 0
  %28 = load %struct.UpVal*, %struct.UpVal** %27, align 8, !tbaa !54
  %29 = icmp eq %struct.UpVal* %28, null
  br i1 %29, label %30, label %8

; <label>:30:                                     ; preds = %26, %8, %2
  %31 = phi %struct.UpVal** [ %3, %2 ], [ %10, %8 ], [ %27, %26 ]
  %32 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 9, %union.StackValue* %1, %struct.UpVal** nonnull %31) #16
  br label %33

; <label>:33:                                     ; preds = %17, %30
  %34 = phi %struct.UpVal* [ %32, %30 ], [ %9, %17 ]
  ret %struct.UpVal* %34
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.UpVal* @newupval(%struct.lua_State*, i32, %union.StackValue*, %struct.UpVal**) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = and i32 %1, 15
  %8 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 40, i32 %7) #17
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 10
  %10 = load i8, i8* %9, align 4, !tbaa !15
  %11 = and i8 %10, 24
  %12 = getelementptr inbounds i8, i8* %8, i64 9
  store i8 %11, i8* %12, align 1, !tbaa !70
  %13 = trunc i32 %1 to i8
  %14 = getelementptr inbounds i8, i8* %8, i64 8
  store i8 %13, i8* %14, align 8, !tbaa !86
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 20
  %16 = bitcast %struct.GCObject** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !18
  %18 = bitcast i8* %8 to i64*
  store i64 %17, i64* %18, align 8, !tbaa !87
  %19 = bitcast %struct.GCObject** %15 to i8**
  store i8* %8, i8** %19, align 8, !tbaa !18
  %20 = bitcast i8* %8 to %struct.UpVal*
  %21 = load %struct.UpVal*, %struct.UpVal** %3, align 8, !tbaa !54
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %2, i64 0, i32 0
  %23 = getelementptr inbounds i8, i8* %8, i64 16
  %24 = bitcast i8* %23 to %struct.TValue**
  store %struct.TValue* %22, %struct.TValue** %24, align 8, !tbaa !67
  %25 = getelementptr inbounds i8, i8* %8, i64 24
  %26 = bitcast i8* %25 to %struct.UpVal**
  store %struct.UpVal* %21, %struct.UpVal** %26, align 8, !tbaa !21
  %27 = getelementptr inbounds i8, i8* %8, i64 32
  %28 = bitcast i8* %27 to %struct.UpVal***
  store %struct.UpVal** %3, %struct.UpVal*** %28, align 8, !tbaa !21
  %29 = icmp eq %struct.UpVal* %21, null
  br i1 %29, label %33, label %30

; <label>:30:                                     ; preds = %4
  %31 = getelementptr inbounds %struct.UpVal, %struct.UpVal* %21, i64 0, i32 4, i32 0, i32 1
  %32 = bitcast %struct.UpVal*** %31 to i8**
  store i8* %25, i8** %32, align 8, !tbaa !21
  br label %33

; <label>:33:                                     ; preds = %4, %30
  %34 = bitcast %struct.UpVal** %3 to i8**
  store i8* %8, i8** %34, align 8, !tbaa !54
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 14
  %36 = load %struct.lua_State*, %struct.lua_State** %35, align 8, !tbaa !27
  %37 = icmp eq %struct.lua_State* %36, %0
  br i1 %37, label %38, label %44

; <label>:38:                                     ; preds = %33
  %39 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %39, i64 0, i32 36
  %41 = bitcast %struct.lua_State** %40 to i64*
  %42 = load i64, i64* %41, align 8, !tbaa !236
  %43 = bitcast %struct.lua_State** %35 to i64*
  store i64 %42, i64* %43, align 8, !tbaa !27
  store %struct.lua_State* %0, %struct.lua_State** %40, align 8, !tbaa !236
  br label %44

; <label>:44:                                     ; preds = %33, %38
  ret %struct.UpVal* %20
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @finishCcall(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 7
  %6 = load i16, i16* %5, align 2, !tbaa !63
  %7 = and i16 %6, 8
  %8 = icmp eq i16 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %2
  %10 = and i16 %6, -9
  store i16 %10, i16* %5, align 2, !tbaa !63
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 1
  %12 = load i64, i64* %11, align 8, !tbaa !21
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 18
  store i64 %12, i64* %13, align 8, !tbaa !36
  br label %14

; <label>:14:                                     ; preds = %2, %9
  %15 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 6
  %16 = load i16, i16* %15, align 4, !tbaa !65
  %17 = icmp slt i16 %16, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %14
  %19 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 1
  %20 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !66
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %23 = icmp ult %union.StackValue* %20, %22
  br i1 %23, label %24, label %25

; <label>:24:                                     ; preds = %18
  store %union.StackValue* %22, %union.StackValue** %19, align 8, !tbaa !66
  br label %25

; <label>:25:                                     ; preds = %24, %18, %14
  %26 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 0
  %27 = load i32 (%struct.lua_State*, i32, i64)*, i32 (%struct.lua_State*, i32, i64)** %26, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 4, i32 0, i32 2
  %29 = load i64, i64* %28, align 8, !tbaa !21
  %30 = tail call i32 %27(%struct.lua_State* nonnull %0, i32 %1, i64 %29) #17
  tail call fastcc void @luaD_poscall(%struct.lua_State* nonnull %0, %struct.CallInfo* nonnull %4, i32 %30) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaG_addinfo(%struct.lua_State*, i8*, %struct.TString*, i32) unnamed_addr #0 {
  %5 = alloca [60 x i8], align 16
  %6 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 60, i8* nonnull %6) #7
  %7 = icmp eq %struct.TString* %2, null
  br i1 %7, label %23, label %8

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 1
  %10 = bitcast %struct.TString* %9 to i8*
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !75
  %13 = icmp eq i8 %12, 20
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %8
  %15 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 4
  %16 = load i8, i8* %15, align 1, !tbaa !123
  %17 = zext i8 %16 to i64
  br label %21

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds %struct.TString, %struct.TString* %2, i64 0, i32 6, i32 0
  %20 = load i64, i64* %19, align 8, !tbaa !21
  br label %21

; <label>:21:                                     ; preds = %18, %14
  %22 = phi i64 [ %17, %14 ], [ %20, %18 ]
  call fastcc void @luaO_chunkid(i8* nonnull %6, i8* nonnull %10, i64 %22) #16
  br label %25

; <label>:23:                                     ; preds = %4
  store i8 63, i8* %6, align 16, !tbaa !21
  %24 = getelementptr inbounds [60 x i8], [60 x i8]* %5, i64 0, i64 1
  store i8 0, i8* %24, align 1, !tbaa !21
  br label %25

; <label>:25:                                     ; preds = %23, %21
  %26 = call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.180, i64 0, i64 0), i8* nonnull %6, i32 %3, i8* %1) #16
  call void @llvm.lifetime.end.p0i8(i64 60, i8* nonnull %6) #7
  ret i8* %26
}

; Function Attrs: noreturn nounwind optsize
declare void @longjmp(%struct.__jmp_buf_tag*, i32) local_unnamed_addr #15

; Function Attrs: noreturn nounwind optsize
declare void @abort() local_unnamed_addr #15

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaO_rawarith(%struct.lua_State*, i32, %struct.TValue* nocapture readonly, %struct.TValue* nocapture readonly, %struct.TValue* nocapture) unnamed_addr #0 {
  switch i32 %1, label %72 [
    i32 7, label %6
    i32 8, label %6
    i32 9, label %6
    i32 10, label %6
    i32 11, label %6
    i32 13, label %6
    i32 5, label %46
    i32 4, label %46
  ]

; <label>:6:                                      ; preds = %5, %5, %5, %5, %5, %5
  %7 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  switch i8 %8, label %109 [
    i8 35, label %9
    i8 19, label %12
  ]

; <label>:9:                                      ; preds = %6
  %10 = bitcast %struct.TValue* %2 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !21
  br label %23

; <label>:12:                                     ; preds = %6
  %13 = bitcast %struct.TValue* %2 to double*
  %14 = load double, double* %13, align 8, !tbaa !21
  %15 = tail call double @llvm.floor.f64(double %14) #7
  %16 = fcmp une double %15, %14
  br i1 %16, label %109, label %17

; <label>:17:                                     ; preds = %12
  %18 = fcmp oge double %15, 0xC3E0000000000000
  %19 = fcmp olt double %15, 0x43E0000000000000
  %20 = and i1 %18, %19
  br i1 %20, label %21, label %109

; <label>:21:                                     ; preds = %17
  %22 = fptosi double %15 to i64
  br label %23

; <label>:23:                                     ; preds = %21, %9
  %24 = phi i64 [ %11, %9 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  switch i8 %26, label %109 [
    i8 35, label %27
    i8 19, label %30
  ]

; <label>:27:                                     ; preds = %23
  %28 = bitcast %struct.TValue* %3 to i64*
  %29 = load i64, i64* %28, align 8, !tbaa !21
  br label %41

; <label>:30:                                     ; preds = %23
  %31 = bitcast %struct.TValue* %3 to double*
  %32 = load double, double* %31, align 8, !tbaa !21
  %33 = tail call double @llvm.floor.f64(double %32) #7
  %34 = fcmp une double %33, %32
  br i1 %34, label %109, label %35

; <label>:35:                                     ; preds = %30
  %36 = fcmp oge double %33, 0xC3E0000000000000
  %37 = fcmp olt double %33, 0x43E0000000000000
  %38 = and i1 %36, %37
  br i1 %38, label %39, label %109

; <label>:39:                                     ; preds = %35
  %40 = fptosi double %33 to i64
  br label %41

; <label>:41:                                     ; preds = %39, %27
  %42 = phi i64 [ %29, %27 ], [ %40, %39 ]
  %43 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %24, i64 %42) #16
  %44 = bitcast %struct.TValue* %4 to i64*
  store i64 %43, i64* %44, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %45, align 8, !tbaa !22
  br label %109

; <label>:46:                                     ; preds = %5, %5
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !22
  switch i8 %48, label %109 [
    i8 19, label %49
    i8 35, label %52
  ]

; <label>:49:                                     ; preds = %46
  %50 = bitcast %struct.TValue* %2 to double*
  %51 = load double, double* %50, align 8, !tbaa !21
  br label %56

; <label>:52:                                     ; preds = %46
  %53 = bitcast %struct.TValue* %2 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21
  %55 = sitofp i64 %54 to double
  br label %56

; <label>:56:                                     ; preds = %49, %52
  %57 = phi double [ %51, %49 ], [ %55, %52 ]
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %59 = load i8, i8* %58, align 8, !tbaa !22
  switch i8 %59, label %109 [
    i8 19, label %60
    i8 35, label %63
  ]

; <label>:60:                                     ; preds = %56
  %61 = bitcast %struct.TValue* %3 to double*
  %62 = load double, double* %61, align 8, !tbaa !21
  br label %67

; <label>:63:                                     ; preds = %56
  %64 = bitcast %struct.TValue* %3 to i64*
  %65 = load i64, i64* %64, align 8, !tbaa !21
  %66 = sitofp i64 %65 to double
  br label %67

; <label>:67:                                     ; preds = %60, %63
  %68 = phi double [ %62, %60 ], [ %66, %63 ]
  %69 = tail call fastcc double @numarith(i32 %1, double %57, double %68) #16
  %70 = bitcast %struct.TValue* %4 to double*
  store double %69, double* %70, align 8, !tbaa !21
  %71 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %71, align 8, !tbaa !22
  br label %109

; <label>:72:                                     ; preds = %5
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %74 = load i8, i8* %73, align 8, !tbaa !22
  switch i8 %74, label %109 [
    i8 35, label %75
    i8 19, label %87
  ]

; <label>:75:                                     ; preds = %72
  %76 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !22
  %78 = icmp eq i8 %77, 35
  %79 = bitcast %struct.TValue* %2 to i64*
  %80 = load i64, i64* %79, align 8, !tbaa !21
  br i1 %78, label %81, label %92

; <label>:81:                                     ; preds = %75
  %82 = bitcast %struct.TValue* %3 to i64*
  %83 = load i64, i64* %82, align 8, !tbaa !21
  %84 = tail call fastcc i64 @intarith(%struct.lua_State* %0, i32 %1, i64 %80, i64 %83) #16
  %85 = bitcast %struct.TValue* %4 to i64*
  store i64 %84, i64* %85, align 8, !tbaa !21
  %86 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 35, i8* %86, align 8, !tbaa !22
  br label %109

; <label>:87:                                     ; preds = %72
  %88 = bitcast %struct.TValue* %2 to double*
  %89 = load double, double* %88, align 8, !tbaa !21
  %90 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %91 = load i8, i8* %90, align 8, !tbaa !22
  br label %94

; <label>:92:                                     ; preds = %75
  %93 = sitofp i64 %80 to double
  br label %94

; <label>:94:                                     ; preds = %87, %92
  %95 = phi i8 [ %91, %87 ], [ %77, %92 ]
  %96 = phi double [ %89, %87 ], [ %93, %92 ]
  switch i8 %95, label %109 [
    i8 19, label %97
    i8 35, label %100
  ]

; <label>:97:                                     ; preds = %94
  %98 = bitcast %struct.TValue* %3 to double*
  %99 = load double, double* %98, align 8, !tbaa !21
  br label %104

; <label>:100:                                    ; preds = %94
  %101 = bitcast %struct.TValue* %3 to i64*
  %102 = load i64, i64* %101, align 8, !tbaa !21
  %103 = sitofp i64 %102 to double
  br label %104

; <label>:104:                                    ; preds = %97, %100
  %105 = phi double [ %99, %97 ], [ %103, %100 ]
  %106 = tail call fastcc double @numarith(i32 %1, double %96, double %105) #16
  %107 = bitcast %struct.TValue* %4 to double*
  store double %106, double* %107, align 8, !tbaa !21
  %108 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %108, align 8, !tbaa !22
  br label %109

; <label>:109:                                    ; preds = %72, %23, %6, %30, %35, %12, %17, %41, %81, %104, %94, %67, %56, %46
  %110 = phi i32 [ 1, %67 ], [ 0, %56 ], [ 0, %46 ], [ 1, %81 ], [ 1, %104 ], [ 0, %94 ], [ 1, %41 ], [ 0, %17 ], [ 0, %12 ], [ 0, %35 ], [ 0, %30 ], [ 0, %6 ], [ 0, %23 ], [ 0, %72 ]
  ret i32 %110
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @intarith(%struct.lua_State*, i32, i64, i64) unnamed_addr #0 {
  switch i32 %1, label %47 [
    i32 0, label %5
    i32 1, label %7
    i32 2, label %9
    i32 3, label %11
    i32 6, label %13
    i32 7, label %15
    i32 8, label %17
    i32 9, label %19
    i32 10, label %21
    i32 11, label %32
    i32 12, label %43
    i32 13, label %45
  ]

; <label>:5:                                      ; preds = %4
  %6 = add i64 %3, %2
  br label %47

; <label>:7:                                      ; preds = %4
  %8 = sub i64 %2, %3
  br label %47

; <label>:9:                                      ; preds = %4
  %10 = mul i64 %3, %2
  br label %47

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i64 @luaV_mod(%struct.lua_State* %0, i64 %2, i64 %3) #16
  br label %47

; <label>:13:                                     ; preds = %4
  %14 = tail call fastcc i64 @luaV_idiv(%struct.lua_State* %0, i64 %2, i64 %3) #16
  br label %47

; <label>:15:                                     ; preds = %4
  %16 = and i64 %3, %2
  br label %47

; <label>:17:                                     ; preds = %4
  %18 = or i64 %3, %2
  br label %47

; <label>:19:                                     ; preds = %4
  %20 = xor i64 %3, %2
  br label %47

; <label>:21:                                     ; preds = %4
  %22 = icmp slt i64 %3, 0
  br i1 %22, label %23, label %28

; <label>:23:                                     ; preds = %21
  %24 = icmp slt i64 %3, -63
  %25 = sub nsw i64 0, %3
  %26 = lshr i64 %2, %25
  %27 = select i1 %24, i64 0, i64 %26
  br label %47

; <label>:28:                                     ; preds = %21
  %29 = icmp sgt i64 %3, 63
  %30 = shl i64 %2, %3
  %31 = select i1 %29, i64 0, i64 %30
  br label %47

; <label>:32:                                     ; preds = %4
  %33 = icmp sgt i64 %3, 0
  br i1 %33, label %34, label %38

; <label>:34:                                     ; preds = %32
  %35 = icmp sgt i64 %3, 63
  %36 = lshr i64 %2, %3
  %37 = select i1 %35, i64 0, i64 %36
  br label %47

; <label>:38:                                     ; preds = %32
  %39 = sub nsw i64 0, %3
  %40 = icmp slt i64 %3, -63
  %41 = shl i64 %2, %39
  %42 = select i1 %40, i64 0, i64 %41
  br label %47

; <label>:43:                                     ; preds = %4
  %44 = sub i64 0, %2
  br label %47

; <label>:45:                                     ; preds = %4
  %46 = xor i64 %2, -1
  br label %47

; <label>:47:                                     ; preds = %34, %38, %23, %28, %4, %45, %43, %19, %17, %15, %13, %11, %9, %7, %5
  %48 = phi i64 [ %46, %45 ], [ %44, %43 ], [ %20, %19 ], [ %18, %17 ], [ %16, %15 ], [ %14, %13 ], [ %12, %11 ], [ %10, %9 ], [ %8, %7 ], [ %6, %5 ], [ 0, %4 ], [ %27, %23 ], [ %31, %28 ], [ %37, %34 ], [ %42, %38 ]
  ret i64 %48
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc double @numarith(i32, double, double) unnamed_addr #0 {
  switch i32 %0, label %30 [
    i32 0, label %4
    i32 1, label %6
    i32 2, label %8
    i32 5, label %10
    i32 4, label %12
    i32 6, label %14
    i32 12, label %17
    i32 3, label %19
  ]

; <label>:4:                                      ; preds = %3
  %5 = fadd double %1, %2
  br label %30

; <label>:6:                                      ; preds = %3
  %7 = fsub double %1, %2
  br label %30

; <label>:8:                                      ; preds = %3
  %9 = fmul double %1, %2
  br label %30

; <label>:10:                                     ; preds = %3
  %11 = fdiv double %1, %2
  br label %30

; <label>:12:                                     ; preds = %3
  %13 = tail call double @pow(double %1, double %2) #17
  br label %30

; <label>:14:                                     ; preds = %3
  %15 = fdiv double %1, %2
  %16 = tail call double @llvm.floor.f64(double %15)
  br label %30

; <label>:17:                                     ; preds = %3
  %18 = fsub double -0.000000e+00, %1
  br label %30

; <label>:19:                                     ; preds = %3
  %20 = tail call double @fmod(double %1, double %2) #17
  %21 = fcmp ogt double %20, 0.000000e+00
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %19
  %23 = fcmp olt double %2, 0.000000e+00
  br i1 %23, label %28, label %30

; <label>:24:                                     ; preds = %19
  %25 = fcmp olt double %20, 0.000000e+00
  %26 = fcmp ogt double %2, 0.000000e+00
  %27 = and i1 %26, %25
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %24, %22
  %29 = fadd double %20, %2
  br label %30

; <label>:30:                                     ; preds = %28, %24, %22, %3, %17, %14, %12, %10, %8, %6, %4
  %31 = phi double [ %18, %17 ], [ %16, %14 ], [ %13, %12 ], [ %11, %10 ], [ %9, %8 ], [ %7, %6 ], [ %5, %4 ], [ 0.000000e+00, %3 ], [ %29, %28 ], [ %20, %22 ], [ %20, %24 ]
  ret double %31
}

; Function Attrs: nounwind optsize readonly
declare i8* @strpbrk(i8*, i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @l_str2dloc(i8*, double* nocapture) unnamed_addr #0 {
  %3 = alloca i8*, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call double @strtod(i8* %0, i8** nonnull %3) #17
  store double %5, double* %1, align 8, !tbaa !140
  %6 = load i8*, i8** %3, align 8, !tbaa !54
  %7 = icmp eq i8* %6, %0
  br i1 %7, label %33, label %8

; <label>:8:                                      ; preds = %2
  %9 = load i8, i8* %6, align 1, !tbaa !21
  %10 = zext i8 %9 to i64
  %11 = add nuw nsw i64 %10, 1
  %12 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %11
  %13 = load i8, i8* %12, align 1, !tbaa !21
  %14 = and i8 %13, 8
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %28, label %16

; <label>:16:                                     ; preds = %8
  br label %17

; <label>:17:                                     ; preds = %16, %17
  %18 = phi i8* [ %19, %17 ], [ %6, %16 ]
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  %20 = load i8, i8* %19, align 1, !tbaa !21
  %21 = zext i8 %20 to i64
  %22 = add nuw nsw i64 %21, 1
  %23 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %22
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = and i8 %24, 8
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %27, label %17

; <label>:27:                                     ; preds = %17
  store i8* %19, i8** %3, align 8, !tbaa !54
  br label %28

; <label>:28:                                     ; preds = %27, %8
  %29 = phi i8* [ %19, %27 ], [ %6, %8 ]
  %30 = phi i8 [ %20, %27 ], [ %9, %8 ]
  %31 = icmp eq i8 %30, 0
  %32 = select i1 %31, i8* %29, i8* null
  br label %33

; <label>:33:                                     ; preds = %2, %28
  %34 = phi i8* [ %32, %28 ], [ null, %2 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i8* %34
}

; Function Attrs: nounwind optsize
declare i8* @strcpy(i8*, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare %struct.lconv* @localeconv() local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @strtod(i8* readonly, i8** nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @tostringbuff(%struct.TValue* nocapture readonly, i8* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.TValue, %struct.TValue* %0, i64 0, i32 1
  %4 = load i8, i8* %3, align 8, !tbaa !22
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %6, label %11

; <label>:6:                                      ; preds = %2
  %7 = bitcast %struct.TValue* %0 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !21
  %9 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %8) #17
  %10 = sext i32 %9 to i64
  br label %29

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.TValue* %0 to double*
  %13 = load double, double* %12, align 8, !tbaa !21
  %14 = tail call i32 (i8*, i64, i8*, ...) @snprintf(i8* %1, i64 50, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %13) #17
  %15 = sext i32 %14 to i64
  %16 = tail call i64 @strspn(i8* %1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.191, i64 0, i64 0)) #21
  %17 = getelementptr inbounds i8, i8* %1, i64 %16
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = icmp eq i8 %18, 0
  br i1 %19, label %20, label %29

; <label>:20:                                     ; preds = %11
  %21 = tail call %struct.lconv* @localeconv() #17
  %22 = getelementptr inbounds %struct.lconv, %struct.lconv* %21, i64 0, i32 0
  %23 = load i8*, i8** %22, align 8, !tbaa !142
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = add nsw i64 %15, 1
  %26 = getelementptr inbounds i8, i8* %1, i64 %15
  store i8 %24, i8* %26, align 1, !tbaa !21
  %27 = add nsw i64 %15, 2
  %28 = getelementptr inbounds i8, i8* %1, i64 %25
  store i8 48, i8* %28, align 1, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %11, %20, %6
  %30 = phi i64 [ %10, %6 ], [ %27, %20 ], [ %15, %11 ]
  ret i64 %30
}

; Function Attrs: nounwind optsize
declare i32 @snprintf(i8* nocapture, i64, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: nounwind optsize readonly
declare i64 @strspn(i8* nocapture, i8* nocapture) local_unnamed_addr #4

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaM_toobig(%struct.lua_State*) unnamed_addr #5 {
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.192, i64 0, i64 0)) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @addstr2buff(%struct.BuffFS*, i8*, i64) unnamed_addr #0 {
  %4 = icmp ult i64 %2, 401
  br i1 %4, label %5, label %20

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %7 = load i32, i32* %6, align 4, !tbaa !151
  %8 = sext i32 %7 to i64
  %9 = sub nsw i64 400, %8
  %10 = icmp ult i64 %9, %2
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %5
  %12 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 0
  tail call fastcc void @pushstr(%struct.BuffFS* nonnull %0, i8* nonnull %12, i64 %8) #17
  store i32 0, i32* %6, align 4, !tbaa !151
  br label %13

; <label>:13:                                     ; preds = %5, %11
  %14 = phi i32 [ %7, %5 ], [ 0, %11 ]
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 %15
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %16, i8* %1, i64 %2, i32 1, i1 false)
  %17 = load i32, i32* %6, align 4, !tbaa !151
  %18 = trunc i64 %2 to i32
  %19 = add i32 %17, %18
  store i32 %19, i32* %6, align 4, !tbaa !151
  br label %25

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 0
  %22 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %23 = load i32, i32* %22, align 4, !tbaa !151
  %24 = sext i32 %23 to i64
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* nonnull %21, i64 %24) #17
  store i32 0, i32* %22, align 4, !tbaa !151
  tail call fastcc void @pushstr(%struct.BuffFS* %0, i8* %1, i64 %2) #16
  br label %25

; <label>:25:                                     ; preds = %20, %13
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @addnum2buff(%struct.BuffFS*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 2
  %4 = load i32, i32* %3, align 4, !tbaa !151
  %5 = sext i32 %4 to i64
  %6 = sub nsw i64 400, %5
  %7 = icmp ult i64 %6, 50
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 0
  tail call fastcc void @pushstr(%struct.BuffFS* nonnull %0, i8* nonnull %9, i64 %5) #17
  store i32 0, i32* %3, align 4, !tbaa !151
  br label %10

; <label>:10:                                     ; preds = %2, %8
  %11 = phi i32 [ %4, %2 ], [ 0, %8 ]
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 3, i64 %12
  %14 = tail call fastcc i64 @tostringbuff(%struct.TValue* %1, i8* nonnull %13) #16
  %15 = load i32, i32* %3, align 4, !tbaa !151
  %16 = trunc i64 %14 to i32
  %17 = add i32 %15, %16
  store i32 %17, i32* %3, align 4, !tbaa !151
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i32 @luaO_utf8esc(i8* nocapture, i64) unnamed_addr #2 {
  %3 = icmp ult i64 %1, 128
  br i1 %3, label %28, label %4

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %6 = phi i64 [ %12, %5 ], [ 1, %4 ]
  %7 = phi i64 [ %15, %5 ], [ %1, %4 ]
  %8 = phi i32 [ %16, %5 ], [ 63, %4 ]
  %9 = trunc i64 %7 to i8
  %10 = and i8 %9, 63
  %11 = or i8 %10, -128
  %12 = add nuw i64 %6, 1
  %13 = sub nsw i64 8, %6
  %14 = getelementptr inbounds i8, i8* %0, i64 %13
  store i8 %11, i8* %14, align 1, !tbaa !21
  %15 = lshr i64 %7, 6
  %16 = lshr i32 %8, 1
  %17 = zext i32 %16 to i64
  %18 = icmp ugt i64 %15, %17
  br i1 %18, label %5, label %19

; <label>:19:                                     ; preds = %5
  %20 = trunc i64 %12 to i32
  %21 = and i32 %8, 254
  %22 = xor i32 %21, 254
  %23 = zext i32 %22 to i64
  %24 = or i64 %15, %23
  %25 = shl i64 %6, 32
  %26 = sub i64 30064771072, %25
  %27 = ashr exact i64 %26, 32
  br label %28

; <label>:28:                                     ; preds = %2, %19
  %29 = phi i64 [ %27, %19 ], [ 7, %2 ]
  %30 = phi i64 [ %24, %19 ], [ %1, %2 ]
  %31 = phi i32 [ %20, %19 ], [ 1, %2 ]
  %32 = trunc i64 %30 to i8
  %33 = getelementptr inbounds i8, i8* %0, i64 %29
  store i8 %32, i8* %33, align 1, !tbaa !21
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @pushstr(%struct.BuffFS* nocapture, i8*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 0
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !154
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2) #16
  %10 = bitcast %struct.TValue* %8 to %struct.TString**
  store %struct.TString* %9, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %9, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !75
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %6, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.BuffFS, %struct.BuffFS* %0, i64 0, i32 1
  %18 = load i32, i32* %17, align 8, !tbaa !153
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* %17, align 8, !tbaa !153
  %20 = icmp sgt i32 %18, 0
  br i1 %20, label %21, label %27

; <label>:21:                                     ; preds = %3
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 3
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 10
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !62
  %25 = icmp ugt %union.StackValue* %22, %24
  br i1 %25, label %26, label %27

; <label>:26:                                     ; preds = %21
  tail call fastcc void @luaV_concat(%struct.lua_State* nonnull %5, i32 %19) #16
  store i32 1, i32* %17, align 8, !tbaa !153
  br label %27

; <label>:27:                                     ; preds = %26, %21, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TValue* @luaH_newkey(%struct.lua_State*, %struct.Table*, %struct.TValue* nocapture readonly) unnamed_addr #0 {
  %4 = alloca [32 x i32], align 16
  %5 = bitcast [32 x i32]* %4 to i8*
  %6 = alloca %struct.TValue, align 8
  %7 = bitcast %struct.TValue* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = and i8 %9, 15
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %12, label %13, !prof !61

; <label>:12:                                     ; preds = %3
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.201, i64 0, i64 0)) #18
  unreachable

; <label>:13:                                     ; preds = %3
  %14 = icmp eq i8 %9, 19
  br i1 %14, label %15, label %31

; <label>:15:                                     ; preds = %13
  %16 = bitcast %struct.TValue* %2 to double*
  %17 = load double, double* %16, align 8, !tbaa !21
  %18 = tail call double @llvm.floor.f64(double %17) #7
  %19 = fcmp une double %18, %17
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %15
  %21 = fcmp oge double %18, 0xC3E0000000000000
  %22 = fcmp olt double %18, 0x43E0000000000000
  %23 = and i1 %21, %22
  br i1 %23, label %24, label %28

; <label>:24:                                     ; preds = %20
  %25 = fptosi double %18 to i64
  %26 = bitcast %struct.TValue* %6 to i64*
  store i64 %25, i64* %26, align 8, !tbaa !21
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 35, i8* %27, align 8, !tbaa !22
  br label %31

; <label>:28:                                     ; preds = %20, %15
  %29 = fcmp uno double %17, 0.000000e+00
  br i1 %29, label %30, label %31, !prof !61

; <label>:30:                                     ; preds = %28
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.202, i64 0, i64 0)) #18
  unreachable

; <label>:31:                                     ; preds = %24, %28, %13
  %32 = phi i8* [ %27, %24 ], [ %8, %28 ], [ %8, %13 ]
  %33 = phi i8 [ 35, %24 ], [ 19, %28 ], [ %9, %13 ]
  %34 = phi %struct.TValue* [ %6, %24 ], [ %2, %28 ], [ %2, %13 ]
  %35 = zext i8 %33 to i32
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 0, i32 0
  %37 = call fastcc %union.Node* @mainposition(%struct.Table* %1, i32 %35, %union.Value* %36) #17
  %38 = getelementptr inbounds %union.Node, %union.Node* %37, i64 0, i32 0, i32 1
  %39 = load i8, i8* %38, align 8, !tbaa !21
  %40 = and i8 %39, 15
  %41 = icmp eq i8 %40, 0
  %42 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 8
  %43 = load %union.Node*, %union.Node** %42, align 8, !tbaa !147
  %44 = icmp eq %union.Node* %43, null
  br i1 %41, label %45, label %46

; <label>:45:                                     ; preds = %31
  br i1 %44, label %60, label %233

; <label>:46:                                     ; preds = %31
  br i1 %44, label %60, label %47

; <label>:47:                                     ; preds = %46
  %48 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %49 = load %union.Node*, %union.Node** %48, align 8, !tbaa !156
  %50 = icmp ugt %union.Node* %43, %49
  br i1 %50, label %51, label %60

; <label>:51:                                     ; preds = %47
  br label %54

; <label>:52:                                     ; preds = %54
  %53 = icmp ugt %union.Node* %56, %49
  br i1 %53, label %54, label %60

; <label>:54:                                     ; preds = %51, %52
  %55 = phi %union.Node* [ %56, %52 ], [ %43, %51 ]
  %56 = getelementptr inbounds %union.Node, %union.Node* %55, i64 -1
  store %union.Node* %56, %union.Node** %42, align 8, !tbaa !147
  %57 = getelementptr inbounds %union.Node, %union.Node* %55, i64 -1, i32 0, i32 2
  %58 = load i8, i8* %57, align 1, !tbaa !21
  %59 = icmp eq i8 %58, 0
  br i1 %59, label %169, label %52

; <label>:60:                                     ; preds = %52, %45, %46, %47
  call void @llvm.lifetime.start.p0i8(i64 128, i8* nonnull %5) #7
  call void @llvm.memset.p0i8.i64(i8* nonnull %5, i8 0, i64 128, i32 16, i1 false)
  %61 = tail call fastcc i32 @luaH_realasize(%struct.Table* nonnull %1) #17
  %62 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 5
  store i32 %61, i32* %62, align 4, !tbaa !92
  %63 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %64 = load i8, i8* %63, align 1, !tbaa !146
  %65 = and i8 %64, 127
  store i8 %65, i8* %63, align 1, !tbaa !146
  %66 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 0
  %67 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 6
  br label %68

; <label>:68:                                     ; preds = %94, %60
  %69 = phi i64 [ 0, %60 ], [ %101, %94 ]
  %70 = phi i32 [ 1, %60 ], [ %95, %94 ]
  %71 = phi i32 [ 0, %60 ], [ %100, %94 ]
  %72 = phi i32 [ 1, %60 ], [ %102, %94 ]
  %73 = icmp ugt i32 %72, %61
  br i1 %73, label %74, label %76

; <label>:74:                                     ; preds = %68
  %75 = icmp ugt i32 %70, %61
  br i1 %75, label %104, label %76

; <label>:76:                                     ; preds = %74, %68
  %77 = phi i32 [ %61, %74 ], [ %72, %68 ]
  %78 = icmp ugt i32 %70, %77
  br i1 %78, label %94, label %79

; <label>:79:                                     ; preds = %76
  %80 = load %struct.TValue*, %struct.TValue** %67, align 8, !tbaa !91
  br label %81

; <label>:81:                                     ; preds = %81, %79
  %82 = phi i32 [ 0, %79 ], [ %91, %81 ]
  %83 = phi i32 [ %70, %79 ], [ %92, %81 ]
  %84 = add i32 %83, -1
  %85 = zext i32 %84 to i64
  %86 = getelementptr inbounds %struct.TValue, %struct.TValue* %80, i64 %85, i32 1
  %87 = load i8, i8* %86, align 8, !tbaa !22
  %88 = and i8 %87, 15
  %89 = icmp ne i8 %88, 0
  %90 = zext i1 %89 to i32
  %91 = add i32 %82, %90
  %92 = add i32 %83, 1
  %93 = icmp ugt i32 %92, %77
  br i1 %93, label %94, label %81

; <label>:94:                                     ; preds = %81, %76
  %95 = phi i32 [ %70, %76 ], [ %92, %81 ]
  %96 = phi i32 [ 0, %76 ], [ %91, %81 ]
  %97 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 %69
  %98 = load i32, i32* %97, align 4, !tbaa !77
  %99 = add i32 %98, %96
  store i32 %99, i32* %97, align 4, !tbaa !77
  %100 = add i32 %96, %71
  %101 = add nuw nsw i64 %69, 1
  %102 = shl i32 %72, 1
  %103 = icmp ult i64 %101, 32
  br i1 %103, label %68, label %104

; <label>:104:                                    ; preds = %94, %74
  %105 = phi i32 [ %71, %74 ], [ %100, %94 ]
  %106 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 4
  %107 = load i8, i8* %106, align 1, !tbaa !93
  %108 = zext i8 %107 to i32
  %109 = shl i32 1, %108
  %110 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 7
  %111 = sext i32 %109 to i64
  br label %112

; <label>:112:                                    ; preds = %135, %104
  %113 = phi i64 [ %111, %104 ], [ %116, %135 ]
  %114 = phi i32 [ 0, %104 ], [ %137, %135 ]
  %115 = phi i32 [ 0, %104 ], [ %136, %135 ]
  %116 = add nsw i64 %113, -1
  %117 = load %union.Node*, %union.Node** %110, align 8, !tbaa !156
  %118 = getelementptr inbounds %union.Node, %union.Node* %117, i64 %116, i32 0, i32 1
  %119 = load i8, i8* %118, align 8, !tbaa !21
  %120 = and i8 %119, 15
  %121 = icmp eq i8 %120, 0
  br i1 %121, label %135, label %122

; <label>:122:                                    ; preds = %112
  %123 = getelementptr inbounds %union.Node, %union.Node* %117, i64 %116, i32 0, i32 2
  %124 = load i8, i8* %123, align 1, !tbaa !21
  %125 = icmp eq i8 %124, 35
  br i1 %125, label %126, label %132

; <label>:126:                                    ; preds = %122
  %127 = getelementptr inbounds %union.Node, %union.Node* %117, i64 %116, i32 0, i32 4
  %128 = bitcast %union.Value* %127 to i64*
  %129 = load i64, i64* %128, align 8, !tbaa !21
  %130 = call fastcc i32 @countint(i64 %129, i32* nonnull %66) #17
  %131 = add nsw i32 %130, %115
  br label %132

; <label>:132:                                    ; preds = %126, %122
  %133 = phi i32 [ %131, %126 ], [ %115, %122 ]
  %134 = add nsw i32 %114, 1
  br label %135

; <label>:135:                                    ; preds = %132, %112
  %136 = phi i32 [ %115, %112 ], [ %133, %132 ]
  %137 = phi i32 [ %114, %112 ], [ %134, %132 ]
  %138 = trunc i64 %116 to i32
  %139 = icmp eq i32 %138, 0
  br i1 %139, label %140, label %112

; <label>:140:                                    ; preds = %135
  %141 = add i32 %136, %105
  %142 = load i8, i8* %32, align 8, !tbaa !22
  %143 = icmp eq i8 %142, 35
  br i1 %143, label %144, label %149

; <label>:144:                                    ; preds = %140
  %145 = bitcast %struct.TValue* %34 to i64*
  %146 = load i64, i64* %145, align 8, !tbaa !21
  %147 = call fastcc i32 @countint(i64 %146, i32* nonnull %66) #17
  %148 = add i32 %147, %141
  br label %149

; <label>:149:                                    ; preds = %144, %140
  %150 = phi i32 [ %148, %144 ], [ %141, %140 ]
  br label %151

; <label>:151:                                    ; preds = %159, %149
  %152 = phi i64 [ 0, %149 ], [ %166, %159 ]
  %153 = phi i32 [ 0, %149 ], [ %165, %159 ]
  %154 = phi i32 [ 0, %149 ], [ %164, %159 ]
  %155 = phi i32 [ 0, %149 ], [ %162, %159 ]
  %156 = phi i32 [ 1, %149 ], [ %167, %159 ]
  %157 = lshr i32 %156, 1
  %158 = icmp ugt i32 %150, %157
  br i1 %158, label %159, label %226

; <label>:159:                                    ; preds = %151
  %160 = getelementptr inbounds [32 x i32], [32 x i32]* %4, i64 0, i64 %152
  %161 = load i32, i32* %160, align 4, !tbaa !77
  %162 = add i32 %161, %155
  %163 = icmp ugt i32 %162, %157
  %164 = select i1 %163, i32 %162, i32 %154
  %165 = select i1 %163, i32 %156, i32 %153
  %166 = add nuw nsw i64 %152, 1
  %167 = shl i32 %156, 1
  %168 = icmp eq i32 %167, 0
  br i1 %168, label %226, label %151

; <label>:169:                                    ; preds = %54
  %170 = getelementptr inbounds %union.Node, %union.Node* %37, i64 0, i32 0, i32 2
  %171 = load i8, i8* %170, align 1, !tbaa !21
  %172 = zext i8 %171 to i32
  %173 = getelementptr inbounds %union.Node, %union.Node* %37, i64 0, i32 0, i32 4
  %174 = tail call fastcc %union.Node* @mainposition(%struct.Table* nonnull %1, i32 %172, %union.Value* nonnull %173) #16
  %175 = icmp eq %union.Node* %174, %37
  br i1 %175, label %205, label %176

; <label>:176:                                    ; preds = %169
  br label %177

; <label>:177:                                    ; preds = %176, %177
  %178 = phi %union.Node* [ %182, %177 ], [ %174, %176 ]
  %179 = getelementptr inbounds %union.Node, %union.Node* %178, i64 0, i32 0, i32 3
  %180 = load i32, i32* %179, align 4, !tbaa !21
  %181 = sext i32 %180 to i64
  %182 = getelementptr inbounds %union.Node, %union.Node* %178, i64 %181
  %183 = icmp eq %union.Node* %182, %37
  br i1 %183, label %184, label %177

; <label>:184:                                    ; preds = %177
  %185 = getelementptr inbounds %union.Node, %union.Node* %178, i64 0, i32 0, i32 3
  %186 = ptrtoint %union.Node* %56 to i64
  %187 = ptrtoint %union.Node* %178 to i64
  %188 = sub i64 %186, %187
  %189 = sdiv exact i64 %188, 24
  %190 = trunc i64 %189 to i32
  store i32 %190, i32* %185, align 4, !tbaa !21
  %191 = bitcast %union.Node* %56 to i8*
  %192 = bitcast %union.Node* %37 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %191, i8* %192, i64 24, i32 8, i1 false), !tbaa.struct !243
  %193 = getelementptr inbounds %union.Node, %union.Node* %37, i64 0, i32 0, i32 3
  %194 = load i32, i32* %193, align 4, !tbaa !21
  %195 = icmp eq i32 %194, 0
  br i1 %195, label %204, label %196

; <label>:196:                                    ; preds = %184
  %197 = ptrtoint %union.Node* %37 to i64
  %198 = sub i64 %197, %186
  %199 = sdiv exact i64 %198, 24
  %200 = trunc i64 %199 to i32
  %201 = getelementptr inbounds %union.Node, %union.Node* %55, i64 -1, i32 0, i32 3
  %202 = load i32, i32* %201, align 4, !tbaa !21
  %203 = add nsw i32 %202, %200
  store i32 %203, i32* %201, align 4, !tbaa !21
  store i32 0, i32* %193, align 4, !tbaa !21
  br label %204

; <label>:204:                                    ; preds = %184, %196
  store i8 16, i8* %38, align 8, !tbaa !21
  br label %233

; <label>:205:                                    ; preds = %169
  %206 = getelementptr inbounds %union.Node, %union.Node* %37, i64 0, i32 0, i32 3
  %207 = load i32, i32* %206, align 4, !tbaa !21
  %208 = icmp eq i32 %207, 0
  br i1 %208, label %209, label %211

; <label>:209:                                    ; preds = %205
  %210 = ptrtoint %union.Node* %56 to i64
  br label %220

; <label>:211:                                    ; preds = %205
  %212 = sext i32 %207 to i64
  %213 = getelementptr inbounds %union.Node, %union.Node* %37, i64 %212
  %214 = ptrtoint %union.Node* %213 to i64
  %215 = ptrtoint %union.Node* %56 to i64
  %216 = sub i64 %214, %215
  %217 = sdiv exact i64 %216, 24
  %218 = trunc i64 %217 to i32
  %219 = getelementptr inbounds %union.Node, %union.Node* %55, i64 -1, i32 0, i32 3
  store i32 %218, i32* %219, align 4, !tbaa !21
  br label %220

; <label>:220:                                    ; preds = %209, %211
  %221 = phi i64 [ %210, %209 ], [ %215, %211 ]
  %222 = ptrtoint %union.Node* %37 to i64
  %223 = sub i64 %221, %222
  %224 = sdiv exact i64 %223, 24
  %225 = trunc i64 %224 to i32
  store i32 %225, i32* %206, align 4, !tbaa !21
  br label %233

; <label>:226:                                    ; preds = %159, %151
  %227 = phi i32 [ %164, %159 ], [ %154, %151 ]
  %228 = phi i32 [ %165, %159 ], [ %153, %151 ]
  %229 = add i32 %105, 1
  %230 = add i32 %229, %137
  %231 = sub i32 %230, %227
  tail call fastcc void @luaH_resize(%struct.lua_State* %0, %struct.Table* %1, i32 %228, i32 %231) #17
  call void @llvm.lifetime.end.p0i8(i64 128, i8* nonnull %5) #7
  %232 = call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %0, %struct.Table* %1, %struct.TValue* %34) #16
  br label %260

; <label>:233:                                    ; preds = %204, %220, %45
  %234 = phi %union.Node* [ %37, %45 ], [ %56, %220 ], [ %37, %204 ]
  %235 = getelementptr inbounds %union.Node, %union.Node* %234, i64 0, i32 0, i32 4
  %236 = bitcast %struct.TValue* %34 to i64*
  %237 = bitcast %union.Value* %235 to i64*
  %238 = load i64, i64* %236, align 8
  store i64 %238, i64* %237, align 8
  %239 = load i8, i8* %32, align 8, !tbaa !22
  %240 = getelementptr inbounds %union.Node, %union.Node* %234, i64 0, i32 0, i32 2
  store i8 %239, i8* %240, align 1, !tbaa !21
  %241 = load i8, i8* %32, align 8, !tbaa !22
  %242 = and i8 %241, 64
  %243 = icmp eq i8 %242, 0
  br i1 %243, label %258, label %244

; <label>:244:                                    ; preds = %233
  %245 = bitcast %struct.Table* %1 to %struct.GCObject*
  %246 = getelementptr inbounds %struct.Table, %struct.Table* %1, i64 0, i32 2
  %247 = load i8, i8* %246, align 1, !tbaa !21
  %248 = and i8 %247, 32
  %249 = icmp eq i8 %248, 0
  br i1 %249, label %258, label %250

; <label>:250:                                    ; preds = %244
  %251 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 0, i32 0, i32 0
  %252 = load %struct.GCObject*, %struct.GCObject** %251, align 8, !tbaa !21
  %253 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %252, i64 0, i32 2
  %254 = load i8, i8* %253, align 1, !tbaa !70
  %255 = and i8 %254, 24
  %256 = icmp eq i8 %255, 0
  br i1 %256, label %258, label %257

; <label>:257:                                    ; preds = %250
  tail call fastcc void @luaC_barrierback_(%struct.lua_State* %0, %struct.GCObject* %245) #16
  br label %258

; <label>:258:                                    ; preds = %250, %244, %233, %257
  %259 = bitcast %union.Node* %234 to %struct.TValue*
  br label %260

; <label>:260:                                    ; preds = %226, %258
  %261 = phi %struct.TValue* [ %259, %258 ], [ %232, %226 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %7) #7
  ret %struct.TValue* %261
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i32 @countint(i64, i32* nocapture) unnamed_addr #2 {
  %3 = add i64 %0, -1
  %4 = icmp ugt i64 %3, 2147483647
  %5 = trunc i64 %0 to i32
  %6 = icmp eq i32 %5, 0
  %7 = or i1 %6, %4
  br i1 %7, label %30, label %8

; <label>:8:                                      ; preds = %2
  %9 = add i32 %5, -1
  %10 = icmp ugt i32 %9, 255
  br i1 %10, label %11, label %18

; <label>:11:                                     ; preds = %8
  br label %12

; <label>:12:                                     ; preds = %11, %12
  %13 = phi i32 [ %15, %12 ], [ 0, %11 ]
  %14 = phi i32 [ %16, %12 ], [ %9, %11 ]
  %15 = add nuw nsw i32 %13, 8
  %16 = lshr i32 %14, 8
  %17 = icmp ugt i32 %14, 65535
  br i1 %17, label %12, label %18

; <label>:18:                                     ; preds = %12, %8
  %19 = phi i32 [ %9, %8 ], [ %16, %12 ]
  %20 = phi i32 [ 0, %8 ], [ %15, %12 ]
  %21 = zext i32 %19 to i64
  %22 = getelementptr inbounds [256 x i8], [256 x i8]* @luaO_ceillog2.log_2, i64 0, i64 %21
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = zext i8 %23 to i32
  %25 = add nuw nsw i32 %20, %24
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds i32, i32* %1, i64 %26
  %28 = load i32, i32* %27, align 4, !tbaa !77
  %29 = add i32 %28, 1
  store i32 %29, i32* %27, align 4, !tbaa !77
  br label %30

; <label>:30:                                     ; preds = %2, %18
  %31 = phi i32 [ 1, %18 ], [ 0, %2 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.CallInfo* @luaE_extendCI(%struct.lua_State*) unnamed_addr #0 {
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %0) #16
  %2 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 64, i32 0) #16
  %3 = bitcast i8* %2 to %struct.CallInfo*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 3
  %7 = bitcast %struct.CallInfo** %6 to i8**
  store i8* %2, i8** %7, align 8, !tbaa !117
  %8 = ptrtoint %struct.CallInfo* %5 to i64
  %9 = getelementptr inbounds i8, i8* %2, i64 16
  %10 = bitcast i8* %9 to i64*
  store i64 %8, i64* %10, align 8, !tbaa !105
  %11 = getelementptr inbounds i8, i8* %2, i64 24
  %12 = bitcast i8* %11 to %struct.CallInfo**
  store %struct.CallInfo* null, %struct.CallInfo** %12, align 8, !tbaa !117
  %13 = getelementptr inbounds i8, i8* %2, i64 40
  %14 = bitcast i8* %13 to i32*
  store i32 0, i32* %14, align 8, !tbaa !21
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 5
  %16 = load i16, i16* %15, align 4, !tbaa !25
  %17 = add i16 %16, 1
  store i16 %17, i16* %15, align 4, !tbaa !25
  ret %struct.CallInfo* %3
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaE_enterCcall(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 19
  %3 = load i32, i32* %2, align 8, !tbaa !29
  %4 = and i32 %3, 65528
  %5 = add i32 %3, 1
  store i32 %5, i32* %2, align 8, !tbaa !29
  %6 = icmp ugt i32 %4, 2199
  br i1 %6, label %7, label %18

; <label>:7:                                      ; preds = %1
  tail call fastcc void @luaE_freeCI(%struct.lua_State* nonnull %0) #16
  %8 = load i32, i32* %2, align 8, !tbaa !29
  %9 = and i32 %8, 65535
  %10 = icmp ugt i32 %9, 2199
  br i1 %10, label %11, label %18

; <label>:11:                                     ; preds = %7
  %12 = icmp ult i32 %9, 2213
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %11
  %14 = add i32 %8, 14
  store i32 %14, i32* %2, align 8, !tbaa !29
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i64 0, i64 0)) #18
  unreachable

; <label>:15:                                     ; preds = %11
  %16 = icmp ugt i32 %9, 2474
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %15
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 5) #18
  unreachable

; <label>:18:                                     ; preds = %7, %15, %1
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @f_parser(%struct.lua_State*, i8*) #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LexState, align 8
  %6 = alloca %struct.FuncState, align 8
  %7 = alloca double, align 8
  %8 = alloca i64, align 8
  %9 = alloca %struct.LoadState, align 8
  %10 = bitcast i8* %1 to %struct.Zio**
  %11 = load %struct.Zio*, %struct.Zio** %10, align 8, !tbaa !166
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !244
  %14 = add i64 %13, -1
  store i64 %14, i64* %12, align 8, !tbaa !244
  %15 = icmp eq i64 %13, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 1
  %18 = load i8*, i8** %17, align 8, !tbaa !245
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  store i8* %19, i8** %17, align 8, !tbaa !245
  %20 = load i8, i8* %18, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %24

; <label>:22:                                     ; preds = %2
  %23 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %11) #16
  br label %24

; <label>:24:                                     ; preds = %22, %16
  %25 = phi i32 [ %21, %16 ], [ %23, %22 ]
  %26 = icmp eq i32 %25, 27
  %27 = getelementptr inbounds i8, i8* %1, i64 80
  %28 = bitcast i8* %27 to i8**
  %29 = load i8*, i8** %28, align 8, !tbaa !173
  br i1 %26, label %30, label %90

; <label>:30:                                     ; preds = %24
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %29, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.203, i64 0, i64 0)) #16
  %31 = bitcast i8* %1 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !166
  %33 = getelementptr inbounds i8, i8* %1, i64 88
  %34 = bitcast i8* %33 to i8**
  %35 = load i8*, i8** %34, align 8, !tbaa !172
  %36 = bitcast %struct.LoadState* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %36) #7
  %37 = load i8, i8* %35, align 1, !tbaa !21
  switch i8 %37, label %40 [
    i8 64, label %38
    i8 61, label %38
    i8 27, label %41
  ]

; <label>:38:                                     ; preds = %30, %30
  %39 = getelementptr inbounds i8, i8* %35, i64 1
  br label %41

; <label>:40:                                     ; preds = %30
  br label %41

; <label>:41:                                     ; preds = %30, %40, %38
  %42 = phi i8* [ %35, %40 ], [ %39, %38 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.206, i64 0, i64 0), %30 ]
  %43 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %9, i64 0, i32 2
  store i8* %42, i8** %43, align 8, !tbaa !246
  %44 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %9, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %44, align 8, !tbaa !248
  %45 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %9, i64 0, i32 1
  %46 = bitcast %struct.Zio** %45 to i64*
  store i64 %32, i64* %46, align 8, !tbaa !249
  call fastcc void @checkliteral(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i64 0, i64 1), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.207, i64 0, i64 0)) #17
  %47 = call fastcc i64 @LoadUnsigned(%struct.LoadState* nonnull %9, i64 2147483647) #17
  %48 = trunc i64 %47 to i32
  %49 = icmp eq i32 %48, 504
  br i1 %49, label %51, label %50

; <label>:50:                                     ; preds = %41
  call fastcc void @error(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.208, i64 0, i64 0)) #19
  unreachable

; <label>:51:                                     ; preds = %41
  %52 = call fastcc zeroext i8 @LoadByte(%struct.LoadState* nonnull %9) #17
  %53 = icmp eq i8 %52, 0
  br i1 %53, label %55, label %54

; <label>:54:                                     ; preds = %51
  call fastcc void @error(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.209, i64 0, i64 0)) #19
  unreachable

; <label>:55:                                     ; preds = %51
  call fastcc void @checkliteral(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.210, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.211, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %9, i64 4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.212, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %9, i64 8, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.213, i64 0, i64 0)) #17
  call fastcc void @fchecksize(%struct.LoadState* nonnull %9, i64 8, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.214, i64 0, i64 0)) #17
  %56 = bitcast i64* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %56) #7
  call fastcc void @LoadBlock(%struct.LoadState* nonnull %9, i8* nonnull %56, i64 8) #17
  %57 = load i64, i64* %8, align 8, !tbaa !144
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %56) #7
  %58 = icmp eq i64 %57, 22136
  br i1 %58, label %60, label %59

; <label>:59:                                     ; preds = %55
  call fastcc void @error(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.215, i64 0, i64 0)) #19
  unreachable

; <label>:60:                                     ; preds = %55
  %61 = bitcast double* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %61) #7
  call fastcc void @LoadBlock(%struct.LoadState* nonnull %9, i8* nonnull %61, i64 8) #17
  %62 = load double, double* %7, align 8, !tbaa !140
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %61) #7
  %63 = fcmp une double %62, 3.705000e+02
  br i1 %63, label %64, label %65

; <label>:64:                                     ; preds = %60
  call fastcc void @error(%struct.LoadState* nonnull %9, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.216, i64 0, i64 0)) #19
  unreachable

; <label>:65:                                     ; preds = %60
  %66 = call fastcc zeroext i8 @LoadByte(%struct.LoadState* nonnull %9) #17
  %67 = zext i8 %66 to i32
  %68 = tail call fastcc %struct.LClosure* @luaF_newLclosure(%struct.lua_State* %0, i32 %67) #17
  %69 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %70 = bitcast %union.StackValue** %69 to %struct.TValue**
  %71 = load %struct.TValue*, %struct.TValue** %70, align 8, !tbaa !20
  %72 = bitcast %struct.TValue* %71 to %struct.LClosure**
  store %struct.LClosure* %68, %struct.LClosure** %72, align 8, !tbaa !21
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %71, i64 0, i32 1
  store i8 86, i8* %73, align 8, !tbaa !22
  %74 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %75 = bitcast %union.StackValue** %74 to i64*
  %76 = load i64, i64* %75, align 8, !tbaa !62
  %77 = bitcast %union.StackValue** %69 to i64*
  %78 = load i64, i64* %77, align 8, !tbaa !20
  %79 = sub i64 %76, %78
  %80 = icmp slt i64 %79, 32
  %81 = inttoptr i64 %78 to %union.StackValue*
  br i1 %80, label %82, label %85

; <label>:82:                                     ; preds = %65
  %83 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 1, i32 1) #17
  %84 = load %union.StackValue*, %union.StackValue** %69, align 8, !tbaa !20
  br label %85

; <label>:85:                                     ; preds = %65, %82
  %86 = phi %union.StackValue* [ %81, %65 ], [ %84, %82 ]
  %87 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 1
  store %union.StackValue* %87, %union.StackValue** %69, align 8, !tbaa !20
  %88 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* nonnull %0) #17
  %89 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %68, i64 0, i32 5
  store %struct.Proto* %88, %struct.Proto** %89, align 8, !tbaa !197
  call fastcc void @LoadFunction(%struct.LoadState* nonnull %9, %struct.Proto* %88, %struct.TString* null) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %36) #7
  br label %291

; <label>:90:                                     ; preds = %24
  tail call fastcc void @checkmode(%struct.lua_State* %0, i8* %29, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.204, i64 0, i64 0)) #16
  %91 = bitcast i8* %1 to i64*
  %92 = load i64, i64* %91, align 8, !tbaa !166
  %93 = getelementptr inbounds i8, i8* %1, i64 8
  %94 = getelementptr inbounds i8, i8* %1, i64 32
  %95 = getelementptr inbounds i8, i8* %1, i64 88
  %96 = bitcast i8* %95 to i8**
  %97 = load i8*, i8** %96, align 8, !tbaa !172
  %98 = bitcast %struct.LexState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %98) #7
  %99 = bitcast %struct.FuncState* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %99) #7
  %100 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %101 = load %struct.global_State*, %struct.global_State** %100, align 8, !tbaa !2
  %102 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 40, i32 6) #17
  %103 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 10
  %104 = load i8, i8* %103, align 4, !tbaa !15
  %105 = and i8 %104, 24
  %106 = getelementptr inbounds i8, i8* %102, i64 9
  store i8 %105, i8* %106, align 1, !tbaa !70
  %107 = getelementptr inbounds i8, i8* %102, i64 8
  store i8 22, i8* %107, align 8, !tbaa !86
  %108 = getelementptr inbounds %struct.global_State, %struct.global_State* %101, i64 0, i32 20
  %109 = bitcast %struct.GCObject** %108 to i64*
  %110 = load i64, i64* %109, align 8, !tbaa !18
  %111 = bitcast i8* %102 to i64*
  store i64 %110, i64* %111, align 8, !tbaa !87
  %112 = bitcast %struct.GCObject** %108 to i8**
  store i8* %102, i8** %112, align 8, !tbaa !18
  %113 = bitcast i8* %102 to %struct.LClosure*
  %114 = getelementptr inbounds i8, i8* %102, i64 24
  %115 = bitcast i8* %114 to %struct.Proto**
  store %struct.Proto* null, %struct.Proto** %115, align 8, !tbaa !197
  %116 = getelementptr inbounds i8, i8* %102, i64 10
  store i8 1, i8* %116, align 2, !tbaa !182
  %117 = getelementptr i8, i8* %102, i64 32
  %118 = bitcast i8* %117 to i64*
  store i64 0, i64* %118, align 8
  %119 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %120 = bitcast %union.StackValue** %119 to %struct.TValue**
  %121 = load %struct.TValue*, %struct.TValue** %120, align 8, !tbaa !20
  %122 = bitcast %struct.TValue* %121 to i8**
  store i8* %102, i8** %122, align 8, !tbaa !21
  %123 = getelementptr inbounds %struct.TValue, %struct.TValue* %121, i64 0, i32 1
  store i8 86, i8* %123, align 8, !tbaa !22
  %124 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 10
  %125 = bitcast %union.StackValue** %124 to i64*
  %126 = load i64, i64* %125, align 8, !tbaa !62
  %127 = bitcast %union.StackValue** %119 to i64*
  %128 = load i64, i64* %127, align 8, !tbaa !20
  %129 = sub i64 %126, %128
  %130 = icmp slt i64 %129, 32
  %131 = inttoptr i64 %128 to %union.StackValue*
  br i1 %130, label %132, label %135

; <label>:132:                                    ; preds = %90
  %133 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 1, i32 1) #17
  %134 = load %union.StackValue*, %union.StackValue** %119, align 8, !tbaa !20
  br label %135

; <label>:135:                                    ; preds = %132, %90
  %136 = phi %union.StackValue* [ %131, %90 ], [ %134, %132 ]
  %137 = getelementptr inbounds %union.StackValue, %union.StackValue* %136, i64 1
  store %union.StackValue* %137, %union.StackValue** %119, align 8, !tbaa !20
  %138 = load %struct.global_State*, %struct.global_State** %100, align 8, !tbaa !2
  %139 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* nonnull %0, i64 56, i32 5) #17
  %140 = getelementptr inbounds %struct.global_State, %struct.global_State* %138, i64 0, i32 10
  %141 = load i8, i8* %140, align 4, !tbaa !15
  %142 = and i8 %141, 24
  %143 = getelementptr inbounds i8, i8* %139, i64 9
  store i8 %142, i8* %143, align 1, !tbaa !70
  %144 = getelementptr inbounds i8, i8* %139, i64 8
  store i8 5, i8* %144, align 8, !tbaa !86
  %145 = getelementptr inbounds %struct.global_State, %struct.global_State* %138, i64 0, i32 20
  %146 = bitcast %struct.GCObject** %145 to i64*
  %147 = load i64, i64* %146, align 8, !tbaa !18
  %148 = bitcast i8* %139 to i64*
  store i64 %147, i64* %148, align 8, !tbaa !87
  %149 = bitcast %struct.GCObject** %145 to i8**
  store i8* %139, i8** %149, align 8, !tbaa !18
  %150 = getelementptr inbounds i8, i8* %139, i64 40
  %151 = bitcast i8* %150 to %struct.Table**
  store %struct.Table* null, %struct.Table** %151, align 8, !tbaa !88
  %152 = getelementptr inbounds i8, i8* %139, i64 10
  store i8 -1, i8* %152, align 2, !tbaa !90
  %153 = getelementptr inbounds i8, i8* %139, i64 16
  %154 = bitcast i8* %153 to %struct.TValue**
  store %struct.TValue* null, %struct.TValue** %154, align 8, !tbaa !91
  %155 = getelementptr inbounds i8, i8* %139, i64 12
  %156 = bitcast i8* %155 to i32*
  store i32 0, i32* %156, align 4, !tbaa !92
  %157 = getelementptr inbounds i8, i8* %139, i64 24
  %158 = getelementptr inbounds i8, i8* %139, i64 11
  store i8 0, i8* %158, align 1, !tbaa !93
  %159 = bitcast i8* %157 to <2 x %union.Node*>*
  store <2 x %union.Node*> <%union.Node* @dummynode_, %union.Node* null>, <2 x %union.Node*>* %159, align 8, !tbaa !54
  %160 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 9
  %161 = bitcast %struct.Table** %160 to i8**
  store i8* %139, i8** %161, align 8, !tbaa !250
  %162 = load %struct.TValue*, %struct.TValue** %120, align 8, !tbaa !20
  %163 = bitcast %struct.TValue* %162 to i8**
  store i8* %139, i8** %163, align 8, !tbaa !21
  %164 = getelementptr inbounds %struct.TValue, %struct.TValue* %162, i64 0, i32 1
  store i8 69, i8* %164, align 8, !tbaa !22
  %165 = load i64, i64* %125, align 8, !tbaa !62
  %166 = load i64, i64* %127, align 8, !tbaa !20
  %167 = sub i64 %165, %166
  %168 = icmp slt i64 %167, 32
  %169 = inttoptr i64 %166 to %union.StackValue*
  br i1 %168, label %170, label %173

; <label>:170:                                    ; preds = %135
  %171 = tail call fastcc i32 @luaD_growstack(%struct.lua_State* nonnull %0, i32 1, i32 1) #17
  %172 = load %union.StackValue*, %union.StackValue** %119, align 8, !tbaa !20
  br label %173

; <label>:173:                                    ; preds = %170, %135
  %174 = phi %union.StackValue* [ %169, %135 ], [ %172, %170 ]
  %175 = getelementptr inbounds %union.StackValue, %union.StackValue* %174, i64 1
  store %union.StackValue* %175, %union.StackValue** %119, align 8, !tbaa !20
  %176 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* nonnull %0) #17
  store %struct.Proto* %176, %struct.Proto** %115, align 8, !tbaa !197
  %177 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 0
  store %struct.Proto* %176, %struct.Proto** %177, align 8, !tbaa !253
  %178 = tail call fastcc %struct.TString* @luaS_new(%struct.lua_State* nonnull %0, i8* %97) #17
  %179 = getelementptr inbounds %struct.Proto, %struct.Proto* %176, i64 0, i32 22
  store %struct.TString* %178, %struct.TString** %179, align 8, !tbaa !122
  %180 = getelementptr inbounds %struct.Proto, %struct.Proto* %176, i64 0, i32 2
  %181 = load i8, i8* %180, align 1, !tbaa !234
  %182 = and i8 %181, 32
  %183 = icmp eq i8 %182, 0
  %184 = ptrtoint %struct.TString* %178 to i64
  br i1 %183, label %195, label %185

; <label>:185:                                    ; preds = %173
  %186 = getelementptr inbounds %struct.TString, %struct.TString* %178, i64 0, i32 2
  %187 = load i8, i8* %186, align 1, !tbaa !148
  %188 = and i8 %187, 24
  %189 = icmp eq i8 %188, 0
  br i1 %189, label %195, label %190

; <label>:190:                                    ; preds = %185
  %191 = bitcast %struct.Proto* %176 to %struct.GCObject*
  %192 = bitcast %struct.TString* %178 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* %191, %struct.GCObject* %192) #17
  %193 = bitcast %struct.TString** %179 to i64*
  %194 = load i64, i64* %193, align 8, !tbaa !122
  br label %195

; <label>:195:                                    ; preds = %190, %185, %173
  %196 = phi i64 [ %184, %185 ], [ %184, %173 ], [ %194, %190 ]
  %197 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 8
  %198 = bitcast %struct.Mbuffer** %197 to i8**
  store i8* %93, i8** %198, align 8, !tbaa !255
  %199 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 10
  %200 = bitcast %struct.Dyndata** %199 to i8**
  store i8* %94, i8** %200, align 8, !tbaa !256
  %201 = getelementptr inbounds i8, i8* %1, i64 72
  %202 = bitcast i8* %201 to i32*
  store i32 0, i32* %202, align 8, !tbaa !257
  %203 = getelementptr inbounds i8, i8* %1, i64 56
  %204 = bitcast i8* %203 to i32*
  store i32 0, i32* %204, align 8, !tbaa !258
  %205 = getelementptr inbounds i8, i8* %1, i64 40
  %206 = bitcast i8* %205 to i32*
  store i32 0, i32* %206, align 8, !tbaa !259
  %207 = bitcast %struct.TString** %179 to i64*
  %208 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 3, i32 0
  store i32 0, i32* %208, align 8, !tbaa !260
  %209 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  store %struct.lua_State* %0, %struct.lua_State** %209, align 8, !tbaa !261
  %210 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 0
  store i32 %25, i32* %210, align 8, !tbaa !262
  %211 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 4, i32 0
  store i32 289, i32* %211, align 8, !tbaa !263
  %212 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 7
  %213 = bitcast %struct.Zio** %212 to i64*
  store i64 %92, i64* %213, align 8, !tbaa !264
  %214 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 5
  %215 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 1
  store i32 1, i32* %215, align 4, !tbaa !265
  %216 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 2
  store i32 1, i32* %216, align 8, !tbaa !266
  %217 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 11
  %218 = bitcast %struct.TString** %217 to i64*
  store i64 %196, i64* %218, align 8, !tbaa !267
  %219 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.104, i64 0, i64 0), i64 4) #17
  %220 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 12
  store %struct.TString* %219, %struct.TString** %220, align 8, !tbaa !268
  %221 = bitcast i8* %93 to i8**
  %222 = load i8*, i8** %221, align 8, !tbaa !269
  %223 = getelementptr inbounds i8, i8* %1, i64 24
  %224 = bitcast i8* %223 to i64*
  %225 = load i64, i64* %224, align 8, !tbaa !270
  %226 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* nonnull %0, i8* %222, i64 %225, i64 32) #17
  store i8* %226, i8** %221, align 8, !tbaa !269
  store i64 32, i64* %224, align 8, !tbaa !270
  %227 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %227) #7
  %228 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %228) #7
  %229 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 1
  %230 = bitcast %struct.FuncState** %229 to i64*
  store i64 0, i64* %230, align 8, !tbaa !271
  %231 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 2
  store %struct.LexState* %5, %struct.LexState** %231, align 8, !tbaa !272
  store %struct.FuncState* %6, %struct.FuncState** %214, align 8, !tbaa !273
  %232 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 4
  store i32 0, i32* %232, align 8, !tbaa !274
  %233 = getelementptr inbounds %struct.Proto, %struct.Proto* %176, i64 0, i32 13
  %234 = load i32, i32* %233, align 4, !tbaa !124
  %235 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 6
  store i32 %234, i32* %235, align 8, !tbaa !275
  %236 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 5
  store i32 0, i32* %236, align 4, !tbaa !276
  %237 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 7
  store i32 0, i32* %237, align 4, !tbaa !277
  %238 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 9
  store i32 0, i32* %238, align 4, !tbaa !278
  %239 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 8
  store i32 0, i32* %239, align 8, !tbaa !279
  %240 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 12
  %241 = bitcast i16* %240 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %241, i8 0, i64 7, i32 8, i1 false) #7
  %242 = load i32, i32* %206, align 8, !tbaa !259
  %243 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 10
  store i32 %242, i32* %243, align 8, !tbaa !280
  %244 = load i32, i32* %202, align 8, !tbaa !257
  %245 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 11
  store i32 %244, i32* %245, align 4, !tbaa !281
  %246 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 3
  store i64 %196, i64* %207, align 8, !tbaa !122
  %247 = getelementptr inbounds %struct.Proto, %struct.Proto* %176, i64 0, i32 5
  store i8 2, i8* %247, align 4, !tbaa !158
  %248 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  store i8 0, i8* %248, align 2, !tbaa !282
  %249 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  store i8 0, i8* %249, align 8, !tbaa !284
  %250 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  store i32 %244, i32* %250, align 8, !tbaa !285
  %251 = load i32, i32* %204, align 8, !tbaa !258
  %252 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  store i32 %251, i32* %252, align 4, !tbaa !286
  %253 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  store i8 0, i8* %253, align 1, !tbaa !287
  %254 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 6
  store i8 0, i8* %254, align 1, !tbaa !288
  %255 = bitcast %struct.BlockCnt* %3 to i64*
  store i64 0, i64* %255, align 8, !tbaa !289
  store %struct.BlockCnt* %3, %struct.BlockCnt** %246, align 8, !tbaa !290
  %256 = getelementptr inbounds %struct.Proto, %struct.Proto* %176, i64 0, i32 4
  store i8 1, i8* %256, align 1, !tbaa !115
  %257 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %6, i32 82) #17
  %258 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %258, align 8, !tbaa !291
  %259 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %259, align 4, !tbaa !293
  %260 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 8, i32* %260, align 8, !tbaa !294
  %261 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %262 = bitcast %union.anon.8* %261 to i32*
  store i32 0, i32* %262, align 8, !tbaa !21
  %263 = load %struct.TString*, %struct.TString** %220, align 8, !tbaa !268
  %264 = call fastcc i32 @newupvalue(%struct.FuncState* nonnull %6, %struct.TString* %263, %struct.expdesc* nonnull %4) #17
  %265 = load i32, i32* %215, align 4, !tbaa !265
  store i32 %265, i32* %216, align 8, !tbaa !266
  %266 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 4
  %267 = getelementptr inbounds %struct.Token, %struct.Token* %266, i64 0, i32 0
  %268 = load i32, i32* %267, align 8, !tbaa !263
  %269 = icmp eq i32 %268, 289
  br i1 %269, label %274, label %270

; <label>:270:                                    ; preds = %195
  %271 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 3
  %272 = bitcast %struct.Token* %271 to i8*
  %273 = bitcast %struct.Token* %266 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %272, i8* nonnull %273, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %267, align 8, !tbaa !263
  br label %277

; <label>:274:                                    ; preds = %195
  %275 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 3, i32 1
  %276 = call fastcc i32 @llex(%struct.LexState* nonnull %5, %union.SemInfo* nonnull %275) #17
  store i32 %276, i32* %208, align 8, !tbaa !260
  br label %277

; <label>:277:                                    ; preds = %274, %270
  br label %278

; <label>:278:                                    ; preds = %277, %280
  %279 = load i32, i32* %208, align 8, !tbaa !260
  switch i32 %279, label %280 [
    i32 260, label %284
    i32 261, label %284
    i32 262, label %284
    i32 289, label %284
    i32 277, label %284
  ]

; <label>:280:                                    ; preds = %278
  %281 = icmp eq i32 %279, 274
  call fastcc void @statement(%struct.LexState* nonnull %5) #17
  br i1 %281, label %282, label %278

; <label>:282:                                    ; preds = %280
  %283 = load i32, i32* %208, align 8, !tbaa !260
  br label %284

; <label>:284:                                    ; preds = %278, %278, %278, %278, %278, %282
  %285 = phi i32 [ %283, %282 ], [ %279, %278 ], [ %279, %278 ], [ %279, %278 ], [ %279, %278 ], [ %279, %278 ]
  %286 = icmp eq i32 %285, 289
  br i1 %286, label %288, label %287

; <label>:287:                                    ; preds = %284
  call fastcc void @error_expected(%struct.LexState* nonnull %5, i32 289) #19
  unreachable

; <label>:288:                                    ; preds = %284
  call fastcc void @close_func(%struct.LexState* nonnull %5) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %228) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %227) #7
  %289 = load %union.StackValue*, %union.StackValue** %119, align 8, !tbaa !20
  %290 = getelementptr inbounds %union.StackValue, %union.StackValue* %289, i64 -1
  store %union.StackValue* %290, %union.StackValue** %119, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %99) #7
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %98) #7
  br label %291

; <label>:291:                                    ; preds = %288, %85
  %292 = phi %struct.LClosure* [ %68, %85 ], [ %113, %288 ]
  %293 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %292, i64 0, i32 3
  %294 = load i8, i8* %293, align 2, !tbaa !182
  %295 = icmp eq i8 %294, 0
  br i1 %295, label %332, label %296

; <label>:296:                                    ; preds = %291
  %297 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %298 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %292, i64 0, i32 2
  %299 = bitcast %struct.LClosure* %292 to %struct.GCObject*
  br label %300

; <label>:300:                                    ; preds = %327, %296
  %301 = phi i64 [ 0, %296 ], [ %328, %327 ]
  %302 = load %struct.global_State*, %struct.global_State** %297, align 8, !tbaa !2
  %303 = call fastcc i8* @luaM_malloc_(%struct.lua_State* nonnull %0, i64 40, i32 9) #17
  %304 = getelementptr inbounds %struct.global_State, %struct.global_State* %302, i64 0, i32 10
  %305 = load i8, i8* %304, align 4, !tbaa !15
  %306 = and i8 %305, 24
  %307 = getelementptr inbounds i8, i8* %303, i64 9
  store i8 %306, i8* %307, align 1, !tbaa !70
  %308 = getelementptr inbounds i8, i8* %303, i64 8
  store i8 9, i8* %308, align 8, !tbaa !86
  %309 = getelementptr inbounds %struct.global_State, %struct.global_State* %302, i64 0, i32 20
  %310 = bitcast %struct.GCObject** %309 to i64*
  %311 = load i64, i64* %310, align 8, !tbaa !18
  %312 = bitcast i8* %303 to i64*
  store i64 %311, i64* %312, align 8, !tbaa !87
  %313 = bitcast %struct.GCObject** %309 to i8**
  store i8* %303, i8** %313, align 8, !tbaa !18
  %314 = getelementptr inbounds i8, i8* %303, i64 24
  %315 = getelementptr inbounds i8, i8* %303, i64 16
  %316 = bitcast i8* %315 to i8**
  store i8* %314, i8** %316, align 8, !tbaa !67
  %317 = getelementptr inbounds i8, i8* %303, i64 32
  store i8 0, i8* %317, align 8, !tbaa !22
  %318 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %292, i64 0, i32 6, i64 %301
  %319 = bitcast %struct.UpVal** %318 to i8**
  store i8* %303, i8** %319, align 8, !tbaa !54
  %320 = load i8, i8* %298, align 1, !tbaa !201
  %321 = and i8 %320, 32
  %322 = icmp eq i8 %321, 0
  %323 = icmp eq i8 %306, 0
  %324 = or i1 %323, %322
  br i1 %324, label %327, label %325

; <label>:325:                                    ; preds = %300
  %326 = bitcast i8* %303 to %struct.GCObject*
  call fastcc void @luaC_barrier_(%struct.lua_State* nonnull %0, %struct.GCObject* nonnull %299, %struct.GCObject* nonnull %326) #17
  br label %327

; <label>:327:                                    ; preds = %325, %300
  %328 = add nuw nsw i64 %301, 1
  %329 = load i8, i8* %293, align 2, !tbaa !182
  %330 = zext i8 %329 to i64
  %331 = icmp ult i64 %328, %330
  br i1 %331, label %300, label %332

; <label>:332:                                    ; preds = %327, %291
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaM_saferealloc_(%struct.lua_State*, i8*, i64, i64) unnamed_addr #0 {
  %5 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %2, i64 %3) #16
  %6 = icmp eq i8* %5, null
  %7 = icmp ne i64 %3, 0
  %8 = and i1 %7, %6
  br i1 %8, label %9, label %10, !prof !61

; <label>:9:                                      ; preds = %4
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:10:                                     ; preds = %4
  ret i8* %5
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaZ_fill(%struct.Zio* nocapture) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 4
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !162
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 2
  %7 = load i8* (%struct.lua_State*, i8*, i64*)*, i8* (%struct.lua_State*, i8*, i64*)** %6, align 8, !tbaa !164
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 3
  %9 = load i8*, i8** %8, align 8, !tbaa !165
  %10 = call i8* %7(%struct.lua_State* %5, i8* %9, i64* nonnull %2) #17
  %11 = icmp eq i8* %10, null
  %12 = load i64, i64* %2, align 8
  %13 = icmp eq i64 %12, 0
  %14 = or i1 %11, %13
  br i1 %14, label %22, label %15

; <label>:15:                                     ; preds = %1
  %16 = add i64 %12, -1
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 0
  store i64 %16, i64* %17, align 8, !tbaa !244
  %18 = getelementptr inbounds %struct.Zio, %struct.Zio* %0, i64 0, i32 1
  %19 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %19, i8** %18, align 8, !tbaa !245
  %20 = load i8, i8* %10, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %22

; <label>:22:                                     ; preds = %1, %15
  %23 = phi i32 [ %21, %15 ], [ -1, %1 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %23
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checkmode(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = icmp eq i8* %1, null
  br i1 %4, label %12, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i8, i8* %2, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  %8 = tail call i8* @strchr(i8* nonnull %1, i32 %7) #21
  %9 = icmp eq i8* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %5
  %11 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.205, i64 0, i64 0), i8* nonnull %2, i8* nonnull %1) #16
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 3) #18
  unreachable

; <label>:12:                                     ; preds = %3, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc zeroext i8 @LoadByte(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %3 = load %struct.Zio*, %struct.Zio** %2, align 8, !tbaa !249
  %4 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 0
  %5 = load i64, i64* %4, align 8, !tbaa !244
  %6 = add i64 %5, -1
  store i64 %6, i64* %4, align 8, !tbaa !244
  %7 = icmp eq i64 %5, 0
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %3, i64 0, i32 1
  %10 = load i8*, i8** %9, align 8, !tbaa !245
  %11 = getelementptr inbounds i8, i8* %10, i64 1
  store i8* %11, i8** %9, align 8, !tbaa !245
  %12 = load i8, i8* %10, align 1, !tbaa !21
  %13 = zext i8 %12 to i32
  br label %18

; <label>:14:                                     ; preds = %1
  %15 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %3) #16
  %16 = icmp eq i32 %15, -1
  br i1 %16, label %17, label %18

; <label>:17:                                     ; preds = %14
  tail call fastcc void @error(%struct.LoadState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %8, %14
  %19 = phi i32 [ %13, %8 ], [ %15, %14 ]
  %20 = trunc i32 %19 to i8
  ret i8 %20
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.Proto* @luaF_newproto(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %0, i64 128, i32 10) #17
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 10
  %6 = load i8, i8* %5, align 4, !tbaa !15
  %7 = and i8 %6, 24
  %8 = getelementptr inbounds i8, i8* %4, i64 9
  store i8 %7, i8* %8, align 1, !tbaa !70
  %9 = getelementptr inbounds i8, i8* %4, i64 8
  store i8 10, i8* %9, align 8, !tbaa !86
  %10 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 20
  %11 = bitcast %struct.GCObject** %10 to i64*
  %12 = load i64, i64* %11, align 8, !tbaa !18
  %13 = bitcast i8* %4 to i64*
  store i64 %12, i64* %13, align 8, !tbaa !87
  %14 = bitcast %struct.GCObject** %10 to i8**
  store i8* %4, i8** %14, align 8, !tbaa !18
  %15 = bitcast i8* %4 to %struct.Proto*
  %16 = getelementptr inbounds i8, i8* %4, i64 56
  %17 = getelementptr inbounds i8, i8* %4, i64 16
  %18 = getelementptr inbounds i8, i8* %4, i64 10
  store i8 0, i8* %18, align 2, !tbaa !131
  %19 = getelementptr inbounds i8, i8* %4, i64 11
  store i8 0, i8* %19, align 1, !tbaa !115
  %20 = getelementptr inbounds i8, i8* %4, i64 12
  store i8 0, i8* %20, align 4, !tbaa !158
  call void @llvm.memset.p0i8.i64(i8* nonnull %17, i8 0, i64 36, i32 8, i1 false)
  call void @llvm.memset.p0i8.i64(i8* nonnull %16, i8 0, i64 64, i32 8, i1 false)
  ret %struct.Proto* %15
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @LoadFunction(%struct.LoadState* readonly, %struct.Proto*, %struct.TString*) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = alloca double, align 8
  %6 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #16
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 22
  %8 = icmp eq %struct.TString* %6, null
  %9 = select i1 %8, %struct.TString* %2, %struct.TString* %6
  store %struct.TString* %9, %struct.TString** %7, align 8, !tbaa !122
  %10 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %11 = trunc i64 %10 to i32
  %12 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 13
  store i32 %11, i32* %12, align 4, !tbaa !124
  %13 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %14 = trunc i64 %13 to i32
  %15 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 14
  store i32 %14, i32* %15, align 8, !tbaa !125
  %16 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 3
  store i8 %16, i8* %17, align 2, !tbaa !131
  %18 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %19 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 4
  store i8 %18, i8* %19, align 1, !tbaa !115
  %20 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 5
  store i8 %20, i8* %21, align 4, !tbaa !158
  %22 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %23 = trunc i64 %22 to i32
  %24 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %25 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %26 = shl i64 %22, 32
  %27 = ashr exact i64 %26, 30
  %28 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %25, i64 %27, i32 0) #17
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 16
  %30 = bitcast i32** %29 to i8**
  store i8* %28, i8** %30, align 8, !tbaa !116
  %31 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 8
  store i32 %23, i32* %31, align 8, !tbaa !220
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %28, i64 %27) #17
  %32 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %33 = trunc i64 %32 to i32
  %34 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %35 = shl i64 %32, 32
  %36 = ashr exact i64 %35, 28
  %37 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %34, i64 %36, i32 0) #17
  %38 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 15
  %39 = bitcast %struct.TValue** %38 to i8**
  store i8* %37, i8** %39, align 8, !tbaa !223
  %40 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 7
  store i32 %33, i32* %40, align 4, !tbaa !224
  %41 = icmp sgt i32 %33, 0
  %42 = bitcast i8* %37 to %struct.TValue*
  br i1 %41, label %43, label %87

; <label>:43:                                     ; preds = %3
  %44 = and i64 %32, 4294967295
  br label %45

; <label>:45:                                     ; preds = %45, %43
  %46 = phi i64 [ 0, %43 ], [ %48, %45 ]
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %42, i64 %46, i32 1
  store i8 0, i8* %47, align 8, !tbaa !22
  %48 = add nuw nsw i64 %46, 1
  %49 = icmp eq i64 %48, %44
  br i1 %49, label %50, label %45

; <label>:50:                                     ; preds = %45
  %51 = bitcast double* %5 to i8*
  %52 = bitcast double* %5 to i64*
  %53 = bitcast i64* %4 to i8*
  %54 = ashr exact i64 %35, 32
  br label %55

; <label>:55:                                     ; preds = %85, %50
  %56 = phi %struct.TValue* [ %42, %50 ], [ %86, %85 ]
  %57 = phi i64 [ 0, %50 ], [ %83, %85 ]
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %56, i64 %57
  %59 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  switch i8 %59, label %82 [
    i8 0, label %79
    i8 1, label %60
    i8 19, label %64
    i8 35, label %67
    i8 20, label %70
    i8 36, label %70
  ]

; <label>:60:                                     ; preds = %55
  %61 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %62 = zext i8 %61 to i32
  %63 = bitcast %struct.TValue* %58 to i32*
  store i32 %62, i32* %63, align 8, !tbaa !21
  br label %79

; <label>:64:                                     ; preds = %55
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %51) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %51, i64 8) #17
  %65 = load i64, i64* %52, align 8, !tbaa !140
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %51) #7
  %66 = bitcast %struct.TValue* %58 to i64*
  store i64 %65, i64* %66, align 8, !tbaa !21
  br label %79

; <label>:67:                                     ; preds = %55
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %53) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %53, i64 8) #17
  %68 = load i64, i64* %4, align 8, !tbaa !144
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %53) #7
  %69 = bitcast %struct.TValue* %58 to i64*
  store i64 %68, i64* %69, align 8, !tbaa !21
  br label %79

; <label>:70:                                     ; preds = %55, %55
  %71 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %72 = icmp eq %struct.TString* %71, null
  br i1 %72, label %73, label %74

; <label>:73:                                     ; preds = %70
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.221, i64 0, i64 0)) #19
  unreachable

; <label>:74:                                     ; preds = %70
  %75 = bitcast %struct.TValue* %58 to %struct.TString**
  store %struct.TString* %71, %struct.TString** %75, align 8, !tbaa !21
  %76 = getelementptr inbounds %struct.TString, %struct.TString* %71, i64 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !75
  %78 = or i8 %77, 64
  br label %79

; <label>:79:                                     ; preds = %55, %60, %64, %67, %74
  %80 = phi i8 [ %78, %74 ], [ 35, %67 ], [ 19, %64 ], [ 1, %60 ], [ %59, %55 ]
  %81 = getelementptr inbounds %struct.TValue, %struct.TValue* %56, i64 %57, i32 1
  store i8 %80, i8* %81, align 8, !tbaa !22
  br label %82

; <label>:82:                                     ; preds = %79, %55
  %83 = add nuw nsw i64 %57, 1
  %84 = icmp slt i64 %83, %54
  br i1 %84, label %85, label %87

; <label>:85:                                     ; preds = %82
  %86 = load %struct.TValue*, %struct.TValue** %38, align 8, !tbaa !223
  br label %55

; <label>:87:                                     ; preds = %82, %3
  %88 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %89 = trunc i64 %88 to i32
  %90 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %91 = shl i64 %88, 32
  %92 = ashr exact i64 %91, 28
  %93 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %90, i64 %92, i32 0) #17
  %94 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 18
  %95 = bitcast %struct.Upvaldesc** %94 to i8**
  store i8* %93, i8** %95, align 8, !tbaa !198
  %96 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 6
  store i32 %89, i32* %96, align 8, !tbaa !190
  %97 = icmp sgt i32 %89, 0
  %98 = bitcast i8* %93 to %struct.Upvaldesc*
  br i1 %97, label %99, label %117

; <label>:99:                                     ; preds = %87
  %100 = and i64 %88, 4294967295
  br label %101

; <label>:101:                                    ; preds = %101, %99
  %102 = phi i64 [ 0, %99 ], [ %104, %101 ]
  %103 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %98, i64 %102, i32 0
  store %struct.TString* null, %struct.TString** %103, align 8, !tbaa !199
  %104 = add nuw nsw i64 %102, 1
  %105 = icmp eq i64 %104, %100
  br i1 %105, label %106, label %101

; <label>:106:                                    ; preds = %101
  br label %107

; <label>:107:                                    ; preds = %106, %107
  %108 = phi i64 [ %115, %107 ], [ 0, %106 ]
  %109 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %110 = load %struct.Upvaldesc*, %struct.Upvaldesc** %94, align 8, !tbaa !198
  %111 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %110, i64 %108, i32 1
  store i8 %109, i8* %111, align 8, !tbaa !240
  %112 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #17
  %113 = load %struct.Upvaldesc*, %struct.Upvaldesc** %94, align 8, !tbaa !198
  %114 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %113, i64 %108, i32 2
  store i8 %112, i8* %114, align 1, !tbaa !241
  %115 = add nuw nsw i64 %108, 1
  %116 = icmp eq i64 %115, %100
  br i1 %116, label %117, label %107

; <label>:117:                                    ; preds = %107, %87
  %118 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %119 = trunc i64 %118 to i32
  %120 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %121 = shl i64 %118, 32
  %122 = ashr exact i64 %121, 29
  %123 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %120, i64 %122, i32 0) #17
  %124 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 17
  %125 = bitcast %struct.Proto*** %124 to i8**
  store i8* %123, i8** %125, align 8, !tbaa !221
  %126 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 10
  store i32 %119, i32* %126, align 8, !tbaa !222
  %127 = icmp sgt i32 %119, 0
  br i1 %127, label %128, label %154

; <label>:128:                                    ; preds = %117
  %129 = bitcast i8* %123 to %struct.Proto**
  %130 = and i64 %118, 4294967295
  store %struct.Proto* null, %struct.Proto** %129, align 8, !tbaa !54
  %131 = icmp eq i64 %130, 1
  br i1 %131, label %139, label %132

; <label>:132:                                    ; preds = %128
  br label %133

; <label>:133:                                    ; preds = %132, %133
  %134 = phi i64 [ %137, %133 ], [ 1, %132 ]
  %135 = load %struct.Proto**, %struct.Proto*** %124, align 8, !tbaa !221
  %136 = getelementptr inbounds %struct.Proto*, %struct.Proto** %135, i64 %134
  store %struct.Proto* null, %struct.Proto** %136, align 8, !tbaa !54
  %137 = add nuw nsw i64 %134, 1
  %138 = icmp eq i64 %137, %130
  br i1 %138, label %139, label %133

; <label>:139:                                    ; preds = %133, %128
  br i1 %127, label %140, label %154

; <label>:140:                                    ; preds = %139
  %141 = and i64 %118, 4294967295
  br label %142

; <label>:142:                                    ; preds = %142, %140
  %143 = phi i64 [ 0, %140 ], [ %152, %142 ]
  %144 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %145 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %144) #17
  %146 = load %struct.Proto**, %struct.Proto*** %124, align 8, !tbaa !221
  %147 = getelementptr inbounds %struct.Proto*, %struct.Proto** %146, i64 %143
  store %struct.Proto* %145, %struct.Proto** %147, align 8, !tbaa !54
  %148 = load %struct.Proto**, %struct.Proto*** %124, align 8, !tbaa !221
  %149 = getelementptr inbounds %struct.Proto*, %struct.Proto** %148, i64 %143
  %150 = load %struct.Proto*, %struct.Proto** %149, align 8, !tbaa !54
  %151 = load %struct.TString*, %struct.TString** %7, align 8, !tbaa !122
  tail call fastcc void @LoadFunction(%struct.LoadState* %0, %struct.Proto* %150, %struct.TString* %151) #17
  %152 = add nuw nsw i64 %143, 1
  %153 = icmp eq i64 %152, %141
  br i1 %153, label %154, label %142

; <label>:154:                                    ; preds = %142, %117, %139
  %155 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %156 = trunc i64 %155 to i32
  %157 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %158 = shl i64 %155, 32
  %159 = ashr exact i64 %158, 32
  %160 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %157, i64 %159, i32 0) #17
  %161 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  store i8* %160, i8** %161, align 8, !tbaa !137
  %162 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  store i32 %156, i32* %162, align 4, !tbaa !136
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* %160, i64 %159) #17
  %163 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %164 = trunc i64 %163 to i32
  %165 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %166 = shl i64 %163, 32
  %167 = ashr exact i64 %166, 29
  %168 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %165, i64 %167, i32 0) #17
  %169 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %170 = bitcast %struct.AbsLineInfo** %169 to i8**
  store i8* %168, i8** %170, align 8, !tbaa !225
  %171 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  store i32 %164, i32* %171, align 8, !tbaa !226
  %172 = icmp sgt i32 %164, 0
  %173 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %174 = trunc i64 %173 to i32
  br i1 %172, label %175, label %192

; <label>:175:                                    ; preds = %154
  %176 = and i64 %163, 4294967295
  br label %177

; <label>:177:                                    ; preds = %177, %175
  %178 = phi i64 [ 0, %175 ], [ %186, %177 ]
  %179 = phi i32 [ %174, %175 ], [ %188, %177 ]
  %180 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %169, align 8, !tbaa !225
  %181 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %180, i64 %178, i32 0
  store i32 %179, i32* %181, align 4, !tbaa !238
  %182 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %183 = trunc i64 %182 to i32
  %184 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %169, align 8, !tbaa !225
  %185 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %184, i64 %178, i32 1
  store i32 %183, i32* %185, align 4, !tbaa !296
  %186 = add nuw nsw i64 %178, 1
  %187 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %188 = trunc i64 %187 to i32
  %189 = icmp eq i64 %186, %176
  br i1 %189, label %190, label %177

; <label>:190:                                    ; preds = %177
  %191 = trunc i64 %187 to i32
  br label %192

; <label>:192:                                    ; preds = %190, %154
  %193 = phi i64 [ %173, %154 ], [ %187, %190 ]
  %194 = phi i32 [ %174, %154 ], [ %191, %190 ]
  %195 = load %struct.lua_State*, %struct.lua_State** %24, align 8, !tbaa !248
  %196 = shl i64 %193, 32
  %197 = ashr exact i64 %196, 28
  %198 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %195, i64 %197, i32 0) #17
  %199 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 21
  %200 = bitcast %struct.LocVar** %199 to i8**
  store i8* %198, i8** %200, align 8, !tbaa !110
  %201 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 11
  store i32 %194, i32* %201, align 4, !tbaa !108
  %202 = icmp sgt i32 %194, 0
  %203 = bitcast i8* %198 to %struct.LocVar*
  br i1 %202, label %204, label %227

; <label>:204:                                    ; preds = %192
  %205 = zext i32 %194 to i64
  br label %206

; <label>:206:                                    ; preds = %206, %204
  %207 = phi i64 [ 0, %204 ], [ %209, %206 ]
  %208 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %203, i64 %207, i32 0
  store %struct.TString* null, %struct.TString** %208, align 8, !tbaa !114
  %209 = add nuw nsw i64 %207, 1
  %210 = icmp eq i64 %209, %205
  br i1 %210, label %211, label %206

; <label>:211:                                    ; preds = %206
  br label %212

; <label>:212:                                    ; preds = %211, %212
  %213 = phi i64 [ %225, %212 ], [ 0, %211 ]
  %214 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %215 = load %struct.LocVar*, %struct.LocVar** %199, align 8, !tbaa !110
  %216 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %215, i64 %213, i32 0
  store %struct.TString* %214, %struct.TString** %216, align 8, !tbaa !114
  %217 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %218 = trunc i64 %217 to i32
  %219 = load %struct.LocVar*, %struct.LocVar** %199, align 8, !tbaa !110
  %220 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %219, i64 %213, i32 1
  store i32 %218, i32* %220, align 8, !tbaa !111
  %221 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %222 = trunc i64 %221 to i32
  %223 = load %struct.LocVar*, %struct.LocVar** %199, align 8, !tbaa !110
  %224 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %223, i64 %213, i32 2
  store i32 %222, i32* %224, align 4, !tbaa !113
  %225 = add nuw nsw i64 %213, 1
  %226 = icmp eq i64 %225, %205
  br i1 %226, label %227, label %212

; <label>:227:                                    ; preds = %212, %192
  %228 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 2147483647) #17
  %229 = trunc i64 %228 to i32
  %230 = icmp sgt i32 %229, 0
  br i1 %230, label %231, label %240

; <label>:231:                                    ; preds = %227
  %232 = and i64 %228, 4294967295
  br label %233

; <label>:233:                                    ; preds = %233, %231
  %234 = phi i64 [ 0, %231 ], [ %238, %233 ]
  %235 = tail call fastcc %struct.TString* @LoadStringN(%struct.LoadState* %0) #17
  %236 = load %struct.Upvaldesc*, %struct.Upvaldesc** %94, align 8, !tbaa !198
  %237 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %236, i64 %234, i32 0
  store %struct.TString* %235, %struct.TString** %237, align 8, !tbaa !199
  %238 = add nuw nsw i64 %234, 1
  %239 = icmp eq i64 %238, %232
  br i1 %239, label %240, label %233

; <label>:240:                                    ; preds = %233, %227
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checkliteral(%struct.LoadState* nocapture readonly, i8* nocapture readonly, i8*) unnamed_addr #0 {
  %4 = alloca [12 x i8], align 1
  %5 = getelementptr inbounds [12 x i8], [12 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 12, i8* nonnull %5) #7
  %6 = tail call i64 @strlen(i8* %1) #21
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %5, i64 %6) #16
  %7 = call i32 @memcmp(i8* %1, i8* nonnull %5, i64 %6) #21
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %3
  tail call fastcc void @error(%struct.LoadState* %0, i8* %2) #18
  unreachable

; <label>:10:                                     ; preds = %3
  call void @llvm.lifetime.end.p0i8(i64 12, i8* nonnull %5) #7
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @error(%struct.LoadState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !248
  %5 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 2
  %6 = load i8*, i8** %5, align 8, !tbaa !246
  %7 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.219, i64 0, i64 0), i8* %6, i8* %1) #16
  %8 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !248
  tail call fastcc void @luaD_throw(%struct.lua_State* %8, i32 3) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fchecksize(%struct.LoadState* nocapture readonly, i64, i8*) unnamed_addr #0 {
  %4 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %5 = zext i8 %4 to i64
  %6 = icmp eq i64 %5, %1
  br i1 %6, label %11, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !248
  %10 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.220, i64 0, i64 0), i8* %2) #16
  tail call fastcc void @error(%struct.LoadState* %0, i8* %10) #18
  unreachable

; <label>:11:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @LoadBlock(%struct.LoadState* nocapture readonly, i8* nocapture, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 1
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !249
  %6 = icmp eq i64 %2, 0
  br i1 %6, label %39, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %10 = load i64, i64* %8, align 8, !tbaa !244
  br label %11

; <label>:11:                                     ; preds = %26, %7
  %12 = phi i64 [ %10, %7 ], [ %32, %26 ]
  %13 = phi i64 [ %2, %7 ], [ %36, %26 ]
  %14 = phi i8* [ %1, %7 ], [ %35, %26 ]
  %15 = icmp eq i64 %12, 0
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %11
  %17 = load i8*, i8** %9, align 8, !tbaa !245
  br label %26

; <label>:18:                                     ; preds = %11
  %19 = tail call fastcc i32 @luaZ_fill(%struct.Zio* nonnull %5) #17
  %20 = icmp eq i32 %19, -1
  br i1 %20, label %38, label %21

; <label>:21:                                     ; preds = %18
  %22 = load i64, i64* %8, align 8, !tbaa !244
  %23 = add i64 %22, 1
  store i64 %23, i64* %8, align 8, !tbaa !244
  %24 = load i8*, i8** %9, align 8, !tbaa !245
  %25 = getelementptr inbounds i8, i8* %24, i64 -1
  store i8* %25, i8** %9, align 8, !tbaa !245
  br label %26

; <label>:26:                                     ; preds = %21, %16
  %27 = phi i8* [ %17, %16 ], [ %25, %21 ]
  %28 = phi i64 [ %12, %16 ], [ %23, %21 ]
  %29 = icmp ugt i64 %13, %28
  %30 = select i1 %29, i64 %28, i64 %13
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %27, i64 %30, i32 1, i1 false) #7
  %31 = load i64, i64* %8, align 8, !tbaa !244
  %32 = sub i64 %31, %30
  store i64 %32, i64* %8, align 8, !tbaa !244
  %33 = load i8*, i8** %9, align 8, !tbaa !245
  %34 = getelementptr inbounds i8, i8* %33, i64 %30
  store i8* %34, i8** %9, align 8, !tbaa !245
  %35 = getelementptr inbounds i8, i8* %14, i64 %30
  %36 = sub i64 %13, %30
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %39, label %11

; <label>:38:                                     ; preds = %18
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.217, i64 0, i64 0)) #18
  unreachable

; <label>:39:                                     ; preds = %26, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @LoadUnsigned(%struct.LoadState* nocapture readonly, i64) unnamed_addr #0 {
  %3 = lshr i64 %1, 7
  br label %4

; <label>:4:                                      ; preds = %9, %2
  %5 = phi i64 [ 0, %2 ], [ %13, %9 ]
  %6 = tail call fastcc zeroext i8 @LoadByte(%struct.LoadState* %0) #16
  %7 = icmp ult i64 %5, %3
  br i1 %7, label %9, label %8

; <label>:8:                                      ; preds = %4
  tail call fastcc void @error(%struct.LoadState* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0)) #18
  unreachable

; <label>:9:                                      ; preds = %4
  %10 = shl i64 %5, 7
  %11 = and i8 %6, 127
  %12 = zext i8 %11 to i64
  %13 = or i64 %10, %12
  %14 = icmp sgt i8 %6, -1
  br i1 %14, label %4, label %15

; <label>:15:                                     ; preds = %9
  ret i64 %13
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TString* @LoadStringN(%struct.LoadState* nocapture readonly) unnamed_addr #0 {
  %2 = alloca [40 x i8], align 16
  %3 = tail call fastcc i64 @LoadUnsigned(%struct.LoadState* %0, i64 -1) #17
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %40, label %5

; <label>:5:                                      ; preds = %1
  %6 = add i64 %3, -1
  %7 = icmp ult i64 %6, 41
  br i1 %7, label %8, label %13

; <label>:8:                                      ; preds = %5
  %9 = getelementptr inbounds [40 x i8], [40 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %9) #7
  call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %9, i64 %6) #16
  %10 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !248
  %12 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* nonnull %9, i64 %6) #16
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %9) #7
  br label %40

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.LoadState, %struct.LoadState* %0, i64 0, i32 0
  %15 = load %struct.lua_State*, %struct.lua_State** %14, align 8, !tbaa !248
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %15, i64 0, i32 7
  %17 = load %struct.global_State*, %struct.global_State** %16, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 9
  %19 = load i32, i32* %18, align 8, !tbaa !78
  %20 = add i64 %3, 24
  %21 = tail call fastcc i8* @luaM_malloc_(%struct.lua_State* %15, i64 %20, i32 4) #17
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 10
  %23 = load i8, i8* %22, align 4, !tbaa !15
  %24 = and i8 %23, 24
  %25 = getelementptr inbounds i8, i8* %21, i64 9
  store i8 %24, i8* %25, align 1, !tbaa !70
  %26 = getelementptr inbounds i8, i8* %21, i64 8
  store i8 36, i8* %26, align 8, !tbaa !86
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 20
  %28 = bitcast %struct.GCObject** %27 to i64*
  %29 = load i64, i64* %28, align 8, !tbaa !18
  %30 = bitcast i8* %21 to i64*
  store i64 %29, i64* %30, align 8, !tbaa !87
  %31 = bitcast %struct.GCObject** %27 to i8**
  store i8* %21, i8** %31, align 8, !tbaa !18
  %32 = bitcast i8* %21 to %struct.TString*
  %33 = getelementptr inbounds i8, i8* %21, i64 12
  %34 = bitcast i8* %33 to i32*
  store i32 %19, i32* %34, align 4, !tbaa !150
  %35 = getelementptr inbounds i8, i8* %21, i64 10
  store i8 0, i8* %35, align 2, !tbaa !99
  %36 = getelementptr inbounds i8, i8* %21, i64 24
  %37 = getelementptr inbounds i8, i8* %36, i64 %6
  store i8 0, i8* %37, align 1, !tbaa !21
  %38 = getelementptr inbounds i8, i8* %21, i64 16
  %39 = bitcast i8* %38 to i64*
  store i64 %6, i64* %39, align 8, !tbaa !21
  tail call fastcc void @LoadBlock(%struct.LoadState* %0, i8* nonnull %36, i64 %6) #16
  br label %40

; <label>:40:                                     ; preds = %1, %13, %8
  %41 = phi %struct.TString* [ %12, %8 ], [ %32, %13 ], [ null, %1 ]
  ret %struct.TString* %41
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @newupvalue(%struct.FuncState* nocapture, %struct.TString*, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !253
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 6
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %8 = load i8, i8* %7, align 1, !tbaa !297
  %9 = icmp eq i8 %8, -1
  br i1 %9, label %10, label %11

; <label>:10:                                     ; preds = %3
  tail call fastcc void @errorlimit(%struct.FuncState* nonnull %0, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0)) #19
  unreachable

; <label>:11:                                     ; preds = %3
  %12 = zext i8 %8 to i32
  %13 = load i32, i32* %6, align 8, !tbaa !190
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %15 = load %struct.LexState*, %struct.LexState** %14, align 8, !tbaa !272
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %15, i64 0, i32 6
  %17 = load %struct.lua_State*, %struct.lua_State** %16, align 8, !tbaa !261
  %18 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 18
  %19 = bitcast %struct.Upvaldesc** %18 to i8**
  %20 = load i8*, i8** %19, align 8, !tbaa !198
  %21 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %17, i8* %20, i32 %12, i32* nonnull %6, i32 16, i32 255, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.225, i64 0, i64 0)) #16
  store i8* %21, i8** %19, align 8, !tbaa !198
  %22 = load i32, i32* %6, align 8, !tbaa !190
  %23 = icmp slt i32 %13, %22
  %24 = bitcast i8* %21 to %struct.Upvaldesc*
  br i1 %23, label %25, label %33

; <label>:25:                                     ; preds = %11
  %26 = sext i32 %13 to i64
  %27 = sext i32 %22 to i64
  br label %28

; <label>:28:                                     ; preds = %25, %28
  %29 = phi i64 [ %26, %25 ], [ %30, %28 ]
  %30 = add nsw i64 %29, 1
  %31 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %24, i64 %29, i32 0
  store %struct.TString* null, %struct.TString** %31, align 8, !tbaa !199
  %32 = icmp slt i64 %30, %27
  br i1 %32, label %28, label %33

; <label>:33:                                     ; preds = %28, %11
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %35 = load i32, i32* %34, align 8, !tbaa !294
  %36 = icmp eq i32 %35, 8
  %37 = zext i1 %36 to i8
  %38 = load i8, i8* %7, align 1, !tbaa !297
  %39 = zext i8 %38 to i64
  %40 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %24, i64 %39, i32 1
  store i8 %37, i8* %40, align 8, !tbaa !240
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %42 = bitcast %union.anon.8* %41 to i32*
  %43 = load i32, i32* %42, align 8, !tbaa !21
  %44 = trunc i32 %43 to i8
  %45 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %24, i64 %39, i32 2
  store i8 %44, i8* %45, align 1, !tbaa !241
  %46 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %24, i64 %39, i32 0
  store %struct.TString* %1, %struct.TString** %46, align 8, !tbaa !199
  %47 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 2
  %48 = load i8, i8* %47, align 1, !tbaa !234
  %49 = and i8 %48, 32
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %63, label %51

; <label>:51:                                     ; preds = %33
  %52 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %53 = load i8, i8* %52, align 1, !tbaa !148
  %54 = and i8 %53, 24
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %63, label %56

; <label>:56:                                     ; preds = %51
  %57 = load %struct.LexState*, %struct.LexState** %14, align 8, !tbaa !272
  %58 = getelementptr inbounds %struct.LexState, %struct.LexState* %57, i64 0, i32 6
  %59 = load %struct.lua_State*, %struct.lua_State** %58, align 8, !tbaa !261
  %60 = bitcast %struct.Proto* %5 to %struct.GCObject*
  %61 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %59, %struct.GCObject* %60, %struct.GCObject* %61) #16
  %62 = load i8, i8* %7, align 1, !tbaa !297
  br label %63

; <label>:63:                                     ; preds = %51, %33, %56
  %64 = phi i8 [ %38, %51 ], [ %38, %33 ], [ %62, %56 ]
  %65 = add i8 %64, 1
  store i8 %65, i8* %7, align 1, !tbaa !297
  %66 = zext i8 %64 to i32
  ret i32 %66
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @close_func(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %3 = load %struct.lua_State*, %struct.lua_State** %2, align 8, !tbaa !261
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !273
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !253
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 13
  %9 = load i8, i8* %8, align 2, !tbaa !298
  %10 = zext i8 %9 to i32
  %11 = shl nuw nsw i32 %10, 7
  %12 = or i32 %11, 65608
  %13 = tail call fastcc i32 @luaK_code(%struct.FuncState* %5, i32 %12) #17
  tail call fastcc void @leaveblock(%struct.FuncState* %5) #16
  %14 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !253
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 4
  %16 = load i32, i32* %15, align 8, !tbaa !274
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %18, label %84

; <label>:18:                                     ; preds = %1
  %19 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 16
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 17
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 4
  %22 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 3
  br label %23

; <label>:23:                                     ; preds = %79, %18
  %24 = phi i64 [ 0, %18 ], [ %80, %79 ]
  %25 = load i32*, i32** %19, align 8, !tbaa !116
  %26 = getelementptr inbounds i32, i32* %25, i64 %24
  %27 = load i32, i32* %26, align 4, !tbaa !77
  %28 = trunc i32 %27 to i7
  switch i7 %28, label %79 [
    i7 -56, label %29
    i7 -55, label %29
    i7 -57, label %38
    i7 -58, label %38
    i7 57, label %61
  ]

; <label>:29:                                     ; preds = %23, %23
  %30 = load i8, i8* %20, align 2, !tbaa !299
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %35

; <label>:32:                                     ; preds = %29
  %33 = load i8, i8* %21, align 1, !tbaa !115
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %79, label %35

; <label>:35:                                     ; preds = %32, %29
  %36 = and i32 %27, -128
  %37 = or i32 %36, 71
  store i32 %37, i32* %26, align 4, !tbaa !77
  br label %38

; <label>:38:                                     ; preds = %35, %23, %23
  %39 = phi i32 [ %27, %23 ], [ %27, %23 ], [ %37, %35 ]
  %40 = load i8, i8* %20, align 2, !tbaa !299
  %41 = icmp eq i8 %40, 0
  %42 = load i8, i8* %21, align 1, !tbaa !115
  br i1 %41, label %43, label %47

; <label>:43:                                     ; preds = %38
  %44 = icmp eq i8 %42, 0
  br i1 %44, label %79, label %45

; <label>:45:                                     ; preds = %43
  %46 = and i32 %39, 16744447
  br label %50

; <label>:47:                                     ; preds = %38
  %48 = and i32 %39, 16744447
  %49 = icmp eq i8 %42, 0
  br i1 %49, label %55, label %50

; <label>:50:                                     ; preds = %47, %45
  %51 = phi i32 [ %46, %45 ], [ %48, %47 ]
  %52 = load i8, i8* %22, align 2, !tbaa !131
  %53 = zext i8 %52 to i32
  %54 = add nuw nsw i32 %53, 1
  br label %55

; <label>:55:                                     ; preds = %50, %47
  %56 = phi i32 [ %51, %50 ], [ %48, %47 ]
  %57 = phi i32 [ %54, %50 ], [ 0, %47 ]
  %58 = shl i32 %57, 24
  %59 = or i32 %56, %58
  %60 = or i32 %59, 32768
  store i32 %60, i32* %26, align 4, !tbaa !77
  br label %79

; <label>:61:                                     ; preds = %23
  %62 = trunc i64 %24 to i32
  br label %63

; <label>:63:                                     ; preds = %71, %61
  %64 = phi i32 [ %62, %61 ], [ %74, %71 ]
  %65 = phi i32 [ 0, %61 ], [ %75, %71 ]
  %66 = sext i32 %64 to i64
  %67 = getelementptr inbounds i32, i32* %25, i64 %66
  %68 = load i32, i32* %67, align 4, !tbaa !77
  %69 = and i32 %68, 127
  %70 = icmp eq i32 %69, 57
  br i1 %70, label %71, label %77

; <label>:71:                                     ; preds = %63
  %72 = lshr i32 %68, 7
  %73 = add i32 %64, -16777214
  %74 = add i32 %73, %72
  %75 = add nuw nsw i32 %65, 1
  %76 = icmp ult i32 %75, 100
  br i1 %76, label %63, label %77

; <label>:77:                                     ; preds = %71, %63
  %78 = phi i32 [ %64, %63 ], [ %74, %71 ]
  tail call fastcc void @fixjump(%struct.FuncState* %5, i32 %62, i32 %78) #17
  br label %79

; <label>:79:                                     ; preds = %77, %55, %43, %32, %23
  %80 = add nuw nsw i64 %24, 1
  %81 = load i32, i32* %15, align 8, !tbaa !274
  %82 = sext i32 %81 to i64
  %83 = icmp slt i64 %80, %82
  br i1 %83, label %23, label %84

; <label>:84:                                     ; preds = %79, %1
  %85 = phi i32 [ %16, %1 ], [ %81, %79 ]
  %86 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %87 = bitcast i32** %86 to i8**
  %88 = load i8*, i8** %87, align 8, !tbaa !116
  %89 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 8
  %90 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %88, i32* nonnull %89, i32 %85, i32 4) #16
  store i8* %90, i8** %87, align 8, !tbaa !116
  %91 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 19
  %92 = load i8*, i8** %91, align 8, !tbaa !137
  %93 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 9
  %94 = load i32, i32* %15, align 8, !tbaa !274
  %95 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %92, i32* nonnull %93, i32 %94, i32 1) #16
  store i8* %95, i8** %91, align 8, !tbaa !137
  %96 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 20
  %97 = bitcast %struct.AbsLineInfo** %96 to i8**
  %98 = load i8*, i8** %97, align 8, !tbaa !225
  %99 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 12
  %100 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 9
  %101 = load i32, i32* %100, align 4, !tbaa !278
  %102 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %98, i32* nonnull %99, i32 %101, i32 8) #16
  store i8* %102, i8** %97, align 8, !tbaa !225
  %103 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 15
  %104 = bitcast %struct.TValue** %103 to i8**
  %105 = load i8*, i8** %104, align 8, !tbaa !223
  %106 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 7
  %107 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 7
  %108 = load i32, i32* %107, align 4, !tbaa !277
  %109 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %105, i32* nonnull %106, i32 %108, i32 16) #16
  store i8* %109, i8** %104, align 8, !tbaa !223
  %110 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 17
  %111 = bitcast %struct.Proto*** %110 to i8**
  %112 = load i8*, i8** %111, align 8, !tbaa !221
  %113 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 10
  %114 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 8
  %115 = load i32, i32* %114, align 8, !tbaa !279
  %116 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %112, i32* nonnull %113, i32 %115, i32 8) #16
  store i8* %116, i8** %111, align 8, !tbaa !221
  %117 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 21
  %118 = bitcast %struct.LocVar** %117 to i8**
  %119 = load i8*, i8** %118, align 8, !tbaa !110
  %120 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 11
  %121 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 12
  %122 = load i16, i16* %121, align 8, !tbaa !300
  %123 = sext i16 %122 to i32
  %124 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %119, i32* nonnull %120, i32 %123, i32 16) #16
  store i8* %124, i8** %118, align 8, !tbaa !110
  %125 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 18
  %126 = bitcast %struct.Upvaldesc** %125 to i8**
  %127 = load i8*, i8** %126, align 8, !tbaa !198
  %128 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 6
  %129 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 14
  %130 = load i8, i8* %129, align 1, !tbaa !297
  %131 = zext i8 %130 to i32
  %132 = tail call fastcc i8* @luaM_shrinkvector_(%struct.lua_State* %3, i8* %127, i32* nonnull %128, i32 %131, i32 16) #16
  store i8* %132, i8** %126, align 8, !tbaa !198
  %133 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 1
  %134 = bitcast %struct.FuncState** %133 to i64*
  %135 = load i64, i64* %134, align 8, !tbaa !271
  %136 = bitcast %struct.FuncState** %4 to i64*
  store i64 %135, i64* %136, align 8, !tbaa !273
  %137 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %3, i64 0, i32 7
  %138 = load %struct.global_State*, %struct.global_State** %137, align 8, !tbaa !2
  %139 = getelementptr inbounds %struct.global_State, %struct.global_State* %138, i64 0, i32 3
  %140 = load i64, i64* %139, align 8, !tbaa !11
  %141 = icmp sgt i64 %140, 0
  br i1 %141, label %142, label %143

; <label>:142:                                    ; preds = %84
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %3) #16
  br label %143

; <label>:143:                                    ; preds = %142, %84
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaK_code(%struct.FuncState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %4 = load %struct.Proto*, %struct.Proto** %3, align 8, !tbaa !253
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %6 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !272
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %6, i64 0, i32 6
  %8 = load %struct.lua_State*, %struct.lua_State** %7, align 8, !tbaa !261
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 16
  %10 = bitcast i32** %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !116
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %13 = load i32, i32* %12, align 8, !tbaa !274
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %4, i64 0, i32 8
  %15 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %8, i8* %11, i32 %13, i32* nonnull %14, i32 4, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0)) #16
  %16 = bitcast i8* %15 to i32*
  store i8* %15, i8** %10, align 8, !tbaa !116
  %17 = load i32, i32* %12, align 8, !tbaa !274
  %18 = add nsw i32 %17, 1
  store i32 %18, i32* %12, align 8, !tbaa !274
  %19 = sext i32 %17 to i64
  %20 = getelementptr inbounds i32, i32* %16, i64 %19
  store i32 %1, i32* %20, align 4, !tbaa !77
  %21 = load %struct.LexState*, %struct.LexState** %5, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 2
  %23 = load i32, i32* %22, align 8, !tbaa !266
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %4, i32 %23) #16
  %24 = load i32, i32* %12, align 8, !tbaa !274
  %25 = add nsw i32 %24, -1
  ret i32 %25
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaM_growaux_(%struct.lua_State*, i8*, i32, i32* nocapture, i32, i32, i8*) unnamed_addr #0 {
  %8 = load i32, i32* %3, align 4, !tbaa !77
  %9 = icmp sgt i32 %8, %2
  br i1 %9, label %31, label %10

; <label>:10:                                     ; preds = %7
  %11 = sdiv i32 %5, 2
  %12 = icmp slt i32 %8, %11
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %10
  %14 = icmp slt i32 %8, %5
  br i1 %14, label %20, label %15, !prof !73

; <label>:15:                                     ; preds = %13
  tail call void (%struct.lua_State*, i8*, ...) @luaG_runerror(%struct.lua_State* %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.223, i64 0, i64 0), i8* %6, i32 %5) #18
  unreachable

; <label>:16:                                     ; preds = %10
  %17 = shl nsw i32 %8, 1
  %18 = icmp sgt i32 %17, 4
  %19 = select i1 %18, i32 %17, i32 4
  br label %20

; <label>:20:                                     ; preds = %13, %16
  %21 = phi i32 [ %19, %16 ], [ %5, %13 ]
  %22 = sext i32 %8 to i64
  %23 = sext i32 %4 to i64
  %24 = mul nsw i64 %22, %23
  %25 = sext i32 %21 to i64
  %26 = mul nsw i64 %25, %23
  %27 = tail call fastcc i8* @luaM_realloc_(%struct.lua_State* %0, i8* %1, i64 %24, i64 %26) #16
  %28 = icmp eq i8* %27, null
  br i1 %28, label %29, label %30, !prof !61

; <label>:29:                                     ; preds = %20
  tail call fastcc void @luaD_throw(%struct.lua_State* %0, i32 4) #18
  unreachable

; <label>:30:                                     ; preds = %20
  store i32 %21, i32* %3, align 4, !tbaa !77
  br label %31

; <label>:31:                                     ; preds = %7, %30
  %32 = phi i8* [ %27, %30 ], [ %1, %7 ]
  ret i8* %32
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @savelineinfo(%struct.FuncState* nocapture, %struct.Proto* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %5 = load i32, i32* %4, align 8, !tbaa !275
  %6 = sub nsw i32 %2, %5
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %8 = load i32, i32* %7, align 8, !tbaa !274
  %9 = add nsw i32 %8, -1
  %10 = icmp sgt i32 %6, -1
  %11 = sub i32 0, %6
  %12 = select i1 %10, i32 %6, i32 %11
  %13 = icmp sgt i32 %12, 127
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  br i1 %13, label %22, label %15

; <label>:15:                                     ; preds = %3
  %16 = load i8, i8* %14, align 1, !tbaa !301
  %17 = add i8 %16, 1
  store i8 %17, i8* %14, align 1, !tbaa !301
  %18 = icmp ugt i8 %16, 120
  br i1 %18, label %22, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %21 = trunc i32 %6 to i8
  br label %40

; <label>:22:                                     ; preds = %3, %15
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %24 = load %struct.LexState*, %struct.LexState** %23, align 8, !tbaa !272
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %24, i64 0, i32 6
  %26 = load %struct.lua_State*, %struct.lua_State** %25, align 8, !tbaa !261
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 20
  %28 = bitcast %struct.AbsLineInfo** %27 to i8**
  %29 = load i8*, i8** %28, align 8, !tbaa !225
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %31 = load i32, i32* %30, align 4, !tbaa !278
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 12
  %33 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %26, i8* %29, i32 %31, i32* nonnull %32, i32 8, i32 2147483647, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i64 0, i64 0)) #16
  %34 = bitcast i8* %33 to %struct.AbsLineInfo*
  store i8* %33, i8** %28, align 8, !tbaa !225
  %35 = load i32, i32* %30, align 4, !tbaa !278
  %36 = sext i32 %35 to i64
  %37 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %34, i64 %36, i32 0
  store i32 %9, i32* %37, align 4, !tbaa !238
  %38 = add nsw i32 %35, 1
  store i32 %38, i32* %30, align 4, !tbaa !278
  %39 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %34, i64 %36, i32 1
  store i32 %2, i32* %39, align 4, !tbaa !296
  store i8 0, i8* %14, align 1, !tbaa !301
  br label %40

; <label>:40:                                     ; preds = %19, %22
  %41 = phi %struct.LexState** [ %20, %19 ], [ %23, %22 ]
  %42 = phi i8 [ %21, %19 ], [ -128, %22 ]
  %43 = load %struct.LexState*, %struct.LexState** %41, align 8, !tbaa !272
  %44 = getelementptr inbounds %struct.LexState, %struct.LexState* %43, i64 0, i32 6
  %45 = load %struct.lua_State*, %struct.lua_State** %44, align 8, !tbaa !261
  %46 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 19
  %47 = load i8*, i8** %46, align 8, !tbaa !137
  %48 = getelementptr inbounds %struct.Proto, %struct.Proto* %1, i64 0, i32 9
  %49 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %45, i8* %47, i32 %9, i32* nonnull %48, i32 1, i32 2147483647, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.222, i64 0, i64 0)) #16
  store i8* %49, i8** %46, align 8, !tbaa !137
  %50 = sext i32 %9 to i64
  %51 = getelementptr inbounds i8, i8* %49, i64 %50
  store i8 %42, i8* %51, align 1, !tbaa !21
  store i32 %2, i32* %4, align 8, !tbaa !275
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @errorlimit(%struct.FuncState* nocapture readonly, i32, i8*) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !261
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !253
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 13
  %11 = load i32, i32* %10, align 4, !tbaa !124
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %15, label %13

; <label>:13:                                     ; preds = %3
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.227, i64 0, i64 0), i32 %11) #16
  br label %15

; <label>:15:                                     ; preds = %3, %13
  %16 = phi i8* [ %14, %13 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.226, i64 0, i64 0), %3 ]
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %7, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.228, i64 0, i64 0), i8* %2, i32 %1, i8* %16) #16
  %18 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %18, i8* %17) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaX_syntaxerror(%struct.LexState* nocapture readonly, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !260
  tail call fastcc void @lexerror(%struct.LexState* %0, i8* %1, i32 %4) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @lexerror(%struct.LexState* nocapture readonly, i8*, i32) unnamed_addr #5 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !261
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %7 = load %struct.TString*, %struct.TString** %6, align 8, !tbaa !267
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  %10 = tail call fastcc i8* @luaG_addinfo(%struct.lua_State* %5, i8* %1, %struct.TString* %7, i32 %9) #16
  %11 = icmp eq i32 %2, 0
  br i1 %11, label %28, label %12

; <label>:12:                                     ; preds = %3
  %13 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !261
  %14 = add i32 %2, -290
  %15 = icmp ult i32 %14, 4
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %12
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 0) #17
  %17 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !261
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %19 = load %struct.Mbuffer*, %struct.Mbuffer** %18, align 8, !tbaa !255
  %20 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %19, i64 0, i32 0
  %21 = load i8*, i8** %20, align 8, !tbaa !269
  %22 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %17, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %21) #17
  br label %25

; <label>:23:                                     ; preds = %12
  %24 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %2) #17
  br label %25

; <label>:25:                                     ; preds = %16, %23
  %26 = phi i8* [ %22, %16 ], [ %24, %23 ]
  %27 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.229, i64 0, i64 0), i8* %10, i8* %26) #16
  br label %28

; <label>:28:                                     ; preds = %3, %25
  %29 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !261
  tail call fastcc void @luaD_throw(%struct.lua_State* %29, i32 3) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @save(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %4 = load %struct.Mbuffer*, %struct.Mbuffer** %3, align 8, !tbaa !255
  %5 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 1
  %6 = load i64, i64* %5, align 8, !tbaa !302
  %7 = add i64 %6, 1
  %8 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 2
  %9 = load i64, i64* %8, align 8, !tbaa !270
  %10 = icmp ugt i64 %7, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %13 = load i8*, i8** %12, align 8, !tbaa !269
  br label %26

; <label>:14:                                     ; preds = %2
  %15 = icmp ugt i64 %9, 4611686018427387902
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %14
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.231, i64 0, i64 0), i32 0) #18
  unreachable

; <label>:17:                                     ; preds = %14
  %18 = shl i64 %9, 1
  %19 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %20 = load %struct.lua_State*, %struct.lua_State** %19, align 8, !tbaa !261
  %21 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %4, i64 0, i32 0
  %22 = load i8*, i8** %21, align 8, !tbaa !269
  %23 = tail call fastcc i8* @luaM_saferealloc_(%struct.lua_State* %20, i8* %22, i64 %9, i64 %18) #16
  store i8* %23, i8** %21, align 8, !tbaa !269
  store i64 %18, i64* %8, align 8, !tbaa !270
  %24 = load i64, i64* %5, align 8, !tbaa !302
  %25 = add i64 %24, 1
  br label %26

; <label>:26:                                     ; preds = %11, %17
  %27 = phi i64 [ %7, %11 ], [ %25, %17 ]
  %28 = phi i64 [ %6, %11 ], [ %24, %17 ]
  %29 = phi i8* [ %13, %11 ], [ %23, %17 ]
  %30 = trunc i32 %1 to i8
  store i64 %27, i64* %5, align 8, !tbaa !302
  %31 = getelementptr inbounds i8, i8* %29, i64 %28
  store i8 %30, i8* %31, align 1, !tbaa !21
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaX_token2str(%struct.LexState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = icmp slt i32 %1, 257
  br i1 %3, label %4, label %15

; <label>:4:                                      ; preds = %2
  %5 = add nsw i32 %1, 1
  %6 = sext i32 %5 to i64
  %7 = add nsw i64 %6, -33
  %8 = icmp ult i64 %7, 95
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !261
  br i1 %8, label %11, label %13

; <label>:11:                                     ; preds = %4
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.232, i64 0, i64 0), i32 %1) #16
  br label %25

; <label>:13:                                     ; preds = %4
  %14 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %10, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.233, i64 0, i64 0), i32 %1) #16
  br label %25

; <label>:15:                                     ; preds = %2
  %16 = add nsw i32 %1, -257
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds [37 x i8*], [37 x i8*]* @luaX_tokens, i64 0, i64 %17
  %19 = load i8*, i8** %18, align 8, !tbaa !54
  %20 = icmp slt i32 %1, 289
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !261
  %24 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %23, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.230, i64 0, i64 0), i8* %19) #16
  br label %25

; <label>:25:                                     ; preds = %21, %15, %13, %11
  %26 = phi i8* [ %12, %11 ], [ %14, %13 ], [ %24, %21 ], [ %19, %15 ]
  ret i8* %26
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @llex(%struct.LexState*, %union.SemInfo*) unnamed_addr #0 {
  %3 = alloca [8 x i8], align 1
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %5 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %6 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %5, i64 0, i32 1
  store i64 0, i64* %6, align 8, !tbaa !302
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  br label %9

; <label>:9:                                      ; preds = %74, %2
  %10 = load i32, i32* %7, align 8, !tbaa !262
  switch i32 %10, label %575 [
    i32 10, label %11
    i32 13, label %11
    i32 32, label %12
    i32 12, label %12
    i32 9, label %12
    i32 11, label %12
    i32 45, label %28
    i32 91, label %93
    i32 61, label %100
    i32 60, label %119
    i32 62, label %141
    i32 47, label %163
    i32 126, label %182
    i32 58, label %201
    i32 34, label %220
    i32 39, label %220
    i32 46, label %543
    i32 48, label %573
    i32 49, label %573
    i32 50, label %573
    i32 51, label %573
    i32 52, label %573
    i32 53, label %573
    i32 54, label %573
    i32 55, label %573
    i32 56, label %573
    i32 57, label %573
    i32 -1, label %640
  ]

; <label>:11:                                     ; preds = %9, %9
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br label %74

; <label>:12:                                     ; preds = %9, %9, %9, %9
  %13 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !244
  %16 = add i64 %15, -1
  store i64 %16, i64* %14, align 8, !tbaa !244
  %17 = icmp eq i64 %15, 0
  br i1 %17, label %24, label %18

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.Zio, %struct.Zio* %13, i64 0, i32 1
  %20 = load i8*, i8** %19, align 8, !tbaa !245
  %21 = getelementptr inbounds i8, i8* %20, i64 1
  store i8* %21, i8** %19, align 8, !tbaa !245
  %22 = load i8, i8* %20, align 1, !tbaa !21
  %23 = zext i8 %22 to i32
  br label %26

; <label>:24:                                     ; preds = %12
  %25 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %13) #16
  br label %26

; <label>:26:                                     ; preds = %24, %18
  %27 = phi i32 [ %23, %18 ], [ %25, %24 ]
  store i32 %27, i32* %7, align 8, !tbaa !262
  br label %74

; <label>:28:                                     ; preds = %9
  %29 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %30 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 0
  %31 = load i64, i64* %30, align 8, !tbaa !244
  %32 = add i64 %31, -1
  store i64 %32, i64* %30, align 8, !tbaa !244
  %33 = icmp eq i64 %31, 0
  br i1 %33, label %40, label %34

; <label>:34:                                     ; preds = %28
  %35 = getelementptr inbounds %struct.Zio, %struct.Zio* %29, i64 0, i32 1
  %36 = load i8*, i8** %35, align 8, !tbaa !245
  %37 = getelementptr inbounds i8, i8* %36, i64 1
  store i8* %37, i8** %35, align 8, !tbaa !245
  %38 = load i8, i8* %36, align 1, !tbaa !21
  %39 = zext i8 %38 to i32
  br label %42

; <label>:40:                                     ; preds = %28
  %41 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %29) #16
  br label %42

; <label>:42:                                     ; preds = %40, %34
  %43 = phi i32 [ %39, %34 ], [ %41, %40 ]
  store i32 %43, i32* %7, align 8, !tbaa !262
  %44 = icmp eq i32 %43, 45
  br i1 %44, label %45, label %640

; <label>:45:                                     ; preds = %42
  %46 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %47 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 0
  %48 = load i64, i64* %47, align 8, !tbaa !244
  %49 = add i64 %48, -1
  store i64 %49, i64* %47, align 8, !tbaa !244
  %50 = icmp eq i64 %48, 0
  br i1 %50, label %57, label %51

; <label>:51:                                     ; preds = %45
  %52 = getelementptr inbounds %struct.Zio, %struct.Zio* %46, i64 0, i32 1
  %53 = load i8*, i8** %52, align 8, !tbaa !245
  %54 = getelementptr inbounds i8, i8* %53, i64 1
  store i8* %54, i8** %52, align 8, !tbaa !245
  %55 = load i8, i8* %53, align 1, !tbaa !21
  %56 = zext i8 %55 to i32
  br label %59

; <label>:57:                                     ; preds = %45
  %58 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %46) #16
  br label %59

; <label>:59:                                     ; preds = %57, %51
  %60 = phi i32 [ %56, %51 ], [ %58, %57 ]
  store i32 %60, i32* %7, align 8, !tbaa !262
  %61 = icmp eq i32 %60, 91
  br i1 %61, label %64, label %62

; <label>:62:                                     ; preds = %69, %59
  %63 = phi i32 [ %60, %59 ], [ %70, %69 ]
  br label %75

; <label>:64:                                     ; preds = %59
  %65 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %66 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %67 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %66, i64 0, i32 1
  store i64 0, i64* %67, align 8, !tbaa !302
  %68 = icmp ugt i64 %65, 1
  br i1 %68, label %71, label %69

; <label>:69:                                     ; preds = %64
  %70 = load i32, i32* %7, align 8, !tbaa !262
  br label %62

; <label>:71:                                     ; preds = %64
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* null, i64 %65) #16
  %72 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %73 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %72, i64 0, i32 1
  store i64 0, i64* %73, align 8, !tbaa !302
  br label %74

; <label>:74:                                     ; preds = %75, %75, %75, %71, %26, %11
  br label %9

; <label>:75:                                     ; preds = %62, %91
  %76 = phi i32 [ %92, %91 ], [ %63, %62 ]
  switch i32 %76, label %77 [
    i32 10, label %74
    i32 13, label %74
    i32 -1, label %74
  ]

; <label>:77:                                     ; preds = %75
  %78 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %79 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 0
  %80 = load i64, i64* %79, align 8, !tbaa !244
  %81 = add i64 %80, -1
  store i64 %81, i64* %79, align 8, !tbaa !244
  %82 = icmp eq i64 %80, 0
  br i1 %82, label %89, label %83

; <label>:83:                                     ; preds = %77
  %84 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 1
  %85 = load i8*, i8** %84, align 8, !tbaa !245
  %86 = getelementptr inbounds i8, i8* %85, i64 1
  store i8* %86, i8** %84, align 8, !tbaa !245
  %87 = load i8, i8* %85, align 1, !tbaa !21
  %88 = zext i8 %87 to i32
  br label %91

; <label>:89:                                     ; preds = %77
  %90 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %78) #16
  br label %91

; <label>:91:                                     ; preds = %89, %83
  %92 = phi i32 [ %88, %83 ], [ %90, %89 ]
  store i32 %92, i32* %7, align 8, !tbaa !262
  br label %75

; <label>:93:                                     ; preds = %9
  %94 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %95 = icmp ugt i64 %94, 1
  br i1 %95, label %96, label %97

; <label>:96:                                     ; preds = %93
  tail call fastcc void @read_long_string(%struct.LexState* nonnull %0, %union.SemInfo* %1, i64 %94) #16
  br label %640

; <label>:97:                                     ; preds = %93
  %98 = icmp eq i64 %94, 0
  br i1 %98, label %99, label %640

; <label>:99:                                     ; preds = %97
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.234, i64 0, i64 0), i32 293) #18
  unreachable

; <label>:100:                                    ; preds = %9
  %101 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %102 = getelementptr inbounds %struct.Zio, %struct.Zio* %101, i64 0, i32 0
  %103 = load i64, i64* %102, align 8, !tbaa !244
  %104 = add i64 %103, -1
  store i64 %104, i64* %102, align 8, !tbaa !244
  %105 = icmp eq i64 %103, 0
  br i1 %105, label %112, label %106

; <label>:106:                                    ; preds = %100
  %107 = getelementptr inbounds %struct.Zio, %struct.Zio* %101, i64 0, i32 1
  %108 = load i8*, i8** %107, align 8, !tbaa !245
  %109 = getelementptr inbounds i8, i8* %108, i64 1
  store i8* %109, i8** %107, align 8, !tbaa !245
  %110 = load i8, i8* %108, align 1, !tbaa !21
  %111 = zext i8 %110 to i32
  br label %114

; <label>:112:                                    ; preds = %100
  %113 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %101) #16
  br label %114

; <label>:114:                                    ; preds = %112, %106
  %115 = phi i32 [ %111, %106 ], [ %113, %112 ]
  store i32 %115, i32* %7, align 8, !tbaa !262
  %116 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %117 = icmp eq i32 %116, 0
  %118 = select i1 %117, i32 61, i32 282
  br label %640

; <label>:119:                                    ; preds = %9
  %120 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %121 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 0
  %122 = load i64, i64* %121, align 8, !tbaa !244
  %123 = add i64 %122, -1
  store i64 %123, i64* %121, align 8, !tbaa !244
  %124 = icmp eq i64 %122, 0
  br i1 %124, label %131, label %125

; <label>:125:                                    ; preds = %119
  %126 = getelementptr inbounds %struct.Zio, %struct.Zio* %120, i64 0, i32 1
  %127 = load i8*, i8** %126, align 8, !tbaa !245
  %128 = getelementptr inbounds i8, i8* %127, i64 1
  store i8* %128, i8** %126, align 8, !tbaa !245
  %129 = load i8, i8* %127, align 1, !tbaa !21
  %130 = zext i8 %129 to i32
  br label %133

; <label>:131:                                    ; preds = %119
  %132 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %120) #16
  br label %133

; <label>:133:                                    ; preds = %131, %125
  %134 = phi i32 [ %130, %125 ], [ %132, %131 ]
  store i32 %134, i32* %7, align 8, !tbaa !262
  %135 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %136 = icmp eq i32 %135, 0
  br i1 %136, label %137, label %640

; <label>:137:                                    ; preds = %133
  %138 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 60) #16
  %139 = icmp eq i32 %138, 0
  %140 = select i1 %139, i32 60, i32 286
  br label %640

; <label>:141:                                    ; preds = %9
  %142 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %143 = getelementptr inbounds %struct.Zio, %struct.Zio* %142, i64 0, i32 0
  %144 = load i64, i64* %143, align 8, !tbaa !244
  %145 = add i64 %144, -1
  store i64 %145, i64* %143, align 8, !tbaa !244
  %146 = icmp eq i64 %144, 0
  br i1 %146, label %153, label %147

; <label>:147:                                    ; preds = %141
  %148 = getelementptr inbounds %struct.Zio, %struct.Zio* %142, i64 0, i32 1
  %149 = load i8*, i8** %148, align 8, !tbaa !245
  %150 = getelementptr inbounds i8, i8* %149, i64 1
  store i8* %150, i8** %148, align 8, !tbaa !245
  %151 = load i8, i8* %149, align 1, !tbaa !21
  %152 = zext i8 %151 to i32
  br label %155

; <label>:153:                                    ; preds = %141
  %154 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %142) #16
  br label %155

; <label>:155:                                    ; preds = %153, %147
  %156 = phi i32 [ %152, %147 ], [ %154, %153 ]
  store i32 %156, i32* %7, align 8, !tbaa !262
  %157 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %158 = icmp eq i32 %157, 0
  br i1 %158, label %159, label %640

; <label>:159:                                    ; preds = %155
  %160 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 62) #16
  %161 = icmp eq i32 %160, 0
  %162 = select i1 %161, i32 62, i32 287
  br label %640

; <label>:163:                                    ; preds = %9
  %164 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %165 = getelementptr inbounds %struct.Zio, %struct.Zio* %164, i64 0, i32 0
  %166 = load i64, i64* %165, align 8, !tbaa !244
  %167 = add i64 %166, -1
  store i64 %167, i64* %165, align 8, !tbaa !244
  %168 = icmp eq i64 %166, 0
  br i1 %168, label %175, label %169

; <label>:169:                                    ; preds = %163
  %170 = getelementptr inbounds %struct.Zio, %struct.Zio* %164, i64 0, i32 1
  %171 = load i8*, i8** %170, align 8, !tbaa !245
  %172 = getelementptr inbounds i8, i8* %171, i64 1
  store i8* %172, i8** %170, align 8, !tbaa !245
  %173 = load i8, i8* %171, align 1, !tbaa !21
  %174 = zext i8 %173 to i32
  br label %177

; <label>:175:                                    ; preds = %163
  %176 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %164) #16
  br label %177

; <label>:177:                                    ; preds = %175, %169
  %178 = phi i32 [ %174, %169 ], [ %176, %175 ]
  store i32 %178, i32* %7, align 8, !tbaa !262
  %179 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 47) #16
  %180 = icmp eq i32 %179, 0
  %181 = select i1 %180, i32 47, i32 279
  br label %640

; <label>:182:                                    ; preds = %9
  %183 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %184 = getelementptr inbounds %struct.Zio, %struct.Zio* %183, i64 0, i32 0
  %185 = load i64, i64* %184, align 8, !tbaa !244
  %186 = add i64 %185, -1
  store i64 %186, i64* %184, align 8, !tbaa !244
  %187 = icmp eq i64 %185, 0
  br i1 %187, label %194, label %188

; <label>:188:                                    ; preds = %182
  %189 = getelementptr inbounds %struct.Zio, %struct.Zio* %183, i64 0, i32 1
  %190 = load i8*, i8** %189, align 8, !tbaa !245
  %191 = getelementptr inbounds i8, i8* %190, i64 1
  store i8* %191, i8** %189, align 8, !tbaa !245
  %192 = load i8, i8* %190, align 1, !tbaa !21
  %193 = zext i8 %192 to i32
  br label %196

; <label>:194:                                    ; preds = %182
  %195 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %183) #16
  br label %196

; <label>:196:                                    ; preds = %194, %188
  %197 = phi i32 [ %193, %188 ], [ %195, %194 ]
  store i32 %197, i32* %7, align 8, !tbaa !262
  %198 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 61) #16
  %199 = icmp eq i32 %198, 0
  %200 = select i1 %199, i32 126, i32 285
  br label %640

; <label>:201:                                    ; preds = %9
  %202 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %203 = getelementptr inbounds %struct.Zio, %struct.Zio* %202, i64 0, i32 0
  %204 = load i64, i64* %203, align 8, !tbaa !244
  %205 = add i64 %204, -1
  store i64 %205, i64* %203, align 8, !tbaa !244
  %206 = icmp eq i64 %204, 0
  br i1 %206, label %213, label %207

; <label>:207:                                    ; preds = %201
  %208 = getelementptr inbounds %struct.Zio, %struct.Zio* %202, i64 0, i32 1
  %209 = load i8*, i8** %208, align 8, !tbaa !245
  %210 = getelementptr inbounds i8, i8* %209, i64 1
  store i8* %210, i8** %208, align 8, !tbaa !245
  %211 = load i8, i8* %209, align 1, !tbaa !21
  %212 = zext i8 %211 to i32
  br label %215

; <label>:213:                                    ; preds = %201
  %214 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %202) #16
  br label %215

; <label>:215:                                    ; preds = %213, %207
  %216 = phi i32 [ %212, %207 ], [ %214, %213 ]
  store i32 %216, i32* %7, align 8, !tbaa !262
  %217 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 58) #16
  %218 = icmp eq i32 %217, 0
  %219 = select i1 %218, i32 58, i32 288
  br label %640

; <label>:220:                                    ; preds = %9, %9
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %10) #17
  %221 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %222 = getelementptr inbounds %struct.Zio, %struct.Zio* %221, i64 0, i32 0
  %223 = load i64, i64* %222, align 8, !tbaa !244
  %224 = add i64 %223, -1
  store i64 %224, i64* %222, align 8, !tbaa !244
  %225 = icmp eq i64 %223, 0
  br i1 %225, label %232, label %226

; <label>:226:                                    ; preds = %220
  %227 = getelementptr inbounds %struct.Zio, %struct.Zio* %221, i64 0, i32 1
  %228 = load i8*, i8** %227, align 8, !tbaa !245
  %229 = getelementptr inbounds i8, i8* %228, i64 1
  store i8* %229, i8** %227, align 8, !tbaa !245
  %230 = load i8, i8* %228, align 1, !tbaa !21
  %231 = zext i8 %230 to i32
  br label %234

; <label>:232:                                    ; preds = %220
  %233 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %221) #17
  br label %234

; <label>:234:                                    ; preds = %232, %226
  %235 = phi i32 [ %231, %226 ], [ %233, %232 ]
  store i32 %235, i32* %7, align 8, !tbaa !262
  %236 = icmp eq i32 %235, %10
  br i1 %236, label %518, label %237

; <label>:237:                                    ; preds = %234
  %238 = getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 0
  br label %239

; <label>:239:                                    ; preds = %515, %237
  %240 = phi i32 [ %235, %237 ], [ %516, %515 ]
  switch i32 %240, label %499 [
    i32 -1, label %241
    i32 10, label %242
    i32 13, label %242
    i32 92, label %243
  ]

; <label>:241:                                    ; preds = %239
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 289) #19
  unreachable

; <label>:242:                                    ; preds = %239, %239
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.238, i64 0, i64 0), i32 293) #19
  unreachable

; <label>:243:                                    ; preds = %239
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 92) #17
  %244 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %245 = getelementptr inbounds %struct.Zio, %struct.Zio* %244, i64 0, i32 0
  %246 = load i64, i64* %245, align 8, !tbaa !244
  %247 = add i64 %246, -1
  store i64 %247, i64* %245, align 8, !tbaa !244
  %248 = icmp eq i64 %246, 0
  br i1 %248, label %255, label %249

; <label>:249:                                    ; preds = %243
  %250 = getelementptr inbounds %struct.Zio, %struct.Zio* %244, i64 0, i32 1
  %251 = load i8*, i8** %250, align 8, !tbaa !245
  %252 = getelementptr inbounds i8, i8* %251, i64 1
  store i8* %252, i8** %250, align 8, !tbaa !245
  %253 = load i8, i8* %251, align 1, !tbaa !21
  %254 = zext i8 %253 to i32
  br label %257

; <label>:255:                                    ; preds = %243
  %256 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %244) #17
  br label %257

; <label>:257:                                    ; preds = %255, %249
  %258 = phi i32 [ %254, %249 ], [ %256, %255 ]
  store i32 %258, i32* %7, align 8, !tbaa !262
  switch i32 %258, label %429 [
    i32 97, label %476
    i32 98, label %259
    i32 102, label %260
    i32 110, label %261
    i32 114, label %262
    i32 116, label %263
    i32 118, label %264
    i32 120, label %265
    i32 117, label %274
    i32 10, label %372
    i32 13, label %372
    i32 92, label %373
    i32 34, label %373
    i32 39, label %373
    i32 -1, label %515
    i32 122, label %374
  ]

; <label>:259:                                    ; preds = %257
  br label %476

; <label>:260:                                    ; preds = %257
  br label %476

; <label>:261:                                    ; preds = %257
  br label %476

; <label>:262:                                    ; preds = %257
  br label %476

; <label>:263:                                    ; preds = %257
  br label %476

; <label>:264:                                    ; preds = %257
  br label %476

; <label>:265:                                    ; preds = %257
  %266 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %267 = shl i32 %266, 4
  %268 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %269 = add nsw i32 %267, %268
  %270 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %271 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %270, i64 0, i32 1
  %272 = load i64, i64* %271, align 8, !tbaa !302
  %273 = add i64 %272, -2
  store i64 %273, i64* %271, align 8, !tbaa !302
  br label %476

; <label>:274:                                    ; preds = %257
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %238) #7
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 117) #17
  %275 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %276 = getelementptr inbounds %struct.Zio, %struct.Zio* %275, i64 0, i32 0
  %277 = load i64, i64* %276, align 8, !tbaa !244
  %278 = add i64 %277, -1
  store i64 %278, i64* %276, align 8, !tbaa !244
  %279 = icmp eq i64 %277, 0
  br i1 %279, label %286, label %280

; <label>:280:                                    ; preds = %274
  %281 = getelementptr inbounds %struct.Zio, %struct.Zio* %275, i64 0, i32 1
  %282 = load i8*, i8** %281, align 8, !tbaa !245
  %283 = getelementptr inbounds i8, i8* %282, i64 1
  store i8* %283, i8** %281, align 8, !tbaa !245
  %284 = load i8, i8* %282, align 1, !tbaa !21
  %285 = zext i8 %284 to i32
  br label %288

; <label>:286:                                    ; preds = %274
  %287 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %275) #17
  br label %288

; <label>:288:                                    ; preds = %286, %280
  %289 = phi i32 [ %285, %280 ], [ %287, %286 ]
  store i32 %289, i32* %7, align 8, !tbaa !262
  %290 = icmp eq i32 %289, 123
  %291 = zext i1 %290 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %291, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.241, i64 0, i64 0)) #17
  %292 = tail call fastcc i32 @gethexa(%struct.LexState* nonnull %0) #17
  %293 = sext i32 %292 to i64
  %294 = load i32, i32* %7, align 8, !tbaa !262
  br label %295

; <label>:295:                                    ; preds = %320, %288
  %296 = phi i32 [ %294, %288 ], [ %325, %320 ]
  %297 = phi i64 [ %293, %288 ], [ %335, %320 ]
  %298 = phi i32 [ 4, %288 ], [ %321, %320 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %296) #17
  %299 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %300 = getelementptr inbounds %struct.Zio, %struct.Zio* %299, i64 0, i32 0
  %301 = load i64, i64* %300, align 8, !tbaa !244
  %302 = add i64 %301, -1
  store i64 %302, i64* %300, align 8, !tbaa !244
  %303 = icmp eq i64 %301, 0
  br i1 %303, label %310, label %304

; <label>:304:                                    ; preds = %295
  %305 = getelementptr inbounds %struct.Zio, %struct.Zio* %299, i64 0, i32 1
  %306 = load i8*, i8** %305, align 8, !tbaa !245
  %307 = getelementptr inbounds i8, i8* %306, i64 1
  store i8* %307, i8** %305, align 8, !tbaa !245
  %308 = load i8, i8* %306, align 1, !tbaa !21
  %309 = zext i8 %308 to i32
  br label %312

; <label>:310:                                    ; preds = %295
  %311 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %299) #17
  br label %312

; <label>:312:                                    ; preds = %310, %304
  %313 = phi i32 [ %309, %304 ], [ %311, %310 ]
  store i32 %313, i32* %7, align 8, !tbaa !262
  %314 = add nsw i32 %313, 1
  %315 = sext i32 %314 to i64
  %316 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %315
  %317 = load i8, i8* %316, align 1, !tbaa !21
  %318 = and i8 %317, 16
  %319 = icmp eq i8 %318, 0
  br i1 %319, label %336, label %320

; <label>:320:                                    ; preds = %312
  %321 = add nuw nsw i32 %298, 1
  %322 = icmp ult i64 %297, 134217728
  %323 = zext i1 %322 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %323, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.242, i64 0, i64 0)) #17
  %324 = shl i64 %297, 4
  %325 = load i32, i32* %7, align 8, !tbaa !262
  %326 = add nsw i32 %325, 1
  %327 = sext i32 %326 to i64
  %328 = add nsw i64 %327, -49
  %329 = icmp ult i64 %328, 10
  %330 = add nsw i32 %325, -48
  %331 = or i32 %325, 32
  %332 = add nsw i32 %331, -87
  %333 = select i1 %329, i32 %330, i32 %332
  %334 = sext i32 %333 to i64
  %335 = add i64 %324, %334
  br label %295

; <label>:336:                                    ; preds = %312
  %337 = icmp eq i32 %313, 125
  %338 = zext i1 %337 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %338, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.243, i64 0, i64 0)) #17
  %339 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %340 = getelementptr inbounds %struct.Zio, %struct.Zio* %339, i64 0, i32 0
  %341 = load i64, i64* %340, align 8, !tbaa !244
  %342 = add i64 %341, -1
  store i64 %342, i64* %340, align 8, !tbaa !244
  %343 = icmp eq i64 %341, 0
  br i1 %343, label %350, label %344

; <label>:344:                                    ; preds = %336
  %345 = getelementptr inbounds %struct.Zio, %struct.Zio* %339, i64 0, i32 1
  %346 = load i8*, i8** %345, align 8, !tbaa !245
  %347 = getelementptr inbounds i8, i8* %346, i64 1
  store i8* %347, i8** %345, align 8, !tbaa !245
  %348 = load i8, i8* %346, align 1, !tbaa !21
  %349 = zext i8 %348 to i32
  br label %352

; <label>:350:                                    ; preds = %336
  %351 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %339) #17
  br label %352

; <label>:352:                                    ; preds = %350, %344
  %353 = phi i32 [ %349, %344 ], [ %351, %350 ]
  store i32 %353, i32* %7, align 8, !tbaa !262
  %354 = zext i32 %298 to i64
  %355 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %356 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %355, i64 0, i32 1
  %357 = load i64, i64* %356, align 8, !tbaa !302
  %358 = sub i64 %357, %354
  store i64 %358, i64* %356, align 8, !tbaa !302
  %359 = call fastcc i32 @luaO_utf8esc(i8* nonnull %238, i64 %297) #17
  %360 = icmp sgt i32 %359, 0
  br i1 %360, label %361, label %371

; <label>:361:                                    ; preds = %352
  %362 = sext i32 %359 to i64
  br label %363

; <label>:363:                                    ; preds = %363, %361
  %364 = phi i64 [ %362, %361 ], [ %369, %363 ]
  %365 = sub nsw i64 8, %364
  %366 = getelementptr inbounds [8 x i8], [8 x i8]* %3, i64 0, i64 %365
  %367 = load i8, i8* %366, align 1, !tbaa !21
  %368 = sext i8 %367 to i32
  tail call fastcc void @save(%struct.LexState* %0, i32 %368) #17
  %369 = add nsw i64 %364, -1
  %370 = icmp sgt i64 %364, 1
  br i1 %370, label %363, label %371

; <label>:371:                                    ; preds = %363, %352
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %238) #7
  br label %515

; <label>:372:                                    ; preds = %257, %257
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #17
  br label %493

; <label>:373:                                    ; preds = %257, %257, %257
  br label %476

; <label>:374:                                    ; preds = %257
  %375 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %376 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %375, i64 0, i32 1
  %377 = load i64, i64* %376, align 8, !tbaa !302
  %378 = add i64 %377, -1
  store i64 %378, i64* %376, align 8, !tbaa !302
  %379 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %380 = getelementptr inbounds %struct.Zio, %struct.Zio* %379, i64 0, i32 0
  %381 = load i64, i64* %380, align 8, !tbaa !244
  %382 = add i64 %381, -1
  store i64 %382, i64* %380, align 8, !tbaa !244
  %383 = icmp eq i64 %381, 0
  br i1 %383, label %390, label %384

; <label>:384:                                    ; preds = %374
  %385 = getelementptr inbounds %struct.Zio, %struct.Zio* %379, i64 0, i32 1
  %386 = load i8*, i8** %385, align 8, !tbaa !245
  %387 = getelementptr inbounds i8, i8* %386, i64 1
  store i8* %387, i8** %385, align 8, !tbaa !245
  %388 = load i8, i8* %386, align 1, !tbaa !21
  %389 = zext i8 %388 to i32
  br label %392

; <label>:390:                                    ; preds = %374
  %391 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %379) #17
  br label %392

; <label>:392:                                    ; preds = %390, %384
  %393 = phi i32 [ %389, %384 ], [ %391, %390 ]
  store i32 %393, i32* %7, align 8, !tbaa !262
  %394 = add nsw i32 %393, 1
  %395 = sext i32 %394 to i64
  %396 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %395
  %397 = load i8, i8* %396, align 1, !tbaa !21
  %398 = and i8 %397, 8
  %399 = icmp eq i8 %398, 0
  br i1 %399, label %515, label %400

; <label>:400:                                    ; preds = %392
  br label %401

; <label>:401:                                    ; preds = %400, %421
  %402 = phi i32 [ %422, %421 ], [ %393, %400 ]
  switch i32 %402, label %405 [
    i32 10, label %403
    i32 13, label %403
  ]

; <label>:403:                                    ; preds = %401, %401
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #17
  %404 = load i32, i32* %7, align 8, !tbaa !262
  br label %421

; <label>:405:                                    ; preds = %401
  %406 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %407 = getelementptr inbounds %struct.Zio, %struct.Zio* %406, i64 0, i32 0
  %408 = load i64, i64* %407, align 8, !tbaa !244
  %409 = add i64 %408, -1
  store i64 %409, i64* %407, align 8, !tbaa !244
  %410 = icmp eq i64 %408, 0
  br i1 %410, label %417, label %411

; <label>:411:                                    ; preds = %405
  %412 = getelementptr inbounds %struct.Zio, %struct.Zio* %406, i64 0, i32 1
  %413 = load i8*, i8** %412, align 8, !tbaa !245
  %414 = getelementptr inbounds i8, i8* %413, i64 1
  store i8* %414, i8** %412, align 8, !tbaa !245
  %415 = load i8, i8* %413, align 1, !tbaa !21
  %416 = zext i8 %415 to i32
  br label %419

; <label>:417:                                    ; preds = %405
  %418 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %406) #17
  br label %419

; <label>:419:                                    ; preds = %417, %411
  %420 = phi i32 [ %416, %411 ], [ %418, %417 ]
  store i32 %420, i32* %7, align 8, !tbaa !262
  br label %421

; <label>:421:                                    ; preds = %419, %403
  %422 = phi i32 [ %420, %419 ], [ %404, %403 ]
  %423 = add nsw i32 %422, 1
  %424 = sext i32 %423 to i64
  %425 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %424
  %426 = load i8, i8* %425, align 1, !tbaa !21
  %427 = and i8 %426, 8
  %428 = icmp eq i8 %427, 0
  br i1 %428, label %515, label %401

; <label>:429:                                    ; preds = %257
  %430 = add nsw i32 %258, 1
  %431 = sext i32 %430 to i64
  %432 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %431
  %433 = load i8, i8* %432, align 1, !tbaa !21
  %434 = and i8 %433, 2
  %435 = zext i8 %434 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %435, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.239, i64 0, i64 0)) #17
  %436 = load i32, i32* %7, align 8, !tbaa !262
  br label %437

; <label>:437:                                    ; preds = %462, %429
  %438 = phi i32 [ %436, %429 ], [ %463, %462 ]
  %439 = phi i32 [ 0, %429 ], [ %448, %462 ]
  %440 = phi i32 [ 0, %429 ], [ %464, %462 ]
  %441 = add nsw i32 %438, 1
  %442 = sext i32 %441 to i64
  %443 = add nsw i64 %442, -49
  %444 = icmp ult i64 %443, 10
  br i1 %444, label %445, label %466

; <label>:445:                                    ; preds = %437
  %446 = mul nsw i32 %439, 10
  %447 = add i32 %438, -48
  %448 = add i32 %447, %446
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %438) #17
  %449 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %450 = getelementptr inbounds %struct.Zio, %struct.Zio* %449, i64 0, i32 0
  %451 = load i64, i64* %450, align 8, !tbaa !244
  %452 = add i64 %451, -1
  store i64 %452, i64* %450, align 8, !tbaa !244
  %453 = icmp eq i64 %451, 0
  br i1 %453, label %460, label %454

; <label>:454:                                    ; preds = %445
  %455 = getelementptr inbounds %struct.Zio, %struct.Zio* %449, i64 0, i32 1
  %456 = load i8*, i8** %455, align 8, !tbaa !245
  %457 = getelementptr inbounds i8, i8* %456, i64 1
  store i8* %457, i8** %455, align 8, !tbaa !245
  %458 = load i8, i8* %456, align 1, !tbaa !21
  %459 = zext i8 %458 to i32
  br label %462

; <label>:460:                                    ; preds = %445
  %461 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %449) #17
  br label %462

; <label>:462:                                    ; preds = %460, %454
  %463 = phi i32 [ %459, %454 ], [ %461, %460 ]
  store i32 %463, i32* %7, align 8, !tbaa !262
  %464 = add nuw nsw i32 %440, 1
  %465 = icmp ult i32 %464, 3
  br i1 %465, label %437, label %466

; <label>:466:                                    ; preds = %462, %437
  %467 = phi i32 [ 3, %462 ], [ %440, %437 ]
  %468 = phi i32 [ %448, %462 ], [ %439, %437 ]
  %469 = icmp slt i32 %468, 256
  %470 = zext i1 %469 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %470, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.244, i64 0, i64 0)) #17
  %471 = zext i32 %467 to i64
  %472 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %473 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %472, i64 0, i32 1
  %474 = load i64, i64* %473, align 8, !tbaa !302
  %475 = sub i64 %474, %471
  store i64 %475, i64* %473, align 8, !tbaa !302
  br label %493

; <label>:476:                                    ; preds = %373, %265, %264, %263, %262, %261, %260, %259, %257
  %477 = phi i32 [ %258, %373 ], [ %269, %265 ], [ 11, %264 ], [ 9, %263 ], [ 13, %262 ], [ 10, %261 ], [ 12, %260 ], [ 8, %259 ], [ 7, %257 ]
  %478 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %479 = getelementptr inbounds %struct.Zio, %struct.Zio* %478, i64 0, i32 0
  %480 = load i64, i64* %479, align 8, !tbaa !244
  %481 = add i64 %480, -1
  store i64 %481, i64* %479, align 8, !tbaa !244
  %482 = icmp eq i64 %480, 0
  br i1 %482, label %489, label %483

; <label>:483:                                    ; preds = %476
  %484 = getelementptr inbounds %struct.Zio, %struct.Zio* %478, i64 0, i32 1
  %485 = load i8*, i8** %484, align 8, !tbaa !245
  %486 = getelementptr inbounds i8, i8* %485, i64 1
  store i8* %486, i8** %484, align 8, !tbaa !245
  %487 = load i8, i8* %485, align 1, !tbaa !21
  %488 = zext i8 %487 to i32
  br label %491

; <label>:489:                                    ; preds = %476
  %490 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %478) #17
  br label %491

; <label>:491:                                    ; preds = %489, %483
  %492 = phi i32 [ %488, %483 ], [ %490, %489 ]
  store i32 %492, i32* %7, align 8, !tbaa !262
  br label %493

; <label>:493:                                    ; preds = %491, %466, %372
  %494 = phi i32 [ %468, %466 ], [ %477, %491 ], [ 10, %372 ]
  %495 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %496 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %495, i64 0, i32 1
  %497 = load i64, i64* %496, align 8, !tbaa !302
  %498 = add i64 %497, -1
  store i64 %498, i64* %496, align 8, !tbaa !302
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %494) #17
  br label %515

; <label>:499:                                    ; preds = %239
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %240) #17
  %500 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %501 = getelementptr inbounds %struct.Zio, %struct.Zio* %500, i64 0, i32 0
  %502 = load i64, i64* %501, align 8, !tbaa !244
  %503 = add i64 %502, -1
  store i64 %503, i64* %501, align 8, !tbaa !244
  %504 = icmp eq i64 %502, 0
  br i1 %504, label %511, label %505

; <label>:505:                                    ; preds = %499
  %506 = getelementptr inbounds %struct.Zio, %struct.Zio* %500, i64 0, i32 1
  %507 = load i8*, i8** %506, align 8, !tbaa !245
  %508 = getelementptr inbounds i8, i8* %507, i64 1
  store i8* %508, i8** %506, align 8, !tbaa !245
  %509 = load i8, i8* %507, align 1, !tbaa !21
  %510 = zext i8 %509 to i32
  br label %513

; <label>:511:                                    ; preds = %499
  %512 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %500) #17
  br label %513

; <label>:513:                                    ; preds = %511, %505
  %514 = phi i32 [ %510, %505 ], [ %512, %511 ]
  store i32 %514, i32* %7, align 8, !tbaa !262
  br label %515

; <label>:515:                                    ; preds = %421, %513, %493, %392, %371, %257
  %516 = load i32, i32* %7, align 8, !tbaa !262
  %517 = icmp eq i32 %516, %10
  br i1 %517, label %518, label %239

; <label>:518:                                    ; preds = %515, %234
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %10) #17
  %519 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %520 = getelementptr inbounds %struct.Zio, %struct.Zio* %519, i64 0, i32 0
  %521 = load i64, i64* %520, align 8, !tbaa !244
  %522 = add i64 %521, -1
  store i64 %522, i64* %520, align 8, !tbaa !244
  %523 = icmp eq i64 %521, 0
  br i1 %523, label %530, label %524

; <label>:524:                                    ; preds = %518
  %525 = getelementptr inbounds %struct.Zio, %struct.Zio* %519, i64 0, i32 1
  %526 = load i8*, i8** %525, align 8, !tbaa !245
  %527 = getelementptr inbounds i8, i8* %526, i64 1
  store i8* %527, i8** %525, align 8, !tbaa !245
  %528 = load i8, i8* %526, align 1, !tbaa !21
  %529 = zext i8 %528 to i32
  br label %532

; <label>:530:                                    ; preds = %518
  %531 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %519) #17
  br label %532

; <label>:532:                                    ; preds = %524, %530
  %533 = phi i32 [ %529, %524 ], [ %531, %530 ]
  store i32 %533, i32* %7, align 8, !tbaa !262
  %534 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %535 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %534, i64 0, i32 0
  %536 = load i8*, i8** %535, align 8, !tbaa !269
  %537 = getelementptr inbounds i8, i8* %536, i64 1
  %538 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %534, i64 0, i32 1
  %539 = load i64, i64* %538, align 8, !tbaa !302
  %540 = add i64 %539, -2
  %541 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* nonnull %537, i64 %540) #17
  %542 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %541, %struct.TString** %542, align 8, !tbaa !21
  br label %640

; <label>:543:                                    ; preds = %9
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 46) #16
  %544 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %545 = getelementptr inbounds %struct.Zio, %struct.Zio* %544, i64 0, i32 0
  %546 = load i64, i64* %545, align 8, !tbaa !244
  %547 = add i64 %546, -1
  store i64 %547, i64* %545, align 8, !tbaa !244
  %548 = icmp eq i64 %546, 0
  br i1 %548, label %555, label %549

; <label>:549:                                    ; preds = %543
  %550 = getelementptr inbounds %struct.Zio, %struct.Zio* %544, i64 0, i32 1
  %551 = load i8*, i8** %550, align 8, !tbaa !245
  %552 = getelementptr inbounds i8, i8* %551, i64 1
  store i8* %552, i8** %550, align 8, !tbaa !245
  %553 = load i8, i8* %551, align 1, !tbaa !21
  %554 = zext i8 %553 to i32
  br label %557

; <label>:555:                                    ; preds = %543
  %556 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %544) #16
  br label %557

; <label>:557:                                    ; preds = %555, %549
  %558 = phi i32 [ %554, %549 ], [ %556, %555 ]
  store i32 %558, i32* %7, align 8, !tbaa !262
  %559 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46) #16
  %560 = icmp eq i32 %559, 0
  br i1 %560, label %565, label %561

; <label>:561:                                    ; preds = %557
  %562 = tail call fastcc i32 @check_next1(%struct.LexState* nonnull %0, i32 46) #16
  %563 = icmp eq i32 %562, 0
  %564 = select i1 %563, i32 280, i32 281
  br label %640

; <label>:565:                                    ; preds = %557
  %566 = load i32, i32* %7, align 8, !tbaa !262
  %567 = add nsw i32 %566, 1
  %568 = sext i32 %567 to i64
  %569 = add nsw i64 %568, -49
  %570 = icmp ult i64 %569, 10
  br i1 %570, label %571, label %640

; <label>:571:                                    ; preds = %565
  %572 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1) #16
  br label %640

; <label>:573:                                    ; preds = %9, %9, %9, %9, %9, %9, %9, %9, %9, %9
  %574 = tail call fastcc i32 @read_numeral(%struct.LexState* nonnull %0, %union.SemInfo* %1) #16
  br label %640

; <label>:575:                                    ; preds = %9
  %576 = add nsw i32 %10, 1
  %577 = sext i32 %576 to i64
  %578 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %577
  %579 = load i8, i8* %578, align 1, !tbaa !21
  %580 = and i8 %579, 1
  %581 = icmp eq i8 %580, 0
  br i1 %581, label %624, label %582

; <label>:582:                                    ; preds = %575
  br label %583

; <label>:583:                                    ; preds = %582, %598
  %584 = phi i32 [ %599, %598 ], [ %10, %582 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %584) #16
  %585 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %586 = getelementptr inbounds %struct.Zio, %struct.Zio* %585, i64 0, i32 0
  %587 = load i64, i64* %586, align 8, !tbaa !244
  %588 = add i64 %587, -1
  store i64 %588, i64* %586, align 8, !tbaa !244
  %589 = icmp eq i64 %587, 0
  br i1 %589, label %596, label %590

; <label>:590:                                    ; preds = %583
  %591 = getelementptr inbounds %struct.Zio, %struct.Zio* %585, i64 0, i32 1
  %592 = load i8*, i8** %591, align 8, !tbaa !245
  %593 = getelementptr inbounds i8, i8* %592, i64 1
  store i8* %593, i8** %591, align 8, !tbaa !245
  %594 = load i8, i8* %592, align 1, !tbaa !21
  %595 = zext i8 %594 to i32
  br label %598

; <label>:596:                                    ; preds = %583
  %597 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %585) #16
  br label %598

; <label>:598:                                    ; preds = %596, %590
  %599 = phi i32 [ %595, %590 ], [ %597, %596 ]
  store i32 %599, i32* %7, align 8, !tbaa !262
  %600 = add nsw i32 %599, 1
  %601 = sext i32 %600 to i64
  %602 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %601
  %603 = load i8, i8* %602, align 1, !tbaa !21
  %604 = and i8 %603, 3
  %605 = icmp eq i8 %604, 0
  br i1 %605, label %606, label %583

; <label>:606:                                    ; preds = %598
  %607 = load %struct.Mbuffer*, %struct.Mbuffer** %4, align 8, !tbaa !255
  %608 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %607, i64 0, i32 0
  %609 = load i8*, i8** %608, align 8, !tbaa !269
  %610 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %607, i64 0, i32 1
  %611 = load i64, i64* %610, align 8, !tbaa !302
  %612 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %609, i64 %611) #16
  %613 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %612, %struct.TString** %613, align 8, !tbaa !21
  %614 = getelementptr inbounds %struct.TString, %struct.TString* %612, i64 0, i32 1
  %615 = load i8, i8* %614, align 8, !tbaa !75
  %616 = icmp eq i8 %615, 20
  br i1 %616, label %617, label %640

; <label>:617:                                    ; preds = %606
  %618 = getelementptr inbounds %struct.TString, %struct.TString* %612, i64 0, i32 3
  %619 = load i8, i8* %618, align 2, !tbaa !99
  %620 = icmp eq i8 %619, 0
  br i1 %620, label %640, label %621

; <label>:621:                                    ; preds = %617
  %622 = zext i8 %619 to i32
  %623 = or i32 %622, 256
  br label %640

; <label>:624:                                    ; preds = %575
  %625 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %626 = getelementptr inbounds %struct.Zio, %struct.Zio* %625, i64 0, i32 0
  %627 = load i64, i64* %626, align 8, !tbaa !244
  %628 = add i64 %627, -1
  store i64 %628, i64* %626, align 8, !tbaa !244
  %629 = icmp eq i64 %627, 0
  br i1 %629, label %636, label %630

; <label>:630:                                    ; preds = %624
  %631 = getelementptr inbounds %struct.Zio, %struct.Zio* %625, i64 0, i32 1
  %632 = load i8*, i8** %631, align 8, !tbaa !245
  %633 = getelementptr inbounds i8, i8* %632, i64 1
  store i8* %633, i8** %631, align 8, !tbaa !245
  %634 = load i8, i8* %632, align 1, !tbaa !21
  %635 = zext i8 %634 to i32
  br label %638

; <label>:636:                                    ; preds = %624
  %637 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %625) #16
  br label %638

; <label>:638:                                    ; preds = %636, %630
  %639 = phi i32 [ %635, %630 ], [ %637, %636 ]
  store i32 %639, i32* %7, align 8, !tbaa !262
  br label %640

; <label>:640:                                    ; preds = %9, %42, %621, %617, %606, %565, %561, %215, %196, %177, %159, %155, %137, %133, %114, %96, %97, %638, %573, %571, %532
  %641 = phi i32 [ %10, %638 ], [ %574, %573 ], [ %572, %571 ], [ 293, %532 ], [ 293, %96 ], [ 91, %97 ], [ %118, %114 ], [ 284, %133 ], [ %140, %137 ], [ 283, %155 ], [ %162, %159 ], [ %181, %177 ], [ %200, %196 ], [ %219, %215 ], [ %564, %561 ], [ 46, %565 ], [ %623, %621 ], [ 292, %617 ], [ 292, %606 ], [ 289, %9 ], [ 45, %42 ]
  ret i32 %641
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @inclinenumber(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !262
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !244
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !244
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !245
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !245
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !262
  switch i32 %19, label %38 [
    i32 10, label %20
    i32 13, label %20
  ]

; <label>:20:                                     ; preds = %18, %18
  %21 = icmp eq i32 %19, %3
  br i1 %21, label %38, label %22

; <label>:22:                                     ; preds = %20
  %23 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !264
  %24 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 0
  %25 = load i64, i64* %24, align 8, !tbaa !244
  %26 = add i64 %25, -1
  store i64 %26, i64* %24, align 8, !tbaa !244
  %27 = icmp eq i64 %25, 0
  br i1 %27, label %34, label %28

; <label>:28:                                     ; preds = %22
  %29 = getelementptr inbounds %struct.Zio, %struct.Zio* %23, i64 0, i32 1
  %30 = load i8*, i8** %29, align 8, !tbaa !245
  %31 = getelementptr inbounds i8, i8* %30, i64 1
  store i8* %31, i8** %29, align 8, !tbaa !245
  %32 = load i8, i8* %30, align 1, !tbaa !21
  %33 = zext i8 %32 to i32
  br label %36

; <label>:34:                                     ; preds = %22
  %35 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %23) #16
  br label %36

; <label>:36:                                     ; preds = %34, %28
  %37 = phi i32 [ %33, %28 ], [ %35, %34 ]
  store i32 %37, i32* %2, align 8, !tbaa !262
  br label %38

; <label>:38:                                     ; preds = %18, %20, %36
  %39 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %40 = load i32, i32* %39, align 4, !tbaa !265
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* %39, align 4, !tbaa !265
  %42 = icmp eq i32 %41, 2147483647
  br i1 %42, label %43, label %44

; <label>:43:                                     ; preds = %38
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.235, i64 0, i64 0), i32 0) #18
  unreachable

; <label>:44:                                     ; preds = %38
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @skip_sep(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !262
  tail call fastcc void @save(%struct.LexState* %0, i32 %3) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !244
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !244
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !245
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !245
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !262
  %20 = icmp eq i32 %19, 61
  br i1 %20, label %21, label %41

; <label>:21:                                     ; preds = %18
  br label %22

; <label>:22:                                     ; preds = %21, %37
  %23 = phi i64 [ %39, %37 ], [ 0, %21 ]
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 61) #16
  %24 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !264
  %25 = getelementptr inbounds %struct.Zio, %struct.Zio* %24, i64 0, i32 0
  %26 = load i64, i64* %25, align 8, !tbaa !244
  %27 = add i64 %26, -1
  store i64 %27, i64* %25, align 8, !tbaa !244
  %28 = icmp eq i64 %26, 0
  br i1 %28, label %35, label %29

; <label>:29:                                     ; preds = %22
  %30 = getelementptr inbounds %struct.Zio, %struct.Zio* %24, i64 0, i32 1
  %31 = load i8*, i8** %30, align 8, !tbaa !245
  %32 = getelementptr inbounds i8, i8* %31, i64 1
  store i8* %32, i8** %30, align 8, !tbaa !245
  %33 = load i8, i8* %31, align 1, !tbaa !21
  %34 = zext i8 %33 to i32
  br label %37

; <label>:35:                                     ; preds = %22
  %36 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %24) #16
  br label %37

; <label>:37:                                     ; preds = %35, %29
  %38 = phi i32 [ %34, %29 ], [ %36, %35 ]
  store i32 %38, i32* %2, align 8, !tbaa !262
  %39 = add i64 %23, 1
  %40 = icmp eq i32 %38, 61
  br i1 %40, label %22, label %41

; <label>:41:                                     ; preds = %37, %18
  %42 = phi i32 [ %19, %18 ], [ %38, %37 ]
  %43 = phi i64 [ 0, %18 ], [ %39, %37 ]
  %44 = icmp eq i32 %42, %3
  %45 = add i64 %43, 2
  %46 = icmp eq i64 %43, 0
  %47 = zext i1 %46 to i64
  %48 = select i1 %44, i64 %45, i64 %47
  ret i64 %48
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @read_long_string(%struct.LexState* nocapture, %union.SemInfo*, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %5 = load i32, i32* %4, align 4, !tbaa !265
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !262
  tail call fastcc void @save(%struct.LexState* %0, i32 %7) #16
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %9 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %10 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 0
  %11 = load i64, i64* %10, align 8, !tbaa !244
  %12 = add i64 %11, -1
  store i64 %12, i64* %10, align 8, !tbaa !244
  %13 = icmp eq i64 %11, 0
  br i1 %13, label %20, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.Zio, %struct.Zio* %9, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !245
  %17 = getelementptr inbounds i8, i8* %16, i64 1
  store i8* %17, i8** %15, align 8, !tbaa !245
  %18 = load i8, i8* %16, align 1, !tbaa !21
  %19 = zext i8 %18 to i32
  br label %22

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %9) #16
  br label %22

; <label>:22:                                     ; preds = %20, %14
  %23 = phi i32 [ %19, %14 ], [ %21, %20 ]
  store i32 %23, i32* %6, align 8, !tbaa !262
  switch i32 %23, label %25 [
    i32 10, label %24
    i32 13, label %24
  ]

; <label>:24:                                     ; preds = %22, %22
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br label %25

; <label>:25:                                     ; preds = %22, %24
  %26 = icmp eq %union.SemInfo* %1, null
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  br label %28

; <label>:28:                                     ; preds = %56, %25
  %29 = load i32, i32* %6, align 8, !tbaa !262
  switch i32 %29, label %60 [
    i32 -1, label %30
    i32 93, label %35
    i32 10, label %55
    i32 13, label %55
  ]

; <label>:30:                                     ; preds = %28
  %31 = select i1 %26, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.236, i64 0, i64 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.184, i64 0, i64 0)
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %33 = load %struct.lua_State*, %struct.lua_State** %32, align 8, !tbaa !261
  %34 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %33, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.237, i64 0, i64 0), i8* %31, i32 %5) #16
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %34, i32 289) #18
  unreachable

; <label>:35:                                     ; preds = %28
  %36 = tail call fastcc i64 @skip_sep(%struct.LexState* nonnull %0) #16
  %37 = icmp eq i64 %36, %2
  br i1 %37, label %38, label %56

; <label>:38:                                     ; preds = %35
  %39 = load i32, i32* %6, align 8, !tbaa !262
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %39) #16
  %40 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %41 = getelementptr inbounds %struct.Zio, %struct.Zio* %40, i64 0, i32 0
  %42 = load i64, i64* %41, align 8, !tbaa !244
  %43 = add i64 %42, -1
  store i64 %43, i64* %41, align 8, !tbaa !244
  %44 = icmp eq i64 %42, 0
  br i1 %44, label %51, label %45

; <label>:45:                                     ; preds = %38
  %46 = getelementptr inbounds %struct.Zio, %struct.Zio* %40, i64 0, i32 1
  %47 = load i8*, i8** %46, align 8, !tbaa !245
  %48 = getelementptr inbounds i8, i8* %47, i64 1
  store i8* %48, i8** %46, align 8, !tbaa !245
  %49 = load i8, i8* %47, align 1, !tbaa !21
  %50 = zext i8 %49 to i32
  br label %53

; <label>:51:                                     ; preds = %38
  %52 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %40) #16
  br label %53

; <label>:53:                                     ; preds = %51, %45
  %54 = phi i32 [ %50, %45 ], [ %52, %51 ]
  store i32 %54, i32* %6, align 8, !tbaa !262
  br i1 %26, label %104, label %93

; <label>:55:                                     ; preds = %28, %28
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 10) #16
  tail call fastcc void @inclinenumber(%struct.LexState* nonnull %0) #16
  br i1 %26, label %57, label %56

; <label>:56:                                     ; preds = %55, %75, %91, %57, %35
  br label %28

; <label>:57:                                     ; preds = %55
  %58 = load %struct.Mbuffer*, %struct.Mbuffer** %27, align 8, !tbaa !255
  %59 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %58, i64 0, i32 1
  store i64 0, i64* %59, align 8, !tbaa !302
  br label %56

; <label>:60:                                     ; preds = %28
  br i1 %26, label %77, label %61

; <label>:61:                                     ; preds = %60
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %29) #16
  %62 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %63 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !244
  %65 = add i64 %64, -1
  store i64 %65, i64* %63, align 8, !tbaa !244
  %66 = icmp eq i64 %64, 0
  br i1 %66, label %73, label %67

; <label>:67:                                     ; preds = %61
  %68 = getelementptr inbounds %struct.Zio, %struct.Zio* %62, i64 0, i32 1
  %69 = load i8*, i8** %68, align 8, !tbaa !245
  %70 = getelementptr inbounds i8, i8* %69, i64 1
  store i8* %70, i8** %68, align 8, !tbaa !245
  %71 = load i8, i8* %69, align 1, !tbaa !21
  %72 = zext i8 %71 to i32
  br label %75

; <label>:73:                                     ; preds = %61
  %74 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %62) #16
  br label %75

; <label>:75:                                     ; preds = %73, %67
  %76 = phi i32 [ %72, %67 ], [ %74, %73 ]
  store i32 %76, i32* %6, align 8, !tbaa !262
  br label %56

; <label>:77:                                     ; preds = %60
  %78 = load %struct.Zio*, %struct.Zio** %8, align 8, !tbaa !264
  %79 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 0
  %80 = load i64, i64* %79, align 8, !tbaa !244
  %81 = add i64 %80, -1
  store i64 %81, i64* %79, align 8, !tbaa !244
  %82 = icmp eq i64 %80, 0
  br i1 %82, label %89, label %83

; <label>:83:                                     ; preds = %77
  %84 = getelementptr inbounds %struct.Zio, %struct.Zio* %78, i64 0, i32 1
  %85 = load i8*, i8** %84, align 8, !tbaa !245
  %86 = getelementptr inbounds i8, i8* %85, i64 1
  store i8* %86, i8** %84, align 8, !tbaa !245
  %87 = load i8, i8* %85, align 1, !tbaa !21
  %88 = zext i8 %87 to i32
  br label %91

; <label>:89:                                     ; preds = %77
  %90 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %78) #16
  br label %91

; <label>:91:                                     ; preds = %89, %83
  %92 = phi i32 [ %88, %83 ], [ %90, %89 ]
  store i32 %92, i32* %6, align 8, !tbaa !262
  br label %56

; <label>:93:                                     ; preds = %53
  %94 = load %struct.Mbuffer*, %struct.Mbuffer** %27, align 8, !tbaa !255
  %95 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %94, i64 0, i32 0
  %96 = load i8*, i8** %95, align 8, !tbaa !269
  %97 = getelementptr inbounds i8, i8* %96, i64 %2
  %98 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %94, i64 0, i32 1
  %99 = load i64, i64* %98, align 8, !tbaa !302
  %100 = shl i64 %2, 1
  %101 = sub i64 %99, %100
  %102 = tail call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* %97, i64 %101) #16
  %103 = bitcast %union.SemInfo* %1 to %struct.TString**
  store %struct.TString* %102, %struct.TString** %103, align 8, !tbaa !21
  br label %104

; <label>:104:                                    ; preds = %53, %93
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @check_next1(%struct.LexState* nocapture, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !262
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %6, label %23

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !264
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !244
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !244
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %6
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !245
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !245
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %6
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8) #16
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %3, align 8, !tbaa !262
  br label %23

; <label>:23:                                     ; preds = %2, %21
  %24 = phi i32 [ 1, %21 ], [ 0, %2 ]
  ret i32 %24
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @read_numeral(%struct.LexState* nocapture, %union.SemInfo* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %4) #7
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !262
  tail call fastcc void @save(%struct.LexState* %0, i32 %6) #16
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %8 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !264
  %9 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !244
  %11 = add i64 %10, -1
  store i64 %11, i64* %9, align 8, !tbaa !244
  %12 = icmp eq i64 %10, 0
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.Zio, %struct.Zio* %8, i64 0, i32 1
  %15 = load i8*, i8** %14, align 8, !tbaa !245
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  store i8* %16, i8** %14, align 8, !tbaa !245
  %17 = load i8, i8* %15, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  br label %21

; <label>:19:                                     ; preds = %2
  %20 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %8) #16
  br label %21

; <label>:21:                                     ; preds = %19, %13
  %22 = phi i32 [ %18, %13 ], [ %20, %19 ]
  store i32 %22, i32* %5, align 8, !tbaa !262
  %23 = icmp eq i32 %6, 48
  br i1 %23, label %24, label %28

; <label>:24:                                     ; preds = %21
  %25 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.246, i64 0, i64 0)) #16
  %26 = icmp eq i32 %25, 0
  %27 = select i1 %26, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.247, i64 0, i64 0)
  br label %28

; <label>:28:                                     ; preds = %24, %21
  %29 = phi i8* [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.245, i64 0, i64 0), %21 ], [ %27, %24 ]
  br label %30

; <label>:30:                                     ; preds = %73, %28
  %31 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* %29) #16
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %35, label %33

; <label>:33:                                     ; preds = %30
  %34 = tail call fastcc i32 @check_next2(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.248, i64 0, i64 0)) #16
  br label %35

; <label>:35:                                     ; preds = %30, %33
  %36 = load i32, i32* %5, align 8, !tbaa !262
  %37 = add nsw i32 %36, 1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %38
  %40 = load i8, i8* %39, align 1, !tbaa !21
  %41 = and i8 %40, 16
  %42 = icmp eq i8 %41, 0
  br i1 %42, label %57, label %43

; <label>:43:                                     ; preds = %35
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36) #16
  %44 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !264
  %45 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 0
  %46 = load i64, i64* %45, align 8, !tbaa !244
  %47 = add i64 %46, -1
  store i64 %47, i64* %45, align 8, !tbaa !244
  %48 = icmp eq i64 %46, 0
  br i1 %48, label %55, label %49

; <label>:49:                                     ; preds = %43
  %50 = getelementptr inbounds %struct.Zio, %struct.Zio* %44, i64 0, i32 1
  %51 = load i8*, i8** %50, align 8, !tbaa !245
  %52 = getelementptr inbounds i8, i8* %51, i64 1
  store i8* %52, i8** %50, align 8, !tbaa !245
  %53 = load i8, i8* %51, align 1, !tbaa !21
  %54 = zext i8 %53 to i32
  br label %73

; <label>:55:                                     ; preds = %43
  %56 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %44) #16
  br label %73

; <label>:57:                                     ; preds = %35
  %58 = icmp eq i32 %36, 46
  br i1 %58, label %59, label %75

; <label>:59:                                     ; preds = %57
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 46) #16
  %60 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !264
  %61 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 0
  %62 = load i64, i64* %61, align 8, !tbaa !244
  %63 = add i64 %62, -1
  store i64 %63, i64* %61, align 8, !tbaa !244
  %64 = icmp eq i64 %62, 0
  br i1 %64, label %71, label %65

; <label>:65:                                     ; preds = %59
  %66 = getelementptr inbounds %struct.Zio, %struct.Zio* %60, i64 0, i32 1
  %67 = load i8*, i8** %66, align 8, !tbaa !245
  %68 = getelementptr inbounds i8, i8* %67, i64 1
  store i8* %68, i8** %66, align 8, !tbaa !245
  %69 = load i8, i8* %67, align 1, !tbaa !21
  %70 = zext i8 %69 to i32
  br label %73

; <label>:71:                                     ; preds = %59
  %72 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %60) #16
  br label %73

; <label>:73:                                     ; preds = %65, %71, %49, %55
  %74 = phi i32 [ %54, %49 ], [ %56, %55 ], [ %70, %65 ], [ %72, %71 ]
  store i32 %74, i32* %5, align 8, !tbaa !262
  br label %30

; <label>:75:                                     ; preds = %57
  %76 = and i8 %40, 3
  %77 = icmp eq i8 %76, 0
  br i1 %77, label %94, label %78

; <label>:78:                                     ; preds = %75
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %36) #16
  %79 = load %struct.Zio*, %struct.Zio** %7, align 8, !tbaa !264
  %80 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 0
  %81 = load i64, i64* %80, align 8, !tbaa !244
  %82 = add i64 %81, -1
  store i64 %82, i64* %80, align 8, !tbaa !244
  %83 = icmp eq i64 %81, 0
  br i1 %83, label %90, label %84

; <label>:84:                                     ; preds = %78
  %85 = getelementptr inbounds %struct.Zio, %struct.Zio* %79, i64 0, i32 1
  %86 = load i8*, i8** %85, align 8, !tbaa !245
  %87 = getelementptr inbounds i8, i8* %86, i64 1
  store i8* %87, i8** %85, align 8, !tbaa !245
  %88 = load i8, i8* %86, align 1, !tbaa !21
  %89 = zext i8 %88 to i32
  br label %92

; <label>:90:                                     ; preds = %78
  %91 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %79) #16
  br label %92

; <label>:92:                                     ; preds = %90, %84
  %93 = phi i32 [ %89, %84 ], [ %91, %90 ]
  store i32 %93, i32* %5, align 8, !tbaa !262
  br label %94

; <label>:94:                                     ; preds = %75, %92
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 0) #16
  %95 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 8
  %96 = load %struct.Mbuffer*, %struct.Mbuffer** %95, align 8, !tbaa !255
  %97 = getelementptr inbounds %struct.Mbuffer, %struct.Mbuffer* %96, i64 0, i32 0
  %98 = load i8*, i8** %97, align 8, !tbaa !269
  %99 = call fastcc i64 @luaO_str2num(i8* %98, %struct.TValue* nonnull %3) #16
  %100 = icmp eq i64 %99, 0
  br i1 %100, label %101, label %102

; <label>:101:                                    ; preds = %94
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.249, i64 0, i64 0), i32 290) #18
  unreachable

; <label>:102:                                    ; preds = %94
  %103 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !22
  %105 = icmp eq i8 %104, 35
  %106 = bitcast %struct.TValue* %3 to i64*
  %107 = load i64, i64* %106, align 8, !tbaa !21
  %108 = bitcast %union.SemInfo* %1 to i64*
  store i64 %107, i64* %108, align 8, !tbaa !21
  %109 = select i1 %105, i32 291, i32 290
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %4) #7
  ret i32 %109
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TString* @luaX_newstring(%struct.LexState* nocapture readonly, i8* nocapture readonly, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %5 = load %struct.lua_State*, %struct.lua_State** %4, align 8, !tbaa !261
  %6 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %5, i8* %1, i64 %2) #16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  store %union.StackValue* %9, %union.StackValue** %7, align 8, !tbaa !20
  %10 = bitcast %union.StackValue* %8 to %struct.TString**
  store %struct.TString* %6, %struct.TString** %10, align 8, !tbaa !21
  %11 = getelementptr inbounds %struct.TString, %struct.TString* %6, i64 0, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !75
  %13 = or i8 %12, 64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0, i32 1
  store i8 %13, i8* %14, align 8, !tbaa !22
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 9
  %16 = load %struct.Table*, %struct.Table** %15, align 8, !tbaa !250
  %17 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 -1, i32 0
  %19 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %5, %struct.Table* %16, %struct.TValue* nonnull %18) #16
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %32

; <label>:24:                                     ; preds = %3
  %25 = bitcast %struct.TValue* %19 to i32*
  store i32 1, i32* %25, align 8, !tbaa !21
  store i8 1, i8* %20, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %5, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 3
  %29 = load i64, i64* %28, align 8, !tbaa !11
  %30 = icmp sgt i64 %29, 0
  br i1 %30, label %31, label %36

; <label>:31:                                     ; preds = %24
  tail call fastcc void @luaC_step(%struct.lua_State* nonnull %5) #16
  br label %36

; <label>:32:                                     ; preds = %3
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 1, i32 0, i32 0
  %34 = bitcast %struct.GCObject** %33 to %struct.TString**
  %35 = load %struct.TString*, %struct.TString** %34, align 8, !tbaa !21
  br label %36

; <label>:36:                                     ; preds = %24, %31, %32
  %37 = phi %struct.TString* [ %6, %31 ], [ %6, %24 ], [ %35, %32 ]
  %38 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -1
  store %union.StackValue* %39, %union.StackValue** %7, align 8, !tbaa !20
  ret %struct.TString* %37
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @esccheck(%struct.LexState* nocapture, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %27

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !262
  %8 = icmp eq i32 %7, -1
  br i1 %8, label %26, label %9

; <label>:9:                                      ; preds = %5
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %7) #16
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %11 = load %struct.Zio*, %struct.Zio** %10, align 8, !tbaa !264
  %12 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 0
  %13 = load i64, i64* %12, align 8, !tbaa !244
  %14 = add i64 %13, -1
  store i64 %14, i64* %12, align 8, !tbaa !244
  %15 = icmp eq i64 %13, 0
  br i1 %15, label %22, label %16

; <label>:16:                                     ; preds = %9
  %17 = getelementptr inbounds %struct.Zio, %struct.Zio* %11, i64 0, i32 1
  %18 = load i8*, i8** %17, align 8, !tbaa !245
  %19 = getelementptr inbounds i8, i8* %18, i64 1
  store i8* %19, i8** %17, align 8, !tbaa !245
  %20 = load i8, i8* %18, align 1, !tbaa !21
  %21 = zext i8 %20 to i32
  br label %24

; <label>:22:                                     ; preds = %9
  %23 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %11) #16
  br label %24

; <label>:24:                                     ; preds = %22, %16
  %25 = phi i32 [ %21, %16 ], [ %23, %22 ]
  store i32 %25, i32* %6, align 8, !tbaa !262
  br label %26

; <label>:26:                                     ; preds = %5, %24
  tail call fastcc void @lexerror(%struct.LexState* nonnull %0, i8* %2, i32 293) #18
  unreachable

; <label>:27:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @gethexa(%struct.LexState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !262
  tail call fastcc void @save(%struct.LexState* %0, i32 %3) #16
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %5 = load %struct.Zio*, %struct.Zio** %4, align 8, !tbaa !264
  %6 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 0
  %7 = load i64, i64* %6, align 8, !tbaa !244
  %8 = add i64 %7, -1
  store i64 %8, i64* %6, align 8, !tbaa !244
  %9 = icmp eq i64 %7, 0
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.Zio, %struct.Zio* %5, i64 0, i32 1
  %12 = load i8*, i8** %11, align 8, !tbaa !245
  %13 = getelementptr inbounds i8, i8* %12, i64 1
  store i8* %13, i8** %11, align 8, !tbaa !245
  %14 = load i8, i8* %12, align 1, !tbaa !21
  %15 = zext i8 %14 to i32
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %5) #16
  br label %18

; <label>:18:                                     ; preds = %16, %10
  %19 = phi i32 [ %15, %10 ], [ %17, %16 ]
  store i32 %19, i32* %2, align 8, !tbaa !262
  %20 = add nsw i32 %19, 1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds [257 x i8], [257 x i8]* @luai_ctype_, i64 0, i64 %21
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = and i8 %23, 16
  %25 = zext i8 %24 to i32
  tail call fastcc void @esccheck(%struct.LexState* nonnull %0, i32 %25, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.240, i64 0, i64 0)) #16
  %26 = load i32, i32* %2, align 8, !tbaa !262
  %27 = add nsw i32 %26, 1
  %28 = sext i32 %27 to i64
  %29 = add nsw i64 %28, -49
  %30 = icmp ult i64 %29, 10
  %31 = add nsw i32 %26, -48
  %32 = or i32 %26, 32
  %33 = add nsw i32 %32, -87
  %34 = select i1 %30, i32 %31, i32 %33
  ret i32 %34
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @check_next2(%struct.LexState* nocapture, i8* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !262
  %5 = load i8, i8* %1, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %13, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr inbounds i8, i8* %1, i64 1
  %10 = load i8, i8* %9, align 1, !tbaa !21
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %4, %11
  br i1 %12, label %13, label %30

; <label>:13:                                     ; preds = %8, %2
  tail call fastcc void @save(%struct.LexState* nonnull %0, i32 %4) #16
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 7
  %15 = load %struct.Zio*, %struct.Zio** %14, align 8, !tbaa !264
  %16 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !244
  %18 = add i64 %17, -1
  store i64 %18, i64* %16, align 8, !tbaa !244
  %19 = icmp eq i64 %17, 0
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %13
  %21 = getelementptr inbounds %struct.Zio, %struct.Zio* %15, i64 0, i32 1
  %22 = load i8*, i8** %21, align 8, !tbaa !245
  %23 = getelementptr inbounds i8, i8* %22, i64 1
  store i8* %23, i8** %21, align 8, !tbaa !245
  %24 = load i8, i8* %22, align 1, !tbaa !21
  %25 = zext i8 %24 to i32
  br label %28

; <label>:26:                                     ; preds = %13
  %27 = tail call fastcc i32 @luaZ_fill(%struct.Zio* %15) #16
  br label %28

; <label>:28:                                     ; preds = %26, %20
  %29 = phi i32 [ %25, %20 ], [ %27, %26 ]
  store i32 %29, i32* %3, align 8, !tbaa !262
  br label %30

; <label>:30:                                     ; preds = %8, %28
  %31 = phi i32 [ 1, %28 ], [ 0, %8 ]
  ret i32 %31
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @statement(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = alloca %struct.expdesc, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = alloca %struct.LHS_assign, align 8
  %7 = alloca %struct.expdesc, align 8
  %8 = alloca %struct.expdesc, align 8
  %9 = alloca %struct.expdesc, align 8
  %10 = alloca %struct.expdesc, align 8
  %11 = alloca %struct.expdesc, align 8
  %12 = alloca %struct.BlockCnt, align 8
  %13 = alloca %struct.BlockCnt, align 8
  %14 = alloca %struct.expdesc, align 8
  %15 = alloca %struct.BlockCnt, align 8
  %16 = alloca %struct.BlockCnt, align 8
  %17 = alloca i32, align 4
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %19 = load i32, i32* %18, align 4, !tbaa !265
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %21 = load %struct.lua_State*, %struct.lua_State** %20, align 8, !tbaa !261
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %21) #16
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %23 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %23, label %755 [
    i32 59, label %24
    i32 267, label %38
    i32 278, label %65
    i32 259, label %117
    i32 264, label %132
    i32 273, label %271
    i32 265, label %349
    i32 269, label %377
    i32 288, label %526
    i32 274, label %583
    i32 258, label %667
    i32 266, label %691
  ]

; <label>:24:                                     ; preds = %1
  %25 = load i32, i32* %18, align 4, !tbaa !265
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %25, i32* %26, align 8, !tbaa !266
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %28 = getelementptr inbounds %struct.Token, %struct.Token* %27, i64 0, i32 0
  %29 = load i32, i32* %28, align 8, !tbaa !263
  %30 = icmp eq i32 %29, 289
  br i1 %30, label %35, label %31

; <label>:31:                                     ; preds = %24
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %33 = bitcast %struct.Token* %32 to i8*
  %34 = bitcast %struct.Token* %27 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %33, i8* nonnull %34, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %28, align 8, !tbaa !263
  br label %782

; <label>:35:                                     ; preds = %24
  %36 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %37 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %36) #17
  store i32 %37, i32* %22, align 8, !tbaa !260
  br label %782

; <label>:38:                                     ; preds = %1
  %39 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %40 = load %struct.FuncState*, %struct.FuncState** %39, align 8, !tbaa !273
  %41 = bitcast i32* %17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %41) #7
  store i32 -1, i32* %17, align 4, !tbaa !77
  call fastcc void @test_then_block(%struct.LexState* nonnull %0, i32* nonnull %17) #17
  br label %42

; <label>:42:                                     ; preds = %44, %38
  %43 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %43, label %60 [
    i32 261, label %44
    i32 260, label %45
  ]

; <label>:44:                                     ; preds = %42
  call fastcc void @test_then_block(%struct.LexState* nonnull %0, i32* nonnull %17) #17
  br label %42

; <label>:45:                                     ; preds = %42
  %46 = load i32, i32* %18, align 4, !tbaa !265
  %47 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %46, i32* %47, align 8, !tbaa !266
  %48 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %49 = getelementptr inbounds %struct.Token, %struct.Token* %48, i64 0, i32 0
  %50 = load i32, i32* %49, align 8, !tbaa !263
  %51 = icmp eq i32 %50, 289
  br i1 %51, label %56, label %52

; <label>:52:                                     ; preds = %45
  %53 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %54 = bitcast %struct.Token* %53 to i8*
  %55 = bitcast %struct.Token* %48 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %54, i8* nonnull %55, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %49, align 8, !tbaa !263
  br label %59

; <label>:56:                                     ; preds = %45
  %57 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %58 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %57) #17
  store i32 %58, i32* %22, align 8, !tbaa !260
  br label %59

; <label>:59:                                     ; preds = %52, %56
  tail call fastcc void @block(%struct.LexState* nonnull %0) #17
  br label %60

; <label>:60:                                     ; preds = %42, %59
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 267, i32 %19) #17
  %61 = load i32, i32* %17, align 4, !tbaa !77
  %62 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %40, i64 0, i32 4
  %63 = load i32, i32* %62, align 8, !tbaa !274
  %64 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %40, i64 0, i32 5
  store i32 %63, i32* %64, align 4, !tbaa !276
  tail call fastcc void @patchlistaux(%struct.FuncState* %40, i32 %61, i32 %63, i32 255, i32 %63) #17
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %41) #7
  br label %782

; <label>:65:                                     ; preds = %1
  %66 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %67 = load %struct.FuncState*, %struct.FuncState** %66, align 8, !tbaa !273
  %68 = bitcast %struct.BlockCnt* %16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %68) #7
  %69 = load i32, i32* %18, align 4, !tbaa !265
  %70 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %69, i32* %70, align 8, !tbaa !266
  %71 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %72 = getelementptr inbounds %struct.Token, %struct.Token* %71, i64 0, i32 0
  %73 = load i32, i32* %72, align 8, !tbaa !263
  %74 = icmp eq i32 %73, 289
  br i1 %74, label %79, label %75

; <label>:75:                                     ; preds = %65
  %76 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %77 = bitcast %struct.Token* %76 to i8*
  %78 = bitcast %struct.Token* %71 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %77, i8* nonnull %78, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %72, align 8, !tbaa !263
  br label %82

; <label>:79:                                     ; preds = %65
  %80 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %81 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %80) #17
  store i32 %81, i32* %22, align 8, !tbaa !260
  br label %82

; <label>:82:                                     ; preds = %79, %75
  %83 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 4
  %84 = load i32, i32* %83, align 8, !tbaa !274
  %85 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 5
  store i32 %84, i32* %85, align 4, !tbaa !276
  %86 = tail call fastcc i32 @cond(%struct.LexState* nonnull %0) #17
  %87 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 5
  store i8 1, i8* %87, align 2, !tbaa !282
  %88 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 13
  %89 = load i8, i8* %88, align 2, !tbaa !298
  %90 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 3
  store i8 %89, i8* %90, align 8, !tbaa !284
  %91 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 2
  %92 = load %struct.LexState*, %struct.LexState** %91, align 8, !tbaa !272
  %93 = getelementptr inbounds %struct.LexState, %struct.LexState* %92, i64 0, i32 10
  %94 = load %struct.Dyndata*, %struct.Dyndata** %93, align 8, !tbaa !256
  %95 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %94, i64 0, i32 2, i32 1
  %96 = load i32, i32* %95, align 8, !tbaa !257
  %97 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 1
  store i32 %96, i32* %97, align 8, !tbaa !285
  %98 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %94, i64 0, i32 1, i32 1
  %99 = load i32, i32* %98, align 8, !tbaa !258
  %100 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 2
  store i32 %99, i32* %100, align 4, !tbaa !286
  %101 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 4
  store i8 0, i8* %101, align 1, !tbaa !287
  %102 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %67, i64 0, i32 3
  %103 = load %struct.BlockCnt*, %struct.BlockCnt** %102, align 8, !tbaa !290
  %104 = icmp eq %struct.BlockCnt* %103, null
  %105 = ptrtoint %struct.BlockCnt* %103 to i64
  br i1 %104, label %111, label %106

; <label>:106:                                    ; preds = %82
  %107 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %103, i64 0, i32 6
  %108 = load i8, i8* %107, align 1, !tbaa !288
  %109 = icmp ne i8 %108, 0
  %110 = zext i1 %109 to i8
  br label %111

; <label>:111:                                    ; preds = %82, %106
  %112 = phi i8 [ 0, %82 ], [ %110, %106 ]
  %113 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %16, i64 0, i32 6
  store i8 %112, i8* %113, align 1, !tbaa !288
  %114 = bitcast %struct.BlockCnt* %16 to i64*
  store i64 %105, i64* %114, align 8, !tbaa !289
  store %struct.BlockCnt* %16, %struct.BlockCnt** %102, align 8, !tbaa !290
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 259) #17
  call fastcc void @block(%struct.LexState* nonnull %0) #17
  %115 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %67, i32 2147483449) #17
  call fastcc void @patchlistaux(%struct.FuncState* nonnull %67, i32 %115, i32 %84, i32 255, i32 %84) #17
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 278, i32 %19) #17
  call fastcc void @leaveblock(%struct.FuncState* nonnull %67) #17
  %116 = load i32, i32* %83, align 8, !tbaa !274
  store i32 %116, i32* %85, align 4, !tbaa !276
  call fastcc void @patchlistaux(%struct.FuncState* nonnull %67, i32 %86, i32 %116, i32 255, i32 %116) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %68) #7
  br label %782

; <label>:117:                                    ; preds = %1
  %118 = load i32, i32* %18, align 4, !tbaa !265
  %119 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %118, i32* %119, align 8, !tbaa !266
  %120 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %121 = getelementptr inbounds %struct.Token, %struct.Token* %120, i64 0, i32 0
  %122 = load i32, i32* %121, align 8, !tbaa !263
  %123 = icmp eq i32 %122, 289
  br i1 %123, label %128, label %124

; <label>:124:                                    ; preds = %117
  %125 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %126 = bitcast %struct.Token* %125 to i8*
  %127 = bitcast %struct.Token* %120 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %126, i8* nonnull %127, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %121, align 8, !tbaa !263
  br label %131

; <label>:128:                                    ; preds = %117
  %129 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %130 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %129) #17
  store i32 %130, i32* %22, align 8, !tbaa !260
  br label %131

; <label>:131:                                    ; preds = %124, %128
  tail call fastcc void @block(%struct.LexState* nonnull %0) #16
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 259, i32 %19) #16
  br label %782

; <label>:132:                                    ; preds = %1
  %133 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %134 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  %135 = bitcast %struct.BlockCnt* %15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %135) #7
  %136 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 5
  store i8 1, i8* %136, align 2, !tbaa !282
  %137 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %134, i64 0, i32 13
  %138 = load i8, i8* %137, align 2, !tbaa !298
  %139 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 3
  store i8 %138, i8* %139, align 8, !tbaa !284
  %140 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %134, i64 0, i32 2
  %141 = load %struct.LexState*, %struct.LexState** %140, align 8, !tbaa !272
  %142 = getelementptr inbounds %struct.LexState, %struct.LexState* %141, i64 0, i32 10
  %143 = load %struct.Dyndata*, %struct.Dyndata** %142, align 8, !tbaa !256
  %144 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %143, i64 0, i32 2, i32 1
  %145 = load i32, i32* %144, align 8, !tbaa !257
  %146 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 1
  store i32 %145, i32* %146, align 8, !tbaa !285
  %147 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %143, i64 0, i32 1, i32 1
  %148 = load i32, i32* %147, align 8, !tbaa !258
  %149 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 2
  store i32 %148, i32* %149, align 4, !tbaa !286
  %150 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 4
  store i8 0, i8* %150, align 1, !tbaa !287
  %151 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %134, i64 0, i32 3
  %152 = load %struct.BlockCnt*, %struct.BlockCnt** %151, align 8, !tbaa !290
  %153 = icmp eq %struct.BlockCnt* %152, null
  %154 = ptrtoint %struct.BlockCnt* %152 to i64
  br i1 %153, label %160, label %155

; <label>:155:                                    ; preds = %132
  %156 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %152, i64 0, i32 6
  %157 = load i8, i8* %156, align 1, !tbaa !288
  %158 = icmp ne i8 %157, 0
  %159 = zext i1 %158 to i8
  br label %160

; <label>:160:                                    ; preds = %155, %132
  %161 = phi i8 [ 0, %132 ], [ %159, %155 ]
  %162 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %15, i64 0, i32 6
  store i8 %161, i8* %162, align 1, !tbaa !288
  %163 = bitcast %struct.BlockCnt* %15 to i64*
  store i64 %154, i64* %163, align 8, !tbaa !289
  store %struct.BlockCnt* %15, %struct.BlockCnt** %151, align 8, !tbaa !290
  %164 = load i32, i32* %18, align 4, !tbaa !265
  %165 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %164, i32* %165, align 8, !tbaa !266
  %166 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %167 = getelementptr inbounds %struct.Token, %struct.Token* %166, i64 0, i32 0
  %168 = load i32, i32* %167, align 8, !tbaa !263
  %169 = icmp eq i32 %168, 289
  br i1 %169, label %174, label %170

; <label>:170:                                    ; preds = %160
  %171 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %172 = bitcast %struct.Token* %171 to i8*
  %173 = bitcast %struct.Token* %166 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %172, i8* nonnull %173, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %167, align 8, !tbaa !263
  br label %177

; <label>:174:                                    ; preds = %160
  %175 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %176 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %175) #17
  store i32 %176, i32* %22, align 8, !tbaa !260
  br label %177

; <label>:177:                                    ; preds = %174, %170
  %178 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %179 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %179, label %269 [
    i32 61, label %180
    i32 44, label %220
    i32 268, label %220
  ]

; <label>:180:                                    ; preds = %177
  %181 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  %182 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %181, i64 0, i32 15
  %183 = load i8, i8* %182, align 4, !tbaa !303
  %184 = zext i8 %183 to i32
  %185 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.269, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %185) #17
  %186 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.270, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %186) #17
  %187 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.271, i64 0, i64 0), i64 10) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %187) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %178) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #17
  %188 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %188) #7
  %189 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5, i32 0) #17
  %190 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %190, %struct.expdesc* nonnull %5) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %188) #7
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 44) #17
  %191 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %191) #7
  %192 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4, i32 0) #17
  %193 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %193, %struct.expdesc* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %191) #7
  %194 = load i32, i32* %22, align 8, !tbaa !260
  %195 = icmp eq i32 %194, 44
  br i1 %195, label %196, label %211

; <label>:196:                                    ; preds = %180
  %197 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %197, i32* %165, align 8, !tbaa !266
  %198 = load i32, i32* %167, align 8, !tbaa !263
  %199 = icmp eq i32 %198, 289
  br i1 %199, label %204, label %200

; <label>:200:                                    ; preds = %196
  %201 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %202 = bitcast %struct.Token* %201 to i8*
  %203 = bitcast %struct.Token* %166 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %202, i8* nonnull %203, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %167, align 8, !tbaa !263
  br label %207

; <label>:204:                                    ; preds = %196
  %205 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %206 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %205) #17
  store i32 %206, i32* %22, align 8, !tbaa !260
  br label %207

; <label>:207:                                    ; preds = %200, %204
  %208 = bitcast %struct.expdesc* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %208) #7
  %209 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %3, i32 0) #17
  %210 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %210, %struct.expdesc* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %208) #7
  br label %219

; <label>:211:                                    ; preds = %180
  %212 = load i8, i8* %182, align 4, !tbaa !303
  %213 = zext i8 %212 to i32
  %214 = shl nuw nsw i32 %213, 7
  %215 = or i32 %214, -2147483647
  %216 = call fastcc i32 @luaK_code(%struct.FuncState* %181, i32 %215) #17
  call fastcc void @luaK_checkstack(%struct.FuncState* %181, i32 1) #17
  %217 = load i8, i8* %182, align 4, !tbaa !303
  %218 = add i8 %217, 1
  store i8 %218, i8* %182, align 4, !tbaa !303
  br label %219

; <label>:219:                                    ; preds = %211, %207
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 3) #17
  call fastcc void @forbody(%struct.LexState* nonnull %0, i32 %184, i32 %19, i32 1, i32 0) #17
  br label %270

; <label>:220:                                    ; preds = %177, %177
  %221 = load %struct.FuncState*, %struct.FuncState** %133, align 8, !tbaa !273
  %222 = bitcast %struct.expdesc* %14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %222) #7
  %223 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %221, i64 0, i32 15
  %224 = load i8, i8* %223, align 4, !tbaa !303
  %225 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.272, i64 0, i64 0), i64 15) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %225) #17
  %226 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.273, i64 0, i64 0), i64 11) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %226) #17
  %227 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %221, i64 0, i32 13
  %228 = load i8, i8* %227, align 2, !tbaa !298
  %229 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %221, i64 0, i32 3
  br label %230

; <label>:230:                                    ; preds = %230, %220
  %231 = phi %struct.BlockCnt** [ %229, %220 ], [ %236, %230 ]
  %232 = load %struct.BlockCnt*, %struct.BlockCnt** %231, align 8, !tbaa !54
  %233 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %232, i64 0, i32 3
  %234 = load i8, i8* %233, align 8, !tbaa !284
  %235 = icmp ugt i8 %234, %228
  %236 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %232, i64 0, i32 0
  br i1 %235, label %230, label %237

; <label>:237:                                    ; preds = %230
  %238 = zext i8 %224 to i32
  %239 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %232, i64 0, i32 4
  store i8 1, i8* %239, align 1, !tbaa !287
  %240 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %221, i64 0, i32 17
  store i8 1, i8* %240, align 2, !tbaa !299
  %241 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.274, i64 0, i64 0), i64 13) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %241) #17
  %242 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.275, i64 0, i64 0), i64 13) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %242) #17
  call fastcc void @new_localvar(%struct.LexState* %0, %struct.TString* %178) #17
  %243 = load i32, i32* %22, align 8, !tbaa !260
  %244 = icmp eq i32 %243, 44
  br i1 %244, label %245, label %265

; <label>:245:                                    ; preds = %237
  %246 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %247 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %248 = bitcast %struct.Token* %247 to i8*
  %249 = bitcast %struct.Token* %166 to i8*
  br label %250

; <label>:250:                                    ; preds = %245, %258
  %251 = phi i32 [ 5, %245 ], [ %260, %258 ]
  %252 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %252, i32* %165, align 8, !tbaa !266
  %253 = load i32, i32* %167, align 8, !tbaa !263
  %254 = icmp eq i32 %253, 289
  br i1 %254, label %256, label %255

; <label>:255:                                    ; preds = %250
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %248, i8* nonnull %249, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %167, align 8, !tbaa !263
  br label %258

; <label>:256:                                    ; preds = %250
  %257 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %246) #17
  store i32 %257, i32* %22, align 8, !tbaa !260
  br label %258

; <label>:258:                                    ; preds = %255, %256
  %259 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %259) #17
  %260 = add nuw nsw i32 %251, 1
  %261 = load i32, i32* %22, align 8, !tbaa !260
  %262 = icmp eq i32 %261, 44
  br i1 %262, label %250, label %263

; <label>:263:                                    ; preds = %258
  %264 = add nsw i32 %251, -3
  br label %265

; <label>:265:                                    ; preds = %263, %237
  %266 = phi i32 [ 1, %237 ], [ %264, %263 ]
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 268) #17
  %267 = load i32, i32* %18, align 4, !tbaa !265
  %268 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %14) #17
  call fastcc void @adjust_assign(%struct.LexState* nonnull %0, i32 4, i32 %268, %struct.expdesc* nonnull %14) #17
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 4) #17
  call fastcc void @luaK_checkstack(%struct.FuncState* %221, i32 3) #17
  call fastcc void @forbody(%struct.LexState* nonnull %0, i32 %238, i32 %267, i32 %266, i32 1) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %222) #7
  br label %270

; <label>:269:                                    ; preds = %177
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.268, i64 0, i64 0)) #19
  unreachable

; <label>:270:                                    ; preds = %219, %265
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 262, i32 264, i32 %19) #17
  call fastcc void @leaveblock(%struct.FuncState* %134) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %135) #7
  br label %782

; <label>:271:                                    ; preds = %1
  %272 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %273 = load %struct.FuncState*, %struct.FuncState** %272, align 8, !tbaa !273
  %274 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %273, i64 0, i32 4
  %275 = load i32, i32* %274, align 8, !tbaa !274
  %276 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %273, i64 0, i32 5
  store i32 %275, i32* %276, align 4, !tbaa !276
  %277 = bitcast %struct.BlockCnt* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %277) #7
  %278 = bitcast %struct.BlockCnt* %13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %278) #7
  %279 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 5
  store i8 1, i8* %279, align 2, !tbaa !282
  %280 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %273, i64 0, i32 13
  %281 = load i8, i8* %280, align 2, !tbaa !298
  %282 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 3
  store i8 %281, i8* %282, align 8, !tbaa !284
  %283 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %273, i64 0, i32 2
  %284 = load %struct.LexState*, %struct.LexState** %283, align 8, !tbaa !272
  %285 = getelementptr inbounds %struct.LexState, %struct.LexState* %284, i64 0, i32 10
  %286 = load %struct.Dyndata*, %struct.Dyndata** %285, align 8, !tbaa !256
  %287 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %286, i64 0, i32 2, i32 1
  %288 = load i32, i32* %287, align 8, !tbaa !257
  %289 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 1
  store i32 %288, i32* %289, align 8, !tbaa !285
  %290 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %286, i64 0, i32 1, i32 1
  %291 = load i32, i32* %290, align 8, !tbaa !258
  %292 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 2
  store i32 %291, i32* %292, align 4, !tbaa !286
  %293 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 4
  store i8 0, i8* %293, align 1, !tbaa !287
  %294 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %273, i64 0, i32 3
  %295 = load %struct.BlockCnt*, %struct.BlockCnt** %294, align 8, !tbaa !290
  %296 = icmp eq %struct.BlockCnt* %295, null
  %297 = ptrtoint %struct.BlockCnt* %295 to i64
  br i1 %296, label %303, label %298

; <label>:298:                                    ; preds = %271
  %299 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %295, i64 0, i32 6
  %300 = load i8, i8* %299, align 1, !tbaa !288
  %301 = icmp ne i8 %300, 0
  %302 = zext i1 %301 to i8
  br label %303

; <label>:303:                                    ; preds = %298, %271
  %304 = phi i8 [ 0, %271 ], [ %302, %298 ]
  %305 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %12, i64 0, i32 6
  store i8 %304, i8* %305, align 1, !tbaa !288
  %306 = bitcast %struct.BlockCnt* %12 to i64*
  store i64 %297, i64* %306, align 8, !tbaa !289
  %307 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 5
  store i8 0, i8* %307, align 2, !tbaa !282
  %308 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 3
  store i8 %281, i8* %308, align 8, !tbaa !284
  %309 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 1
  store i32 %288, i32* %309, align 8, !tbaa !285
  %310 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 2
  store i32 %291, i32* %310, align 4, !tbaa !286
  %311 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 4
  store i8 0, i8* %311, align 1, !tbaa !287
  %312 = ptrtoint %struct.BlockCnt* %12 to i64
  %313 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %13, i64 0, i32 6
  store i8 %304, i8* %313, align 1, !tbaa !288
  %314 = bitcast %struct.BlockCnt* %13 to i64*
  store i64 %312, i64* %314, align 8, !tbaa !289
  store %struct.BlockCnt* %13, %struct.BlockCnt** %294, align 8, !tbaa !290
  %315 = load i32, i32* %18, align 4, !tbaa !265
  %316 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %315, i32* %316, align 8, !tbaa !266
  %317 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %318 = getelementptr inbounds %struct.Token, %struct.Token* %317, i64 0, i32 0
  %319 = load i32, i32* %318, align 8, !tbaa !263
  %320 = icmp eq i32 %319, 289
  br i1 %320, label %325, label %321

; <label>:321:                                    ; preds = %303
  %322 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %323 = bitcast %struct.Token* %322 to i8*
  %324 = bitcast %struct.Token* %317 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %323, i8* nonnull %324, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %318, align 8, !tbaa !263
  br label %328

; <label>:325:                                    ; preds = %303
  %326 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %327 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %326) #17
  store i32 %327, i32* %22, align 8, !tbaa !260
  br label %328

; <label>:328:                                    ; preds = %325, %321
  br label %329

; <label>:329:                                    ; preds = %328, %331
  %330 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %330, label %331 [
    i32 260, label %333
    i32 261, label %333
    i32 262, label %333
    i32 289, label %333
    i32 277, label %333
  ]

; <label>:331:                                    ; preds = %329
  %332 = icmp eq i32 %330, 274
  call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br i1 %332, label %333, label %329

; <label>:333:                                    ; preds = %329, %329, %329, %329, %329, %331
  call fastcc void @check_match(%struct.LexState* %0, i32 277, i32 273, i32 %19) #17
  %334 = call fastcc i32 @cond(%struct.LexState* %0) #17
  call fastcc void @leaveblock(%struct.FuncState* %273) #17
  %335 = load i8, i8* %311, align 1, !tbaa !287
  %336 = icmp eq i8 %335, 0
  br i1 %336, label %347, label %337

; <label>:337:                                    ; preds = %333
  %338 = call fastcc i32 @luaK_code(%struct.FuncState* %273, i32 2147483449) #17
  %339 = load i32, i32* %274, align 8, !tbaa !274
  store i32 %339, i32* %276, align 4, !tbaa !276
  call fastcc void @patchlistaux(%struct.FuncState* %273, i32 %334, i32 %339, i32 255, i32 %339) #17
  %340 = load i8, i8* %308, align 8, !tbaa !284
  %341 = zext i8 %340 to i32
  %342 = shl nuw nsw i32 %341, 7
  %343 = or i32 %342, 55
  %344 = call fastcc i32 @luaK_code(%struct.FuncState* %273, i32 %343) #17
  %345 = call fastcc i32 @luaK_code(%struct.FuncState* %273, i32 2147483449) #17
  %346 = load i32, i32* %274, align 8, !tbaa !274
  store i32 %346, i32* %276, align 4, !tbaa !276
  call fastcc void @patchlistaux(%struct.FuncState* %273, i32 %338, i32 %346, i32 255, i32 %346) #17
  br label %347

; <label>:347:                                    ; preds = %333, %337
  %348 = phi i32 [ %345, %337 ], [ %334, %333 ]
  call fastcc void @patchlistaux(%struct.FuncState* %273, i32 %348, i32 %275, i32 255, i32 %275) #17
  call fastcc void @leaveblock(%struct.FuncState* %273) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %278) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %277) #7
  br label %782

; <label>:349:                                    ; preds = %1
  %350 = bitcast %struct.expdesc* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %350) #7
  %351 = bitcast %struct.expdesc* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %351) #7
  %352 = load i32, i32* %18, align 4, !tbaa !265
  %353 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %352, i32* %353, align 8, !tbaa !266
  %354 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %355 = getelementptr inbounds %struct.Token, %struct.Token* %354, i64 0, i32 0
  %356 = load i32, i32* %355, align 8, !tbaa !263
  %357 = icmp eq i32 %356, 289
  br i1 %357, label %362, label %358

; <label>:358:                                    ; preds = %349
  %359 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %360 = bitcast %struct.Token* %359 to i8*
  %361 = bitcast %struct.Token* %354 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %360, i8* nonnull %361, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %355, align 8, !tbaa !263
  br label %365

; <label>:362:                                    ; preds = %349
  %363 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %364 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %363) #17
  store i32 %364, i32* %22, align 8, !tbaa !260
  br label %365

; <label>:365:                                    ; preds = %362, %358
  call fastcc void @singlevar(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %10) #17
  br label %366

; <label>:366:                                    ; preds = %368, %365
  %367 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %367, label %370 [
    i32 46, label %368
    i32 58, label %369
  ]

; <label>:368:                                    ; preds = %366
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %10) #17
  br label %366

; <label>:369:                                    ; preds = %366
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %10) #17
  br label %370

; <label>:370:                                    ; preds = %366, %369
  %371 = phi i32 [ 1, %369 ], [ 0, %366 ]
  call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %11, i32 %371, i32 %19) #17
  %372 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %373 = load %struct.FuncState*, %struct.FuncState** %372, align 8, !tbaa !273
  call fastcc void @luaK_storevar(%struct.FuncState* %373, %struct.expdesc* nonnull %10, %struct.expdesc* nonnull %11) #17
  %374 = load %struct.FuncState*, %struct.FuncState** %372, align 8, !tbaa !273
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %374) #17
  %375 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %374, i64 0, i32 0
  %376 = load %struct.Proto*, %struct.Proto** %375, align 8, !tbaa !253
  tail call fastcc void @savelineinfo(%struct.FuncState* %374, %struct.Proto* %376, i32 %19) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %351) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %350) #7
  br label %782

; <label>:377:                                    ; preds = %1
  %378 = load i32, i32* %18, align 4, !tbaa !265
  %379 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %378, i32* %379, align 8, !tbaa !266
  %380 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %381 = getelementptr inbounds %struct.Token, %struct.Token* %380, i64 0, i32 0
  %382 = load i32, i32* %381, align 8, !tbaa !263
  %383 = icmp eq i32 %382, 289
  br i1 %383, label %389, label %384

; <label>:384:                                    ; preds = %377
  %385 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %386 = bitcast %struct.Token* %385 to i8*
  %387 = bitcast %struct.Token* %380 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %386, i8* nonnull %387, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %381, align 8, !tbaa !263
  %388 = load i32, i32* %22, align 8, !tbaa !260
  br label %392

; <label>:389:                                    ; preds = %377
  %390 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %391 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %390) #17
  store i32 %391, i32* %22, align 8, !tbaa !260
  br label %392

; <label>:392:                                    ; preds = %384, %389
  %393 = phi i32 [ %388, %384 ], [ %391, %389 ]
  switch i32 %393, label %482 [
    i32 265, label %394
    i32 42, label %434
  ]

; <label>:394:                                    ; preds = %392
  %395 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %395, i32* %379, align 8, !tbaa !266
  %396 = load i32, i32* %381, align 8, !tbaa !263
  %397 = icmp eq i32 %396, 289
  br i1 %397, label %402, label %398

; <label>:398:                                    ; preds = %394
  %399 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %400 = bitcast %struct.Token* %399 to i8*
  %401 = bitcast %struct.Token* %380 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %400, i8* nonnull %401, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %381, align 8, !tbaa !263
  br label %405

; <label>:402:                                    ; preds = %394
  %403 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %404 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %403) #17
  store i32 %404, i32* %22, align 8, !tbaa !260
  br label %405

; <label>:405:                                    ; preds = %398, %402
  %406 = bitcast %struct.expdesc* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %406) #7
  %407 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %408 = load %struct.FuncState*, %struct.FuncState** %407, align 8, !tbaa !273
  %409 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %409) #17
  tail call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 1) #17
  %410 = load i32, i32* %18, align 4, !tbaa !265
  call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %9, i32 0, i32 %410) #17
  %411 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %408, i64 0, i32 4
  %412 = load i32, i32* %411, align 8, !tbaa !274
  %413 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %9, i64 0, i32 1
  %414 = bitcast %union.anon.8* %413 to i32*
  %415 = load i32, i32* %414, align 8, !tbaa !21
  %416 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %408, i64 0, i32 2
  %417 = load %struct.LexState*, %struct.LexState** %416, align 8, !tbaa !272
  %418 = getelementptr inbounds %struct.LexState, %struct.LexState* %417, i64 0, i32 10
  %419 = load %struct.Dyndata*, %struct.Dyndata** %418, align 8, !tbaa !256
  %420 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %419, i64 0, i32 0, i32 0
  %421 = load %struct.Vardesc*, %struct.Vardesc** %420, align 8, !tbaa !304
  %422 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %408, i64 0, i32 10
  %423 = load i32, i32* %422, align 8, !tbaa !280
  %424 = add nsw i32 %423, %415
  %425 = sext i32 %424 to i64
  %426 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %421, i64 %425, i32 0
  %427 = load i16, i16* %426, align 2, !tbaa !305
  %428 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %408, i64 0, i32 0
  %429 = load %struct.Proto*, %struct.Proto** %428, align 8, !tbaa !253
  %430 = getelementptr inbounds %struct.Proto, %struct.Proto* %429, i64 0, i32 21
  %431 = load %struct.LocVar*, %struct.LocVar** %430, align 8, !tbaa !110
  %432 = sext i16 %427 to i64
  %433 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %431, i64 %432, i32 1
  store i32 %412, i32* %433, align 8, !tbaa !111
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %406) #7
  br label %782

; <label>:434:                                    ; preds = %392
  %435 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %435, i32* %379, align 8, !tbaa !266
  %436 = load i32, i32* %381, align 8, !tbaa !263
  %437 = icmp eq i32 %436, 289
  br i1 %437, label %442, label %438

; <label>:438:                                    ; preds = %434
  %439 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %440 = bitcast %struct.Token* %439 to i8*
  %441 = bitcast %struct.Token* %380 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %440, i8* nonnull %441, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %381, align 8, !tbaa !263
  br label %445

; <label>:442:                                    ; preds = %434
  %443 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %444 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %443) #17
  store i32 %444, i32* %22, align 8, !tbaa !260
  br label %445

; <label>:445:                                    ; preds = %438, %442
  %446 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %447 = load %struct.FuncState*, %struct.FuncState** %446, align 8, !tbaa !273
  %448 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %449 = getelementptr inbounds %struct.TString, %struct.TString* %448, i64 1
  %450 = bitcast %struct.TString* %449 to i8*
  %451 = tail call i32 @strcmp(i8* nonnull %450, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.276, i64 0, i64 0)) #21
  %452 = icmp eq i32 %451, 0
  br i1 %452, label %456, label %453

; <label>:453:                                    ; preds = %445
  %454 = load %struct.lua_State*, %struct.lua_State** %20, align 8, !tbaa !261
  %455 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %454, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.277, i64 0, i64 0), %struct.TString* nonnull %449) #17
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %455) #19
  unreachable

; <label>:456:                                    ; preds = %445
  %457 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %457) #17
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #17
  %458 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %458) #7
  %459 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %2, i32 0) #17
  %460 = load %struct.FuncState*, %struct.FuncState** %446, align 8, !tbaa !273
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %460, %struct.expdesc* nonnull %2) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %458) #7
  %461 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %447, i64 0, i32 13
  %462 = load i8, i8* %461, align 2, !tbaa !298
  %463 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %447, i64 0, i32 3
  br label %464

; <label>:464:                                    ; preds = %464, %456
  %465 = phi %struct.BlockCnt** [ %463, %456 ], [ %470, %464 ]
  %466 = load %struct.BlockCnt*, %struct.BlockCnt** %465, align 8, !tbaa !54
  %467 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %466, i64 0, i32 3
  %468 = load i8, i8* %467, align 8, !tbaa !284
  %469 = icmp ugt i8 %468, %462
  %470 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %466, i64 0, i32 0
  br i1 %469, label %464, label %471

; <label>:471:                                    ; preds = %464
  %472 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %466, i64 0, i32 4
  store i8 1, i8* %472, align 1, !tbaa !287
  %473 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %447, i64 0, i32 17
  store i8 1, i8* %473, align 2, !tbaa !299
  %474 = load %struct.BlockCnt*, %struct.BlockCnt** %463, align 8, !tbaa !290
  %475 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %474, i64 0, i32 6
  store i8 1, i8* %475, align 1, !tbaa !288
  call fastcc void @adjustlocalvars(%struct.LexState* %0, i32 1) #17
  %476 = load i8, i8* %461, align 2, !tbaa !298
  %477 = zext i8 %476 to i32
  %478 = shl nuw nsw i32 %477, 7
  %479 = add nsw i32 %478, -128
  %480 = or i32 %479, 56
  %481 = call fastcc i32 @luaK_code(%struct.FuncState* %447, i32 %480) #17
  br label %782

; <label>:482:                                    ; preds = %392
  %483 = bitcast %struct.expdesc* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %483) #7
  %484 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %484) #17
  %485 = load i32, i32* %22, align 8, !tbaa !260
  %486 = icmp eq i32 %485, 44
  br i1 %486, label %487, label %505

; <label>:487:                                    ; preds = %482
  %488 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %489 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %490 = bitcast %struct.Token* %489 to i8*
  %491 = bitcast %struct.Token* %380 to i8*
  br label %492

; <label>:492:                                    ; preds = %487, %500
  %493 = phi i32 [ 1, %487 ], [ %502, %500 ]
  %494 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %494, i32* %379, align 8, !tbaa !266
  %495 = load i32, i32* %381, align 8, !tbaa !263
  %496 = icmp eq i32 %495, 289
  br i1 %496, label %498, label %497

; <label>:497:                                    ; preds = %492
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %490, i8* nonnull %491, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %381, align 8, !tbaa !263
  br label %500

; <label>:498:                                    ; preds = %492
  %499 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %488) #17
  store i32 %499, i32* %22, align 8, !tbaa !260
  br label %500

; <label>:500:                                    ; preds = %498, %497
  %501 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  tail call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %501) #17
  %502 = add nuw nsw i32 %493, 1
  %503 = load i32, i32* %22, align 8, !tbaa !260
  %504 = icmp eq i32 %503, 44
  br i1 %504, label %492, label %505

; <label>:505:                                    ; preds = %500, %482
  %506 = phi i32 [ %485, %482 ], [ %503, %500 ]
  %507 = phi i32 [ 1, %482 ], [ %502, %500 ]
  %508 = icmp eq i32 %506, 61
  br i1 %508, label %509, label %522

; <label>:509:                                    ; preds = %505
  %510 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %510, i32* %379, align 8, !tbaa !266
  %511 = load i32, i32* %381, align 8, !tbaa !263
  %512 = icmp eq i32 %511, 289
  br i1 %512, label %517, label %513

; <label>:513:                                    ; preds = %509
  %514 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %515 = bitcast %struct.Token* %514 to i8*
  %516 = bitcast %struct.Token* %380 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %515, i8* nonnull %516, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %381, align 8, !tbaa !263
  br label %520

; <label>:517:                                    ; preds = %509
  %518 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %519 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %518) #17
  store i32 %519, i32* %22, align 8, !tbaa !260
  br label %520

; <label>:520:                                    ; preds = %513, %517
  %521 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %8) #17
  br label %524

; <label>:522:                                    ; preds = %505
  %523 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %8, i64 0, i32 0
  store i32 0, i32* %523, align 8, !tbaa !294
  br label %524

; <label>:524:                                    ; preds = %522, %520
  %525 = phi i32 [ %521, %520 ], [ 0, %522 ]
  call fastcc void @adjust_assign(%struct.LexState* nonnull %0, i32 %507, i32 %525, %struct.expdesc* nonnull %8) #17
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 %507) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %483) #7
  br label %782

; <label>:526:                                    ; preds = %1
  %527 = load i32, i32* %18, align 4, !tbaa !265
  %528 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %527, i32* %528, align 8, !tbaa !266
  %529 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %530 = getelementptr inbounds %struct.Token, %struct.Token* %529, i64 0, i32 0
  %531 = load i32, i32* %530, align 8, !tbaa !263
  %532 = icmp eq i32 %531, 289
  br i1 %532, label %537, label %533

; <label>:533:                                    ; preds = %526
  %534 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %535 = bitcast %struct.Token* %534 to i8*
  %536 = bitcast %struct.Token* %529 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %535, i8* nonnull %536, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %530, align 8, !tbaa !263
  br label %540

; <label>:537:                                    ; preds = %526
  %538 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %539 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %538) #17
  store i32 %539, i32* %22, align 8, !tbaa !260
  br label %540

; <label>:540:                                    ; preds = %533, %537
  %541 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #16
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 288) #17
  br label %542

; <label>:542:                                    ; preds = %544, %540
  %543 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %543, label %545 [
    i32 288, label %544
    i32 59, label %544
  ]

; <label>:544:                                    ; preds = %542, %542
  tail call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br label %542

; <label>:545:                                    ; preds = %542
  %546 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %547 = load %struct.Dyndata*, %struct.Dyndata** %546, align 8, !tbaa !256
  %548 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %549 = load %struct.FuncState*, %struct.FuncState** %548, align 8, !tbaa !273
  %550 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %549, i64 0, i32 11
  %551 = load i32, i32* %550, align 4, !tbaa !281
  %552 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %547, i64 0, i32 2, i32 1
  %553 = load i32, i32* %552, align 8, !tbaa !257
  %554 = icmp slt i32 %551, %553
  br i1 %554, label %555, label %577

; <label>:555:                                    ; preds = %545
  %556 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %547, i64 0, i32 2, i32 0
  %557 = load %struct.Labeldesc*, %struct.Labeldesc** %556, align 8, !tbaa !307
  %558 = sext i32 %551 to i64
  %559 = sext i32 %553 to i64
  br label %562

; <label>:560:                                    ; preds = %562
  %561 = icmp slt i64 %568, %559
  br i1 %561, label %562, label %577

; <label>:562:                                    ; preds = %560, %555
  %563 = phi i64 [ %558, %555 ], [ %568, %560 ]
  %564 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %557, i64 %563
  %565 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %564, i64 0, i32 0
  %566 = load %struct.TString*, %struct.TString** %565, align 8, !tbaa !308
  %567 = icmp eq %struct.TString* %566, %541
  %568 = add nsw i64 %563, 1
  br i1 %567, label %569, label %560

; <label>:569:                                    ; preds = %562
  %570 = icmp eq %struct.Labeldesc* %564, null
  br i1 %570, label %577, label %571, !prof !73

; <label>:571:                                    ; preds = %569
  %572 = load %struct.lua_State*, %struct.lua_State** %20, align 8, !tbaa !261
  %573 = getelementptr inbounds %struct.TString, %struct.TString* %541, i64 1
  %574 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %557, i64 %563, i32 2
  %575 = load i32, i32* %574, align 4, !tbaa !310
  %576 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %572, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.278, i64 0, i64 0), %struct.TString* nonnull %573, i32 %575) #17
  tail call fastcc void @luaK_semerror(%struct.LexState* %0, i8* %576) #19
  unreachable

; <label>:577:                                    ; preds = %560, %569, %545
  switch i32 %543, label %579 [
    i32 260, label %580
    i32 261, label %580
    i32 262, label %580
    i32 289, label %580
    i32 277, label %578
  ]

; <label>:578:                                    ; preds = %577
  br label %580

; <label>:579:                                    ; preds = %577
  br label %580

; <label>:580:                                    ; preds = %577, %577, %577, %577, %578, %579
  %581 = phi i32 [ 0, %579 ], [ 0, %578 ], [ 1, %577 ], [ 1, %577 ], [ 1, %577 ], [ 1, %577 ]
  %582 = tail call fastcc i32 @createlabel(%struct.LexState* %0, %struct.TString* %541, i32 %19, i32 %581) #17
  br label %782

; <label>:583:                                    ; preds = %1
  %584 = load i32, i32* %18, align 4, !tbaa !265
  %585 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %584, i32* %585, align 8, !tbaa !266
  %586 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %587 = getelementptr inbounds %struct.Token, %struct.Token* %586, i64 0, i32 0
  %588 = load i32, i32* %587, align 8, !tbaa !263
  %589 = icmp eq i32 %588, 289
  br i1 %589, label %595, label %590

; <label>:590:                                    ; preds = %583
  %591 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %592 = bitcast %struct.Token* %591 to i8*
  %593 = bitcast %struct.Token* %586 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %592, i8* nonnull %593, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %587, align 8, !tbaa !263
  %594 = load i32, i32* %22, align 8, !tbaa !260
  br label %598

; <label>:595:                                    ; preds = %583
  %596 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %597 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %596) #17
  store i32 %597, i32* %22, align 8, !tbaa !260
  br label %598

; <label>:598:                                    ; preds = %590, %595
  %599 = phi i32 [ %594, %590 ], [ %597, %595 ]
  %600 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %601 = load %struct.FuncState*, %struct.FuncState** %600, align 8, !tbaa !273
  %602 = bitcast %struct.expdesc* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %602) #7
  %603 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %601, i64 0, i32 13
  %604 = load i8, i8* %603, align 2, !tbaa !298
  %605 = zext i8 %604 to i32
  switch i32 %599, label %606 [
    i32 260, label %642
    i32 261, label %642
    i32 262, label %642
    i32 289, label %642
    i32 277, label %642
    i32 59, label %642
  ]

; <label>:606:                                    ; preds = %598
  %607 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %7) #17
  %608 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %7, i64 0, i32 0
  %609 = load i32, i32* %608, align 8, !tbaa !294
  %610 = and i32 %609, -2
  %611 = icmp eq i32 %610, 16
  br i1 %611, label %612, label %636

; <label>:612:                                    ; preds = %606
  call fastcc void @luaK_setreturns(%struct.FuncState* %601, %struct.expdesc* nonnull %7, i32 -1) #17
  %613 = load i32, i32* %608, align 8, !tbaa !294
  %614 = icmp eq i32 %613, 16
  %615 = icmp eq i32 %607, 1
  %616 = and i1 %615, %614
  br i1 %616, label %617, label %643

; <label>:617:                                    ; preds = %612
  %618 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %601, i64 0, i32 3
  %619 = load %struct.BlockCnt*, %struct.BlockCnt** %618, align 8, !tbaa !290
  %620 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %619, i64 0, i32 6
  %621 = load i8, i8* %620, align 1, !tbaa !288
  %622 = icmp eq i8 %621, 0
  br i1 %622, label %623, label %643

; <label>:623:                                    ; preds = %617
  %624 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %601, i64 0, i32 0
  %625 = load %struct.Proto*, %struct.Proto** %624, align 8, !tbaa !253
  %626 = getelementptr inbounds %struct.Proto, %struct.Proto* %625, i64 0, i32 16
  %627 = load i32*, i32** %626, align 8, !tbaa !116
  %628 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %7, i64 0, i32 1
  %629 = bitcast %union.anon.8* %628 to i32*
  %630 = load i32, i32* %629, align 8, !tbaa !21
  %631 = sext i32 %630 to i64
  %632 = getelementptr inbounds i32, i32* %627, i64 %631
  %633 = load i32, i32* %632, align 4, !tbaa !77
  %634 = and i32 %633, -128
  %635 = or i32 %634, 70
  store i32 %635, i32* %632, align 4, !tbaa !77
  br label %643

; <label>:636:                                    ; preds = %606
  %637 = icmp eq i32 %607, 1
  br i1 %637, label %638, label %640

; <label>:638:                                    ; preds = %636
  %639 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %601, %struct.expdesc* nonnull %7) #17
  br label %643

; <label>:640:                                    ; preds = %636
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %601, %struct.expdesc* nonnull %7) #17
  %641 = icmp eq i32 %607, 0
  br i1 %641, label %642, label %643

; <label>:642:                                    ; preds = %598, %598, %598, %598, %598, %598, %640
  br label %643

; <label>:643:                                    ; preds = %617, %623, %612, %638, %640, %642
  %644 = phi i32 [ 0, %642 ], [ %607, %640 ], [ 1, %638 ], [ -1, %612 ], [ -1, %623 ], [ -1, %617 ]
  %645 = phi i32 [ %605, %642 ], [ %605, %640 ], [ %639, %638 ], [ %605, %612 ], [ %605, %623 ], [ %605, %617 ]
  %646 = phi i32 [ 72, %642 ], [ 71, %640 ], [ 73, %638 ], [ 71, %612 ], [ 71, %623 ], [ 71, %617 ]
  %647 = shl i32 %645, 7
  %648 = shl i32 %644, 16
  %649 = add i32 %648, 65536
  %650 = or i32 %649, %647
  %651 = or i32 %650, %646
  %652 = call fastcc i32 @luaK_code(%struct.FuncState* %601, i32 %651) #17
  %653 = load i32, i32* %22, align 8, !tbaa !260
  %654 = icmp eq i32 %653, 59
  br i1 %654, label %655, label %666

; <label>:655:                                    ; preds = %643
  %656 = load i32, i32* %18, align 4, !tbaa !265
  store i32 %656, i32* %585, align 8, !tbaa !266
  %657 = load i32, i32* %587, align 8, !tbaa !263
  %658 = icmp eq i32 %657, 289
  br i1 %658, label %663, label %659

; <label>:659:                                    ; preds = %655
  %660 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %661 = bitcast %struct.Token* %660 to i8*
  %662 = bitcast %struct.Token* %586 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %661, i8* nonnull %662, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %587, align 8, !tbaa !263
  br label %666

; <label>:663:                                    ; preds = %655
  %664 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %665 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %664) #17
  store i32 %665, i32* %22, align 8, !tbaa !260
  br label %666

; <label>:666:                                    ; preds = %663, %659, %643
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %602) #7
  br label %782

; <label>:667:                                    ; preds = %1
  %668 = load i32, i32* %18, align 4, !tbaa !265
  %669 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %668, i32* %669, align 8, !tbaa !266
  %670 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %671 = getelementptr inbounds %struct.Token, %struct.Token* %670, i64 0, i32 0
  %672 = load i32, i32* %671, align 8, !tbaa !263
  %673 = icmp eq i32 %672, 289
  br i1 %673, label %678, label %674

; <label>:674:                                    ; preds = %667
  %675 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %676 = bitcast %struct.Token* %675 to i8*
  %677 = bitcast %struct.Token* %670 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %676, i8* nonnull %677, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %671, align 8, !tbaa !263
  br label %681

; <label>:678:                                    ; preds = %667
  %679 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %680 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %679) #17
  store i32 %680, i32* %22, align 8, !tbaa !260
  br label %681

; <label>:681:                                    ; preds = %674, %678
  %682 = load %struct.lua_State*, %struct.lua_State** %20, align 8, !tbaa !261
  %683 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %682, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #17
  %684 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %685 = load %struct.FuncState*, %struct.FuncState** %684, align 8, !tbaa !273
  %686 = tail call fastcc i32 @luaK_code(%struct.FuncState* %685, i32 2147483449) #17
  %687 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %688 = load %struct.Dyndata*, %struct.Dyndata** %687, align 8, !tbaa !256
  %689 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %688, i64 0, i32 1
  %690 = tail call fastcc i32 @newlabelentry(%struct.LexState* nonnull %0, %struct.Labellist* nonnull %689, %struct.TString* %683, i32 %668, i32 %686) #17
  br label %782

; <label>:691:                                    ; preds = %1
  %692 = load i32, i32* %18, align 4, !tbaa !265
  %693 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %692, i32* %693, align 8, !tbaa !266
  %694 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %695 = getelementptr inbounds %struct.Token, %struct.Token* %694, i64 0, i32 0
  %696 = load i32, i32* %695, align 8, !tbaa !263
  %697 = icmp eq i32 %696, 289
  br i1 %697, label %702, label %698

; <label>:698:                                    ; preds = %691
  %699 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %700 = bitcast %struct.Token* %699 to i8*
  %701 = bitcast %struct.Token* %694 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %700, i8* nonnull %701, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %695, align 8, !tbaa !263
  br label %706

; <label>:702:                                    ; preds = %691
  %703 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %704 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %703) #17
  store i32 %704, i32* %22, align 8, !tbaa !260
  %705 = load i32, i32* %18, align 4, !tbaa !265
  br label %706

; <label>:706:                                    ; preds = %698, %702
  %707 = phi i32 [ %692, %698 ], [ %705, %702 ]
  %708 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %709 = load %struct.FuncState*, %struct.FuncState** %708, align 8, !tbaa !273
  %710 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %711 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %712 = load %struct.Dyndata*, %struct.Dyndata** %711, align 8, !tbaa !256
  %713 = load %struct.FuncState*, %struct.FuncState** %708, align 8, !tbaa !273
  %714 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %713, i64 0, i32 11
  %715 = load i32, i32* %714, align 4, !tbaa !281
  %716 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %712, i64 0, i32 2, i32 1
  %717 = load i32, i32* %716, align 8, !tbaa !257
  %718 = icmp slt i32 %715, %717
  br i1 %718, label %719, label %735

; <label>:719:                                    ; preds = %706
  %720 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %712, i64 0, i32 2, i32 0
  %721 = load %struct.Labeldesc*, %struct.Labeldesc** %720, align 8, !tbaa !307
  %722 = sext i32 %715 to i64
  %723 = sext i32 %717 to i64
  br label %726

; <label>:724:                                    ; preds = %726
  %725 = icmp slt i64 %732, %723
  br i1 %725, label %726, label %735

; <label>:726:                                    ; preds = %724, %719
  %727 = phi i64 [ %722, %719 ], [ %732, %724 ]
  %728 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %721, i64 %727
  %729 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %728, i64 0, i32 0
  %730 = load %struct.TString*, %struct.TString** %729, align 8, !tbaa !308
  %731 = icmp eq %struct.TString* %730, %710
  %732 = add nsw i64 %727, 1
  br i1 %731, label %733, label %724

; <label>:733:                                    ; preds = %726
  %734 = icmp eq %struct.Labeldesc* %728, null
  br i1 %734, label %735, label %740

; <label>:735:                                    ; preds = %724, %733, %706
  %736 = tail call fastcc i32 @luaK_code(%struct.FuncState* %709, i32 2147483449) #17
  %737 = load %struct.Dyndata*, %struct.Dyndata** %711, align 8, !tbaa !256
  %738 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %737, i64 0, i32 1
  %739 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %738, %struct.TString* %710, i32 %707, i32 %736) #17
  br label %782

; <label>:740:                                    ; preds = %733
  %741 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %709, i64 0, i32 13
  %742 = load i8, i8* %741, align 2, !tbaa !298
  %743 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %721, i64 %727, i32 3
  %744 = load i8, i8* %743, align 8, !tbaa !311
  %745 = icmp ugt i8 %742, %744
  br i1 %745, label %746, label %751

; <label>:746:                                    ; preds = %740
  %747 = zext i8 %744 to i32
  %748 = shl nuw nsw i32 %747, 7
  %749 = or i32 %748, 55
  %750 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %709, i32 %749) #17
  br label %751

; <label>:751:                                    ; preds = %746, %740
  %752 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %709, i32 2147483449) #17
  %753 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %721, i64 %727, i32 1
  %754 = load i32, i32* %753, align 8, !tbaa !312
  tail call fastcc void @patchlistaux(%struct.FuncState* nonnull %709, i32 %752, i32 %754, i32 255, i32 %754) #17
  br label %782

; <label>:755:                                    ; preds = %1
  %756 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %757 = load %struct.FuncState*, %struct.FuncState** %756, align 8, !tbaa !273
  %758 = bitcast %struct.LHS_assign* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %758) #7
  %759 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %6, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %759) #17
  %760 = load i32, i32* %22, align 8, !tbaa !260
  switch i32 %760, label %763 [
    i32 61, label %761
    i32 44, label %761
  ]

; <label>:761:                                    ; preds = %755, %755
  %762 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %6, i64 0, i32 0
  store %struct.LHS_assign* null, %struct.LHS_assign** %762, align 8, !tbaa !313
  call fastcc void @restassign(%struct.LexState* nonnull %0, %struct.LHS_assign* nonnull %6, i32 1) #17
  br label %781

; <label>:763:                                    ; preds = %755
  %764 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %757, i64 0, i32 0
  %765 = load %struct.Proto*, %struct.Proto** %764, align 8, !tbaa !253
  %766 = getelementptr inbounds %struct.Proto, %struct.Proto* %765, i64 0, i32 16
  %767 = load i32*, i32** %766, align 8, !tbaa !116
  %768 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %6, i64 0, i32 1, i32 1
  %769 = bitcast %union.anon.8* %768 to i32*
  %770 = load i32, i32* %769, align 8, !tbaa !21
  %771 = sext i32 %770 to i64
  %772 = getelementptr inbounds i32, i32* %767, i64 %771
  %773 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %759, i64 0, i32 0
  %774 = load i32, i32* %773, align 8, !tbaa !315
  %775 = icmp eq i32 %774, 16
  br i1 %775, label %777, label %776

; <label>:776:                                    ; preds = %763
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #19
  unreachable

; <label>:777:                                    ; preds = %763
  %778 = load i32, i32* %772, align 4, !tbaa !77
  %779 = and i32 %778, 16777215
  %780 = or i32 %779, 16777216
  store i32 %780, i32* %772, align 4, !tbaa !77
  br label %781

; <label>:781:                                    ; preds = %761, %777
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %758) #7
  br label %782

; <label>:782:                                    ; preds = %751, %735, %524, %471, %35, %31, %405, %781, %681, %666, %580, %370, %347, %270, %131, %111, %60
  %783 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %784 = load %struct.FuncState*, %struct.FuncState** %783, align 8, !tbaa !273
  %785 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %784, i64 0, i32 13
  %786 = load i8, i8* %785, align 2, !tbaa !298
  %787 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %784, i64 0, i32 15
  store i8 %786, i8* %787, align 4, !tbaa !303
  %788 = load %struct.lua_State*, %struct.lua_State** %20, align 8, !tbaa !261
  %789 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %788, i64 0, i32 19
  %790 = load i32, i32* %789, align 8, !tbaa !29
  %791 = add i32 %790, -1
  store i32 %791, i32* %789, align 8, !tbaa !29
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @block(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.BlockCnt, align 8
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !273
  %5 = bitcast %struct.BlockCnt* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 5
  store i8 0, i8* %6, align 2, !tbaa !282
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 13
  %8 = load i8, i8* %7, align 2, !tbaa !298
  %9 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 3
  store i8 %8, i8* %9, align 8, !tbaa !284
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 2
  %11 = load %struct.LexState*, %struct.LexState** %10, align 8, !tbaa !272
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %11, i64 0, i32 10
  %13 = load %struct.Dyndata*, %struct.Dyndata** %12, align 8, !tbaa !256
  %14 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %13, i64 0, i32 2, i32 1
  %15 = load i32, i32* %14, align 8, !tbaa !257
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 1
  store i32 %15, i32* %16, align 8, !tbaa !285
  %17 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %13, i64 0, i32 1, i32 1
  %18 = load i32, i32* %17, align 8, !tbaa !258
  %19 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 2
  store i32 %18, i32* %19, align 4, !tbaa !286
  %20 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 4
  store i8 0, i8* %20, align 1, !tbaa !287
  %21 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 3
  %22 = load %struct.BlockCnt*, %struct.BlockCnt** %21, align 8, !tbaa !290
  %23 = icmp eq %struct.BlockCnt* %22, null
  %24 = ptrtoint %struct.BlockCnt* %22 to i64
  br i1 %23, label %30, label %25

; <label>:25:                                     ; preds = %1
  %26 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %22, i64 0, i32 6
  %27 = load i8, i8* %26, align 1, !tbaa !288
  %28 = icmp ne i8 %27, 0
  %29 = zext i1 %28 to i8
  br label %30

; <label>:30:                                     ; preds = %1, %25
  %31 = phi i8 [ 0, %1 ], [ %29, %25 ]
  %32 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %2, i64 0, i32 6
  store i8 %31, i8* %32, align 1, !tbaa !288
  %33 = bitcast %struct.BlockCnt* %2 to i64*
  store i64 %24, i64* %33, align 8, !tbaa !289
  store %struct.BlockCnt* %2, %struct.BlockCnt** %21, align 8, !tbaa !290
  %34 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %35

; <label>:35:                                     ; preds = %37, %30
  %36 = load i32, i32* %34, align 8, !tbaa !260
  switch i32 %36, label %37 [
    i32 260, label %39
    i32 261, label %39
    i32 262, label %39
    i32 289, label %39
    i32 277, label %39
  ]

; <label>:37:                                     ; preds = %35
  %38 = icmp eq i32 %36, 274
  call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br i1 %38, label %39, label %35

; <label>:39:                                     ; preds = %35, %35, %35, %35, %35, %37
  call fastcc void @leaveblock(%struct.FuncState* %4) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @check_match(%struct.LexState*, i32, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !260
  %7 = icmp eq i32 %6, %1
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  br i1 %7, label %10, label %23

; <label>:10:                                     ; preds = %4
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %9, i32* %11, align 8, !tbaa !266
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %13 = getelementptr inbounds %struct.Token, %struct.Token* %12, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !263
  %15 = icmp eq i32 %14, 289
  br i1 %15, label %20, label %16

; <label>:16:                                     ; preds = %10
  %17 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %18 = bitcast %struct.Token* %17 to i8*
  %19 = bitcast %struct.Token* %12 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %18, i8* nonnull %19, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %13, align 8, !tbaa !263
  br label %32

; <label>:20:                                     ; preds = %10
  %21 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %22 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %21) #17
  store i32 %22, i32* %5, align 8, !tbaa !260
  br label %32

; <label>:23:                                     ; preds = %4
  %24 = icmp eq i32 %9, %3
  br i1 %24, label %25, label %26

; <label>:25:                                     ; preds = %23
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #18
  unreachable

; <label>:26:                                     ; preds = %23
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %28 = load %struct.lua_State*, %struct.lua_State** %27, align 8, !tbaa !261
  %29 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %1) #16
  %30 = tail call fastcc i8* @luaX_token2str(%struct.LexState* nonnull %0, i32 %2) #16
  %31 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %28, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.266, i64 0, i64 0), i8* %29, i8* %30, i32 %3) #16
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* %31) #18
  unreachable

; <label>:32:                                     ; preds = %16, %20
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.TString* @str_checkname(%struct.LexState*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %3 = load i32, i32* %2, align 8, !tbaa !260
  %4 = icmp eq i32 %3, 292
  br i1 %4, label %6, label %5

; <label>:5:                                      ; preds = %1
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 292) #19
  unreachable

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %8 = bitcast %union.SemInfo* %7 to %struct.TString**
  %9 = load %struct.TString*, %struct.TString** %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %11 = load i32, i32* %10, align 4, !tbaa !265
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %11, i32* %12, align 8, !tbaa !266
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %14 = getelementptr inbounds %struct.Token, %struct.Token* %13, i64 0, i32 0
  %15 = load i32, i32* %14, align 8, !tbaa !263
  %16 = icmp eq i32 %15, 289
  br i1 %16, label %21, label %17

; <label>:17:                                     ; preds = %6
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %19 = bitcast %struct.Token* %18 to i8*
  %20 = bitcast %struct.Token* %13 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %19, i8* nonnull %20, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %14, align 8, !tbaa !263
  br label %23

; <label>:21:                                     ; preds = %6
  %22 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %7) #17
  store i32 %22, i32* %2, align 8, !tbaa !260
  br label %23

; <label>:23:                                     ; preds = %17, %21
  ret %struct.TString* %9
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @test_then_block(%struct.LexState*, i32* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.BlockCnt, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = bitcast %struct.BlockCnt* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  %8 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %10 = load i32, i32* %9, align 4, !tbaa !265
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %10, i32* %11, align 8, !tbaa !266
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %13 = getelementptr inbounds %struct.Token, %struct.Token* %12, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !263
  %15 = icmp eq i32 %14, 289
  br i1 %15, label %21, label %16

; <label>:16:                                     ; preds = %2
  %17 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %18 = bitcast %struct.Token* %17 to i8*
  %19 = bitcast %struct.Token* %12 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %18, i8* nonnull %19, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %13, align 8, !tbaa !263
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  br label %25

; <label>:21:                                     ; preds = %2
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %23 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %22) #17
  %24 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 %23, i32* %24, align 8, !tbaa !260
  br label %25

; <label>:25:                                     ; preds = %16, %21
  %26 = phi i32* [ %20, %16 ], [ %24, %21 ]
  %27 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4, i32 0) #17
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 275) #16
  %28 = load i32, i32* %9, align 4, !tbaa !265
  %29 = load i32, i32* %26, align 8, !tbaa !260
  switch i32 %29, label %159 [
    i32 258, label %30
    i32 266, label %44
  ]

; <label>:30:                                     ; preds = %25
  store i32 %28, i32* %11, align 8, !tbaa !266
  %31 = load i32, i32* %13, align 8, !tbaa !263
  %32 = icmp eq i32 %31, 289
  br i1 %32, label %37, label %33

; <label>:33:                                     ; preds = %30
  %34 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %35 = bitcast %struct.Token* %34 to i8*
  %36 = bitcast %struct.Token* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %35, i8* nonnull %36, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %13, align 8, !tbaa !263
  br label %40

; <label>:37:                                     ; preds = %30
  %38 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %39 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %38) #17
  store i32 %39, i32* %26, align 8, !tbaa !260
  br label %40

; <label>:40:                                     ; preds = %37, %33
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %42 = load %struct.lua_State*, %struct.lua_State** %41, align 8, !tbaa !261
  %43 = call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %42, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #17
  br label %94

; <label>:44:                                     ; preds = %25
  %45 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %46 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %45) #17
  %47 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 0
  store i32 %46, i32* %47, align 8, !tbaa !263
  %48 = icmp eq i32 %46, 292
  br i1 %48, label %49, label %159

; <label>:49:                                     ; preds = %44
  %50 = bitcast %union.SemInfo* %45 to %struct.TString**
  %51 = load %struct.TString*, %struct.TString** %50, align 8, !tbaa !21
  %52 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %53 = load %struct.Dyndata*, %struct.Dyndata** %52, align 8, !tbaa !256
  %54 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  %55 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %54, i64 0, i32 11
  %56 = load i32, i32* %55, align 4, !tbaa !281
  %57 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %53, i64 0, i32 2, i32 1
  %58 = load i32, i32* %57, align 8, !tbaa !257
  %59 = icmp slt i32 %56, %58
  br i1 %59, label %60, label %85

; <label>:60:                                     ; preds = %49
  %61 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %53, i64 0, i32 2, i32 0
  %62 = load %struct.Labeldesc*, %struct.Labeldesc** %61, align 8, !tbaa !307
  %63 = sext i32 %56 to i64
  %64 = sext i32 %58 to i64
  br label %67

; <label>:65:                                     ; preds = %67
  %66 = icmp slt i64 %73, %64
  br i1 %66, label %67, label %85

; <label>:67:                                     ; preds = %65, %60
  %68 = phi i64 [ %63, %60 ], [ %73, %65 ]
  %69 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %68
  %70 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %69, i64 0, i32 0
  %71 = load %struct.TString*, %struct.TString** %70, align 8, !tbaa !308
  %72 = icmp eq %struct.TString* %71, %51
  %73 = add nsw i64 %68, 1
  br i1 %72, label %74, label %65

; <label>:74:                                     ; preds = %67
  %75 = icmp eq %struct.Labeldesc* %69, null
  br i1 %75, label %85, label %76

; <label>:76:                                     ; preds = %74
  %77 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %54, i64 0, i32 13
  %78 = load i8, i8* %77, align 2, !tbaa !298
  %79 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %68, i32 3
  %80 = load i8, i8* %79, align 8, !tbaa !311
  %81 = icmp ugt i8 %78, %80
  br i1 %81, label %159, label %82

; <label>:82:                                     ; preds = %76
  %83 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %68, i32 1
  %84 = load i32, i32* %83, align 8, !tbaa !312
  br label %85

; <label>:85:                                     ; preds = %65, %49, %74, %82
  %86 = phi %struct.TString* [ null, %82 ], [ %51, %74 ], [ %51, %49 ], [ %51, %65 ]
  %87 = phi i32 [ %84, %82 ], [ -1, %74 ], [ -1, %49 ], [ -1, %65 ]
  %88 = load i32, i32* %9, align 4, !tbaa !265
  store i32 %88, i32* %11, align 8, !tbaa !266
  %89 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %90 = bitcast %struct.Token* %89 to i8*
  %91 = bitcast %struct.Token* %12 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %90, i8* nonnull %91, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %13, align 8, !tbaa !263
  store i32 %88, i32* %11, align 8, !tbaa !266
  %92 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %93 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %92) #17
  store i32 %93, i32* %26, align 8, !tbaa !260
  br label %94

; <label>:94:                                     ; preds = %85, %40
  %95 = phi %struct.TString* [ %86, %85 ], [ %43, %40 ]
  %96 = phi i32 [ %87, %85 ], [ -1, %40 ]
  %97 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  call fastcc void @luaK_goiffalse(%struct.FuncState* %97, %struct.expdesc* nonnull %4) #16
  %98 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  store i8 0, i8* %98, align 2, !tbaa !282
  %99 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 13
  %100 = load i8, i8* %99, align 2, !tbaa !298
  %101 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  store i8 %100, i8* %101, align 8, !tbaa !284
  %102 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 2
  %103 = load %struct.LexState*, %struct.LexState** %102, align 8, !tbaa !272
  %104 = getelementptr inbounds %struct.LexState, %struct.LexState* %103, i64 0, i32 10
  %105 = load %struct.Dyndata*, %struct.Dyndata** %104, align 8, !tbaa !256
  %106 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %105, i64 0, i32 2, i32 1
  %107 = load i32, i32* %106, align 8, !tbaa !257
  %108 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  store i32 %107, i32* %108, align 8, !tbaa !285
  %109 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %105, i64 0, i32 1, i32 1
  %110 = load i32, i32* %109, align 8, !tbaa !258
  %111 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  store i32 %110, i32* %111, align 4, !tbaa !286
  %112 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  store i8 0, i8* %112, align 1, !tbaa !287
  %113 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 3
  %114 = load %struct.BlockCnt*, %struct.BlockCnt** %113, align 8, !tbaa !290
  %115 = icmp eq %struct.BlockCnt* %114, null
  %116 = ptrtoint %struct.BlockCnt* %114 to i64
  br i1 %115, label %122, label %117

; <label>:117:                                    ; preds = %94
  %118 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %114, i64 0, i32 6
  %119 = load i8, i8* %118, align 1, !tbaa !288
  %120 = icmp ne i8 %119, 0
  %121 = zext i1 %120 to i8
  br label %122

; <label>:122:                                    ; preds = %94, %117
  %123 = phi i8 [ 0, %94 ], [ %121, %117 ]
  %124 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 6
  store i8 %123, i8* %124, align 1, !tbaa !288
  %125 = bitcast %struct.BlockCnt* %3 to i64*
  store i64 %116, i64* %125, align 8, !tbaa !289
  store %struct.BlockCnt* %3, %struct.BlockCnt** %113, align 8, !tbaa !290
  %126 = icmp eq %struct.TString* %95, null
  %127 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  %128 = load i32, i32* %127, align 8, !tbaa !291
  br i1 %126, label %134, label %129

; <label>:129:                                    ; preds = %122
  %130 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %131 = load %struct.Dyndata*, %struct.Dyndata** %130, align 8, !tbaa !256
  %132 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %131, i64 0, i32 1
  %133 = call fastcc i32 @newlabelentry(%struct.LexState* nonnull %0, %struct.Labellist* nonnull %132, %struct.TString* nonnull %95, i32 %28, i32 %128) #17
  br label %135

; <label>:134:                                    ; preds = %122
  call fastcc void @patchlistaux(%struct.FuncState* nonnull %7, i32 %128, i32 %96, i32 255, i32 %96) #17
  br label %135

; <label>:135:                                    ; preds = %134, %129
  %136 = load i32, i32* %26, align 8, !tbaa !260
  %137 = icmp eq i32 %136, 59
  br i1 %137, label %138, label %154

; <label>:138:                                    ; preds = %135
  %139 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %140 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %141 = bitcast %struct.Token* %140 to i8*
  %142 = bitcast %struct.Token* %12 to i8*
  br label %143

; <label>:143:                                    ; preds = %138, %151
  %144 = load i32, i32* %9, align 4, !tbaa !265
  store i32 %144, i32* %11, align 8, !tbaa !266
  %145 = load i32, i32* %13, align 8, !tbaa !263
  %146 = icmp eq i32 %145, 289
  br i1 %146, label %149, label %147

; <label>:147:                                    ; preds = %143
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %141, i8* nonnull %142, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %13, align 8, !tbaa !263
  %148 = load i32, i32* %26, align 8, !tbaa !260
  br label %151

; <label>:149:                                    ; preds = %143
  %150 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %139) #17
  store i32 %150, i32* %26, align 8, !tbaa !260
  br label %151

; <label>:151:                                    ; preds = %147, %149
  %152 = phi i32 [ %148, %147 ], [ %150, %149 ]
  %153 = icmp eq i32 %152, 59
  br i1 %153, label %143, label %154

; <label>:154:                                    ; preds = %151, %135
  %155 = phi i32 [ %136, %135 ], [ %152, %151 ]
  switch i32 %155, label %157 [
    i32 260, label %156
    i32 261, label %156
    i32 262, label %156
    i32 289, label %156
  ]

; <label>:156:                                    ; preds = %154, %154, %154, %154
  call fastcc void @leaveblock(%struct.FuncState* %7) #16
  br label %207

; <label>:157:                                    ; preds = %154
  %158 = call fastcc i32 @luaK_code(%struct.FuncState* %7, i32 2147483449) #17
  br label %191

; <label>:159:                                    ; preds = %44, %76, %25
  %160 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  call fastcc void @luaK_goiftrue(%struct.FuncState* %160, %struct.expdesc* nonnull %4) #16
  %161 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  store i8 0, i8* %161, align 2, !tbaa !282
  %162 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 13
  %163 = load i8, i8* %162, align 2, !tbaa !298
  %164 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  store i8 %163, i8* %164, align 8, !tbaa !284
  %165 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 2
  %166 = load %struct.LexState*, %struct.LexState** %165, align 8, !tbaa !272
  %167 = getelementptr inbounds %struct.LexState, %struct.LexState* %166, i64 0, i32 10
  %168 = load %struct.Dyndata*, %struct.Dyndata** %167, align 8, !tbaa !256
  %169 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %168, i64 0, i32 2, i32 1
  %170 = load i32, i32* %169, align 8, !tbaa !257
  %171 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  store i32 %170, i32* %171, align 8, !tbaa !285
  %172 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %168, i64 0, i32 1, i32 1
  %173 = load i32, i32* %172, align 8, !tbaa !258
  %174 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  store i32 %173, i32* %174, align 4, !tbaa !286
  %175 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  store i8 0, i8* %175, align 1, !tbaa !287
  %176 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 3
  %177 = load %struct.BlockCnt*, %struct.BlockCnt** %176, align 8, !tbaa !290
  %178 = icmp eq %struct.BlockCnt* %177, null
  %179 = ptrtoint %struct.BlockCnt* %177 to i64
  br i1 %178, label %185, label %180

; <label>:180:                                    ; preds = %159
  %181 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %177, i64 0, i32 6
  %182 = load i8, i8* %181, align 1, !tbaa !288
  %183 = icmp ne i8 %182, 0
  %184 = zext i1 %183 to i8
  br label %185

; <label>:185:                                    ; preds = %159, %180
  %186 = phi i8 [ 0, %159 ], [ %184, %180 ]
  %187 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 6
  store i8 %186, i8* %187, align 1, !tbaa !288
  %188 = bitcast %struct.BlockCnt* %3 to i64*
  store i64 %179, i64* %188, align 8, !tbaa !289
  store %struct.BlockCnt* %3, %struct.BlockCnt** %176, align 8, !tbaa !290
  %189 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  %190 = load i32, i32* %189, align 4, !tbaa !293
  br label %191

; <label>:191:                                    ; preds = %185, %157
  %192 = phi i32 [ %158, %157 ], [ %190, %185 ]
  br label %193

; <label>:193:                                    ; preds = %195, %191
  %194 = load i32, i32* %26, align 8, !tbaa !260
  switch i32 %194, label %195 [
    i32 260, label %197
    i32 261, label %197
    i32 262, label %197
    i32 289, label %197
    i32 277, label %197
  ]

; <label>:195:                                    ; preds = %193
  %196 = icmp eq i32 %194, 274
  call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br i1 %196, label %197, label %193

; <label>:197:                                    ; preds = %193, %193, %193, %193, %193, %195
  call fastcc void @leaveblock(%struct.FuncState* %7) #16
  %198 = load i32, i32* %26, align 8, !tbaa !260
  %199 = and i32 %198, -2
  %200 = icmp eq i32 %199, 260
  br i1 %200, label %201, label %203

; <label>:201:                                    ; preds = %197
  %202 = call fastcc i32 @luaK_code(%struct.FuncState* %7, i32 2147483449) #17
  call fastcc void @luaK_concat(%struct.FuncState* %7, i32* %1, i32 %202) #16
  br label %203

; <label>:203:                                    ; preds = %197, %201
  %204 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 4
  %205 = load i32, i32* %204, align 8, !tbaa !274
  %206 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 5
  store i32 %205, i32* %206, align 4, !tbaa !276
  call fastcc void @patchlistaux(%struct.FuncState* %7, i32 %192, i32 %205, i32 255, i32 %205) #17
  br label %207

; <label>:207:                                    ; preds = %203, %156
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %5) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checknext(%struct.LexState*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !260
  %5 = icmp eq i32 %4, %1
  br i1 %5, label %7, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @error_expected(%struct.LexState* nonnull %0, i32 %1) #19
  unreachable

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %9, i32* %10, align 8, !tbaa !266
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %12 = getelementptr inbounds %struct.Token, %struct.Token* %11, i64 0, i32 0
  %13 = load i32, i32* %12, align 8, !tbaa !263
  %14 = icmp eq i32 %13, 289
  br i1 %14, label %19, label %15

; <label>:15:                                     ; preds = %7
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %17 = bitcast %struct.Token* %16 to i8*
  %18 = bitcast %struct.Token* %11 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %17, i8* nonnull %18, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %12, align 8, !tbaa !263
  br label %22

; <label>:19:                                     ; preds = %7
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %21 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %20) #17
  store i32 %21, i32* %3, align 8, !tbaa !260
  br label %22

; <label>:22:                                     ; preds = %15, %19
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_goiffalse(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  switch i32 %4, label %9 [
    i32 14, label %5
    i32 1, label %11
    i32 3, label %11
  ]

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  br label %11

; <label>:9:                                      ; preds = %2
  %10 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 1) #16
  br label %11

; <label>:11:                                     ; preds = %2, %2, %9, %5
  %12 = phi i32 [ %10, %9 ], [ %8, %5 ], [ -1, %2 ], [ -1, %2 ]
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %13, i32 %12) #16
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !293
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %17 = load i32, i32* %16, align 8, !tbaa !274
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %17, i32* %18, align 4, !tbaa !276
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %15, i32 %17, i32 255, i32 %17) #17
  store i32 -1, i32* %14, align 4, !tbaa !293
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @leaveblock(%struct.FuncState* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  %3 = load %struct.BlockCnt*, %struct.BlockCnt** %2, align 8, !tbaa !290
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 5
  %7 = load i8, i8* %6, align 2, !tbaa !282
  %8 = icmp eq i8 %7, 0
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !261
  %12 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %11, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #16
  %13 = tail call fastcc i32 @createlabel(%struct.LexState* %5, %struct.TString* %12, i32 0, i32 0) #16
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %15, label %30

; <label>:15:                                     ; preds = %9, %1
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 0
  %17 = load %struct.BlockCnt*, %struct.BlockCnt** %16, align 8, !tbaa !289
  %18 = icmp eq %struct.BlockCnt* %17, null
  br i1 %18, label %30, label %19

; <label>:19:                                     ; preds = %15
  %20 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  %21 = load i8, i8* %20, align 1, !tbaa !287
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %30, label %23

; <label>:23:                                     ; preds = %19
  %24 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %25 = load i8, i8* %24, align 8, !tbaa !284
  %26 = zext i8 %25 to i32
  %27 = shl nuw nsw i32 %26, 7
  %28 = or i32 %27, 55
  %29 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %28) #17
  br label %30

; <label>:30:                                     ; preds = %9, %19, %15, %23
  %31 = bitcast %struct.BlockCnt* %3 to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !289
  %33 = bitcast %struct.BlockCnt** %2 to i64*
  store i64 %32, i64* %33, align 8, !tbaa !290
  %34 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 3
  %35 = load i8, i8* %34, align 8, !tbaa !284
  %36 = zext i8 %35 to i32
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %38 = load i8, i8* %37, align 2, !tbaa !298
  %39 = zext i8 %38 to i32
  %40 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %40, i64 0, i32 10
  %42 = load %struct.Dyndata*, %struct.Dyndata** %41, align 8, !tbaa !256
  %43 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 0, i32 1
  %44 = load i32, i32* %43, align 8, !tbaa !259
  %45 = sub nsw i32 %36, %39
  %46 = add i32 %45, %44
  store i32 %46, i32* %43, align 8, !tbaa !259
  %47 = icmp ult i8 %35, %38
  br i1 %47, label %48, label %73

; <label>:48:                                     ; preds = %30
  %49 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %50 = load i32, i32* %49, align 8, !tbaa !274
  %51 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 0, i32 0
  %52 = load %struct.Vardesc*, %struct.Vardesc** %51, align 8, !tbaa !304
  %53 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 10
  %54 = load i32, i32* %53, align 8, !tbaa !280
  %55 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %56 = load %struct.Proto*, %struct.Proto** %55, align 8, !tbaa !253
  %57 = getelementptr inbounds %struct.Proto, %struct.Proto* %56, i64 0, i32 21
  %58 = load %struct.LocVar*, %struct.LocVar** %57, align 8, !tbaa !110
  br label %59

; <label>:59:                                     ; preds = %59, %48
  %60 = phi i32 [ %71, %59 ], [ %39, %48 ]
  %61 = trunc i32 %60 to i8
  %62 = add i8 %61, -1
  %63 = zext i8 %62 to i32
  %64 = add nsw i32 %54, %63
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %52, i64 %65, i32 0
  %67 = load i16, i16* %66, align 2, !tbaa !305
  %68 = sext i16 %67 to i64
  %69 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %58, i64 %68, i32 2
  store i32 %50, i32* %69, align 4, !tbaa !113
  %70 = icmp ugt i8 %62, %35
  %71 = add nsw i32 %60, -1
  br i1 %70, label %59, label %72

; <label>:72:                                     ; preds = %59
  store i8 %35, i8* %37, align 2, !tbaa !298
  br label %73

; <label>:73:                                     ; preds = %30, %72
  %74 = phi i8 [ %38, %30 ], [ %35, %72 ]
  %75 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %74, i8* %75, align 4, !tbaa !303
  %76 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 1
  %77 = load i32, i32* %76, align 8, !tbaa !285
  %78 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 10
  %79 = load %struct.Dyndata*, %struct.Dyndata** %78, align 8, !tbaa !256
  %80 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %79, i64 0, i32 2, i32 1
  store i32 %77, i32* %80, align 8, !tbaa !257
  %81 = icmp eq i64 %32, 0
  %82 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 2
  %83 = load i32, i32* %82, align 4, !tbaa !286
  br i1 %81, label %107, label %84

; <label>:84:                                     ; preds = %73
  %85 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 1
  %86 = load i32, i32* %85, align 8, !tbaa !316
  %87 = icmp slt i32 %83, %86
  br i1 %87, label %88, label %116

; <label>:88:                                     ; preds = %84
  %89 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %42, i64 0, i32 1, i32 0
  %90 = load %struct.Labeldesc*, %struct.Labeldesc** %89, align 8, !tbaa !317
  %91 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %3, i64 0, i32 4
  %92 = sext i32 %83 to i64
  %93 = sext i32 %86 to i64
  br label %94

; <label>:94:                                     ; preds = %104, %88
  %95 = phi i64 [ %92, %88 ], [ %105, %104 ]
  %96 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %90, i64 %95, i32 3
  %97 = load i8, i8* %96, align 8, !tbaa !311
  %98 = icmp ugt i8 %97, %35
  br i1 %98, label %99, label %104

; <label>:99:                                     ; preds = %94
  store i8 %35, i8* %96, align 8, !tbaa !311
  %100 = load i8, i8* %91, align 1, !tbaa !287
  %101 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %90, i64 %95, i32 4
  %102 = load i8, i8* %101, align 1, !tbaa !318
  %103 = or i8 %102, %100
  store i8 %103, i8* %101, align 1, !tbaa !318
  br label %104

; <label>:104:                                    ; preds = %99, %94
  %105 = add nsw i64 %95, 1
  %106 = icmp eq i64 %105, %93
  br i1 %106, label %116, label %94

; <label>:107:                                    ; preds = %73
  %108 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %79, i64 0, i32 1, i32 1
  %109 = load i32, i32* %108, align 8, !tbaa !258
  %110 = icmp slt i32 %83, %109
  br i1 %110, label %111, label %116

; <label>:111:                                    ; preds = %107
  %112 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %79, i64 0, i32 1, i32 0
  %113 = load %struct.Labeldesc*, %struct.Labeldesc** %112, align 8, !tbaa !319
  %114 = sext i32 %83 to i64
  %115 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %113, i64 %114
  tail call fastcc void @undefgoto(%struct.LexState* nonnull %5, %struct.Labeldesc* %115) #18
  unreachable

; <label>:116:                                    ; preds = %104, %84, %107
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_goiftrue(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  switch i32 %4, label %30 [
    i32 14, label %5
    i32 4, label %32
    i32 5, label %32
    i32 6, label %32
    i32 2, label %32
  ]

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %7 = bitcast %union.anon.8* %6 to i32*
  %8 = load i32, i32* %7, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %10 = load %struct.Proto*, %struct.Proto** %9, align 8, !tbaa !253
  %11 = getelementptr inbounds %struct.Proto, %struct.Proto* %10, i64 0, i32 16
  %12 = load i32*, i32** %11, align 8, !tbaa !116
  %13 = sext i32 %8 to i64
  %14 = getelementptr inbounds i32, i32* %12, i64 %13
  %15 = icmp sgt i32 %8, 0
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %5
  %17 = getelementptr inbounds i32, i32* %14, i64 -1
  %18 = load i32, i32* %17, align 4, !tbaa !77
  %19 = and i32 %18, 127
  %20 = zext i32 %19 to i64
  %21 = add nsw i64 %20, -58
  %22 = icmp ult i64 %21, 11
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %16, %5
  %24 = load i32, i32* %14, align 4, !tbaa !77
  br label %25

; <label>:25:                                     ; preds = %16, %23
  %26 = phi i32 [ %24, %23 ], [ %18, %16 ]
  %27 = phi i32* [ %14, %23 ], [ %17, %16 ]
  %28 = xor i32 %26, 32768
  store i32 %28, i32* %27, align 4, !tbaa !77
  %29 = load i32, i32* %7, align 8, !tbaa !21
  br label %32

; <label>:30:                                     ; preds = %2
  %31 = tail call fastcc i32 @jumponcond(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 0) #16
  br label %32

; <label>:32:                                     ; preds = %2, %2, %2, %2, %30, %25
  %33 = phi i32 [ %31, %30 ], [ %29, %25 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ], [ -1, %2 ]
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %34, i32 %33) #16
  %35 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %36 = load i32, i32* %35, align 8, !tbaa !291
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %38 = load i32, i32* %37, align 8, !tbaa !274
  %39 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %38, i32* %39, align 4, !tbaa !276
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %36, i32 %38, i32 255, i32 %38) #17
  store i32 -1, i32* %35, align 8, !tbaa !291
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_concat(%struct.FuncState* nocapture readonly, i32* nocapture, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, -1
  br i1 %4, label %27, label %5

; <label>:5:                                      ; preds = %3
  %6 = load i32, i32* %1, align 4, !tbaa !77
  %7 = icmp eq i32 %6, -1
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %5
  store i32 %2, i32* %1, align 4, !tbaa !77
  br label %27

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %11 = load %struct.Proto*, %struct.Proto** %10, align 8, !tbaa !253
  %12 = getelementptr inbounds %struct.Proto, %struct.Proto* %11, i64 0, i32 16
  %13 = load i32*, i32** %12, align 8, !tbaa !116
  br label %14

; <label>:14:                                     ; preds = %14, %9
  %15 = phi i32 [ %6, %9 ], [ %24, %14 ]
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds i32, i32* %13, i64 %16
  %18 = load i32, i32* %17, align 4, !tbaa !77
  %19 = lshr i32 %18, 7
  %20 = add nsw i32 %19, -16777215
  %21 = icmp eq i32 %20, -1
  %22 = add nsw i32 %15, 1
  %23 = add nsw i32 %22, %20
  %24 = select i1 %21, i32 -1, i32 %23
  %25 = icmp eq i32 %24, -1
  br i1 %25, label %26, label %14

; <label>:26:                                     ; preds = %14
  tail call fastcc void @fixjump(%struct.FuncState* nonnull %0, i32 %15, i32 %2) #16
  br label %27

; <label>:27:                                     ; preds = %8, %26, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @subexpr(%struct.LexState*, %struct.expdesc*, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = alloca %struct.expdesc, align 8
  %8 = alloca %struct.expdesc, align 8
  %9 = alloca i64, align 8
  %10 = alloca i32, align 4
  %11 = alloca %struct.expdesc, align 8
  %12 = alloca %struct.expdesc, align 8
  %13 = alloca %struct.expdesc, align 8
  %14 = alloca %struct.expdesc, align 8
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %16 = load %struct.lua_State*, %struct.lua_State** %15, align 8, !tbaa !261
  tail call fastcc void @luaE_enterCcall(%struct.lua_State* %16) #16
  %17 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %18 = load i32, i32* %17, align 8, !tbaa !260
  switch i32 %18, label %218 [
    i32 271, label %22
    i32 45, label %19
    i32 126, label %20
    i32 35, label %21
    i32 290, label %127
    i32 291, label %137
    i32 293, label %147
    i32 270, label %165
    i32 276, label %171
    i32 263, label %177
    i32 281, label %183
    i32 123, label %199
    i32 265, label %200
  ]

; <label>:19:                                     ; preds = %3
  br label %22

; <label>:20:                                     ; preds = %3
  br label %22

; <label>:21:                                     ; preds = %3
  br label %22

; <label>:22:                                     ; preds = %3, %21, %20, %19
  %23 = phi i32 [ 2, %3 ], [ 0, %19 ], [ 1, %20 ], [ 3, %21 ]
  %24 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %25 = load i32, i32* %24, align 4, !tbaa !265
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %25, i32* %26, align 8, !tbaa !266
  %27 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %28 = getelementptr inbounds %struct.Token, %struct.Token* %27, i64 0, i32 0
  %29 = load i32, i32* %28, align 8, !tbaa !263
  %30 = icmp eq i32 %29, 289
  br i1 %30, label %35, label %31

; <label>:31:                                     ; preds = %22
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %33 = bitcast %struct.Token* %32 to i8*
  %34 = bitcast %struct.Token* %27 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %33, i8* nonnull %34, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %28, align 8, !tbaa !263
  br label %38

; <label>:35:                                     ; preds = %22
  %36 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %37 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %36) #17
  store i32 %37, i32* %17, align 8, !tbaa !260
  br label %38

; <label>:38:                                     ; preds = %31, %35
  %39 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 12) #16
  %40 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %41 = load %struct.FuncState*, %struct.FuncState** %40, align 8, !tbaa !273
  %42 = trunc i32 %23 to i2
  switch i2 %42, label %234 [
    i2 0, label %43
    i2 1, label %43
    i2 -1, label %47
    i2 -2, label %72
  ]

; <label>:43:                                     ; preds = %38, %38
  %44 = or i32 %23, 12
  %45 = tail call fastcc i32 @constfolding(%struct.FuncState* %41, i32 %44, %struct.expdesc* %1, %struct.expdesc* nonnull @luaK_prefix.ef) #17
  %46 = icmp eq i32 %45, 0
  br i1 %46, label %47, label %235

; <label>:47:                                     ; preds = %43, %38
  %48 = phi i32 [ %23, %43 ], [ 3, %38 ]
  %49 = add nsw i32 %48, 50
  %50 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %41, %struct.expdesc* %1) #17
  %51 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %52 = load i32, i32* %51, align 8, !tbaa !294
  %53 = icmp eq i32 %52, 7
  %54 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %55 = bitcast %union.anon.8* %54 to i32*
  br i1 %53, label %56, label %66

; <label>:56:                                     ; preds = %47
  %57 = load i32, i32* %55, align 8, !tbaa !21
  %58 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 13
  %59 = load i8, i8* %58, align 2, !tbaa !298
  %60 = zext i8 %59 to i32
  %61 = icmp slt i32 %57, %60
  br i1 %61, label %66, label %62

; <label>:62:                                     ; preds = %56
  %63 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 15
  %64 = load i8, i8* %63, align 4, !tbaa !303
  %65 = add i8 %64, -1
  store i8 %65, i8* %63, align 4, !tbaa !303
  br label %66

; <label>:66:                                     ; preds = %62, %56, %47
  %67 = shl i32 %50, 16
  %68 = or i32 %67, %49
  %69 = tail call fastcc i32 @luaK_code(%struct.FuncState* %41, i32 %68) #17
  store i32 %69, i32* %55, align 8, !tbaa !21
  store i32 15, i32* %51, align 8, !tbaa !294
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %41) #17
  %70 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 0
  %71 = load %struct.Proto*, %struct.Proto** %70, align 8, !tbaa !253
  tail call fastcc void @savelineinfo(%struct.FuncState* %41, %struct.Proto* %71, i32 %25) #17
  br label %235

; <label>:72:                                     ; preds = %38
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %41, %struct.expdesc* %1) #17
  %73 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %74 = load i32, i32* %73, align 8, !tbaa !294
  switch i32 %74, label %121 [
    i32 1, label %75
    i32 3, label %75
    i32 4, label %76
    i32 5, label %76
    i32 6, label %76
    i32 2, label %76
    i32 14, label %77
    i32 15, label %101
    i32 7, label %101
  ]

; <label>:75:                                     ; preds = %72, %72
  store i32 2, i32* %73, align 8, !tbaa !294
  br label %121

; <label>:76:                                     ; preds = %72, %72, %72, %72
  store i32 3, i32* %73, align 8, !tbaa !294
  br label %121

; <label>:77:                                     ; preds = %72
  %78 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %79 = bitcast %union.anon.8* %78 to i32*
  %80 = load i32, i32* %79, align 8, !tbaa !21
  %81 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 0
  %82 = load %struct.Proto*, %struct.Proto** %81, align 8, !tbaa !253
  %83 = getelementptr inbounds %struct.Proto, %struct.Proto* %82, i64 0, i32 16
  %84 = load i32*, i32** %83, align 8, !tbaa !116
  %85 = sext i32 %80 to i64
  %86 = getelementptr inbounds i32, i32* %84, i64 %85
  %87 = icmp sgt i32 %80, 0
  br i1 %87, label %88, label %95

; <label>:88:                                     ; preds = %77
  %89 = getelementptr inbounds i32, i32* %86, i64 -1
  %90 = load i32, i32* %89, align 4, !tbaa !77
  %91 = and i32 %90, 127
  %92 = zext i32 %91 to i64
  %93 = add nsw i64 %92, -58
  %94 = icmp ult i64 %93, 11
  br i1 %94, label %97, label %95

; <label>:95:                                     ; preds = %88, %77
  %96 = load i32, i32* %86, align 4, !tbaa !77
  br label %97

; <label>:97:                                     ; preds = %95, %88
  %98 = phi i32 [ %96, %95 ], [ %90, %88 ]
  %99 = phi i32* [ %86, %95 ], [ %89, %88 ]
  %100 = xor i32 %98, 32768
  store i32 %100, i32* %99, align 4, !tbaa !77
  br label %121

; <label>:101:                                    ; preds = %72, %72
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %41, %struct.expdesc* nonnull %1) #17
  %102 = load i32, i32* %73, align 8, !tbaa !294
  %103 = icmp eq i32 %102, 7
  %104 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %105 = bitcast %union.anon.8* %104 to i32*
  br i1 %103, label %106, label %116

; <label>:106:                                    ; preds = %101
  %107 = load i32, i32* %105, align 8, !tbaa !21
  %108 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 13
  %109 = load i8, i8* %108, align 2, !tbaa !298
  %110 = zext i8 %109 to i32
  %111 = icmp slt i32 %107, %110
  br i1 %111, label %116, label %112

; <label>:112:                                    ; preds = %106
  %113 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %41, i64 0, i32 15
  %114 = load i8, i8* %113, align 4, !tbaa !303
  %115 = add i8 %114, -1
  store i8 %115, i8* %113, align 4, !tbaa !303
  br label %116

; <label>:116:                                    ; preds = %112, %106, %101
  %117 = load i32, i32* %105, align 8, !tbaa !21
  %118 = shl i32 %117, 16
  %119 = or i32 %118, 52
  %120 = tail call fastcc i32 @luaK_code(%struct.FuncState* %41, i32 %119) #17
  store i32 %120, i32* %105, align 8, !tbaa !21
  store i32 15, i32* %73, align 8, !tbaa !294
  br label %121

; <label>:121:                                    ; preds = %116, %97, %76, %75, %72
  %122 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %123 = load i32, i32* %122, align 4, !tbaa !293
  %124 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %125 = load i32, i32* %124, align 8, !tbaa !291
  store i32 %125, i32* %122, align 4, !tbaa !293
  store i32 %123, i32* %124, align 8, !tbaa !291
  tail call fastcc void @removevalues(%struct.FuncState* %41, i32 %125) #17
  %126 = load i32, i32* %124, align 8, !tbaa !291
  tail call fastcc void @removevalues(%struct.FuncState* %41, i32 %126) #17
  br label %235

; <label>:127:                                    ; preds = %3
  %128 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %128, align 8, !tbaa !291
  %129 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %129, align 4, !tbaa !293
  %130 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 5, i32* %130, align 8, !tbaa !294
  %131 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %132 = bitcast %union.anon.8* %131 to i32*
  store i32 0, i32* %132, align 8, !tbaa !21
  %133 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1, i32 0
  %134 = bitcast double* %133 to i64*
  %135 = load i64, i64* %134, align 8, !tbaa !21
  %136 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %135, i64* %136, align 8, !tbaa !21
  br label %219

; <label>:137:                                    ; preds = %3
  %138 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %138, align 8, !tbaa !291
  %139 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %139, align 4, !tbaa !293
  %140 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 6, i32* %140, align 8, !tbaa !294
  %141 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %142 = bitcast %union.anon.8* %141 to i32*
  store i32 0, i32* %142, align 8, !tbaa !21
  %143 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %144 = bitcast %union.SemInfo* %143 to i64*
  %145 = load i64, i64* %144, align 8, !tbaa !21
  %146 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  store i64 %145, i64* %146, align 8, !tbaa !21
  br label %219

; <label>:147:                                    ; preds = %3
  %148 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %149 = bitcast %union.SemInfo* %148 to %struct.TString**
  %150 = load %struct.TString*, %struct.TString** %149, align 8, !tbaa !21
  %151 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %152 = load %struct.FuncState*, %struct.FuncState** %151, align 8, !tbaa !273
  %153 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %153) #7
  %154 = bitcast %struct.TValue* %4 to %struct.TString**
  store %struct.TString* %150, %struct.TString** %154, align 8, !tbaa !21
  %155 = getelementptr inbounds %struct.TString, %struct.TString* %150, i64 0, i32 1
  %156 = load i8, i8* %155, align 8, !tbaa !75
  %157 = or i8 %156, 64
  %158 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 %157, i8* %158, align 8, !tbaa !22
  %159 = call fastcc i32 @addk(%struct.FuncState* %152, %struct.TValue* nonnull %4, %struct.TValue* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %153) #7
  %160 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %160, align 8, !tbaa !291
  %161 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %161, align 4, !tbaa !293
  %162 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 4, i32* %162, align 8, !tbaa !294
  %163 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %164 = bitcast %union.anon.8* %163 to i32*
  store i32 %159, i32* %164, align 8, !tbaa !21
  br label %219

; <label>:165:                                    ; preds = %3
  %166 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %166, align 8, !tbaa !291
  %167 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %167, align 4, !tbaa !293
  %168 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 1, i32* %168, align 8, !tbaa !294
  %169 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %170 = bitcast %union.anon.8* %169 to i32*
  store i32 0, i32* %170, align 8, !tbaa !21
  br label %219

; <label>:171:                                    ; preds = %3
  %172 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %172, align 8, !tbaa !291
  %173 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %173, align 4, !tbaa !293
  %174 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 2, i32* %174, align 8, !tbaa !294
  %175 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %176 = bitcast %union.anon.8* %175 to i32*
  store i32 0, i32* %176, align 8, !tbaa !21
  br label %219

; <label>:177:                                    ; preds = %3
  %178 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %178, align 8, !tbaa !291
  %179 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %179, align 4, !tbaa !293
  %180 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 3, i32* %180, align 8, !tbaa !294
  %181 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %182 = bitcast %union.anon.8* %181 to i32*
  store i32 0, i32* %182, align 8, !tbaa !21
  br label %219

; <label>:183:                                    ; preds = %3
  %184 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %185 = load %struct.FuncState*, %struct.FuncState** %184, align 8, !tbaa !273
  %186 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %185, i64 0, i32 0
  %187 = load %struct.Proto*, %struct.Proto** %186, align 8, !tbaa !253
  %188 = getelementptr inbounds %struct.Proto, %struct.Proto* %187, i64 0, i32 4
  %189 = load i8, i8* %188, align 1, !tbaa !115
  %190 = icmp eq i8 %189, 0
  br i1 %190, label %191, label %192

; <label>:191:                                    ; preds = %183
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.253, i64 0, i64 0)) #19
  unreachable

; <label>:192:                                    ; preds = %183
  %193 = tail call fastcc i32 @luaK_code(%struct.FuncState* %185, i32 16777297) #17
  %194 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %194, align 8, !tbaa !291
  %195 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %195, align 4, !tbaa !293
  %196 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 17, i32* %196, align 8, !tbaa !294
  %197 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %198 = bitcast %union.anon.8* %197 to i32*
  store i32 %193, i32* %198, align 8, !tbaa !21
  br label %219

; <label>:199:                                    ; preds = %3
  tail call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  br label %235

; <label>:200:                                    ; preds = %3
  %201 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %202 = load i32, i32* %201, align 4, !tbaa !265
  %203 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %202, i32* %203, align 8, !tbaa !266
  %204 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %205 = getelementptr inbounds %struct.Token, %struct.Token* %204, i64 0, i32 0
  %206 = load i32, i32* %205, align 8, !tbaa !263
  %207 = icmp eq i32 %206, 289
  br i1 %207, label %212, label %208

; <label>:208:                                    ; preds = %200
  %209 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %210 = bitcast %struct.Token* %209 to i8*
  %211 = bitcast %struct.Token* %204 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %210, i8* nonnull %211, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %205, align 8, !tbaa !263
  br label %216

; <label>:212:                                    ; preds = %200
  %213 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %214 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %213) #17
  store i32 %214, i32* %17, align 8, !tbaa !260
  %215 = load i32, i32* %201, align 4, !tbaa !265
  br label %216

; <label>:216:                                    ; preds = %212, %208
  %217 = phi i32 [ %215, %212 ], [ %202, %208 ]
  tail call fastcc void @body(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0, i32 %217) #17
  br label %235

; <label>:218:                                    ; preds = %3
  tail call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  br label %235

; <label>:219:                                    ; preds = %192, %177, %171, %165, %147, %137, %127
  %220 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %221 = load i32, i32* %220, align 4, !tbaa !265
  %222 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %221, i32* %222, align 8, !tbaa !266
  %223 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %224 = getelementptr inbounds %struct.Token, %struct.Token* %223, i64 0, i32 0
  %225 = load i32, i32* %224, align 8, !tbaa !263
  %226 = icmp eq i32 %225, 289
  br i1 %226, label %231, label %227

; <label>:227:                                    ; preds = %219
  %228 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %229 = bitcast %struct.Token* %228 to i8*
  %230 = bitcast %struct.Token* %223 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %229, i8* nonnull %230, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %224, align 8, !tbaa !263
  br label %235

; <label>:231:                                    ; preds = %219
  %232 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %233 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %232) #17
  store i32 %233, i32* %17, align 8, !tbaa !260
  br label %237

; <label>:234:                                    ; preds = %38
  unreachable

; <label>:235:                                    ; preds = %43, %66, %121, %227, %199, %216, %218
  %236 = load i32, i32* %17, align 8, !tbaa !260
  br label %237

; <label>:237:                                    ; preds = %235, %231
  %238 = phi i32 [ %236, %235 ], [ %233, %231 ]
  switch i32 %238, label %542 [
    i32 43, label %259
    i32 45, label %239
    i32 42, label %240
    i32 37, label %241
    i32 94, label %242
    i32 47, label %243
    i32 279, label %244
    i32 38, label %245
    i32 124, label %246
    i32 126, label %247
    i32 286, label %248
    i32 287, label %249
    i32 280, label %250
    i32 285, label %251
    i32 282, label %252
    i32 60, label %253
    i32 284, label %254
    i32 62, label %255
    i32 283, label %256
    i32 257, label %257
    i32 272, label %258
  ]

; <label>:239:                                    ; preds = %237
  br label %259

; <label>:240:                                    ; preds = %237
  br label %259

; <label>:241:                                    ; preds = %237
  br label %259

; <label>:242:                                    ; preds = %237
  br label %259

; <label>:243:                                    ; preds = %237
  br label %259

; <label>:244:                                    ; preds = %237
  br label %259

; <label>:245:                                    ; preds = %237
  br label %259

; <label>:246:                                    ; preds = %237
  br label %259

; <label>:247:                                    ; preds = %237
  br label %259

; <label>:248:                                    ; preds = %237
  br label %259

; <label>:249:                                    ; preds = %237
  br label %259

; <label>:250:                                    ; preds = %237
  br label %259

; <label>:251:                                    ; preds = %237
  br label %259

; <label>:252:                                    ; preds = %237
  br label %259

; <label>:253:                                    ; preds = %237
  br label %259

; <label>:254:                                    ; preds = %237
  br label %259

; <label>:255:                                    ; preds = %237
  br label %259

; <label>:256:                                    ; preds = %237
  br label %259

; <label>:257:                                    ; preds = %237
  br label %259

; <label>:258:                                    ; preds = %237
  br label %259

; <label>:259:                                    ; preds = %258, %257, %256, %255, %254, %253, %252, %251, %250, %249, %248, %247, %246, %245, %244, %243, %242, %241, %240, %239, %237
  %260 = phi i32 [ 0, %237 ], [ 1, %239 ], [ 2, %240 ], [ 3, %241 ], [ 4, %242 ], [ 5, %243 ], [ 6, %244 ], [ 7, %245 ], [ 8, %246 ], [ 9, %247 ], [ 10, %248 ], [ 11, %249 ], [ 12, %250 ], [ 16, %251 ], [ 13, %252 ], [ 14, %253 ], [ 15, %254 ], [ 17, %255 ], [ 18, %256 ], [ 19, %257 ], [ 20, %258 ]
  %261 = bitcast %struct.expdesc* %14 to i8*
  %262 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %263 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  %264 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %265 = getelementptr inbounds %struct.Token, %struct.Token* %264, i64 0, i32 0
  %266 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %267 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %268 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %269 = bitcast %struct.Token* %268 to i8*
  %270 = bitcast %struct.Token* %264 to i8*
  %271 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %14, i64 0, i32 3
  %272 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %273 = bitcast %struct.expdesc* %1 to i8*
  %274 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %14, i64 0, i32 2
  %275 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %276 = bitcast i64* %5 to i8*
  %277 = bitcast i32* %6 to i8*
  %278 = bitcast %struct.expdesc* %7 to i8*
  %279 = bitcast i64* %9 to i8*
  %280 = bitcast i32* %10 to i8*
  %281 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %282 = bitcast %struct.expdesc* %8 to i8*
  %283 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %14, i64 0, i32 0
  %284 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %285 = bitcast %union.anon.8* %284 to i32*
  %286 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %14, i64 0, i32 1
  %287 = bitcast %union.anon.8* %286 to i32*
  %288 = bitcast %struct.expdesc* %13 to i8*
  %289 = bitcast %struct.expdesc* %12 to i8*
  %290 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %291 = bitcast %struct.expdesc* %11 to i8*
  %292 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %14, i64 0, i32 1, i32 0
  br label %293

; <label>:293:                                    ; preds = %259, %539
  %294 = phi i32 [ %260, %259 ], [ %540, %539 ]
  %295 = zext i32 %294 to i64
  %296 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %295, i32 0
  %297 = load i8, i8* %296, align 2, !tbaa !320
  %298 = zext i8 %297 to i32
  %299 = icmp sgt i32 %298, %2
  br i1 %299, label %300, label %542

; <label>:300:                                    ; preds = %293
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %261) #7
  %301 = load i32, i32* %262, align 4, !tbaa !265
  store i32 %301, i32* %263, align 8, !tbaa !266
  %302 = load i32, i32* %265, align 8, !tbaa !263
  %303 = icmp eq i32 %302, 289
  br i1 %303, label %305, label %304

; <label>:304:                                    ; preds = %300
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %269, i8* nonnull %270, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %265, align 8, !tbaa !263
  br label %307

; <label>:305:                                    ; preds = %300
  %306 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %266) #17
  store i32 %306, i32* %17, align 8, !tbaa !260
  br label %307

; <label>:307:                                    ; preds = %304, %305
  %308 = load %struct.FuncState*, %struct.FuncState** %267, align 8, !tbaa !273
  switch i32 %294, label %355 [
    i32 19, label %309
    i32 20, label %316
    i32 12, label %323
    i32 0, label %329
    i32 1, label %329
    i32 2, label %329
    i32 5, label %329
    i32 6, label %329
    i32 3, label %329
    i32 4, label %329
    i32 7, label %329
    i32 8, label %329
    i32 9, label %329
    i32 10, label %329
    i32 11, label %329
    i32 13, label %339
    i32 16, label %339
    i32 14, label %349
    i32 15, label %349
    i32 17, label %349
    i32 18, label %349
  ]

; <label>:309:                                    ; preds = %307
  call fastcc void @luaK_goiftrue(%struct.FuncState* %308, %struct.expdesc* %1) #17
  %310 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %295, i32 1
  %311 = load i8, i8* %310, align 1, !tbaa !322
  %312 = zext i8 %311 to i32
  %313 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %14, i32 %312) #16
  %314 = load %struct.FuncState*, %struct.FuncState** %267, align 8, !tbaa !273
  call fastcc void @luaK_dischargevars(%struct.FuncState* %314, %struct.expdesc* nonnull %14) #17
  %315 = load i32, i32* %272, align 4, !tbaa !293
  call fastcc void @luaK_concat(%struct.FuncState* %314, i32* nonnull %271, i32 %315) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  br label %539

; <label>:316:                                    ; preds = %307
  call fastcc void @luaK_goiffalse(%struct.FuncState* %308, %struct.expdesc* %1) #17
  %317 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %295, i32 1
  %318 = load i8, i8* %317, align 1, !tbaa !322
  %319 = zext i8 %318 to i32
  %320 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %14, i32 %319) #16
  %321 = load %struct.FuncState*, %struct.FuncState** %267, align 8, !tbaa !273
  call fastcc void @luaK_dischargevars(%struct.FuncState* %321, %struct.expdesc* nonnull %14) #17
  %322 = load i32, i32* %275, align 8, !tbaa !291
  call fastcc void @luaK_concat(%struct.FuncState* %321, i32* nonnull %274, i32 %322) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  br label %539

; <label>:323:                                    ; preds = %307
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %308, %struct.expdesc* %1) #17
  %324 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %295, i32 1
  %325 = load i8, i8* %324, align 1, !tbaa !322
  %326 = zext i8 %325 to i32
  %327 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %14, i32 %326) #16
  %328 = load %struct.FuncState*, %struct.FuncState** %267, align 8, !tbaa !273
  br label %361

; <label>:329:                                    ; preds = %307, %307, %307, %307, %307, %307, %307, %307, %307, %307, %307, %307
  %330 = load i32, i32* %275, align 8, !tbaa !291
  %331 = load i32, i32* %272, align 4, !tbaa !293
  %332 = icmp eq i32 %330, %331
  br i1 %332, label %333, label %337

; <label>:333:                                    ; preds = %329
  %334 = load i32, i32* %281, align 8, !tbaa !294
  %335 = add i32 %334, -5
  %336 = icmp ult i32 %335, 2
  br i1 %336, label %355, label %337

; <label>:337:                                    ; preds = %333, %329
  %338 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %308, %struct.expdesc* nonnull %1) #17
  br label %355

; <label>:339:                                    ; preds = %307, %307
  %340 = load i32, i32* %275, align 8, !tbaa !291
  %341 = load i32, i32* %272, align 4, !tbaa !293
  %342 = icmp eq i32 %340, %341
  br i1 %342, label %343, label %347

; <label>:343:                                    ; preds = %339
  %344 = load i32, i32* %281, align 8, !tbaa !294
  %345 = add i32 %344, -5
  %346 = icmp ult i32 %345, 2
  br i1 %346, label %355, label %347

; <label>:347:                                    ; preds = %343, %339
  %348 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %308, %struct.expdesc* nonnull %1) #17
  br label %355

; <label>:349:                                    ; preds = %307, %307, %307, %307
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %276) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %277) #7
  %350 = call fastcc i32 @isSCnumber(%struct.expdesc* %1, i64* nonnull %5, i32* nonnull %6) #17
  %351 = icmp eq i32 %350, 0
  br i1 %351, label %352, label %354

; <label>:352:                                    ; preds = %349
  %353 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %308, %struct.expdesc* %1) #17
  br label %354

; <label>:354:                                    ; preds = %352, %349
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %277) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %276) #7
  br label %355

; <label>:355:                                    ; preds = %307, %333, %337, %343, %347, %354
  %356 = getelementptr inbounds [21 x %struct.anon.10], [21 x %struct.anon.10]* @priority, i64 0, i64 %295, i32 1
  %357 = load i8, i8* %356, align 1, !tbaa !322
  %358 = zext i8 %357 to i32
  %359 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %14, i32 %358) #16
  %360 = load %struct.FuncState*, %struct.FuncState** %267, align 8, !tbaa !273
  switch i32 %294, label %539 [
    i32 18, label %537
    i32 17, label %537
    i32 12, label %361
    i32 0, label %425
    i32 2, label %425
    i32 1, label %440
    i32 5, label %440
    i32 6, label %440
    i32 3, label %440
    i32 4, label %440
    i32 7, label %445
    i32 8, label %445
    i32 9, label %445
    i32 10, label %468
    i32 11, label %487
    i32 13, label %491
    i32 16, label %491
    i32 14, label %535
    i32 15, label %535
  ]

; <label>:361:                                    ; preds = %323, %355
  %362 = phi %struct.FuncState* [ %328, %323 ], [ %360, %355 ]
  %363 = phi i32 [ %327, %323 ], [ %359, %355 ]
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %362, %struct.expdesc* nonnull %14) #17
  %364 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 4
  %365 = load i32, i32* %364, align 8, !tbaa !274
  %366 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 5
  %367 = load i32, i32* %366, align 4, !tbaa !276
  %368 = icmp sgt i32 %365, %367
  br i1 %368, label %369, label %377

; <label>:369:                                    ; preds = %361
  %370 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 0
  %371 = load %struct.Proto*, %struct.Proto** %370, align 8, !tbaa !253
  %372 = getelementptr inbounds %struct.Proto, %struct.Proto* %371, i64 0, i32 16
  %373 = load i32*, i32** %372, align 8, !tbaa !116
  %374 = add nsw i32 %365, -1
  %375 = sext i32 %374 to i64
  %376 = getelementptr inbounds i32, i32* %373, i64 %375
  br label %377

; <label>:377:                                    ; preds = %369, %361
  %378 = phi i32* [ %376, %369 ], [ @previousinstruction.invalidinstruction, %361 ]
  %379 = load i32, i32* %378, align 4, !tbaa !77
  %380 = and i32 %379, 127
  %381 = icmp eq i32 %380, 54
  br i1 %381, label %382, label %405

; <label>:382:                                    ; preds = %377
  %383 = load i32, i32* %283, align 8, !tbaa !294
  %384 = icmp eq i32 %383, 7
  br i1 %384, label %385, label %395

; <label>:385:                                    ; preds = %382
  %386 = load i32, i32* %287, align 8, !tbaa !21
  %387 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 13
  %388 = load i8, i8* %387, align 2, !tbaa !298
  %389 = zext i8 %388 to i32
  %390 = icmp slt i32 %386, %389
  br i1 %390, label %395, label %391

; <label>:391:                                    ; preds = %385
  %392 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 15
  %393 = load i8, i8* %392, align 4, !tbaa !303
  %394 = add i8 %393, -1
  store i8 %394, i8* %392, align 4, !tbaa !303
  br label %395

; <label>:395:                                    ; preds = %391, %385, %382
  %396 = and i32 %379, -16744321
  %397 = load i32, i32* %285, align 8, !tbaa !21
  %398 = shl i32 %397, 7
  %399 = and i32 %398, 32640
  %400 = and i32 %379, 16711680
  %401 = add nuw nsw i32 %400, 65536
  %402 = and i32 %401, 16711680
  %403 = or i32 %402, %396
  %404 = or i32 %403, %399
  store i32 %404, i32* %378, align 4, !tbaa !77
  br label %539

; <label>:405:                                    ; preds = %377
  %406 = load i32, i32* %285, align 8, !tbaa !21
  %407 = shl i32 %406, 7
  %408 = or i32 %407, 131126
  %409 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %362, i32 %408) #17
  %410 = load i32, i32* %283, align 8, !tbaa !294
  %411 = icmp eq i32 %410, 7
  br i1 %411, label %412, label %422

; <label>:412:                                    ; preds = %405
  %413 = load i32, i32* %287, align 8, !tbaa !21
  %414 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 13
  %415 = load i8, i8* %414, align 2, !tbaa !298
  %416 = zext i8 %415 to i32
  %417 = icmp slt i32 %413, %416
  br i1 %417, label %422, label %418

; <label>:418:                                    ; preds = %412
  %419 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 15
  %420 = load i8, i8* %419, align 4, !tbaa !303
  %421 = add i8 %420, -1
  store i8 %421, i8* %419, align 4, !tbaa !303
  br label %422

; <label>:422:                                    ; preds = %418, %412, %405
  call fastcc void @removelastlineinfo(%struct.FuncState* nonnull %362) #17
  %423 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %362, i64 0, i32 0
  %424 = load %struct.Proto*, %struct.Proto** %423, align 8, !tbaa !253
  call fastcc void @savelineinfo(%struct.FuncState* nonnull %362, %struct.Proto* %424, i32 %301) #17
  br label %539

; <label>:425:                                    ; preds = %355, %355
  %426 = call fastcc i32 @constfolding(%struct.FuncState* %360, i32 %294, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  %427 = icmp eq i32 %426, 0
  br i1 %427, label %428, label %539

; <label>:428:                                    ; preds = %425
  %429 = add i32 %294, 38
  %430 = load i32, i32* %275, align 8, !tbaa !291
  %431 = load i32, i32* %272, align 4, !tbaa !293
  %432 = icmp eq i32 %430, %431
  br i1 %432, label %433, label %438

; <label>:433:                                    ; preds = %428
  %434 = load i32, i32* %281, align 8, !tbaa !294
  %435 = add i32 %434, -5
  %436 = icmp ult i32 %435, 2
  br i1 %436, label %437, label %438

; <label>:437:                                    ; preds = %433
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %288)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %288, i8* nonnull %273, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %261, i8* nonnull %288, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %288)
  br label %438

; <label>:438:                                    ; preds = %437, %433, %428
  %439 = phi i32 [ 1, %437 ], [ 0, %428 ], [ 0, %433 ]
  call fastcc void @codearith(%struct.FuncState* %360, i32 %429, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %14, i32 %439, i32 %301) #17
  br label %539

; <label>:440:                                    ; preds = %355, %355, %355, %355, %355
  %441 = call fastcc i32 @constfolding(%struct.FuncState* %360, i32 %294, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  %442 = icmp eq i32 %441, 0
  br i1 %442, label %443, label %539

; <label>:443:                                    ; preds = %440
  %444 = add i32 %294, 38
  call fastcc void @codearith(%struct.FuncState* %360, i32 %444, %struct.expdesc* %1, %struct.expdesc* nonnull %14, i32 0, i32 %301) #17
  br label %539

; <label>:445:                                    ; preds = %355, %355, %355
  %446 = call fastcc i32 @constfolding(%struct.FuncState* %360, i32 %294, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  %447 = icmp eq i32 %446, 0
  br i1 %447, label %448, label %539

; <label>:448:                                    ; preds = %445
  %449 = load i32, i32* %281, align 8, !tbaa !294
  %450 = icmp eq i32 %449, 6
  br i1 %450, label %451, label %455

; <label>:451:                                    ; preds = %448
  %452 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %360, %struct.expdesc* nonnull %1) #17
  %453 = icmp eq i32 %452, 0
  br i1 %453, label %455, label %454

; <label>:454:                                    ; preds = %451
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %289)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %289, i8* nonnull %273, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %261, i8* nonnull %289, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %289)
  br label %464

; <label>:455:                                    ; preds = %451, %448
  %456 = load i32, i32* %283, align 8, !tbaa !294
  %457 = icmp eq i32 %456, 6
  br i1 %457, label %458, label %461

; <label>:458:                                    ; preds = %455
  %459 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %360, %struct.expdesc* nonnull %14) #17
  %460 = icmp eq i32 %459, 0
  br i1 %460, label %461, label %464

; <label>:461:                                    ; preds = %458, %455
  %462 = add i32 %294, 38
  %463 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %360, %struct.expdesc* nonnull %14) #17
  call fastcc void @finishbinexpval(%struct.FuncState* %360, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %14, i32 %462, i32 %463, i32 0, i32 %301) #17
  br label %539

; <label>:464:                                    ; preds = %458, %454
  %465 = phi i32 [ 1, %454 ], [ 0, %458 ]
  %466 = load i32, i32* %287, align 8, !tbaa !21
  %467 = add i32 %294, 26
  call fastcc void @finishbinexpval(%struct.FuncState* %360, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %14, i32 %467, i32 %466, i32 %465, i32 %301) #17
  br label %539

; <label>:468:                                    ; preds = %355
  %469 = call fastcc i32 @constfolding(%struct.FuncState* %360, i32 10, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  %470 = icmp eq i32 %469, 0
  br i1 %470, label %471, label %539

; <label>:471:                                    ; preds = %468
  %472 = load i32, i32* %281, align 8, !tbaa !294
  %473 = icmp eq i32 %472, 6
  br i1 %473, label %474, label %486

; <label>:474:                                    ; preds = %471
  %475 = load i32, i32* %275, align 8, !tbaa !291
  %476 = load i32, i32* %272, align 4, !tbaa !293
  %477 = icmp eq i32 %475, %476
  br i1 %477, label %478, label %486

; <label>:478:                                    ; preds = %474
  %479 = load i64, i64* %290, align 8, !tbaa !21
  %480 = add i64 %479, 127
  %481 = icmp ugt i64 %480, 255
  br i1 %481, label %486, label %482

; <label>:482:                                    ; preds = %478
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %291)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %291, i8* nonnull %273, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %261, i8* nonnull %291, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %291)
  %483 = load i64, i64* %292, align 8, !tbaa !21
  %484 = trunc i64 %483 to i32
  %485 = add nsw i32 %484, 127
  call fastcc void @finishbinexpval(%struct.FuncState* %360, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %14, i32 37, i32 %485, i32 1, i32 %301) #17
  br label %539

; <label>:486:                                    ; preds = %478, %474, %471
  call fastcc void @codeshift(%struct.FuncState* %360, i32 48, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %14, i32 %301) #17
  br label %539

; <label>:487:                                    ; preds = %355
  %488 = call fastcc i32 @constfolding(%struct.FuncState* %360, i32 11, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  %489 = icmp eq i32 %488, 0
  br i1 %489, label %490, label %539

; <label>:490:                                    ; preds = %487
  call fastcc void @codeshift(%struct.FuncState* %360, i32 49, %struct.expdesc* %1, %struct.expdesc* nonnull %14, i32 %301) #17
  br label %539

; <label>:491:                                    ; preds = %355, %355
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %279) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %280) #7
  store i32 0, i32* %10, align 4, !tbaa !77
  %492 = load i32, i32* %281, align 8, !tbaa !294
  %493 = icmp eq i32 %492, 7
  br i1 %493, label %495, label %494

; <label>:494:                                    ; preds = %491
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %282)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %282, i8* nonnull %273, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %261, i8* nonnull %282, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %282)
  br label %495

; <label>:495:                                    ; preds = %494, %491
  %496 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %360, %struct.expdesc* nonnull %1) #17
  %497 = call fastcc i32 @isSCnumber(%struct.expdesc* nonnull %14, i64* nonnull %9, i32* nonnull %10) #17
  %498 = icmp eq i32 %497, 0
  br i1 %498, label %502, label %499

; <label>:499:                                    ; preds = %495
  %500 = load i64, i64* %9, align 8, !tbaa !144
  %501 = trunc i64 %500 to i32
  br label %509

; <label>:502:                                    ; preds = %495
  %503 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %360, %struct.expdesc* nonnull %14) #17
  %504 = icmp eq i32 %503, 0
  br i1 %504, label %507, label %505

; <label>:505:                                    ; preds = %502
  %506 = load i32, i32* %287, align 8, !tbaa !21
  br label %509

; <label>:507:                                    ; preds = %502
  %508 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %360, %struct.expdesc* nonnull %14) #17
  br label %509

; <label>:509:                                    ; preds = %507, %505, %499
  %510 = phi i32 [ %501, %499 ], [ %506, %505 ], [ %508, %507 ]
  %511 = phi i32 [ 62, %499 ], [ 61, %505 ], [ 58, %507 ]
  %512 = load i32, i32* %281, align 8, !tbaa !294
  %513 = icmp eq i32 %512, 7
  br i1 %513, label %514, label %516

; <label>:514:                                    ; preds = %509
  %515 = load i32, i32* %285, align 8, !tbaa !21
  br label %516

; <label>:516:                                    ; preds = %514, %509
  %517 = phi i32 [ %515, %514 ], [ -1, %509 ]
  %518 = load i32, i32* %283, align 8, !tbaa !294
  %519 = icmp eq i32 %518, 7
  %520 = load i32, i32* %287, align 8
  %521 = select i1 %519, i32 %520, i32 -1
  call fastcc void @freeregs(%struct.FuncState* %360, i32 %517, i32 %521) #17
  %522 = load i32, i32* %10, align 4, !tbaa !77
  %523 = icmp eq i32 %294, 13
  %524 = zext i1 %523 to i32
  %525 = shl i32 %496, 7
  %526 = shl i32 %510, 16
  %527 = shl i32 %522, 24
  %528 = shl nuw nsw i32 %524, 15
  %529 = or i32 %525, %528
  %530 = or i32 %529, %511
  %531 = or i32 %530, %526
  %532 = or i32 %531, %527
  %533 = call fastcc i32 @luaK_code(%struct.FuncState* %360, i32 %532) #17
  %534 = call fastcc i32 @luaK_code(%struct.FuncState* %360, i32 2147483449) #17
  store i32 %534, i32* %285, align 8, !tbaa !21
  store i32 14, i32* %281, align 8, !tbaa !294
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %280) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %279) #7
  br label %539

; <label>:535:                                    ; preds = %355, %355
  %536 = add i32 %294, 45
  call fastcc void @codeorder(%struct.FuncState* %360, i32 %536, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  br label %539

; <label>:537:                                    ; preds = %355, %355
  %538 = add i32 %294, 42
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %278)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %278, i8* %273, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %273, i8* nonnull %261, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %261, i8* nonnull %278, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %278)
  call fastcc void @codeorder(%struct.FuncState* %360, i32 %538, %struct.expdesc* %1, %struct.expdesc* nonnull %14) #17
  br label %539

; <label>:539:                                    ; preds = %355, %309, %316, %395, %422, %425, %438, %440, %443, %445, %461, %464, %468, %482, %486, %487, %490, %516, %535, %537
  %540 = phi i32 [ %359, %355 ], [ %313, %309 ], [ %320, %316 ], [ %363, %395 ], [ %363, %422 ], [ %359, %425 ], [ %359, %438 ], [ %359, %440 ], [ %359, %443 ], [ %359, %445 ], [ %359, %461 ], [ %359, %464 ], [ %359, %468 ], [ %359, %482 ], [ %359, %486 ], [ %359, %487 ], [ %359, %490 ], [ %359, %516 ], [ %359, %535 ], [ %359, %537 ]
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %261) #7
  %541 = icmp eq i32 %540, 21
  br i1 %541, label %542, label %293

; <label>:542:                                    ; preds = %293, %539, %237
  %543 = phi i32 [ 21, %237 ], [ 21, %539 ], [ %294, %293 ]
  %544 = load %struct.lua_State*, %struct.lua_State** %15, align 8, !tbaa !261
  %545 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %544, i64 0, i32 19
  %546 = load i32, i32* %545, align 8, !tbaa !29
  %547 = add i32 %546, -1
  store i32 %547, i32* %545, align 8, !tbaa !29
  ret i32 %543
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @constfolding(%struct.FuncState* nocapture readonly, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly) unnamed_addr #0 {
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast %struct.TValue* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %9) #7
  %10 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %12 = load i32, i32* %11, align 8, !tbaa !291
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %14 = load i32, i32* %13, align 4, !tbaa !293
  %15 = icmp eq i32 %12, %14
  br i1 %15, label %16, label %87

; <label>:16:                                     ; preds = %4
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %18 = load i32, i32* %17, align 8, !tbaa !294
  switch i32 %18, label %87 [
    i32 6, label %20
    i32 5, label %19
  ]

; <label>:19:                                     ; preds = %16
  br label %20

; <label>:20:                                     ; preds = %16, %19
  %21 = phi i8 [ 19, %19 ], [ 35, %16 ]
  %22 = phi i6 [ 19, %19 ], [ -29, %16 ]
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  %24 = load i64, i64* %23, align 8, !tbaa !21
  %25 = bitcast %struct.TValue* %5 to i64*
  store i64 %24, i64* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %21, i8* %26, align 8, !tbaa !22
  %27 = bitcast i64 %24 to double
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 2
  %29 = load i32, i32* %28, align 8, !tbaa !291
  %30 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 3
  %31 = load i32, i32* %30, align 4, !tbaa !293
  %32 = icmp eq i32 %29, %31
  br i1 %32, label %33, label %87

; <label>:33:                                     ; preds = %20
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %35 = load i32, i32* %34, align 8, !tbaa !294
  switch i32 %35, label %87 [
    i32 6, label %37
    i32 5, label %36
  ]

; <label>:36:                                     ; preds = %33
  br label %37

; <label>:37:                                     ; preds = %33, %36
  %38 = phi i8 [ 19, %36 ], [ 35, %33 ]
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %40 = load i64, i64* %39, align 8, !tbaa !21
  %41 = bitcast %struct.TValue* %6 to i64*
  store i64 %40, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 %38, i8* %42, align 8, !tbaa !22
  %43 = bitcast i64 %40 to double
  switch i32 %1, label %67 [
    i32 7, label %44
    i32 8, label %44
    i32 9, label %44
    i32 10, label %44
    i32 11, label %44
    i32 13, label %44
    i32 5, label %57
    i32 6, label %57
    i32 3, label %57
  ]

; <label>:44:                                     ; preds = %37, %37, %37, %37, %37, %37
  switch i6 %22, label %87 [
    i6 -29, label %52
    i6 19, label %45
  ]

; <label>:45:                                     ; preds = %44
  %46 = tail call double @llvm.floor.f64(double %27) #7
  %47 = fcmp une double %46, %27
  br i1 %47, label %87, label %48

; <label>:48:                                     ; preds = %45
  %49 = fcmp oge double %46, 0xC3E0000000000000
  %50 = fcmp olt double %46, 0x43E0000000000000
  %51 = and i1 %49, %50
  br i1 %51, label %52, label %87

; <label>:52:                                     ; preds = %48, %44
  %53 = trunc i8 %38 to i6
  switch i6 %53, label %87 [
    i6 -29, label %67
    i6 19, label %54
  ]

; <label>:54:                                     ; preds = %52
  %55 = tail call double @llvm.floor.f64(double %43) #7
  %56 = fcmp une double %55, %43
  br i1 %56, label %87, label %63

; <label>:57:                                     ; preds = %37, %37, %37
  %58 = icmp eq i8 %38, 35
  %59 = sitofp i64 %40 to double
  %60 = bitcast i64 %40 to double
  %61 = select i1 %58, double %59, double %60
  %62 = fcmp une double %61, 0.000000e+00
  br i1 %62, label %67, label %87

; <label>:63:                                     ; preds = %54
  %64 = fcmp oge double %55, 0xC3E0000000000000
  %65 = fcmp olt double %55, 0x43E0000000000000
  %66 = and i1 %64, %65
  br i1 %66, label %67, label %87

; <label>:67:                                     ; preds = %57, %63, %52, %37
  %68 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %69 = load %struct.LexState*, %struct.LexState** %68, align 8, !tbaa !272
  %70 = getelementptr inbounds %struct.LexState, %struct.LexState* %69, i64 0, i32 6
  %71 = load %struct.lua_State*, %struct.lua_State** %70, align 8, !tbaa !261
  %72 = call fastcc i32 @luaO_rawarith(%struct.lua_State* %71, i32 %1, %struct.TValue* nonnull %5, %struct.TValue* nonnull %6, %struct.TValue* nonnull %7) #16
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %74 = load i8, i8* %73, align 8, !tbaa !22
  %75 = icmp eq i8 %74, 35
  br i1 %75, label %76, label %80

; <label>:76:                                     ; preds = %67
  store i32 6, i32* %17, align 8, !tbaa !294
  %77 = bitcast %struct.TValue* %7 to i64*
  %78 = load i64, i64* %77, align 8, !tbaa !21
  %79 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  store i64 %78, i64* %79, align 8, !tbaa !21
  br label %87

; <label>:80:                                     ; preds = %67
  %81 = bitcast %struct.TValue* %7 to double*
  %82 = load double, double* %81, align 8, !tbaa !21
  %83 = fcmp ueq double %82, 0.000000e+00
  br i1 %83, label %87, label %84

; <label>:84:                                     ; preds = %80
  store i32 5, i32* %17, align 8, !tbaa !294
  %85 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %86 = bitcast %union.anon.8* %85 to double*
  store double %82, double* %86, align 8, !tbaa !21
  br label %87

; <label>:87:                                     ; preds = %57, %63, %52, %54, %44, %45, %48, %33, %20, %16, %4, %76, %84, %80
  %88 = phi i32 [ 0, %63 ], [ 0, %80 ], [ 1, %84 ], [ 1, %76 ], [ 0, %4 ], [ 0, %16 ], [ 0, %20 ], [ 0, %33 ], [ 0, %48 ], [ 0, %45 ], [ 0, %44 ], [ 0, %54 ], [ 0, %52 ], [ 0, %57 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %88
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %9, label %6

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  br label %24

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %11 = load i32, i32* %10, align 8, !tbaa !291
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !293
  %14 = icmp eq i32 %11, %13
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %16 = bitcast %union.anon.8* %15 to i32*
  %17 = load i32, i32* %16, align 8, !tbaa !21
  br i1 %14, label %29, label %18

; <label>:18:                                     ; preds = %9
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %20 = load i8, i8* %19, align 2, !tbaa !298
  %21 = zext i8 %20 to i32
  %22 = icmp slt i32 %17, %21
  br i1 %22, label %24, label %23

; <label>:23:                                     ; preds = %18
  tail call fastcc void @exp2reg(%struct.FuncState* nonnull %0, %struct.expdesc* nonnull %1, i32 %17) #16
  br label %26

; <label>:24:                                     ; preds = %6, %18
  %25 = phi i32* [ %8, %6 ], [ %16, %18 ]
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  br label %26

; <label>:26:                                     ; preds = %23, %24
  %27 = phi i32* [ %25, %24 ], [ %16, %23 ]
  %28 = load i32, i32* %27, align 8, !tbaa !21
  br label %29

; <label>:29:                                     ; preds = %26, %9
  %30 = phi i32 [ %17, %9 ], [ %28, %26 ]
  ret i32 %30
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_dischargevars(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  switch i32 %4, label %98 [
    i32 8, label %5
    i32 9, label %6
    i32 11, label %13
    i32 12, label %28
    i32 13, label %53
    i32 10, label %78
    i32 17, label %97
    i32 16, label %97
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = shl i32 %9, 16
  %11 = or i32 %10, 7
  %12 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %11) #17
  store i32 %12, i32* %8, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %15 = bitcast %union.anon.8* %14 to %struct.anon.9*
  %16 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %15, i64 0, i32 1
  %17 = load i8, i8* %16, align 2, !tbaa !21
  %18 = zext i8 %17 to i32
  %19 = bitcast %union.anon.8* %14 to i16*
  %20 = load i16, i16* %19, align 8, !tbaa !21
  %21 = zext i16 %20 to i32
  %22 = shl nuw nsw i32 %18, 16
  %23 = shl i32 %21, 24
  %24 = or i32 %22, %23
  %25 = or i32 %24, 9
  %26 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %25) #17
  %27 = bitcast %union.anon.8* %14 to i32*
  store i32 %26, i32* %27, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:28:                                     ; preds = %2
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %30 = bitcast %union.anon.8* %29 to %struct.anon.9*
  %31 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 2, !tbaa !21
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %34 = load i8, i8* %33, align 2, !tbaa !298
  %35 = icmp ugt i8 %34, %32
  br i1 %35, label %41, label %36

; <label>:36:                                     ; preds = %28
  %37 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %38 = load i8, i8* %37, align 4, !tbaa !303
  %39 = add i8 %38, -1
  store i8 %39, i8* %37, align 4, !tbaa !303
  %40 = load i8, i8* %31, align 2, !tbaa !21
  br label %41

; <label>:41:                                     ; preds = %28, %36
  %42 = phi i8 [ %32, %28 ], [ %40, %36 ]
  %43 = zext i8 %42 to i32
  %44 = bitcast %union.anon.8* %29 to i16*
  %45 = load i16, i16* %44, align 8, !tbaa !21
  %46 = zext i16 %45 to i32
  %47 = shl nuw nsw i32 %43, 16
  %48 = shl i32 %46, 24
  %49 = or i32 %47, %48
  %50 = or i32 %49, 11
  %51 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %50) #17
  %52 = bitcast %union.anon.8* %29 to i32*
  store i32 %51, i32* %52, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:53:                                     ; preds = %2
  %54 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %55 = bitcast %union.anon.8* %54 to %struct.anon.9*
  %56 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %55, i64 0, i32 1
  %57 = load i8, i8* %56, align 2, !tbaa !21
  %58 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %59 = load i8, i8* %58, align 2, !tbaa !298
  %60 = icmp ugt i8 %59, %57
  br i1 %60, label %66, label %61

; <label>:61:                                     ; preds = %53
  %62 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %63 = load i8, i8* %62, align 4, !tbaa !303
  %64 = add i8 %63, -1
  store i8 %64, i8* %62, align 4, !tbaa !303
  %65 = load i8, i8* %56, align 2, !tbaa !21
  br label %66

; <label>:66:                                     ; preds = %53, %61
  %67 = phi i8 [ %57, %53 ], [ %65, %61 ]
  %68 = zext i8 %67 to i32
  %69 = bitcast %union.anon.8* %54 to i16*
  %70 = load i16, i16* %69, align 8, !tbaa !21
  %71 = zext i16 %70 to i32
  %72 = shl nuw nsw i32 %68, 16
  %73 = shl i32 %71, 24
  %74 = or i32 %72, %73
  %75 = or i32 %74, 12
  %76 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %75) #17
  %77 = bitcast %union.anon.8* %54 to i32*
  store i32 %76, i32* %77, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:78:                                     ; preds = %2
  %79 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %80 = bitcast %union.anon.8* %79 to %struct.anon.9*
  %81 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %80, i64 0, i32 1
  %82 = load i8, i8* %81, align 2, !tbaa !21
  %83 = zext i8 %82 to i32
  %84 = bitcast %union.anon.8* %79 to i16*
  %85 = load i16, i16* %84, align 8, !tbaa !21
  %86 = sext i16 %85 to i32
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %83, i32 %86) #16
  %87 = load i8, i8* %81, align 2, !tbaa !21
  %88 = zext i8 %87 to i32
  %89 = load i16, i16* %84, align 8, !tbaa !21
  %90 = zext i16 %89 to i32
  %91 = shl nuw nsw i32 %88, 16
  %92 = shl i32 %90, 24
  %93 = or i32 %91, %92
  %94 = or i32 %93, 10
  %95 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %94) #17
  %96 = bitcast %union.anon.8* %79 to i32*
  store i32 %95, i32* %96, align 8, !tbaa !21
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %98

; <label>:97:                                     ; preds = %2, %2
  tail call fastcc void @luaK_setoneret(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  br label %98

; <label>:98:                                     ; preds = %2, %97, %78, %66, %41, %13, %6, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @exp2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* %1, i32 %2) #16
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !294
  %6 = icmp eq i32 %5, 14
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  br i1 %6, label %8, label %12

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %10 = bitcast %union.anon.8* %9 to i32*
  %11 = load i32, i32* %10, align 8, !tbaa !21
  tail call fastcc void @luaK_concat(%struct.FuncState* %0, i32* nonnull %7, i32 %11) #16
  br label %12

; <label>:12:                                     ; preds = %3, %8
  %13 = load i32, i32* %7, align 8, !tbaa !291
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !293
  %16 = icmp eq i32 %13, %15
  br i1 %16, label %52, label %17

; <label>:17:                                     ; preds = %12
  %18 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %13) #16
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %20, label %26

; <label>:20:                                     ; preds = %17
  %21 = tail call fastcc i32 @need_value(%struct.FuncState* %0, i32 %15) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %20
  %24 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  br label %44

; <label>:26:                                     ; preds = %20, %17
  %27 = load i32, i32* %4, align 8, !tbaa !294
  %28 = icmp eq i32 %27, 14
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %26
  %30 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 2147483449) #17
  br label %31

; <label>:31:                                     ; preds = %26, %29
  %32 = phi i32 [ %30, %29 ], [ -1, %26 ]
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %34 = load i32, i32* %33, align 8, !tbaa !274
  %35 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  store i32 %34, i32* %35, align 4, !tbaa !276
  %36 = shl i32 %2, 7
  %37 = or i32 %36, 16777221
  %38 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %37) #17
  %39 = load i32, i32* %33, align 8, !tbaa !274
  store i32 %39, i32* %35, align 4, !tbaa !276
  %40 = or i32 %36, 65541
  %41 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %40) #17
  %42 = load i32, i32* %33, align 8, !tbaa !274
  store i32 %42, i32* %35, align 4, !tbaa !276
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %32, i32 %42, i32 255, i32 %42) #17
  %43 = load i32, i32* %14, align 4, !tbaa !293
  br label %44

; <label>:44:                                     ; preds = %23, %31
  %45 = phi i32* [ %25, %23 ], [ %35, %31 ]
  %46 = phi i32* [ %24, %23 ], [ %33, %31 ]
  %47 = phi i32 [ %15, %23 ], [ %43, %31 ]
  %48 = phi i32 [ -1, %23 ], [ %41, %31 ]
  %49 = phi i32 [ -1, %23 ], [ %38, %31 ]
  %50 = load i32, i32* %46, align 8, !tbaa !274
  store i32 %50, i32* %45, align 4, !tbaa !276
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %47, i32 %50, i32 %2, i32 %49) #16
  %51 = load i32, i32* %7, align 8, !tbaa !291
  tail call fastcc void @patchlistaux(%struct.FuncState* %0, i32 %51, i32 %50, i32 %2, i32 %48) #16
  br label %52

; <label>:52:                                     ; preds = %12, %44
  store i32 -1, i32* %7, align 8, !tbaa !291
  store i32 -1, i32* %14, align 4, !tbaa !293
  %53 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %54 = bitcast %union.anon.8* %53 to i32*
  store i32 %2, i32* %54, align 8, !tbaa !21
  store i32 7, i32* %4, align 8, !tbaa !294
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_exp2nextreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %6, label %18

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %8 = bitcast %union.anon.8* %7 to i32*
  %9 = load i32, i32* %8, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %11 = load i8, i8* %10, align 2, !tbaa !298
  %12 = zext i8 %11 to i32
  %13 = icmp slt i32 %9, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %16 = load i8, i8* %15, align 4, !tbaa !303
  %17 = add i8 %16, -1
  store i8 %17, i8* %15, align 4, !tbaa !303
  br label %18

; <label>:18:                                     ; preds = %2, %6, %14
  tail call fastcc void @luaK_checkstack(%struct.FuncState* %0, i32 1) #17
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %20 = load i8, i8* %19, align 4, !tbaa !303
  %21 = add i8 %20, 1
  store i8 %21, i8* %19, align 4, !tbaa !303
  %22 = zext i8 %21 to i32
  %23 = add nsw i32 %22, -1
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 %23) #16
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @freeregs(%struct.FuncState* nocapture, i32, i32) unnamed_addr #2 {
  %4 = icmp sgt i32 %1, %2
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !298
  %7 = zext i8 %6 to i32
  br i1 %4, label %8, label %20

; <label>:8:                                      ; preds = %3
  %9 = icmp sgt i32 %7, %1
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %8
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %12 = load i8, i8* %11, align 4, !tbaa !303
  %13 = add i8 %12, -1
  store i8 %13, i8* %11, align 4, !tbaa !303
  br label %14

; <label>:14:                                     ; preds = %8, %10
  %15 = icmp sgt i32 %7, %2
  br i1 %15, label %32, label %16

; <label>:16:                                     ; preds = %14
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %18 = load i8, i8* %17, align 4, !tbaa !303
  %19 = add i8 %18, -1
  store i8 %19, i8* %17, align 4, !tbaa !303
  br label %32

; <label>:20:                                     ; preds = %3
  %21 = icmp sgt i32 %7, %2
  br i1 %21, label %26, label %22

; <label>:22:                                     ; preds = %20
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %24 = load i8, i8* %23, align 4, !tbaa !303
  %25 = add i8 %24, -1
  store i8 %25, i8* %23, align 4, !tbaa !303
  br label %26

; <label>:26:                                     ; preds = %20, %22
  %27 = icmp sgt i32 %7, %1
  br i1 %27, label %32, label %28

; <label>:28:                                     ; preds = %26
  %29 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %30 = load i8, i8* %29, align 4, !tbaa !303
  %31 = add i8 %30, -1
  store i8 %31, i8* %29, align 4, !tbaa !303
  br label %32

; <label>:32:                                     ; preds = %28, %26, %16, %14
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @luaK_setoneret(%struct.FuncState* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  switch i32 %4, label %31 [
    i32 16, label %5
    i32 17, label %18
  ]

; <label>:5:                                      ; preds = %2
  store i32 7, i32* %3, align 8, !tbaa !294
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %7 = load %struct.Proto*, %struct.Proto** %6, align 8, !tbaa !253
  %8 = getelementptr inbounds %struct.Proto, %struct.Proto* %7, i64 0, i32 16
  %9 = load i32*, i32** %8, align 8, !tbaa !116
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  %12 = load i32, i32* %11, align 8, !tbaa !21
  %13 = sext i32 %12 to i64
  %14 = getelementptr inbounds i32, i32* %9, i64 %13
  %15 = load i32, i32* %14, align 4, !tbaa !77
  %16 = lshr i32 %15, 7
  %17 = and i32 %16, 255
  store i32 %17, i32* %11, align 8, !tbaa !21
  br label %31

; <label>:18:                                     ; preds = %2
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %20 = load %struct.Proto*, %struct.Proto** %19, align 8, !tbaa !253
  %21 = getelementptr inbounds %struct.Proto, %struct.Proto* %20, i64 0, i32 16
  %22 = load i32*, i32** %21, align 8, !tbaa !116
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = load i32, i32* %24, align 8, !tbaa !21
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds i32, i32* %22, i64 %26
  %28 = load i32, i32* %27, align 4, !tbaa !77
  %29 = and i32 %28, 16777215
  %30 = or i32 %29, 33554432
  store i32 %30, i32* %27, align 4, !tbaa !77
  store i32 15, i32* %3, align 8, !tbaa !294
  br label %31

; <label>:31:                                     ; preds = %2, %18, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @discharge2reg(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !294
  switch i32 %6, label %78 [
    i32 1, label %7
    i32 3, label %8
    i32 2, label %8
    i32 4, label %16
    i32 5, label %20
    i32 6, label %47
    i32 15, label %50
    i32 7, label %65
  ]

; <label>:7:                                      ; preds = %3
  tail call fastcc void @luaK_nil(%struct.FuncState* %0, i32 %2, i32 1) #16
  br label %75

; <label>:8:                                      ; preds = %3, %3
  %9 = icmp eq i32 %6, 2
  %10 = zext i1 %9 to i32
  %11 = shl i32 %2, 7
  %12 = shl nuw nsw i32 %10, 16
  %13 = or i32 %11, %12
  %14 = or i32 %13, 5
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14) #17
  br label %75

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  %19 = load i32, i32* %18, align 8, !tbaa !21
  tail call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %2, i32 %19) #16
  br label %75

; <label>:20:                                     ; preds = %3
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %22 = bitcast %union.anon.8* %21 to double*
  %23 = load double, double* %22, align 8, !tbaa !21
  %24 = tail call double @llvm.floor.f64(double %23) #7
  %25 = fcmp une double %24, %23
  br i1 %25, label %42, label %26

; <label>:26:                                     ; preds = %20
  %27 = fcmp oge double %24, 0xC3E0000000000000
  %28 = fcmp olt double %24, 0x43E0000000000000
  %29 = and i1 %27, %28
  br i1 %29, label %30, label %42

; <label>:30:                                     ; preds = %26
  %31 = fptosi double %24 to i64
  %32 = add i64 %31, 65535
  %33 = icmp ugt i64 %32, 131071
  br i1 %33, label %42, label %34

; <label>:34:                                     ; preds = %30
  %35 = trunc i64 %31 to i32
  %36 = shl i32 %2, 7
  %37 = shl i32 %35, 15
  %38 = add i32 %37, 2147450880
  %39 = or i32 %36, %38
  %40 = or i32 %39, 2
  %41 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %40) #17
  br label %75

; <label>:42:                                     ; preds = %30, %26, %20
  %43 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %43) #7
  %44 = bitcast %struct.TValue* %4 to double*
  store double %23, double* %44, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 19, i8* %45, align 8, !tbaa !22
  %46 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %4, %struct.TValue* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %43) #7
  call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %2, i32 %46) #17
  br label %75

; <label>:47:                                     ; preds = %3
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %49 = load i64, i64* %48, align 8, !tbaa !21
  tail call fastcc void @luaK_int(%struct.FuncState* %0, i32 %2, i64 %49) #16
  br label %75

; <label>:50:                                     ; preds = %3
  %51 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %52 = load %struct.Proto*, %struct.Proto** %51, align 8, !tbaa !253
  %53 = getelementptr inbounds %struct.Proto, %struct.Proto* %52, i64 0, i32 16
  %54 = load i32*, i32** %53, align 8, !tbaa !116
  %55 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %56 = bitcast %union.anon.8* %55 to i32*
  %57 = load i32, i32* %56, align 8, !tbaa !21
  %58 = sext i32 %57 to i64
  %59 = getelementptr inbounds i32, i32* %54, i64 %58
  %60 = load i32, i32* %59, align 4, !tbaa !77
  %61 = and i32 %60, -32641
  %62 = shl i32 %2, 7
  %63 = and i32 %62, 32640
  %64 = or i32 %61, %63
  store i32 %64, i32* %59, align 4, !tbaa !77
  br label %75

; <label>:65:                                     ; preds = %3
  %66 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %67 = bitcast %union.anon.8* %66 to i32*
  %68 = load i32, i32* %67, align 8, !tbaa !21
  %69 = icmp eq i32 %68, %2
  br i1 %69, label %75, label %70

; <label>:70:                                     ; preds = %65
  %71 = shl i32 %2, 7
  %72 = shl i32 %68, 16
  %73 = or i32 %72, %71
  %74 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %73) #17
  br label %75

; <label>:75:                                     ; preds = %42, %34, %65, %70, %50, %47, %16, %8, %7
  %76 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %77 = bitcast %union.anon.8* %76 to i32*
  store i32 %2, i32* %77, align 8, !tbaa !21
  store i32 7, i32* %5, align 8, !tbaa !294
  br label %78

; <label>:78:                                     ; preds = %3, %75
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc i32 @need_value(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %36, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !253
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 16
  %8 = load i32*, i32** %7, align 8, !tbaa !116
  br label %9

; <label>:9:                                      ; preds = %4, %27
  %10 = phi i32 [ %1, %4 ], [ %34, %27 ]
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i32, i32* %8, i64 %11
  %13 = icmp sgt i32 %10, 0
  br i1 %13, label %14, label %21

; <label>:14:                                     ; preds = %9
  %15 = getelementptr inbounds i32, i32* %12, i64 -1
  %16 = load i32, i32* %15, align 4, !tbaa !77
  %17 = and i32 %16, 127
  %18 = zext i32 %17 to i64
  %19 = add nsw i64 %18, -58
  %20 = icmp ult i64 %19, 11
  br i1 %20, label %23, label %21

; <label>:21:                                     ; preds = %14, %9
  %22 = load i32, i32* %12, align 4, !tbaa !77
  br label %23

; <label>:23:                                     ; preds = %14, %21
  %24 = phi i32 [ %22, %21 ], [ %16, %14 ]
  %25 = and i32 %24, 127
  %26 = icmp eq i32 %25, 68
  br i1 %26, label %27, label %36

; <label>:27:                                     ; preds = %23
  %28 = load i32, i32* %12, align 4, !tbaa !77
  %29 = lshr i32 %28, 7
  %30 = add nsw i32 %29, -16777215
  %31 = icmp eq i32 %30, -1
  %32 = add nsw i32 %10, 1
  %33 = add nsw i32 %32, %30
  %34 = select i1 %31, i32 -1, i32 %33
  %35 = icmp eq i32 %34, -1
  br i1 %35, label %36, label %9

; <label>:36:                                     ; preds = %23, %27, %2
  %37 = phi i32 [ 0, %2 ], [ 0, %27 ], [ 1, %23 ]
  ret i32 %37
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @patchlistaux(%struct.FuncState* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = icmp eq i32 %1, -1
  br i1 %6, label %29, label %7

; <label>:7:                                      ; preds = %5
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  br label %9

; <label>:9:                                      ; preds = %7, %27
  %10 = phi i32 [ %1, %7 ], [ %22, %27 ]
  %11 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !253
  %12 = getelementptr inbounds %struct.Proto, %struct.Proto* %11, i64 0, i32 16
  %13 = load i32*, i32** %12, align 8, !tbaa !116
  %14 = sext i32 %10 to i64
  %15 = getelementptr inbounds i32, i32* %13, i64 %14
  %16 = load i32, i32* %15, align 4, !tbaa !77
  %17 = lshr i32 %16, 7
  %18 = add nsw i32 %17, -16777215
  %19 = icmp eq i32 %18, -1
  %20 = add nsw i32 %10, 1
  %21 = add nsw i32 %20, %18
  %22 = select i1 %19, i32 -1, i32 %21
  %23 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %10, i32 %3) #16
  %24 = icmp eq i32 %23, 0
  br i1 %24, label %26, label %25

; <label>:25:                                     ; preds = %9
  tail call fastcc void @fixjump(%struct.FuncState* nonnull %0, i32 %10, i32 %2) #16
  br label %27

; <label>:26:                                     ; preds = %9
  tail call fastcc void @fixjump(%struct.FuncState* nonnull %0, i32 %10, i32 %4) #16
  br label %27

; <label>:27:                                     ; preds = %26, %25
  %28 = icmp eq i32 %22, -1
  br i1 %28, label %29, label %9

; <label>:29:                                     ; preds = %27, %5
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_nil(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = add nsw i32 %2, %1
  %5 = add i32 %4, 255
  %6 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %7 = load i32, i32* %6, align 8, !tbaa !274
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 5
  %9 = load i32, i32* %8, align 4, !tbaa !276
  %10 = icmp sgt i32 %7, %9
  br i1 %10, label %11, label %19

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %13 = load %struct.Proto*, %struct.Proto** %12, align 8, !tbaa !253
  %14 = getelementptr inbounds %struct.Proto, %struct.Proto* %13, i64 0, i32 16
  %15 = load i32*, i32** %14, align 8, !tbaa !116
  %16 = add nsw i32 %7, -1
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, i32* %15, i64 %17
  br label %19

; <label>:19:                                     ; preds = %3, %11
  %20 = phi i32* [ %18, %11 ], [ @previousinstruction.invalidinstruction, %3 ]
  %21 = load i32, i32* %20, align 4, !tbaa !77
  %22 = and i32 %21, 127
  %23 = icmp eq i32 %22, 6
  br i1 %23, label %24, label %51

; <label>:24:                                     ; preds = %19
  %25 = lshr i32 %21, 7
  %26 = and i32 %25, 255
  %27 = lshr i32 %21, 16
  %28 = and i32 %27, 255
  %29 = add nuw nsw i32 %26, %28
  %30 = icmp sgt i32 %26, %1
  %31 = add nuw nsw i32 %29, 1
  %32 = icmp slt i32 %31, %1
  %33 = or i1 %30, %32
  br i1 %33, label %34, label %38

; <label>:34:                                     ; preds = %24
  %35 = icmp slt i32 %26, %1
  %36 = icmp sgt i32 %26, %4
  %37 = or i1 %35, %36
  br i1 %37, label %51, label %38

; <label>:38:                                     ; preds = %24, %34
  %39 = icmp slt i32 %26, %1
  %40 = select i1 %39, i32 %26, i32 %1
  %41 = icmp slt i32 %29, %4
  %42 = select i1 %41, i32 %5, i32 %29
  %43 = and i32 %21, -16744321
  %44 = shl i32 %40, 7
  %45 = and i32 %44, 32640
  %46 = or i32 %45, %43
  %47 = sub i32 %42, %40
  %48 = shl i32 %47, 16
  %49 = and i32 %48, 16711680
  %50 = or i32 %46, %49
  store i32 %50, i32* %20, align 4, !tbaa !77
  br label %58

; <label>:51:                                     ; preds = %34, %19
  %52 = shl i32 %1, 7
  %53 = shl i32 %2, 16
  %54 = add i32 %53, -65536
  %55 = or i32 %52, %54
  %56 = or i32 %55, 6
  %57 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %56) #17
  br label %58

; <label>:58:                                     ; preds = %38, %51
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_codek(%struct.FuncState* nocapture, i32, i32) unnamed_addr #0 {
  %4 = icmp slt i32 %2, 131072
  %5 = shl i32 %1, 7
  br i1 %4, label %6, label %11

; <label>:6:                                      ; preds = %3
  %7 = shl i32 %2, 15
  %8 = or i32 %5, %7
  %9 = or i32 %8, 3
  %10 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %9) #17
  br label %17

; <label>:11:                                     ; preds = %3
  %12 = or i32 %5, 4
  %13 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %12) #17
  %14 = shl i32 %2, 7
  %15 = or i32 %14, 83
  %16 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %15) #17
  br label %17

; <label>:17:                                     ; preds = %11, %6
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_int(%struct.FuncState* nocapture, i32, i64) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = alloca %struct.TValue, align 8
  %6 = add i64 %2, 65535
  %7 = icmp ugt i64 %6, 131071
  br i1 %7, label %16, label %8

; <label>:8:                                      ; preds = %3
  %9 = trunc i64 %2 to i32
  %10 = shl i32 %1, 7
  %11 = shl i32 %9, 15
  %12 = add i32 %11, 2147450880
  %13 = or i32 %10, %12
  %14 = or i32 %13, 1
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14) #17
  br label %25

; <label>:16:                                     ; preds = %3
  %17 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %17) #7
  %18 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %18) #7
  %19 = inttoptr i64 %2 to i8*
  %20 = bitcast %struct.TValue* %4 to i8**
  store i8* %19, i8** %20, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %21, align 8, !tbaa !22
  %22 = bitcast %struct.TValue* %5 to i64*
  store i64 %2, i64* %22, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %23, align 8, !tbaa !22
  %24 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %4, %struct.TValue* nonnull %5) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %18) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %17) #7
  call fastcc void @luaK_codek(%struct.FuncState* %0, i32 %1, i32 %24) #16
  br label %25

; <label>:25:                                     ; preds = %16, %8
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @addk(%struct.FuncState* nocapture, %struct.TValue* nocapture readonly, %struct.TValue*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %5 = load %struct.LexState*, %struct.LexState** %4, align 8, !tbaa !272
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 6
  %7 = load %struct.lua_State*, %struct.lua_State** %6, align 8, !tbaa !261
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !253
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %5, i64 0, i32 9
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !250
  %12 = tail call fastcc %struct.TValue* @luaH_set(%struct.lua_State* %7, %struct.Table* %11, %struct.TValue* %1) #16
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  %14 = load i8, i8* %13, align 8, !tbaa !22
  %15 = icmp eq i8 %14, 35
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %18 = bitcast %struct.TValue* %12 to i64*
  br label %42

; <label>:19:                                     ; preds = %3
  %20 = bitcast %struct.TValue* %12 to i64*
  %21 = load i64, i64* %20, align 8, !tbaa !21
  %22 = trunc i64 %21 to i32
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 7
  %24 = load i32, i32* %23, align 4, !tbaa !277
  %25 = icmp sgt i32 %24, %22
  br i1 %25, label %26, label %42

; <label>:26:                                     ; preds = %19
  %27 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !223
  %29 = shl i64 %21, 32
  %30 = ashr exact i64 %29, 32
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %30, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = xor i8 %34, %32
  %36 = and i8 %35, 63
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %42

; <label>:38:                                     ; preds = %26
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 %30
  %40 = tail call fastcc i32 @luaV_equalobj(%struct.lua_State* null, %struct.TValue* %39, %struct.TValue* nonnull %2) #16
  %41 = icmp eq i32 %40, 0
  br i1 %41, label %42, label %91

; <label>:42:                                     ; preds = %16, %38, %19, %26
  %43 = phi i64* [ %18, %16 ], [ %20, %38 ], [ %20, %19 ], [ %20, %26 ]
  %44 = phi i32* [ %17, %16 ], [ %23, %38 ], [ %23, %19 ], [ %23, %26 ]
  %45 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 7
  %46 = load i32, i32* %45, align 4, !tbaa !224
  %47 = load i32, i32* %44, align 4, !tbaa !277
  %48 = sext i32 %47 to i64
  store i64 %48, i64* %43, align 8, !tbaa !21
  store i8 35, i8* %13, align 8, !tbaa !22
  %49 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 15
  %50 = bitcast %struct.TValue** %49 to i8**
  %51 = load i8*, i8** %50, align 8, !tbaa !223
  %52 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %7, i8* %51, i32 %47, i32* nonnull %45, i32 16, i32 33554431, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.250, i64 0, i64 0)) #16
  store i8* %52, i8** %50, align 8, !tbaa !223
  %53 = load i32, i32* %45, align 4, !tbaa !224
  %54 = icmp slt i32 %46, %53
  %55 = bitcast i8* %52 to %struct.TValue*
  br i1 %54, label %56, label %64

; <label>:56:                                     ; preds = %42
  %57 = sext i32 %46 to i64
  %58 = sext i32 %53 to i64
  br label %59

; <label>:59:                                     ; preds = %56, %59
  %60 = phi i64 [ %57, %56 ], [ %61, %59 ]
  %61 = add nsw i64 %60, 1
  %62 = getelementptr inbounds %struct.TValue, %struct.TValue* %55, i64 %60, i32 1
  store i8 0, i8* %62, align 8, !tbaa !22
  %63 = icmp slt i64 %61, %58
  br i1 %63, label %59, label %64

; <label>:64:                                     ; preds = %59, %42
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %55, i64 %48
  %66 = bitcast %struct.TValue* %2 to i64*
  %67 = bitcast %struct.TValue* %65 to i64*
  %68 = load i64, i64* %66, align 8
  store i64 %68, i64* %67, align 8
  %69 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 1
  %70 = load i8, i8* %69, align 8, !tbaa !22
  %71 = getelementptr inbounds %struct.TValue, %struct.TValue* %55, i64 %48, i32 1
  store i8 %70, i8* %71, align 8, !tbaa !22
  %72 = load i32, i32* %44, align 4, !tbaa !277
  %73 = add nsw i32 %72, 1
  store i32 %73, i32* %44, align 4, !tbaa !277
  %74 = load i8, i8* %69, align 8, !tbaa !22
  %75 = and i8 %74, 64
  %76 = icmp eq i8 %75, 0
  br i1 %76, label %91, label %77

; <label>:77:                                     ; preds = %64
  %78 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 2
  %79 = load i8, i8* %78, align 1, !tbaa !234
  %80 = and i8 %79, 32
  %81 = icmp eq i8 %80, 0
  br i1 %81, label %91, label %82

; <label>:82:                                     ; preds = %77
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %2, i64 0, i32 0, i32 0
  %84 = load %struct.GCObject*, %struct.GCObject** %83, align 8, !tbaa !21
  %85 = getelementptr inbounds %struct.GCObject, %struct.GCObject* %84, i64 0, i32 2
  %86 = load i8, i8* %85, align 1, !tbaa !70
  %87 = and i8 %86, 24
  %88 = icmp eq i8 %87, 0
  br i1 %88, label %91, label %89

; <label>:89:                                     ; preds = %82
  %90 = bitcast %struct.Proto* %9 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %7, %struct.GCObject* %90, %struct.GCObject* %84) #16
  br label %91

; <label>:91:                                     ; preds = %89, %64, %77, %82, %38
  %92 = phi i32 [ %22, %38 ], [ %47, %82 ], [ %47, %77 ], [ %47, %64 ], [ %47, %89 ]
  ret i32 %92
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i32 @patchtestreg(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #2 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !253
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !116
  %8 = sext i32 %1 to i64
  %9 = getelementptr inbounds i32, i32* %7, i64 %8
  %10 = icmp sgt i32 %1, 0
  br i1 %10, label %11, label %18

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds i32, i32* %9, i64 -1
  %13 = load i32, i32* %12, align 4, !tbaa !77
  %14 = and i32 %13, 127
  %15 = zext i32 %14 to i64
  %16 = add nsw i64 %15, -58
  %17 = icmp ult i64 %16, 11
  br i1 %17, label %20, label %18

; <label>:18:                                     ; preds = %11, %3
  %19 = load i32, i32* %9, align 4, !tbaa !77
  br label %20

; <label>:20:                                     ; preds = %11, %18
  %21 = phi i32 [ %19, %18 ], [ %13, %11 ]
  %22 = phi i32* [ %9, %18 ], [ %12, %11 ]
  %23 = and i32 %21, 127
  %24 = icmp eq i32 %23, 68
  br i1 %24, label %25, label %44

; <label>:25:                                     ; preds = %20
  %26 = icmp eq i32 %2, 255
  br i1 %26, label %36, label %27

; <label>:27:                                     ; preds = %25
  %28 = lshr i32 %21, 16
  %29 = and i32 %28, 255
  %30 = icmp eq i32 %29, %2
  br i1 %30, label %36, label %31

; <label>:31:                                     ; preds = %27
  %32 = and i32 %21, -32641
  %33 = shl i32 %2, 7
  %34 = and i32 %33, 32640
  %35 = or i32 %32, %34
  br label %42

; <label>:36:                                     ; preds = %27, %25
  %37 = lshr i32 %21, 9
  %38 = and i32 %37, 32640
  %39 = and i32 %21, 32768
  %40 = or i32 %39, %38
  %41 = or i32 %40, 67
  br label %42

; <label>:42:                                     ; preds = %36, %31
  %43 = phi i32 [ %41, %36 ], [ %35, %31 ]
  store i32 %43, i32* %22, align 4, !tbaa !77
  br label %44

; <label>:44:                                     ; preds = %20, %42
  %45 = phi i32 [ 1, %42 ], [ 0, %20 ]
  ret i32 %45
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fixjump(%struct.FuncState* nocapture readonly, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !253
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !116
  %8 = sext i32 %1 to i64
  %9 = getelementptr inbounds i32, i32* %7, i64 %8
  %10 = xor i32 %1, -1
  %11 = add i32 %10, %2
  %12 = add i32 %11, 16777215
  %13 = icmp ult i32 %12, 33554432
  br i1 %13, label %17, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %16 = load %struct.LexState*, %struct.LexState** %15, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %16, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #18
  unreachable

; <label>:17:                                     ; preds = %3
  %18 = load i32, i32* %9, align 4, !tbaa !77
  %19 = and i32 %18, 127
  %20 = shl i32 %11, 7
  %21 = add i32 %20, 2147483520
  %22 = or i32 %19, %21
  store i32 %22, i32* %9, align 4, !tbaa !77
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_checkstack(%struct.FuncState* nocapture readonly, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %4 = load i8, i8* %3, align 4, !tbaa !303
  %5 = zext i8 %4 to i32
  %6 = add nsw i32 %5, %1
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !253
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 5
  %10 = load i8, i8* %9, align 4, !tbaa !158
  %11 = zext i8 %10 to i32
  %12 = icmp sgt i32 %6, %11
  br i1 %12, label %13, label %20

; <label>:13:                                     ; preds = %2
  %14 = icmp sgt i32 %6, 254
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %13
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %17 = load %struct.LexState*, %struct.LexState** %16, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %17, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.252, i64 0, i64 0)) #18
  unreachable

; <label>:18:                                     ; preds = %13
  %19 = trunc i32 %6 to i8
  store i8 %19, i8* %9, align 4, !tbaa !158
  br label %20

; <label>:20:                                     ; preds = %18, %2
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @removelastlineinfo(%struct.FuncState* nocapture) unnamed_addr #2 {
  %2 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %3 = load %struct.Proto*, %struct.Proto** %2, align 8, !tbaa !253
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !274
  %6 = add nsw i32 %5, -1
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %3, i64 0, i32 19
  %8 = load i8*, i8** %7, align 8, !tbaa !137
  %9 = sext i32 %6 to i64
  %10 = getelementptr inbounds i8, i8* %8, i64 %9
  %11 = load i8, i8* %10, align 1, !tbaa !21
  %12 = icmp eq i8 %11, -128
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %1
  %14 = sext i8 %11 to i32
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 6
  %16 = load i32, i32* %15, align 8, !tbaa !275
  %17 = sub nsw i32 %16, %14
  store i32 %17, i32* %15, align 8, !tbaa !275
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  %19 = load i8, i8* %18, align 1, !tbaa !301
  %20 = add i8 %19, -1
  store i8 %20, i8* %18, align 1, !tbaa !301
  br label %26

; <label>:21:                                     ; preds = %1
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 9
  %23 = load i32, i32* %22, align 4, !tbaa !278
  %24 = add nsw i32 %23, -1
  store i32 %24, i32* %22, align 4, !tbaa !278
  %25 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 16
  store i8 121, i8* %25, align 1, !tbaa !301
  br label %26

; <label>:26:                                     ; preds = %21, %13
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @discharge2anyreg(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !294
  %5 = icmp eq i32 %4, 7
  br i1 %5, label %12, label %6

; <label>:6:                                      ; preds = %2
  tail call fastcc void @luaK_checkstack(%struct.FuncState* %0, i32 1) #17
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %8 = load i8, i8* %7, align 4, !tbaa !303
  %9 = add i8 %8, 1
  store i8 %9, i8* %7, align 4, !tbaa !303
  %10 = zext i8 %9 to i32
  %11 = add nsw i32 %10, -1
  tail call fastcc void @discharge2reg(%struct.FuncState* %0, %struct.expdesc* nonnull %1, i32 %11) #16
  br label %12

; <label>:12:                                     ; preds = %2, %6
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @removevalues(%struct.FuncState* nocapture readonly, i32) unnamed_addr #2 {
  %3 = icmp eq i32 %1, -1
  br i1 %3, label %22, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  br label %6

; <label>:6:                                      ; preds = %4, %6
  %7 = phi i32 [ %1, %4 ], [ %20, %6 ]
  %8 = tail call fastcc i32 @patchtestreg(%struct.FuncState* %0, i32 %7, i32 255) #16
  %9 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !253
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !116
  %12 = sext i32 %7 to i64
  %13 = getelementptr inbounds i32, i32* %11, i64 %12
  %14 = load i32, i32* %13, align 4, !tbaa !77
  %15 = lshr i32 %14, 7
  %16 = add nsw i32 %15, -16777215
  %17 = icmp eq i32 %16, -1
  %18 = add nsw i32 %7, 1
  %19 = add nsw i32 %18, %16
  %20 = select i1 %17, i32 -1, i32 %19
  %21 = icmp eq i32 %20, -1
  br i1 %21, label %22, label %6

; <label>:22:                                     ; preds = %6, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @constructor(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.ConsControl, align 8
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %5 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !273
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %7 = load i32, i32* %6, align 4, !tbaa !265
  %8 = tail call fastcc i32 @luaK_code(%struct.FuncState* %5, i32 17) #17
  %9 = bitcast %struct.ConsControl* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* nonnull %9) #7
  %10 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 4
  store i32 0, i32* %10, align 8, !tbaa !325
  %11 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 2
  store i32 0, i32* %11, align 8, !tbaa !327
  %12 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 3
  store i32 0, i32* %12, align 4, !tbaa !328
  %13 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 1
  store %struct.expdesc* %1, %struct.expdesc** %13, align 8, !tbaa !329
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %14, align 8, !tbaa !291
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %15, align 4, !tbaa !293
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %16, align 8, !tbaa !294
  %17 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %18 = bitcast %union.anon.8* %17 to i32*
  store i32 %8, i32* %18, align 8, !tbaa !21
  %19 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0
  %20 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 2
  store i32 -1, i32* %20, align 8, !tbaa !291
  %21 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 3
  store i32 -1, i32* %21, align 4, !tbaa !293
  %22 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 0
  store i32 0, i32* %22, align 8, !tbaa !294
  %23 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %3, i64 0, i32 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  store i32 0, i32* %24, align 8, !tbaa !21
  %25 = load %struct.FuncState*, %struct.FuncState** %4, align 8, !tbaa !273
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %25, %struct.expdesc* %1) #16
  tail call fastcc void @checknext(%struct.LexState* %0, i32 123) #16
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %27 = load i32, i32* %26, align 8, !tbaa !260
  %28 = icmp eq i32 %27, 125
  br i1 %28, label %93, label %29

; <label>:29:                                     ; preds = %2
  %30 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 1
  %31 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4, i32 0
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  %33 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %34 = getelementptr inbounds %struct.Token, %struct.Token* %33, i64 0, i32 0
  %35 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %36 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %37 = bitcast %struct.Token* %36 to i8*
  %38 = bitcast %struct.Token* %33 to i8*
  br label %46

; <label>:39:                                     ; preds = %90, %83
  store i32 289, i32* %34, align 8, !tbaa !263
  %40 = load i32, i32* %26, align 8, !tbaa !260
  br label %41

; <label>:41:                                     ; preds = %39, %84, %91
  %42 = phi i32 [ %40, %39 ], [ %85, %84 ], [ %92, %91 ]
  %43 = icmp eq i32 %42, 125
  br i1 %43, label %93, label %44

; <label>:44:                                     ; preds = %41
  %45 = load i32, i32* %22, align 8, !tbaa !330
  br label %46

; <label>:46:                                     ; preds = %44, %29
  %47 = phi i32 [ %45, %44 ], [ 0, %29 ]
  %48 = icmp eq i32 %47, 0
  br i1 %48, label %58, label %49

; <label>:49:                                     ; preds = %46
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %19) #17
  store i32 0, i32* %22, align 8, !tbaa !330
  %50 = load i32, i32* %10, align 8, !tbaa !325
  %51 = icmp eq i32 %50, 50
  br i1 %51, label %52, label %58

; <label>:52:                                     ; preds = %49
  %53 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !329
  %54 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %53, i64 0, i32 1
  %55 = bitcast %union.anon.8* %54 to i32*
  %56 = load i32, i32* %55, align 8, !tbaa !21
  %57 = load i32, i32* %12, align 4, !tbaa !328
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %56, i32 %57, i32 50) #17
  store i32 0, i32* %10, align 8, !tbaa !325
  br label %58

; <label>:58:                                     ; preds = %46, %49, %52
  %59 = load i32, i32* %26, align 8, !tbaa !260
  switch i32 %59, label %71 [
    i32 292, label %60
    i32 91, label %70
  ]

; <label>:60:                                     ; preds = %58
  %61 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %30) #17
  store i32 %61, i32* %31, align 8, !tbaa !263
  %62 = icmp eq i32 %61, 61
  br i1 %62, label %69, label %63

; <label>:63:                                     ; preds = %60
  %64 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %19, i32 0) #17
  %65 = load i32, i32* %12, align 4, !tbaa !328
  %66 = add nsw i32 %65, 1
  store i32 %66, i32* %12, align 4, !tbaa !328
  %67 = load i32, i32* %10, align 8, !tbaa !325
  %68 = add nsw i32 %67, 1
  store i32 %68, i32* %10, align 8, !tbaa !325
  br label %77

; <label>:69:                                     ; preds = %60
  call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %77

; <label>:70:                                     ; preds = %58
  call fastcc void @recfield(%struct.LexState* nonnull %0, %struct.ConsControl* nonnull %3) #17
  br label %77

; <label>:71:                                     ; preds = %58
  %72 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %19, i32 0) #17
  %73 = load i32, i32* %12, align 4, !tbaa !328
  %74 = add nsw i32 %73, 1
  store i32 %74, i32* %12, align 4, !tbaa !328
  %75 = load i32, i32* %10, align 8, !tbaa !325
  %76 = add nsw i32 %75, 1
  store i32 %76, i32* %10, align 8, !tbaa !325
  br label %77

; <label>:77:                                     ; preds = %63, %69, %70, %71
  %78 = load i32, i32* %26, align 8, !tbaa !260
  switch i32 %78, label %93 [
    i32 44, label %79
    i32 59, label %86
  ]

; <label>:79:                                     ; preds = %77
  %80 = load i32, i32* %6, align 4, !tbaa !265
  store i32 %80, i32* %32, align 8, !tbaa !266
  %81 = load i32, i32* %34, align 8, !tbaa !263
  %82 = icmp eq i32 %81, 289
  br i1 %82, label %84, label %83

; <label>:83:                                     ; preds = %79
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %37, i8* nonnull %38, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  br label %39

; <label>:84:                                     ; preds = %79
  %85 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %35) #17
  store i32 %85, i32* %26, align 8, !tbaa !260
  br label %41

; <label>:86:                                     ; preds = %77
  %87 = load i32, i32* %6, align 4, !tbaa !265
  store i32 %87, i32* %32, align 8, !tbaa !266
  %88 = load i32, i32* %34, align 8, !tbaa !263
  %89 = icmp eq i32 %88, 289
  br i1 %89, label %91, label %90

; <label>:90:                                     ; preds = %86
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %37, i8* nonnull %38, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  br label %39

; <label>:91:                                     ; preds = %86
  %92 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %35) #17
  store i32 %92, i32* %26, align 8, !tbaa !260
  br label %41

; <label>:93:                                     ; preds = %41, %77, %2
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 125, i32 123, i32 %7) #16
  %94 = load i32, i32* %10, align 8, !tbaa !325
  %95 = icmp eq i32 %94, 0
  br i1 %95, label %115, label %96

; <label>:96:                                     ; preds = %93
  %97 = load i32, i32* %22, align 8, !tbaa !330
  switch i32 %97, label %106 [
    i32 16, label %98
    i32 17, label %98
    i32 0, label %108
  ]

; <label>:98:                                     ; preds = %96, %96
  call fastcc void @luaK_setreturns(%struct.FuncState* %5, %struct.expdesc* nonnull %19, i32 -1) #17
  %99 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !329
  %100 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %99, i64 0, i32 1
  %101 = bitcast %union.anon.8* %100 to i32*
  %102 = load i32, i32* %101, align 8, !tbaa !21
  %103 = load i32, i32* %12, align 4, !tbaa !328
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %102, i32 %103, i32 -1) #17
  %104 = load i32, i32* %12, align 4, !tbaa !328
  %105 = add nsw i32 %104, -1
  store i32 %105, i32* %12, align 4, !tbaa !328
  br label %115

; <label>:106:                                    ; preds = %96
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %5, %struct.expdesc* nonnull %19) #17
  %107 = load i32, i32* %10, align 8, !tbaa !325
  br label %108

; <label>:108:                                    ; preds = %106, %96
  %109 = phi i32 [ %94, %96 ], [ %107, %106 ]
  %110 = load %struct.expdesc*, %struct.expdesc** %13, align 8, !tbaa !329
  %111 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %110, i64 0, i32 1
  %112 = bitcast %union.anon.8* %111 to i32*
  %113 = load i32, i32* %112, align 8, !tbaa !21
  %114 = load i32, i32* %12, align 4, !tbaa !328
  call fastcc void @luaK_setlist(%struct.FuncState* %5, i32 %113, i32 %114, i32 %109) #17
  br label %115

; <label>:115:                                    ; preds = %93, %98, %108
  %116 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  %117 = load %struct.Proto*, %struct.Proto** %116, align 8, !tbaa !253
  %118 = getelementptr inbounds %struct.Proto, %struct.Proto* %117, i64 0, i32 16
  %119 = load i32*, i32** %118, align 8, !tbaa !116
  %120 = sext i32 %8 to i64
  %121 = getelementptr inbounds i32, i32* %119, i64 %120
  %122 = load i32, i32* %121, align 4, !tbaa !77
  %123 = and i32 %122, -16711681
  %124 = load i32, i32* %12, align 4, !tbaa !328
  %125 = call fastcc i32 @luaO_int2fb(i32 %124) #16
  %126 = shl i32 %125, 16
  %127 = and i32 %126, 16711680
  %128 = or i32 %127, %123
  store i32 %128, i32* %121, align 4, !tbaa !77
  %129 = and i32 %128, 16777215
  %130 = load i32, i32* %11, align 8, !tbaa !327
  %131 = call fastcc i32 @luaO_int2fb(i32 %130) #16
  %132 = shl i32 %131, 24
  %133 = or i32 %129, %132
  store i32 %133, i32* %121, align 4, !tbaa !77
  call void @llvm.lifetime.end.p0i8(i64 48, i8* nonnull %9) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @body(%struct.LexState*, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %5 = alloca %struct.FuncState, align 8
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.FuncState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %7) #7
  %8 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !261
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %12 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !273
  %13 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %12, i64 0, i32 0
  %14 = load %struct.Proto*, %struct.Proto** %13, align 8, !tbaa !253
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %12, i64 0, i32 8
  %16 = load i32, i32* %15, align 8, !tbaa !279
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 10
  %18 = load i32, i32* %17, align 8, !tbaa !222
  %19 = icmp slt i32 %16, %18
  %20 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 17
  br i1 %19, label %41, label %21

; <label>:21:                                     ; preds = %4
  %22 = bitcast %struct.Proto*** %20 to i8**
  %23 = load i8*, i8** %22, align 8, !tbaa !221
  %24 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %10, i8* %23, i32 %16, i32* nonnull %17, i32 8, i32 131071, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.257, i64 0, i64 0)) #17
  store i8* %24, i8** %22, align 8, !tbaa !221
  %25 = load i32, i32* %17, align 8, !tbaa !222
  %26 = icmp slt i32 %18, %25
  br i1 %26, label %27, label %41

; <label>:27:                                     ; preds = %21
  %28 = bitcast i8* %24 to %struct.Proto**
  %29 = sext i32 %18 to i64
  %30 = sext i32 %25 to i64
  %31 = add nsw i64 %29, 1
  %32 = getelementptr inbounds %struct.Proto*, %struct.Proto** %28, i64 %29
  store %struct.Proto* null, %struct.Proto** %32, align 8, !tbaa !54
  %33 = icmp slt i64 %31, %30
  br i1 %33, label %34, label %41

; <label>:34:                                     ; preds = %27
  br label %35

; <label>:35:                                     ; preds = %34, %35
  %36 = phi i64 [ %38, %35 ], [ %31, %34 ]
  %37 = load %struct.Proto**, %struct.Proto*** %20, align 8, !tbaa !221
  %38 = add nsw i64 %36, 1
  %39 = getelementptr inbounds %struct.Proto*, %struct.Proto** %37, i64 %36
  store %struct.Proto* null, %struct.Proto** %39, align 8, !tbaa !54
  %40 = icmp eq i64 %38, %30
  br i1 %40, label %41, label %35

; <label>:41:                                     ; preds = %35, %27, %21, %4
  %42 = tail call fastcc %struct.Proto* @luaF_newproto(%struct.lua_State* %10) #17
  %43 = load %struct.Proto**, %struct.Proto*** %20, align 8, !tbaa !221
  %44 = load i32, i32* %15, align 8, !tbaa !279
  %45 = add nsw i32 %44, 1
  store i32 %45, i32* %15, align 8, !tbaa !279
  %46 = sext i32 %44 to i64
  %47 = getelementptr inbounds %struct.Proto*, %struct.Proto** %43, i64 %46
  store %struct.Proto* %42, %struct.Proto** %47, align 8, !tbaa !54
  %48 = getelementptr inbounds %struct.Proto, %struct.Proto* %14, i64 0, i32 2
  %49 = load i8, i8* %48, align 1, !tbaa !234
  %50 = and i8 %49, 32
  %51 = icmp eq i8 %50, 0
  br i1 %51, label %60, label %52

; <label>:52:                                     ; preds = %41
  %53 = getelementptr inbounds %struct.Proto, %struct.Proto* %42, i64 0, i32 2
  %54 = load i8, i8* %53, align 1, !tbaa !234
  %55 = and i8 %54, 24
  %56 = icmp eq i8 %55, 0
  br i1 %56, label %60, label %57

; <label>:57:                                     ; preds = %52
  %58 = bitcast %struct.Proto* %14 to %struct.GCObject*
  %59 = bitcast %struct.Proto* %42 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %10, %struct.GCObject* %58, %struct.GCObject* %59) #17
  br label %60

; <label>:60:                                     ; preds = %41, %52, %57
  %61 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 0
  store %struct.Proto* %42, %struct.Proto** %61, align 8, !tbaa !253
  %62 = getelementptr inbounds %struct.Proto, %struct.Proto* %42, i64 0, i32 13
  store i32 %3, i32* %62, align 4, !tbaa !124
  %63 = bitcast %struct.FuncState** %11 to i64*
  %64 = load i64, i64* %63, align 8, !tbaa !273
  %65 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 1
  %66 = bitcast %struct.FuncState** %65 to i64*
  store i64 %64, i64* %66, align 8, !tbaa !271
  %67 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 2
  store %struct.LexState* %0, %struct.LexState** %67, align 8, !tbaa !272
  store %struct.FuncState* %5, %struct.FuncState** %11, align 8, !tbaa !273
  %68 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 4
  store i32 0, i32* %68, align 8, !tbaa !274
  %69 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 6
  store i32 %3, i32* %69, align 8, !tbaa !275
  %70 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 5
  store i32 0, i32* %70, align 4, !tbaa !276
  %71 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 7
  store i32 0, i32* %71, align 4, !tbaa !277
  %72 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 9
  store i32 0, i32* %72, align 4, !tbaa !278
  %73 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 8
  store i32 0, i32* %73, align 8, !tbaa !279
  %74 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 12
  %75 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %76 = bitcast i16* %74 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull %76, i8 0, i64 7, i32 8, i1 false) #7
  %77 = load %struct.Dyndata*, %struct.Dyndata** %75, align 8, !tbaa !256
  %78 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %77, i64 0, i32 0, i32 1
  %79 = load i32, i32* %78, align 8, !tbaa !259
  %80 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 10
  store i32 %79, i32* %80, align 8, !tbaa !280
  %81 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %77, i64 0, i32 2, i32 1
  %82 = load i32, i32* %81, align 8, !tbaa !257
  %83 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 11
  store i32 %82, i32* %83, align 4, !tbaa !281
  %84 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %5, i64 0, i32 3
  %85 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 11
  %86 = bitcast %struct.TString** %85 to i64*
  %87 = load i64, i64* %86, align 8, !tbaa !267
  %88 = getelementptr inbounds %struct.Proto, %struct.Proto* %42, i64 0, i32 22
  %89 = bitcast %struct.TString** %88 to i64*
  store i64 %87, i64* %89, align 8, !tbaa !122
  %90 = getelementptr inbounds %struct.Proto, %struct.Proto* %42, i64 0, i32 5
  store i8 2, i8* %90, align 4, !tbaa !158
  %91 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 5
  store i8 0, i8* %91, align 2, !tbaa !282
  %92 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 3
  store i8 0, i8* %92, align 8, !tbaa !284
  %93 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 1
  store i32 %82, i32* %93, align 8, !tbaa !285
  %94 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %77, i64 0, i32 1, i32 1
  %95 = load i32, i32* %94, align 8, !tbaa !258
  %96 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 2
  store i32 %95, i32* %96, align 4, !tbaa !286
  %97 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 4
  store i8 0, i8* %97, align 1, !tbaa !287
  %98 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 6
  store i8 0, i8* %98, align 1, !tbaa !288
  %99 = bitcast %struct.BlockCnt* %6 to i64*
  store i64 0, i64* %99, align 8, !tbaa !289
  store %struct.BlockCnt* %6, %struct.BlockCnt** %84, align 8, !tbaa !290
  call fastcc void @checknext(%struct.LexState* %0, i32 40) #16
  %100 = icmp eq i32 %2, 0
  br i1 %100, label %103, label %101

; <label>:101:                                    ; preds = %60
  %102 = call fastcc %struct.TString* @luaX_newstring(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.256, i64 0, i64 0), i64 4) #16
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %102) #16
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 1) #16
  br label %103

; <label>:103:                                    ; preds = %60, %101
  %104 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !273
  %105 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %104, i64 0, i32 0
  %106 = load %struct.Proto*, %struct.Proto** %105, align 8, !tbaa !253
  %107 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %108 = load i32, i32* %107, align 8, !tbaa !260
  %109 = icmp eq i32 %108, 41
  br i1 %109, label %145, label %110

; <label>:110:                                    ; preds = %103
  %111 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %112 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  %113 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %114 = getelementptr inbounds %struct.Token, %struct.Token* %113, i64 0, i32 0
  %115 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %116 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %117 = bitcast %struct.Token* %116 to i8*
  %118 = bitcast %struct.Token* %113 to i8*
  br label %119

; <label>:119:                                    ; preds = %143, %110
  %120 = phi i32 [ %108, %110 ], [ %144, %143 ]
  %121 = phi i32 [ 0, %110 ], [ %132, %143 ]
  switch i32 %120, label %129 [
    i32 292, label %130
    i32 281, label %122
  ]

; <label>:122:                                    ; preds = %119
  %123 = load i32, i32* %111, align 4, !tbaa !265
  store i32 %123, i32* %112, align 8, !tbaa !266
  %124 = load i32, i32* %114, align 8, !tbaa !263
  %125 = icmp eq i32 %124, 289
  br i1 %125, label %127, label %126

; <label>:126:                                    ; preds = %122
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %117, i8* nonnull %118, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %114, align 8, !tbaa !263
  br label %145

; <label>:127:                                    ; preds = %122
  %128 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %115) #17
  store i32 %128, i32* %107, align 8, !tbaa !260
  br label %145

; <label>:129:                                    ; preds = %119
  call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.259, i64 0, i64 0)) #19
  unreachable

; <label>:130:                                    ; preds = %119
  %131 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  call fastcc void @new_localvar(%struct.LexState* nonnull %0, %struct.TString* %131) #17
  %132 = add nuw nsw i32 %121, 1
  %133 = load i32, i32* %107, align 8, !tbaa !260
  %134 = icmp eq i32 %133, 44
  br i1 %134, label %135, label %145

; <label>:135:                                    ; preds = %130
  %136 = load i32, i32* %111, align 4, !tbaa !265
  store i32 %136, i32* %112, align 8, !tbaa !266
  %137 = load i32, i32* %114, align 8, !tbaa !263
  %138 = icmp eq i32 %137, 289
  br i1 %138, label %141, label %139

; <label>:139:                                    ; preds = %135
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %117, i8* nonnull %118, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %114, align 8, !tbaa !263
  %140 = load i32, i32* %107, align 8, !tbaa !260
  br label %143

; <label>:141:                                    ; preds = %135
  %142 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %115) #17
  store i32 %142, i32* %107, align 8, !tbaa !260
  br label %143

; <label>:143:                                    ; preds = %141, %139
  %144 = phi i32 [ %140, %139 ], [ %142, %141 ]
  br label %119

; <label>:145:                                    ; preds = %130, %127, %126, %103
  %146 = phi i32 [ 0, %103 ], [ %121, %126 ], [ %121, %127 ], [ %132, %130 ]
  %147 = phi i1 [ true, %103 ], [ false, %126 ], [ false, %127 ], [ true, %130 ]
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 %146) #17
  %148 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %104, i64 0, i32 13
  %149 = load i8, i8* %148, align 2, !tbaa !298
  %150 = getelementptr inbounds %struct.Proto, %struct.Proto* %106, i64 0, i32 3
  store i8 %149, i8* %150, align 2, !tbaa !131
  br i1 %147, label %159, label %151

; <label>:151:                                    ; preds = %145
  %152 = zext i8 %149 to i32
  %153 = load %struct.Proto*, %struct.Proto** %105, align 8, !tbaa !253
  %154 = getelementptr inbounds %struct.Proto, %struct.Proto* %153, i64 0, i32 4
  store i8 1, i8* %154, align 1, !tbaa !115
  %155 = shl nuw nsw i32 %152, 7
  %156 = or i32 %155, 82
  %157 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %104, i32 %156) #17
  %158 = load i8, i8* %148, align 2, !tbaa !298
  br label %159

; <label>:159:                                    ; preds = %145, %151
  %160 = phi i8 [ %149, %145 ], [ %158, %151 ]
  %161 = zext i8 %160 to i32
  call fastcc void @luaK_checkstack(%struct.FuncState* nonnull %104, i32 %161) #17
  %162 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %104, i64 0, i32 15
  %163 = load i8, i8* %162, align 4, !tbaa !303
  %164 = add i8 %163, %160
  store i8 %164, i8* %162, align 4, !tbaa !303
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 41) #16
  br label %165

; <label>:165:                                    ; preds = %167, %159
  %166 = load i32, i32* %107, align 8, !tbaa !260
  switch i32 %166, label %167 [
    i32 260, label %169
    i32 261, label %169
    i32 262, label %169
    i32 289, label %169
    i32 277, label %169
  ]

; <label>:167:                                    ; preds = %165
  %168 = icmp eq i32 %166, 274
  call fastcc void @statement(%struct.LexState* nonnull %0) #17
  br i1 %168, label %169, label %165

; <label>:169:                                    ; preds = %165, %165, %165, %165, %165, %167
  %170 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %171 = load i32, i32* %170, align 4, !tbaa !265
  %172 = load %struct.Proto*, %struct.Proto** %61, align 8, !tbaa !253
  %173 = getelementptr inbounds %struct.Proto, %struct.Proto* %172, i64 0, i32 14
  store i32 %171, i32* %173, align 8, !tbaa !125
  call fastcc void @check_match(%struct.LexState* %0, i32 262, i32 265, i32 %3) #16
  %174 = load %struct.FuncState*, %struct.FuncState** %11, align 8, !tbaa !273
  %175 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %174, i64 0, i32 1
  %176 = load %struct.FuncState*, %struct.FuncState** %175, align 8, !tbaa !271
  %177 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %176, i64 0, i32 8
  %178 = load i32, i32* %177, align 8, !tbaa !279
  %179 = shl i32 %178, 15
  %180 = add i32 %179, -32768
  %181 = or i32 %180, 80
  %182 = call fastcc i32 @luaK_code(%struct.FuncState* %176, i32 %181) #17
  %183 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %183, align 8, !tbaa !291
  %184 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %184, align 4, !tbaa !293
  %185 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 15, i32* %185, align 8, !tbaa !294
  %186 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %187 = bitcast %union.anon.8* %186 to i32*
  store i32 %182, i32* %187, align 8, !tbaa !21
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %176, %struct.expdesc* %1) #17
  call fastcc void @close_func(%struct.LexState* %0) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @suffixedexp(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 4, !tbaa !265
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %11 = load i32, i32* %10, align 8, !tbaa !260
  switch i32 %11, label %32 [
    i32 40, label %12
    i32 292, label %28
  ]

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %9, i32* %13, align 8, !tbaa !266
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %15 = getelementptr inbounds %struct.Token, %struct.Token* %14, i64 0, i32 0
  %16 = load i32, i32* %15, align 8, !tbaa !263
  %17 = icmp eq i32 %16, 289
  br i1 %17, label %22, label %18

; <label>:18:                                     ; preds = %12
  %19 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %20 = bitcast %struct.Token* %19 to i8*
  %21 = bitcast %struct.Token* %14 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %20, i8* nonnull %21, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %15, align 8, !tbaa !263
  br label %25

; <label>:22:                                     ; preds = %12
  %23 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %24 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %23) #17
  store i32 %24, i32* %10, align 8, !tbaa !260
  br label %25

; <label>:25:                                     ; preds = %22, %18
  %26 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0) #17
  tail call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %9) #17
  %27 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %27, %struct.expdesc* %1) #17
  br label %33

; <label>:28:                                     ; preds = %2
  tail call fastcc void @singlevar(%struct.LexState* nonnull %0, %struct.expdesc* %1) #17
  %29 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  %30 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %31 = getelementptr inbounds %struct.Token, %struct.Token* %30, i64 0, i32 0
  br label %33

; <label>:32:                                     ; preds = %2
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.260, i64 0, i64 0)) #19
  unreachable

; <label>:33:                                     ; preds = %25, %28
  %34 = phi i32* [ %15, %25 ], [ %31, %28 ]
  %35 = phi %struct.Token* [ %14, %25 ], [ %30, %28 ]
  %36 = phi i32* [ %13, %25 ], [ %29, %28 ]
  %37 = bitcast %struct.expdesc* %4 to i8*
  %38 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %39 = bitcast %struct.expdesc* %5 to i8*
  %40 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %42 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %43 = bitcast %struct.TValue* %3 to i8*
  %44 = bitcast %struct.TValue* %3 to %struct.TString**
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  %46 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 2
  %47 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 3
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 0
  %49 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 1
  %50 = bitcast %union.anon.8* %49 to i32*
  %51 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %52 = bitcast %union.anon.8* %51 to i32*
  %53 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %54 = bitcast %struct.Token* %53 to i8*
  %55 = bitcast %struct.Token* %35 to i8*
  %56 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 13
  %57 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 15
  br label %58

; <label>:58:                                     ; preds = %124, %33
  %59 = load i32, i32* %10, align 8, !tbaa !260
  switch i32 %59, label %125 [
    i32 46, label %60
    i32 91, label %61
    i32 58, label %71
    i32 40, label %123
    i32 293, label %123
    i32 123, label %123
  ]

; <label>:60:                                     ; preds = %58
  call fastcc void @fieldsel(%struct.LexState* nonnull %0, %struct.expdesc* %1) #16
  br label %124

; <label>:61:                                     ; preds = %58
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %37) #7
  %62 = load i32, i32* %38, align 8, !tbaa !294
  %63 = icmp eq i32 %62, 9
  br i1 %63, label %64, label %68

; <label>:64:                                     ; preds = %61
  %65 = load i32, i32* %40, align 8, !tbaa !291
  %66 = load i32, i32* %41, align 4, !tbaa !293
  %67 = icmp eq i32 %65, %66
  br i1 %67, label %70, label %68

; <label>:68:                                     ; preds = %64, %61
  %69 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %7, %struct.expdesc* nonnull %1) #17
  br label %70

; <label>:70:                                     ; preds = %64, %68
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  call fastcc void @luaK_indexed(%struct.FuncState* %7, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %4) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %37) #7
  br label %124

; <label>:71:                                     ; preds = %58
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %39) #7
  %72 = load i32, i32* %8, align 4, !tbaa !265
  store i32 %72, i32* %36, align 8, !tbaa !266
  %73 = load i32, i32* %34, align 8, !tbaa !263
  %74 = icmp eq i32 %73, 289
  br i1 %74, label %76, label %75

; <label>:75:                                     ; preds = %71
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %54, i8* nonnull %55, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %34, align 8, !tbaa !263
  br label %78

; <label>:76:                                     ; preds = %71
  %77 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %42) #17
  store i32 %77, i32* %10, align 8, !tbaa !260
  br label %78

; <label>:78:                                     ; preds = %75, %76
  %79 = call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %80 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %43) #7
  store %struct.TString* %79, %struct.TString** %44, align 8, !tbaa !21
  %81 = getelementptr inbounds %struct.TString, %struct.TString* %79, i64 0, i32 1
  %82 = load i8, i8* %81, align 8, !tbaa !75
  %83 = or i8 %82, 64
  store i8 %83, i8* %45, align 8, !tbaa !22
  %84 = call fastcc i32 @addk(%struct.FuncState* %80, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %43) #7
  store i32 -1, i32* %46, align 8, !tbaa !291
  store i32 -1, i32* %47, align 4, !tbaa !293
  store i32 4, i32* %48, align 8, !tbaa !294
  store i32 %84, i32* %50, align 8, !tbaa !21
  %85 = call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %7, %struct.expdesc* %1) #17
  %86 = load i32, i32* %52, align 8, !tbaa !21
  %87 = load i32, i32* %38, align 8, !tbaa !294
  %88 = icmp eq i32 %87, 7
  br i1 %88, label %89, label %96

; <label>:89:                                     ; preds = %78
  %90 = load i8, i8* %56, align 2, !tbaa !298
  %91 = zext i8 %90 to i32
  %92 = icmp slt i32 %86, %91
  br i1 %92, label %96, label %93

; <label>:93:                                     ; preds = %89
  %94 = load i8, i8* %57, align 4, !tbaa !303
  %95 = add i8 %94, -1
  store i8 %95, i8* %57, align 4, !tbaa !303
  br label %96

; <label>:96:                                     ; preds = %93, %89, %78
  %97 = load i8, i8* %57, align 4, !tbaa !303
  %98 = zext i8 %97 to i32
  store i32 %98, i32* %52, align 8, !tbaa !21
  store i32 7, i32* %38, align 8, !tbaa !294
  call fastcc void @luaK_checkstack(%struct.FuncState* %7, i32 2) #17
  %99 = load i8, i8* %57, align 4, !tbaa !303
  %100 = add i8 %99, 2
  store i8 %100, i8* %57, align 4, !tbaa !303
  %101 = load i32, i32* %52, align 8, !tbaa !21
  %102 = call fastcc i32 @luaK_exp2RK(%struct.FuncState* %7, %struct.expdesc* nonnull %5) #17
  %103 = load i32, i32* %50, align 8, !tbaa !21
  %104 = shl i32 %101, 7
  %105 = shl i32 %86, 16
  %106 = shl i32 %103, 24
  %107 = shl i32 %102, 15
  %108 = or i32 %105, %104
  %109 = or i32 %108, %107
  %110 = or i32 %109, %106
  %111 = or i32 %110, 18
  %112 = call fastcc i32 @luaK_code(%struct.FuncState* %7, i32 %111) #17
  %113 = load i32, i32* %48, align 8, !tbaa !294
  %114 = icmp eq i32 %113, 7
  br i1 %114, label %115, label %122

; <label>:115:                                    ; preds = %96
  %116 = load i8, i8* %56, align 2, !tbaa !298
  %117 = zext i8 %116 to i32
  %118 = icmp slt i32 %103, %117
  br i1 %118, label %122, label %119

; <label>:119:                                    ; preds = %115
  %120 = load i8, i8* %57, align 4, !tbaa !303
  %121 = add i8 %120, -1
  store i8 %121, i8* %57, align 4, !tbaa !303
  br label %122

; <label>:122:                                    ; preds = %96, %115, %119
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %1, i32 %9) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %39) #7
  br label %124

; <label>:123:                                    ; preds = %58, %58, %58
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %7, %struct.expdesc* %1) #16
  call fastcc void @funcargs(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 %9) #16
  br label %124

; <label>:124:                                    ; preds = %123, %122, %70, %60
  br label %58

; <label>:125:                                    ; preds = %58
  ret void
}

; Function Attrs: norecurse nounwind optsize readnone uwtable
define internal fastcc i32 @luaO_int2fb(i32) unnamed_addr #6 {
  %2 = icmp ult i32 %0, 8
  br i1 %2, label %32, label %3

; <label>:3:                                      ; preds = %1
  %4 = icmp ugt i32 %0, 127
  br i1 %4, label %5, label %13

; <label>:5:                                      ; preds = %3
  br label %6

; <label>:6:                                      ; preds = %5, %6
  %7 = phi i32 [ %11, %6 ], [ 0, %5 ]
  %8 = phi i32 [ %10, %6 ], [ %0, %5 ]
  %9 = add i32 %8, 15
  %10 = lshr i32 %9, 4
  %11 = add nuw nsw i32 %7, 4
  %12 = icmp ugt i32 %9, 2047
  br i1 %12, label %6, label %13

; <label>:13:                                     ; preds = %6, %3
  %14 = phi i32 [ %0, %3 ], [ %10, %6 ]
  %15 = phi i32 [ 0, %3 ], [ %11, %6 ]
  %16 = icmp ugt i32 %14, 15
  br i1 %16, label %17, label %25

; <label>:17:                                     ; preds = %13
  br label %18

; <label>:18:                                     ; preds = %17, %18
  %19 = phi i32 [ %23, %18 ], [ %15, %17 ]
  %20 = phi i32 [ %22, %18 ], [ %14, %17 ]
  %21 = add i32 %20, 1
  %22 = lshr i32 %21, 1
  %23 = add nuw nsw i32 %19, 1
  %24 = icmp ugt i32 %21, 31
  br i1 %24, label %18, label %25

; <label>:25:                                     ; preds = %18, %13
  %26 = phi i32 [ %14, %13 ], [ %22, %18 ]
  %27 = phi i32 [ %15, %13 ], [ %23, %18 ]
  %28 = shl i32 %27, 3
  %29 = add i32 %28, 8
  %30 = add nsw i32 %26, -8
  %31 = or i32 %29, %30
  br label %32

; <label>:32:                                     ; preds = %1, %25
  %33 = phi i32 [ %31, %25 ], [ %0, %1 ]
  ret i32 %33
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_setlist(%struct.FuncState* nocapture, i32, i32, i32) unnamed_addr #0 {
  %5 = add nsw i32 %2, -1
  %6 = sdiv i32 %5, 50
  %7 = add nsw i32 %6, 1
  %8 = icmp eq i32 %3, -1
  %9 = select i1 %8, i32 0, i32 %3
  %10 = icmp slt i32 %2, 12751
  br i1 %10, label %11, label %19

; <label>:11:                                     ; preds = %4
  %12 = shl i32 %1, 7
  %13 = shl i32 %9, 16
  %14 = shl i32 %7, 24
  %15 = or i32 %12, %13
  %16 = or i32 %15, %14
  %17 = or i32 %16, 79
  %18 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %17) #17
  br label %33

; <label>:19:                                     ; preds = %4
  %20 = icmp slt i32 %2, 1677721551
  br i1 %20, label %21, label %30

; <label>:21:                                     ; preds = %19
  %22 = shl i32 %1, 7
  %23 = shl i32 %9, 16
  %24 = or i32 %22, %23
  %25 = or i32 %24, 79
  %26 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %25) #17
  %27 = shl i32 %7, 7
  %28 = or i32 %27, 83
  %29 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %28) #17
  br label %33

; <label>:30:                                     ; preds = %19
  %31 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %32 = load %struct.LexState*, %struct.LexState** %31, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %32, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.254, i64 0, i64 0)) #18
  unreachable

; <label>:33:                                     ; preds = %21, %11
  %34 = trunc i32 %1 to i8
  %35 = add i8 %34, 1
  %36 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  store i8 %35, i8* %36, align 4, !tbaa !303
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @recfield(%struct.LexState*, %struct.ConsControl* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = alloca %struct.expdesc, align 8
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %8 = load %struct.FuncState*, %struct.FuncState** %7, align 8, !tbaa !273
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %8, i64 0, i32 15
  %10 = load i8, i8* %9, align 4, !tbaa !303
  %11 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %11) #7
  %12 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %12) #7
  %13 = bitcast %struct.expdesc* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %13) #7
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %15 = load i32, i32* %14, align 8, !tbaa !260
  %16 = icmp eq i32 %15, 292
  br i1 %16, label %17, label %32

; <label>:17:                                     ; preds = %2
  %18 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %19 = load %struct.FuncState*, %struct.FuncState** %7, align 8, !tbaa !273
  %20 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %20) #7
  %21 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %18, %struct.TString** %21, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TString, %struct.TString* %18, i64 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !75
  %24 = or i8 %23, 64
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %24, i8* %25, align 8, !tbaa !22
  %26 = call fastcc i32 @addk(%struct.FuncState* %19, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %20) #7
  %27 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 2
  store i32 -1, i32* %27, align 8, !tbaa !291
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 3
  store i32 -1, i32* %28, align 4, !tbaa !293
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 0
  store i32 4, i32* %29, align 8, !tbaa !294
  %30 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 1
  %31 = bitcast %union.anon.8* %30 to i32*
  store i32 %26, i32* %31, align 8, !tbaa !21
  br label %33

; <label>:32:                                     ; preds = %2
  call fastcc void @yindex(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5) #16
  br label %33

; <label>:33:                                     ; preds = %32, %17
  %34 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 2
  %35 = load i32, i32* %34, align 8, !tbaa !327
  %36 = add nsw i32 %35, 1
  store i32 %36, i32* %34, align 8, !tbaa !327
  call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #16
  %37 = getelementptr inbounds %struct.ConsControl, %struct.ConsControl* %1, i64 0, i32 1
  %38 = bitcast %struct.expdesc** %37 to i8**
  %39 = load i8*, i8** %38, align 8, !tbaa !329
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %11, i8* %39, i64 24, i32 8, i1 false), !tbaa.struct !323
  call fastcc void @luaK_indexed(%struct.FuncState* %8, %struct.expdesc* nonnull %4, %struct.expdesc* nonnull %5) #16
  %40 = call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %6, i32 0) #17
  call fastcc void @luaK_storevar(%struct.FuncState* %8, %struct.expdesc* nonnull %4, %struct.expdesc* nonnull %6) #16
  store i8 %10, i8* %9, align 4, !tbaa !303
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %11) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @yindex(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %4 = load i32, i32* %3, align 4, !tbaa !265
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %4, i32* %5, align 8, !tbaa !266
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %7 = getelementptr inbounds %struct.Token, %struct.Token* %6, i64 0, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !263
  %9 = icmp eq i32 %8, 289
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %12 = bitcast %struct.Token* %11 to i8*
  %13 = bitcast %struct.Token* %6 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %12, i8* nonnull %13, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %7, align 8, !tbaa !263
  br label %18

; <label>:14:                                     ; preds = %2
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %16 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %15) #17
  %17 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 %16, i32* %17, align 8, !tbaa !260
  br label %18

; <label>:18:                                     ; preds = %10, %14
  %19 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0) #17
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %21 = load %struct.FuncState*, %struct.FuncState** %20, align 8, !tbaa !273
  %22 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %23 = load i32, i32* %22, align 8, !tbaa !291
  %24 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %25 = load i32, i32* %24, align 4, !tbaa !293
  %26 = icmp eq i32 %23, %25
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %18
  %28 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %21, %struct.expdesc* nonnull %1) #17
  br label %30

; <label>:29:                                     ; preds = %18
  tail call fastcc void @luaK_dischargevars(%struct.FuncState* %21, %struct.expdesc* nonnull %1) #17
  br label %30

; <label>:30:                                     ; preds = %27, %29
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 93) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_indexed(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !294
  %6 = icmp eq i32 %5, 9
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = trunc i32 %10 to i8
  %12 = bitcast %union.anon.8* %8 to %struct.anon.9*
  %13 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %12, i64 0, i32 1
  store i8 %11, i8* %13, align 2, !tbaa !21
  br label %61

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %16 = load i32, i32* %15, align 8, !tbaa !294
  %17 = icmp eq i32 %16, 4
  br i1 %17, label %18, label %45

; <label>:18:                                     ; preds = %14
  %19 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %20 = load i32, i32* %19, align 8, !tbaa !291
  %21 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %22 = load i32, i32* %21, align 4, !tbaa !293
  %23 = icmp eq i32 %20, %22
  br i1 %23, label %24, label %45

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %26 = bitcast %union.anon.8* %25 to i32*
  %27 = load i32, i32* %26, align 8, !tbaa !21
  %28 = icmp slt i32 %27, 256
  br i1 %28, label %29, label %45

; <label>:29:                                     ; preds = %24
  %30 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %31 = load %struct.Proto*, %struct.Proto** %30, align 8, !tbaa !253
  %32 = getelementptr inbounds %struct.Proto, %struct.Proto* %31, i64 0, i32 15
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !223
  %34 = sext i32 %27 to i64
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 %34, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  %37 = icmp eq i8 %36, 84
  br i1 %37, label %38, label %45

; <label>:38:                                     ; preds = %29
  %39 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %40 = bitcast %union.anon.8* %39 to i32*
  %41 = load i32, i32* %40, align 8, !tbaa !21
  %42 = trunc i32 %41 to i8
  %43 = bitcast %union.anon.8* %39 to %struct.anon.9*
  %44 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %43, i64 0, i32 1
  store i8 %42, i8* %44, align 2, !tbaa !21
  br label %55

; <label>:45:                                     ; preds = %24, %18, %14, %29
  %46 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  %47 = load i32, i32* %4, align 8, !tbaa !294
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %49 = bitcast %union.anon.8* %48 to i32*
  %50 = load i32, i32* %49, align 8, !tbaa !21
  %51 = trunc i32 %50 to i8
  %52 = bitcast %union.anon.8* %48 to %struct.anon.9*
  %53 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %52, i64 0, i32 1
  store i8 %51, i8* %53, align 2, !tbaa !21
  %54 = icmp eq i32 %47, 9
  br i1 %54, label %55, label %61

; <label>:55:                                     ; preds = %38, %45
  %56 = phi %union.anon.8* [ %39, %38 ], [ %48, %45 ]
  %57 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %58 = bitcast %union.anon.8* %57 to i32*
  %59 = load i32, i32* %58, align 8, !tbaa !21
  %60 = trunc i32 %59 to i16
  br label %102

; <label>:61:                                     ; preds = %7, %45
  %62 = phi %union.anon.8* [ %8, %7 ], [ %48, %45 ]
  %63 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %64 = load i32, i32* %63, align 8, !tbaa !294
  switch i32 %64, label %99 [
    i32 4, label %65
    i32 6, label %87
  ]

; <label>:65:                                     ; preds = %61
  %66 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %67 = load i32, i32* %66, align 8, !tbaa !291
  %68 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %69 = load i32, i32* %68, align 4, !tbaa !293
  %70 = icmp eq i32 %67, %69
  br i1 %70, label %71, label %99

; <label>:71:                                     ; preds = %65
  %72 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %73 = bitcast %union.anon.8* %72 to i32*
  %74 = load i32, i32* %73, align 8, !tbaa !21
  %75 = icmp slt i32 %74, 256
  br i1 %75, label %76, label %99

; <label>:76:                                     ; preds = %71
  %77 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %78 = load %struct.Proto*, %struct.Proto** %77, align 8, !tbaa !253
  %79 = getelementptr inbounds %struct.Proto, %struct.Proto* %78, i64 0, i32 15
  %80 = load %struct.TValue*, %struct.TValue** %79, align 8, !tbaa !223
  %81 = sext i32 %74 to i64
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %80, i64 %81, i32 1
  %83 = load i8, i8* %82, align 8, !tbaa !22
  %84 = icmp eq i8 %83, 84
  br i1 %84, label %85, label %99

; <label>:85:                                     ; preds = %76
  %86 = trunc i32 %74 to i16
  br label %102

; <label>:87:                                     ; preds = %61
  %88 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  %89 = load i32, i32* %88, align 8, !tbaa !291
  %90 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %91 = load i32, i32* %90, align 4, !tbaa !293
  %92 = icmp eq i32 %89, %91
  br i1 %92, label %93, label %99

; <label>:93:                                     ; preds = %87
  %94 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1, i32 0
  %95 = load i64, i64* %94, align 8, !tbaa !21
  %96 = icmp ugt i64 %95, 255
  br i1 %96, label %99, label %97

; <label>:97:                                     ; preds = %93
  %98 = trunc i64 %95 to i16
  br label %102

; <label>:99:                                     ; preds = %76, %61, %65, %71, %87, %93
  %100 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %2) #16
  %101 = trunc i32 %100 to i16
  br label %102

; <label>:102:                                    ; preds = %85, %99, %97, %55
  %103 = phi %union.anon.8* [ %62, %85 ], [ %62, %99 ], [ %62, %97 ], [ %56, %55 ]
  %104 = phi i16 [ %86, %85 ], [ %101, %99 ], [ %98, %97 ], [ %60, %55 ]
  %105 = phi i32 [ 13, %85 ], [ 10, %99 ], [ 12, %97 ], [ 11, %55 ]
  %106 = bitcast %union.anon.8* %103 to i16*
  store i16 %104, i16* %106, align 8, !tbaa !21
  store i32 %105, i32* %4, align 8, !tbaa !294
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_storevar(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, %struct.expdesc* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !294
  switch i32 %5, label %124 [
    i32 8, label %6
    i32 9, label %26
    i32 11, label %36
    i32 12, label %58
    i32 13, label %80
    i32 10, label %102
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %8 = load i32, i32* %7, align 8, !tbaa !294
  %9 = icmp eq i32 %8, 7
  br i1 %9, label %10, label %22

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %12 = bitcast %union.anon.8* %11 to i32*
  %13 = load i32, i32* %12, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %15 = load i8, i8* %14, align 2, !tbaa !298
  %16 = zext i8 %15 to i32
  %17 = icmp slt i32 %13, %16
  br i1 %17, label %22, label %18

; <label>:18:                                     ; preds = %10
  %19 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %20 = load i8, i8* %19, align 4, !tbaa !303
  %21 = add i8 %20, -1
  store i8 %21, i8* %19, align 4, !tbaa !303
  br label %22

; <label>:22:                                     ; preds = %6, %10, %18
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %24 = bitcast %union.anon.8* %23 to i32*
  %25 = load i32, i32* %24, align 8, !tbaa !21
  tail call fastcc void @exp2reg(%struct.FuncState* %0, %struct.expdesc* nonnull %2, i32 %25) #16
  br label %140

; <label>:26:                                     ; preds = %3
  %27 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %29 = bitcast %union.anon.8* %28 to i32*
  %30 = load i32, i32* %29, align 8, !tbaa !21
  %31 = shl i32 %27, 7
  %32 = shl i32 %30, 16
  %33 = or i32 %31, %32
  %34 = or i32 %33, 8
  %35 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %34) #17
  br label %124

; <label>:36:                                     ; preds = %3
  %37 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %38 = bitcast %union.anon.8* %37 to %struct.anon.9*
  %39 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %38, i64 0, i32 1
  %40 = load i8, i8* %39, align 2, !tbaa !21
  %41 = zext i8 %40 to i32
  %42 = bitcast %union.anon.8* %37 to i16*
  %43 = load i16, i16* %42, align 8, !tbaa !21
  %44 = zext i16 %43 to i32
  %45 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %2) #17
  %46 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %47 = bitcast %union.anon.8* %46 to i32*
  %48 = load i32, i32* %47, align 8, !tbaa !21
  %49 = shl nuw nsw i32 %41, 7
  %50 = shl nuw i32 %44, 16
  %51 = shl i32 %48, 24
  %52 = shl i32 %45, 15
  %53 = or i32 %49, %50
  %54 = or i32 %53, %52
  %55 = or i32 %54, %51
  %56 = or i32 %55, 13
  %57 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %56) #17
  br label %124

; <label>:58:                                     ; preds = %3
  %59 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %60 = bitcast %union.anon.8* %59 to %struct.anon.9*
  %61 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %60, i64 0, i32 1
  %62 = load i8, i8* %61, align 2, !tbaa !21
  %63 = zext i8 %62 to i32
  %64 = bitcast %union.anon.8* %59 to i16*
  %65 = load i16, i16* %64, align 8, !tbaa !21
  %66 = zext i16 %65 to i32
  %67 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %2) #17
  %68 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %69 = bitcast %union.anon.8* %68 to i32*
  %70 = load i32, i32* %69, align 8, !tbaa !21
  %71 = shl nuw nsw i32 %63, 7
  %72 = shl nuw i32 %66, 16
  %73 = shl i32 %70, 24
  %74 = shl i32 %67, 15
  %75 = or i32 %71, %72
  %76 = or i32 %75, %74
  %77 = or i32 %76, %73
  %78 = or i32 %77, 15
  %79 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %78) #17
  br label %124

; <label>:80:                                     ; preds = %3
  %81 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %82 = bitcast %union.anon.8* %81 to %struct.anon.9*
  %83 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %82, i64 0, i32 1
  %84 = load i8, i8* %83, align 2, !tbaa !21
  %85 = zext i8 %84 to i32
  %86 = bitcast %union.anon.8* %81 to i16*
  %87 = load i16, i16* %86, align 8, !tbaa !21
  %88 = zext i16 %87 to i32
  %89 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %2) #17
  %90 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %91 = bitcast %union.anon.8* %90 to i32*
  %92 = load i32, i32* %91, align 8, !tbaa !21
  %93 = shl nuw nsw i32 %85, 7
  %94 = shl nuw i32 %88, 16
  %95 = shl i32 %92, 24
  %96 = shl i32 %89, 15
  %97 = or i32 %93, %94
  %98 = or i32 %97, %96
  %99 = or i32 %98, %95
  %100 = or i32 %99, 16
  %101 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %100) #17
  br label %124

; <label>:102:                                    ; preds = %3
  %103 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %104 = bitcast %union.anon.8* %103 to %struct.anon.9*
  %105 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %104, i64 0, i32 1
  %106 = load i8, i8* %105, align 2, !tbaa !21
  %107 = zext i8 %106 to i32
  %108 = bitcast %union.anon.8* %103 to i16*
  %109 = load i16, i16* %108, align 8, !tbaa !21
  %110 = zext i16 %109 to i32
  %111 = tail call fastcc i32 @luaK_exp2RK(%struct.FuncState* %0, %struct.expdesc* %2) #17
  %112 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %113 = bitcast %union.anon.8* %112 to i32*
  %114 = load i32, i32* %113, align 8, !tbaa !21
  %115 = shl nuw nsw i32 %107, 7
  %116 = shl nuw i32 %110, 16
  %117 = shl i32 %114, 24
  %118 = shl i32 %111, 15
  %119 = or i32 %115, %116
  %120 = or i32 %119, %118
  %121 = or i32 %120, %117
  %122 = or i32 %121, 14
  %123 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %122) #17
  br label %124

; <label>:124:                                    ; preds = %3, %102, %80, %58, %36, %26
  %125 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %126 = load i32, i32* %125, align 8, !tbaa !294
  %127 = icmp eq i32 %126, 7
  br i1 %127, label %128, label %140

; <label>:128:                                    ; preds = %124
  %129 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %130 = bitcast %union.anon.8* %129 to i32*
  %131 = load i32, i32* %130, align 8, !tbaa !21
  %132 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %133 = load i8, i8* %132, align 2, !tbaa !298
  %134 = zext i8 %133 to i32
  %135 = icmp slt i32 %131, %134
  br i1 %135, label %140, label %136

; <label>:136:                                    ; preds = %128
  %137 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %138 = load i8, i8* %137, align 4, !tbaa !303
  %139 = add i8 %138, -1
  store i8 %139, i8* %137, align 4, !tbaa !303
  br label %140

; <label>:140:                                    ; preds = %136, %128, %124, %22
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2RK(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %2
  %6 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1) #16
  br label %7

; <label>:7:                                      ; preds = %2, %5
  %8 = phi i32 [ 0, %5 ], [ 1, %2 ]
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @luaK_exp2K(%struct.FuncState* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.TValue, align 8
  %5 = alloca %struct.TValue, align 8
  %6 = alloca %struct.TValue, align 8
  %7 = alloca %struct.TValue, align 8
  %8 = alloca %struct.TValue, align 8
  %9 = alloca %struct.TValue, align 8
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %11 = load i32, i32* %10, align 8, !tbaa !291
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !293
  %14 = icmp eq i32 %11, %13
  br i1 %14, label %15, label %68

; <label>:15:                                     ; preds = %2
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %17 = load i32, i32* %16, align 8, !tbaa !294
  switch i32 %17, label %68 [
    i32 2, label %18
    i32 3, label %23
    i32 1, label %28
    i32 6, label %40
    i32 5, label %51
    i32 4, label %58
  ]

; <label>:18:                                     ; preds = %15
  %19 = bitcast %struct.TValue* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %19) #7
  %20 = bitcast %struct.TValue* %9 to i32*
  store i32 1, i32* %20, align 8, !tbaa !21
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 1, i8* %21, align 8, !tbaa !22
  %22 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %9, %struct.TValue* nonnull %9) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %19) #7
  br label %62

; <label>:23:                                     ; preds = %15
  %24 = bitcast %struct.TValue* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %24) #7
  %25 = bitcast %struct.TValue* %8 to i32*
  store i32 0, i32* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 1, i8* %26, align 8, !tbaa !22
  %27 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %8, %struct.TValue* nonnull %8) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %24) #7
  br label %62

; <label>:28:                                     ; preds = %15
  %29 = bitcast %struct.TValue* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %29) #7
  %30 = bitcast %struct.TValue* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %30) #7
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %31, align 8, !tbaa !22
  %32 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %33 = load %struct.LexState*, %struct.LexState** %32, align 8, !tbaa !272
  %34 = getelementptr inbounds %struct.LexState, %struct.LexState* %33, i64 0, i32 9
  %35 = bitcast %struct.Table** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !250
  %37 = bitcast %struct.TValue* %6 to i64*
  store i64 %36, i64* %37, align 8, !tbaa !21
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 69, i8* %38, align 8, !tbaa !22
  %39 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %6, %struct.TValue* nonnull %7) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %30) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %29) #7
  br label %62

; <label>:40:                                     ; preds = %15
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %42 = load i64, i64* %41, align 8, !tbaa !21
  %43 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %43) #7
  %44 = bitcast %struct.TValue* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %44) #7
  %45 = inttoptr i64 %42 to i8*
  %46 = bitcast %struct.TValue* %4 to i8**
  store i8* %45, i8** %46, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 2, i8* %47, align 8, !tbaa !22
  %48 = bitcast %struct.TValue* %5 to i64*
  store i64 %42, i64* %48, align 8, !tbaa !21
  %49 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 35, i8* %49, align 8, !tbaa !22
  %50 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %4, %struct.TValue* nonnull %5) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %44) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %43) #7
  br label %62

; <label>:51:                                     ; preds = %15
  %52 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1, i32 0
  %53 = load i64, i64* %52, align 8, !tbaa !21
  %54 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %54) #7
  %55 = bitcast %struct.TValue* %3 to i64*
  store i64 %53, i64* %55, align 8, !tbaa !21
  %56 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 19, i8* %56, align 8, !tbaa !22
  %57 = call fastcc i32 @addk(%struct.FuncState* %0, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %54) #7
  br label %62

; <label>:58:                                     ; preds = %15
  %59 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %60 = bitcast %union.anon.8* %59 to i32*
  %61 = load i32, i32* %60, align 8, !tbaa !21
  br label %62

; <label>:62:                                     ; preds = %58, %51, %40, %28, %23, %18
  %63 = phi i32 [ %61, %58 ], [ %57, %51 ], [ %50, %40 ], [ %39, %28 ], [ %27, %23 ], [ %22, %18 ]
  %64 = icmp slt i32 %63, 256
  br i1 %64, label %65, label %68

; <label>:65:                                     ; preds = %62
  store i32 4, i32* %16, align 8, !tbaa !294
  %66 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %67 = bitcast %union.anon.8* %66 to i32*
  store i32 %63, i32* %67, align 8, !tbaa !21
  br label %68

; <label>:68:                                     ; preds = %15, %65, %2, %62
  %69 = phi i32 [ 0, %62 ], [ 0, %2 ], [ 0, %15 ], [ 1, %65 ]
  ret i32 %69
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @luaK_setreturns(%struct.FuncState* nocapture, %struct.expdesc* nocapture readonly, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %5 = load %struct.Proto*, %struct.Proto** %4, align 8, !tbaa !253
  %6 = getelementptr inbounds %struct.Proto, %struct.Proto* %5, i64 0, i32 16
  %7 = load i32*, i32** %6, align 8, !tbaa !116
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %9 = bitcast %union.anon.8* %8 to i32*
  %10 = load i32, i32* %9, align 8, !tbaa !21
  %11 = sext i32 %10 to i64
  %12 = getelementptr inbounds i32, i32* %7, i64 %11
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %14 = load i32, i32* %13, align 8, !tbaa !294
  switch i32 %14, label %34 [
    i32 16, label %15
    i32 17, label %21
  ]

; <label>:15:                                     ; preds = %3
  %16 = load i32, i32* %12, align 4, !tbaa !77
  %17 = and i32 %16, 16777215
  %18 = shl i32 %2, 24
  %19 = add i32 %18, 16777216
  %20 = or i32 %17, %19
  store i32 %20, i32* %12, align 4, !tbaa !77
  br label %34

; <label>:21:                                     ; preds = %3
  %22 = load i32, i32* %12, align 4, !tbaa !77
  %23 = and i32 %22, 16744575
  %24 = shl i32 %2, 24
  %25 = add i32 %24, 16777216
  %26 = or i32 %23, %25
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %28 = load i8, i8* %27, align 4, !tbaa !303
  %29 = zext i8 %28 to i32
  %30 = shl nuw nsw i32 %29, 7
  %31 = or i32 %30, %26
  store i32 %31, i32* %12, align 4, !tbaa !77
  tail call fastcc void @luaK_checkstack(%struct.FuncState* nonnull %0, i32 1) #17
  %32 = load i8, i8* %27, align 4, !tbaa !303
  %33 = add i8 %32, 1
  store i8 %33, i8* %27, align 4, !tbaa !303
  br label %34

; <label>:34:                                     ; preds = %3, %21, %15
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @new_localvar(%struct.LexState* nocapture readonly, %struct.TString*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !273
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !256
  %7 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %8 = load %struct.Proto*, %struct.Proto** %7, align 8, !tbaa !253
  %9 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 11
  %10 = load i32, i32* %9, align 4, !tbaa !108
  %11 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !261
  %13 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 21
  %14 = bitcast %struct.LocVar** %13 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !110
  %16 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 12
  %17 = load i16, i16* %16, align 8, !tbaa !300
  %18 = sext i16 %17 to i32
  %19 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %12, i8* %15, i32 %18, i32* nonnull %9, i32 16, i32 32767, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #17
  store i8* %19, i8** %14, align 8, !tbaa !110
  %20 = load i32, i32* %9, align 4, !tbaa !108
  %21 = icmp slt i32 %10, %20
  %22 = bitcast i8* %19 to %struct.LocVar*
  br i1 %21, label %23, label %31

; <label>:23:                                     ; preds = %2
  %24 = sext i32 %10 to i64
  %25 = sext i32 %20 to i64
  br label %26

; <label>:26:                                     ; preds = %26, %23
  %27 = phi i64 [ %24, %23 ], [ %28, %26 ]
  %28 = add nsw i64 %27, 1
  %29 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %22, i64 %27, i32 0
  store %struct.TString* null, %struct.TString** %29, align 8, !tbaa !114
  %30 = icmp eq i64 %28, %25
  br i1 %30, label %31, label %26

; <label>:31:                                     ; preds = %26, %2
  %32 = load i16, i16* %16, align 8, !tbaa !300
  %33 = sext i16 %32 to i64
  %34 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %22, i64 %33, i32 0
  store %struct.TString* %1, %struct.TString** %34, align 8, !tbaa !114
  %35 = getelementptr inbounds %struct.Proto, %struct.Proto* %8, i64 0, i32 2
  %36 = load i8, i8* %35, align 1, !tbaa !234
  %37 = and i8 %36, 32
  %38 = icmp eq i8 %37, 0
  br i1 %38, label %49, label %39

; <label>:39:                                     ; preds = %31
  %40 = getelementptr inbounds %struct.TString, %struct.TString* %1, i64 0, i32 2
  %41 = load i8, i8* %40, align 1, !tbaa !148
  %42 = and i8 %41, 24
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %49, label %44

; <label>:44:                                     ; preds = %39
  %45 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !261
  %46 = bitcast %struct.Proto* %8 to %struct.GCObject*
  %47 = bitcast %struct.TString* %1 to %struct.GCObject*
  tail call fastcc void @luaC_barrier_(%struct.lua_State* %45, %struct.GCObject* %46, %struct.GCObject* %47) #17
  %48 = load i16, i16* %16, align 8, !tbaa !300
  br label %49

; <label>:49:                                     ; preds = %31, %39, %44
  %50 = phi i16 [ %32, %39 ], [ %32, %31 ], [ %48, %44 ]
  %51 = add i16 %50, 1
  store i16 %51, i16* %16, align 8, !tbaa !300
  %52 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 1
  %53 = load i32, i32* %52, align 8, !tbaa !259
  %54 = add nsw i32 %53, 1
  %55 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 10
  %56 = load i32, i32* %55, align 8, !tbaa !280
  %57 = sub nsw i32 %54, %56
  %58 = icmp sgt i32 %57, 200
  br i1 %58, label %59, label %60

; <label>:59:                                     ; preds = %49
  tail call fastcc void @errorlimit(%struct.FuncState* nonnull %4, i32 200, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #19
  unreachable

; <label>:60:                                     ; preds = %49
  %61 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !261
  %62 = bitcast %struct.Dyndata* %6 to i8**
  %63 = load i8*, i8** %62, align 8, !tbaa !304
  %64 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 2
  %65 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %61, i8* %63, i32 %54, i32* nonnull %64, i32 2, i32 2147483647, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.258, i64 0, i64 0)) #16
  %66 = bitcast i8* %65 to %struct.Vardesc*
  store i8* %65, i8** %62, align 8, !tbaa !304
  %67 = load i32, i32* %52, align 8, !tbaa !259
  %68 = add nsw i32 %67, 1
  store i32 %68, i32* %52, align 8, !tbaa !259
  %69 = sext i32 %67 to i64
  %70 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %66, i64 %69, i32 0
  store i16 %50, i16* %70, align 2, !tbaa !305
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc void @adjustlocalvars(%struct.LexState* nocapture readonly, i32) unnamed_addr #2 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !273
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 13
  %6 = load i8, i8* %5, align 2, !tbaa !298
  %7 = trunc i32 %1 to i8
  %8 = add i8 %6, %7
  store i8 %8, i8* %5, align 2, !tbaa !298
  %9 = icmp eq i32 %1, 0
  br i1 %9, label %40, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 4
  %12 = load i32, i32* %11, align 8, !tbaa !274
  %13 = zext i8 %8 to i32
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 2
  %15 = load %struct.LexState*, %struct.LexState** %14, align 8, !tbaa !272
  %16 = getelementptr inbounds %struct.LexState, %struct.LexState* %15, i64 0, i32 10
  %17 = load %struct.Dyndata*, %struct.Dyndata** %16, align 8, !tbaa !256
  %18 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %17, i64 0, i32 0, i32 0
  %19 = load %struct.Vardesc*, %struct.Vardesc** %18, align 8, !tbaa !304
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 10
  %21 = load i32, i32* %20, align 8, !tbaa !280
  %22 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %4, i64 0, i32 0
  %23 = load %struct.Proto*, %struct.Proto** %22, align 8, !tbaa !253
  %24 = getelementptr inbounds %struct.Proto, %struct.Proto* %23, i64 0, i32 21
  %25 = load %struct.LocVar*, %struct.LocVar** %24, align 8, !tbaa !110
  %26 = sext i32 %1 to i64
  br label %27

; <label>:27:                                     ; preds = %10, %27
  %28 = phi i64 [ %26, %10 ], [ %37, %27 ]
  %29 = trunc i64 %28 to i32
  %30 = sub i32 %13, %29
  %31 = add nsw i32 %30, %21
  %32 = sext i32 %31 to i64
  %33 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %19, i64 %32, i32 0
  %34 = load i16, i16* %33, align 2, !tbaa !305
  %35 = sext i16 %34 to i64
  %36 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %25, i64 %35, i32 1
  store i32 %12, i32* %36, align 8, !tbaa !111
  %37 = add nsw i64 %28, -1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %40, label %27

; <label>:40:                                     ; preds = %27, %2
  ret void
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal fastcc %struct.LocVar* @getlocvar(%struct.FuncState* nocapture readonly, i32) unnamed_addr #3 {
  %3 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %4 = load %struct.LexState*, %struct.LexState** %3, align 8, !tbaa !272
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %4, i64 0, i32 10
  %6 = load %struct.Dyndata*, %struct.Dyndata** %5, align 8, !tbaa !256
  %7 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %6, i64 0, i32 0, i32 0
  %8 = load %struct.Vardesc*, %struct.Vardesc** %7, align 8, !tbaa !304
  %9 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 10
  %10 = load i32, i32* %9, align 8, !tbaa !280
  %11 = add nsw i32 %10, %1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %8, i64 %12, i32 0
  %14 = load i16, i16* %13, align 2, !tbaa !305
  %15 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %16 = load %struct.Proto*, %struct.Proto** %15, align 8, !tbaa !253
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %16, i64 0, i32 21
  %18 = load %struct.LocVar*, %struct.LocVar** %17, align 8, !tbaa !110
  %19 = sext i16 %14 to i64
  %20 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %18, i64 %19
  ret %struct.LocVar* %20
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fieldsel(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %7 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !294
  %10 = icmp eq i32 %9, 9
  br i1 %10, label %11, label %17

; <label>:11:                                     ; preds = %2
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  %13 = load i32, i32* %12, align 8, !tbaa !291
  %14 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  %15 = load i32, i32* %14, align 4, !tbaa !293
  %16 = icmp eq i32 %13, %15
  br i1 %16, label %19, label %17

; <label>:17:                                     ; preds = %11, %2
  %18 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %6, %struct.expdesc* nonnull %1) #17
  br label %19

; <label>:19:                                     ; preds = %11, %17
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %21 = load i32, i32* %20, align 4, !tbaa !265
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %21, i32* %22, align 8, !tbaa !266
  %23 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %24 = getelementptr inbounds %struct.Token, %struct.Token* %23, i64 0, i32 0
  %25 = load i32, i32* %24, align 8, !tbaa !263
  %26 = icmp eq i32 %25, 289
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %19
  %28 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %29 = bitcast %struct.Token* %28 to i8*
  %30 = bitcast %struct.Token* %23 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %29, i8* nonnull %30, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %24, align 8, !tbaa !263
  br label %35

; <label>:31:                                     ; preds = %19
  %32 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %33 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %32) #17
  %34 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 %33, i32* %34, align 8, !tbaa !260
  br label %35

; <label>:35:                                     ; preds = %27, %31
  %36 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* nonnull %0) #17
  %37 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %38 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %38) #7
  %39 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %36, %struct.TString** %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TString, %struct.TString* %36, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !75
  %42 = or i8 %41, 64
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %42, i8* %43, align 8, !tbaa !22
  %44 = call fastcc i32 @addk(%struct.FuncState* %37, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %38) #7
  %45 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %45, align 8, !tbaa !291
  %46 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %46, align 4, !tbaa !293
  %47 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 4, i32* %47, align 8, !tbaa !294
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %49 = bitcast %union.anon.8* %48 to i32*
  store i32 %44, i32* %49, align 8, !tbaa !21
  call fastcc void @luaK_indexed(%struct.FuncState* %6, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %4) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @funcargs(%struct.LexState*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.TValue, align 8
  %5 = alloca %struct.expdesc, align 8
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  %8 = bitcast %struct.expdesc* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %8) #7
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %10 = load i32, i32* %9, align 8, !tbaa !260
  switch i32 %10, label %65 [
    i32 40, label %11
    i32 123, label %35
    i32 293, label %36
  ]

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %13 = load i32, i32* %12, align 4, !tbaa !265
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %13, i32* %14, align 8, !tbaa !266
  %15 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %16 = getelementptr inbounds %struct.Token, %struct.Token* %15, i64 0, i32 0
  %17 = load i32, i32* %16, align 8, !tbaa !263
  %18 = icmp eq i32 %17, 289
  br i1 %18, label %24, label %19

; <label>:19:                                     ; preds = %11
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %21 = bitcast %struct.Token* %20 to i8*
  %22 = bitcast %struct.Token* %15 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %21, i8* nonnull %22, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %16, align 8, !tbaa !263
  %23 = load i32, i32* %9, align 8, !tbaa !260
  br label %27

; <label>:24:                                     ; preds = %11
  %25 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %26 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %25) #17
  store i32 %26, i32* %9, align 8, !tbaa !260
  br label %27

; <label>:27:                                     ; preds = %19, %24
  %28 = phi i32 [ %23, %19 ], [ %26, %24 ]
  %29 = icmp eq i32 %28, 41
  br i1 %29, label %30, label %32

; <label>:30:                                     ; preds = %27
  %31 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 0
  store i32 0, i32* %31, align 8, !tbaa !294
  br label %34

; <label>:32:                                     ; preds = %27
  %33 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5) #16
  call fastcc void @luaK_setreturns(%struct.FuncState* %7, %struct.expdesc* nonnull %5, i32 -1) #16
  br label %34

; <label>:34:                                     ; preds = %32, %30
  call fastcc void @check_match(%struct.LexState* nonnull %0, i32 41, i32 40, i32 %2) #16
  br label %66

; <label>:35:                                     ; preds = %3
  call fastcc void @constructor(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %5) #16
  br label %66

; <label>:36:                                     ; preds = %3
  %37 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %38 = bitcast %union.SemInfo* %37 to %struct.TString**
  %39 = load %struct.TString*, %struct.TString** %38, align 8, !tbaa !21
  %40 = bitcast %struct.TValue* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %40) #7
  %41 = bitcast %struct.TValue* %4 to %struct.TString**
  store %struct.TString* %39, %struct.TString** %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TString, %struct.TString* %39, i64 0, i32 1
  %43 = load i8, i8* %42, align 8, !tbaa !75
  %44 = or i8 %43, 64
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 %44, i8* %45, align 8, !tbaa !22
  %46 = call fastcc i32 @addk(%struct.FuncState* %7, %struct.TValue* nonnull %4, %struct.TValue* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %40) #7
  %47 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 2
  store i32 -1, i32* %47, align 8, !tbaa !291
  %48 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 3
  store i32 -1, i32* %48, align 4, !tbaa !293
  %49 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 0
  store i32 4, i32* %49, align 8, !tbaa !294
  %50 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 1
  %51 = bitcast %union.anon.8* %50 to i32*
  store i32 %46, i32* %51, align 8, !tbaa !21
  %52 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %53 = load i32, i32* %52, align 4, !tbaa !265
  %54 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %53, i32* %54, align 8, !tbaa !266
  %55 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %56 = getelementptr inbounds %struct.Token, %struct.Token* %55, i64 0, i32 0
  %57 = load i32, i32* %56, align 8, !tbaa !263
  %58 = icmp eq i32 %57, 289
  br i1 %58, label %63, label %59

; <label>:59:                                     ; preds = %36
  %60 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %61 = bitcast %struct.Token* %60 to i8*
  %62 = bitcast %struct.Token* %55 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %61, i8* nonnull %62, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %56, align 8, !tbaa !263
  br label %66

; <label>:63:                                     ; preds = %36
  %64 = call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %37) #17
  store i32 %64, i32* %9, align 8, !tbaa !260
  br label %66

; <label>:65:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* nonnull %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.261, i64 0, i64 0)) #18
  unreachable

; <label>:66:                                     ; preds = %63, %59, %35, %34
  %67 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %68 = bitcast %union.anon.8* %67 to i32*
  %69 = load i32, i32* %68, align 8, !tbaa !21
  %70 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %5, i64 0, i32 0
  %71 = load i32, i32* %70, align 8, !tbaa !294
  switch i32 %71, label %72 [
    i32 16, label %81
    i32 17, label %81
    i32 0, label %73
  ]

; <label>:72:                                     ; preds = %66
  call fastcc void @luaK_exp2nextreg(%struct.FuncState* %7, %struct.expdesc* nonnull %5) #16
  br label %73

; <label>:73:                                     ; preds = %66, %72
  %74 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 15
  %75 = load i8, i8* %74, align 4, !tbaa !303
  %76 = zext i8 %75 to i32
  %77 = xor i32 %69, 65535
  %78 = add i32 %77, %76
  %79 = shl i32 %78, 16
  %80 = add i32 %79, 65536
  br label %81

; <label>:81:                                     ; preds = %66, %66, %73
  %82 = phi i32 [ %80, %73 ], [ 0, %66 ], [ 0, %66 ]
  %83 = shl i32 %69, 7
  %84 = or i32 %83, %82
  %85 = or i32 %84, 33554501
  %86 = call fastcc i32 @luaK_code(%struct.FuncState* %7, i32 %85) #17
  %87 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 2
  store i32 -1, i32* %87, align 8, !tbaa !291
  %88 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 3
  store i32 -1, i32* %88, align 4, !tbaa !293
  %89 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  store i32 16, i32* %89, align 8, !tbaa !294
  store i32 %86, i32* %68, align 8, !tbaa !21
  call fastcc void @removelastlineinfo(%struct.FuncState* %7) #17
  %90 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 0
  %91 = load %struct.Proto*, %struct.Proto** %90, align 8, !tbaa !253
  call fastcc void @savelineinfo(%struct.FuncState* %7, %struct.Proto* %91, i32 %2) #17
  %92 = trunc i32 %69 to i8
  %93 = add i8 %92, 1
  %94 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %7, i64 0, i32 15
  store i8 %93, i8* %94, align 4, !tbaa !303
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %8) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @singlevar(%struct.LexState*, %struct.expdesc* nocapture) unnamed_addr #0 {
  %3 = alloca %struct.TValue, align 8
  %4 = alloca %struct.expdesc, align 8
  %5 = tail call fastcc %struct.TString* @str_checkname(%struct.LexState* %0) #16
  %6 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %7 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  tail call fastcc void @singlevaraux(%struct.FuncState* %7, %struct.TString* %5, %struct.expdesc* %1, i32 1) #16
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !294
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %11, label %28

; <label>:11:                                     ; preds = %2
  %12 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %12) #7
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 12
  %14 = load %struct.TString*, %struct.TString** %13, align 8, !tbaa !268
  tail call fastcc void @singlevaraux(%struct.FuncState* %7, %struct.TString* %14, %struct.expdesc* nonnull %1, i32 1) #16
  %15 = load %struct.FuncState*, %struct.FuncState** %6, align 8, !tbaa !273
  %16 = bitcast %struct.TValue* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #7
  %17 = bitcast %struct.TValue* %3 to %struct.TString**
  store %struct.TString* %5, %struct.TString** %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TString, %struct.TString* %5, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !75
  %20 = or i8 %19, 64
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %3, i64 0, i32 1
  store i8 %20, i8* %21, align 8, !tbaa !22
  %22 = call fastcc i32 @addk(%struct.FuncState* %15, %struct.TValue* nonnull %3, %struct.TValue* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #7
  %23 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %23, align 8, !tbaa !291
  %24 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %24, align 4, !tbaa !293
  %25 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 4, i32* %25, align 8, !tbaa !294
  %26 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %27 = bitcast %union.anon.8* %26 to i32*
  store i32 %22, i32* %27, align 8, !tbaa !21
  call fastcc void @luaK_indexed(%struct.FuncState* %7, %struct.expdesc* nonnull %1, %struct.expdesc* nonnull %4) #16
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %12) #7
  br label %28

; <label>:28:                                     ; preds = %11, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @singlevaraux(%struct.FuncState*, %struct.TString*, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %5 = icmp eq %struct.FuncState* %0, null
  br i1 %5, label %6, label %12

; <label>:6:                                      ; preds = %4
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %7, align 8, !tbaa !291
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %8, align 4, !tbaa !293
  %9 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 0, i32* %9, align 8, !tbaa !294
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to i32*
  store i32 0, i32* %11, align 8, !tbaa !21
  ret void

; <label>:12:                                     ; preds = %4
  %13 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %14 = load i8, i8* %13, align 2, !tbaa !298
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %12
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %18 = load %struct.Proto*, %struct.Proto** %17, align 8, !tbaa !253
  br label %69

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %21 = load %struct.LexState*, %struct.LexState** %20, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 10
  %23 = load %struct.Dyndata*, %struct.Dyndata** %22, align 8, !tbaa !256
  %24 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 0, i32 0
  %25 = load %struct.Vardesc*, %struct.Vardesc** %24, align 8, !tbaa !304
  %26 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 10
  %27 = load i32, i32* %26, align 8, !tbaa !280
  %28 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %29 = load %struct.Proto*, %struct.Proto** %28, align 8, !tbaa !253
  %30 = getelementptr inbounds %struct.Proto, %struct.Proto* %29, i64 0, i32 21
  %31 = load %struct.LocVar*, %struct.LocVar** %30, align 8, !tbaa !110
  %32 = zext i8 %14 to i64
  %33 = sext i32 %27 to i64
  br label %36

; <label>:34:                                     ; preds = %36
  %35 = icmp sgt i64 %37, 1
  br i1 %35, label %36, label %69

; <label>:36:                                     ; preds = %34, %19
  %37 = phi i64 [ %32, %19 ], [ %38, %34 ]
  %38 = add nsw i64 %37, -1
  %39 = add nsw i64 %38, %33
  %40 = getelementptr inbounds %struct.Vardesc, %struct.Vardesc* %25, i64 %39, i32 0
  %41 = load i16, i16* %40, align 2, !tbaa !305
  %42 = sext i16 %41 to i64
  %43 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %31, i64 %42, i32 0
  %44 = load %struct.TString*, %struct.TString** %43, align 8, !tbaa !114
  %45 = icmp eq %struct.TString* %44, %1
  br i1 %45, label %46, label %34

; <label>:46:                                     ; preds = %36
  %47 = trunc i64 %38 to i32
  %48 = icmp sgt i32 %47, -1
  br i1 %48, label %49, label %69

; <label>:49:                                     ; preds = %46
  %50 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %50, align 8, !tbaa !291
  %51 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %51, align 4, !tbaa !293
  %52 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  store i32 8, i32* %52, align 8, !tbaa !294
  %53 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %54 = bitcast %union.anon.8* %53 to i32*
  store i32 %47, i32* %54, align 8, !tbaa !21
  %55 = icmp eq i32 %3, 0
  br i1 %55, label %56, label %106

; <label>:56:                                     ; preds = %49
  %57 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 3
  br label %58

; <label>:58:                                     ; preds = %58, %56
  %59 = phi %struct.BlockCnt** [ %57, %56 ], [ %65, %58 ]
  %60 = load %struct.BlockCnt*, %struct.BlockCnt** %59, align 8, !tbaa !54
  %61 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %60, i64 0, i32 3
  %62 = load i8, i8* %61, align 8, !tbaa !284
  %63 = zext i8 %62 to i32
  %64 = icmp sgt i32 %63, %47
  %65 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %60, i64 0, i32 0
  br i1 %64, label %58, label %66

; <label>:66:                                     ; preds = %58
  %67 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %60, i64 0, i32 4
  store i8 1, i8* %67, align 1, !tbaa !287
  %68 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 17
  store i8 1, i8* %68, align 2, !tbaa !299
  br label %106

; <label>:69:                                     ; preds = %34, %16, %46
  %70 = phi %struct.Proto* [ %18, %16 ], [ %29, %46 ], [ %29, %34 ]
  %71 = getelementptr inbounds %struct.Proto, %struct.Proto* %70, i64 0, i32 18
  %72 = load %struct.Upvaldesc*, %struct.Upvaldesc** %71, align 8, !tbaa !198
  %73 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 14
  %74 = load i8, i8* %73, align 1, !tbaa !297
  %75 = icmp eq i8 %74, 0
  br i1 %75, label %91, label %76

; <label>:76:                                     ; preds = %69
  %77 = zext i8 %74 to i64
  br label %78

; <label>:78:                                     ; preds = %83, %76
  %79 = phi i64 [ 0, %76 ], [ %84, %83 ]
  %80 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %72, i64 %79, i32 0
  %81 = load %struct.TString*, %struct.TString** %80, align 8, !tbaa !199
  %82 = icmp eq %struct.TString* %81, %1
  br i1 %82, label %86, label %83

; <label>:83:                                     ; preds = %78
  %84 = add nuw nsw i64 %79, 1
  %85 = icmp ult i64 %84, %77
  br i1 %85, label %78, label %91

; <label>:86:                                     ; preds = %78
  %87 = trunc i64 %79 to i32
  %88 = icmp slt i32 %87, 0
  br i1 %88, label %91, label %89

; <label>:89:                                     ; preds = %86
  %90 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  br label %99

; <label>:91:                                     ; preds = %83, %69, %86
  %92 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 1
  %93 = load %struct.FuncState*, %struct.FuncState** %92, align 8, !tbaa !271
  tail call fastcc void @singlevaraux(%struct.FuncState* %93, %struct.TString* %1, %struct.expdesc* %2, i32 0) #16
  %94 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %95 = load i32, i32* %94, align 8, !tbaa !294
  %96 = icmp eq i32 %95, 0
  br i1 %96, label %106, label %97

; <label>:97:                                     ; preds = %91
  %98 = tail call fastcc i32 @newupvalue(%struct.FuncState* nonnull %0, %struct.TString* %1, %struct.expdesc* nonnull %2) #16
  br label %99

; <label>:99:                                     ; preds = %89, %97
  %100 = phi i32* [ %90, %89 ], [ %94, %97 ]
  %101 = phi i32 [ %87, %89 ], [ %98, %97 ]
  %102 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 2
  store i32 -1, i32* %102, align 8, !tbaa !291
  %103 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  store i32 -1, i32* %103, align 4, !tbaa !293
  store i32 9, i32* %100, align 8, !tbaa !294
  %104 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %105 = bitcast %union.anon.8* %104 to i32*
  store i32 %101, i32* %105, align 8, !tbaa !21
  br label %106

; <label>:106:                                    ; preds = %66, %49, %99, %91
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @explist(%struct.LexState*, %struct.expdesc*) unnamed_addr #0 {
  %3 = tail call fastcc i32 @subexpr(%struct.LexState* %0, %struct.expdesc* %1, i32 0) #17
  %4 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !260
  %6 = icmp eq i32 %5, 44
  br i1 %6, label %7, label %31

; <label>:7:                                      ; preds = %2
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %9 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %11 = getelementptr inbounds %struct.Token, %struct.Token* %10, i64 0, i32 0
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %13 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %15 = bitcast %struct.Token* %14 to i8*
  %16 = bitcast %struct.Token* %10 to i8*
  br label %17

; <label>:17:                                     ; preds = %7, %25
  %18 = phi i32 [ 1, %7 ], [ %28, %25 ]
  %19 = load i32, i32* %8, align 4, !tbaa !265
  store i32 %19, i32* %9, align 8, !tbaa !266
  %20 = load i32, i32* %11, align 8, !tbaa !263
  %21 = icmp eq i32 %20, 289
  br i1 %21, label %23, label %22

; <label>:22:                                     ; preds = %17
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %15, i8* nonnull %16, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %11, align 8, !tbaa !263
  br label %25

; <label>:23:                                     ; preds = %17
  %24 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %12) #17
  store i32 %24, i32* %4, align 8, !tbaa !260
  br label %25

; <label>:25:                                     ; preds = %22, %23
  %26 = load %struct.FuncState*, %struct.FuncState** %13, align 8, !tbaa !273
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %26, %struct.expdesc* %1) #16
  %27 = tail call fastcc i32 @subexpr(%struct.LexState* nonnull %0, %struct.expdesc* %1, i32 0) #17
  %28 = add nuw nsw i32 %18, 1
  %29 = load i32, i32* %4, align 8, !tbaa !260
  %30 = icmp eq i32 %29, 44
  br i1 %30, label %17, label %31

; <label>:31:                                     ; preds = %25, %2
  %32 = phi i32 [ 1, %2 ], [ %28, %25 ]
  ret i32 %32
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @isSCnumber(%struct.expdesc* nocapture readonly, i64* nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !294
  switch i32 %5, label %35 [
    i32 6, label %6
    i32 5, label %9
  ]

; <label>:6:                                      ; preds = %3
  %7 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !21
  store i64 %8, i64* %1, align 8, !tbaa !144
  br label %24

; <label>:9:                                      ; preds = %3
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 1
  %11 = bitcast %union.anon.8* %10 to double*
  %12 = load double, double* %11, align 8, !tbaa !21
  %13 = tail call double @llvm.floor.f64(double %12) #7
  %14 = fcmp une double %13, %12
  br i1 %14, label %35, label %15

; <label>:15:                                     ; preds = %9
  %16 = fcmp oge double %13, 0xC3E0000000000000
  %17 = fcmp olt double %13, 0x43E0000000000000
  %18 = and i1 %16, %17
  br i1 %18, label %19, label %35

; <label>:19:                                     ; preds = %15
  %20 = fptosi double %13 to i64
  store i64 %20, i64* %1, align 8, !tbaa !144
  %21 = add i64 %20, 65535
  %22 = icmp ugt i64 %21, 131071
  br i1 %22, label %35, label %23

; <label>:23:                                     ; preds = %19
  store i32 1, i32* %2, align 4, !tbaa !77
  br label %24

; <label>:24:                                     ; preds = %23, %6
  %25 = phi i64 [ %20, %23 ], [ %8, %6 ]
  %26 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 2
  %27 = load i32, i32* %26, align 8, !tbaa !291
  %28 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %0, i64 0, i32 3
  %29 = load i32, i32* %28, align 4, !tbaa !293
  %30 = icmp eq i32 %27, %29
  br i1 %30, label %31, label %35

; <label>:31:                                     ; preds = %24
  %32 = add i64 %25, 127
  %33 = icmp ugt i64 %32, 255
  br i1 %33, label %35, label %34

; <label>:34:                                     ; preds = %31
  store i64 %32, i64* %1, align 8, !tbaa !144
  br label %35

; <label>:35:                                     ; preds = %9, %15, %24, %31, %19, %3, %34
  %36 = phi i32 [ 1, %34 ], [ 0, %3 ], [ 0, %19 ], [ 0, %31 ], [ 0, %24 ], [ 0, %15 ], [ 0, %9 ]
  ret i32 %36
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @codearith(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32, i32) unnamed_addr #0 {
  %7 = alloca %struct.expdesc, align 8
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !294
  %10 = icmp eq i32 %9, 6
  %11 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 2
  %12 = load i32, i32* %11, align 8, !tbaa !291
  %13 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 3
  %14 = load i32, i32* %13, align 4, !tbaa !293
  %15 = icmp eq i32 %12, %14
  %16 = and i1 %10, %15
  br i1 %16, label %17, label %26

; <label>:17:                                     ; preds = %6
  %18 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %19 = load i64, i64* %18, align 8, !tbaa !21
  %20 = add i64 %19, 127
  %21 = icmp ugt i64 %20, 255
  br i1 %21, label %26, label %22

; <label>:22:                                     ; preds = %17
  %23 = add i32 %1, -19
  %24 = trunc i64 %19 to i32
  %25 = add nsw i32 %24, 127
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* nonnull %3, i32 %23, i32 %25, i32 %4, i32 %5) #17
  br label %48

; <label>:26:                                     ; preds = %6, %17
  %27 = phi i32 [ %12, %17 ], [ %14, %6 ]
  %28 = icmp eq i32 %12, %27
  %29 = add i32 %9, -5
  %30 = icmp ult i32 %29, 2
  %31 = and i1 %30, %28
  br i1 %31, label %32, label %40

; <label>:32:                                     ; preds = %26
  %33 = tail call fastcc i32 @luaK_exp2K(%struct.FuncState* %0, %struct.expdesc* nonnull %3) #16
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %40, label %35

; <label>:35:                                     ; preds = %32
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to i32*
  %38 = load i32, i32* %37, align 8, !tbaa !21
  %39 = add i32 %1, -12
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* nonnull %3, i32 %39, i32 %38, i32 %4, i32 %5) #16
  br label %48

; <label>:40:                                     ; preds = %26, %32
  %41 = icmp eq i32 %4, 0
  br i1 %41, label %46, label %42

; <label>:42:                                     ; preds = %40
  %43 = bitcast %struct.expdesc* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %43)
  %44 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %43, i8* %44, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  %45 = bitcast %struct.expdesc* %3 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %44, i8* %45, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* nonnull %43, i64 24, i32 8, i1 false) #7, !tbaa.struct !323
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %43)
  br label %46

; <label>:46:                                     ; preds = %40, %42
  %47 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %3) #17
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* nonnull %3, i32 %1, i32 %47, i32 0, i32 %5) #17
  br label %48

; <label>:48:                                     ; preds = %35, %46, %22
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @codeshift(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %7 = load i32, i32* %6, align 8, !tbaa !294
  %8 = icmp eq i32 %7, 6
  br i1 %8, label %9, label %29

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 2
  %11 = load i32, i32* %10, align 8, !tbaa !291
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !293
  %14 = icmp eq i32 %11, %13
  br i1 %14, label %15, label %29

; <label>:15:                                     ; preds = %9
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1, i32 0
  %17 = load i64, i64* %16, align 8, !tbaa !21
  %18 = add i64 %17, 127
  %19 = icmp ugt i64 %18, 255
  br i1 %19, label %29, label %20

; <label>:20:                                     ; preds = %15
  %21 = icmp eq i32 %1, 48
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %20
  %23 = sub nsw i64 0, %17
  store i64 %23, i64* %16, align 8, !tbaa !21
  br label %24

; <label>:24:                                     ; preds = %22, %20
  %25 = phi i64 [ %23, %22 ], [ %17, %20 ]
  %26 = phi i32 [ 1, %22 ], [ 0, %20 ]
  %27 = trunc i64 %25 to i32
  %28 = add nsw i32 %27, 127
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* nonnull %3, i32 36, i32 %28, i32 %26, i32 %4) #17
  br label %31

; <label>:29:                                     ; preds = %5, %9, %15
  %30 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %3) #17
  tail call fastcc void @finishbinexpval(%struct.FuncState* %0, %struct.expdesc* %2, %struct.expdesc* nonnull %3, i32 %1, i32 %30, i32 0, i32 %4) #17
  br label %31

; <label>:31:                                     ; preds = %29, %24
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @codeorder(%struct.FuncState* nocapture, i32, %struct.expdesc* nocapture, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  store i32 0, i32* %6, align 4, !tbaa !77
  %9 = call fastcc i32 @isSCnumber(%struct.expdesc* %3, i64* nonnull %5, i32* nonnull %6) #16
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %16, label %11

; <label>:11:                                     ; preds = %4
  %12 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %13 = load i64, i64* %5, align 8, !tbaa !144
  %14 = trunc i64 %13 to i32
  %15 = add i32 %1, 4
  br label %28

; <label>:16:                                     ; preds = %4
  %17 = call fastcc i32 @isSCnumber(%struct.expdesc* %2, i64* nonnull %5, i32* nonnull %6) #16
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %16
  %20 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3) #16
  %21 = load i64, i64* %5, align 8, !tbaa !144
  %22 = trunc i64 %21 to i32
  %23 = icmp eq i32 %1, 59
  %24 = select i1 %23, i32 65, i32 66
  br label %28

; <label>:25:                                     ; preds = %16
  %26 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %2) #16
  %27 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %3) #16
  br label %28

; <label>:28:                                     ; preds = %19, %25, %11
  %29 = phi i32 [ %15, %11 ], [ %24, %19 ], [ %1, %25 ]
  %30 = phi i32 [ %12, %11 ], [ %20, %19 ], [ %26, %25 ]
  %31 = phi i32 [ %14, %11 ], [ %22, %19 ], [ %27, %25 ]
  %32 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %33 = load i32, i32* %32, align 8, !tbaa !294
  %34 = icmp eq i32 %33, 7
  br i1 %34, label %35, label %39

; <label>:35:                                     ; preds = %28
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to i32*
  %38 = load i32, i32* %37, align 8, !tbaa !21
  br label %39

; <label>:39:                                     ; preds = %35, %28
  %40 = phi i32 [ %38, %35 ], [ -1, %28 ]
  %41 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %42 = load i32, i32* %41, align 8, !tbaa !294
  %43 = icmp eq i32 %42, 7
  br i1 %43, label %44, label %48

; <label>:44:                                     ; preds = %39
  %45 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 1
  %46 = bitcast %union.anon.8* %45 to i32*
  %47 = load i32, i32* %46, align 8, !tbaa !21
  br label %48

; <label>:48:                                     ; preds = %39, %44
  %49 = phi i32 [ %47, %44 ], [ -1, %39 ]
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %40, i32 %49) #17
  %50 = load i32, i32* %6, align 4, !tbaa !77
  %51 = shl i32 %30, 7
  %52 = shl i32 %31, 16
  %53 = shl i32 %50, 24
  %54 = or i32 %29, %51
  %55 = or i32 %54, %52
  %56 = or i32 %55, %53
  %57 = or i32 %56, 32768
  %58 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %57) #17
  %59 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 2147483449) #17
  %60 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %61 = bitcast %union.anon.8* %60 to i32*
  store i32 %59, i32* %61, align 8, !tbaa !21
  store i32 14, i32* %32, align 8, !tbaa !294
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @finishbinexpval(%struct.FuncState* nocapture, %struct.expdesc* nocapture, %struct.expdesc* nocapture readonly, i32, i32, i32, i32) unnamed_addr #0 {
  %8 = tail call fastcc i32 @luaK_exp2anyreg(%struct.FuncState* %0, %struct.expdesc* %1) #16
  %9 = shl i32 %8, 16
  %10 = shl i32 %4, 24
  %11 = shl i32 %5, 15
  %12 = or i32 %10, %3
  %13 = or i32 %12, %11
  %14 = or i32 %13, %9
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %14) #17
  %16 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %17 = load i32, i32* %16, align 8, !tbaa !294
  %18 = icmp eq i32 %17, 7
  br i1 %18, label %19, label %23

; <label>:19:                                     ; preds = %7
  %20 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %21 = bitcast %union.anon.8* %20 to i32*
  %22 = load i32, i32* %21, align 8, !tbaa !21
  br label %23

; <label>:23:                                     ; preds = %19, %7
  %24 = phi i32 [ %22, %19 ], [ -1, %7 ]
  %25 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %26 = load i32, i32* %25, align 8, !tbaa !294
  %27 = icmp eq i32 %26, 7
  br i1 %27, label %28, label %32

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 1
  %30 = bitcast %union.anon.8* %29 to i32*
  %31 = load i32, i32* %30, align 8, !tbaa !21
  br label %32

; <label>:32:                                     ; preds = %23, %28
  %33 = phi i32 [ %31, %28 ], [ -1, %23 ]
  tail call fastcc void @freeregs(%struct.FuncState* %0, i32 %24, i32 %33) #17
  %34 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %35 = bitcast %union.anon.8* %34 to i32*
  store i32 %15, i32* %35, align 8, !tbaa !21
  store i32 15, i32* %16, align 8, !tbaa !294
  tail call fastcc void @removelastlineinfo(%struct.FuncState* %0) #17
  %36 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %37 = load %struct.Proto*, %struct.Proto** %36, align 8, !tbaa !253
  tail call fastcc void @savelineinfo(%struct.FuncState* %0, %struct.Proto* %37, i32 %6) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @jumponcond(%struct.FuncState* nocapture, %struct.expdesc* nocapture, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 0
  %5 = load i32, i32* %4, align 8, !tbaa !294
  %6 = icmp eq i32 %5, 15
  br i1 %6, label %7, label %33

; <label>:7:                                      ; preds = %3
  %8 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %9 = load %struct.Proto*, %struct.Proto** %8, align 8, !tbaa !253
  %10 = getelementptr inbounds %struct.Proto, %struct.Proto* %9, i64 0, i32 16
  %11 = load i32*, i32** %10, align 8, !tbaa !116
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %13 = bitcast %union.anon.8* %12 to i32*
  %14 = load i32, i32* %13, align 8, !tbaa !21
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds i32, i32* %11, i64 %15
  %17 = load i32, i32* %16, align 4, !tbaa !77
  %18 = and i32 %17, 127
  %19 = icmp eq i32 %18, 52
  br i1 %19, label %20, label %33

; <label>:20:                                     ; preds = %7
  tail call fastcc void @removelastlineinfo(%struct.FuncState* nonnull %0) #17
  %21 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 4
  %22 = load i32, i32* %21, align 8, !tbaa !274
  %23 = add nsw i32 %22, -1
  store i32 %23, i32* %21, align 8, !tbaa !274
  %24 = icmp eq i32 %2, 0
  %25 = zext i1 %24 to i32
  %26 = lshr i32 %17, 9
  %27 = and i32 %26, 32640
  %28 = shl nuw nsw i32 %25, 15
  %29 = or i32 %28, %27
  %30 = or i32 %29, 67
  %31 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 %30) #17
  %32 = tail call fastcc i32 @luaK_code(%struct.FuncState* nonnull %0, i32 2147483449) #17
  br label %56

; <label>:33:                                     ; preds = %7, %3
  tail call fastcc void @discharge2anyreg(%struct.FuncState* %0, %struct.expdesc* nonnull %1) #16
  %34 = load i32, i32* %4, align 8, !tbaa !294
  %35 = icmp eq i32 %34, 7
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %1, i64 0, i32 1
  %37 = bitcast %union.anon.8* %36 to i32*
  br i1 %35, label %38, label %48

; <label>:38:                                     ; preds = %33
  %39 = load i32, i32* %37, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 13
  %41 = load i8, i8* %40, align 2, !tbaa !298
  %42 = zext i8 %41 to i32
  %43 = icmp slt i32 %39, %42
  br i1 %43, label %48, label %44

; <label>:44:                                     ; preds = %38
  %45 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 15
  %46 = load i8, i8* %45, align 4, !tbaa !303
  %47 = add i8 %46, -1
  store i8 %47, i8* %45, align 4, !tbaa !303
  br label %48

; <label>:48:                                     ; preds = %33, %38, %44
  %49 = load i32, i32* %37, align 8, !tbaa !21
  %50 = shl i32 %49, 16
  %51 = shl i32 %2, 15
  %52 = or i32 %51, %50
  %53 = or i32 %52, 32708
  %54 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 %53) #17
  %55 = tail call fastcc i32 @luaK_code(%struct.FuncState* %0, i32 2147483449) #17
  br label %56

; <label>:56:                                     ; preds = %20, %48
  %57 = phi i32 [ %55, %48 ], [ %32, %20 ]
  ret i32 %57
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @newlabelentry(%struct.LexState* nocapture readonly, %struct.Labellist* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 1
  %7 = load i32, i32* %6, align 8, !tbaa !316
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %9 = load %struct.lua_State*, %struct.lua_State** %8, align 8, !tbaa !261
  %10 = bitcast %struct.Labellist* %1 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !317
  %12 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %1, i64 0, i32 2
  %13 = tail call fastcc i8* @luaM_growaux_(%struct.lua_State* %9, i8* %11, i32 %7, i32* nonnull %12, i32 24, i32 32767, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.262, i64 0, i64 0)) #16
  %14 = bitcast i8* %13 to %struct.Labeldesc*
  store i8* %13, i8** %10, align 8, !tbaa !317
  %15 = sext i32 %7 to i64
  %16 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 0
  store %struct.TString* %2, %struct.TString** %16, align 8, !tbaa !308
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 2
  store i32 %3, i32* %17, align 4, !tbaa !310
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %19 = load %struct.FuncState*, %struct.FuncState** %18, align 8, !tbaa !273
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %19, i64 0, i32 13
  %21 = load i8, i8* %20, align 2, !tbaa !298
  %22 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 3
  store i8 %21, i8* %22, align 8, !tbaa !311
  %23 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 4
  store i8 0, i8* %23, align 1, !tbaa !318
  %24 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %14, i64 %15, i32 1
  store i32 %4, i32* %24, align 8, !tbaa !312
  %25 = add nsw i32 %7, 1
  store i32 %25, i32* %6, align 8, !tbaa !316
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @createlabel(%struct.LexState* nocapture, %struct.TString*, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %7 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 10
  %8 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !256
  %9 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %8, i64 0, i32 2
  %10 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 4
  %11 = load i32, i32* %10, align 8, !tbaa !274
  %12 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 5
  store i32 %11, i32* %12, align 4, !tbaa !276
  %13 = tail call fastcc i32 @newlabelentry(%struct.LexState* %0, %struct.Labellist* nonnull %9, %struct.TString* %1, i32 %2, i32 %11) #16
  %14 = icmp eq i32 %3, 0
  br i1 %14, label %15, label %19

; <label>:15:                                     ; preds = %4
  %16 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %17 = load %struct.Labeldesc*, %struct.Labeldesc** %16, align 8, !tbaa !317
  %18 = sext i32 %13 to i64
  br label %28

; <label>:19:                                     ; preds = %4
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 3
  %21 = load %struct.BlockCnt*, %struct.BlockCnt** %20, align 8, !tbaa !290
  %22 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %21, i64 0, i32 3
  %23 = load i8, i8* %22, align 8, !tbaa !284
  %24 = getelementptr inbounds %struct.Labellist, %struct.Labellist* %9, i64 0, i32 0
  %25 = load %struct.Labeldesc*, %struct.Labeldesc** %24, align 8, !tbaa !317
  %26 = sext i32 %13 to i64
  %27 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %25, i64 %26, i32 3
  store i8 %23, i8* %27, align 8, !tbaa !311
  br label %28

; <label>:28:                                     ; preds = %15, %19
  %29 = phi i64 [ %18, %15 ], [ %26, %19 ]
  %30 = phi %struct.Labeldesc* [ %17, %15 ], [ %25, %19 ]
  %31 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !256
  %32 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %33 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %32, i64 0, i32 3
  %34 = load %struct.BlockCnt*, %struct.BlockCnt** %33, align 8, !tbaa !290
  %35 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %34, i64 0, i32 2
  %36 = load i32, i32* %35, align 4, !tbaa !286
  %37 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %31, i64 0, i32 1, i32 1
  %38 = load i32, i32* %37, align 8, !tbaa !316
  %39 = icmp slt i32 %36, %38
  br i1 %39, label %40, label %110

; <label>:40:                                     ; preds = %28
  %41 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %31, i64 0, i32 1, i32 0
  %42 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %30, i64 %29, i32 0
  %43 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %30, i64 %29, i32 3
  %44 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %30, i64 %29, i32 1
  br label %45

; <label>:45:                                     ; preds = %96, %40
  %46 = phi i32 [ %38, %40 ], [ %97, %96 ]
  %47 = phi i32 [ 0, %40 ], [ %99, %96 ]
  %48 = phi i32 [ %36, %40 ], [ %98, %96 ]
  %49 = load %struct.Labeldesc*, %struct.Labeldesc** %41, align 8, !tbaa !317
  %50 = sext i32 %48 to i64
  %51 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %49, i64 %50, i32 0
  %52 = load %struct.TString*, %struct.TString** %51, align 8, !tbaa !308
  %53 = load %struct.TString*, %struct.TString** %42, align 8, !tbaa !308
  %54 = icmp eq %struct.TString* %52, %53
  br i1 %54, label %55, label %94

; <label>:55:                                     ; preds = %45
  %56 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %49, i64 %50, i32 4
  %57 = load i8, i8* %56, align 1, !tbaa !318
  %58 = zext i8 %57 to i32
  %59 = or i32 %47, %58
  %60 = load %struct.Dyndata*, %struct.Dyndata** %7, align 8, !tbaa !256
  %61 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %60, i64 0, i32 1, i32 0
  %62 = load %struct.Labeldesc*, %struct.Labeldesc** %61, align 8, !tbaa !317
  %63 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %50, i32 3
  %64 = load i8, i8* %63, align 8, !tbaa !311
  %65 = load i8, i8* %43, align 8, !tbaa !311
  %66 = icmp ult i8 %64, %65
  br i1 %66, label %67, label %69, !prof !61

; <label>:67:                                     ; preds = %55
  %68 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %50
  tail call fastcc void @jumpscopeerror(%struct.LexState* nonnull %0, %struct.Labeldesc* %68) #19
  unreachable

; <label>:69:                                     ; preds = %55
  %70 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %71 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %62, i64 %50, i32 1
  %72 = load i32, i32* %71, align 8, !tbaa !312
  %73 = load i32, i32* %44, align 8, !tbaa !312
  tail call fastcc void @patchlistaux(%struct.FuncState* %70, i32 %72, i32 %73, i32 255, i32 %73) #17
  %74 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %60, i64 0, i32 1, i32 1
  %75 = load i32, i32* %74, align 8, !tbaa !316
  %76 = add nsw i32 %75, -1
  %77 = icmp sgt i32 %76, %48
  br i1 %77, label %78, label %91

; <label>:78:                                     ; preds = %69
  br label %79

; <label>:79:                                     ; preds = %78, %79
  %80 = phi i64 [ %83, %79 ], [ %50, %78 ]
  %81 = load %struct.Labeldesc*, %struct.Labeldesc** %61, align 8, !tbaa !317
  %82 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %81, i64 %80
  %83 = add nsw i64 %80, 1
  %84 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %81, i64 %83
  %85 = bitcast %struct.Labeldesc* %82 to i8*
  %86 = bitcast %struct.Labeldesc* %84 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %85, i8* %86, i64 24, i32 8, i1 false) #7, !tbaa.struct !331
  %87 = load i32, i32* %74, align 8, !tbaa !316
  %88 = add nsw i32 %87, -1
  %89 = sext i32 %88 to i64
  %90 = icmp slt i64 %83, %89
  br i1 %90, label %79, label %91

; <label>:91:                                     ; preds = %79, %69
  %92 = phi i32 [ %76, %69 ], [ %88, %79 ]
  store i32 %92, i32* %74, align 8, !tbaa !316
  %93 = load i32, i32* %37, align 8, !tbaa !316
  br label %96

; <label>:94:                                     ; preds = %45
  %95 = add nsw i32 %48, 1
  br label %96

; <label>:96:                                     ; preds = %94, %91
  %97 = phi i32 [ %93, %91 ], [ %46, %94 ]
  %98 = phi i32 [ %48, %91 ], [ %95, %94 ]
  %99 = phi i32 [ %59, %91 ], [ %47, %94 ]
  %100 = icmp slt i32 %98, %97
  br i1 %100, label %45, label %101

; <label>:101:                                    ; preds = %96
  %102 = icmp eq i32 %99, 0
  br i1 %102, label %110, label %103

; <label>:103:                                    ; preds = %101
  %104 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 13
  %105 = load i8, i8* %104, align 2, !tbaa !298
  %106 = zext i8 %105 to i32
  %107 = shl nuw nsw i32 %106, 7
  %108 = or i32 %107, 55
  %109 = tail call fastcc i32 @luaK_code(%struct.FuncState* %6, i32 %108) #17
  br label %110

; <label>:110:                                    ; preds = %28, %101, %103
  %111 = phi i32 [ 1, %103 ], [ 0, %101 ], [ 0, %28 ]
  ret i32 %111
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @undefgoto(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 0
  %4 = load %struct.TString*, %struct.TString** %3, align 8, !tbaa !308
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %6 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !261
  %7 = tail call fastcc %struct.TString* @luaS_newlstr(%struct.lua_State* %6, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i64 0, i64 0), i64 5) #16
  %8 = icmp eq %struct.TString* %4, %7
  %9 = load %struct.lua_State*, %struct.lua_State** %5, align 8, !tbaa !261
  br i1 %8, label %10, label %14

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %12 = load i32, i32* %11, align 4, !tbaa !310
  %13 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.264, i64 0, i64 0), i32 %12) #16
  br label %21

; <label>:14:                                     ; preds = %2
  %15 = bitcast %struct.Labeldesc* %1 to i8**
  %16 = load i8*, i8** %15, align 8, !tbaa !308
  %17 = getelementptr inbounds i8, i8* %16, i64 24
  %18 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %19 = load i32, i32* %18, align 4, !tbaa !310
  %20 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %9, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.265, i64 0, i64 0), i8* nonnull %17, i32 %19) #16
  br label %21

; <label>:21:                                     ; preds = %14, %10
  %22 = phi i8* [ %13, %10 ], [ %20, %14 ]
  tail call fastcc void @luaK_semerror(%struct.LexState* nonnull %0, i8* %22) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @jumpscopeerror(%struct.LexState* nocapture, %struct.Labeldesc* nocapture readonly) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %4 = load %struct.FuncState*, %struct.FuncState** %3, align 8, !tbaa !273
  %5 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 3
  %6 = load i8, i8* %5, align 8, !tbaa !311
  %7 = zext i8 %6 to i32
  %8 = tail call fastcc %struct.LocVar* @getlocvar(%struct.FuncState* %4, i32 %7) #16
  %9 = bitcast %struct.LocVar* %8 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !114
  %11 = getelementptr inbounds i8, i8* %10, i64 24
  %12 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %13 = load %struct.lua_State*, %struct.lua_State** %12, align 8, !tbaa !261
  %14 = bitcast %struct.Labeldesc* %1 to i8**
  %15 = load i8*, i8** %14, align 8, !tbaa !308
  %16 = getelementptr inbounds i8, i8* %15, i64 24
  %17 = getelementptr inbounds %struct.Labeldesc, %struct.Labeldesc* %1, i64 0, i32 2
  %18 = load i32, i32* %17, align 4, !tbaa !310
  %19 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %13, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.263, i64 0, i64 0), i8* nonnull %16, i32 %18, i8* nonnull %11) #16
  tail call fastcc void @luaK_semerror(%struct.LexState* %0, i8* %19) #18
  unreachable
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @luaK_semerror(%struct.LexState* nocapture, i8*) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  store i32 0, i32* %3, align 8, !tbaa !260
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %1) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @cond(%struct.LexState*) unnamed_addr #0 {
  %2 = alloca %struct.expdesc, align 8
  %3 = bitcast %struct.expdesc* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %3) #7
  %4 = call fastcc i32 @subexpr(%struct.LexState* %0, %struct.expdesc* nonnull %2, i32 0) #17
  %5 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 0
  %6 = load i32, i32* %5, align 8, !tbaa !294
  %7 = icmp eq i32 %6, 1
  br i1 %7, label %8, label %9

; <label>:8:                                      ; preds = %1
  store i32 3, i32* %5, align 8, !tbaa !294
  br label %9

; <label>:9:                                      ; preds = %8, %1
  %10 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %11 = load %struct.FuncState*, %struct.FuncState** %10, align 8, !tbaa !273
  call fastcc void @luaK_goiftrue(%struct.FuncState* %11, %struct.expdesc* nonnull %2) #16
  %12 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %2, i64 0, i32 3
  %13 = load i32, i32* %12, align 4, !tbaa !293
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %3) #7
  ret i32 %13
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal fastcc void @error_expected(%struct.LexState* nocapture readonly, i32) unnamed_addr #5 {
  %3 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %4 = load %struct.lua_State*, %struct.lua_State** %3, align 8, !tbaa !261
  %5 = tail call fastcc i8* @luaX_token2str(%struct.LexState* %0, i32 %1) #16
  %6 = tail call i8* (%struct.lua_State*, i8*, ...) @luaO_pushfstring(%struct.lua_State* %4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.267, i64 0, i64 0), i8* %5) #16
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* %6) #18
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @forbody(%struct.LexState*, i32, i32, i32, i32) unnamed_addr #0 {
  %6 = alloca %struct.BlockCnt, align 8
  %7 = bitcast %struct.BlockCnt* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %7) #7
  %8 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %9 = load %struct.FuncState*, %struct.FuncState** %8, align 8, !tbaa !273
  tail call fastcc void @checknext(%struct.LexState* %0, i32 259) #16
  %10 = sext i32 %4 to i64
  %11 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forprep, i64 0, i64 %10
  %12 = load i32, i32* %11, align 4, !tbaa !21
  %13 = shl i32 %1, 7
  %14 = or i32 %12, %13
  %15 = tail call fastcc i32 @luaK_code(%struct.FuncState* %9, i32 %14) #17
  %16 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 5
  store i8 0, i8* %16, align 2, !tbaa !282
  %17 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 13
  %18 = load i8, i8* %17, align 2, !tbaa !298
  %19 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 3
  store i8 %18, i8* %19, align 8, !tbaa !284
  %20 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 2
  %21 = load %struct.LexState*, %struct.LexState** %20, align 8, !tbaa !272
  %22 = getelementptr inbounds %struct.LexState, %struct.LexState* %21, i64 0, i32 10
  %23 = load %struct.Dyndata*, %struct.Dyndata** %22, align 8, !tbaa !256
  %24 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 2, i32 1
  %25 = load i32, i32* %24, align 8, !tbaa !257
  %26 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 1
  store i32 %25, i32* %26, align 8, !tbaa !285
  %27 = getelementptr inbounds %struct.Dyndata, %struct.Dyndata* %23, i64 0, i32 1, i32 1
  %28 = load i32, i32* %27, align 8, !tbaa !258
  %29 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 2
  store i32 %28, i32* %29, align 4, !tbaa !286
  %30 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 4
  store i8 0, i8* %30, align 1, !tbaa !287
  %31 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 3
  %32 = load %struct.BlockCnt*, %struct.BlockCnt** %31, align 8, !tbaa !290
  %33 = icmp eq %struct.BlockCnt* %32, null
  %34 = ptrtoint %struct.BlockCnt* %32 to i64
  br i1 %33, label %40, label %35

; <label>:35:                                     ; preds = %5
  %36 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %32, i64 0, i32 6
  %37 = load i8, i8* %36, align 1, !tbaa !288
  %38 = icmp ne i8 %37, 0
  %39 = zext i1 %38 to i8
  br label %40

; <label>:40:                                     ; preds = %5, %35
  %41 = phi i8 [ 0, %5 ], [ %39, %35 ]
  %42 = getelementptr inbounds %struct.BlockCnt, %struct.BlockCnt* %6, i64 0, i32 6
  store i8 %41, i8* %42, align 1, !tbaa !288
  %43 = bitcast %struct.BlockCnt* %6 to i64*
  store i64 %34, i64* %43, align 8, !tbaa !289
  store %struct.BlockCnt* %6, %struct.BlockCnt** %31, align 8, !tbaa !290
  call fastcc void @adjustlocalvars(%struct.LexState* nonnull %0, i32 %3) #16
  call fastcc void @luaK_checkstack(%struct.FuncState* %9, i32 %3) #17
  %44 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 15
  %45 = load i8, i8* %44, align 4, !tbaa !303
  %46 = trunc i32 %3 to i8
  %47 = add i8 %45, %46
  store i8 %47, i8* %44, align 4, !tbaa !303
  call fastcc void @block(%struct.LexState* nonnull %0) #16
  call fastcc void @leaveblock(%struct.FuncState* %9) #16
  %48 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 4
  %49 = load i32, i32* %48, align 8, !tbaa !274
  %50 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 5
  store i32 %49, i32* %50, align 4, !tbaa !276
  call fastcc void @fixforjump(%struct.FuncState* %9, i32 %15, i32 %49, i32 0) #16
  %51 = icmp eq i32 %4, 0
  br i1 %51, label %52, label %54

; <label>:52:                                     ; preds = %40
  %53 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 0
  br label %63

; <label>:54:                                     ; preds = %40
  %55 = shl i32 %3, 24
  %56 = or i32 %13, %55
  %57 = or i32 %56, 77
  %58 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %9, i32 %57) #17
  call fastcc void @removelastlineinfo(%struct.FuncState* nonnull %9) #17
  %59 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %9, i64 0, i32 0
  %60 = load %struct.Proto*, %struct.Proto** %59, align 8, !tbaa !253
  call fastcc void @savelineinfo(%struct.FuncState* nonnull %9, %struct.Proto* %60, i32 %2) #17
  %61 = shl i32 %1, 7
  %62 = add i32 %61, 256
  br label %63

; <label>:63:                                     ; preds = %52, %54
  %64 = phi %struct.Proto** [ %53, %52 ], [ %59, %54 ]
  %65 = phi i32 [ %13, %52 ], [ %62, %54 ]
  %66 = getelementptr inbounds [2 x i32], [2 x i32]* @forbody.forloop, i64 0, i64 %10
  %67 = load i32, i32* %66, align 4, !tbaa !21
  %68 = or i32 %65, %67
  %69 = call fastcc i32 @luaK_code(%struct.FuncState* nonnull %9, i32 %68) #17
  %70 = add nsw i32 %15, 1
  call fastcc void @fixforjump(%struct.FuncState* nonnull %9, i32 %69, i32 %70, i32 1) #16
  call fastcc void @removelastlineinfo(%struct.FuncState* nonnull %9) #17
  %71 = load %struct.Proto*, %struct.Proto** %64, align 8, !tbaa !253
  call fastcc void @savelineinfo(%struct.FuncState* nonnull %9, %struct.Proto* %71, i32 %2) #17
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %7) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @fixforjump(%struct.FuncState* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 0
  %6 = load %struct.Proto*, %struct.Proto** %5, align 8, !tbaa !253
  %7 = getelementptr inbounds %struct.Proto, %struct.Proto* %6, i64 0, i32 16
  %8 = load i32*, i32** %7, align 8, !tbaa !116
  %9 = sext i32 %1 to i64
  %10 = getelementptr inbounds i32, i32* %8, i64 %9
  %11 = xor i32 %1, -1
  %12 = add i32 %11, %2
  %13 = icmp eq i32 %3, 0
  %14 = sub nsw i32 0, %12
  %15 = select i1 %13, i32 %12, i32 %14
  %16 = icmp sgt i32 %15, 131071
  br i1 %16, label %17, label %20, !prof !61

; <label>:17:                                     ; preds = %4
  %18 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %0, i64 0, i32 2
  %19 = load %struct.LexState*, %struct.LexState** %18, align 8, !tbaa !272
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %19, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.251, i64 0, i64 0)) #18
  unreachable

; <label>:20:                                     ; preds = %4
  %21 = load i32, i32* %10, align 4, !tbaa !77
  %22 = and i32 %21, 32767
  %23 = shl i32 %15, 15
  %24 = or i32 %22, %23
  store i32 %24, i32* %10, align 4, !tbaa !77
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @adjust_assign(%struct.LexState* nocapture readonly, i32, i32, %struct.expdesc* nocapture) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %6 = load %struct.FuncState*, %struct.FuncState** %5, align 8, !tbaa !273
  %7 = sub nsw i32 %1, %2
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %3, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !294
  switch i32 %9, label %10 [
    i32 16, label %17
    i32 17, label %17
    i32 0, label %11
  ]

; <label>:10:                                     ; preds = %4
  tail call fastcc void @luaK_exp2nextreg(%struct.FuncState* %6, %struct.expdesc* nonnull %3) #16
  br label %11

; <label>:11:                                     ; preds = %4, %10
  %12 = icmp sgt i32 %7, 0
  br i1 %12, label %13, label %26

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  %15 = load i8, i8* %14, align 4, !tbaa !303
  %16 = zext i8 %15 to i32
  tail call fastcc void @luaK_nil(%struct.FuncState* %6, i32 %16, i32 %7) #16
  br label %24

; <label>:17:                                     ; preds = %4, %4
  %18 = add nsw i32 %7, 1
  %19 = icmp sgt i32 %18, 0
  %20 = select i1 %19, i32 %18, i32 0
  tail call fastcc void @luaK_setreturns(%struct.FuncState* %6, %struct.expdesc* nonnull %3, i32 %20) #16
  %21 = icmp sgt i32 %7, 0
  br i1 %21, label %22, label %26

; <label>:22:                                     ; preds = %17
  %23 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  br label %24

; <label>:24:                                     ; preds = %22, %13
  %25 = phi i8* [ %23, %22 ], [ %14, %13 ]
  tail call fastcc void @luaK_checkstack(%struct.FuncState* %6, i32 %7) #17
  br label %28

; <label>:26:                                     ; preds = %11, %17
  %27 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %6, i64 0, i32 15
  br label %28

; <label>:28:                                     ; preds = %26, %24
  %29 = phi i8* [ %27, %26 ], [ %25, %24 ]
  %30 = load i8, i8* %29, align 4, !tbaa !303
  %31 = trunc i32 %7 to i8
  %32 = add i8 %30, %31
  store i8 %32, i8* %29, align 4, !tbaa !303
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @restassign(%struct.LexState*, %struct.LHS_assign*, i32) unnamed_addr #0 {
  %4 = alloca %struct.expdesc, align 8
  %5 = alloca %struct.LHS_assign, align 8
  %6 = bitcast %struct.expdesc* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %1, i64 0, i32 1
  %8 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %7, i64 0, i32 0
  %9 = load i32, i32* %8, align 8, !tbaa !315
  %10 = add i32 %9, -8
  %11 = icmp ult i32 %10, 6
  br i1 %11, label %13, label %12

; <label>:12:                                     ; preds = %3
  tail call fastcc void @luaX_syntaxerror(%struct.LexState* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.279, i64 0, i64 0)) #18
  unreachable

; <label>:13:                                     ; preds = %3
  %14 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 0
  %15 = load i32, i32* %14, align 8, !tbaa !260
  %16 = icmp eq i32 %15, 44
  br i1 %16, label %17, label %121

; <label>:17:                                     ; preds = %13
  %18 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 1
  %19 = load i32, i32* %18, align 4, !tbaa !265
  %20 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 2
  store i32 %19, i32* %20, align 8, !tbaa !266
  %21 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 4
  %22 = getelementptr inbounds %struct.Token, %struct.Token* %21, i64 0, i32 0
  %23 = load i32, i32* %22, align 8, !tbaa !263
  %24 = icmp eq i32 %23, 289
  br i1 %24, label %29, label %25

; <label>:25:                                     ; preds = %17
  %26 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3
  %27 = bitcast %struct.Token* %26 to i8*
  %28 = bitcast %struct.Token* %21 to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %27, i8* nonnull %28, i64 16, i32 8, i1 false) #7, !tbaa.struct !295
  store i32 289, i32* %22, align 8, !tbaa !263
  br label %32

; <label>:29:                                     ; preds = %17
  %30 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 3, i32 1
  %31 = tail call fastcc i32 @llex(%struct.LexState* nonnull %0, %union.SemInfo* nonnull %30) #17
  store i32 %31, i32* %14, align 8, !tbaa !260
  br label %32

; <label>:32:                                     ; preds = %25, %29
  %33 = bitcast %struct.LHS_assign* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %33) #7
  %34 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 0
  store %struct.LHS_assign* %1, %struct.LHS_assign** %34, align 8, !tbaa !313
  %35 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 1
  call fastcc void @suffixedexp(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %35) #16
  %36 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %35, i64 0, i32 0
  %37 = load i32, i32* %36, align 8, !tbaa !315
  %38 = add i32 %37, -10
  %39 = icmp ult i32 %38, 4
  br i1 %39, label %113, label %40

; <label>:40:                                     ; preds = %32
  %41 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %42 = load %struct.FuncState*, %struct.FuncState** %41, align 8, !tbaa !273
  %43 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %42, i64 0, i32 15
  %44 = load i8, i8* %43, align 4, !tbaa !303
  %45 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %5, i64 0, i32 1, i32 1
  %46 = bitcast %union.anon.8* %45 to i32*
  %47 = zext i8 %44 to i16
  br label %48

; <label>:48:                                     ; preds = %93, %40
  %49 = phi %struct.LHS_assign* [ %1, %40 ], [ %96, %93 ]
  %50 = phi i32 [ 0, %40 ], [ %94, %93 ]
  %51 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %49, i64 0, i32 1, i32 0
  %52 = load i32, i32* %51, align 8, !tbaa !315
  %53 = add i32 %52, -10
  %54 = icmp ult i32 %53, 4
  br i1 %54, label %55, label %93

; <label>:55:                                     ; preds = %48
  %56 = icmp eq i32 %52, 11
  %57 = load i32, i32* %36, align 8, !tbaa !294
  br i1 %56, label %58, label %69

; <label>:58:                                     ; preds = %55
  %59 = icmp eq i32 %57, 9
  br i1 %59, label %60, label %93

; <label>:60:                                     ; preds = %58
  %61 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %49, i64 0, i32 1, i32 1
  %62 = bitcast %union.anon.8* %61 to %struct.anon.9*
  %63 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %62, i64 0, i32 1
  %64 = load i8, i8* %63, align 2, !tbaa !21
  %65 = zext i8 %64 to i32
  %66 = load i32, i32* %46, align 8, !tbaa !21
  %67 = icmp eq i32 %66, %65
  br i1 %67, label %68, label %93

; <label>:68:                                     ; preds = %60
  store i32 13, i32* %51, align 8, !tbaa !315
  store i8 %44, i8* %63, align 2, !tbaa !21
  br label %93

; <label>:69:                                     ; preds = %55
  %70 = icmp eq i32 %57, 8
  br i1 %70, label %71, label %93

; <label>:71:                                     ; preds = %69
  %72 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %49, i64 0, i32 1, i32 1
  %73 = bitcast %union.anon.8* %72 to %struct.anon.9*
  %74 = getelementptr inbounds %struct.anon.9, %struct.anon.9* %73, i64 0, i32 1
  %75 = load i8, i8* %74, align 2, !tbaa !21
  %76 = zext i8 %75 to i32
  %77 = load i32, i32* %46, align 8, !tbaa !21
  %78 = icmp eq i32 %77, %76
  br i1 %78, label %79, label %80

; <label>:79:                                     ; preds = %71
  store i8 %44, i8* %74, align 2, !tbaa !21
  br label %80

; <label>:80:                                     ; preds = %79, %71
  %81 = phi i32 [ 1, %79 ], [ %50, %71 ]
  %82 = icmp ne i32 %52, 10
  %83 = xor i1 %70, true
  %84 = or i1 %82, %83
  br i1 %84, label %93, label %85

; <label>:85:                                     ; preds = %80
  %86 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %49, i64 0, i32 1, i32 1
  %87 = bitcast %union.anon.8* %86 to i16*
  %88 = load i16, i16* %87, align 8, !tbaa !21
  %89 = sext i16 %88 to i32
  %90 = load i32, i32* %46, align 8, !tbaa !21
  %91 = icmp eq i32 %90, %89
  br i1 %91, label %92, label %93

; <label>:92:                                     ; preds = %85
  store i16 %47, i16* %87, align 8, !tbaa !21
  br label %93

; <label>:93:                                     ; preds = %69, %80, %92, %85, %68, %60, %58, %48
  %94 = phi i32 [ 1, %68 ], [ %50, %60 ], [ %50, %58 ], [ 1, %92 ], [ %81, %85 ], [ %81, %80 ], [ %50, %48 ], [ %50, %69 ]
  %95 = getelementptr inbounds %struct.LHS_assign, %struct.LHS_assign* %49, i64 0, i32 0
  %96 = load %struct.LHS_assign*, %struct.LHS_assign** %95, align 8, !tbaa !313
  %97 = icmp eq %struct.LHS_assign* %96, null
  br i1 %97, label %98, label %48

; <label>:98:                                     ; preds = %93
  %99 = icmp eq i32 %94, 0
  br i1 %99, label %113, label %100

; <label>:100:                                    ; preds = %98
  %101 = zext i8 %44 to i32
  %102 = load i32, i32* %36, align 8, !tbaa !294
  %103 = icmp eq i32 %102, 8
  %104 = select i1 %103, i32 0, i32 7
  %105 = load i32, i32* %46, align 8, !tbaa !21
  %106 = shl nuw nsw i32 %101, 7
  %107 = or i32 %104, %106
  %108 = shl i32 %105, 16
  %109 = or i32 %107, %108
  %110 = call fastcc i32 @luaK_code(%struct.FuncState* %42, i32 %109) #17
  call fastcc void @luaK_checkstack(%struct.FuncState* %42, i32 1) #17
  %111 = load i8, i8* %43, align 4, !tbaa !303
  %112 = add i8 %111, 1
  store i8 %112, i8* %43, align 4, !tbaa !303
  br label %113

; <label>:113:                                    ; preds = %100, %98, %32
  %114 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 6
  %115 = load %struct.lua_State*, %struct.lua_State** %114, align 8, !tbaa !261
  call fastcc void @luaE_enterCcall(%struct.lua_State* %115) #16
  %116 = add nsw i32 %2, 1
  call fastcc void @restassign(%struct.LexState* %0, %struct.LHS_assign* nonnull %5, i32 %116) #16
  %117 = load %struct.lua_State*, %struct.lua_State** %114, align 8, !tbaa !261
  %118 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %117, i64 0, i32 19
  %119 = load i32, i32* %118, align 8, !tbaa !29
  %120 = add i32 %119, -1
  store i32 %120, i32* %118, align 8, !tbaa !29
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %33) #7
  br label %157

; <label>:121:                                    ; preds = %13
  tail call fastcc void @checknext(%struct.LexState* nonnull %0, i32 61) #16
  %122 = call fastcc i32 @explist(%struct.LexState* nonnull %0, %struct.expdesc* nonnull %4) #16
  %123 = icmp eq i32 %122, %2
  br i1 %123, label %125, label %124

; <label>:124:                                    ; preds = %121
  call fastcc void @adjust_assign(%struct.LexState* nonnull %0, i32 %2, i32 %122, %struct.expdesc* nonnull %4) #16
  br label %157

; <label>:125:                                    ; preds = %121
  %126 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %127 = load %struct.FuncState*, %struct.FuncState** %126, align 8, !tbaa !273
  %128 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  %129 = load i32, i32* %128, align 8, !tbaa !294
  switch i32 %129, label %156 [
    i32 16, label %130
    i32 17, label %143
  ]

; <label>:130:                                    ; preds = %125
  store i32 7, i32* %128, align 8, !tbaa !294
  %131 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %127, i64 0, i32 0
  %132 = load %struct.Proto*, %struct.Proto** %131, align 8, !tbaa !253
  %133 = getelementptr inbounds %struct.Proto, %struct.Proto* %132, i64 0, i32 16
  %134 = load i32*, i32** %133, align 8, !tbaa !116
  %135 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %136 = bitcast %union.anon.8* %135 to i32*
  %137 = load i32, i32* %136, align 8, !tbaa !21
  %138 = sext i32 %137 to i64
  %139 = getelementptr inbounds i32, i32* %134, i64 %138
  %140 = load i32, i32* %139, align 4, !tbaa !77
  %141 = lshr i32 %140, 7
  %142 = and i32 %141, 255
  store i32 %142, i32* %136, align 8, !tbaa !21
  br label %156

; <label>:143:                                    ; preds = %125
  %144 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %127, i64 0, i32 0
  %145 = load %struct.Proto*, %struct.Proto** %144, align 8, !tbaa !253
  %146 = getelementptr inbounds %struct.Proto, %struct.Proto* %145, i64 0, i32 16
  %147 = load i32*, i32** %146, align 8, !tbaa !116
  %148 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %149 = bitcast %union.anon.8* %148 to i32*
  %150 = load i32, i32* %149, align 8, !tbaa !21
  %151 = sext i32 %150 to i64
  %152 = getelementptr inbounds i32, i32* %147, i64 %151
  %153 = load i32, i32* %152, align 4, !tbaa !77
  %154 = and i32 %153, 16777215
  %155 = or i32 %154, 33554432
  store i32 %155, i32* %152, align 4, !tbaa !77
  store i32 15, i32* %128, align 8, !tbaa !294
  br label %156

; <label>:156:                                    ; preds = %125, %130, %143
  call fastcc void @luaK_storevar(%struct.FuncState* %127, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4) #16
  br label %169

; <label>:157:                                    ; preds = %124, %113
  %158 = getelementptr inbounds %struct.LexState, %struct.LexState* %0, i64 0, i32 5
  %159 = load %struct.FuncState*, %struct.FuncState** %158, align 8, !tbaa !273
  %160 = getelementptr inbounds %struct.FuncState, %struct.FuncState* %159, i64 0, i32 15
  %161 = load i8, i8* %160, align 4, !tbaa !303
  %162 = zext i8 %161 to i32
  %163 = add nsw i32 %162, -1
  %164 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 2
  store i32 -1, i32* %164, align 8, !tbaa !291
  %165 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 3
  store i32 -1, i32* %165, align 4, !tbaa !293
  %166 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 0
  store i32 7, i32* %166, align 8, !tbaa !294
  %167 = getelementptr inbounds %struct.expdesc, %struct.expdesc* %4, i64 0, i32 1
  %168 = bitcast %union.anon.8* %167 to i32*
  store i32 %163, i32* %168, align 8, !tbaa !21
  call fastcc void @luaK_storevar(%struct.FuncState* %159, %struct.expdesc* nonnull %7, %struct.expdesc* nonnull %4) #16
  br label %169

; <label>:169:                                    ; preds = %156, %157
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @luaM_shrinkvector_(%struct.lua_State*, i8*, i32* nocapture, i32, i32) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %7 = load %struct.global_State*, %struct.global_State** %6, align 8, !tbaa !2
  %8 = load i32, i32* %2, align 4, !tbaa !77
  %9 = mul nsw i32 %8, %4
  %10 = sext i32 %9 to i64
  %11 = mul nsw i32 %4, %3
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 0
  %14 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %13, align 8, !tbaa !59
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 1
  %16 = load i8*, i8** %15, align 8, !tbaa !60
  %17 = tail call i8* %14(i8* %16, i8* %1, i64 %10, i64 %12) #17
  %18 = icmp eq i8* %17, null
  %19 = icmp sgt i32 %3, 0
  %20 = and i1 %19, %18
  br i1 %20, label %21, label %22, !prof !61

; <label>:21:                                     ; preds = %5
  tail call fastcc void @luaD_throw(%struct.lua_State* nonnull %0, i32 4) #18
  unreachable

; <label>:22:                                     ; preds = %5
  %23 = sub nsw i64 %12, %10
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %7, i64 0, i32 3
  %25 = load i64, i64* %24, align 8, !tbaa !11
  %26 = add i64 %23, %25
  store i64 %26, i64* %24, align 8, !tbaa !11
  store i32 %3, i32* %2, align 4, !tbaa !77
  ret i8* %17
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpFunction(%struct.Proto* readonly, %struct.TString* readnone, %struct.DumpState*) unnamed_addr #0 {
  %4 = alloca i8, align 1
  %5 = alloca i8, align 1
  %6 = alloca i64, align 8
  %7 = alloca double, align 8
  %8 = alloca i8, align 1
  %9 = alloca i8, align 1
  %10 = alloca i8, align 1
  %11 = alloca i8, align 1
  %12 = alloca i8, align 1
  %13 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 3
  %14 = load i32, i32* %13, align 8, !tbaa !188
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %20

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %18 = load %struct.TString*, %struct.TString** %17, align 8, !tbaa !122
  %19 = icmp eq %struct.TString* %18, %1
  br i1 %19, label %20, label %21

; <label>:20:                                     ; preds = %3, %16
  tail call fastcc void @DumpSize(i64 0, %struct.DumpState* nonnull %2) #17
  br label %22

; <label>:21:                                     ; preds = %16
  tail call fastcc void @DumpString(%struct.TString* %18, %struct.DumpState* nonnull %2) #16
  br label %22

; <label>:22:                                     ; preds = %21, %20
  %23 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 13
  %24 = load i32, i32* %23, align 4, !tbaa !124
  %25 = sext i32 %24 to i64
  tail call fastcc void @DumpSize(i64 %25, %struct.DumpState* nonnull %2) #17
  %26 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 14
  %27 = load i32, i32* %26, align 8, !tbaa !125
  %28 = sext i32 %27 to i64
  tail call fastcc void @DumpSize(i64 %28, %struct.DumpState* nonnull %2) #17
  %29 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 3
  %30 = load i8, i8* %29, align 2, !tbaa !131
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %12) #7
  store i8 %30, i8* %12, align 1, !tbaa !21
  %31 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 4
  %32 = load i32, i32* %31, align 4, !tbaa !189
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %34, label %42

; <label>:34:                                     ; preds = %22
  %35 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %36 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %35, align 8, !tbaa !186
  %37 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %38 = load %struct.lua_State*, %struct.lua_State** %37, align 8, !tbaa !184
  %39 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %40 = load i8*, i8** %39, align 8, !tbaa !187
  %41 = call i32 %36(%struct.lua_State* %38, i8* nonnull %12, i64 1, i8* %40) #17
  store i32 %41, i32* %31, align 4, !tbaa !189
  br label %42

; <label>:42:                                     ; preds = %22, %34
  %43 = phi i32 [ %32, %22 ], [ %41, %34 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %12) #7
  %44 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 4
  %45 = load i8, i8* %44, align 1, !tbaa !115
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %11) #7
  store i8 %45, i8* %11, align 1, !tbaa !21
  %46 = icmp eq i32 %43, 0
  br i1 %46, label %47, label %55

; <label>:47:                                     ; preds = %42
  %48 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %49 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %48, align 8, !tbaa !186
  %50 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %51 = load %struct.lua_State*, %struct.lua_State** %50, align 8, !tbaa !184
  %52 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %53 = load i8*, i8** %52, align 8, !tbaa !187
  %54 = call i32 %49(%struct.lua_State* %51, i8* nonnull %11, i64 1, i8* %53) #17
  store i32 %54, i32* %31, align 4, !tbaa !189
  br label %55

; <label>:55:                                     ; preds = %42, %47
  %56 = phi i32 [ %54, %47 ], [ %43, %42 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %11) #7
  %57 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 5
  %58 = load i8, i8* %57, align 4, !tbaa !158
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %10) #7
  store i8 %58, i8* %10, align 1, !tbaa !21
  %59 = icmp eq i32 %56, 0
  br i1 %59, label %60, label %68

; <label>:60:                                     ; preds = %55
  %61 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %62 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %61, align 8, !tbaa !186
  %63 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %64 = load %struct.lua_State*, %struct.lua_State** %63, align 8, !tbaa !184
  %65 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %66 = load i8*, i8** %65, align 8, !tbaa !187
  %67 = call i32 %62(%struct.lua_State* %64, i8* nonnull %10, i64 1, i8* %66) #17
  store i32 %67, i32* %31, align 4, !tbaa !189
  br label %68

; <label>:68:                                     ; preds = %55, %60
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %10) #7
  %69 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 8
  %70 = load i32, i32* %69, align 8, !tbaa !220
  %71 = sext i32 %70 to i64
  call fastcc void @DumpSize(i64 %71, %struct.DumpState* nonnull %2) #17
  %72 = load i32, i32* %69, align 8, !tbaa !220
  %73 = load i32, i32* %31, align 4, !tbaa !189
  %74 = icmp eq i32 %73, 0
  %75 = icmp ne i32 %72, 0
  %76 = and i1 %75, %74
  br i1 %76, label %77, label %90

; <label>:77:                                     ; preds = %68
  %78 = sext i32 %72 to i64
  %79 = shl nsw i64 %78, 2
  %80 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 16
  %81 = bitcast i32** %80 to i8**
  %82 = load i8*, i8** %81, align 8, !tbaa !116
  %83 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %84 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %83, align 8, !tbaa !186
  %85 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %86 = load %struct.lua_State*, %struct.lua_State** %85, align 8, !tbaa !184
  %87 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %88 = load i8*, i8** %87, align 8, !tbaa !187
  %89 = call i32 %84(%struct.lua_State* %86, i8* %82, i64 %79, i8* %88) #17
  store i32 %89, i32* %31, align 4, !tbaa !189
  br label %90

; <label>:90:                                     ; preds = %68, %77
  %91 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 7
  %92 = load i32, i32* %91, align 4, !tbaa !224
  %93 = sext i32 %92 to i64
  call fastcc void @DumpSize(i64 %93, %struct.DumpState* nonnull %2) #17
  %94 = icmp sgt i32 %92, 0
  br i1 %94, label %95, label %160

; <label>:95:                                     ; preds = %90
  %96 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 15
  %97 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %98 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %99 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %100 = bitcast double* %7 to i8*
  %101 = bitcast double* %7 to i64*
  %102 = bitcast i64* %6 to i8*
  %103 = zext i32 %92 to i64
  br label %104

; <label>:104:                                    ; preds = %157, %95
  %105 = phi i64 [ 0, %95 ], [ %158, %157 ]
  %106 = load %struct.TValue*, %struct.TValue** %96, align 8, !tbaa !223
  %107 = getelementptr inbounds %struct.TValue, %struct.TValue* %106, i64 %105
  %108 = getelementptr inbounds %struct.TValue, %struct.TValue* %106, i64 %105, i32 1
  %109 = load i8, i8* %108, align 8, !tbaa !22
  %110 = and i8 %109, 63
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %9) #7
  store i8 %110, i8* %9, align 1, !tbaa !21
  %111 = load i32, i32* %31, align 4, !tbaa !189
  %112 = icmp eq i32 %111, 0
  br i1 %112, label %113, label %119

; <label>:113:                                    ; preds = %104
  %114 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %97, align 8, !tbaa !186
  %115 = load %struct.lua_State*, %struct.lua_State** %98, align 8, !tbaa !184
  %116 = load i8*, i8** %99, align 8, !tbaa !187
  %117 = call i32 %114(%struct.lua_State* %115, i8* nonnull %9, i64 1, i8* %116) #17
  store i32 %117, i32* %31, align 4, !tbaa !189
  %118 = load i8, i8* %108, align 8, !tbaa !22
  br label %119

; <label>:119:                                    ; preds = %113, %104
  %120 = phi i32 [ %111, %104 ], [ %117, %113 ]
  %121 = phi i8 [ %109, %104 ], [ %118, %113 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %9) #7
  %122 = trunc i8 %121 to i6
  switch i6 %122, label %157 [
    i6 -28, label %154
    i6 1, label %123
    i6 19, label %134
    i6 -29, label %144
    i6 20, label %154
  ]

; <label>:123:                                    ; preds = %119
  %124 = bitcast %struct.TValue* %107 to i32*
  %125 = load i32, i32* %124, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %8) #7
  %126 = trunc i32 %125 to i8
  store i8 %126, i8* %8, align 1, !tbaa !21
  %127 = icmp eq i32 %120, 0
  br i1 %127, label %128, label %133

; <label>:128:                                    ; preds = %123
  %129 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %97, align 8, !tbaa !186
  %130 = load %struct.lua_State*, %struct.lua_State** %98, align 8, !tbaa !184
  %131 = load i8*, i8** %99, align 8, !tbaa !187
  %132 = call i32 %129(%struct.lua_State* %130, i8* nonnull %8, i64 1, i8* %131) #17
  store i32 %132, i32* %31, align 4, !tbaa !189
  br label %133

; <label>:133:                                    ; preds = %128, %123
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %8) #7
  br label %157

; <label>:134:                                    ; preds = %119
  %135 = bitcast %struct.TValue* %107 to i64*
  %136 = load i64, i64* %135, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %100) #7
  store i64 %136, i64* %101, align 8, !tbaa !140
  %137 = icmp eq i32 %120, 0
  br i1 %137, label %138, label %143

; <label>:138:                                    ; preds = %134
  %139 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %97, align 8, !tbaa !186
  %140 = load %struct.lua_State*, %struct.lua_State** %98, align 8, !tbaa !184
  %141 = load i8*, i8** %99, align 8, !tbaa !187
  %142 = call i32 %139(%struct.lua_State* %140, i8* nonnull %100, i64 8, i8* %141) #17
  store i32 %142, i32* %31, align 4, !tbaa !189
  br label %143

; <label>:143:                                    ; preds = %138, %134
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %100) #7
  br label %157

; <label>:144:                                    ; preds = %119
  %145 = bitcast %struct.TValue* %107 to i64*
  %146 = load i64, i64* %145, align 8, !tbaa !21
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %102) #7
  store i64 %146, i64* %6, align 8, !tbaa !144
  %147 = icmp eq i32 %120, 0
  br i1 %147, label %148, label %153

; <label>:148:                                    ; preds = %144
  %149 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %97, align 8, !tbaa !186
  %150 = load %struct.lua_State*, %struct.lua_State** %98, align 8, !tbaa !184
  %151 = load i8*, i8** %99, align 8, !tbaa !187
  %152 = call i32 %149(%struct.lua_State* %150, i8* nonnull %102, i64 8, i8* %151) #17
  store i32 %152, i32* %31, align 4, !tbaa !189
  br label %153

; <label>:153:                                    ; preds = %148, %144
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %102) #7
  br label %157

; <label>:154:                                    ; preds = %119, %119
  %155 = bitcast %struct.TValue* %107 to %struct.TString**
  %156 = load %struct.TString*, %struct.TString** %155, align 8, !tbaa !21
  call fastcc void @DumpString(%struct.TString* %156, %struct.DumpState* nonnull %2) #17
  br label %157

; <label>:157:                                    ; preds = %154, %153, %143, %133, %119
  %158 = add nuw nsw i64 %105, 1
  %159 = icmp eq i64 %158, %103
  br i1 %159, label %160, label %104

; <label>:160:                                    ; preds = %157, %90
  %161 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 6
  %162 = load i32, i32* %161, align 8, !tbaa !190
  %163 = sext i32 %162 to i64
  call fastcc void @DumpSize(i64 %163, %struct.DumpState* nonnull %2) #17
  %164 = icmp sgt i32 %162, 0
  br i1 %164, label %165, label %200

; <label>:165:                                    ; preds = %160
  %166 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %167 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %168 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %169 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %170 = load i32, i32* %31, align 4, !tbaa !189
  %171 = zext i32 %162 to i64
  br label %172

; <label>:172:                                    ; preds = %196, %165
  %173 = phi i32 [ %170, %165 ], [ %197, %196 ]
  %174 = phi i64 [ 0, %165 ], [ %198, %196 ]
  %175 = load %struct.Upvaldesc*, %struct.Upvaldesc** %166, align 8, !tbaa !198
  %176 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %175, i64 %174, i32 1
  %177 = load i8, i8* %176, align 8, !tbaa !240
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #7
  store i8 %177, i8* %5, align 1, !tbaa !21
  %178 = icmp eq i32 %173, 0
  br i1 %178, label %179, label %185

; <label>:179:                                    ; preds = %172
  %180 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %167, align 8, !tbaa !186
  %181 = load %struct.lua_State*, %struct.lua_State** %168, align 8, !tbaa !184
  %182 = load i8*, i8** %169, align 8, !tbaa !187
  %183 = call i32 %180(%struct.lua_State* %181, i8* nonnull %5, i64 1, i8* %182) #17
  store i32 %183, i32* %31, align 4, !tbaa !189
  %184 = load %struct.Upvaldesc*, %struct.Upvaldesc** %166, align 8, !tbaa !198
  br label %185

; <label>:185:                                    ; preds = %179, %172
  %186 = phi %struct.Upvaldesc* [ %175, %172 ], [ %184, %179 ]
  %187 = phi i32 [ %173, %172 ], [ %183, %179 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #7
  %188 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %186, i64 %174, i32 2
  %189 = load i8, i8* %188, align 1, !tbaa !241
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %4) #7
  store i8 %189, i8* %4, align 1, !tbaa !21
  %190 = icmp eq i32 %187, 0
  br i1 %190, label %191, label %196

; <label>:191:                                    ; preds = %185
  %192 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %167, align 8, !tbaa !186
  %193 = load %struct.lua_State*, %struct.lua_State** %168, align 8, !tbaa !184
  %194 = load i8*, i8** %169, align 8, !tbaa !187
  %195 = call i32 %192(%struct.lua_State* %193, i8* nonnull %4, i64 1, i8* %194) #17
  store i32 %195, i32* %31, align 4, !tbaa !189
  br label %196

; <label>:196:                                    ; preds = %191, %185
  %197 = phi i32 [ %187, %185 ], [ %195, %191 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %4) #7
  %198 = add nuw nsw i64 %174, 1
  %199 = icmp eq i64 %198, %171
  br i1 %199, label %200, label %172

; <label>:200:                                    ; preds = %196, %160
  %201 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 10
  %202 = load i32, i32* %201, align 8, !tbaa !222
  %203 = sext i32 %202 to i64
  call fastcc void @DumpSize(i64 %203, %struct.DumpState* %2) #17
  %204 = icmp sgt i32 %202, 0
  br i1 %204, label %205, label %217

; <label>:205:                                    ; preds = %200
  %206 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 17
  %207 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 22
  %208 = zext i32 %202 to i64
  br label %209

; <label>:209:                                    ; preds = %209, %205
  %210 = phi i64 [ 0, %205 ], [ %215, %209 ]
  %211 = load %struct.Proto**, %struct.Proto*** %206, align 8, !tbaa !221
  %212 = getelementptr inbounds %struct.Proto*, %struct.Proto** %211, i64 %210
  %213 = load %struct.Proto*, %struct.Proto** %212, align 8, !tbaa !54
  %214 = load %struct.TString*, %struct.TString** %207, align 8, !tbaa !122
  call fastcc void @DumpFunction(%struct.Proto* %213, %struct.TString* %214, %struct.DumpState* %2) #17
  %215 = add nuw nsw i64 %210, 1
  %216 = icmp eq i64 %215, %208
  br i1 %216, label %217, label %209

; <label>:217:                                    ; preds = %209, %200
  %218 = load i32, i32* %13, align 8, !tbaa !188
  %219 = icmp eq i32 %218, 0
  br i1 %219, label %220, label %224

; <label>:220:                                    ; preds = %217
  %221 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 9
  %222 = load i32, i32* %221, align 4, !tbaa !136
  %223 = sext i32 %222 to i64
  br label %224

; <label>:224:                                    ; preds = %220, %217
  %225 = phi i64 [ %223, %220 ], [ 0, %217 ]
  call fastcc void @DumpSize(i64 %225, %struct.DumpState* nonnull %2) #17
  %226 = load i32, i32* %31, align 4, !tbaa !189
  %227 = icmp eq i32 %226, 0
  %228 = icmp ne i64 %225, 0
  %229 = and i1 %228, %227
  br i1 %229, label %230, label %240

; <label>:230:                                    ; preds = %224
  %231 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 19
  %232 = load i8*, i8** %231, align 8, !tbaa !137
  %233 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 1
  %234 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %233, align 8, !tbaa !186
  %235 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 0
  %236 = load %struct.lua_State*, %struct.lua_State** %235, align 8, !tbaa !184
  %237 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %2, i64 0, i32 2
  %238 = load i8*, i8** %237, align 8, !tbaa !187
  %239 = call i32 %234(%struct.lua_State* %236, i8* %232, i64 %225, i8* %238) #17
  store i32 %239, i32* %31, align 4, !tbaa !189
  br label %240

; <label>:240:                                    ; preds = %230, %224
  %241 = load i32, i32* %13, align 8, !tbaa !188
  %242 = icmp eq i32 %241, 0
  br i1 %242, label %244, label %243

; <label>:243:                                    ; preds = %240
  call fastcc void @DumpSize(i64 0, %struct.DumpState* nonnull %2) #17
  br label %264

; <label>:244:                                    ; preds = %240
  %245 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 12
  %246 = load i32, i32* %245, align 8, !tbaa !226
  %247 = sext i32 %246 to i64
  call fastcc void @DumpSize(i64 %247, %struct.DumpState* nonnull %2) #17
  %248 = icmp sgt i32 %246, 0
  br i1 %248, label %249, label %264

; <label>:249:                                    ; preds = %244
  %250 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 20
  %251 = zext i32 %246 to i64
  br label %252

; <label>:252:                                    ; preds = %252, %249
  %253 = phi i64 [ 0, %249 ], [ %262, %252 ]
  %254 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %250, align 8, !tbaa !225
  %255 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %254, i64 %253, i32 0
  %256 = load i32, i32* %255, align 4, !tbaa !238
  %257 = sext i32 %256 to i64
  call fastcc void @DumpSize(i64 %257, %struct.DumpState* %2) #17
  %258 = load %struct.AbsLineInfo*, %struct.AbsLineInfo** %250, align 8, !tbaa !225
  %259 = getelementptr inbounds %struct.AbsLineInfo, %struct.AbsLineInfo* %258, i64 %253, i32 1
  %260 = load i32, i32* %259, align 4, !tbaa !296
  %261 = sext i32 %260 to i64
  call fastcc void @DumpSize(i64 %261, %struct.DumpState* %2) #17
  %262 = add nuw nsw i64 %253, 1
  %263 = icmp eq i64 %262, %251
  br i1 %263, label %264, label %252

; <label>:264:                                    ; preds = %252, %244, %243
  %265 = load i32, i32* %13, align 8, !tbaa !188
  %266 = icmp eq i32 %265, 0
  br i1 %266, label %268, label %267

; <label>:267:                                    ; preds = %264
  call fastcc void @DumpSize(i64 0, %struct.DumpState* nonnull %2) #17
  br label %291

; <label>:268:                                    ; preds = %264
  %269 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 11
  %270 = load i32, i32* %269, align 4, !tbaa !108
  %271 = sext i32 %270 to i64
  call fastcc void @DumpSize(i64 %271, %struct.DumpState* nonnull %2) #17
  %272 = icmp sgt i32 %270, 0
  br i1 %272, label %273, label %291

; <label>:273:                                    ; preds = %268
  %274 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 21
  %275 = zext i32 %270 to i64
  br label %276

; <label>:276:                                    ; preds = %276, %273
  %277 = phi i64 [ 0, %273 ], [ %289, %276 ]
  %278 = load %struct.LocVar*, %struct.LocVar** %274, align 8, !tbaa !110
  %279 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %278, i64 %277, i32 0
  %280 = load %struct.TString*, %struct.TString** %279, align 8, !tbaa !114
  call fastcc void @DumpString(%struct.TString* %280, %struct.DumpState* %2) #17
  %281 = load %struct.LocVar*, %struct.LocVar** %274, align 8, !tbaa !110
  %282 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %281, i64 %277, i32 1
  %283 = load i32, i32* %282, align 8, !tbaa !111
  %284 = sext i32 %283 to i64
  call fastcc void @DumpSize(i64 %284, %struct.DumpState* %2) #17
  %285 = load %struct.LocVar*, %struct.LocVar** %274, align 8, !tbaa !110
  %286 = getelementptr inbounds %struct.LocVar, %struct.LocVar* %285, i64 %277, i32 2
  %287 = load i32, i32* %286, align 4, !tbaa !113
  %288 = sext i32 %287 to i64
  call fastcc void @DumpSize(i64 %288, %struct.DumpState* %2) #17
  %289 = add nuw nsw i64 %277, 1
  %290 = icmp eq i64 %289, %275
  br i1 %290, label %291, label %276

; <label>:291:                                    ; preds = %276, %268, %267
  %292 = load i32, i32* %13, align 8, !tbaa !188
  %293 = icmp eq i32 %292, 0
  br i1 %293, label %295, label %294

; <label>:294:                                    ; preds = %291
  call fastcc void @DumpSize(i64 0, %struct.DumpState* nonnull %2) #17
  br label %309

; <label>:295:                                    ; preds = %291
  %296 = load i32, i32* %161, align 8, !tbaa !190
  %297 = sext i32 %296 to i64
  call fastcc void @DumpSize(i64 %297, %struct.DumpState* nonnull %2) #17
  %298 = icmp sgt i32 %296, 0
  br i1 %298, label %299, label %309

; <label>:299:                                    ; preds = %295
  %300 = getelementptr inbounds %struct.Proto, %struct.Proto* %0, i64 0, i32 18
  %301 = zext i32 %296 to i64
  br label %302

; <label>:302:                                    ; preds = %302, %299
  %303 = phi i64 [ 0, %299 ], [ %307, %302 ]
  %304 = load %struct.Upvaldesc*, %struct.Upvaldesc** %300, align 8, !tbaa !198
  %305 = getelementptr inbounds %struct.Upvaldesc, %struct.Upvaldesc* %304, i64 %303, i32 0
  %306 = load %struct.TString*, %struct.TString** %305, align 8, !tbaa !199
  call fastcc void @DumpString(%struct.TString* %306, %struct.DumpState* %2) #17
  %307 = add nuw nsw i64 %303, 1
  %308 = icmp eq i64 %307, %301
  br i1 %308, label %309, label %302

; <label>:309:                                    ; preds = %302, %294, %295
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpSize(i64, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = alloca [10 x i8], align 1
  %4 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %4) #7
  br label %5

; <label>:5:                                      ; preds = %5, %2
  %6 = phi i64 [ %10, %5 ], [ 0, %2 ]
  %7 = phi i64 [ %13, %5 ], [ %0, %2 ]
  %8 = trunc i64 %7 to i8
  %9 = and i8 %8, 127
  %10 = add nuw nsw i64 %6, 1
  %11 = sub nsw i64 9, %6
  %12 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 %11
  store i8 %9, i8* %12, align 1, !tbaa !21
  %13 = lshr i64 %7, 7
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %15, label %5

; <label>:15:                                     ; preds = %5
  %16 = and i64 %10, 4294967295
  %17 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 9
  %18 = load i8, i8* %17, align 1, !tbaa !21
  %19 = or i8 %18, -128
  store i8 %19, i8* %17, align 1, !tbaa !21
  %20 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 4
  %21 = load i32, i32* %20, align 4, !tbaa !189
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %23, label %34

; <label>:23:                                     ; preds = %15
  %24 = getelementptr inbounds [10 x i8], [10 x i8]* %3, i64 0, i64 10
  %25 = sub nsw i64 0, %16
  %26 = getelementptr inbounds i8, i8* %24, i64 %25
  %27 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 1
  %28 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %27, align 8, !tbaa !186
  %29 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 0
  %30 = load %struct.lua_State*, %struct.lua_State** %29, align 8, !tbaa !184
  %31 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 2
  %32 = load i8*, i8** %31, align 8, !tbaa !187
  %33 = call i32 %28(%struct.lua_State* %30, i8* nonnull %26, i64 %16, i8* %32) #17
  store i32 %33, i32* %20, align 4, !tbaa !189
  br label %34

; <label>:34:                                     ; preds = %15, %23
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %4) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @DumpString(%struct.TString*, %struct.DumpState* nocapture) unnamed_addr #0 {
  %3 = icmp eq %struct.TString* %0, null
  br i1 %3, label %4, label %5

; <label>:4:                                      ; preds = %2
  tail call fastcc void @DumpSize(i64 0, %struct.DumpState* %1) #16
  br label %34

; <label>:5:                                      ; preds = %2
  %6 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !75
  %8 = icmp eq i8 %7, 20
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %5
  %10 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 4
  %11 = load i8, i8* %10, align 1, !tbaa !123
  %12 = zext i8 %11 to i64
  br label %16

; <label>:13:                                     ; preds = %5
  %14 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 0, i32 6, i32 0
  %15 = load i64, i64* %14, align 8, !tbaa !21
  br label %16

; <label>:16:                                     ; preds = %13, %9
  %17 = phi i64 [ %12, %9 ], [ %15, %13 ]
  %18 = add i64 %17, 1
  tail call fastcc void @DumpSize(i64 %18, %struct.DumpState* %1) #16
  %19 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 4
  %20 = load i32, i32* %19, align 4, !tbaa !189
  %21 = icmp eq i32 %20, 0
  %22 = icmp ne i64 %17, 0
  %23 = and i1 %22, %21
  br i1 %23, label %24, label %34

; <label>:24:                                     ; preds = %16
  %25 = getelementptr inbounds %struct.TString, %struct.TString* %0, i64 1
  %26 = bitcast %struct.TString* %25 to i8*
  %27 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 1
  %28 = load i32 (%struct.lua_State*, i8*, i64, i8*)*, i32 (%struct.lua_State*, i8*, i64, i8*)** %27, align 8, !tbaa !186
  %29 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 0
  %30 = load %struct.lua_State*, %struct.lua_State** %29, align 8, !tbaa !184
  %31 = getelementptr inbounds %struct.DumpState, %struct.DumpState* %1, i64 0, i32 2
  %32 = load i8*, i8** %31, align 8, !tbaa !187
  %33 = tail call i32 %28(%struct.lua_State* %30, i8* nonnull %26, i64 %17, i8* %32) #17
  store i32 %33, i32* %19, align 4, !tbaa !189
  br label %34

; <label>:34:                                     ; preds = %24, %16, %4
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal void @trynewtbcupval(%struct.lua_State*, i8*) #0 {
  %3 = bitcast i8* %1 to %union.StackValue*
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 12
  %5 = tail call fastcc %struct.UpVal* @newupval(%struct.lua_State* %0, i32 25, %union.StackValue* %3, %struct.UpVal** nonnull %4) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @findfield(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %49, label %5

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 -1, i32 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !22
  %10 = and i8 %9, 15
  %11 = icmp eq i8 %10, 5
  br i1 %11, label %12, label %49

; <label>:12:                                     ; preds = %5
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0, i32 1
  store i8 0, i8* %13, align 8, !tbaa !21
  %14 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %6, align 8, !tbaa !20
  %16 = tail call i32 @lua_next(%struct.lua_State* nonnull %0, i32 -2) #16
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %49, label %18

; <label>:18:                                     ; preds = %12
  %19 = add nsw i32 %2, -1
  br label %20

; <label>:20:                                     ; preds = %18, %43
  %21 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 -2, i32 0, i32 1
  %23 = load i8, i8* %22, align 8, !tbaa !22
  %24 = and i8 %23, 15
  %25 = icmp eq i8 %24, 4
  br i1 %25, label %26, label %43

; <label>:26:                                     ; preds = %20
  %27 = tail call i32 @lua_rawequal(%struct.lua_State* nonnull %0, i32 %1, i32 -1) #16
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %33, label %29

; <label>:29:                                     ; preds = %26
  %30 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1
  store %union.StackValue* %31, %union.StackValue** %6, align 8, !tbaa !20
  %32 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %31, i32 0) #17
  br label %49

; <label>:33:                                     ; preds = %26
  %34 = tail call fastcc i32 @findfield(%struct.lua_State* nonnull %0, i32 %1, i32 %19) #16
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %38

; <label>:36:                                     ; preds = %33
  %37 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  br label %43

; <label>:38:                                     ; preds = %33
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 -1) #16
  %39 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1
  store %union.StackValue* %40, %union.StackValue** %6, align 8, !tbaa !20
  %41 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %40, i32 0) #17
  %42 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0)) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  tail call void @lua_concat(%struct.lua_State* nonnull %0, i32 3) #16
  br label %49

; <label>:43:                                     ; preds = %36, %20
  %44 = phi %union.StackValue* [ %37, %36 ], [ %21, %20 ]
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 -1
  store %union.StackValue* %45, %union.StackValue** %6, align 8, !tbaa !20
  %46 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %45, i32 0) #17
  %47 = tail call i32 @lua_next(%struct.lua_State* nonnull %0, i32 -2) #16
  %48 = icmp eq i32 %47, 0
  br i1 %48, label %49, label %20

; <label>:49:                                     ; preds = %43, %12, %5, %3, %38, %29
  %50 = phi i32 [ 1, %29 ], [ 1, %38 ], [ 0, %3 ], [ 0, %5 ], [ 0, %12 ], [ 0, %43 ]
  ret i32 %50
}

; Function Attrs: nounwind optsize readonly
declare i32 @strncmp(i8* nocapture, i8* nocapture, i64) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @resizebox(%struct.lua_State*, i32, i64) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %5 = load %struct.global_State*, %struct.global_State** %4, align 8, !tbaa !2
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 1
  %7 = load i8*, i8** %6, align 8, !tbaa !60
  %8 = getelementptr inbounds %struct.global_State, %struct.global_State* %5, i64 0, i32 0
  %9 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %8, align 8, !tbaa !59
  %10 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 %1) #16
  %11 = bitcast i8* %10 to i8**
  %12 = load i8*, i8** %11, align 8, !tbaa !332
  %13 = getelementptr inbounds i8, i8* %10, i64 8
  %14 = bitcast i8* %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !334
  %16 = tail call i8* %9(i8* %7, i8* %12, i64 %15, i64 %2) #17
  %17 = icmp eq i8* %16, null
  %18 = icmp ne i64 %2, 0
  %19 = and i1 %18, %17
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %3
  %21 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.293, i64 0, i64 0)) #16
  unreachable

; <label>:22:                                     ; preds = %3
  store i8* %16, i8** %11, align 8, !tbaa !332
  store i64 %2, i64* %14, align 8, !tbaa !334
  ret i8* %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @boxgc(%struct.lua_State* nocapture readonly) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %3 = load %struct.global_State*, %struct.global_State** %2, align 8, !tbaa !2
  %4 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 1
  %5 = load i8*, i8** %4, align 8, !tbaa !60
  %6 = getelementptr inbounds %struct.global_State, %struct.global_State* %3, i64 0, i32 0
  %7 = load i8* (i8*, i8*, i64, i64)*, i8* (i8*, i8*, i64, i64)** %6, align 8, !tbaa !59
  %8 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 1) #17
  %9 = bitcast i8* %8 to i8**
  %10 = load i8*, i8** %9, align 8, !tbaa !332
  %11 = getelementptr inbounds i8, i8* %8, i64 8
  %12 = bitcast i8* %11 to i64*
  %13 = load i64, i64* %12, align 8, !tbaa !334
  %14 = tail call i8* %7(i8* %5, i8* %10, i64 %13, i64 0) #17
  store i8* %14, i8** %9, align 8, !tbaa !332
  store i64 0, i64* %12, align 8, !tbaa !334
  ret i32 0
}

; Function Attrs: nounwind optsize
declare i32 @_IO_getc(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i32 @feof(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i64 @fread(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare void @free(i8* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i32 @fprintf(%struct._IO_FILE* nocapture, i8* nocapture readonly, ...) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i32 @fflush(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_assert(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  %10 = ptrtoint %union.StackValue* %8 to i64
  br i1 %9, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %29, label %23

; <label>:23:                                     ; preds = %17
  %24 = icmp eq i8 %20, 1
  br i1 %24, label %25, label %32

; <label>:25:                                     ; preds = %23
  %26 = bitcast %struct.TValue* %18 to i32*
  %27 = load i32, i32* %26, align 8, !tbaa !21
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %17, %25
  tail call void @luaL_checkany(%struct.lua_State* nonnull %0, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 1, i32 -1) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #16
  %30 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.324, i64 0, i64 0)) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  %31 = tail call i32 @luaB_error(%struct.lua_State* nonnull %0) #16
  unreachable

; <label>:32:                                     ; preds = %23, %25
  %33 = ptrtoint %union.StackValue* %6 to i64
  %34 = sub i64 %10, %33
  %35 = lshr exact i64 %34, 4
  %36 = trunc i64 %35 to i32
  ret i32 %36
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_collectgarbage(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.327, i64 0, i64 0), i8** getelementptr inbounds ([11 x i8*], [11 x i8*]* @luaB_collectgarbage.opts, i64 0, i64 0)) #16
  %3 = sext i32 %2 to i64
  %4 = getelementptr inbounds [10 x i32], [10 x i32]* @luaB_collectgarbage.optsnum, i64 0, i64 %3
  %5 = load i32, i32* %4, align 4, !tbaa !77
  switch i32 %5, label %76 [
    i32 3, label %6
    i32 5, label %20
    i32 6, label %33
    i32 7, label %33
    i32 9, label %45
    i32 10, label %56
    i32 11, label %65
  ]

; <label>:6:                                      ; preds = %1
  %7 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 3) #16
  %8 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 4) #16
  %9 = sitofp i32 %7 to double
  %10 = sitofp i32 %8 to double
  %11 = fmul double %10, 0x3F50000000000000
  %12 = fadd double %11, %9
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = bitcast %struct.TValue* %15 to double*
  store double %12, double* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 19, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %13, align 8, !tbaa !20
  br label %86

; <label>:20:                                     ; preds = %1
  %21 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %22 = trunc i64 %21 to i32
  %23 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 5, i32 %22) #16
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %25 = bitcast %union.StackValue** %24 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %27 = icmp ne i32 %23, 0
  %28 = zext i1 %27 to i32
  %29 = bitcast %struct.TValue* %26 to i32*
  store i32 %28, i32* %29, align 8, !tbaa !21
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 1, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %24, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %24, align 8, !tbaa !20
  br label %86

; <label>:33:                                     ; preds = %1, %1
  %34 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %35 = trunc i64 %34 to i32
  %36 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5, i32 %35) #16
  %37 = sext i32 %36 to i64
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %39 = bitcast %union.StackValue** %38 to %struct.TValue**
  %40 = load %struct.TValue*, %struct.TValue** %39, align 8, !tbaa !20
  %41 = bitcast %struct.TValue* %40 to i64*
  store i64 %37, i64* %41, align 8, !tbaa !21
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  store i8 35, i8* %42, align 8, !tbaa !22
  %43 = load %union.StackValue*, %union.StackValue** %38, align 8, !tbaa !20
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 1
  store %union.StackValue* %44, %union.StackValue** %38, align 8, !tbaa !20
  br label %86

; <label>:45:                                     ; preds = %1
  %46 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 9) #16
  %47 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %48 = bitcast %union.StackValue** %47 to %struct.TValue**
  %49 = load %struct.TValue*, %struct.TValue** %48, align 8, !tbaa !20
  %50 = icmp ne i32 %46, 0
  %51 = zext i1 %50 to i32
  %52 = bitcast %struct.TValue* %49 to i32*
  store i32 %51, i32* %52, align 8, !tbaa !21
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 0, i32 1
  store i8 1, i8* %53, align 8, !tbaa !22
  %54 = load %union.StackValue*, %union.StackValue** %47, align 8, !tbaa !20
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 1
  store %union.StackValue* %55, %union.StackValue** %47, align 8, !tbaa !20
  br label %86

; <label>:56:                                     ; preds = %1
  %57 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %58 = trunc i64 %57 to i32
  %59 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %60 = trunc i64 %59 to i32
  %61 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 10, i32 %58, i32 %60) #16
  %62 = icmp eq i32 %61, 11
  %63 = select i1 %62, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i64 0, i64 0)
  %64 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %63) #17
  br label %86

; <label>:65:                                     ; preds = %1
  %66 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 0) #16
  %67 = trunc i64 %66 to i32
  %68 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %69 = trunc i64 %68 to i32
  %70 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 0) #16
  %71 = trunc i64 %70 to i32
  %72 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 11, i32 %67, i32 %69, i32 %71) #16
  %73 = icmp eq i32 %72, 11
  %74 = select i1 %73, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.333, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.332, i64 0, i64 0)
  %75 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %74) #17
  br label %86

; <label>:76:                                     ; preds = %1
  %77 = tail call i32 (%struct.lua_State*, i32, ...) @lua_gc(%struct.lua_State* %0, i32 %5) #16
  %78 = sext i32 %77 to i64
  %79 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %80 = bitcast %union.StackValue** %79 to %struct.TValue**
  %81 = load %struct.TValue*, %struct.TValue** %80, align 8, !tbaa !20
  %82 = bitcast %struct.TValue* %81 to i64*
  store i64 %78, i64* %82, align 8, !tbaa !21
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %81, i64 0, i32 1
  store i8 35, i8* %83, align 8, !tbaa !22
  %84 = load %union.StackValue*, %union.StackValue** %79, align 8, !tbaa !20
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 1
  store %union.StackValue* %85, %union.StackValue** %79, align 8, !tbaa !20
  br label %86

; <label>:86:                                     ; preds = %76, %65, %56, %45, %33, %20, %6
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_dofile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* %2, i8* null) #16
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @lua_error(%struct.lua_State* %0) #16
  unreachable

; <label>:7:                                      ; preds = %1
  tail call void @lua_callk(%struct.lua_State* %0, i32 0, i32 -1, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @dofilecont) #16
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, -1
  ret i32 %20
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal i32 @luaB_error(%struct.lua_State*) #5 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = trunc i64 %2 to i32
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %53, label %24

; <label>:24:                                     ; preds = %18
  %25 = icmp eq i8 %22, 4
  %26 = icmp sgt i32 %3, 0
  %27 = and i1 %26, %25
  br i1 %27, label %28, label %53

; <label>:28:                                     ; preds = %24
  tail call void @luaL_where(%struct.lua_State* nonnull %0, i32 %3) #16
  %29 = bitcast %union.StackValue** %9 to %struct.TValue**
  %30 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !20
  %31 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 0
  %33 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !64
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1
  %35 = bitcast %struct.TValue* %30 to %union.StackValue*
  %36 = icmp ult %union.StackValue* %34, %35
  br i1 %36, label %41, label %37

; <label>:37:                                     ; preds = %28
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %39 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %40 = getelementptr inbounds %struct.global_State, %struct.global_State* %39, i64 0, i32 8
  br label %43

; <label>:41:                                     ; preds = %28
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 0, i32 0
  br label %43

; <label>:43:                                     ; preds = %37, %41
  %44 = phi %struct.TValue* [ %40, %37 ], [ %42, %41 ]
  %45 = bitcast %struct.TValue* %44 to i64*
  %46 = bitcast %struct.TValue* %30 to i64*
  %47 = load i64, i64* %45, align 8
  store i64 %47, i64* %46, align 8
  %48 = getelementptr inbounds %struct.TValue, %struct.TValue* %44, i64 0, i32 1
  %49 = load i8, i8* %48, align 8, !tbaa !22
  %50 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  store i8 %49, i8* %50, align 8, !tbaa !22
  %51 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %52 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 1
  store %union.StackValue* %52, %union.StackValue** %9, align 8, !tbaa !20
  tail call void @lua_concat(%struct.lua_State* nonnull %0, i32 2) #16
  br label %53

; <label>:53:                                     ; preds = %18, %43, %24
  %54 = tail call i32 @lua_error(%struct.lua_State* nonnull %0) #16
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %13

; <label>:11:                                     ; preds = %1
  %12 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0)) #16
  br label %13

; <label>:13:                                     ; preds = %11, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_ipairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @ipairsaux, i32 (%struct.lua_State*)** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 38, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !24
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %10, i64 0, i32 0
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !64
  %13 = icmp ult %union.StackValue* %12, %7
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  br label %20

; <label>:18:                                     ; preds = %1
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 1, i32 0
  br label %20

; <label>:20:                                     ; preds = %14, %18
  %21 = phi %struct.TValue* [ %17, %14 ], [ %19, %18 ]
  %22 = bitcast %struct.TValue* %21 to i64*
  %23 = bitcast %union.StackValue* %8 to i64*
  %24 = load i64, i64* %22, align 8
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1, i32 0, i32 1
  store i8 %26, i8* %27, align 8, !tbaa !22
  %28 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  store %union.StackValue* %29, %union.StackValue** %2, align 8, !tbaa !20
  %30 = bitcast %union.StackValue* %29 to i64*
  store i64 0, i64* %30, align 8, !tbaa !21
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1, i32 0, i32 1
  store i8 35, i8* %31, align 8, !tbaa !22
  %32 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 1
  store %union.StackValue* %33, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_loadfile(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* null, i64* null) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 3
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %30

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  %28 = icmp eq %struct.TValue* %19, %27
  %29 = select i1 %28, i32 0, i32 3
  br label %30

; <label>:30:                                     ; preds = %24, %18
  %31 = phi i32 [ 3, %18 ], [ %29, %24 ]
  %32 = tail call i32 @luaL_loadfilex(%struct.lua_State* nonnull %0, i8* %2, i8* %3) #16
  %33 = tail call fastcc i32 @load_aux(%struct.lua_State* nonnull %0, i32 %32, i32 %31) #16
  ret i32 %33
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_load(%struct.lua_State*) #0 {
  %2 = alloca %struct.LoadS, align 8
  %3 = alloca i64, align 8
  %4 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %6 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.335, i64 0, i64 0), i64* null) #16
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 4
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %14 = icmp ult %union.StackValue* %11, %13
  br i1 %14, label %19, label %15

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %17 = load %struct.global_State*, %struct.global_State** %16, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 8
  br label %21

; <label>:19:                                     ; preds = %1
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 0, i32 0
  br label %21

; <label>:21:                                     ; preds = %15, %19
  %22 = phi %struct.TValue* [ %18, %15 ], [ %20, %19 ]
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %22, i64 0, i32 1
  %24 = load i8, i8* %23, align 8, !tbaa !22
  %25 = and i8 %24, 15
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %27, label %33

; <label>:27:                                     ; preds = %21
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %29 = load %struct.global_State*, %struct.global_State** %28, align 8, !tbaa !2
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %29, i64 0, i32 8
  %31 = icmp eq %struct.TValue* %22, %30
  %32 = select i1 %31, i32 0, i32 4
  br label %33

; <label>:33:                                     ; preds = %27, %21
  %34 = phi i32 [ 4, %21 ], [ %32, %27 ]
  %35 = icmp eq i8* %5, null
  br i1 %35, label %43, label %36

; <label>:36:                                     ; preds = %33
  %37 = call i8* @luaL_optlstring(%struct.lua_State* nonnull %0, i32 2, i8* nonnull %5, i64* null) #16
  %38 = load i64, i64* %3, align 8, !tbaa !82
  %39 = bitcast %struct.LoadS* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %39) #7
  %40 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %2, i64 0, i32 0
  store i8* %5, i8** %40, align 8, !tbaa !211
  %41 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %2, i64 0, i32 1
  store i64 %38, i64* %41, align 8, !tbaa !213
  %42 = call i32 @lua_load(%struct.lua_State* nonnull %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %39, i8* %37, i8* %6) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %39) #7
  br label %46

; <label>:43:                                     ; preds = %33
  %44 = call i8* @luaL_optlstring(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.336, i64 0, i64 0), i64* null) #16
  call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 6) #16
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 5) #16
  %45 = call i32 @lua_load(%struct.lua_State* nonnull %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @generic_reader, i8* null, i8* %44, i8* %6) #16
  br label %46

; <label>:46:                                     ; preds = %43, %36
  %47 = phi i32 [ %42, %36 ], [ %45, %43 ]
  %48 = call fastcc i32 @load_aux(%struct.lua_State* nonnull %0, i32 %47, i32 %34) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %48
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_next(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_next(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %1, %4
  %12 = phi i32 [ 1, %4 ], [ 2, %1 ]
  ret i32 %12
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_pairs(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @luaL_getmetafield(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.339, i64 0, i64 0)) #16
  %3 = icmp eq i32 %2, 0
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  br i1 %3, label %7, label %36

; <label>:7:                                      ; preds = %1
  %8 = bitcast %struct.TValue* %6 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @luaB_next, i32 (%struct.lua_State*)** %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 38, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %4, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %13 = load %struct.CallInfo*, %struct.CallInfo** %12, align 8, !tbaa !24
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %13, i64 0, i32 0
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !64
  %16 = icmp ult %union.StackValue* %15, %10
  br i1 %16, label %21, label %17

; <label>:17:                                     ; preds = %7
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %19 = load %struct.global_State*, %struct.global_State** %18, align 8, !tbaa !2
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %19, i64 0, i32 8
  br label %23

; <label>:21:                                     ; preds = %7
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1, i32 0
  br label %23

; <label>:23:                                     ; preds = %17, %21
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = bitcast %struct.TValue* %24 to i64*
  %26 = bitcast %union.StackValue* %11 to i64*
  %27 = load i64, i64* %25, align 8
  store i64 %27, i64* %26, align 8
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1, i32 0, i32 1
  store i8 %29, i8* %30, align 8, !tbaa !22
  %31 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %4, align 8, !tbaa !20
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1, i32 0, i32 1
  store i8 0, i8* %33, align 8, !tbaa !21
  %34 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %4, align 8, !tbaa !20
  br label %61

; <label>:36:                                     ; preds = %1
  %37 = bitcast %struct.TValue* %6 to %union.StackValue*
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %39 = load %struct.CallInfo*, %struct.CallInfo** %38, align 8, !tbaa !24
  %40 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %39, i64 0, i32 0
  %41 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !64
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  %43 = icmp ult %union.StackValue* %42, %37
  br i1 %43, label %48, label %44

; <label>:44:                                     ; preds = %36
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %46 = load %struct.global_State*, %struct.global_State** %45, align 8, !tbaa !2
  %47 = getelementptr inbounds %struct.global_State, %struct.global_State* %46, i64 0, i32 8
  br label %50

; <label>:48:                                     ; preds = %36
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 0, i32 0
  br label %50

; <label>:50:                                     ; preds = %44, %48
  %51 = phi %struct.TValue* [ %47, %44 ], [ %49, %48 ]
  %52 = bitcast %struct.TValue* %51 to i64*
  %53 = bitcast %struct.TValue* %6 to i64*
  %54 = load i64, i64* %52, align 8
  store i64 %54, i64* %53, align 8
  %55 = getelementptr inbounds %struct.TValue, %struct.TValue* %51, i64 0, i32 1
  %56 = load i8, i8* %55, align 8, !tbaa !22
  %57 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 %56, i8* %57, align 8, !tbaa !22
  %58 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 1
  store %union.StackValue* %59, %union.StackValue** %4, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 -1
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %60, i32 3) #17
  br label %61

; <label>:61:                                     ; preds = %50, %23
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_pcall(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to i32*
  store i32 1, i32* %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 1, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1) #16
  %9 = bitcast %union.StackValue** %2 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = add nsw i32 %19, -2
  %21 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %20, i32 -1, i32 0, i64 0, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall) #16
  %22 = icmp ugt i32 %21, 1
  br i1 %22, label %23, label %38

; <label>:23:                                     ; preds = %1
  %24 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %25 = bitcast %struct.TValue* %24 to i32*
  store i32 0, i32* %25, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  store i8 1, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %2, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0
  %30 = bitcast %struct.TValue* %29 to i64*
  %31 = bitcast %union.StackValue* %28 to i64*
  %32 = load i64, i64* %30, align 8
  store i64 %32, i64* %31, align 8
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1, i32 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1, i32 0, i32 1
  store i8 %34, i8* %35, align 8, !tbaa !22
  %36 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 1
  store %union.StackValue* %37, %union.StackValue** %2, align 8, !tbaa !20
  br label %48

; <label>:38:                                     ; preds = %1
  %39 = load i64, i64* %9, align 8, !tbaa !20
  %40 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %41 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %40, i64 0, i32 0
  %42 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !64
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 1
  %44 = ptrtoint %union.StackValue* %43 to i64
  %45 = sub i64 %39, %44
  %46 = lshr exact i64 %45, 4
  %47 = trunc i64 %46 to i32
  br label %48

; <label>:48:                                     ; preds = %23, %38
  %49 = phi i32 [ 2, %23 ], [ %47, %38 ]
  ret i32 %49
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_print(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = icmp slt i32 %14, 1
  br i1 %15, label %34, label %16

; <label>:16:                                     ; preds = %1
  %17 = bitcast i64* %2 to i8*
  br label %18

; <label>:18:                                     ; preds = %25, %16
  %19 = phi i32 [ 1, %16 ], [ %32, %25 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %17) #7
  %20 = call i8* @luaL_tolstring(%struct.lua_State* nonnull %0, i32 %19, i64* nonnull %2) #16
  %21 = icmp ugt i32 %19, 1
  br i1 %21, label %22, label %25

; <label>:22:                                     ; preds = %18
  %23 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %24 = call i32 @fputc(i32 9, %struct._IO_FILE* %23)
  br label %25

; <label>:25:                                     ; preds = %22, %18
  %26 = load i64, i64* %2, align 8, !tbaa !82
  %27 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %28 = call i64 @fwrite(i8* %20, i64 1, i64 %26, %struct._IO_FILE* %27) #16
  %29 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1
  store %union.StackValue* %30, %union.StackValue** %3, align 8, !tbaa !20
  %31 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %30, i32 0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %17) #7
  %32 = add nuw nsw i32 %19, 1
  %33 = icmp eq i32 %19, %14
  br i1 %33, label %34, label %18

; <label>:34:                                     ; preds = %25, %1
  %35 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %36 = call i32 @fputc(i32 10, %struct._IO_FILE* %35)
  %37 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %38 = call i32 @fflush(%struct._IO_FILE* %37) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_warn(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %30, label %23

; <label>:23:                                     ; preds = %17
  %24 = icmp eq i8 %20, 1
  br i1 %24, label %25, label %30

; <label>:25:                                     ; preds = %23
  %26 = bitcast %struct.TValue* %18 to i32*
  %27 = load i32, i32* %26, align 8, !tbaa !21
  %28 = icmp ne i32 %27, 0
  %29 = zext i1 %28 to i32
  br label %30

; <label>:30:                                     ; preds = %17, %23, %25
  %31 = phi i32 [ 0, %17 ], [ 1, %23 ], [ %29, %25 ]
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %33 = load %struct.global_State*, %struct.global_State** %32, align 8, !tbaa !2
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 43
  %35 = load void (i8*, i8*, i32)*, void (i8*, i8*, i32)** %34, align 8, !tbaa !192
  %36 = icmp eq void (i8*, i8*, i32)* %35, null
  br i1 %36, label %40, label %37

; <label>:37:                                     ; preds = %30
  %38 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 44
  %39 = load i8*, i8** %38, align 8, !tbaa !191
  tail call void %35(i8* %39, i8* %2, i32 %31) #17
  br label %40

; <label>:40:                                     ; preds = %30, %37
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawequal(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_rawequal(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = icmp ne i32 %2, 0
  %7 = zext i1 %6 to i32
  %8 = bitcast %struct.TValue* %5 to i32*
  store i32 %7, i32* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 1, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %3, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawlen(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp ne i8 %20, 0
  %22 = or i8 %20, 1
  %23 = icmp eq i8 %22, 5
  %24 = and i1 %21, %23
  br i1 %24, label %27, label %25

; <label>:25:                                     ; preds = %16
  %26 = tail call i32 @luaL_typeerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.341, i64 0, i64 0)) #16
  br label %27

; <label>:27:                                     ; preds = %16, %25
  %28 = tail call i64 @lua_rawlen(%struct.lua_State* nonnull %0, i32 1) #16
  %29 = bitcast %union.StackValue** %7 to %struct.TValue**
  %30 = load %struct.TValue*, %struct.TValue** %29, align 8, !tbaa !20
  %31 = bitcast %struct.TValue* %30 to i64*
  store i64 %28, i64* %31, align 8, !tbaa !21
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  store i8 35, i8* %32, align 8, !tbaa !22
  %33 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1
  store %union.StackValue* %34, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawget(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %2 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_rawset(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 5) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 3) #16
  tail call void @lua_rawset(%struct.lua_State* %0, i32 1) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_select(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = inttoptr i64 %4 to %union.StackValue*
  %15 = icmp ult %union.StackValue* %9, %14
  br i1 %15, label %20, label %16

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %18 = load %struct.global_State*, %struct.global_State** %17, align 8, !tbaa !2
  %19 = getelementptr inbounds %struct.global_State, %struct.global_State* %18, i64 0, i32 8
  br label %22

; <label>:20:                                     ; preds = %1
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0
  br label %22

; <label>:22:                                     ; preds = %16, %20
  %23 = phi %struct.TValue* [ %19, %16 ], [ %21, %20 ]
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = and i8 %25, 15
  %27 = icmp eq i8 %26, 4
  br i1 %27, label %28, label %42

; <label>:28:                                     ; preds = %22
  %29 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  %30 = load i8, i8* %29, align 1, !tbaa !21
  %31 = icmp eq i8 %30, 35
  br i1 %31, label %32, label %42

; <label>:32:                                     ; preds = %28
  %33 = shl i64 %11, 28
  %34 = add i64 %33, -4294967296
  %35 = ashr exact i64 %34, 32
  %36 = bitcast %union.StackValue** %2 to %struct.TValue**
  %37 = load %struct.TValue*, %struct.TValue** %36, align 8, !tbaa !20
  %38 = bitcast %struct.TValue* %37 to i64*
  store i64 %35, i64* %38, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %37, i64 0, i32 1
  store i8 35, i8* %39, align 8, !tbaa !22
  %40 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %2, align 8, !tbaa !20
  br label %57

; <label>:42:                                     ; preds = %22, %28
  %43 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %44 = icmp slt i64 %43, 0
  %45 = shl i64 %11, 28
  %46 = ashr exact i64 %45, 32
  %47 = add nsw i64 %43, %46
  %48 = icmp sgt i64 %43, %46
  %49 = select i1 %48, i64 %46, i64 %43
  %50 = select i1 %44, i64 %47, i64 %49
  %51 = icmp sgt i64 %50, 0
  br i1 %51, label %54, label %52

; <label>:52:                                     ; preds = %42
  %53 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.342, i64 0, i64 0)) #16
  br label %54

; <label>:54:                                     ; preds = %52, %42
  %55 = trunc i64 %50 to i32
  %56 = sub nsw i32 %13, %55
  br label %57

; <label>:57:                                     ; preds = %54, %32
  %58 = phi i32 [ 1, %32 ], [ %56, %54 ]
  ret i32 %58
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_setmetatable(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %28

; <label>:22:                                     ; preds = %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 8
  %26 = icmp eq %struct.TValue* %17, %25
  br i1 %26, label %27, label %28

; <label>:27:                                     ; preds = %22
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 5) #16
  br label %30

; <label>:28:                                     ; preds = %16, %22
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 5) #16
  %29 = trunc i8 %19 to i4
  switch i4 %29, label %30 [
    i4 5, label %32
    i4 0, label %32
  ]

; <label>:30:                                     ; preds = %27, %28
  %31 = tail call i32 @luaL_typeerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0)) #16
  br label %32

; <label>:32:                                     ; preds = %28, %28, %30
  %33 = tail call i32 @luaL_getmetafield(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.334, i64 0, i64 0)) #16
  %34 = icmp eq i32 %33, 0
  br i1 %34, label %37, label %35

; <label>:35:                                     ; preds = %32
  %36 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.344, i64 0, i64 0)) #16
  unreachable

; <label>:37:                                     ; preds = %32
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 2) #16
  %38 = tail call i32 @lua_setmetatable(%struct.lua_State* nonnull %0, i32 1) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_tonumber(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %58

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  %26 = icmp ult %union.StackValue* %25, %10
  br i1 %26, label %31, label %27

; <label>:27:                                     ; preds = %24
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %29 = load %struct.global_State*, %struct.global_State** %28, align 8, !tbaa !2
  %30 = getelementptr inbounds %struct.global_State, %struct.global_State* %29, i64 0, i32 8
  br label %33

; <label>:31:                                     ; preds = %24
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 0, i32 0
  br label %33

; <label>:33:                                     ; preds = %27, %31
  %34 = phi %struct.TValue* [ %30, %27 ], [ %32, %31 ]
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %34, i64 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  %37 = and i8 %36, 15
  %38 = icmp eq i8 %37, 3
  br i1 %38, label %39, label %40

; <label>:39:                                     ; preds = %33
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  br label %146

; <label>:40:                                     ; preds = %33
  %41 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %41) #7
  %42 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* nonnull %2) #16
  %43 = icmp eq i8* %42, null
  br i1 %43, label %56, label %44

; <label>:44:                                     ; preds = %40
  %45 = bitcast %union.StackValue** %9 to %struct.TValue**
  %46 = load %struct.TValue*, %struct.TValue** %45, align 8, !tbaa !20
  %47 = call fastcc i64 @luaO_str2num(i8* nonnull %42, %struct.TValue* %46) #17
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %52, label %49

; <label>:49:                                     ; preds = %44
  %50 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %50, i64 1
  store %union.StackValue* %51, %union.StackValue** %9, align 8, !tbaa !20
  br label %52

; <label>:52:                                     ; preds = %44, %49
  %53 = load i64, i64* %2, align 8, !tbaa !82
  %54 = add i64 %53, 1
  %55 = icmp eq i64 %47, %54
  br i1 %55, label %57, label %56

; <label>:56:                                     ; preds = %40, %52
  call void @luaL_checkany(%struct.lua_State* nonnull %0, i32 1) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %41) #7
  br label %140

; <label>:57:                                     ; preds = %52
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %41) #7
  br label %146

; <label>:58:                                     ; preds = %18
  %59 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %59) #7
  %60 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #16
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 4) #16
  %61 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* nonnull %3) #16
  %62 = add i64 %60, -2
  %63 = icmp ult i64 %62, 35
  br i1 %63, label %66, label %64

; <label>:64:                                     ; preds = %58
  %65 = call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.345, i64 0, i64 0)) #16
  br label %66

; <label>:66:                                     ; preds = %58, %64
  %67 = trunc i64 %60 to i32
  %68 = call i64 @strspn(i8* %61, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #21
  %69 = getelementptr inbounds i8, i8* %61, i64 %68
  %70 = load i8, i8* %69, align 1, !tbaa !21
  switch i8 %70, label %75 [
    i8 45, label %71
    i8 43, label %73
  ]

; <label>:71:                                     ; preds = %66
  %72 = getelementptr inbounds i8, i8* %69, i64 1
  br label %75

; <label>:73:                                     ; preds = %66
  %74 = getelementptr inbounds i8, i8* %69, i64 1
  br label %75

; <label>:75:                                     ; preds = %73, %71, %66
  %76 = phi i32 [ 1, %71 ], [ 0, %73 ], [ 0, %66 ]
  %77 = phi i8* [ %72, %71 ], [ %74, %73 ], [ %69, %66 ]
  %78 = tail call i16** @__ctype_b_loc() #22
  %79 = load i16*, i16** %78, align 8, !tbaa !54
  %80 = load i8, i8* %77, align 1, !tbaa !21
  %81 = zext i8 %80 to i64
  %82 = getelementptr inbounds i16, i16* %79, i64 %81
  %83 = load i16, i16* %82, align 2, !tbaa !324
  %84 = and i16 %83, 8
  %85 = icmp eq i16 %84, 0
  br i1 %85, label %126, label %86

; <label>:86:                                     ; preds = %75
  %87 = shl i64 %60, 32
  %88 = ashr exact i64 %87, 32
  br label %89

; <label>:89:                                     ; preds = %109, %86
  %90 = phi i16 [ %83, %86 ], [ %117, %109 ]
  %91 = phi i8 [ %80, %86 ], [ %114, %109 ]
  %92 = phi i64 [ 0, %86 ], [ %112, %109 ]
  %93 = phi i8* [ %77, %86 ], [ %113, %109 ]
  %94 = and i16 %90, 2048
  %95 = icmp eq i16 %94, 0
  br i1 %95, label %99, label %96

; <label>:96:                                     ; preds = %89
  %97 = sext i8 %91 to i32
  %98 = add nsw i32 %97, -48
  br label %106

; <label>:99:                                     ; preds = %89
  %100 = zext i8 %91 to i64
  %101 = tail call i32** @__ctype_toupper_loc() #22
  %102 = load i32*, i32** %101, align 8, !tbaa !54
  %103 = getelementptr inbounds i32, i32* %102, i64 %100
  %104 = load i32, i32* %103, align 4, !tbaa !77
  %105 = add nsw i32 %104, -55
  br label %106

; <label>:106:                                    ; preds = %99, %96
  %107 = phi i32 [ %98, %96 ], [ %105, %99 ]
  %108 = icmp slt i32 %107, %67
  br i1 %108, label %109, label %126

; <label>:109:                                    ; preds = %106
  %110 = mul i64 %92, %88
  %111 = sext i32 %107 to i64
  %112 = add i64 %110, %111
  %113 = getelementptr inbounds i8, i8* %93, i64 1
  %114 = load i8, i8* %113, align 1, !tbaa !21
  %115 = zext i8 %114 to i64
  %116 = getelementptr inbounds i16, i16* %79, i64 %115
  %117 = load i16, i16* %116, align 2, !tbaa !324
  %118 = and i16 %117, 8
  %119 = icmp eq i16 %118, 0
  br i1 %119, label %120, label %89

; <label>:120:                                    ; preds = %109
  %121 = call i64 @strspn(i8* nonnull %113, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.346, i64 0, i64 0)) #21
  %122 = getelementptr inbounds i8, i8* %113, i64 %121
  %123 = icmp eq i32 %76, 0
  %124 = sub i64 0, %112
  %125 = select i1 %123, i64 %112, i64 %124
  br label %126

; <label>:126:                                    ; preds = %106, %75, %120
  %127 = phi i64 [ 0, %75 ], [ %125, %120 ], [ 0, %106 ]
  %128 = phi i8* [ null, %75 ], [ %122, %120 ], [ null, %106 ]
  %129 = load i64, i64* %3, align 8, !tbaa !82
  %130 = getelementptr inbounds i8, i8* %61, i64 %129
  %131 = icmp eq i8* %128, %130
  br i1 %131, label %132, label %139

; <label>:132:                                    ; preds = %126
  %133 = bitcast %union.StackValue** %9 to %struct.TValue**
  %134 = load %struct.TValue*, %struct.TValue** %133, align 8, !tbaa !20
  %135 = bitcast %struct.TValue* %134 to i64*
  store i64 %127, i64* %135, align 8, !tbaa !21
  %136 = getelementptr inbounds %struct.TValue, %struct.TValue* %134, i64 0, i32 1
  store i8 35, i8* %136, align 8, !tbaa !22
  %137 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %138 = getelementptr inbounds %union.StackValue, %union.StackValue* %137, i64 1
  store %union.StackValue* %138, %union.StackValue** %9, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %59) #7
  br label %146

; <label>:139:                                    ; preds = %126
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %59) #7
  br label %140

; <label>:140:                                    ; preds = %139, %56
  %141 = bitcast %union.StackValue** %9 to %struct.TValue**
  %142 = load %struct.TValue*, %struct.TValue** %141, align 8, !tbaa !20
  %143 = getelementptr inbounds %struct.TValue, %struct.TValue* %142, i64 0, i32 1
  store i8 0, i8* %143, align 8, !tbaa !21
  %144 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %145 = getelementptr inbounds %union.StackValue, %union.StackValue* %144, i64 1
  store %union.StackValue* %145, %union.StackValue** %9, align 8, !tbaa !20
  br label %146

; <label>:146:                                    ; preds = %132, %57, %140, %39
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_tostring(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i8* @luaL_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_type(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 8
  %26 = icmp eq %struct.TValue* %17, %25
  br i1 %26, label %30, label %27

; <label>:27:                                     ; preds = %16, %22
  %28 = add nuw nsw i8 %20, 1
  %29 = zext i8 %28 to i64
  br label %32

; <label>:30:                                     ; preds = %22
  %31 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %32

; <label>:32:                                     ; preds = %27, %30
  %33 = phi i64 [ %29, %27 ], [ 0, %30 ]
  %34 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %33
  %35 = load i8*, i8** %34, align 8, !tbaa !54
  %36 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %35) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_xpcall(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 2, i32 6) #16
  %14 = bitcast %union.StackValue** %2 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  %16 = bitcast %struct.TValue* %15 to i32*
  store i32 1, i32* %16, align 8, !tbaa !21
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %15, i64 0, i32 1
  store i8 1, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %2, align 8, !tbaa !20
  %20 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %21 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %20, i64 0, i32 0
  %22 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !64
  %23 = icmp ult %union.StackValue* %22, %18
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %1
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %30

; <label>:28:                                     ; preds = %1
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1, i32 0
  br label %30

; <label>:30:                                     ; preds = %24, %28
  %31 = phi %struct.TValue* [ %27, %24 ], [ %29, %28 ]
  %32 = bitcast %struct.TValue* %31 to i64*
  %33 = bitcast %union.StackValue* %19 to i64*
  %34 = load i64, i64* %32, align 8
  store i64 %34, i64* %33, align 8
  %35 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %36 = load i8, i8* %35, align 8, !tbaa !22
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1, i32 0, i32 1
  store i8 %36, i8* %37, align 8, !tbaa !22
  %38 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 1
  store %union.StackValue* %39, %union.StackValue** %2, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 3, i32 2) #16
  %40 = add nsw i32 %13, -2
  %41 = tail call i32 @lua_pcallk(%struct.lua_State* nonnull %0, i32 %40, i32 -1, i32 2, i64 2, i32 (%struct.lua_State*, i32, i64)* nonnull @finishpcall) #16
  %42 = tail call i32 @finishpcall(%struct.lua_State* nonnull %0, i32 %41, i64 2) #16
  ret i32 %42
}

; Function Attrs: norecurse nounwind optsize readonly uwtable
define internal i32 @dofilecont(%struct.lua_State* nocapture readonly, i32, i64) #3 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = add nsw i32 %15, -1
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ipairsaux(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %3 = add nsw i64 %2, 1
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to i64*
  store i64 %3, i64* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 35, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  %11 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3) #16
  %12 = icmp eq i32 %11, 0
  %13 = select i1 %12, i32 1, i32 2
  ret i32 %13
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @load_aux(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %26

; <label>:5:                                      ; preds = %3
  %6 = icmp eq i32 %2, 0
  br i1 %6, label %33, label %7

; <label>:7:                                      ; preds = %5
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %2) #17
  %12 = bitcast %struct.TValue* %11 to i64*
  %13 = bitcast %struct.TValue* %10 to i64*
  %14 = load i64, i64* %12, align 8
  store i64 %14, i64* %13, align 8
  %15 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  %16 = load i8, i8* %15, align 8, !tbaa !22
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 %16, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %8, align 8, !tbaa !20
  %20 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 -2, i32 1) #16
  %21 = icmp eq i8* %20, null
  br i1 %21, label %22, label %33

; <label>:22:                                     ; preds = %7
  %23 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 -1
  store %union.StackValue* %24, %union.StackValue** %8, align 8, !tbaa !20
  %25 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %24, i32 0) #17
  br label %33

; <label>:26:                                     ; preds = %3
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %28 = bitcast %union.StackValue** %27 to %struct.TValue**
  %29 = load %struct.TValue*, %struct.TValue** %28, align 8, !tbaa !20
  %30 = getelementptr inbounds %struct.TValue, %struct.TValue* %29, i64 0, i32 1
  store i8 0, i8* %30, align 8, !tbaa !21
  %31 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %27, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %33

; <label>:33:                                     ; preds = %22, %5, %7, %26
  %34 = phi i32 [ 2, %26 ], [ 1, %7 ], [ 1, %5 ], [ 1, %22 ]
  ret i32 %34
}

; Function Attrs: nounwind optsize uwtable
define internal i8* @generic_reader(%struct.lua_State*, i8* nocapture readnone, i64*) #0 {
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.337, i64 0, i64 0)) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = bitcast %struct.TValue* %6 to %union.StackValue*
  %13 = icmp ult %union.StackValue* %11, %12
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %3
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %16 = load %struct.global_State*, %struct.global_State** %15, align 8, !tbaa !2
  %17 = getelementptr inbounds %struct.global_State, %struct.global_State* %16, i64 0, i32 8
  br label %20

; <label>:18:                                     ; preds = %3
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 0, i32 0
  br label %20

; <label>:20:                                     ; preds = %14, %18
  %21 = phi %struct.TValue* [ %17, %14 ], [ %19, %18 ]
  %22 = bitcast %struct.TValue* %21 to i64*
  %23 = bitcast %struct.TValue* %6 to i64*
  %24 = load i64, i64* %22, align 8
  store i64 %24, i64* %23, align 8
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 %26, i8* %27, align 8, !tbaa !22
  %28 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  store %union.StackValue* %29, %union.StackValue** %4, align 8, !tbaa !20
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %28, i32 1) #17
  %30 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1, i32 0
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1, i32 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = and i8 %33, 15
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %44

; <label>:36:                                     ; preds = %20
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %38 = load %struct.global_State*, %struct.global_State** %37, align 8, !tbaa !2
  %39 = getelementptr inbounds %struct.global_State, %struct.global_State* %38, i64 0, i32 8
  %40 = icmp eq %struct.TValue* %31, %39
  br i1 %40, label %47, label %41

; <label>:41:                                     ; preds = %36
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 -1
  store %union.StackValue* %42, %union.StackValue** %4, align 8, !tbaa !20
  %43 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %42, i32 0) #17
  store i64 0, i64* %2, align 8, !tbaa !82
  br label %72

; <label>:44:                                     ; preds = %20
  %45 = add nsw i8 %34, -3
  %46 = icmp ugt i8 %45, 1
  br i1 %46, label %47, label %49

; <label>:47:                                     ; preds = %36, %44
  %48 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.338, i64 0, i64 0)) #16
  unreachable

; <label>:49:                                     ; preds = %44
  %50 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %51 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %50, i64 0, i32 0
  %52 = load %union.StackValue*, %union.StackValue** %51, align 8, !tbaa !64
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 5
  %54 = icmp ult %union.StackValue* %53, %30
  br i1 %54, label %59, label %55

; <label>:55:                                     ; preds = %49
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %57 = load %struct.global_State*, %struct.global_State** %56, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 8
  br label %61

; <label>:59:                                     ; preds = %49
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 0, i32 0
  br label %61

; <label>:61:                                     ; preds = %55, %59
  %62 = phi %struct.TValue* [ %58, %55 ], [ %60, %59 ]
  %63 = bitcast %struct.TValue* %31 to i64*
  %64 = bitcast %struct.TValue* %62 to i64*
  %65 = load i64, i64* %63, align 8
  store i64 %65, i64* %64, align 8
  %66 = load i8, i8* %32, align 8, !tbaa !22
  %67 = getelementptr inbounds %struct.TValue, %struct.TValue* %62, i64 0, i32 1
  store i8 %66, i8* %67, align 8, !tbaa !22
  %68 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1
  store %union.StackValue* %69, %union.StackValue** %4, align 8, !tbaa !20
  %70 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %69, i32 0) #17
  %71 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 5, i64* %2) #16
  br label %72

; <label>:72:                                     ; preds = %61, %41
  %73 = phi i8* [ null, %41 ], [ %71, %61 ]
  ret i8* %73
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal i32 @finishpcall(%struct.lua_State* nocapture, i32, i64) #2 {
  %4 = icmp ugt i32 %1, 1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br i1 %4, label %6, label %22

; <label>:6:                                      ; preds = %3
  %7 = bitcast %union.StackValue** %5 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i32*
  store i32 0, i32* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 1, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %5, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  %14 = bitcast %struct.TValue* %13 to i64*
  %15 = bitcast %union.StackValue* %12 to i64*
  %16 = load i64, i64* %14, align 8
  store i64 %16, i64* %15, align 8
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0, i32 1
  %18 = load i8, i8* %17, align 8, !tbaa !22
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1, i32 0, i32 1
  store i8 %18, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %5, align 8, !tbaa !20
  br label %36

; <label>:22:                                     ; preds = %3
  %23 = bitcast %union.StackValue** %5 to i64*
  %24 = load i64, i64* %23, align 8, !tbaa !20
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %26 = load %struct.CallInfo*, %struct.CallInfo** %25, align 8, !tbaa !24
  %27 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %26, i64 0, i32 0
  %28 = load %union.StackValue*, %union.StackValue** %27, align 8, !tbaa !64
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %28, i64 1
  %30 = ptrtoint %union.StackValue* %29 to i64
  %31 = sub i64 %24, %30
  %32 = lshr exact i64 %31, 4
  %33 = trunc i64 %32 to i32
  %34 = trunc i64 %2 to i32
  %35 = sub nsw i32 %33, %34
  br label %36

; <label>:36:                                     ; preds = %22, %6
  %37 = phi i32 [ 2, %6 ], [ %35, %22 ]
  ret i32 %37
}

; Function Attrs: nounwind optsize
declare i64 @fwrite(i8* nocapture, i64, i64, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize readnone
declare i16** @__ctype_b_loc() local_unnamed_addr #8

; Function Attrs: nounwind optsize readnone
declare i32** @__ctype_toupper_loc() local_unnamed_addr #8

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_cocreate(%struct.lua_State*) #0 {
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  %2 = tail call %struct.lua_State* @lua_newthread(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = bitcast %struct.TValue* %5 to %union.StackValue*
  %12 = icmp ult %union.StackValue* %10, %11
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %15 = load %struct.global_State*, %struct.global_State** %14, align 8, !tbaa !2
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 8
  br label %19

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  br label %19

; <label>:19:                                     ; preds = %13, %17
  %20 = phi %struct.TValue* [ %16, %13 ], [ %18, %17 ]
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %5 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %3, align 8, !tbaa !20
  %29 = icmp eq %struct.lua_State* %2, %0
  br i1 %29, label %42, label %30

; <label>:30:                                     ; preds = %19
  store %union.StackValue* %27, %union.StackValue** %3, align 8, !tbaa !20
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 6
  %32 = bitcast %union.StackValue** %31 to %struct.TValue**
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %34 = bitcast %union.StackValue* %27 to i64*
  %35 = bitcast %struct.TValue* %33 to i64*
  %36 = load i64, i64* %34, align 8
  store i64 %36, i64* %35, align 8
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 0, i32 0, i32 1
  %38 = load i8, i8* %37, align 8, !tbaa !22
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  store i8 %38, i8* %39, align 8, !tbaa !22
  %40 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %31, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %30, %19
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_coresume(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = add nsw i32 %14, -1
  %16 = tail call fastcc i32 @auxresume(%struct.lua_State* %0, %struct.lua_State* %2, i32 %15) #16
  %17 = icmp slt i32 %16, 0
  %18 = bitcast %union.StackValue** %3 to %struct.TValue**
  %19 = load %struct.TValue*, %struct.TValue** %18, align 8, !tbaa !20
  %20 = bitcast %struct.TValue* %19 to i32*
  br i1 %17, label %21, label %25

; <label>:21:                                     ; preds = %1
  store i32 0, i32* %20, align 8, !tbaa !21
  %22 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 1, i8* %22, align 8, !tbaa !22
  %23 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %23, i64 1
  store %union.StackValue* %24, %union.StackValue** %3, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  br label %31

; <label>:25:                                     ; preds = %1
  store i32 1, i32* %20, align 8, !tbaa !21
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 1, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %3, align 8, !tbaa !20
  %29 = add nsw i32 %16, 1
  %30 = xor i32 %16, -1
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 %30, i32 1) #16
  br label %31

; <label>:31:                                     ; preds = %25, %21
  %32 = phi i32 [ 2, %21 ], [ %29, %25 ]
  ret i32 %32
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal i32 @luaB_corunning(%struct.lua_State*) #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = bitcast %struct.TValue* %4 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %5, align 8, !tbaa !21
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 72, i8* %6, align 8, !tbaa !22
  %7 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  store %union.StackValue* %8, %union.StackValue** %2, align 8, !tbaa !20
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %10 = load %struct.global_State*, %struct.global_State** %9, align 8, !tbaa !2
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %10, i64 0, i32 38
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !38
  %13 = icmp eq %struct.lua_State* %12, %0
  %14 = zext i1 %13 to i32
  %15 = bitcast %union.StackValue* %8 to i32*
  store i32 %14, i32* %15, align 8, !tbaa !21
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1, i32 0, i32 1
  store i8 1, i8* %16, align 8, !tbaa !22
  %17 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  store %union.StackValue* %18, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_costatus(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = icmp eq %struct.lua_State* %2, %0
  br i1 %3, label %26, label %4

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 3
  %6 = load i8, i8* %5, align 2, !tbaa !35
  switch i8 %6, label %25 [
    i8 1, label %26
    i8 0, label %7
  ]

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !54
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 16
  %11 = icmp eq %struct.CallInfo* %9, %10
  br i1 %11, label %12, label %26

; <label>:12:                                     ; preds = %7
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to i64*
  %15 = load i64, i64* %14, align 8, !tbaa !20
  %16 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !64
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %17, i64 1
  %19 = ptrtoint %union.StackValue* %18 to i64
  %20 = sub i64 %15, %19
  %21 = lshr exact i64 %20, 4
  %22 = trunc i64 %21 to i32
  %23 = icmp eq i32 %22, 0
  %24 = select i1 %23, i64 1, i64 2
  br label %26

; <label>:25:                                     ; preds = %4
  br label %26

; <label>:26:                                     ; preds = %1, %4, %7, %12, %25
  %27 = phi i64 [ 1, %25 ], [ 0, %1 ], [ 2, %4 ], [ %24, %12 ], [ 3, %7 ]
  %28 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %27
  %29 = load i8*, i8** %28, align 8, !tbaa !54
  %30 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %29) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_cowrap(%struct.lua_State*) #0 {
  %2 = tail call i32 @luaB_cocreate(%struct.lua_State* %0) #16
  tail call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @luaB_auxwrap, i32 1) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_yield(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = tail call i32 @lua_yieldk(%struct.lua_State* %0, i32 %13, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_yieldable(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br i1 %9, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %28

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  %27 = icmp eq %struct.TValue* %18, %26
  br i1 %27, label %32, label %28

; <label>:28:                                     ; preds = %17, %23
  %29 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* nonnull %0) #16
  %30 = bitcast %union.StackValue** %7 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  br label %32

; <label>:32:                                     ; preds = %23, %28
  %33 = phi %struct.TValue* [ %31, %28 ], [ %10, %23 ]
  %34 = phi %struct.lua_State* [ %29, %28 ], [ %0, %23 ]
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %34, i64 0, i32 19
  %36 = load i32, i32* %35, align 8, !tbaa !29
  %37 = icmp ult i32 %36, 65536
  %38 = zext i1 %37 to i32
  %39 = bitcast %struct.TValue* %33 to i32*
  store i32 %38, i32* %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  store i8 1, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_kill(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct.lua_State* @getco(%struct.lua_State* %0) #16
  %3 = icmp eq %struct.lua_State* %2, %0
  br i1 %3, label %49, label %4

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 3
  %6 = load i8, i8* %5, align 2, !tbaa !35
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %8, label %28

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 8
  %10 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !54
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 16
  %12 = icmp eq %struct.CallInfo* %10, %11
  br i1 %12, label %13, label %49

; <label>:13:                                     ; preds = %8
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to i64*
  %16 = load i64, i64* %15, align 8, !tbaa !20
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %10, i64 0, i32 0
  %18 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !64
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  %20 = ptrtoint %union.StackValue* %19 to i64
  %21 = sub i64 %16, %20
  %22 = lshr exact i64 %21, 4
  %23 = trunc i64 %22 to i32
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 1, i32 2
  %26 = add nsw i32 %25, -1
  %27 = icmp ult i32 %26, 2
  br i1 %27, label %28, label %49

; <label>:28:                                     ; preds = %4, %13
  %29 = tail call i32 @lua_resetthread(%struct.lua_State* nonnull %2) #16
  %30 = icmp eq i32 %29, 0
  %31 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %32 = bitcast %union.StackValue** %31 to %struct.TValue**
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %34 = bitcast %struct.TValue* %33 to i32*
  br i1 %30, label %35, label %36

; <label>:35:                                     ; preds = %28
  store i32 1, i32* %34, align 8, !tbaa !21
  br label %55

; <label>:36:                                     ; preds = %28
  store i32 0, i32* %34, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  store i8 1, i8* %37, align 8, !tbaa !22
  %38 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 1
  store %union.StackValue* %39, %union.StackValue** %31, align 8, !tbaa !20
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %2, i64 0, i32 6
  %41 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 -1
  store %union.StackValue* %42, %union.StackValue** %40, align 8, !tbaa !20
  %43 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %44 = bitcast %union.StackValue* %42 to i64*
  %45 = bitcast %struct.TValue* %43 to i64*
  %46 = load i64, i64* %44, align 8
  store i64 %46, i64* %45, align 8
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 -1, i32 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !22
  br label %55

; <label>:49:                                     ; preds = %8, %1, %13
  %50 = phi i32 [ %25, %13 ], [ 3, %8 ], [ 0, %1 ]
  %51 = zext i32 %50 to i64
  %52 = getelementptr inbounds [4 x i8*], [4 x i8*]* @statname, i64 0, i64 %51
  %53 = load i8*, i8** %52, align 8, !tbaa !54
  %54 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.360, i64 0, i64 0), i8* %53) #16
  unreachable

; <label>:55:                                     ; preds = %36, %35
  %56 = phi %struct.TValue* [ %43, %36 ], [ %33, %35 ]
  %57 = phi i8 [ %48, %36 ], [ 1, %35 ]
  %58 = phi i32 [ 2, %36 ], [ 1, %35 ]
  %59 = getelementptr inbounds %struct.TValue, %struct.TValue* %56, i64 0, i32 1
  store i8 %57, i8* %59, align 8, !tbaa !22
  %60 = load %union.StackValue*, %union.StackValue** %31, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %60, i64 1
  store %union.StackValue* %61, %union.StackValue** %31, align 8, !tbaa !20
  ret i32 %58
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct.lua_State* @getco(%struct.lua_State*) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 72
  br i1 %20, label %21, label %25

; <label>:21:                                     ; preds = %16
  %22 = bitcast %struct.TValue* %17 to %struct.lua_State**
  %23 = load %struct.lua_State*, %struct.lua_State** %22, align 8, !tbaa !21
  %24 = icmp eq %struct.lua_State* %23, null
  br i1 %24, label %25, label %27

; <label>:25:                                     ; preds = %16, %21
  %26 = tail call i32 @luaL_typeerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.186, i64 0, i64 0)) #16
  br label %27

; <label>:27:                                     ; preds = %21, %25
  %28 = phi %struct.lua_State* [ %23, %21 ], [ null, %25 ]
  ret %struct.lua_State* %28
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @auxresume(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = alloca i32, align 4
  %5 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %5) #7
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.355, i64 0, i64 0)) #16
  br label %59

; <label>:10:                                     ; preds = %3
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 3
  %12 = load i8, i8* %11, align 2, !tbaa !35
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %14, label %30

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %16 = bitcast %union.StackValue** %15 to i64*
  %17 = load i64, i64* %16, align 8, !tbaa !20
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 8
  %19 = load %struct.CallInfo*, %struct.CallInfo** %18, align 8, !tbaa !24
  %20 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %19, i64 0, i32 0
  %21 = load %union.StackValue*, %union.StackValue** %20, align 8, !tbaa !64
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  %23 = ptrtoint %union.StackValue* %22 to i64
  %24 = sub i64 %17, %23
  %25 = lshr exact i64 %24, 4
  %26 = trunc i64 %25 to i32
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %14
  %29 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.1, i64 0, i64 0)) #16
  br label %59

; <label>:30:                                     ; preds = %14, %10
  tail call void @lua_xmove(%struct.lua_State* %0, %struct.lua_State* nonnull %1, i32 %2) #16
  %31 = call i32 @lua_resume(%struct.lua_State* nonnull %1, %struct.lua_State* %0, i32 %2, i32* nonnull %4) #16
  %32 = icmp ult i32 %31, 2
  br i1 %32, label %33, label %42

; <label>:33:                                     ; preds = %30
  %34 = load i32, i32* %4, align 4, !tbaa !77
  %35 = add nsw i32 %34, 1
  %36 = tail call i32 @lua_checkstack(%struct.lua_State* %0, i32 %35) #16
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %38, label %41

; <label>:38:                                     ; preds = %33
  %39 = xor i32 %34, -1
  tail call void @lua_settop(%struct.lua_State* nonnull %1, i32 %39) #16
  %40 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.356, i64 0, i64 0)) #16
  br label %59

; <label>:41:                                     ; preds = %33
  tail call void @lua_xmove(%struct.lua_State* nonnull %1, %struct.lua_State* %0, i32 %34) #16
  br label %59

; <label>:42:                                     ; preds = %30
  %43 = icmp eq %struct.lua_State* %1, %0
  br i1 %43, label %59, label %44

; <label>:44:                                     ; preds = %42
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %46 = load %union.StackValue*, %union.StackValue** %45, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 -1
  store %union.StackValue* %47, %union.StackValue** %45, align 8, !tbaa !20
  %48 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %49 = bitcast %union.StackValue** %48 to %struct.TValue**
  %50 = load %struct.TValue*, %struct.TValue** %49, align 8, !tbaa !20
  %51 = bitcast %union.StackValue* %47 to i64*
  %52 = bitcast %struct.TValue* %50 to i64*
  %53 = load i64, i64* %51, align 8
  store i64 %53, i64* %52, align 8
  %54 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 -1, i32 0, i32 1
  %55 = load i8, i8* %54, align 8, !tbaa !22
  %56 = getelementptr inbounds %struct.TValue, %struct.TValue* %50, i64 0, i32 1
  store i8 %55, i8* %56, align 8, !tbaa !22
  %57 = load %union.StackValue*, %union.StackValue** %48, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 1
  store %union.StackValue* %58, %union.StackValue** %48, align 8, !tbaa !20
  br label %59

; <label>:59:                                     ; preds = %44, %42, %41, %38, %28, %8
  %60 = phi i32 [ -1, %28 ], [ %34, %41 ], [ -1, %38 ], [ -1, %8 ], [ -1, %42 ], [ -1, %44 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %5) #7
  ret i32 %60
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @luaB_auxwrap(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = bitcast %struct.CallInfo** %2 to %struct.TValue***
  %4 = load %struct.TValue**, %struct.TValue*** %3, align 8, !tbaa !24
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  %7 = load i8, i8* %6, align 8, !tbaa !21
  %8 = icmp eq i8 %7, 38
  br i1 %8, label %9, label %13

; <label>:9:                                      ; preds = %1
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %11 = load %struct.global_State*, %struct.global_State** %10, align 8, !tbaa !2
  %12 = getelementptr inbounds %struct.global_State, %struct.global_State* %11, i64 0, i32 8
  br label %25

; <label>:13:                                     ; preds = %1
  %14 = bitcast %struct.TValue* %5 to %struct.CClosure**
  %15 = load %struct.CClosure*, %struct.CClosure** %14, align 8, !tbaa !21
  %16 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %15, i64 0, i32 3
  %17 = load i8, i8* %16, align 2, !tbaa !138
  %18 = icmp eq i8 %17, 0
  br i1 %18, label %21, label %19

; <label>:19:                                     ; preds = %13
  %20 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %15, i64 0, i32 6, i64 0
  br label %25

; <label>:21:                                     ; preds = %13
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 8
  br label %25

; <label>:25:                                     ; preds = %9, %19, %21
  %26 = phi %struct.TValue* [ %12, %9 ], [ %20, %19 ], [ %24, %21 ]
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = icmp eq i8 %28, 72
  br i1 %29, label %30, label %33

; <label>:30:                                     ; preds = %25
  %31 = bitcast %struct.TValue* %26 to %struct.lua_State**
  %32 = load %struct.lua_State*, %struct.lua_State** %31, align 8, !tbaa !21
  br label %33

; <label>:33:                                     ; preds = %25, %30
  %34 = phi %struct.lua_State* [ %32, %30 ], [ null, %25 ]
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %36 = bitcast %union.StackValue** %35 to i64*
  %37 = load i64, i64* %36, align 8, !tbaa !20
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 1
  %39 = ptrtoint %struct.TValue* %38 to i64
  %40 = sub i64 %37, %39
  %41 = lshr exact i64 %40, 4
  %42 = trunc i64 %41 to i32
  %43 = tail call fastcc i32 @auxresume(%struct.lua_State* nonnull %0, %struct.lua_State* %34, i32 %42) #16
  %44 = icmp slt i32 %43, 0
  br i1 %44, label %45, label %77

; <label>:45:                                     ; preds = %33
  %46 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %34, i64 0, i32 3
  %47 = load i8, i8* %46, align 2, !tbaa !35
  %48 = icmp ugt i8 %47, 1
  br i1 %48, label %49, label %68

; <label>:49:                                     ; preds = %45
  %50 = tail call i32 @lua_resetthread(%struct.lua_State* nonnull %34) #16
  %51 = icmp eq i32 %50, 0
  %52 = icmp eq %struct.lua_State* %34, %0
  %53 = or i1 %52, %51
  br i1 %53, label %68, label %54

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %34, i64 0, i32 6
  %56 = load %union.StackValue*, %union.StackValue** %55, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 -1
  store %union.StackValue* %57, %union.StackValue** %55, align 8, !tbaa !20
  %58 = bitcast %union.StackValue** %35 to %struct.TValue**
  %59 = load %struct.TValue*, %struct.TValue** %58, align 8, !tbaa !20
  %60 = bitcast %union.StackValue* %57 to i64*
  %61 = bitcast %struct.TValue* %59 to i64*
  %62 = load i64, i64* %60, align 8
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 -1, i32 0, i32 1
  %64 = load i8, i8* %63, align 8, !tbaa !22
  %65 = getelementptr inbounds %struct.TValue, %struct.TValue* %59, i64 0, i32 1
  store i8 %64, i8* %65, align 8, !tbaa !22
  %66 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %67 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 1
  store %union.StackValue* %67, %union.StackValue** %35, align 8, !tbaa !20
  br label %68

; <label>:68:                                     ; preds = %54, %49, %45
  %69 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !20
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %69, i64 -1, i32 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  %72 = and i8 %71, 15
  %73 = icmp eq i8 %72, 4
  br i1 %73, label %74, label %75

; <label>:74:                                     ; preds = %68
  tail call void @luaL_where(%struct.lua_State* nonnull %0, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  tail call void @lua_concat(%struct.lua_State* nonnull %0, i32 2) #16
  br label %75

; <label>:75:                                     ; preds = %68, %74
  %76 = tail call i32 @lua_error(%struct.lua_State* nonnull %0) #16
  unreachable

; <label>:77:                                     ; preds = %33
  ret i32 %43
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_debug(%struct.lua_State*) #0 {
  %2 = alloca %struct.CallS, align 8
  %3 = alloca %struct.LoadS, align 8
  %4 = alloca [250 x i8], align 16
  %5 = getelementptr inbounds [250 x i8], [250 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 250, i8* nonnull %5) #7
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %7 = call i32 @fputs(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.375, i64 0, i64 0), %struct._IO_FILE* %6) #24
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %9 = call i32 @fflush(%struct._IO_FILE* %8) #16
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !54
  %11 = call i8* @fgets(i8* nonnull %5, i32 250, %struct._IO_FILE* %10) #16
  %12 = icmp eq i8* %11, null
  br i1 %12, label %52, label %13

; <label>:13:                                     ; preds = %1
  %14 = bitcast %struct.LoadS* %3 to i8*
  %15 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %3, i64 0, i32 0
  %16 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %3, i64 0, i32 1
  %17 = bitcast %struct.CallS* %2 to i8*
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = getelementptr inbounds %struct.CallS, %struct.CallS* %2, i64 0, i32 0
  %20 = getelementptr inbounds %struct.CallS, %struct.CallS* %2, i64 0, i32 1
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %22 = bitcast %union.StackValue** %21 to i64*
  br label %23

; <label>:23:                                     ; preds = %13, %44
  %24 = call i32 @strcmp(i8* nonnull %5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.376, i64 0, i64 0)) #21
  %25 = icmp eq i32 %24, 0
  br i1 %25, label %52, label %26

; <label>:26:                                     ; preds = %23
  %27 = call i64 @strlen(i8* nonnull %5) #21
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %14) #7
  store i8* %5, i8** %15, align 8, !tbaa !211
  store i64 %27, i64* %16, align 8, !tbaa !213
  %28 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %14, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.377, i64 0, i64 0), i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %14) #7
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %30, label %38

; <label>:30:                                     ; preds = %26
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %17) #7
  %31 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 -1
  store %union.StackValue* %32, %union.StackValue** %19, align 8, !tbaa !159
  %33 = ptrtoint %union.StackValue* %32 to i64
  store i32 0, i32* %20, align 8, !tbaa !161
  %34 = load i64, i64* %22, align 8, !tbaa !23
  %35 = sub i64 %33, %34
  %36 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %17, i64 %35, i64 0) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %17) #7
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %44, label %38

; <label>:38:                                     ; preds = %30, %26
  %39 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %40 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %41 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %39, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i64 0, i64 0), i8* %40) #23
  %42 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %43 = call i32 @fflush(%struct._IO_FILE* %42) #16
  br label %44

; <label>:44:                                     ; preds = %30, %38
  call void @lua_settop(%struct.lua_State* %0, i32 0) #16
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %5) #7
  call void @llvm.lifetime.start.p0i8(i64 250, i8* nonnull %5) #7
  %45 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %46 = call i32 @fputs(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.375, i64 0, i64 0), %struct._IO_FILE* %45) #24
  %47 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8, !tbaa !54
  %48 = call i32 @fflush(%struct._IO_FILE* %47) #16
  %49 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !54
  %50 = call i8* @fgets(i8* nonnull %5, i32 250, %struct._IO_FILE* %49) #16
  %51 = icmp eq i8* %50, null
  br i1 %51, label %52, label %23

; <label>:52:                                     ; preds = %23, %44, %1
  call void @llvm.lifetime.end.p0i8(i64 250, i8* nonnull %5) #7
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 7
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0, i32 1
  store i8 0, i8* %24, align 8, !tbaa !21
  br label %34

; <label>:25:                                     ; preds = %17
  %26 = trunc i64 %2 to i32
  %27 = tail call i32 @lua_getiuservalue(%struct.lua_State* nonnull %0, i32 1, i32 %26) #16
  %28 = icmp eq i32 %27, -1
  br i1 %28, label %38, label %29

; <label>:29:                                     ; preds = %25
  %30 = bitcast %union.StackValue** %8 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to i32*
  store i32 1, i32* %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 1, i8* %33, align 8, !tbaa !22
  br label %34

; <label>:34:                                     ; preds = %29, %23
  %35 = phi i32 [ 1, %23 ], [ 2, %29 ]
  %36 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 1
  store %union.StackValue* %37, %union.StackValue** %8, align 8, !tbaa !20
  br label %38

; <label>:38:                                     ; preds = %34, %25
  %39 = phi i32 [ 1, %25 ], [ %35, %34 ]
  ret i32 %39
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_gethook(%struct.lua_State*) #0 {
  %2 = alloca [5 x i8], align 1
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %15, %11
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 8
  br i1 %22, label %23, label %38

; <label>:23:                                     ; preds = %17
  br i1 %10, label %28, label %24

; <label>:24:                                     ; preds = %23
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %30

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %30

; <label>:30:                                     ; preds = %28, %24
  %31 = phi %struct.TValue* [ %27, %24 ], [ %29, %28 ]
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = icmp eq i8 %33, 72
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %30
  %36 = bitcast %struct.TValue* %31 to %struct.lua_State**
  %37 = load %struct.lua_State*, %struct.lua_State** %36, align 8, !tbaa !21
  br label %38

; <label>:38:                                     ; preds = %17, %30, %35
  %39 = phi %struct.lua_State* [ %37, %35 ], [ null, %30 ], [ %0, %17 ]
  %40 = getelementptr inbounds [5 x i8], [5 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 5, i8* nonnull %40) #7
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %39, i64 0, i32 23
  %42 = load i32, i32* %41, align 8, !tbaa !31
  %43 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %39, i64 0, i32 17
  %44 = load volatile void (%struct.lua_State*, %struct.lua_Debug*)*, void (%struct.lua_State*, %struct.lua_Debug*)** %43, align 8, !tbaa !30
  %45 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %44, null
  br i1 %45, label %46, label %50

; <label>:46:                                     ; preds = %38
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0, i32 1
  store i8 0, i8* %47, align 8, !tbaa !21
  %48 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1
  store %union.StackValue* %49, %union.StackValue** %8, align 8, !tbaa !20
  br label %80

; <label>:50:                                     ; preds = %38
  %51 = icmp eq void (%struct.lua_State*, %struct.lua_Debug*)* %44, @hookf
  br i1 %51, label %54, label %52

; <label>:52:                                     ; preds = %50
  %53 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.378, i64 0, i64 0)) #16
  br label %80

; <label>:54:                                     ; preds = %50
  %55 = tail call i32 @lua_rawgetp(%struct.lua_State* nonnull %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  tail call fastcc void @checkstack(%struct.lua_State* nonnull %0, %struct.lua_State* %39, i32 1) #16
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %39, i64 0, i32 6
  %57 = bitcast %union.StackValue** %56 to %struct.TValue**
  %58 = load %struct.TValue*, %struct.TValue** %57, align 8, !tbaa !20
  %59 = bitcast %struct.TValue* %58 to %struct.lua_State**
  store %struct.lua_State* %39, %struct.lua_State** %59, align 8, !tbaa !21
  %60 = getelementptr inbounds %struct.TValue, %struct.TValue* %58, i64 0, i32 1
  store i8 72, i8* %60, align 8, !tbaa !22
  %61 = load %union.StackValue*, %union.StackValue** %56, align 8, !tbaa !20
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 1
  store %union.StackValue* %62, %union.StackValue** %56, align 8, !tbaa !20
  %63 = icmp eq %struct.lua_State* %39, %0
  br i1 %63, label %75, label %64

; <label>:64:                                     ; preds = %54
  store %union.StackValue* %61, %union.StackValue** %56, align 8, !tbaa !20
  %65 = bitcast %union.StackValue** %8 to %struct.TValue**
  %66 = load %struct.TValue*, %struct.TValue** %65, align 8, !tbaa !20
  %67 = bitcast %union.StackValue* %61 to i64*
  %68 = bitcast %struct.TValue* %66 to i64*
  %69 = load i64, i64* %67, align 8
  store i64 %69, i64* %68, align 8
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 0, i32 0, i32 1
  %71 = load i8, i8* %70, align 8, !tbaa !22
  %72 = getelementptr inbounds %struct.TValue, %struct.TValue* %66, i64 0, i32 1
  store i8 %71, i8* %72, align 8, !tbaa !22
  %73 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %73, i64 1
  store %union.StackValue* %74, %union.StackValue** %8, align 8, !tbaa !20
  br label %75

; <label>:75:                                     ; preds = %64, %54
  %76 = tail call i32 @lua_rawget(%struct.lua_State* nonnull %0, i32 -2) #16
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 -1) #16
  %77 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %77, i64 -1
  store %union.StackValue* %78, %union.StackValue** %8, align 8, !tbaa !20
  %79 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %78, i32 0) #17
  br label %80

; <label>:80:                                     ; preds = %52, %75, %46
  %81 = and i32 %42, 1
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %84, label %83

; <label>:83:                                     ; preds = %80
  store i8 99, i8* %40, align 1, !tbaa !21
  br label %84

; <label>:84:                                     ; preds = %83, %80
  %85 = phi i32 [ 1, %83 ], [ 0, %80 ]
  %86 = and i32 %42, 2
  %87 = icmp eq i32 %86, 0
  br i1 %87, label %92, label %88

; <label>:88:                                     ; preds = %84
  %89 = add nuw nsw i32 %85, 1
  %90 = zext i32 %85 to i64
  %91 = getelementptr inbounds [5 x i8], [5 x i8]* %2, i64 0, i64 %90
  store i8 114, i8* %91, align 1, !tbaa !21
  br label %92

; <label>:92:                                     ; preds = %88, %84
  %93 = phi i32 [ %89, %88 ], [ %85, %84 ]
  %94 = and i32 %42, 4
  %95 = icmp eq i32 %94, 0
  br i1 %95, label %100, label %96

; <label>:96:                                     ; preds = %92
  %97 = add nsw i32 %93, 1
  %98 = sext i32 %93 to i64
  %99 = getelementptr inbounds [5 x i8], [5 x i8]* %2, i64 0, i64 %98
  store i8 108, i8* %99, align 1, !tbaa !21
  br label %100

; <label>:100:                                    ; preds = %92, %96
  %101 = phi i32 [ %97, %96 ], [ %93, %92 ]
  %102 = sext i32 %101 to i64
  %103 = getelementptr inbounds [5 x i8], [5 x i8]* %2, i64 0, i64 %102
  store i8 0, i8* %103, align 1, !tbaa !21
  %104 = call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* nonnull %40) #16
  %105 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %39, i64 0, i32 21
  %106 = load i32, i32* %105, align 8, !tbaa !32
  %107 = sext i32 %106 to i64
  %108 = bitcast %union.StackValue** %8 to %struct.TValue**
  %109 = load %struct.TValue*, %struct.TValue** %108, align 8, !tbaa !20
  %110 = bitcast %struct.TValue* %109 to i64*
  store i64 %107, i64* %110, align 8, !tbaa !21
  %111 = getelementptr inbounds %struct.TValue, %struct.TValue* %109, i64 0, i32 1
  store i8 35, i8* %111, align 8, !tbaa !22
  %112 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %113 = getelementptr inbounds %union.StackValue, %union.StackValue* %112, i64 1
  store %union.StackValue* %113, %union.StackValue** %8, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 5, i8* nonnull %40) #7
  ret i32 3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getinfo(%struct.lua_State*) #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %16, %12
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 8
  br i1 %23, label %24, label %39

; <label>:24:                                     ; preds = %18
  br i1 %11, label %29, label %25

; <label>:25:                                     ; preds = %24
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %27 = load %struct.global_State*, %struct.global_State** %26, align 8, !tbaa !2
  %28 = getelementptr inbounds %struct.global_State, %struct.global_State* %27, i64 0, i32 8
  br label %31

; <label>:29:                                     ; preds = %24
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %31

; <label>:31:                                     ; preds = %29, %25
  %32 = phi %struct.TValue* [ %28, %25 ], [ %30, %29 ]
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %34 = load i8, i8* %33, align 8, !tbaa !22
  %35 = icmp eq i8 %34, 72
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %31
  %37 = bitcast %struct.TValue* %32 to %struct.lua_State**
  %38 = load %struct.lua_State*, %struct.lua_State** %37, align 8, !tbaa !21
  br label %39

; <label>:39:                                     ; preds = %18, %31, %36
  %40 = phi i32 [ 1, %36 ], [ 1, %31 ], [ 0, %18 ]
  %41 = phi %struct.lua_State* [ %38, %36 ], [ null, %31 ], [ %0, %18 ]
  %42 = or i32 %40, 2
  %43 = tail call i8* @luaL_optlstring(%struct.lua_State* nonnull %0, i32 %42, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.381, i64 0, i64 0), i64* null) #16
  tail call fastcc void @checkstack(%struct.lua_State* nonnull %0, %struct.lua_State* %41, i32 3) #16
  %44 = add nuw nsw i32 %40, 1
  %45 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %44) #17
  %46 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 6
  br i1 %49, label %50, label %76

; <label>:50:                                     ; preds = %39
  %51 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.382, i64 0, i64 0), i8* %43) #16
  %52 = bitcast %union.StackValue** %9 to %struct.TValue**
  %53 = load %struct.TValue*, %struct.TValue** %52, align 8, !tbaa !20
  %54 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %44) #17
  %55 = bitcast %struct.TValue* %54 to i64*
  %56 = bitcast %struct.TValue* %53 to i64*
  %57 = load i64, i64* %55, align 8
  store i64 %57, i64* %56, align 8
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %54, i64 0, i32 1
  %59 = load i8, i8* %58, align 8, !tbaa !22
  %60 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  store i8 %59, i8* %60, align 8, !tbaa !22
  %61 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 1
  store %union.StackValue* %62, %union.StackValue** %9, align 8, !tbaa !20
  %63 = icmp eq %struct.lua_State* %41, %0
  br i1 %63, label %111, label %64

; <label>:64:                                     ; preds = %50
  store %union.StackValue* %61, %union.StackValue** %9, align 8, !tbaa !20
  %65 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %41, i64 0, i32 6
  %66 = bitcast %union.StackValue** %65 to %struct.TValue**
  %67 = load %struct.TValue*, %struct.TValue** %66, align 8, !tbaa !20
  %68 = bitcast %union.StackValue* %61 to i64*
  %69 = bitcast %struct.TValue* %67 to i64*
  %70 = load i64, i64* %68, align 8
  store i64 %70, i64* %69, align 8
  %71 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 0, i32 0, i32 1
  %72 = load i8, i8* %71, align 8, !tbaa !22
  %73 = getelementptr inbounds %struct.TValue, %struct.TValue* %67, i64 0, i32 1
  store i8 %72, i8* %73, align 8, !tbaa !22
  %74 = load %union.StackValue*, %union.StackValue** %65, align 8, !tbaa !20
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %74, i64 1
  store %union.StackValue* %75, %union.StackValue** %65, align 8, !tbaa !20
  br label %111

; <label>:76:                                     ; preds = %39
  %77 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 %44) #16
  %78 = trunc i64 %77 to i32
  %79 = icmp slt i32 %78, 0
  br i1 %79, label %105, label %80

; <label>:80:                                     ; preds = %76
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %41, i64 0, i32 8
  %82 = load %struct.CallInfo*, %struct.CallInfo** %81, align 8, !tbaa !54
  %83 = icmp ne i32 %78, 0
  %84 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %41, i64 0, i32 16
  %85 = icmp ne %struct.CallInfo* %82, %84
  %86 = and i1 %83, %85
  br i1 %86, label %87, label %97

; <label>:87:                                     ; preds = %80
  br label %88

; <label>:88:                                     ; preds = %87, %88
  %89 = phi %struct.CallInfo* [ %93, %88 ], [ %82, %87 ]
  %90 = phi i32 [ %91, %88 ], [ %78, %87 ]
  %91 = add nsw i32 %90, -1
  %92 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %89, i64 0, i32 2
  %93 = load %struct.CallInfo*, %struct.CallInfo** %92, align 8, !tbaa !54
  %94 = icmp sgt i32 %90, 1
  %95 = icmp ne %struct.CallInfo* %93, %84
  %96 = and i1 %94, %95
  br i1 %96, label %88, label %97

; <label>:97:                                     ; preds = %88, %80
  %98 = phi i32 [ %78, %80 ], [ %91, %88 ]
  %99 = phi %struct.CallInfo* [ %82, %80 ], [ %93, %88 ]
  %100 = icmp ne i32 %98, 0
  %101 = icmp eq %struct.CallInfo* %99, %84
  %102 = or i1 %100, %101
  br i1 %102, label %105, label %103

; <label>:103:                                    ; preds = %97
  %104 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %99, %struct.CallInfo** %104, align 8, !tbaa !106
  br label %111

; <label>:105:                                    ; preds = %76, %97
  %106 = bitcast %union.StackValue** %9 to %struct.TValue**
  %107 = load %struct.TValue*, %struct.TValue** %106, align 8, !tbaa !20
  %108 = getelementptr inbounds %struct.TValue, %struct.TValue* %107, i64 0, i32 1
  store i8 0, i8* %108, align 8, !tbaa !21
  %109 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %110 = getelementptr inbounds %union.StackValue, %union.StackValue* %109, i64 1
  store %union.StackValue* %110, %union.StackValue** %9, align 8, !tbaa !20
  br label %263

; <label>:111:                                    ; preds = %64, %103, %50
  %112 = phi i8* [ %43, %103 ], [ %51, %50 ], [ %51, %64 ]
  %113 = call i32 @lua_getinfo(%struct.lua_State* %41, i8* %112, %struct.lua_Debug* nonnull %2) #16
  %114 = icmp eq i32 %113, 0
  br i1 %114, label %115, label %117

; <label>:115:                                    ; preds = %111
  %116 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %42, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.383, i64 0, i64 0)) #16
  br label %263

; <label>:117:                                    ; preds = %111
  call void @lua_createtable(%struct.lua_State* %0, i32 0, i32 0) #16
  %118 = call i8* @strchr(i8* %112, i32 83) #21
  %119 = icmp eq i8* %118, null
  br i1 %119, label %156, label %120

; <label>:120:                                    ; preds = %117
  %121 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 4
  %122 = load i8*, i8** %121, align 8, !tbaa !118
  %123 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 5
  %124 = load i64, i64* %123, align 8, !tbaa !119
  %125 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %122, i64 %124) #16
  %126 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %127 = getelementptr inbounds %union.StackValue, %union.StackValue* %126, i64 -2, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %127, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.384, i64 0, i64 0)) #17
  %128 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 15, i64 0
  %129 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %128) #17
  %130 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %131 = getelementptr inbounds %union.StackValue, %union.StackValue* %130, i64 -2, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %131, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.385, i64 0, i64 0)) #17
  %132 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 7
  %133 = load i32, i32* %132, align 4, !tbaa !120
  %134 = sext i32 %133 to i64
  %135 = bitcast %union.StackValue** %9 to %struct.TValue**
  %136 = load %struct.TValue*, %struct.TValue** %135, align 8, !tbaa !20
  %137 = bitcast %struct.TValue* %136 to i64*
  store i64 %134, i64* %137, align 8, !tbaa !21
  %138 = getelementptr inbounds %struct.TValue, %struct.TValue* %136, i64 0, i32 1
  store i8 35, i8* %138, align 8, !tbaa !22
  %139 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %140 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 1
  store %union.StackValue* %140, %union.StackValue** %9, align 8, !tbaa !20
  %141 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %141, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.386, i64 0, i64 0)) #17
  %142 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 8
  %143 = load i32, i32* %142, align 8, !tbaa !121
  %144 = sext i32 %143 to i64
  %145 = load %struct.TValue*, %struct.TValue** %135, align 8, !tbaa !20
  %146 = bitcast %struct.TValue* %145 to i64*
  store i64 %144, i64* %146, align 8, !tbaa !21
  %147 = getelementptr inbounds %struct.TValue, %struct.TValue* %145, i64 0, i32 1
  store i8 35, i8* %147, align 8, !tbaa !22
  %148 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %149 = getelementptr inbounds %union.StackValue, %union.StackValue* %148, i64 1
  store %union.StackValue* %149, %union.StackValue** %9, align 8, !tbaa !20
  %150 = getelementptr inbounds %union.StackValue, %union.StackValue* %148, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %150, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.387, i64 0, i64 0)) #17
  %151 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 3
  %152 = load i8*, i8** %151, align 8, !tbaa !126
  %153 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %152) #17
  %154 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %155 = getelementptr inbounds %union.StackValue, %union.StackValue* %154, i64 -2, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %155, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.388, i64 0, i64 0)) #17
  br label %156

; <label>:156:                                    ; preds = %117, %120
  %157 = call i8* @strchr(i8* %112, i32 108) #21
  %158 = icmp eq i8* %157, null
  br i1 %158, label %170, label %159

; <label>:159:                                    ; preds = %156
  %160 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 6
  %161 = load i32, i32* %160, align 8, !tbaa !127
  %162 = sext i32 %161 to i64
  %163 = bitcast %union.StackValue** %9 to %struct.TValue**
  %164 = load %struct.TValue*, %struct.TValue** %163, align 8, !tbaa !20
  %165 = bitcast %struct.TValue* %164 to i64*
  store i64 %162, i64* %165, align 8, !tbaa !21
  %166 = getelementptr inbounds %struct.TValue, %struct.TValue* %164, i64 0, i32 1
  store i8 35, i8* %166, align 8, !tbaa !22
  %167 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %168 = getelementptr inbounds %union.StackValue, %union.StackValue* %167, i64 1
  store %union.StackValue* %168, %union.StackValue** %9, align 8, !tbaa !20
  %169 = getelementptr inbounds %union.StackValue, %union.StackValue* %167, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %169, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.389, i64 0, i64 0)) #17
  br label %170

; <label>:170:                                    ; preds = %156, %159
  %171 = call i8* @strchr(i8* %112, i32 117) #21
  %172 = icmp eq i8* %171, null
  br i1 %172, label %203, label %173

; <label>:173:                                    ; preds = %170
  %174 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 9
  %175 = load i8, i8* %174, align 4, !tbaa !128
  %176 = zext i8 %175 to i64
  %177 = bitcast %union.StackValue** %9 to %struct.TValue**
  %178 = load %struct.TValue*, %struct.TValue** %177, align 8, !tbaa !20
  %179 = bitcast %struct.TValue* %178 to i64*
  store i64 %176, i64* %179, align 8, !tbaa !21
  %180 = getelementptr inbounds %struct.TValue, %struct.TValue* %178, i64 0, i32 1
  store i8 35, i8* %180, align 8, !tbaa !22
  %181 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %182 = getelementptr inbounds %union.StackValue, %union.StackValue* %181, i64 1
  store %union.StackValue* %182, %union.StackValue** %9, align 8, !tbaa !20
  %183 = getelementptr inbounds %union.StackValue, %union.StackValue* %181, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %183, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.390, i64 0, i64 0)) #17
  %184 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 10
  %185 = load i8, i8* %184, align 1, !tbaa !130
  %186 = zext i8 %185 to i64
  %187 = load %struct.TValue*, %struct.TValue** %177, align 8, !tbaa !20
  %188 = bitcast %struct.TValue* %187 to i64*
  store i64 %186, i64* %188, align 8, !tbaa !21
  %189 = getelementptr inbounds %struct.TValue, %struct.TValue* %187, i64 0, i32 1
  store i8 35, i8* %189, align 8, !tbaa !22
  %190 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %191 = getelementptr inbounds %union.StackValue, %union.StackValue* %190, i64 1
  store %union.StackValue* %191, %union.StackValue** %9, align 8, !tbaa !20
  %192 = getelementptr inbounds %union.StackValue, %union.StackValue* %190, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %192, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.391, i64 0, i64 0)) #17
  %193 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 11
  %194 = load i8, i8* %193, align 2, !tbaa !129
  %195 = load %struct.TValue*, %struct.TValue** %177, align 8, !tbaa !20
  %196 = icmp ne i8 %194, 0
  %197 = zext i1 %196 to i32
  %198 = bitcast %struct.TValue* %195 to i32*
  store i32 %197, i32* %198, align 8, !tbaa !21
  %199 = getelementptr inbounds %struct.TValue, %struct.TValue* %195, i64 0, i32 1
  store i8 1, i8* %199, align 8, !tbaa !22
  %200 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %201 = getelementptr inbounds %union.StackValue, %union.StackValue* %200, i64 1
  store %union.StackValue* %201, %union.StackValue** %9, align 8, !tbaa !20
  %202 = getelementptr inbounds %union.StackValue, %union.StackValue* %200, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %202, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.392, i64 0, i64 0)) #17
  br label %203

; <label>:203:                                    ; preds = %170, %173
  %204 = call i8* @strchr(i8* %112, i32 110) #21
  %205 = icmp eq i8* %204, null
  br i1 %205, label %217, label %206

; <label>:206:                                    ; preds = %203
  %207 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 1
  %208 = load i8*, i8** %207, align 8, !tbaa !202
  %209 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %208) #17
  %210 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %211 = getelementptr inbounds %union.StackValue, %union.StackValue* %210, i64 -2, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %211, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.393, i64 0, i64 0)) #17
  %212 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 2
  %213 = load i8*, i8** %212, align 8, !tbaa !133
  %214 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* %213) #17
  %215 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %216 = getelementptr inbounds %union.StackValue, %union.StackValue* %215, i64 -2, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %216, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.394, i64 0, i64 0)) #17
  br label %217

; <label>:217:                                    ; preds = %203, %206
  %218 = call i8* @strchr(i8* %112, i32 114) #21
  %219 = icmp eq i8* %218, null
  br i1 %219, label %240, label %220

; <label>:220:                                    ; preds = %217
  %221 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 13
  %222 = load i16, i16* %221, align 8, !tbaa !135
  %223 = zext i16 %222 to i64
  %224 = bitcast %union.StackValue** %9 to %struct.TValue**
  %225 = load %struct.TValue*, %struct.TValue** %224, align 8, !tbaa !20
  %226 = bitcast %struct.TValue* %225 to i64*
  store i64 %223, i64* %226, align 8, !tbaa !21
  %227 = getelementptr inbounds %struct.TValue, %struct.TValue* %225, i64 0, i32 1
  store i8 35, i8* %227, align 8, !tbaa !22
  %228 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %229 = getelementptr inbounds %union.StackValue, %union.StackValue* %228, i64 1
  store %union.StackValue* %229, %union.StackValue** %9, align 8, !tbaa !20
  %230 = getelementptr inbounds %union.StackValue, %union.StackValue* %228, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %230, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.395, i64 0, i64 0)) #17
  %231 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 14
  %232 = load i16, i16* %231, align 2, !tbaa !134
  %233 = zext i16 %232 to i64
  %234 = load %struct.TValue*, %struct.TValue** %224, align 8, !tbaa !20
  %235 = bitcast %struct.TValue* %234 to i64*
  store i64 %233, i64* %235, align 8, !tbaa !21
  %236 = getelementptr inbounds %struct.TValue, %struct.TValue* %234, i64 0, i32 1
  store i8 35, i8* %236, align 8, !tbaa !22
  %237 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %238 = getelementptr inbounds %union.StackValue, %union.StackValue* %237, i64 1
  store %union.StackValue* %238, %union.StackValue** %9, align 8, !tbaa !20
  %239 = getelementptr inbounds %union.StackValue, %union.StackValue* %237, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %239, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.396, i64 0, i64 0)) #17
  br label %240

; <label>:240:                                    ; preds = %217, %220
  %241 = call i8* @strchr(i8* %112, i32 116) #21
  %242 = icmp eq i8* %241, null
  br i1 %242, label %255, label %243

; <label>:243:                                    ; preds = %240
  %244 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 12
  %245 = load i8, i8* %244, align 1, !tbaa !132
  %246 = bitcast %union.StackValue** %9 to %struct.TValue**
  %247 = load %struct.TValue*, %struct.TValue** %246, align 8, !tbaa !20
  %248 = icmp ne i8 %245, 0
  %249 = zext i1 %248 to i32
  %250 = bitcast %struct.TValue* %247 to i32*
  store i32 %249, i32* %250, align 8, !tbaa !21
  %251 = getelementptr inbounds %struct.TValue, %struct.TValue* %247, i64 0, i32 1
  store i8 1, i8* %251, align 8, !tbaa !22
  %252 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %253 = getelementptr inbounds %union.StackValue, %union.StackValue* %252, i64 1
  store %union.StackValue* %253, %union.StackValue** %9, align 8, !tbaa !20
  %254 = getelementptr inbounds %union.StackValue, %union.StackValue* %252, i64 -1, i32 0
  call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %254, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.397, i64 0, i64 0)) #17
  br label %255

; <label>:255:                                    ; preds = %240, %243
  %256 = call i8* @strchr(i8* %112, i32 76) #21
  %257 = icmp eq i8* %256, null
  br i1 %257, label %259, label %258

; <label>:258:                                    ; preds = %255
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %41, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.398, i64 0, i64 0)) #16
  br label %259

; <label>:259:                                    ; preds = %255, %258
  %260 = call i8* @strchr(i8* %112, i32 102) #21
  %261 = icmp eq i8* %260, null
  br i1 %261, label %263, label %262

; <label>:262:                                    ; preds = %259
  call fastcc void @treatstackoption(%struct.lua_State* %0, %struct.lua_State* %41, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.399, i64 0, i64 0)) #16
  br label %263

; <label>:263:                                    ; preds = %262, %259, %115, %105
  %264 = phi i32 [ %116, %115 ], [ 1, %105 ], [ 1, %259 ], [ 1, %262 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %3) #7
  ret i32 %264
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getlocal(%struct.lua_State*) #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %15, %11
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 8
  br i1 %22, label %23, label %38

; <label>:23:                                     ; preds = %17
  br i1 %10, label %28, label %24

; <label>:24:                                     ; preds = %23
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %30

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %30

; <label>:30:                                     ; preds = %28, %24
  %31 = phi %struct.TValue* [ %27, %24 ], [ %29, %28 ]
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = icmp eq i8 %33, 72
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %30
  %36 = bitcast %struct.TValue* %31 to %struct.lua_State**
  %37 = load %struct.lua_State*, %struct.lua_State** %36, align 8, !tbaa !21
  br label %38

; <label>:38:                                     ; preds = %17, %30, %35
  %39 = phi i32 [ 1, %35 ], [ 1, %30 ], [ 0, %17 ]
  %40 = phi %struct.lua_State* [ %37, %35 ], [ null, %30 ], [ %0, %17 ]
  %41 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %41) #7
  %42 = or i32 %39, 2
  %43 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 %42) #16
  %44 = trunc i64 %43 to i32
  %45 = add nuw nsw i32 %39, 1
  %46 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %45) #17
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %46, i64 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !22
  %49 = and i8 %48, 15
  %50 = icmp eq i8 %49, 6
  br i1 %50, label %51, label %73

; <label>:51:                                     ; preds = %38
  %52 = bitcast %union.StackValue** %8 to %struct.TValue**
  %53 = load %struct.TValue*, %struct.TValue** %52, align 8, !tbaa !20
  %54 = bitcast %struct.TValue* %46 to i64*
  %55 = bitcast %struct.TValue* %53 to i64*
  %56 = load i64, i64* %54, align 8
  store i64 %56, i64* %55, align 8
  %57 = load i8, i8* %47, align 8, !tbaa !22
  %58 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  store i8 %57, i8* %58, align 8, !tbaa !22
  %59 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 1
  store %union.StackValue* %60, %union.StackValue** %8, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 0, i32 0, i32 1
  %62 = load i8, i8* %61, align 8, !tbaa !21
  %63 = icmp eq i8 %62, 86
  br i1 %63, label %64, label %70

; <label>:64:                                     ; preds = %51
  %65 = bitcast %union.StackValue* %59 to %struct.LClosure**
  %66 = load %struct.LClosure*, %struct.LClosure** %65, align 8, !tbaa !21
  %67 = getelementptr inbounds %struct.LClosure, %struct.LClosure* %66, i64 0, i32 5
  %68 = load %struct.Proto*, %struct.Proto** %67, align 8, !tbaa !21
  %69 = tail call fastcc i8* @luaF_getlocalname(%struct.Proto* %68, i32 %44, i32 0) #17
  br label %70

; <label>:70:                                     ; preds = %51, %64
  %71 = phi i8* [ %69, %64 ], [ null, %51 ]
  %72 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %71) #16
  br label %130

; <label>:73:                                     ; preds = %38
  %74 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 %45) #16
  %75 = trunc i64 %74 to i32
  %76 = icmp slt i32 %75, 0
  br i1 %76, label %100, label %77

; <label>:77:                                     ; preds = %73
  %78 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 8
  %79 = load %struct.CallInfo*, %struct.CallInfo** %78, align 8, !tbaa !54
  %80 = icmp ne i32 %75, 0
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 16
  %82 = icmp ne %struct.CallInfo* %79, %81
  %83 = and i1 %80, %82
  br i1 %83, label %84, label %94

; <label>:84:                                     ; preds = %77
  br label %85

; <label>:85:                                     ; preds = %84, %85
  %86 = phi %struct.CallInfo* [ %90, %85 ], [ %79, %84 ]
  %87 = phi i32 [ %88, %85 ], [ %75, %84 ]
  %88 = add nsw i32 %87, -1
  %89 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %86, i64 0, i32 2
  %90 = load %struct.CallInfo*, %struct.CallInfo** %89, align 8, !tbaa !54
  %91 = icmp sgt i32 %87, 1
  %92 = icmp ne %struct.CallInfo* %90, %81
  %93 = and i1 %91, %92
  br i1 %93, label %85, label %94

; <label>:94:                                     ; preds = %85, %77
  %95 = phi i32 [ %75, %77 ], [ %88, %85 ]
  %96 = phi %struct.CallInfo* [ %79, %77 ], [ %90, %85 ]
  %97 = icmp ne i32 %95, 0
  %98 = icmp eq %struct.CallInfo* %96, %81
  %99 = or i1 %97, %98
  br i1 %99, label %100, label %102

; <label>:100:                                    ; preds = %73, %94
  %101 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %45, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0)) #16
  br label %130

; <label>:102:                                    ; preds = %94
  %103 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %96, %struct.CallInfo** %103, align 8, !tbaa !106
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %40, i32 1) #16
  %104 = call i8* @lua_getlocal(%struct.lua_State* %40, %struct.lua_Debug* nonnull %2, i32 %44) #16
  %105 = icmp eq i8* %104, null
  br i1 %105, label %124, label %106

; <label>:106:                                    ; preds = %102
  %107 = icmp eq %struct.lua_State* %40, %0
  br i1 %107, label %122, label %108

; <label>:108:                                    ; preds = %106
  %109 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 6
  %110 = load %union.StackValue*, %union.StackValue** %109, align 8, !tbaa !20
  %111 = getelementptr inbounds %union.StackValue, %union.StackValue* %110, i64 -1
  store %union.StackValue* %111, %union.StackValue** %109, align 8, !tbaa !20
  %112 = bitcast %union.StackValue** %8 to %struct.TValue**
  %113 = load %struct.TValue*, %struct.TValue** %112, align 8, !tbaa !20
  %114 = bitcast %union.StackValue* %111 to i64*
  %115 = bitcast %struct.TValue* %113 to i64*
  %116 = load i64, i64* %114, align 8
  store i64 %116, i64* %115, align 8
  %117 = getelementptr inbounds %union.StackValue, %union.StackValue* %110, i64 -1, i32 0, i32 1
  %118 = load i8, i8* %117, align 8, !tbaa !22
  %119 = getelementptr inbounds %struct.TValue, %struct.TValue* %113, i64 0, i32 1
  store i8 %118, i8* %119, align 8, !tbaa !22
  %120 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %120, i64 1
  store %union.StackValue* %121, %union.StackValue** %8, align 8, !tbaa !20
  br label %122

; <label>:122:                                    ; preds = %108, %106
  %123 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %104) #16
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %130

; <label>:124:                                    ; preds = %102
  %125 = bitcast %union.StackValue** %8 to %struct.TValue**
  %126 = load %struct.TValue*, %struct.TValue** %125, align 8, !tbaa !20
  %127 = getelementptr inbounds %struct.TValue, %struct.TValue* %126, i64 0, i32 1
  store i8 0, i8* %127, align 8, !tbaa !21
  %128 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %129 = getelementptr inbounds %union.StackValue, %union.StackValue* %128, i64 1
  store %union.StackValue* %129, %union.StackValue** %8, align 8, !tbaa !20
  br label %130

; <label>:130:                                    ; preds = %100, %122, %124, %70
  %131 = phi i32 [ 1, %70 ], [ 2, %122 ], [ 1, %124 ], [ %101, %100 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %41) #7
  ret i32 %131
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal i32 @db_getregistry(%struct.lua_State* nocapture) #2 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to %struct.TValue**
  %4 = load %struct.TValue*, %struct.TValue** %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 7
  %8 = bitcast %struct.TValue* %7 to i64*
  %9 = bitcast %struct.TValue* %4 to i64*
  %10 = load i64, i64* %8, align 8
  store i64 %10, i64* %9, align 8
  %11 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 7, i32 1
  %12 = load i8, i8* %11, align 8, !tbaa !22
  %13 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  store i8 %12, i8* %13, align 8, !tbaa !22
  %14 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  store %union.StackValue* %15, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getmetatable(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 1) #16
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %11

; <label>:11:                                     ; preds = %1, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_getupvalue(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_upvaluejoin(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 3, i32 4) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  switch i8 %21, label %28 [
    i8 118, label %22
    i8 38, label %22
  ]

; <label>:22:                                     ; preds = %18, %18
  %23 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0)) #16
  %24 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %25 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %24, i64 0, i32 0
  %26 = load %union.StackValue*, %union.StackValue** %25, align 8, !tbaa !64
  %27 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  br label %28

; <label>:28:                                     ; preds = %18, %22
  %29 = phi %union.StackValue* [ %10, %18 ], [ %27, %22 ]
  %30 = phi %union.StackValue* [ %7, %18 ], [ %26, %22 ]
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 3
  %32 = icmp ult %union.StackValue* %31, %29
  br i1 %32, label %37, label %33

; <label>:33:                                     ; preds = %28
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %35 = load %struct.global_State*, %struct.global_State** %34, align 8, !tbaa !2
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %35, i64 0, i32 8
  br label %39

; <label>:37:                                     ; preds = %28
  %38 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 0, i32 0
  br label %39

; <label>:39:                                     ; preds = %33, %37
  %40 = phi %struct.TValue* [ %36, %33 ], [ %38, %37 ]
  %41 = getelementptr inbounds %struct.TValue, %struct.TValue* %40, i64 0, i32 1
  %42 = load i8, i8* %41, align 8, !tbaa !22
  switch i8 %42, label %45 [
    i8 118, label %43
    i8 38, label %43
  ]

; <label>:43:                                     ; preds = %39, %39
  %44 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.401, i64 0, i64 0)) #16
  br label %45

; <label>:45:                                     ; preds = %39, %43
  tail call void @lua_upvaluejoin(%struct.lua_State* nonnull %0, i32 1, i32 %2, i32 3, i32 %3) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_upvalueid(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @checkupval(%struct.lua_State* %0, i32 1, i32 2) #16
  %3 = tail call i8* @lua_upvalueid(%struct.lua_State* %0, i32 1, i32 %2) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to i8**
  store i8* %3, i8** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 2, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setuservalue(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %3 = trunc i64 %2 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 7) #16
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 2) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %4 = tail call i32 @lua_setiuservalue(%struct.lua_State* %0, i32 1, i32 %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %13

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %10, align 8, !tbaa !21
  %11 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %7, align 8, !tbaa !20
  br label %13

; <label>:13:                                     ; preds = %1, %6
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_sethook(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %14, %10
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 8
  br i1 %21, label %22, label %37

; <label>:22:                                     ; preds = %16
  br i1 %9, label %27, label %23

; <label>:23:                                     ; preds = %22
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  br label %29

; <label>:27:                                     ; preds = %22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %29

; <label>:29:                                     ; preds = %27, %23
  %30 = phi %struct.TValue* [ %26, %23 ], [ %28, %27 ]
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = icmp eq i8 %32, 72
  br i1 %33, label %34, label %37

; <label>:34:                                     ; preds = %29
  %35 = bitcast %struct.TValue* %30 to %struct.lua_State**
  %36 = load %struct.lua_State*, %struct.lua_State** %35, align 8, !tbaa !21
  br label %37

; <label>:37:                                     ; preds = %16, %29, %34
  %38 = phi i32 [ 1, %34 ], [ 1, %29 ], [ 0, %16 ]
  %39 = phi %struct.lua_State* [ %36, %34 ], [ null, %29 ], [ %0, %16 ]
  %40 = add nuw nsw i32 %38, 1
  %41 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %40) #17
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %41, i64 0, i32 1
  %43 = load i8, i8* %42, align 8, !tbaa !22
  %44 = and i8 %43, 15
  %45 = icmp eq i8 %44, 0
  br i1 %45, label %46, label %47

; <label>:46:                                     ; preds = %37
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 %40) #16
  br label %67

; <label>:47:                                     ; preds = %37
  %48 = or i32 %38, 2
  %49 = tail call i8* @luaL_checklstring(%struct.lua_State* nonnull %0, i32 %48, i64* null) #16
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 %40, i32 6) #16
  %50 = add nuw nsw i32 %38, 3
  %51 = tail call i64 @luaL_optinteger(%struct.lua_State* nonnull %0, i32 %50, i64 0) #16
  %52 = trunc i64 %51 to i32
  %53 = tail call i8* @strchr(i8* %49, i32 99) #21
  %54 = icmp ne i8* %53, null
  %55 = zext i1 %54 to i32
  %56 = tail call i8* @strchr(i8* %49, i32 114) #21
  %57 = icmp eq i8* %56, null
  %58 = or i32 %55, 2
  %59 = select i1 %57, i32 %55, i32 %58
  %60 = tail call i8* @strchr(i8* %49, i32 108) #21
  %61 = icmp eq i8* %60, null
  %62 = or i32 %59, 4
  %63 = select i1 %61, i32 %59, i32 %62
  %64 = icmp sgt i32 %52, 0
  %65 = or i32 %63, 8
  %66 = select i1 %64, i32 %65, i32 %63
  br label %67

; <label>:67:                                     ; preds = %47, %46
  %68 = phi void (%struct.lua_State*, %struct.lua_Debug*)* [ null, %46 ], [ @hookf, %47 ]
  %69 = phi i32 [ 0, %46 ], [ %52, %47 ]
  %70 = phi i32 [ 0, %46 ], [ %66, %47 ]
  %71 = tail call i32 @lua_rawgetp(%struct.lua_State* nonnull %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %73, label %99

; <label>:73:                                     ; preds = %67
  tail call void @lua_createtable(%struct.lua_State* nonnull %0, i32 0, i32 2) #16
  %74 = bitcast %union.StackValue** %7 to %struct.TValue**
  %75 = load %struct.TValue*, %struct.TValue** %74, align 8, !tbaa !20
  %76 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 -1
  %77 = bitcast %struct.TValue* %76 to i64*
  %78 = bitcast %struct.TValue* %75 to i64*
  %79 = load i64, i64* %77, align 8
  store i64 %79, i64* %78, align 8
  %80 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 -1, i32 1
  %81 = load i8, i8* %80, align 8, !tbaa !22
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 1
  store i8 %81, i8* %82, align 8, !tbaa !22
  %83 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 1
  store %union.StackValue* %84, %union.StackValue** %7, align 8, !tbaa !20
  tail call void @lua_rawsetp(%struct.lua_State* nonnull %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %85 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.403, i64 0, i64 0)) #16
  %86 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %87 = getelementptr inbounds %union.StackValue, %union.StackValue* %86, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %87, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.82, i64 0, i64 0)) #17
  %88 = load %struct.TValue*, %struct.TValue** %74, align 8, !tbaa !20
  %89 = getelementptr inbounds %struct.TValue, %struct.TValue* %88, i64 -1
  %90 = bitcast %struct.TValue* %89 to i64*
  %91 = bitcast %struct.TValue* %88 to i64*
  %92 = load i64, i64* %90, align 8
  store i64 %92, i64* %91, align 8
  %93 = getelementptr inbounds %struct.TValue, %struct.TValue* %88, i64 -1, i32 1
  %94 = load i8, i8* %93, align 8, !tbaa !22
  %95 = getelementptr inbounds %struct.TValue, %struct.TValue* %88, i64 0, i32 1
  store i8 %94, i8* %95, align 8, !tbaa !22
  %96 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %97 = getelementptr inbounds %union.StackValue, %union.StackValue* %96, i64 1
  store %union.StackValue* %97, %union.StackValue** %7, align 8, !tbaa !20
  %98 = tail call i32 @lua_setmetatable(%struct.lua_State* nonnull %0, i32 -2) #16
  br label %99

; <label>:99:                                     ; preds = %73, %67
  tail call fastcc void @checkstack(%struct.lua_State* nonnull %0, %struct.lua_State* %39, i32 1) #16
  %100 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %39, i64 0, i32 6
  %101 = bitcast %union.StackValue** %100 to %struct.TValue**
  %102 = load %struct.TValue*, %struct.TValue** %101, align 8, !tbaa !20
  %103 = bitcast %struct.TValue* %102 to %struct.lua_State**
  store %struct.lua_State* %39, %struct.lua_State** %103, align 8, !tbaa !21
  %104 = getelementptr inbounds %struct.TValue, %struct.TValue* %102, i64 0, i32 1
  store i8 72, i8* %104, align 8, !tbaa !22
  %105 = load %union.StackValue*, %union.StackValue** %100, align 8, !tbaa !20
  %106 = getelementptr inbounds %union.StackValue, %union.StackValue* %105, i64 1
  store %union.StackValue* %106, %union.StackValue** %100, align 8, !tbaa !20
  %107 = icmp eq %struct.lua_State* %39, %0
  br i1 %107, label %108, label %111

; <label>:108:                                    ; preds = %99
  %109 = bitcast %union.StackValue** %7 to %struct.TValue**
  %110 = load %struct.TValue*, %struct.TValue** %109, align 8, !tbaa !20
  br label %123

; <label>:111:                                    ; preds = %99
  store %union.StackValue* %105, %union.StackValue** %100, align 8, !tbaa !20
  %112 = bitcast %union.StackValue** %7 to %struct.TValue**
  %113 = load %struct.TValue*, %struct.TValue** %112, align 8, !tbaa !20
  %114 = bitcast %union.StackValue* %105 to i64*
  %115 = bitcast %struct.TValue* %113 to i64*
  %116 = load i64, i64* %114, align 8
  store i64 %116, i64* %115, align 8
  %117 = getelementptr inbounds %union.StackValue, %union.StackValue* %105, i64 0, i32 0, i32 1
  %118 = load i8, i8* %117, align 8, !tbaa !22
  %119 = getelementptr inbounds %struct.TValue, %struct.TValue* %113, i64 0, i32 1
  store i8 %118, i8* %119, align 8, !tbaa !22
  %120 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %120, i64 1
  store %union.StackValue* %121, %union.StackValue** %7, align 8, !tbaa !20
  %122 = getelementptr inbounds %union.StackValue, %union.StackValue* %121, i64 0, i32 0
  br label %123

; <label>:123:                                    ; preds = %108, %111
  %124 = phi %struct.TValue* [ %110, %108 ], [ %122, %111 ]
  %125 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %40) #17
  %126 = bitcast %struct.TValue* %125 to i64*
  %127 = bitcast %struct.TValue* %124 to i64*
  %128 = load i64, i64* %126, align 8
  store i64 %128, i64* %127, align 8
  %129 = getelementptr inbounds %struct.TValue, %struct.TValue* %125, i64 0, i32 1
  %130 = load i8, i8* %129, align 8, !tbaa !22
  %131 = getelementptr inbounds %struct.TValue, %struct.TValue* %124, i64 0, i32 1
  store i8 %130, i8* %131, align 8, !tbaa !22
  %132 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %133 = getelementptr inbounds %union.StackValue, %union.StackValue* %132, i64 1
  store %union.StackValue* %133, %union.StackValue** %7, align 8, !tbaa !20
  tail call void @lua_rawset(%struct.lua_State* nonnull %0, i32 -3) #16
  tail call void @lua_sethook(%struct.lua_State* nonnull %39, void (%struct.lua_State*, %struct.lua_Debug*)* %68, i32 %70, i32 %69) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setlocal(%struct.lua_State*) #0 {
  %2 = alloca %struct.lua_Debug, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %15, %11
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 8
  br i1 %22, label %23, label %38

; <label>:23:                                     ; preds = %17
  br i1 %10, label %28, label %24

; <label>:24:                                     ; preds = %23
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %30

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %30

; <label>:30:                                     ; preds = %28, %24
  %31 = phi %struct.TValue* [ %27, %24 ], [ %29, %28 ]
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = icmp eq i8 %33, 72
  br i1 %34, label %35, label %38

; <label>:35:                                     ; preds = %30
  %36 = bitcast %struct.TValue* %31 to %struct.lua_State**
  %37 = load %struct.lua_State*, %struct.lua_State** %36, align 8, !tbaa !21
  br label %38

; <label>:38:                                     ; preds = %17, %30, %35
  %39 = phi i32 [ 1, %35 ], [ 1, %30 ], [ 0, %17 ]
  %40 = phi %struct.lua_State* [ %37, %35 ], [ null, %30 ], [ %0, %17 ]
  %41 = bitcast %struct.lua_Debug* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 136, i8* nonnull %41) #7
  %42 = add nuw nsw i32 %39, 1
  %43 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 %42) #16
  %44 = trunc i64 %43 to i32
  %45 = or i32 %39, 2
  %46 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 %45) #16
  %47 = icmp slt i32 %44, 0
  br i1 %47, label %71, label %48

; <label>:48:                                     ; preds = %38
  %49 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 8
  %50 = load %struct.CallInfo*, %struct.CallInfo** %49, align 8, !tbaa !54
  %51 = icmp ne i32 %44, 0
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 16
  %53 = icmp ne %struct.CallInfo* %50, %52
  %54 = and i1 %51, %53
  br i1 %54, label %55, label %65

; <label>:55:                                     ; preds = %48
  br label %56

; <label>:56:                                     ; preds = %55, %56
  %57 = phi %struct.CallInfo* [ %61, %56 ], [ %50, %55 ]
  %58 = phi i32 [ %59, %56 ], [ %44, %55 ]
  %59 = add nsw i32 %58, -1
  %60 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %57, i64 0, i32 2
  %61 = load %struct.CallInfo*, %struct.CallInfo** %60, align 8, !tbaa !54
  %62 = icmp sgt i32 %58, 1
  %63 = icmp ne %struct.CallInfo* %61, %52
  %64 = and i1 %62, %63
  br i1 %64, label %56, label %65

; <label>:65:                                     ; preds = %56, %48
  %66 = phi i32 [ %44, %48 ], [ %59, %56 ]
  %67 = phi %struct.CallInfo* [ %50, %48 ], [ %61, %56 ]
  %68 = icmp ne i32 %66, 0
  %69 = icmp eq %struct.CallInfo* %67, %52
  %70 = or i1 %68, %69
  br i1 %70, label %71, label %73

; <label>:71:                                     ; preds = %38, %65
  %72 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %42, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.400, i64 0, i64 0)) #16
  br label %102

; <label>:73:                                     ; preds = %65
  %74 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %2, i64 0, i32 16
  store %struct.CallInfo* %67, %struct.CallInfo** %74, align 8, !tbaa !106
  %75 = trunc i64 %46 to i32
  %76 = add nuw nsw i32 %39, 3
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 %76) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 %76) #16
  tail call fastcc void @checkstack(%struct.lua_State* %0, %struct.lua_State* %40, i32 1) #16
  %77 = icmp eq %struct.lua_State* %40, %0
  br i1 %77, label %92, label %78

; <label>:78:                                     ; preds = %73
  %79 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %79, i64 -1
  store %union.StackValue* %80, %union.StackValue** %8, align 8, !tbaa !20
  %81 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 6
  %82 = bitcast %union.StackValue** %81 to %struct.TValue**
  %83 = load %struct.TValue*, %struct.TValue** %82, align 8, !tbaa !20
  %84 = bitcast %union.StackValue* %80 to i64*
  %85 = bitcast %struct.TValue* %83 to i64*
  %86 = load i64, i64* %84, align 8
  store i64 %86, i64* %85, align 8
  %87 = getelementptr inbounds %union.StackValue, %union.StackValue* %79, i64 -1, i32 0, i32 1
  %88 = load i8, i8* %87, align 8, !tbaa !22
  %89 = getelementptr inbounds %struct.TValue, %struct.TValue* %83, i64 0, i32 1
  store i8 %88, i8* %89, align 8, !tbaa !22
  %90 = load %union.StackValue*, %union.StackValue** %81, align 8, !tbaa !20
  %91 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 1
  store %union.StackValue* %91, %union.StackValue** %81, align 8, !tbaa !20
  br label %92

; <label>:92:                                     ; preds = %78, %73
  %93 = call i8* @lua_setlocal(%struct.lua_State* %40, %struct.lua_Debug* nonnull %2, i32 %75) #16
  %94 = icmp eq i8* %93, null
  br i1 %94, label %95, label %100

; <label>:95:                                     ; preds = %92
  %96 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %40, i64 0, i32 6
  %97 = load %union.StackValue*, %union.StackValue** %96, align 8, !tbaa !20
  %98 = getelementptr inbounds %union.StackValue, %union.StackValue* %97, i64 -1
  store %union.StackValue* %98, %union.StackValue** %96, align 8, !tbaa !20
  %99 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %40, %union.StackValue* nonnull %98, i32 0) #17
  br label %100

; <label>:100:                                    ; preds = %95, %92
  %101 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %93) #16
  br label %102

; <label>:102:                                    ; preds = %100, %71
  %103 = phi i32 [ 1, %100 ], [ %72, %71 ]
  call void @llvm.lifetime.end.p0i8(i64 136, i8* nonnull %41) #7
  ret i32 %103
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setmetatable(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %27

; <label>:22:                                     ; preds = %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 8
  %26 = icmp eq %struct.TValue* %17, %25
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %16, %22
  %28 = trunc i8 %19 to i4
  switch i4 %28, label %29 [
    i4 5, label %31
    i4 0, label %31
  ]

; <label>:29:                                     ; preds = %22, %27
  %30 = tail call i32 @luaL_typeerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.343, i64 0, i64 0)) #16
  br label %31

; <label>:31:                                     ; preds = %27, %27, %29
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 2) #16
  %32 = tail call i32 @lua_setmetatable(%struct.lua_State* nonnull %0, i32 1) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_setupvalue(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 3) #16
  %2 = tail call fastcc i32 @auxupvalue(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @db_traceback(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %14, %10
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 8
  br i1 %21, label %22, label %37

; <label>:22:                                     ; preds = %16
  br i1 %9, label %27, label %23

; <label>:23:                                     ; preds = %22
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  br label %29

; <label>:27:                                     ; preds = %22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %29

; <label>:29:                                     ; preds = %27, %23
  %30 = phi %struct.TValue* [ %26, %23 ], [ %28, %27 ]
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = icmp eq i8 %32, 72
  br i1 %33, label %34, label %37

; <label>:34:                                     ; preds = %29
  %35 = bitcast %struct.TValue* %30 to %struct.lua_State**
  %36 = load %struct.lua_State*, %struct.lua_State** %35, align 8, !tbaa !21
  br label %37

; <label>:37:                                     ; preds = %16, %29, %34
  %38 = phi i32 [ 1, %34 ], [ 1, %29 ], [ 0, %16 ]
  %39 = phi %struct.lua_State* [ %36, %34 ], [ null, %29 ], [ %0, %16 ]
  %40 = add nuw nsw i32 %38, 1
  %41 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 %40, i64* null) #16
  %42 = icmp eq i8* %41, null
  br i1 %42, label %43, label %59

; <label>:43:                                     ; preds = %37
  %44 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %40) #17
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %44, i64 0, i32 1
  %46 = load i8, i8* %45, align 8, !tbaa !22
  %47 = and i8 %46, 15
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %59, label %49

; <label>:49:                                     ; preds = %43
  %50 = bitcast %union.StackValue** %7 to %struct.TValue**
  %51 = load %struct.TValue*, %struct.TValue** %50, align 8, !tbaa !20
  %52 = bitcast %struct.TValue* %44 to i64*
  %53 = bitcast %struct.TValue* %51 to i64*
  %54 = load i64, i64* %52, align 8
  store i64 %54, i64* %53, align 8
  %55 = load i8, i8* %45, align 8, !tbaa !22
  %56 = getelementptr inbounds %struct.TValue, %struct.TValue* %51, i64 0, i32 1
  store i8 %55, i8* %56, align 8, !tbaa !22
  %57 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 1
  store %union.StackValue* %58, %union.StackValue** %7, align 8, !tbaa !20
  br label %65

; <label>:59:                                     ; preds = %43, %37
  %60 = or i32 %38, 2
  %61 = icmp eq %struct.lua_State* %39, %0
  %62 = zext i1 %61 to i64
  %63 = tail call i64 @luaL_optinteger(%struct.lua_State* nonnull %0, i32 %60, i64 %62) #16
  %64 = trunc i64 %63 to i32
  tail call void @luaL_traceback(%struct.lua_State* nonnull %0, %struct.lua_State* %39, i8* %41, i32 %64) #16
  br label %65

; <label>:65:                                     ; preds = %59, %49
  ret i32 1
}

; Function Attrs: nounwind optsize
declare i8* @fgets(i8*, i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal void @hookf(%struct.lua_State*, %struct.lua_Debug* nocapture readonly) #0 {
  %3 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @HOOKKEY to i8*)) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 72, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  %11 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #16
  %12 = icmp eq i32 %11, 6
  br i1 %12, label %13, label %36

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 0
  %15 = load i32, i32* %14, align 8, !tbaa !242
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds [5 x i8*], [5 x i8*]* @hookf.hooknames, i64 0, i64 %16
  %18 = load i8*, i8** %17, align 8, !tbaa !54
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %18) #16
  %20 = getelementptr inbounds %struct.lua_Debug, %struct.lua_Debug* %1, i64 0, i32 6
  %21 = load i32, i32* %20, align 8, !tbaa !127
  %22 = icmp sgt i32 %21, -1
  br i1 %22, label %23, label %27

; <label>:23:                                     ; preds = %13
  %24 = sext i32 %21 to i64
  %25 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %26 = bitcast %struct.TValue* %25 to i64*
  store i64 %24, i64* %26, align 8, !tbaa !21
  br label %29

; <label>:27:                                     ; preds = %13
  %28 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  br label %29

; <label>:29:                                     ; preds = %27, %23
  %30 = phi %struct.TValue* [ %28, %27 ], [ %25, %23 ]
  %31 = phi i8 [ 0, %27 ], [ 35, %23 ]
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  store i8 %31, i8* %32, align 8, !tbaa !21
  %33 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1
  store %union.StackValue* %34, %union.StackValue** %4, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %35, i32 0) #17
  br label %36

; <label>:36:                                     ; preds = %29, %2
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checkstack(%struct.lua_State*, %struct.lua_State*, i32) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %10, label %5

; <label>:5:                                      ; preds = %3
  %6 = tail call i32 @lua_checkstack(%struct.lua_State* %1, i32 %2) #16
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %5
  %9 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.29, i64 0, i64 0)) #16
  unreachable

; <label>:10:                                     ; preds = %5, %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @treatstackoption(%struct.lua_State*, %struct.lua_State*, i8*) unnamed_addr #0 {
  %4 = icmp eq %struct.lua_State* %0, %1
  br i1 %4, label %5, label %8

; <label>:5:                                      ; preds = %3
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  br label %23

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %1, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1
  store %union.StackValue* %11, %union.StackValue** %9, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %13 = bitcast %union.StackValue** %12 to %struct.TValue**
  %14 = load %struct.TValue*, %struct.TValue** %13, align 8, !tbaa !20
  %15 = bitcast %union.StackValue* %11 to i64*
  %16 = bitcast %struct.TValue* %14 to i64*
  %17 = load i64, i64* %15, align 8
  store i64 %17, i64* %16, align 8
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -1, i32 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %14, i64 0, i32 1
  store i8 %19, i8* %20, align 8, !tbaa !22
  %21 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  store %union.StackValue* %22, %union.StackValue** %12, align 8, !tbaa !20
  br label %23

; <label>:23:                                     ; preds = %8, %5
  %24 = phi %union.StackValue* [ %22, %8 ], [ %7, %5 ]
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -2, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %25, i8* %2) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @auxupvalue(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %4 = trunc i64 %3 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 1, i32 6) #16
  %5 = icmp eq i32 %1, 0
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %2
  %7 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 1, i32 %4) #16
  br label %10

; <label>:8:                                      ; preds = %2
  %9 = tail call i8* @lua_setupvalue(%struct.lua_State* %0, i32 1, i32 %4) #16
  br label %10

; <label>:10:                                     ; preds = %8, %6
  %11 = phi i8* [ %7, %6 ], [ %9, %8 ]
  %12 = icmp eq i8* %11, null
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %10
  %14 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11) #16
  %15 = add nsw i32 %1, 1
  %16 = xor i32 %1, -1
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 1) #16
  br label %17

; <label>:17:                                     ; preds = %10, %13
  %18 = phi i32 [ %15, %13 ], [ 0, %10 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @checkupval(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %2) #16
  %5 = trunc i64 %4 to i32
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 6) #16
  %6 = tail call i8* @lua_getupvalue(%struct.lua_State* %0, i32 %1, i32 %5) #16
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %3
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.402, i64 0, i64 0)) #16
  br label %10

; <label>:10:                                     ; preds = %3, %8
  ret i32 %5
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_close(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %31

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  %27 = icmp eq %struct.TValue* %18, %26
  br i1 %27, label %28, label %31

; <label>:28:                                     ; preds = %23
  %29 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 7
  %30 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %29, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #17
  br label %31

; <label>:31:                                     ; preds = %17, %23, %28
  %32 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* nonnull %0) #17
  %33 = tail call i8* @luaL_checkudata(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %34 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %34)
  %35 = getelementptr inbounds i8, i8* %33, i64 8
  %36 = bitcast i8* %35 to i32 (%struct.lua_State*)**
  %37 = bitcast i8* %35 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !217
  store volatile i64 %38, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %36, align 8, !tbaa !217
  %39 = load volatile i64, i64* %2, align 8
  %40 = inttoptr i64 %39 to i32 (%struct.lua_State*)*
  %41 = tail call i32 %40(%struct.lua_State* nonnull %0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %34)
  ret i32 %41
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #16
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2) #16
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null) #16
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_input(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_lines(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %35

; <label>:22:                                     ; preds = %16
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 8
  %26 = icmp eq %struct.TValue* %17, %25
  br i1 %26, label %27, label %35

; <label>:27:                                     ; preds = %22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0, i32 1
  store i8 0, i8* %28, align 8, !tbaa !21
  %29 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %7, align 8, !tbaa !20
  %31 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 0
  %33 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !64
  %34 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1
  br label %35

; <label>:35:                                     ; preds = %16, %22, %27
  %36 = phi %union.StackValue* [ %6, %16 ], [ %6, %22 ], [ %34, %27 ]
  %37 = phi %union.StackValue* [ %8, %16 ], [ %8, %22 ], [ %30, %27 ]
  %38 = icmp ult %union.StackValue* %36, %37
  br i1 %38, label %43, label %39

; <label>:39:                                     ; preds = %35
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %41 = load %struct.global_State*, %struct.global_State** %40, align 8, !tbaa !2
  %42 = getelementptr inbounds %struct.global_State, %struct.global_State* %41, i64 0, i32 8
  br label %45

; <label>:43:                                     ; preds = %35
  %44 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 0, i32 0
  br label %45

; <label>:45:                                     ; preds = %39, %43
  %46 = phi %struct.TValue* [ %42, %39 ], [ %44, %43 ]
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %46, i64 0, i32 1
  %48 = load i8, i8* %47, align 8, !tbaa !22
  %49 = and i8 %48, 15
  %50 = icmp eq i8 %49, 0
  br i1 %50, label %51, label %83

; <label>:51:                                     ; preds = %45
  %52 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %53 = load %struct.global_State*, %struct.global_State** %52, align 8, !tbaa !2
  %54 = getelementptr inbounds %struct.global_State, %struct.global_State* %53, i64 0, i32 8
  %55 = icmp eq %struct.TValue* %46, %54
  br i1 %55, label %83, label %56

; <label>:56:                                     ; preds = %51
  %57 = getelementptr inbounds %struct.global_State, %struct.global_State* %53, i64 0, i32 7
  %58 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %57, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0)) #17
  %59 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 -1, i32 0
  %61 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %62 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %61, i64 0, i32 0
  %63 = load %union.StackValue*, %union.StackValue** %62, align 8, !tbaa !64
  %64 = getelementptr inbounds %union.StackValue, %union.StackValue* %63, i64 1
  %65 = icmp ult %union.StackValue* %64, %59
  br i1 %65, label %69, label %66

; <label>:66:                                     ; preds = %56
  %67 = load %struct.global_State*, %struct.global_State** %52, align 8, !tbaa !2
  %68 = getelementptr inbounds %struct.global_State, %struct.global_State* %67, i64 0, i32 8
  br label %71

; <label>:69:                                     ; preds = %56
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 0, i32 0
  br label %71

; <label>:71:                                     ; preds = %69, %66
  %72 = phi %struct.TValue* [ %68, %66 ], [ %70, %69 ]
  %73 = bitcast %struct.TValue* %60 to i64*
  %74 = bitcast %struct.TValue* %72 to i64*
  %75 = load i64, i64* %73, align 8
  store i64 %75, i64* %74, align 8
  %76 = getelementptr inbounds %union.StackValue, %union.StackValue* %59, i64 -1, i32 0, i32 1
  %77 = load i8, i8* %76, align 8, !tbaa !22
  %78 = getelementptr inbounds %struct.TValue, %struct.TValue* %72, i64 0, i32 1
  store i8 %77, i8* %78, align 8, !tbaa !22
  %79 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %79, i64 -1
  store %union.StackValue* %80, %union.StackValue** %7, align 8, !tbaa !20
  %81 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %80, i32 0) #17
  %82 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* nonnull %0) #16
  tail call fastcc void @aux_lines(%struct.lua_State* nonnull %0, i32 0) #16
  br label %137

; <label>:83:                                     ; preds = %45, %51
  %84 = tail call i8* @luaL_checklstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  tail call fastcc void @opencheck(%struct.lua_State* nonnull %0, i8* %84, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #16
  %85 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %86 = getelementptr inbounds %union.StackValue, %union.StackValue* %85, i64 -1, i32 0
  %87 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %88 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %87, i64 0, i32 0
  %89 = load %union.StackValue*, %union.StackValue** %88, align 8, !tbaa !64
  %90 = getelementptr inbounds %union.StackValue, %union.StackValue* %89, i64 1
  %91 = icmp ult %union.StackValue* %90, %85
  br i1 %91, label %96, label %92

; <label>:92:                                     ; preds = %83
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %94 = load %struct.global_State*, %struct.global_State** %93, align 8, !tbaa !2
  %95 = getelementptr inbounds %struct.global_State, %struct.global_State* %94, i64 0, i32 8
  br label %98

; <label>:96:                                     ; preds = %83
  %97 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 0, i32 0
  br label %98

; <label>:98:                                     ; preds = %92, %96
  %99 = phi %struct.TValue* [ %95, %92 ], [ %97, %96 ]
  %100 = bitcast %struct.TValue* %86 to i64*
  %101 = bitcast %struct.TValue* %99 to i64*
  %102 = load i64, i64* %100, align 8
  store i64 %102, i64* %101, align 8
  %103 = getelementptr inbounds %union.StackValue, %union.StackValue* %85, i64 -1, i32 0, i32 1
  %104 = load i8, i8* %103, align 8, !tbaa !22
  %105 = getelementptr inbounds %struct.TValue, %struct.TValue* %99, i64 0, i32 1
  store i8 %104, i8* %105, align 8, !tbaa !22
  %106 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %107 = getelementptr inbounds %union.StackValue, %union.StackValue* %106, i64 -1
  store %union.StackValue* %107, %union.StackValue** %7, align 8, !tbaa !20
  %108 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %107, i32 0) #17
  tail call fastcc void @aux_lines(%struct.lua_State* nonnull %0, i32 1) #16
  %109 = bitcast %union.StackValue** %7 to %struct.TValue**
  %110 = load %struct.TValue*, %struct.TValue** %109, align 8, !tbaa !20
  %111 = getelementptr inbounds %struct.TValue, %struct.TValue* %110, i64 0, i32 1
  store i8 0, i8* %111, align 8, !tbaa !21
  %112 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %113 = getelementptr inbounds %union.StackValue, %union.StackValue* %112, i64 1
  store %union.StackValue* %113, %union.StackValue** %7, align 8, !tbaa !20
  %114 = getelementptr inbounds %union.StackValue, %union.StackValue* %112, i64 1, i32 0, i32 1
  store i8 0, i8* %114, align 8, !tbaa !21
  %115 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %116 = getelementptr inbounds %union.StackValue, %union.StackValue* %115, i64 1
  store %union.StackValue* %116, %union.StackValue** %7, align 8, !tbaa !20
  %117 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %118 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %117, i64 0, i32 0
  %119 = load %union.StackValue*, %union.StackValue** %118, align 8, !tbaa !64
  %120 = icmp ult %union.StackValue* %119, %115
  br i1 %120, label %125, label %121

; <label>:121:                                    ; preds = %98
  %122 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %123 = load %struct.global_State*, %struct.global_State** %122, align 8, !tbaa !2
  %124 = getelementptr inbounds %struct.global_State, %struct.global_State* %123, i64 0, i32 8
  br label %127

; <label>:125:                                    ; preds = %98
  %126 = getelementptr inbounds %union.StackValue, %union.StackValue* %119, i64 1, i32 0
  br label %127

; <label>:127:                                    ; preds = %121, %125
  %128 = phi %struct.TValue* [ %124, %121 ], [ %126, %125 ]
  %129 = bitcast %struct.TValue* %128 to i64*
  %130 = bitcast %union.StackValue* %116 to i64*
  %131 = load i64, i64* %129, align 8
  store i64 %131, i64* %130, align 8
  %132 = getelementptr inbounds %struct.TValue, %struct.TValue* %128, i64 0, i32 1
  %133 = load i8, i8* %132, align 8, !tbaa !22
  %134 = getelementptr inbounds %union.StackValue, %union.StackValue* %115, i64 1, i32 0, i32 1
  store i8 %133, i8* %134, align 8, !tbaa !22
  %135 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %136 = getelementptr inbounds %union.StackValue, %union.StackValue* %135, i64 1
  store %union.StackValue* %136, %union.StackValue** %7, align 8, !tbaa !20
  br label %137

; <label>:137:                                    ; preds = %71, %127
  %138 = phi i32 [ 4, %127 ], [ 1, %71 ]
  ret i32 %138
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_open(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null) #16
  %4 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #17
  %5 = getelementptr inbounds i8, i8* %4, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %6, align 8, !tbaa !217
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 7
  %10 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %11 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  %12 = bitcast i8* %4 to %struct._IO_FILE**
  store %struct._IO_FILE* null, %struct._IO_FILE** %12, align 8, !tbaa !219
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %6, align 8, !tbaa !217
  %13 = load i8, i8* %3, align 1, !tbaa !21
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %28, label %15

; <label>:15:                                     ; preds = %1
  %16 = sext i8 %13 to i32
  %17 = getelementptr inbounds i8, i8* %3, i64 1
  %18 = tail call i8* @memchr(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.422, i64 0, i64 0), i32 %16, i64 4) #7
  %19 = icmp eq i8* %18, null
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %15
  %21 = load i8, i8* %17, align 1, !tbaa !21
  %22 = icmp eq i8 %21, 43
  %23 = getelementptr inbounds i8, i8* %3, i64 2
  %24 = select i1 %22, i8* %23, i8* %17
  %25 = tail call i64 @strspn(i8* nonnull %24, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.423, i64 0, i64 0)) #21
  %26 = tail call i64 @strlen(i8* nonnull %24) #21
  %27 = icmp eq i64 %25, %26
  br i1 %27, label %30, label %28

; <label>:28:                                     ; preds = %20, %1, %15
  %29 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.421, i64 0, i64 0)) #16
  br label %30

; <label>:30:                                     ; preds = %20, %28
  %31 = tail call %struct._IO_FILE* @fopen64(i8* %2, i8* %3) #16
  store %struct._IO_FILE* %31, %struct._IO_FILE** %12, align 8, !tbaa !219
  %32 = icmp eq %struct._IO_FILE* %31, null
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %30
  %34 = tail call i32 @luaL_fileresult(%struct.lua_State* nonnull %0, i32 0, i8* %2) #16
  br label %35

; <label>:35:                                     ; preds = %30, %33
  %36 = phi i32 [ %34, %33 ], [ 1, %30 ]
  ret i32 %36
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_output(%struct.lua_State*) #0 {
  tail call fastcc void @g_iofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.424, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal i32 @io_popen(%struct.lua_State*) #5 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0), i64* null) #16
  %4 = tail call fastcc %struct.luaL_Stream* @newprefile(%struct.lua_State* %0) #16
  %5 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.425, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.55, i64 0, i64 0)) #16
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1) #16
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_tmpfile(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #17
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %4, align 8, !tbaa !217
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 7
  %8 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %7, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %9 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  store %struct._IO_FILE* null, %struct._IO_FILE** %10, align 8, !tbaa !219
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !217
  %11 = tail call %struct._IO_FILE* @tmpfile64() #16
  store %struct._IO_FILE* %11, %struct._IO_FILE** %10, align 8, !tbaa !219
  %12 = icmp eq %struct._IO_FILE* %11, null
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %1
  %14 = tail call i32 @luaL_fileresult(%struct.lua_State* nonnull %0, i32 0, i8* null) #16
  br label %15

; <label>:15:                                     ; preds = %1, %13
  %16 = phi i32 [ %14, %13 ], [ 1, %1 ]
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_type(%struct.lua_State*) #0 {
  tail call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %2 = tail call i8* @luaL_testudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %11

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  br label %20

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds i8, i8* %2, i64 8
  %13 = bitcast i8* %12 to i32 (%struct.lua_State*)**
  %14 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %13, align 8, !tbaa !217
  %15 = icmp eq i32 (%struct.lua_State*)* %14, null
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %11
  %17 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.426, i64 0, i64 0)) #16
  br label %20

; <label>:18:                                     ; preds = %11
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.427, i64 0, i64 0)) #16
  br label %20

; <label>:20:                                     ; preds = %16, %18, %4
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @getiofile(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.57, i64 0, i64 0)) #16
  %3 = tail call fastcc i32 @g_write(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 1) #16
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_close(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @aux_close(%struct.lua_State* %0) #16
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct._IO_FILE* @tofile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !217
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.412, i64 0, i64 0)) #16
  unreachable

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !219
  ret %struct._IO_FILE* %11
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @aux_close(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca i64, align 8
  %3 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4)
  %5 = getelementptr inbounds i8, i8* %3, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  %7 = bitcast i8* %5 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !217
  store volatile i64 %8, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %6, align 8, !tbaa !217
  %9 = load volatile i64, i64* %2, align 8
  %10 = inttoptr i64 %9 to i32 (%struct.lua_State*)*
  %11 = tail call i32 %10(%struct.lua_State* %0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4)
  ret i32 %11
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc %struct._IO_FILE* @getiofile(%struct.lua_State*, i8*) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7
  %6 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %5, i8* %1) #17
  %7 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1) #16
  %8 = getelementptr inbounds i8, i8* %7, i64 8
  %9 = bitcast i8* %8 to i32 (%struct.lua_State*)**
  %10 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %9, align 8, !tbaa !217
  %11 = icmp eq i32 (%struct.lua_State*)* %10, null
  br i1 %11, label %12, label %15

; <label>:12:                                     ; preds = %2
  %13 = getelementptr inbounds i8, i8* %1, i64 4
  %14 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.413, i64 0, i64 0), i8* nonnull %13) #16
  unreachable

; <label>:15:                                     ; preds = %2
  %16 = bitcast i8* %7 to %struct._IO_FILE**
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** %16, align 8, !tbaa !219
  ret %struct._IO_FILE* %17
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @g_iofile(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %26

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  br label %60

; <label>:26:                                     ; preds = %18
  %27 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  %28 = icmp eq i8* %27, null
  br i1 %28, label %30, label %29

; <label>:29:                                     ; preds = %26
  tail call fastcc void @opencheck(%struct.lua_State* nonnull %0, i8* nonnull %27, i8* %2) #16
  br label %56

; <label>:30:                                     ; preds = %26
  %31 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* nonnull %0) #16
  %32 = bitcast %union.StackValue** %9 to %struct.TValue**
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %34 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %35 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %34, i64 0, i32 0
  %36 = load %union.StackValue*, %union.StackValue** %35, align 8, !tbaa !64
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %36, i64 1
  %38 = bitcast %struct.TValue* %33 to %union.StackValue*
  %39 = icmp ult %union.StackValue* %37, %38
  br i1 %39, label %44, label %40

; <label>:40:                                     ; preds = %30
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %42 = load %struct.global_State*, %struct.global_State** %41, align 8, !tbaa !2
  %43 = getelementptr inbounds %struct.global_State, %struct.global_State* %42, i64 0, i32 8
  br label %46

; <label>:44:                                     ; preds = %30
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %37, i64 0, i32 0
  br label %46

; <label>:46:                                     ; preds = %40, %44
  %47 = phi %struct.TValue* [ %43, %40 ], [ %45, %44 ]
  %48 = bitcast %struct.TValue* %47 to i64*
  %49 = bitcast %struct.TValue* %33 to i64*
  %50 = load i64, i64* %48, align 8
  store i64 %50, i64* %49, align 8
  %51 = getelementptr inbounds %struct.TValue, %struct.TValue* %47, i64 0, i32 1
  %52 = load i8, i8* %51, align 8, !tbaa !22
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %33, i64 0, i32 1
  store i8 %52, i8* %53, align 8, !tbaa !22
  %54 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 1
  store %union.StackValue* %55, %union.StackValue** %9, align 8, !tbaa !20
  br label %56

; <label>:56:                                     ; preds = %46, %29
  %57 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %58 = load %struct.global_State*, %struct.global_State** %57, align 8, !tbaa !2
  %59 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 7
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %59, i8* %1) #17
  br label %60

; <label>:60:                                     ; preds = %24, %56
  %61 = phi %struct.global_State** [ %25, %24 ], [ %57, %56 ]
  %62 = load %struct.global_State*, %struct.global_State** %61, align 8, !tbaa !2
  %63 = getelementptr inbounds %struct.global_State, %struct.global_State* %62, i64 0, i32 7
  %64 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %63, i8* %1) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @opencheck(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #17
  %5 = getelementptr inbounds i8, i8* %4, i64 8
  %6 = bitcast i8* %5 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %6, align 8, !tbaa !217
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 7
  %10 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %11 = tail call i32 @lua_setmetatable(%struct.lua_State* %0, i32 -2) #17
  %12 = bitcast i8* %4 to %struct._IO_FILE**
  store %struct._IO_FILE* null, %struct._IO_FILE** %12, align 8, !tbaa !219
  store i32 (%struct.lua_State*)* @io_fclose, i32 (%struct.lua_State*)** %6, align 8, !tbaa !217
  %13 = tail call %struct._IO_FILE* @fopen64(i8* %1, i8* %2) #16
  store %struct._IO_FILE* %13, %struct._IO_FILE** %12, align 8, !tbaa !219
  %14 = icmp eq %struct._IO_FILE* %13, null
  br i1 %14, label %15, label %20

; <label>:15:                                     ; preds = %3
  %16 = tail call i32* @__errno_location() #22
  %17 = load i32, i32* %16, align 4, !tbaa !77
  %18 = tail call i8* @strerror(i32 %17) #17
  %19 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.414, i64 0, i64 0), i8* %1, i8* %18) #16
  unreachable

; <label>:20:                                     ; preds = %3
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc nonnull %struct.luaL_Stream* @newprefile(%struct.lua_State*) unnamed_addr #0 {
  %2 = tail call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 16, i32 0) #16
  %3 = bitcast i8* %2 to %struct.luaL_Stream*
  %4 = getelementptr inbounds i8, i8* %2, i64 8
  %5 = bitcast i8* %4 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %5, align 8, !tbaa !217
  tail call void @luaL_setmetatable(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  ret %struct.luaL_Stream* %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_fclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = bitcast i8* %2 to %struct._IO_FILE**
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** %3, align 8, !tbaa !219
  %5 = tail call i32 @fclose(%struct._IO_FILE* %4) #16
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i32
  %8 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %7, i8* null) #16
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @aux_lines(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = icmp slt i32 %14, 252
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %2
  %17 = inttoptr i64 %5 to %struct.TValue*
  br label %26

; <label>:18:                                     ; preds = %2
  %19 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 252, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  %20 = bitcast %union.StackValue** %3 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %23 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %22, i64 0, i32 0
  %24 = load %union.StackValue*, %union.StackValue** %23, align 8, !tbaa !64
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  br label %26

; <label>:26:                                     ; preds = %16, %18
  %27 = phi %union.StackValue* [ %25, %18 ], [ %10, %16 ]
  %28 = phi %struct.TValue* [ %21, %18 ], [ %17, %16 ]
  %29 = bitcast %struct.TValue* %28 to %union.StackValue*
  %30 = icmp ult %union.StackValue* %27, %29
  br i1 %30, label %35, label %31

; <label>:31:                                     ; preds = %26
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %33 = load %struct.global_State*, %struct.global_State** %32, align 8, !tbaa !2
  %34 = getelementptr inbounds %struct.global_State, %struct.global_State* %33, i64 0, i32 8
  br label %37

; <label>:35:                                     ; preds = %26
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 0, i32 0
  br label %37

; <label>:37:                                     ; preds = %31, %35
  %38 = phi %struct.TValue* [ %34, %31 ], [ %36, %35 ]
  %39 = bitcast %struct.TValue* %38 to i64*
  %40 = bitcast %struct.TValue* %28 to i64*
  %41 = load i64, i64* %39, align 8
  store i64 %41, i64* %40, align 8
  %42 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  %43 = load i8, i8* %42, align 8, !tbaa !22
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 %43, i8* %44, align 8, !tbaa !22
  %45 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 1
  store %union.StackValue* %46, %union.StackValue** %3, align 8, !tbaa !20
  %47 = shl i64 %12, 28
  %48 = add i64 %47, -4294967296
  %49 = ashr exact i64 %48, 32
  %50 = bitcast %union.StackValue* %46 to i64*
  store i64 %49, i64* %50, align 8, !tbaa !21
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 1, i32 0, i32 1
  store i8 35, i8* %51, align 8, !tbaa !22
  %52 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1
  store %union.StackValue* %53, %union.StackValue** %3, align 8, !tbaa !20
  %54 = icmp ne i32 %1, 0
  %55 = zext i1 %54 to i32
  %56 = bitcast %union.StackValue* %53 to i32*
  store i32 %55, i32* %56, align 8, !tbaa !21
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %52, i64 1, i32 0, i32 1
  store i8 1, i8* %57, align 8, !tbaa !22
  %58 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 1
  store %union.StackValue* %59, %union.StackValue** %3, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 2, i32 3) #16
  %60 = add nsw i32 %14, 2
  tail call void @lua_pushcclosure(%struct.lua_State* nonnull %0, i32 (%struct.lua_State*)* nonnull @io_readline, i32 %60) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_readline(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %4 = tail call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1001002, i32* null) #16
  %5 = trunc i64 %4 to i32
  %6 = getelementptr inbounds i8, i8* %3, i64 8
  %7 = bitcast i8* %6 to i32 (%struct.lua_State*)**
  %8 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %7, align 8, !tbaa !217
  %9 = icmp eq i32 (%struct.lua_State*)* %8, null
  br i1 %9, label %10, label %12

; <label>:10:                                     ; preds = %1
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.416, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %1
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  tail call void @luaL_checkstack(%struct.lua_State* %0, i32 %5, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  %13 = icmp slt i32 %5, 1
  br i1 %13, label %34, label %14

; <label>:14:                                     ; preds = %12
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %16 = bitcast %union.StackValue** %15 to %struct.TValue**
  %17 = load %struct.TValue*, %struct.TValue** %16, align 8, !tbaa !20
  br label %18

; <label>:18:                                     ; preds = %18, %14
  %19 = phi %struct.TValue* [ %17, %14 ], [ %33, %18 ]
  %20 = phi i32 [ 1, %14 ], [ %31, %18 ]
  %21 = sub nuw i32 -1001003, %20
  %22 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %21) #17
  %23 = bitcast %struct.TValue* %22 to i64*
  %24 = bitcast %struct.TValue* %19 to i64*
  %25 = load i64, i64* %23, align 8
  store i64 %25, i64* %24, align 8
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %22, i64 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  store i8 %27, i8* %28, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %15, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %15, align 8, !tbaa !20
  %31 = add nuw nsw i32 %20, 1
  %32 = icmp eq i32 %20, %5
  %33 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 0, i32 0
  br i1 %32, label %34, label %18

; <label>:34:                                     ; preds = %18, %12
  %35 = bitcast i8* %3 to %struct._IO_FILE**
  %36 = load %struct._IO_FILE*, %struct._IO_FILE** %35, align 8, !tbaa !219
  %37 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %36, i32 2) #16
  %38 = sub nsw i32 0, %37
  %39 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %38) #17
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %39, i64 0, i32 1
  %41 = load i8, i8* %40, align 8, !tbaa !22
  %42 = and i8 %41, 15
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %50, label %44

; <label>:44:                                     ; preds = %34
  %45 = icmp eq i8 %41, 1
  br i1 %45, label %46, label %136

; <label>:46:                                     ; preds = %44
  %47 = bitcast %struct.TValue* %39 to i32*
  %48 = load i32, i32* %47, align 8, !tbaa !21
  %49 = icmp eq i32 %48, 0
  br i1 %49, label %50, label %136

; <label>:50:                                     ; preds = %34, %46
  %51 = icmp sgt i32 %37, 1
  br i1 %51, label %52, label %56

; <label>:52:                                     ; preds = %50
  %53 = sub i32 1, %37
  %54 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 %53, i64* null) #16
  %55 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* %54) #16
  unreachable

; <label>:56:                                     ; preds = %50
  %57 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %58 = bitcast %struct.CallInfo** %57 to %struct.TValue***
  %59 = load %struct.TValue**, %struct.TValue*** %58, align 8, !tbaa !24
  %60 = load %struct.TValue*, %struct.TValue** %59, align 8, !tbaa !64
  %61 = getelementptr inbounds %struct.TValue, %struct.TValue* %60, i64 0, i32 1
  %62 = load i8, i8* %61, align 8, !tbaa !21
  %63 = icmp eq i8 %62, 38
  br i1 %63, label %64, label %68

; <label>:64:                                     ; preds = %56
  %65 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %66 = load %struct.global_State*, %struct.global_State** %65, align 8, !tbaa !2
  %67 = getelementptr inbounds %struct.global_State, %struct.global_State* %66, i64 0, i32 8
  br label %80

; <label>:68:                                     ; preds = %56
  %69 = bitcast %struct.TValue* %60 to %struct.CClosure**
  %70 = load %struct.CClosure*, %struct.CClosure** %69, align 8, !tbaa !21
  %71 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %70, i64 0, i32 3
  %72 = load i8, i8* %71, align 2, !tbaa !138
  %73 = icmp ult i8 %72, 3
  br i1 %73, label %76, label %74

; <label>:74:                                     ; preds = %68
  %75 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %70, i64 0, i32 6, i64 2
  br label %80

; <label>:76:                                     ; preds = %68
  %77 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %78 = load %struct.global_State*, %struct.global_State** %77, align 8, !tbaa !2
  %79 = getelementptr inbounds %struct.global_State, %struct.global_State* %78, i64 0, i32 8
  br label %80

; <label>:80:                                     ; preds = %64, %74, %76
  %81 = phi %struct.TValue* [ %67, %64 ], [ %75, %74 ], [ %79, %76 ]
  %82 = getelementptr inbounds %struct.TValue, %struct.TValue* %81, i64 0, i32 1
  %83 = load i8, i8* %82, align 8, !tbaa !22
  %84 = and i8 %83, 15
  %85 = icmp eq i8 %84, 0
  br i1 %85, label %136, label %86

; <label>:86:                                     ; preds = %80
  %87 = icmp eq i8 %83, 1
  br i1 %87, label %88, label %92

; <label>:88:                                     ; preds = %86
  %89 = bitcast %struct.TValue* %81 to i32*
  %90 = load i32, i32* %89, align 8, !tbaa !21
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %136, label %92

; <label>:92:                                     ; preds = %86, %88
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 0) #16
  %93 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %94 = bitcast %union.StackValue** %93 to %struct.TValue**
  %95 = load %struct.TValue*, %struct.TValue** %94, align 8, !tbaa !20
  %96 = load %struct.TValue**, %struct.TValue*** %58, align 8, !tbaa !24
  %97 = load %struct.TValue*, %struct.TValue** %96, align 8, !tbaa !64
  %98 = getelementptr inbounds %struct.TValue, %struct.TValue* %97, i64 0, i32 1
  %99 = load i8, i8* %98, align 8, !tbaa !21
  %100 = icmp eq i8 %99, 38
  br i1 %100, label %101, label %105

; <label>:101:                                    ; preds = %92
  %102 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %103 = load %struct.global_State*, %struct.global_State** %102, align 8, !tbaa !2
  %104 = getelementptr inbounds %struct.global_State, %struct.global_State* %103, i64 0, i32 8
  br label %117

; <label>:105:                                    ; preds = %92
  %106 = bitcast %struct.TValue* %97 to %struct.CClosure**
  %107 = load %struct.CClosure*, %struct.CClosure** %106, align 8, !tbaa !21
  %108 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %107, i64 0, i32 3
  %109 = load i8, i8* %108, align 2, !tbaa !138
  %110 = icmp eq i8 %109, 0
  br i1 %110, label %113, label %111

; <label>:111:                                    ; preds = %105
  %112 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %107, i64 0, i32 6, i64 0
  br label %117

; <label>:113:                                    ; preds = %105
  %114 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %115 = load %struct.global_State*, %struct.global_State** %114, align 8, !tbaa !2
  %116 = getelementptr inbounds %struct.global_State, %struct.global_State* %115, i64 0, i32 8
  br label %117

; <label>:117:                                    ; preds = %101, %111, %113
  %118 = phi %struct.TValue* [ %104, %101 ], [ %112, %111 ], [ %116, %113 ]
  %119 = bitcast %struct.TValue* %118 to i64*
  %120 = bitcast %struct.TValue* %95 to i64*
  %121 = load i64, i64* %119, align 8
  store i64 %121, i64* %120, align 8
  %122 = getelementptr inbounds %struct.TValue, %struct.TValue* %118, i64 0, i32 1
  %123 = load i8, i8* %122, align 8, !tbaa !22
  %124 = getelementptr inbounds %struct.TValue, %struct.TValue* %95, i64 0, i32 1
  store i8 %123, i8* %124, align 8, !tbaa !22
  %125 = load %union.StackValue*, %union.StackValue** %93, align 8, !tbaa !20
  %126 = getelementptr inbounds %union.StackValue, %union.StackValue* %125, i64 1
  store %union.StackValue* %126, %union.StackValue** %93, align 8, !tbaa !20
  %127 = tail call i8* @luaL_checkudata(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %128 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %128)
  %129 = getelementptr inbounds i8, i8* %127, i64 8
  %130 = bitcast i8* %129 to i32 (%struct.lua_State*)**
  %131 = bitcast i8* %129 to i64*
  %132 = load i64, i64* %131, align 8, !tbaa !217
  store volatile i64 %132, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %130, align 8, !tbaa !217
  %133 = load volatile i64, i64* %2, align 8
  %134 = inttoptr i64 %133 to i32 (%struct.lua_State*)*
  %135 = tail call i32 %134(%struct.lua_State* nonnull %0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %128)
  br label %136

; <label>:136:                                    ; preds = %80, %44, %117, %88, %46
  %137 = phi i32 [ %37, %46 ], [ 0, %88 ], [ 0, %117 ], [ %37, %44 ], [ 0, %80 ]
  ret i32 %137
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @g_read(%struct.lua_State*, %struct._IO_FILE*, i32) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = alloca %struct.RN, align 8
  %6 = alloca %struct.luaL_Buffer, align 8
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %11 = load %struct.CallInfo*, %struct.CallInfo** %10, align 8, !tbaa !24
  %12 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %11, i64 0, i32 0
  %13 = load %union.StackValue*, %union.StackValue** %12, align 8, !tbaa !64
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  %15 = ptrtoint %union.StackValue* %14 to i64
  %16 = sub i64 %9, %15
  %17 = lshr exact i64 %16, 4
  %18 = trunc i64 %17 to i32
  tail call void @clearerr(%struct._IO_FILE* %1) #17
  %19 = icmp eq i32 %18, 1
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @read_line(%struct.lua_State* nonnull %0, %struct._IO_FILE* %1, i32 1) #16
  %22 = add nsw i32 %2, 1
  br label %190

; <label>:23:                                     ; preds = %3
  %24 = add nsw i32 %18, 19
  tail call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 %24, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i64 0, i64 0)) #16
  %25 = add nsw i32 %18, -2
  %26 = bitcast %struct.luaL_Buffer* %6 to i8*
  %27 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 3
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 4
  %29 = bitcast %struct.luaL_Buffer* %6 to %union.anon.6**
  %30 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 2
  %31 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 1
  %32 = bitcast %struct.RN* %5 to i8*
  %33 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 0
  %34 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 2
  %35 = bitcast %struct.luaL_Buffer* %4 to i8*
  %36 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 3
  %37 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 4
  %38 = bitcast %struct.luaL_Buffer* %4 to %union.anon.6**
  %39 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %40 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %41 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 1
  %42 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 3, i64 0
  %43 = bitcast %union.StackValue** %7 to %struct.TValue**
  %44 = bitcast i64* %31 to <2 x i64>*
  %45 = bitcast i64* %40 to <2 x i64>*
  br label %46

; <label>:46:                                     ; preds = %23, %183
  %47 = phi i32 [ %25, %23 ], [ %186, %183 ]
  %48 = phi i32 [ %2, %23 ], [ %185, %183 ]
  %49 = call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %48) #17
  %50 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 0, i32 1
  %51 = load i8, i8* %50, align 8, !tbaa !22
  %52 = and i8 %51, 15
  %53 = icmp eq i8 %52, 3
  br i1 %53, label %54, label %70

; <label>:54:                                     ; preds = %46
  %55 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %48) #16
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %57, label %63

; <label>:57:                                     ; preds = %54
  %58 = call i32 @_IO_getc(%struct._IO_FILE* %1) #17
  %59 = call i32 @ungetc(i32 %58, %struct._IO_FILE* %1) #17
  %60 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #17
  %61 = icmp ne i32 %58, -1
  %62 = zext i1 %61 to i32
  br label %183

; <label>:63:                                     ; preds = %54
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %26) #7
  store %struct.lua_State* %0, %struct.lua_State** %27, align 8, !tbaa !207
  store %union.anon.6* %28, %union.anon.6** %29, align 8, !tbaa !206
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %44, align 8, !tbaa !82
  %64 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %6, i64 %55, i32 -1) #17
  %65 = call i64 @fread(i8* %64, i64 1, i64 %55, %struct._IO_FILE* %1) #17
  %66 = load i64, i64* %30, align 8, !tbaa !205
  %67 = add i64 %66, %65
  store i64 %67, i64* %30, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %6) #17
  %68 = icmp ne i64 %65, 0
  %69 = zext i1 %68 to i32
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %26) #7
  br label %183

; <label>:70:                                     ; preds = %46
  %71 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %48, i64* null) #16
  %72 = load i8, i8* %71, align 1, !tbaa !21
  %73 = icmp eq i8 %72, 42
  %74 = getelementptr inbounds i8, i8* %71, i64 1
  %75 = select i1 %73, i8* %74, i8* %71
  %76 = load i8, i8* %75, align 1, !tbaa !21
  %77 = sext i8 %76 to i32
  switch i32 %77, label %181 [
    i32 110, label %78
    i32 108, label %169
    i32 76, label %171
    i32 97, label %173
  ]

; <label>:78:                                     ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 224, i8* nonnull %32) #7
  store %struct._IO_FILE* %1, %struct._IO_FILE** %33, align 8, !tbaa !335
  store i32 0, i32* %34, align 4, !tbaa !337
  %79 = call %struct.lconv* @localeconv() #17
  %80 = getelementptr inbounds %struct.lconv, %struct.lconv* %79, i64 0, i32 0
  %81 = load i8*, i8** %80, align 8, !tbaa !142
  %82 = load i8, i8* %81, align 1, !tbaa !21
  br label %83

; <label>:83:                                     ; preds = %83, %78
  %84 = call i32 @_IO_getc(%struct._IO_FILE* %1) #17
  %85 = tail call i16** @__ctype_b_loc() #22
  %86 = load i16*, i16** %85, align 8, !tbaa !54
  %87 = sext i32 %84 to i64
  %88 = getelementptr inbounds i16, i16* %86, i64 %87
  %89 = load i16, i16* %88, align 2, !tbaa !324
  %90 = and i16 %89, 8192
  %91 = icmp eq i16 %90, 0
  br i1 %91, label %92, label %83

; <label>:92:                                     ; preds = %83
  store i32 %84, i32* %41, align 8, !tbaa !338
  switch i32 %84, label %96 [
    i32 45, label %93
    i32 43, label %93
  ]

; <label>:93:                                     ; preds = %92, %92
  %94 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  %95 = load i32, i32* %41, align 8, !tbaa !338
  br label %96

; <label>:96:                                     ; preds = %93, %92
  %97 = phi i32 [ %84, %92 ], [ %95, %93 ]
  %98 = icmp eq i32 %97, 48
  br i1 %98, label %99, label %112

; <label>:99:                                     ; preds = %96
  %100 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  %101 = icmp eq i32 %100, 0
  br i1 %101, label %112, label %102

; <label>:102:                                    ; preds = %99
  %103 = load i32, i32* %41, align 8, !tbaa !338
  switch i32 %103, label %107 [
    i32 120, label %104
    i32 88, label %104
  ]

; <label>:104:                                    ; preds = %102, %102
  %105 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  %106 = icmp eq i32 %105, 0
  br label %107

; <label>:107:                                    ; preds = %104, %102
  %108 = phi i1 [ %106, %104 ], [ true, %102 ]
  %109 = zext i1 %108 to i32
  %110 = xor i1 %108, true
  %111 = zext i1 %110 to i32
  br label %112

; <label>:112:                                    ; preds = %107, %99, %96
  %113 = phi i32 [ 0, %99 ], [ %109, %107 ], [ 0, %96 ]
  %114 = phi i32 [ 0, %99 ], [ %111, %107 ], [ 0, %96 ]
  %115 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 %114) #17
  %116 = add nsw i32 %115, %113
  %117 = load i32, i32* %41, align 8, !tbaa !338
  %118 = sext i8 %82 to i32
  %119 = icmp eq i32 %117, %118
  %120 = icmp eq i32 %117, 46
  %121 = or i1 %119, %120
  br i1 %121, label %122, label %128

; <label>:122:                                    ; preds = %112
  %123 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  %124 = icmp eq i32 %123, 0
  br i1 %124, label %128, label %125

; <label>:125:                                    ; preds = %122
  %126 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 %114) #17
  %127 = add nsw i32 %126, %116
  br label %128

; <label>:128:                                    ; preds = %125, %122, %112
  %129 = phi i32 [ %127, %125 ], [ %116, %122 ], [ %116, %112 ]
  %130 = icmp sgt i32 %129, 0
  br i1 %130, label %131, label %152

; <label>:131:                                    ; preds = %128
  %132 = icmp eq i32 %114, 0
  %133 = select i1 %132, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.420, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.419, i64 0, i64 0)
  %134 = load i32, i32* %41, align 8, !tbaa !338
  %135 = load i8, i8* %133, align 1, !tbaa !21
  %136 = sext i8 %135 to i32
  %137 = icmp eq i32 %134, %136
  br i1 %137, label %143, label %138

; <label>:138:                                    ; preds = %131
  %139 = getelementptr inbounds i8, i8* %133, i64 1
  %140 = load i8, i8* %139, align 1, !tbaa !21
  %141 = sext i8 %140 to i32
  %142 = icmp eq i32 %134, %141
  br i1 %142, label %143, label %152

; <label>:143:                                    ; preds = %138, %131
  %144 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  %145 = icmp eq i32 %144, 0
  br i1 %145, label %152, label %146

; <label>:146:                                    ; preds = %143
  %147 = load i32, i32* %41, align 8, !tbaa !338
  switch i32 %147, label %150 [
    i32 45, label %148
    i32 43, label %148
  ]

; <label>:148:                                    ; preds = %146, %146
  %149 = call fastcc i32 @nextc(%struct.RN* nonnull %5) #17
  br label %150

; <label>:150:                                    ; preds = %148, %146
  %151 = call fastcc i32 @readdigits(%struct.RN* nonnull %5, i32 0) #17
  br label %152

; <label>:152:                                    ; preds = %150, %143, %138, %128
  %153 = load i32, i32* %41, align 8, !tbaa !338
  %154 = load %struct._IO_FILE*, %struct._IO_FILE** %33, align 8, !tbaa !335
  %155 = call i32 @ungetc(i32 %153, %struct._IO_FILE* %154) #17
  %156 = load i32, i32* %34, align 4, !tbaa !337
  %157 = sext i32 %156 to i64
  %158 = getelementptr inbounds %struct.RN, %struct.RN* %5, i64 0, i32 3, i64 %157
  store i8 0, i8* %158, align 1, !tbaa !21
  %159 = load %struct.TValue*, %struct.TValue** %43, align 8, !tbaa !20
  %160 = call fastcc i64 @luaO_str2num(i8* nonnull %42, %struct.TValue* %159) #17
  %161 = icmp eq i64 %160, 0
  br i1 %161, label %162, label %165

; <label>:162:                                    ; preds = %152
  %163 = load %struct.TValue*, %struct.TValue** %43, align 8, !tbaa !20
  %164 = getelementptr inbounds %struct.TValue, %struct.TValue* %163, i64 0, i32 1
  store i8 0, i8* %164, align 8, !tbaa !21
  br label %165

; <label>:165:                                    ; preds = %152, %162
  %166 = phi i32 [ 0, %162 ], [ 1, %152 ]
  %167 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %168 = getelementptr inbounds %union.StackValue, %union.StackValue* %167, i64 1
  store %union.StackValue* %168, %union.StackValue** %7, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 224, i8* nonnull %32) #7
  br label %183

; <label>:169:                                    ; preds = %70
  %170 = call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 1) #16
  br label %183

; <label>:171:                                    ; preds = %70
  %172 = call fastcc i32 @read_line(%struct.lua_State* %0, %struct._IO_FILE* %1, i32 0) #16
  br label %183

; <label>:173:                                    ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %35) #7
  store %struct.lua_State* %0, %struct.lua_State** %36, align 8, !tbaa !207
  store %union.anon.6* %37, %union.anon.6** %38, align 8, !tbaa !206
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %45, align 8, !tbaa !82
  br label %174

; <label>:174:                                    ; preds = %174, %173
  %175 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1024, i32 -1) #17
  %176 = call i64 @fread(i8* %175, i64 1, i64 1024, %struct._IO_FILE* %1) #17
  %177 = load i64, i64* %39, align 8, !tbaa !205
  %178 = add i64 %177, %176
  store i64 %178, i64* %39, align 8, !tbaa !205
  %179 = icmp eq i64 %176, 1024
  br i1 %179, label %174, label %180

; <label>:180:                                    ; preds = %174
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %35) #7
  br label %183

; <label>:181:                                    ; preds = %70
  %182 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %48, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.417, i64 0, i64 0)) #16
  br label %210

; <label>:183:                                    ; preds = %165, %169, %171, %180, %57, %63
  %184 = phi i32 [ %62, %57 ], [ %69, %63 ], [ %166, %165 ], [ %170, %169 ], [ %172, %171 ], [ 1, %180 ]
  %185 = add nsw i32 %48, 1
  %186 = add nsw i32 %47, -1
  %187 = icmp ne i32 %47, 0
  %188 = icmp ne i32 %184, 0
  %189 = and i1 %187, %188
  br i1 %189, label %46, label %190

; <label>:190:                                    ; preds = %183, %20
  %191 = phi i32 [ %22, %20 ], [ %185, %183 ]
  %192 = phi i32 [ %21, %20 ], [ %184, %183 ]
  %193 = call i32 @ferror(%struct._IO_FILE* %1) #17
  %194 = icmp eq i32 %193, 0
  br i1 %194, label %197, label %195

; <label>:195:                                    ; preds = %190
  %196 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %210

; <label>:197:                                    ; preds = %190
  %198 = icmp eq i32 %192, 0
  br i1 %198, label %199, label %208

; <label>:199:                                    ; preds = %197
  %200 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %201 = getelementptr inbounds %union.StackValue, %union.StackValue* %200, i64 -1
  store %union.StackValue* %201, %union.StackValue** %7, align 8, !tbaa !20
  %202 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %201, i32 0) #17
  %203 = bitcast %union.StackValue** %7 to %struct.TValue**
  %204 = load %struct.TValue*, %struct.TValue** %203, align 8, !tbaa !20
  %205 = getelementptr inbounds %struct.TValue, %struct.TValue* %204, i64 0, i32 1
  store i8 0, i8* %205, align 8, !tbaa !21
  %206 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %207 = getelementptr inbounds %union.StackValue, %union.StackValue* %206, i64 1
  store %union.StackValue* %207, %union.StackValue** %7, align 8, !tbaa !20
  br label %208

; <label>:208:                                    ; preds = %197, %199
  %209 = sub nsw i32 %191, %2
  br label %210

; <label>:210:                                    ; preds = %181, %208, %195
  %211 = phi i32 [ %196, %195 ], [ %209, %208 ], [ %182, %181 ]
  ret i32 %211
}

; Function Attrs: nounwind optsize
declare void @clearerr(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @read_line(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %6, align 8, !tbaa !207
  %7 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 4
  %8 = bitcast %struct.luaL_Buffer* %4 to %union.anon.6**
  store %union.anon.6* %7, %union.anon.6** %8, align 8, !tbaa !206
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %11 = bitcast i64* %10 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %11, align 8, !tbaa !82
  br label %12

; <label>:12:                                     ; preds = %29, %3
  %13 = phi i64 [ 0, %3 ], [ %33, %29 ]
  %14 = phi i32 [ 0, %3 ], [ %20, %29 ]
  switch i32 %14, label %15 [
    i32 -1, label %34
    i32 10, label %34
  ]

; <label>:15:                                     ; preds = %12
  %16 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1024, i32 -1) #17
  br label %17

; <label>:17:                                     ; preds = %15, %21
  %18 = phi i64 [ 0, %15 ], [ %23, %21 ]
  %19 = phi i32 [ 0, %15 ], [ %24, %21 ]
  %20 = call i32 @_IO_getc(%struct._IO_FILE* %1) #16
  switch i32 %20, label %21 [
    i32 -1, label %27
    i32 10, label %27
  ]

; <label>:21:                                     ; preds = %17
  %22 = trunc i32 %20 to i8
  %23 = add nuw nsw i64 %18, 1
  %24 = add nuw nsw i32 %19, 1
  %25 = getelementptr inbounds i8, i8* %16, i64 %18
  store i8 %22, i8* %25, align 1, !tbaa !21
  %26 = icmp ult i64 %23, 1024
  br i1 %26, label %17, label %29

; <label>:27:                                     ; preds = %17, %17
  %28 = trunc i64 %18 to i32
  br label %29

; <label>:29:                                     ; preds = %21, %27
  %30 = phi i32 [ %28, %27 ], [ %24, %21 ]
  %31 = zext i32 %30 to i64
  %32 = load i64, i64* %9, align 8, !tbaa !205
  %33 = add i64 %32, %31
  store i64 %33, i64* %9, align 8, !tbaa !205
  br label %12

; <label>:34:                                     ; preds = %12, %12
  %35 = icmp eq i32 %2, 0
  %36 = icmp eq i32 %14, 10
  %37 = and i1 %35, %36
  br i1 %37, label %38, label %50

; <label>:38:                                     ; preds = %34
  %39 = load i64, i64* %10, align 8, !tbaa !203
  %40 = icmp ult i64 %13, %39
  br i1 %40, label %44, label %41

; <label>:41:                                     ; preds = %38
  %42 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 1, i32 -1) #17
  %43 = load i64, i64* %9, align 8, !tbaa !205
  br label %44

; <label>:44:                                     ; preds = %41, %38
  %45 = phi i64 [ %43, %41 ], [ %13, %38 ]
  %46 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 0
  %47 = load i8*, i8** %46, align 8, !tbaa !206
  %48 = add i64 %45, 1
  store i64 %48, i64* %9, align 8, !tbaa !205
  %49 = getelementptr inbounds i8, i8* %47, i64 %45
  store i8 10, i8* %49, align 1, !tbaa !21
  br label %50

; <label>:50:                                     ; preds = %34, %44
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4) #16
  br i1 %36, label %55, label %51

; <label>:51:                                     ; preds = %50
  %52 = call i64 @lua_rawlen(%struct.lua_State* %0, i32 -1) #16
  %53 = icmp ne i64 %52, 0
  %54 = zext i1 %53 to i32
  br label %55

; <label>:55:                                     ; preds = %51, %50
  %56 = phi i32 [ 1, %50 ], [ %54, %51 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  ret i32 %56
}

; Function Attrs: nounwind optsize
declare i32 @ungetc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @readdigits(%struct.RN* nocapture, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  %4 = tail call i16** @__ctype_b_loc() #22
  %5 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  br label %6

; <label>:6:                                      ; preds = %23, %2
  %7 = phi i32 [ 0, %2 ], [ %24, %23 ]
  %8 = load i16*, i16** %4, align 8, !tbaa !54
  %9 = load i32, i32* %5, align 8, !tbaa !338
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i16, i16* %8, i64 %10
  %12 = load i16, i16* %11, align 2, !tbaa !324
  %13 = zext i16 %12 to i32
  br i1 %3, label %17, label %14

; <label>:14:                                     ; preds = %6
  %15 = and i32 %13, 4096
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %25, label %20

; <label>:17:                                     ; preds = %6
  %18 = and i32 %13, 2048
  %19 = icmp eq i32 %18, 0
  br i1 %19, label %25, label %20

; <label>:20:                                     ; preds = %14, %17
  %21 = tail call fastcc i32 @nextc(%struct.RN* nonnull %0) #16
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %25, label %23

; <label>:23:                                     ; preds = %20
  %24 = add nuw nsw i32 %7, 1
  br label %6

; <label>:25:                                     ; preds = %20, %14, %17
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @nextc(%struct.RN* nocapture) unnamed_addr #0 {
  %2 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 2
  %3 = load i32, i32* %2, align 4, !tbaa !337
  %4 = icmp sgt i32 %3, 199
  br i1 %4, label %5, label %7

; <label>:5:                                      ; preds = %1
  %6 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 0
  store i8 0, i8* %6, align 8, !tbaa !21
  br label %17

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 1
  %9 = load i32, i32* %8, align 8, !tbaa !338
  %10 = trunc i32 %9 to i8
  %11 = add nsw i32 %3, 1
  store i32 %11, i32* %2, align 4, !tbaa !337
  %12 = sext i32 %3 to i64
  %13 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 3, i64 %12
  store i8 %10, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds %struct.RN, %struct.RN* %0, i64 0, i32 0
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %14, align 8, !tbaa !335
  %16 = tail call i32 @_IO_getc(%struct._IO_FILE* %15) #16
  store i32 %16, i32* %8, align 8, !tbaa !338
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ 0, %5 ], [ 1, %7 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize
declare noalias %struct._IO_FILE* @tmpfile64() local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @g_write(%struct.lua_State*, %struct._IO_FILE* nocapture, i32) unnamed_addr #0 {
  %4 = alloca i64, align 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !24
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !64
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  %13 = ptrtoint %union.StackValue* %12 to i64
  %14 = sub i64 %7, %13
  %15 = lshr exact i64 %14, 4
  %16 = trunc i64 %15 to i32
  %17 = sub nsw i32 %16, %2
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %62, label %19

; <label>:19:                                     ; preds = %3
  %20 = bitcast i64* %4 to i8*
  br label %21

; <label>:21:                                     ; preds = %19, %54
  %22 = phi i32 [ %17, %19 ], [ %25, %54 ]
  %23 = phi i32 [ %2, %19 ], [ %57, %54 ]
  %24 = phi i32 [ 1, %19 ], [ %56, %54 ]
  %25 = add nsw i32 %22, -1
  %26 = call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %23) #17
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = and i8 %28, 15
  %30 = icmp eq i8 %29, 3
  br i1 %30, label %31, label %44

; <label>:31:                                     ; preds = %21
  %32 = icmp eq i8 %28, 35
  br i1 %32, label %33, label %36

; <label>:33:                                     ; preds = %31
  %34 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %23, i32* null) #16
  %35 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0), i64 %34) #16
  br label %39

; <label>:36:                                     ; preds = %31
  %37 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %23, i32* null) #16
  %38 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.190, i64 0, i64 0), double %37) #16
  br label %39

; <label>:39:                                     ; preds = %36, %33
  %40 = phi i32 [ %35, %33 ], [ %38, %36 ]
  %41 = icmp ne i32 %24, 0
  %42 = icmp sgt i32 %40, 0
  %43 = and i1 %41, %42
  br label %54

; <label>:44:                                     ; preds = %21
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %45 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %23, i64* nonnull %4) #16
  %46 = icmp eq i32 %24, 0
  br i1 %46, label %52, label %47

; <label>:47:                                     ; preds = %44
  %48 = load i64, i64* %4, align 8, !tbaa !82
  %49 = call i64 @fwrite(i8* %45, i64 1, i64 %48, %struct._IO_FILE* %1) #16
  %50 = load i64, i64* %4, align 8, !tbaa !82
  %51 = icmp eq i64 %49, %50
  br label %52

; <label>:52:                                     ; preds = %44, %47
  %53 = phi i1 [ false, %44 ], [ %51, %47 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  br label %54

; <label>:54:                                     ; preds = %39, %52
  %55 = phi i1 [ %43, %39 ], [ %53, %52 ]
  %56 = zext i1 %55 to i32
  %57 = add nsw i32 %23, 1
  %58 = icmp eq i32 %25, 0
  br i1 %58, label %59, label %21

; <label>:59:                                     ; preds = %54
  br i1 %55, label %62, label %60

; <label>:60:                                     ; preds = %59
  %61 = call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %62

; <label>:62:                                     ; preds = %59, %3, %60
  %63 = phi i32 [ %61, %60 ], [ 1, %59 ], [ 1, %3 ]
  ret i32 %63
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_flush(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @fflush(%struct._IO_FILE* %2) #16
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* null) #16
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_lines(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  tail call fastcc void @aux_lines(%struct.lua_State* %0, i32 0) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_read(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call fastcc i32 @g_read(%struct.lua_State* %0, %struct._IO_FILE* %2, i32 2) #16
  ret i32 %3
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_seek(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.431, i64 0, i64 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_seek.modenames, i64 0, i64 0)) #16
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 0) #16
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_seek.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !77
  %8 = tail call i32 @fseek(%struct._IO_FILE* %2, i64 %4, i32 %7) #16
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %12, label %10

; <label>:10:                                     ; preds = %1
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 0, i8* null) #16
  br label %21

; <label>:12:                                     ; preds = %1
  %13 = tail call i64 @ftell(%struct._IO_FILE* %2) #16
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast %union.StackValue** %14 to %struct.TValue**
  %16 = load %struct.TValue*, %struct.TValue** %15, align 8, !tbaa !20
  %17 = bitcast %struct.TValue* %16 to i64*
  store i64 %13, i64* %17, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %16, i64 0, i32 1
  store i8 35, i8* %18, align 8, !tbaa !22
  %19 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 1
  store %union.StackValue* %20, %union.StackValue** %14, align 8, !tbaa !20
  br label %21

; <label>:21:                                     ; preds = %12, %10
  %22 = phi i32 [ %11, %10 ], [ 1, %12 ]
  ret i32 %22
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_setvbuf(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* null, i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @f_setvbuf.modenames, i64 0, i64 0)) #16
  %4 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1024) #16
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds [3 x i32], [3 x i32]* @f_setvbuf.mode, i64 0, i64 %5
  %7 = load i32, i32* %6, align 4, !tbaa !77
  %8 = tail call i32 @setvbuf(%struct._IO_FILE* %2, i8* null, i32 %7, i64 %4) #17
  %9 = icmp eq i32 %8, 0
  %10 = zext i1 %9 to i32
  %11 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %10, i8* null) #16
  ret i32 %11
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_write(%struct.lua_State*) #0 {
  %2 = tail call fastcc %struct._IO_FILE* @tofile(%struct.lua_State* %0) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to %struct.TValue**
  %5 = load %struct.TValue*, %struct.TValue** %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = bitcast %struct.TValue* %5 to %union.StackValue*
  %12 = icmp ult %union.StackValue* %10, %11
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %15 = load %struct.global_State*, %struct.global_State** %14, align 8, !tbaa !2
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 8
  br label %19

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0
  br label %19

; <label>:19:                                     ; preds = %13, %17
  %20 = phi %struct.TValue* [ %16, %13 ], [ %18, %17 ]
  %21 = bitcast %struct.TValue* %20 to i64*
  %22 = bitcast %struct.TValue* %5 to i64*
  %23 = load i64, i64* %21, align 8
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %25 = load i8, i8* %24, align 8, !tbaa !22
  %26 = getelementptr inbounds %struct.TValue, %struct.TValue* %5, i64 0, i32 1
  store i8 %25, i8* %26, align 8, !tbaa !22
  %27 = load %union.StackValue*, %union.StackValue** %3, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 1
  store %union.StackValue* %28, %union.StackValue** %3, align 8, !tbaa !20
  %29 = tail call fastcc i32 @g_write(%struct.lua_State* nonnull %0, %struct._IO_FILE* %2, i32 2) #16
  ret i32 %29
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_gc(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %4 = getelementptr inbounds i8, i8* %3, i64 8
  %5 = bitcast i8* %4 to i32 (%struct.lua_State*)**
  %6 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %5, align 8, !tbaa !217
  %7 = icmp eq i32 (%struct.lua_State*)* %6, null
  br i1 %7, label %22, label %8

; <label>:8:                                      ; preds = %1
  %9 = bitcast i8* %3 to %struct._IO_FILE**
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** %9, align 8, !tbaa !219
  %11 = icmp eq %struct._IO_FILE* %10, null
  br i1 %11, label %22, label %12

; <label>:12:                                     ; preds = %8
  %13 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #17
  %14 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %14)
  %15 = getelementptr inbounds i8, i8* %13, i64 8
  %16 = bitcast i8* %15 to i32 (%struct.lua_State*)**
  %17 = bitcast i8* %15 to i64*
  %18 = load i64, i64* %17, align 8, !tbaa !217
  store volatile i64 %18, i64* %2, align 8
  store i32 (%struct.lua_State*)* null, i32 (%struct.lua_State*)** %16, align 8, !tbaa !217
  %19 = load volatile i64, i64* %2, align 8
  %20 = inttoptr i64 %19 to i32 (%struct.lua_State*)*
  %21 = tail call i32 %20(%struct.lua_State* %0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %14)
  br label %22

; <label>:22:                                     ; preds = %8, %12, %1
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @f_tostring(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  %5 = load i32 (%struct.lua_State*)*, i32 (%struct.lua_State*)** %4, align 8, !tbaa !217
  %6 = icmp eq i32 (%struct.lua_State*)* %5, null
  br i1 %6, label %7, label %9

; <label>:7:                                      ; preds = %1
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.435, i64 0, i64 0)) #16
  br label %13

; <label>:9:                                      ; preds = %1
  %10 = bitcast i8* %2 to %struct._IO_FILE**
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8, !tbaa !219
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.436, i64 0, i64 0), %struct._IO_FILE* %11) #16
  br label %13

; <label>:13:                                     ; preds = %9, %7
  ret i32 1
}

; Function Attrs: nounwind optsize
declare i32 @fseek(%struct._IO_FILE* nocapture, i64, i32) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i64 @ftell(%struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i32 @setvbuf(%struct._IO_FILE* nocapture, i8*, i32, i64) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal i32 @io_noclose(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checkudata(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.411, i64 0, i64 0)) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 8
  %4 = bitcast i8* %3 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @io_noclose, i32 (%struct.lua_State*)** %4, align 8, !tbaa !217
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 0, i8* %8, align 8, !tbaa !21
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  %11 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.437, i64 0, i64 0)) #16
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_abs(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 35
  br i1 %20, label %21, label %29

; <label>:21:                                     ; preds = %16
  %22 = tail call i64 @lua_tointegerx(%struct.lua_State* nonnull %0, i32 1, i32* null) #16
  %23 = icmp slt i64 %22, 0
  %24 = sub i64 0, %22
  %25 = select i1 %23, i64 %24, i64 %22
  %26 = bitcast %union.StackValue** %7 to %struct.TValue**
  %27 = load %struct.TValue*, %struct.TValue** %26, align 8, !tbaa !20
  %28 = bitcast %struct.TValue* %27 to i64*
  store i64 %25, i64* %28, align 8, !tbaa !21
  br label %35

; <label>:29:                                     ; preds = %16
  %30 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 1) #16
  %31 = tail call double @llvm.fabs.f64(double %30)
  %32 = bitcast %union.StackValue** %7 to %struct.TValue**
  %33 = load %struct.TValue*, %struct.TValue** %32, align 8, !tbaa !20
  %34 = bitcast %struct.TValue* %33 to double*
  store double %31, double* %34, align 8, !tbaa !21
  br label %35

; <label>:35:                                     ; preds = %29, %21
  %36 = phi %struct.TValue* [ %33, %29 ], [ %27, %21 ]
  %37 = phi i8 [ 19, %29 ], [ 35, %21 ]
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %36, i64 0, i32 1
  store i8 %37, i8* %38, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 1
  store %union.StackValue* %40, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_acos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @acos(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_asin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @asin(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_atan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @luaL_optnumber(%struct.lua_State* %0, i32 2, double 1.000000e+00) #16
  %4 = tail call double @atan2(double %2, double %3) #17
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_ceil(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 35
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  br label %43

; <label>:22:                                     ; preds = %16
  %23 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 1) #16
  %24 = tail call double @llvm.ceil.f64(double %23)
  %25 = fcmp oge double %24, 0xC3E0000000000000
  %26 = fcmp olt double %24, 0x43E0000000000000
  %27 = and i1 %25, %26
  br i1 %27, label %28, label %36

; <label>:28:                                     ; preds = %22
  %29 = fptosi double %24 to i64
  %30 = bitcast %union.StackValue** %7 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to i64*
  store i64 %29, i64* %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 35, i8* %33, align 8, !tbaa !22
  %34 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %7, align 8, !tbaa !20
  br label %43

; <label>:36:                                     ; preds = %22
  %37 = bitcast %union.StackValue** %7 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to double*
  store double %24, double* %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 19, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %7, align 8, !tbaa !20
  br label %43

; <label>:43:                                     ; preds = %36, %28, %21
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_cos(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @cos(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_deg(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = fmul double %2, 0x404CA5DC1A63C1F8
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_exp(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @exp(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_toint(%struct.lua_State*) #0 {
  %2 = alloca i32, align 4
  %3 = bitcast i32* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %3) #7
  %4 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 1, i32* nonnull %2) #16
  %5 = load i32, i32* %2, align 4, !tbaa !77
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %12, label %7

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = bitcast %struct.TValue* %10 to i64*
  store i64 %4, i64* %11, align 8, !tbaa !21
  br label %16

; <label>:12:                                     ; preds = %1
  call void @luaL_checkany(%struct.lua_State* %0, i32 1) #16
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = bitcast %union.StackValue** %13 to %struct.TValue**
  %15 = load %struct.TValue*, %struct.TValue** %14, align 8, !tbaa !20
  br label %16

; <label>:16:                                     ; preds = %12, %7
  %17 = phi %struct.TValue* [ %15, %12 ], [ %10, %7 ]
  %18 = phi i8 [ 0, %12 ], [ 35, %7 ]
  %19 = phi %union.StackValue** [ %13, %12 ], [ %8, %7 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 %18, i8* %20, align 8, !tbaa !21
  %21 = load %union.StackValue*, %union.StackValue** %19, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %21, i64 1
  store %union.StackValue* %22, %union.StackValue** %19, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_floor(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 35
  br i1 %20, label %21, label %22

; <label>:21:                                     ; preds = %16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  br label %43

; <label>:22:                                     ; preds = %16
  %23 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 1) #16
  %24 = tail call double @llvm.floor.f64(double %23)
  %25 = fcmp oge double %24, 0xC3E0000000000000
  %26 = fcmp olt double %24, 0x43E0000000000000
  %27 = and i1 %25, %26
  br i1 %27, label %28, label %36

; <label>:28:                                     ; preds = %22
  %29 = fptosi double %24 to i64
  %30 = bitcast %union.StackValue** %7 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = bitcast %struct.TValue* %31 to i64*
  store i64 %29, i64* %32, align 8, !tbaa !21
  %33 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 35, i8* %33, align 8, !tbaa !22
  %34 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 1
  store %union.StackValue* %35, %union.StackValue** %7, align 8, !tbaa !20
  br label %43

; <label>:36:                                     ; preds = %22
  %37 = bitcast %union.StackValue** %7 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to double*
  store double %24, double* %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 19, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %7, align 8, !tbaa !20
  br label %43

; <label>:43:                                     ; preds = %36, %28, %21
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_fmod(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 35
  br i1 %20, label %21, label %53

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2
  %23 = icmp ult %union.StackValue* %22, %8
  br i1 %23, label %28, label %24

; <label>:24:                                     ; preds = %21
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  br label %30

; <label>:28:                                     ; preds = %21
  %29 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 0, i32 0
  br label %30

; <label>:30:                                     ; preds = %24, %28
  %31 = phi %struct.TValue* [ %27, %24 ], [ %29, %28 ]
  %32 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  %33 = load i8, i8* %32, align 8, !tbaa !22
  %34 = icmp eq i8 %33, 35
  br i1 %34, label %35, label %53

; <label>:35:                                     ; preds = %30
  %36 = tail call i64 @lua_tointegerx(%struct.lua_State* nonnull %0, i32 2, i32* null) #16
  %37 = add i64 %36, 1
  %38 = icmp ult i64 %37, 2
  br i1 %38, label %39, label %47

; <label>:39:                                     ; preds = %35
  %40 = icmp eq i64 %36, 0
  br i1 %40, label %41, label %43

; <label>:41:                                     ; preds = %39
  %42 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.460, i64 0, i64 0)) #16
  br label %43

; <label>:43:                                     ; preds = %39, %41
  %44 = bitcast %union.StackValue** %7 to %struct.TValue**
  %45 = load %struct.TValue*, %struct.TValue** %44, align 8, !tbaa !20
  %46 = bitcast %struct.TValue* %45 to i64*
  store i64 0, i64* %46, align 8, !tbaa !21
  br label %60

; <label>:47:                                     ; preds = %35
  %48 = tail call i64 @lua_tointegerx(%struct.lua_State* nonnull %0, i32 1, i32* null) #16
  %49 = srem i64 %48, %36
  %50 = bitcast %union.StackValue** %7 to %struct.TValue**
  %51 = load %struct.TValue*, %struct.TValue** %50, align 8, !tbaa !20
  %52 = bitcast %struct.TValue* %51 to i64*
  store i64 %49, i64* %52, align 8, !tbaa !21
  br label %60

; <label>:53:                                     ; preds = %30, %16
  %54 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 1) #16
  %55 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 2) #16
  %56 = tail call double @fmod(double %54, double %55) #17
  %57 = bitcast %union.StackValue** %7 to %struct.TValue**
  %58 = load %struct.TValue*, %struct.TValue** %57, align 8, !tbaa !20
  %59 = bitcast %struct.TValue* %58 to double*
  store double %56, double* %59, align 8, !tbaa !21
  br label %60

; <label>:60:                                     ; preds = %43, %47, %53
  %61 = phi %struct.TValue* [ %45, %43 ], [ %51, %47 ], [ %58, %53 ]
  %62 = phi i8 [ 35, %43 ], [ 35, %47 ], [ 19, %53 ]
  %63 = getelementptr inbounds %struct.TValue, %struct.TValue* %61, i64 0, i32 1
  store i8 %62, i8* %63, align 8, !tbaa !22
  %64 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 1
  store %union.StackValue* %65, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_ult(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %4 = icmp ult i64 %2, %3
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = zext i1 %4 to i32
  %9 = bitcast %struct.TValue* %7 to i32*
  store i32 %8, i32* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 1, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_log(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 2
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %25

; <label>:23:                                     ; preds = %17
  %24 = tail call double @log(double %2) #17
  br label %38

; <label>:25:                                     ; preds = %17
  %26 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 2) #16
  %27 = fcmp oeq double %26, 2.000000e+00
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %25
  %29 = tail call double @log2(double %2) #17
  br label %38

; <label>:30:                                     ; preds = %25
  %31 = fcmp oeq double %26, 1.000000e+01
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %30
  %33 = tail call double @log10(double %2) #17
  br label %38

; <label>:34:                                     ; preds = %30
  %35 = tail call double @log(double %2) #17
  %36 = tail call double @log(double %26) #17
  %37 = fdiv double %35, %36
  br label %38

; <label>:38:                                     ; preds = %28, %34, %32, %23
  %39 = phi double [ %24, %23 ], [ %29, %28 ], [ %33, %32 ], [ %37, %34 ]
  %40 = bitcast %union.StackValue** %8 to %struct.TValue**
  %41 = load %struct.TValue*, %struct.TValue** %40, align 8, !tbaa !20
  %42 = bitcast %struct.TValue* %41 to double*
  store double %39, double* %42, align 8, !tbaa !21
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %41, i64 0, i32 1
  store i8 19, i8* %43, align 8, !tbaa !22
  %44 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 1
  store %union.StackValue* %45, %union.StackValue** %8, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_max(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %28

; <label>:17:                                     ; preds = %1
  %18 = icmp eq i32 %13, 1
  br i1 %18, label %28, label %19

; <label>:19:                                     ; preds = %17
  br label %20

; <label>:20:                                     ; preds = %19, %20
  %21 = phi i32 [ %26, %20 ], [ 2, %19 ]
  %22 = phi i32 [ %25, %20 ], [ 1, %19 ]
  %23 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %22, i32 %21, i32 1) #16
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 %22, i32 %21
  %26 = add nuw nsw i32 %21, 1
  %27 = icmp eq i32 %21, %13
  br i1 %27, label %28, label %20

; <label>:28:                                     ; preds = %20, %15, %17
  %29 = phi i32 [ 1, %17 ], [ 1, %15 ], [ %25, %20 ]
  %30 = bitcast %union.StackValue** %2 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %29) #17
  %33 = bitcast %struct.TValue* %32 to i64*
  %34 = bitcast %struct.TValue* %31 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %37 = load i8, i8* %36, align 8, !tbaa !22
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %37, i8* %38, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 1
  store %union.StackValue* %40, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_min(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %1
  %16 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.30, i64 0, i64 0)) #16
  br label %28

; <label>:17:                                     ; preds = %1
  %18 = icmp eq i32 %13, 1
  br i1 %18, label %28, label %19

; <label>:19:                                     ; preds = %17
  br label %20

; <label>:20:                                     ; preds = %19, %20
  %21 = phi i32 [ %26, %20 ], [ 2, %19 ]
  %22 = phi i32 [ %25, %20 ], [ 1, %19 ]
  %23 = tail call i32 @lua_compare(%struct.lua_State* %0, i32 %21, i32 %22, i32 1) #16
  %24 = icmp eq i32 %23, 0
  %25 = select i1 %24, i32 %22, i32 %21
  %26 = add nuw nsw i32 %21, 1
  %27 = icmp eq i32 %21, %13
  br i1 %27, label %28, label %20

; <label>:28:                                     ; preds = %20, %15, %17
  %29 = phi i32 [ 1, %17 ], [ 1, %15 ], [ %25, %20 ]
  %30 = bitcast %union.StackValue** %2 to %struct.TValue**
  %31 = load %struct.TValue*, %struct.TValue** %30, align 8, !tbaa !20
  %32 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %29) #17
  %33 = bitcast %struct.TValue* %32 to i64*
  %34 = bitcast %struct.TValue* %31 to i64*
  %35 = load i64, i64* %33, align 8
  store i64 %35, i64* %34, align 8
  %36 = getelementptr inbounds %struct.TValue, %struct.TValue* %32, i64 0, i32 1
  %37 = load i8, i8* %36, align 8, !tbaa !22
  %38 = getelementptr inbounds %struct.TValue, %struct.TValue* %31, i64 0, i32 1
  store i8 %37, i8* %38, align 8, !tbaa !22
  %39 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 1
  store %union.StackValue* %40, %union.StackValue** %2, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_modf(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = icmp eq i8 %19, 35
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  %22 = bitcast %union.StackValue** %7 to %struct.TValue**
  %23 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !20
  %24 = bitcast %struct.TValue* %23 to double*
  store double 0.000000e+00, double* %24, align 8, !tbaa !21
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  br label %55

; <label>:26:                                     ; preds = %16
  %27 = tail call double @luaL_checknumber(%struct.lua_State* nonnull %0, i32 1) #16
  %28 = fcmp olt double %27, 0.000000e+00
  %29 = tail call double @llvm.ceil.f64(double %27)
  %30 = tail call double @llvm.floor.f64(double %27)
  %31 = select i1 %28, double %29, double %30
  %32 = fcmp oge double %31, 0xC3E0000000000000
  %33 = fcmp olt double %31, 0x43E0000000000000
  %34 = and i1 %32, %33
  br i1 %34, label %35, label %40

; <label>:35:                                     ; preds = %26
  %36 = fptosi double %31 to i64
  %37 = bitcast %union.StackValue** %7 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to i64*
  store i64 %36, i64* %39, align 8, !tbaa !21
  br label %44

; <label>:40:                                     ; preds = %26
  %41 = bitcast %union.StackValue** %7 to %struct.TValue**
  %42 = load %struct.TValue*, %struct.TValue** %41, align 8, !tbaa !20
  %43 = bitcast %struct.TValue* %42 to double*
  store double %31, double* %43, align 8, !tbaa !21
  br label %44

; <label>:44:                                     ; preds = %35, %40
  %45 = phi %struct.TValue* [ %38, %35 ], [ %42, %40 ]
  %46 = phi i8 [ 35, %35 ], [ 19, %40 ]
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  store i8 %46, i8* %47, align 8, !tbaa !22
  %48 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1
  store %union.StackValue* %49, %union.StackValue** %7, align 8, !tbaa !20
  %50 = fcmp oeq double %27, %31
  %51 = fsub double %27, %31
  %52 = select i1 %50, double 0.000000e+00, double %51
  %53 = bitcast %union.StackValue* %49 to double*
  store double %52, double* %53, align 8, !tbaa !21
  %54 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1, i32 0, i32 1
  br label %55

; <label>:55:                                     ; preds = %44, %21
  %56 = phi i8* [ %54, %44 ], [ %25, %21 ]
  store i8 19, i8* %56, align 8, !tbaa !22
  %57 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %58 = getelementptr inbounds %union.StackValue, %union.StackValue* %57, i64 1
  store %union.StackValue* %58, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_rad(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = fmul double %2, 0x3F91DF46A2529D39
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_sin(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @sin(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_sqrt(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @sqrt(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_tan(%struct.lua_State*) #0 {
  %2 = tail call double @luaL_checknumber(%struct.lua_State* %0, i32 1) #16
  %3 = tail call double @tan(double %2) #17
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to %struct.TValue**
  %6 = load %struct.TValue*, %struct.TValue** %5, align 8, !tbaa !20
  %7 = bitcast %struct.TValue* %6 to double*
  store double %3, double* %7, align 8, !tbaa !21
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %6, i64 0, i32 1
  store i8 19, i8* %8, align 8, !tbaa !22
  %9 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  store %union.StackValue* %10, %union.StackValue** %4, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_type(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 3
  br i1 %21, label %22, label %36

; <label>:22:                                     ; preds = %16
  br i1 %9, label %27, label %23

; <label>:23:                                     ; preds = %22
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  br label %29

; <label>:27:                                     ; preds = %22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %29

; <label>:29:                                     ; preds = %23, %27
  %30 = phi %struct.TValue* [ %26, %23 ], [ %28, %27 ]
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = icmp eq i8 %32, 35
  %34 = select i1 %33, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.461, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.462, i64 0, i64 0)
  %35 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %34) #16
  br label %42

; <label>:36:                                     ; preds = %16
  tail call void @luaL_checkany(%struct.lua_State* nonnull %0, i32 1) #16
  %37 = bitcast %union.StackValue** %7 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 0, i8* %39, align 8, !tbaa !21
  %40 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %7, align 8, !tbaa !20
  br label %42

; <label>:42:                                     ; preds = %36, %29
  ret i32 1
}

; Function Attrs: nounwind readnone speculatable
declare double @llvm.fabs.f64(double) #14

; Function Attrs: nounwind optsize
declare double @acos(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @asin(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @atan2(double, double) local_unnamed_addr #9

; Function Attrs: nounwind readnone speculatable
declare double @llvm.ceil.f64(double) #14

; Function Attrs: nounwind optsize
declare double @cos(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @exp(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @log(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @log2(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @log10(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @sin(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @sqrt(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare double @tan(double) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @randseed(%struct.lua_State*, %struct.RanState* nocapture) unnamed_addr #0 {
  %3 = tail call i64 @time(i64* null) #17
  %4 = ptrtoint %struct.lua_State* %0 to i64
  %5 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 0
  store i64 %3, i64* %5, align 8, !tbaa !82
  %6 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 1
  store i64 255, i64* %6, align 8, !tbaa !82
  %7 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 2
  store i64 %4, i64* %7, align 8, !tbaa !82
  %8 = getelementptr inbounds %struct.RanState, %struct.RanState* %1, i64 0, i32 0, i64 3
  store i64 0, i64* %8, align 8, !tbaa !82
  br label %9

; <label>:9:                                      ; preds = %9, %2
  %10 = phi i32 [ 0, %2 ], [ %12, %9 ]
  %11 = tail call fastcc i64 @nextrand(i64* %5) #17
  %12 = add nuw nsw i32 %10, 1
  %13 = icmp eq i32 %12, 16
  br i1 %13, label %14, label %9

; <label>:14:                                     ; preds = %9
  ret void
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i64 @nextrand(i64* nocapture) unnamed_addr #2 {
  %2 = load i64, i64* %0, align 8, !tbaa !82
  %3 = getelementptr inbounds i64, i64* %0, i64 1
  %4 = load i64, i64* %3, align 8, !tbaa !82
  %5 = getelementptr inbounds i64, i64* %0, i64 2
  %6 = load i64, i64* %5, align 8, !tbaa !82
  %7 = xor i64 %6, %2
  %8 = getelementptr inbounds i64, i64* %0, i64 3
  %9 = load i64, i64* %8, align 8, !tbaa !82
  %10 = xor i64 %9, %4
  %11 = mul i64 %4, 5
  %12 = mul i64 %4, 640
  %13 = lshr i64 %11, 57
  %14 = or i64 %13, %12
  %15 = mul i64 %14, 9
  %16 = xor i64 %10, %2
  store i64 %16, i64* %0, align 8, !tbaa !82
  %17 = xor i64 %7, %4
  store i64 %17, i64* %3, align 8, !tbaa !82
  %18 = shl i64 %4, 17
  %19 = xor i64 %7, %18
  store i64 %19, i64* %5, align 8, !tbaa !82
  %20 = shl i64 %10, 45
  %21 = lshr i64 %10, 19
  %22 = or i64 %21, %20
  store i64 %22, i64* %8, align 8, !tbaa !82
  ret i64 %15
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_random(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %3 = bitcast i8* %2 to i64*
  %4 = tail call fastcc i64 @nextrand(i64* %3) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !20
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %9 = load %struct.CallInfo*, %struct.CallInfo** %8, align 8, !tbaa !24
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !64
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  %13 = ptrtoint %union.StackValue* %12 to i64
  %14 = sub i64 %7, %13
  %15 = lshr exact i64 %14, 4
  %16 = trunc i64 %15 to i32
  switch i32 %16, label %33 [
    i32 0, label %17
    i32 1, label %23
    i32 2, label %30
  ]

; <label>:17:                                     ; preds = %1
  %18 = inttoptr i64 %7 to %struct.TValue*
  %19 = lshr i64 %4, 11
  %20 = uitofp i64 %19 to double
  %21 = fmul double %20, 0x3CA0000000000000
  %22 = inttoptr i64 %7 to double*
  store double %21, double* %22, align 8, !tbaa !21
  br label %74

; <label>:23:                                     ; preds = %1
  %24 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %26, label %35

; <label>:26:                                     ; preds = %23
  %27 = bitcast %union.StackValue** %5 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = bitcast %struct.TValue* %28 to i64*
  store i64 %4, i64* %29, align 8, !tbaa !21
  br label %74

; <label>:30:                                     ; preds = %1
  %31 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %32 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #16
  br label %35

; <label>:33:                                     ; preds = %1
  %34 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.463, i64 0, i64 0)) #16
  unreachable

; <label>:35:                                     ; preds = %23, %30
  %36 = phi i64 [ %32, %30 ], [ %24, %23 ]
  %37 = phi i64 [ %31, %30 ], [ 1, %23 ]
  %38 = icmp slt i64 %36, %37
  br i1 %38, label %39, label %41

; <label>:39:                                     ; preds = %35
  %40 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.464, i64 0, i64 0)) #16
  br label %41

; <label>:41:                                     ; preds = %35, %39
  %42 = sub i64 %36, %37
  %43 = add i64 %42, 1
  %44 = and i64 %43, %42
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %59, label %46

; <label>:46:                                     ; preds = %41
  %47 = lshr i64 %42, 1
  %48 = or i64 %47, %42
  %49 = lshr i64 %48, 2
  %50 = or i64 %49, %48
  %51 = lshr i64 %50, 4
  %52 = or i64 %51, %50
  %53 = lshr i64 %52, 8
  %54 = or i64 %53, %52
  %55 = lshr i64 %54, 16
  %56 = or i64 %55, %54
  %57 = lshr i64 %56, 32
  %58 = or i64 %57, %56
  br label %59

; <label>:59:                                     ; preds = %46, %41
  %60 = phi i64 [ %58, %46 ], [ %42, %41 ]
  %61 = and i64 %60, %4
  %62 = icmp ugt i64 %61, %42
  br i1 %62, label %63, label %68

; <label>:63:                                     ; preds = %59
  br label %64

; <label>:64:                                     ; preds = %63, %64
  %65 = tail call fastcc i64 @nextrand(i64* %3) #17
  %66 = and i64 %65, %60
  %67 = icmp ugt i64 %66, %42
  br i1 %67, label %64, label %68

; <label>:68:                                     ; preds = %64, %59
  %69 = phi i64 [ %61, %59 ], [ %66, %64 ]
  %70 = add i64 %69, %37
  %71 = bitcast %union.StackValue** %5 to %struct.TValue**
  %72 = load %struct.TValue*, %struct.TValue** %71, align 8, !tbaa !20
  %73 = bitcast %struct.TValue* %72 to i64*
  store i64 %70, i64* %73, align 8, !tbaa !21
  br label %74

; <label>:74:                                     ; preds = %68, %26, %17
  %75 = phi %struct.TValue* [ %72, %68 ], [ %28, %26 ], [ %18, %17 ]
  %76 = phi i8 [ 35, %68 ], [ 35, %26 ], [ 19, %17 ]
  %77 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 1
  store i8 %76, i8* %77, align 8, !tbaa !22
  %78 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 1
  store %union.StackValue* %79, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @math_randomseed(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001001) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %30

; <label>:23:                                     ; preds = %17
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  %27 = icmp eq %struct.TValue* %18, %26
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %23
  %29 = bitcast i8* %2 to %struct.RanState*
  tail call fastcc void @randseed(%struct.lua_State* nonnull %0, %struct.RanState* %29) #16
  br label %45

; <label>:30:                                     ; preds = %17, %23
  %31 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 1) #16
  %32 = tail call i64 @luaL_optinteger(%struct.lua_State* nonnull %0, i32 2, i64 0) #16
  %33 = bitcast i8* %2 to i64*
  store i64 %31, i64* %33, align 8, !tbaa !82
  %34 = getelementptr inbounds i8, i8* %2, i64 8
  %35 = bitcast i8* %34 to i64*
  store i64 255, i64* %35, align 8, !tbaa !82
  %36 = getelementptr inbounds i8, i8* %2, i64 16
  %37 = bitcast i8* %36 to i64*
  store i64 %32, i64* %37, align 8, !tbaa !82
  %38 = getelementptr inbounds i8, i8* %2, i64 24
  %39 = bitcast i8* %38 to i64*
  store i64 0, i64* %39, align 8, !tbaa !82
  br label %40

; <label>:40:                                     ; preds = %40, %30
  %41 = phi i32 [ 0, %30 ], [ %43, %40 ]
  %42 = tail call fastcc i64 @nextrand(i64* %33) #17
  %43 = add nuw nsw i32 %41, 1
  %44 = icmp eq i32 %43, 16
  br i1 %44, label %45, label %40

; <label>:45:                                     ; preds = %40, %28
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gctm(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = icmp sgt i64 %2, 0
  br i1 %3, label %4, label %14

; <label>:4:                                      ; preds = %1
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  br label %6

; <label>:6:                                      ; preds = %4, %6
  %7 = phi i64 [ %2, %4 ], [ %12, %6 ]
  %8 = tail call i32 @lua_rawgeti(%struct.lua_State* %0, i32 1, i64 %7) #16
  %9 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 -1
  store %union.StackValue* %10, %union.StackValue** %5, align 8, !tbaa !20
  %11 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %10, i32 0) #17
  %12 = add nsw i64 %7, -1
  %13 = icmp sgt i64 %7, 1
  br i1 %13, label %6, label %14

; <label>:14:                                     ; preds = %6, %1
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_loadlib(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %2, i8* %3) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %16, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = bitcast %union.StackValue** %7 to %struct.TValue**
  %9 = load %struct.TValue*, %struct.TValue** %8, align 8, !tbaa !20
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %9, i64 0, i32 1
  store i8 0, i8* %10, align 8, !tbaa !21
  %11 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %7, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  %13 = icmp eq i32 %4, 1
  %14 = select i1 %13, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.468, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.469, i64 0, i64 0)
  %15 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %14) #16
  br label %16

; <label>:16:                                     ; preds = %1, %6
  %17 = phi i32 [ 3, %6 ], [ 1, %1 ]
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_searchpath(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i64* null) #16
  %5 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0), i64* null) #16
  %6 = tail call fastcc i8* @searchpath(%struct.lua_State* %0, i8* %2, i8* %3, i8* %4, i8* %5) #16
  %7 = icmp eq i8* %6, null
  br i1 %7, label %8, label %15

; <label>:8:                                      ; preds = %1
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = bitcast %union.StackValue** %9 to %struct.TValue**
  %11 = load %struct.TValue*, %struct.TValue** %10, align 8, !tbaa !20
  %12 = getelementptr inbounds %struct.TValue, %struct.TValue* %11, i64 0, i32 1
  store i8 0, i8* %12, align 8, !tbaa !21
  %13 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %14 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 1
  store %union.StackValue* %14, %union.StackValue** %9, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 1) #16
  br label %15

; <label>:15:                                     ; preds = %1, %8
  %16 = phi i32 [ 2, %8 ], [ 1, %1 ]
  ret i32 %16
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @lookforfunc(%struct.lua_State*, i8*, i8* nocapture readonly) unnamed_addr #0 {
  %4 = tail call i32 @lua_rawgetp(%struct.lua_State* %0, i32 -1001000, i8* bitcast (i32* @CLIBS to i8*)) #17
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0
  %8 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %7, i8* %1) #17
  %9 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1) #17
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 -2
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  %12 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %11, i32 0) #17
  %13 = icmp eq i8* %9, null
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %3
  %15 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0)) #17
  br label %28

; <label>:16:                                     ; preds = %3
  %17 = load i8, i8* %2, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 42
  br i1 %18, label %19, label %26

; <label>:19:                                     ; preds = %16
  %20 = bitcast %union.StackValue** %5 to %struct.TValue**
  %21 = load %struct.TValue*, %struct.TValue** %20, align 8, !tbaa !20
  %22 = bitcast %struct.TValue* %21 to i32*
  store i32 1, i32* %22, align 8, !tbaa !21
  %23 = getelementptr inbounds %struct.TValue, %struct.TValue* %21, i64 0, i32 1
  store i8 1, i8* %23, align 8, !tbaa !22
  %24 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 1
  store %union.StackValue* %25, %union.StackValue** %5, align 8, !tbaa !20
  br label %28

; <label>:26:                                     ; preds = %16
  %27 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.470, i64 0, i64 0)) #17
  br label %28

; <label>:28:                                     ; preds = %26, %19, %14
  %29 = phi i32 [ 1, %14 ], [ 0, %19 ], [ 2, %26 ]
  ret i32 %29
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @searchpath(%struct.lua_State*, i8*, i8*, i8* nocapture readonly, i8* nocapture readonly) unnamed_addr #0 {
  %6 = alloca %struct.luaL_Buffer, align 8
  %7 = alloca %struct.luaL_Buffer, align 8
  %8 = bitcast %struct.luaL_Buffer* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %8) #7
  %9 = load i8, i8* %3, align 1, !tbaa !21
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %17, label %11

; <label>:11:                                     ; preds = %5
  %12 = sext i8 %9 to i32
  %13 = tail call i8* @strchr(i8* %1, i32 %12) #21
  %14 = icmp eq i8* %13, null
  br i1 %14, label %17, label %15

; <label>:15:                                     ; preds = %11
  %16 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %1, i8* nonnull %3, i8* %4) #16
  br label %17

; <label>:17:                                     ; preds = %11, %5, %15
  %18 = phi i8* [ %16, %15 ], [ %1, %11 ], [ %1, %5 ]
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %19, align 8, !tbaa !207
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 4
  %21 = bitcast %struct.luaL_Buffer* %7 to %union.anon.6**
  store %union.anon.6* %20, %union.anon.6** %21, align 8, !tbaa !206
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 2
  %23 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 1
  %24 = bitcast i64* %23 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %24, align 8, !tbaa !82
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %7, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.6, i64 0, i64 0), i8* %18) #16
  %25 = load i64, i64* %22, align 8, !tbaa !205
  %26 = load i64, i64* %23, align 8, !tbaa !203
  %27 = icmp ult i64 %25, %26
  br i1 %27, label %31, label %28

; <label>:28:                                     ; preds = %17
  %29 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1, i32 -1) #17
  %30 = load i64, i64* %22, align 8, !tbaa !205
  br label %31

; <label>:31:                                     ; preds = %28, %17
  %32 = phi i64 [ %30, %28 ], [ %25, %17 ]
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 0
  %34 = load i8*, i8** %33, align 8, !tbaa !206
  %35 = add i64 %32, 1
  store i64 %35, i64* %22, align 8, !tbaa !205
  %36 = getelementptr inbounds i8, i8* %34, i64 %32
  store i8 0, i8* %36, align 1, !tbaa !21
  %37 = load i8*, i8** %33, align 8, !tbaa !206
  %38 = load i64, i64* %22, align 8, !tbaa !205
  %39 = getelementptr inbounds i8, i8* %37, i64 %38
  %40 = getelementptr inbounds i8, i8* %39, i64 -1
  %41 = icmp eq i8* %37, %40
  br i1 %41, label %61, label %42

; <label>:42:                                     ; preds = %31
  br label %45

; <label>:43:                                     ; preds = %51
  %44 = icmp eq i8* %55, %40
  br i1 %44, label %61, label %45

; <label>:45:                                     ; preds = %42, %43
  %46 = phi i8* [ %55, %43 ], [ %37, %42 ]
  %47 = load i8, i8* %46, align 1, !tbaa !21
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %49, label %51

; <label>:49:                                     ; preds = %45
  store i8 59, i8* %46, align 1, !tbaa !21
  %50 = getelementptr inbounds i8, i8* %46, i64 1
  br label %51

; <label>:51:                                     ; preds = %49, %45
  %52 = phi i8* [ %50, %49 ], [ %46, %45 ]
  %53 = call i8* @strchr(i8* nonnull %52, i32 59) #21
  %54 = icmp eq i8* %53, null
  %55 = select i1 %54, i8* %40, i8* %53
  store i8 0, i8* %55, align 1, !tbaa !21
  %56 = call %struct._IO_FILE* @fopen64(i8* nonnull %52, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i64 0, i64 0)) #17
  %57 = icmp eq %struct._IO_FILE* %56, null
  br i1 %57, label %43, label %58

; <label>:58:                                     ; preds = %51
  %59 = call i32 @fclose(%struct._IO_FILE* nonnull %56) #17
  %60 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %52) #16
  br label %69

; <label>:61:                                     ; preds = %43, %31
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %7) #16
  %62 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %63 = bitcast %struct.luaL_Buffer* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %63) #7
  %64 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %64, align 8, !tbaa !207
  %65 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 4
  %66 = bitcast %struct.luaL_Buffer* %6 to %union.anon.6**
  store %union.anon.6* %65, %union.anon.6** %66, align 8, !tbaa !206
  %67 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %6, i64 0, i32 1
  %68 = bitcast i64* %67 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %68, align 8, !tbaa !82
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %6, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.473, i64 0, i64 0)) #17
  call void @luaL_addgsub(%struct.luaL_Buffer* nonnull %6, i8* %62, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.472, i64 0, i64 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.474, i64 0, i64 0)) #17
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %6, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.475, i64 0, i64 0)) #17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %6) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %63) #7
  br label %69

; <label>:69:                                     ; preds = %61, %58
  %70 = phi i8* [ %60, %58 ], [ null, %61 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %8) #7
  ret i8* %70
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @searcher_preload(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %4 = load %struct.global_State*, %struct.global_State** %3, align 8, !tbaa !2
  %5 = getelementptr inbounds %struct.global_State, %struct.global_State* %4, i64 0, i32 7
  %6 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %5, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i64 0, i64 0)) #17
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %10 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* %2) #17
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %12, label %14

; <label>:12:                                     ; preds = %1
  %13 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.476, i64 0, i64 0), i8* %2) #16
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = tail call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.477, i64 0, i64 0)) #16
  br label %16

; <label>:16:                                     ; preds = %14, %12
  %17 = phi i32 [ 1, %12 ], [ 2, %14 ]
  ret i32 %17
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @searcher_Lua(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.64, i64 0, i64 0)) #16
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_loadfilex(%struct.lua_State* %0, i8* nonnull %3, i8* null) #16
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3) #16
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @searcher_C(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0)) #16
  %4 = icmp eq i8* %3, null
  br i1 %4, label %9, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %3, i8* %2) #16
  %7 = icmp eq i32 %6, 0
  %8 = zext i1 %7 to i32
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 %8, i8* nonnull %3) #16
  br label %9

; <label>:9:                                      ; preds = %1, %5
  %10 = phi i32 [ 2, %5 ], [ 1, %1 ]
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @searcher_Croot(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @strchr(i8* %2, i32 46) #21
  %4 = icmp eq i8* %3, null
  br i1 %4, label %20, label %5

; <label>:5:                                      ; preds = %1
  %6 = ptrtoint i8* %3 to i64
  %7 = ptrtoint i8* %2 to i64
  %8 = sub i64 %6, %7
  %9 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %2, i64 %8) #16
  %10 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %11 = tail call fastcc i8* @findfile(%struct.lua_State* %0, i8* %10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.67, i64 0, i64 0)) #16
  %12 = icmp eq i8* %11, null
  br i1 %12, label %20, label %13

; <label>:13:                                     ; preds = %5
  %14 = tail call fastcc i32 @loadfunc(%struct.lua_State* %0, i8* nonnull %11, i8* %2) #16
  switch i32 %14, label %15 [
    i32 0, label %18
    i32 2, label %16
  ]

; <label>:15:                                     ; preds = %13
  tail call fastcc void @checkload(%struct.lua_State* %0, i32 0, i8* nonnull %11) #16
  br label %20

; <label>:16:                                     ; preds = %13
  %17 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.483, i64 0, i64 0), i8* %2, i8* nonnull %11) #16
  br label %20

; <label>:18:                                     ; preds = %13
  %19 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %11) #16
  br label %20

; <label>:20:                                     ; preds = %5, %1, %18, %16, %15
  %21 = phi i32 [ 2, %15 ], [ 1, %16 ], [ 2, %18 ], [ 0, %1 ], [ 1, %5 ]
  ret i32 %21
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @findfile(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = bitcast %struct.CallInfo** %4 to %struct.TValue***
  %6 = load %struct.TValue**, %struct.TValue*** %5, align 8, !tbaa !24
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  %9 = load i8, i8* %8, align 8, !tbaa !21
  %10 = icmp eq i8 %9, 38
  br i1 %10, label %11, label %15

; <label>:11:                                     ; preds = %3
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %27

; <label>:15:                                     ; preds = %3
  %16 = bitcast %struct.TValue* %7 to %struct.CClosure**
  %17 = load %struct.CClosure*, %struct.CClosure** %16, align 8, !tbaa !21
  %18 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %17, i64 0, i32 3
  %19 = load i8, i8* %18, align 2, !tbaa !138
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %23, label %21

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %17, i64 0, i32 6, i64 0
  br label %27

; <label>:23:                                     ; preds = %15
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  br label %27

; <label>:27:                                     ; preds = %11, %21, %23
  %28 = phi %struct.TValue* [ %14, %11 ], [ %22, %21 ], [ %26, %23 ]
  %29 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %28, i8* %2) #17
  %30 = tail call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #16
  %31 = icmp eq i8* %30, null
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %27
  %33 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.478, i64 0, i64 0), i8* %2) #16
  unreachable

; <label>:34:                                     ; preds = %27
  %35 = tail call fastcc i8* @searchpath(%struct.lua_State* nonnull %0, i8* %1, i8* nonnull %30, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.471, i64 0, i64 0)) #16
  ret i8* %35
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checkload(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = icmp eq i32 %1, 0
  br i1 %4, label %5, label %9

; <label>:5:                                      ; preds = %3
  %6 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %7 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #16
  %8 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.479, i64 0, i64 0), i8* %6, i8* %2, i8* %7) #16
  unreachable

; <label>:9:                                      ; preds = %3
  %10 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %2) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @loadfunc(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = tail call i8* @luaL_gsub(%struct.lua_State* %0, i8* %2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.290, i64 0, i64 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.480, i64 0, i64 0)) #16
  %5 = tail call i8* @strchr(i8* %4, i32 45) #21
  %6 = icmp eq i8* %5, null
  br i1 %6, label %16, label %7

; <label>:7:                                      ; preds = %3
  %8 = ptrtoint i8* %5 to i64
  %9 = ptrtoint i8* %4 to i64
  %10 = sub i64 %8, %9
  %11 = tail call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %4, i64 %10) #16
  %12 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* nonnull %11) #16
  %13 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %12) #16
  %14 = icmp eq i32 %13, 2
  %15 = getelementptr inbounds i8, i8* %5, i64 1
  br i1 %14, label %16, label %20

; <label>:16:                                     ; preds = %3, %7
  %17 = phi i8* [ %15, %7 ], [ %4, %3 ]
  %18 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.482, i64 0, i64 0), i8* %17) #16
  %19 = tail call fastcc i32 @lookforfunc(%struct.lua_State* %0, i8* %1, i8* nonnull %18) #16
  br label %20

; <label>:20:                                     ; preds = %7, %16
  %21 = phi i32 [ %19, %16 ], [ %13, %7 ]
  ret i32 %21
}

; Function Attrs: nounwind optsize readonly
declare i8* @getenv(i8* nocapture) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal i32 @ll_require(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  tail call void @lua_settop(%struct.lua_State* %0, i32 1) #16
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %6 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %7 = getelementptr inbounds %struct.global_State, %struct.global_State* %6, i64 0, i32 7
  %8 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %7, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i64 0, i64 0)) #17
  %9 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %10 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %9, i64 0, i32 0
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !64
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 2
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %15 = icmp ult %union.StackValue* %12, %14
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %1
  %17 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %18 = getelementptr inbounds %struct.global_State, %struct.global_State* %17, i64 0, i32 8
  br label %21

; <label>:19:                                     ; preds = %1
  %20 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 0, i32 0
  br label %21

; <label>:21:                                     ; preds = %16, %19
  %22 = phi %struct.TValue* [ %18, %16 ], [ %20, %19 ]
  %23 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %22, i8* %3) #17
  %24 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -1, i32 0
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -1, i32 0, i32 1
  %27 = load i8, i8* %26, align 8, !tbaa !22
  %28 = and i8 %27, 15
  %29 = icmp eq i8 %28, 0
  br i1 %29, label %36, label %30

; <label>:30:                                     ; preds = %21
  %31 = icmp eq i8 %27, 1
  br i1 %31, label %32, label %211

; <label>:32:                                     ; preds = %30
  %33 = bitcast %struct.TValue* %25 to i32*
  %34 = load i32, i32* %33, align 8, !tbaa !21
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %211

; <label>:36:                                     ; preds = %21, %32
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %24, i64 -1
  store %union.StackValue* %37, %union.StackValue** %13, align 8, !tbaa !20
  %38 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %37, i32 0) #17
  %39 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %39) #7
  %40 = bitcast %struct.CallInfo** %4 to %struct.TValue***
  %41 = load %struct.TValue**, %struct.TValue*** %40, align 8, !tbaa !24
  %42 = load %struct.TValue*, %struct.TValue** %41, align 8, !tbaa !64
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %42, i64 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !21
  %45 = icmp eq i8 %44, 38
  br i1 %45, label %46, label %49

; <label>:46:                                     ; preds = %36
  %47 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %48 = getelementptr inbounds %struct.global_State, %struct.global_State* %47, i64 0, i32 8
  br label %60

; <label>:49:                                     ; preds = %36
  %50 = bitcast %struct.TValue* %42 to %struct.CClosure**
  %51 = load %struct.CClosure*, %struct.CClosure** %50, align 8, !tbaa !21
  %52 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %51, i64 0, i32 3
  %53 = load i8, i8* %52, align 2, !tbaa !138
  %54 = icmp eq i8 %53, 0
  br i1 %54, label %57, label %55

; <label>:55:                                     ; preds = %49
  %56 = getelementptr inbounds %struct.CClosure, %struct.CClosure* %51, i64 0, i32 6, i64 0
  br label %60

; <label>:57:                                     ; preds = %49
  %58 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %59 = getelementptr inbounds %struct.global_State, %struct.global_State* %58, i64 0, i32 8
  br label %60

; <label>:60:                                     ; preds = %57, %55, %46
  %61 = phi %struct.TValue* [ %48, %46 ], [ %56, %55 ], [ %59, %57 ]
  %62 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %61, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.467, i64 0, i64 0)) #17
  %63 = icmp eq i32 %62, 5
  br i1 %63, label %66, label %64

; <label>:64:                                     ; preds = %60
  %65 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.489, i64 0, i64 0)) #17
  unreachable

; <label>:66:                                     ; preds = %60
  %67 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %67, align 8, !tbaa !207
  %68 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %69 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %68, %union.anon.6** %69, align 8, !tbaa !206
  %70 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %71 = bitcast i64* %70 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %71, align 8, !tbaa !82
  %72 = call i32 @lua_rawgeti(%struct.lua_State* nonnull %0, i32 3, i64 1) #17
  %73 = icmp eq i32 %72, 0
  br i1 %73, label %75, label %74

; <label>:74:                                     ; preds = %66
  br label %78

; <label>:75:                                     ; preds = %104, %66
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 -2) #17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #17
  %76 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #17
  %77 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.490, i64 0, i64 0), i8* %3, i8* %76) #17
  unreachable

; <label>:78:                                     ; preds = %74, %104
  %79 = phi i64 [ %105, %104 ], [ 1, %74 ]
  %80 = call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* %3) #17
  %81 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %82 = getelementptr inbounds %union.StackValue, %union.StackValue* %81, i64 -2
  call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %82, i32 2) #17
  %83 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 -2, i32 0, i32 1
  %85 = load i8, i8* %84, align 8, !tbaa !22
  %86 = and i8 %85, 15
  %87 = trunc i8 %85 to i4
  switch i4 %87, label %95 [
    i4 0, label %88
    i4 6, label %108
  ]

; <label>:88:                                     ; preds = %78
  %89 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 -2, i32 0
  %90 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %91 = getelementptr inbounds %struct.global_State, %struct.global_State* %90, i64 0, i32 8
  %92 = icmp eq %struct.TValue* %89, %91
  br i1 %92, label %101, label %93

; <label>:93:                                     ; preds = %88
  %94 = icmp eq i8 %86, 6
  br i1 %94, label %108, label %95

; <label>:95:                                     ; preds = %93, %78
  %96 = add nsw i8 %86, -3
  %97 = icmp ugt i8 %96, 1
  br i1 %97, label %101, label %98

; <label>:98:                                     ; preds = %95
  %99 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 -1
  store %union.StackValue* %99, %union.StackValue** %13, align 8, !tbaa !20
  %100 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %99, i32 0) #17
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %2) #17
  br label %104

; <label>:101:                                    ; preds = %95, %88
  %102 = getelementptr inbounds %union.StackValue, %union.StackValue* %83, i64 -2
  store %union.StackValue* %102, %union.StackValue** %13, align 8, !tbaa !20
  %103 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %102, i32 0) #17
  br label %104

; <label>:104:                                    ; preds = %101, %98
  %105 = add nuw i64 %79, 1
  %106 = call i32 @lua_rawgeti(%struct.lua_State* nonnull %0, i32 3, i64 %105) #17
  %107 = icmp eq i32 %106, 0
  br i1 %107, label %75, label %78

; <label>:108:                                    ; preds = %78, %93
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %39) #7
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  %109 = bitcast %union.StackValue** %13 to %struct.TValue**
  %110 = load %struct.TValue*, %struct.TValue** %109, align 8, !tbaa !20
  %111 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %112 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %111, i64 0, i32 0
  %113 = load %union.StackValue*, %union.StackValue** %112, align 8, !tbaa !64
  %114 = getelementptr inbounds %union.StackValue, %union.StackValue* %113, i64 1
  %115 = bitcast %struct.TValue* %110 to %union.StackValue*
  %116 = icmp ult %union.StackValue* %114, %115
  br i1 %116, label %120, label %117

; <label>:117:                                    ; preds = %108
  %118 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %119 = getelementptr inbounds %struct.global_State, %struct.global_State* %118, i64 0, i32 8
  br label %122

; <label>:120:                                    ; preds = %108
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %114, i64 0, i32 0
  br label %122

; <label>:122:                                    ; preds = %117, %120
  %123 = phi %struct.TValue* [ %119, %117 ], [ %121, %120 ]
  %124 = bitcast %struct.TValue* %123 to i64*
  %125 = bitcast %struct.TValue* %110 to i64*
  %126 = load i64, i64* %124, align 8
  store i64 %126, i64* %125, align 8
  %127 = getelementptr inbounds %struct.TValue, %struct.TValue* %123, i64 0, i32 1
  %128 = load i8, i8* %127, align 8, !tbaa !22
  %129 = getelementptr inbounds %struct.TValue, %struct.TValue* %110, i64 0, i32 1
  store i8 %128, i8* %129, align 8, !tbaa !22
  %130 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %131 = getelementptr inbounds %union.StackValue, %union.StackValue* %130, i64 1
  store %union.StackValue* %131, %union.StackValue** %13, align 8, !tbaa !20
  %132 = getelementptr inbounds %union.StackValue, %union.StackValue* %130, i64 -2, i32 0
  %133 = bitcast %struct.TValue* %132 to i64*
  %134 = bitcast %union.StackValue* %131 to i64*
  %135 = load i64, i64* %133, align 8
  store i64 %135, i64* %134, align 8
  %136 = getelementptr inbounds %union.StackValue, %union.StackValue* %130, i64 -2, i32 0, i32 1
  %137 = load i8, i8* %136, align 8, !tbaa !22
  %138 = getelementptr inbounds %union.StackValue, %union.StackValue* %130, i64 1, i32 0, i32 1
  store i8 %137, i8* %138, align 8, !tbaa !22
  %139 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %140 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 1
  store %union.StackValue* %140, %union.StackValue** %13, align 8, !tbaa !20
  %141 = getelementptr inbounds %union.StackValue, %union.StackValue* %139, i64 -2
  call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %141, i32 1) #17
  %142 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %143 = getelementptr inbounds %union.StackValue, %union.StackValue* %142, i64 -1, i32 0, i32 1
  %144 = load i8, i8* %143, align 8, !tbaa !22
  %145 = and i8 %144, 15
  %146 = icmp eq i8 %145, 0
  br i1 %146, label %147, label %152

; <label>:147:                                    ; preds = %122
  %148 = getelementptr inbounds %union.StackValue, %union.StackValue* %142, i64 -1, i32 0
  %149 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %150 = getelementptr inbounds %struct.global_State, %struct.global_State* %149, i64 0, i32 8
  %151 = icmp eq %struct.TValue* %148, %150
  br i1 %151, label %152, label %165

; <label>:152:                                    ; preds = %122, %147
  %153 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %154 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %153, i64 0, i32 0
  %155 = load %union.StackValue*, %union.StackValue** %154, align 8, !tbaa !64
  %156 = getelementptr inbounds %union.StackValue, %union.StackValue* %155, i64 2
  %157 = icmp ult %union.StackValue* %156, %142
  br i1 %157, label %161, label %158

; <label>:158:                                    ; preds = %152
  %159 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %160 = getelementptr inbounds %struct.global_State, %struct.global_State* %159, i64 0, i32 8
  br label %163

; <label>:161:                                    ; preds = %152
  %162 = getelementptr inbounds %union.StackValue, %union.StackValue* %156, i64 0, i32 0
  br label %163

; <label>:163:                                    ; preds = %158, %161
  %164 = phi %struct.TValue* [ %160, %158 ], [ %162, %161 ]
  call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %164, i8* %3) #17
  br label %168

; <label>:165:                                    ; preds = %147
  %166 = getelementptr inbounds %union.StackValue, %union.StackValue* %142, i64 -1
  store %union.StackValue* %166, %union.StackValue** %13, align 8, !tbaa !20
  %167 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %166, i32 0) #17
  br label %168

; <label>:168:                                    ; preds = %165, %163
  %169 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %170 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %169, i64 0, i32 0
  %171 = load %union.StackValue*, %union.StackValue** %170, align 8, !tbaa !64
  %172 = getelementptr inbounds %union.StackValue, %union.StackValue* %171, i64 2
  %173 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %174 = icmp ult %union.StackValue* %172, %173
  br i1 %174, label %178, label %175

; <label>:175:                                    ; preds = %168
  %176 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %177 = getelementptr inbounds %struct.global_State, %struct.global_State* %176, i64 0, i32 8
  br label %180

; <label>:178:                                    ; preds = %168
  %179 = getelementptr inbounds %union.StackValue, %union.StackValue* %172, i64 0, i32 0
  br label %180

; <label>:180:                                    ; preds = %175, %178
  %181 = phi %struct.TValue* [ %177, %175 ], [ %179, %178 ]
  %182 = call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %181, i8* %3) #17
  %183 = icmp eq i32 %182, 0
  br i1 %183, label %184, label %210

; <label>:184:                                    ; preds = %180
  %185 = load %struct.TValue*, %struct.TValue** %109, align 8, !tbaa !20
  %186 = bitcast %struct.TValue* %185 to i32*
  store i32 1, i32* %186, align 8, !tbaa !21
  %187 = getelementptr inbounds %struct.TValue, %struct.TValue* %185, i64 0, i32 1
  store i8 1, i8* %187, align 8, !tbaa !22
  %188 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %189 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 1
  store %union.StackValue* %189, %union.StackValue** %13, align 8, !tbaa !20
  %190 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 -1, i32 0
  %191 = bitcast %union.StackValue* %188 to i64*
  %192 = bitcast %struct.TValue* %190 to i64*
  %193 = load i64, i64* %191, align 8
  store i64 %193, i64* %192, align 8
  %194 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 0, i32 0, i32 1
  %195 = load i8, i8* %194, align 8, !tbaa !22
  %196 = getelementptr inbounds %union.StackValue, %union.StackValue* %188, i64 -1, i32 0, i32 1
  store i8 %195, i8* %196, align 8, !tbaa !22
  %197 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %198 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %197, i64 0, i32 0
  %199 = load %union.StackValue*, %union.StackValue** %198, align 8, !tbaa !64
  %200 = getelementptr inbounds %union.StackValue, %union.StackValue* %199, i64 2
  %201 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !20
  %202 = icmp ult %union.StackValue* %200, %201
  br i1 %202, label %206, label %203

; <label>:203:                                    ; preds = %184
  %204 = load %struct.global_State*, %struct.global_State** %5, align 8, !tbaa !2
  %205 = getelementptr inbounds %struct.global_State, %struct.global_State* %204, i64 0, i32 8
  br label %208

; <label>:206:                                    ; preds = %184
  %207 = getelementptr inbounds %union.StackValue, %union.StackValue* %200, i64 0, i32 0
  br label %208

; <label>:208:                                    ; preds = %203, %206
  %209 = phi %struct.TValue* [ %205, %203 ], [ %207, %206 ]
  call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %209, i8* %3) #17
  br label %210

; <label>:210:                                    ; preds = %208, %180
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #16
  br label %211

; <label>:211:                                    ; preds = %30, %32, %210
  %212 = phi i32 [ 2, %210 ], [ 1, %32 ], [ 1, %30 ]
  ret i32 %212
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_clock(%struct.lua_State* nocapture) #0 {
  %2 = tail call i64 @clock() #17
  %3 = sitofp i64 %2 to double
  %4 = fdiv double %3, 1.000000e+06
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_date(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca [4 x i8], align 1
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.501, i64 0, i64 0), i64* nonnull %2) #16
  %8 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !24
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %10, i64 0, i32 0
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !64
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %16 = icmp ult %union.StackValue* %13, %15
  br i1 %16, label %21, label %17

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %19 = load %struct.global_State*, %struct.global_State** %18, align 8, !tbaa !2
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %19, i64 0, i32 8
  br label %23

; <label>:21:                                     ; preds = %1
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 0, i32 0
  br label %23

; <label>:23:                                     ; preds = %17, %21
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %29, label %31

; <label>:29:                                     ; preds = %23
  %30 = call i64 @time(i64* null) #17
  br label %33

; <label>:31:                                     ; preds = %23
  %32 = call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #17
  br label %33

; <label>:33:                                     ; preds = %31, %29
  %34 = phi i64 [ %30, %29 ], [ %32, %31 ]
  store i64 %34, i64* %3, align 8, !tbaa !82
  %35 = load i64, i64* %2, align 8, !tbaa !82
  %36 = getelementptr inbounds i8, i8* %7, i64 %35
  %37 = load i8, i8* %7, align 1, !tbaa !21
  %38 = icmp eq i8 %37, 33
  br i1 %38, label %39, label %42

; <label>:39:                                     ; preds = %33
  %40 = call %struct.tm* @gmtime(i64* nonnull %3) #17
  %41 = getelementptr inbounds i8, i8* %7, i64 1
  br label %44

; <label>:42:                                     ; preds = %33
  %43 = call %struct.tm* @localtime(i64* nonnull %3) #17
  br label %44

; <label>:44:                                     ; preds = %42, %39
  %45 = phi %struct.tm* [ %40, %39 ], [ %43, %42 ]
  %46 = phi i8* [ %41, %39 ], [ %7, %42 ]
  %47 = icmp eq %struct.tm* %45, null
  br i1 %47, label %48, label %50

; <label>:48:                                     ; preds = %44
  %49 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0)) #16
  unreachable

; <label>:50:                                     ; preds = %44
  %51 = call i32 @strcmp(i8* nonnull %46, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.503, i64 0, i64 0)) #21
  %52 = icmp eq i32 %51, 0
  br i1 %52, label %53, label %54

; <label>:53:                                     ; preds = %50
  call void @lua_createtable(%struct.lua_State* nonnull %0, i32 0, i32 9) #16
  call fastcc void @setallfields(%struct.lua_State* nonnull %0, %struct.tm* nonnull %45) #16
  br label %127

; <label>:54:                                     ; preds = %50
  %55 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %55) #7
  %56 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %56) #7
  store i8 37, i8* %55, align 1, !tbaa !21
  %57 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %57, align 8, !tbaa !207
  %58 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %59 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %58, %union.anon.6** %59, align 8, !tbaa !206
  %60 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %61 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %62 = bitcast i64* %61 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %62, align 8, !tbaa !82
  %63 = icmp ult i8* %46, %36
  br i1 %63, label %64, label %126

; <label>:64:                                     ; preds = %54
  %65 = ptrtoint i8* %36 to i64
  %66 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i64 0, i64 1
  %67 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  br label %68

; <label>:68:                                     ; preds = %64, %123
  %69 = phi i8* [ %46, %64 ], [ %124, %123 ]
  %70 = load i8, i8* %69, align 1, !tbaa !21
  %71 = icmp eq i8 %70, 37
  br i1 %71, label %87, label %72

; <label>:72:                                     ; preds = %68
  %73 = load i64, i64* %60, align 8, !tbaa !205
  %74 = load i64, i64* %61, align 8, !tbaa !203
  %75 = icmp ult i64 %73, %74
  br i1 %75, label %80, label %76

; <label>:76:                                     ; preds = %72
  %77 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %78 = load i8, i8* %69, align 1, !tbaa !21
  %79 = load i64, i64* %60, align 8, !tbaa !205
  br label %80

; <label>:80:                                     ; preds = %76, %72
  %81 = phi i64 [ %79, %76 ], [ %73, %72 ]
  %82 = phi i8 [ %78, %76 ], [ %70, %72 ]
  %83 = getelementptr inbounds i8, i8* %69, i64 1
  %84 = load i8*, i8** %67, align 8, !tbaa !206
  %85 = add i64 %81, 1
  store i64 %85, i64* %60, align 8, !tbaa !205
  %86 = getelementptr inbounds i8, i8* %84, i64 %81
  store i8 %82, i8* %86, align 1, !tbaa !21
  br label %123

; <label>:87:                                     ; preds = %68
  %88 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 250, i32 -1) #17
  %89 = getelementptr inbounds i8, i8* %69, i64 1
  %90 = ptrtoint i8* %89 to i64
  %91 = sub i64 %65, %90
  br label %92

; <label>:92:                                     ; preds = %109, %87
  %93 = phi i8 [ 97, %87 ], [ %113, %109 ]
  %94 = phi i32 [ 1, %87 ], [ %111, %109 ]
  %95 = phi i8* [ getelementptr inbounds ([78 x i8], [78 x i8]* @.str.513, i64 0, i64 0), %87 ], [ %112, %109 ]
  %96 = sext i32 %94 to i64
  %97 = icmp slt i64 %91, %96
  br i1 %97, label %115, label %98

; <label>:98:                                     ; preds = %92
  %99 = icmp eq i8 %93, 124
  br i1 %99, label %100, label %103

; <label>:100:                                    ; preds = %98
  %101 = add nsw i32 %94, 1
  %102 = sext i32 %101 to i64
  br label %109

; <label>:103:                                    ; preds = %98
  %104 = call i32 @memcmp(i8* nonnull %89, i8* %95, i64 %96) #21
  %105 = icmp eq i32 %104, 0
  br i1 %105, label %106, label %109

; <label>:106:                                    ; preds = %103
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %66, i8* nonnull %89, i64 %96, i32 1, i1 false) #7
  %107 = getelementptr inbounds i8, i8* %66, i64 %96
  store i8 0, i8* %107, align 1, !tbaa !21
  %108 = getelementptr inbounds i8, i8* %89, i64 %96
  br label %118

; <label>:109:                                    ; preds = %103, %100
  %110 = phi i64 [ %102, %100 ], [ %96, %103 ]
  %111 = phi i32 [ %101, %100 ], [ %94, %103 ]
  %112 = getelementptr inbounds i8, i8* %95, i64 %110
  %113 = load i8, i8* %112, align 1, !tbaa !21
  %114 = icmp eq i8 %113, 0
  br i1 %114, label %115, label %92

; <label>:115:                                    ; preds = %109, %92
  %116 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.514, i64 0, i64 0), i8* nonnull %89) #17
  %117 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* nonnull %116) #17
  br label %118

; <label>:118:                                    ; preds = %106, %115
  %119 = phi i8* [ %108, %106 ], [ %89, %115 ]
  %120 = call i64 @strftime(i8* %88, i64 250, i8* nonnull %55, %struct.tm* nonnull %45) #17
  %121 = load i64, i64* %60, align 8, !tbaa !205
  %122 = add i64 %121, %120
  store i64 %122, i64* %60, align 8, !tbaa !205
  br label %123

; <label>:123:                                    ; preds = %118, %80
  %124 = phi i8* [ %83, %80 ], [ %119, %118 ]
  %125 = icmp ult i8* %124, %36
  br i1 %125, label %68, label %126

; <label>:126:                                    ; preds = %123, %54
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %56) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %55) #7
  br label %127

; <label>:127:                                    ; preds = %53, %126
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_difftime(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 1) #17
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #17
  %4 = tail call double @difftime(i64 %2, i64 %3) #22
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = bitcast %union.StackValue** %5 to %struct.TValue**
  %7 = load %struct.TValue*, %struct.TValue** %6, align 8, !tbaa !20
  %8 = bitcast %struct.TValue* %7 to double*
  store double %4, double* %8, align 8, !tbaa !21
  %9 = getelementptr inbounds %struct.TValue, %struct.TValue* %7, i64 0, i32 1
  store i8 19, i8* %9, align 8, !tbaa !22
  %10 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  store %union.StackValue* %11, %union.StackValue** %5, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_execute(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i32 @system(i8* %2) #17
  %4 = icmp eq i8* %2, null
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %1
  %6 = tail call i32 @luaL_execresult(%struct.lua_State* %0, i32 %3) #16
  br label %17

; <label>:7:                                      ; preds = %1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %11 = icmp ne i32 %3, 0
  %12 = zext i1 %11 to i32
  %13 = bitcast %struct.TValue* %10 to i32*
  store i32 %12, i32* %13, align 8, !tbaa !21
  %14 = getelementptr inbounds %struct.TValue, %struct.TValue* %10, i64 0, i32 1
  store i8 1, i8* %14, align 8, !tbaa !22
  %15 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 1
  store %union.StackValue* %16, %union.StackValue** %8, align 8, !tbaa !20
  br label %17

; <label>:17:                                     ; preds = %7, %5
  %18 = phi i32 [ %6, %5 ], [ 1, %7 ]
  ret i32 %18
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_exit(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 1
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 1
  br i1 %21, label %22, label %42

; <label>:22:                                     ; preds = %16
  br i1 %9, label %27, label %23

; <label>:23:                                     ; preds = %22
  %24 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %25 = load %struct.global_State*, %struct.global_State** %24, align 8, !tbaa !2
  %26 = getelementptr inbounds %struct.global_State, %struct.global_State* %25, i64 0, i32 8
  br label %29

; <label>:27:                                     ; preds = %22
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %29

; <label>:29:                                     ; preds = %23, %27
  %30 = phi %struct.TValue* [ %26, %23 ], [ %28, %27 ]
  %31 = getelementptr inbounds %struct.TValue, %struct.TValue* %30, i64 0, i32 1
  %32 = load i8, i8* %31, align 8, !tbaa !22
  %33 = and i8 %32, 15
  %34 = icmp eq i8 %33, 0
  br i1 %34, label %49, label %35

; <label>:35:                                     ; preds = %29
  %36 = icmp eq i8 %32, 1
  br i1 %36, label %37, label %49

; <label>:37:                                     ; preds = %35
  %38 = bitcast %struct.TValue* %30 to i32*
  %39 = load i32, i32* %38, align 8, !tbaa !21
  %40 = icmp eq i32 %39, 0
  %41 = zext i1 %40 to i32
  br label %49

; <label>:42:                                     ; preds = %16
  %43 = tail call i64 @luaL_optinteger(%struct.lua_State* nonnull %0, i32 1, i64 0) #16
  %44 = trunc i64 %43 to i32
  %45 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %46 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %45, i64 0, i32 0
  %47 = load %union.StackValue*, %union.StackValue** %46, align 8, !tbaa !64
  %48 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  br label %49

; <label>:49:                                     ; preds = %37, %35, %29, %42
  %50 = phi %union.StackValue* [ %48, %42 ], [ %8, %29 ], [ %8, %35 ], [ %8, %37 ]
  %51 = phi %union.StackValue* [ %47, %42 ], [ %5, %29 ], [ %5, %35 ], [ %5, %37 ]
  %52 = phi i32 [ %44, %42 ], [ 1, %29 ], [ 0, %35 ], [ %41, %37 ]
  %53 = getelementptr inbounds %union.StackValue, %union.StackValue* %51, i64 2
  %54 = icmp ult %union.StackValue* %53, %50
  br i1 %54, label %59, label %55

; <label>:55:                                     ; preds = %49
  %56 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %57 = load %struct.global_State*, %struct.global_State** %56, align 8, !tbaa !2
  %58 = getelementptr inbounds %struct.global_State, %struct.global_State* %57, i64 0, i32 8
  br label %61

; <label>:59:                                     ; preds = %49
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %53, i64 0, i32 0
  br label %61

; <label>:61:                                     ; preds = %55, %59
  %62 = phi %struct.TValue* [ %58, %55 ], [ %60, %59 ]
  %63 = getelementptr inbounds %struct.TValue, %struct.TValue* %62, i64 0, i32 1
  %64 = load i8, i8* %63, align 8, !tbaa !22
  %65 = and i8 %64, 15
  %66 = icmp eq i8 %65, 0
  br i1 %66, label %78, label %67

; <label>:67:                                     ; preds = %61
  %68 = icmp eq i8 %64, 1
  br i1 %68, label %69, label %73

; <label>:69:                                     ; preds = %67
  %70 = bitcast %struct.TValue* %62 to i32*
  %71 = load i32, i32* %70, align 8, !tbaa !21
  %72 = icmp eq i32 %71, 0
  br i1 %72, label %78, label %73

; <label>:73:                                     ; preds = %67, %69
  %74 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %75 = load %struct.global_State*, %struct.global_State** %74, align 8, !tbaa !2
  %76 = getelementptr inbounds %struct.global_State, %struct.global_State* %75, i64 0, i32 38
  %77 = load %struct.lua_State*, %struct.lua_State** %76, align 8, !tbaa !38
  tail call fastcc void @close_state(%struct.lua_State* %77) #17
  br label %78

; <label>:78:                                     ; preds = %61, %73, %69
  tail call void @exit(i32 %52) #19
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_getenv(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @getenv(i8* %2) #17
  %4 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %3) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_remove(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i32 @remove(i8* %2) #17
  %4 = icmp eq i32 %3, 0
  %5 = zext i1 %4 to i32
  %6 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %5, i8* %2) #16
  ret i32 %6
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_rename(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* null) #16
  %4 = tail call i32 @rename(i8* %2, i8* %3) #17
  %5 = icmp eq i32 %4, 0
  %6 = zext i1 %5 to i32
  %7 = tail call i32 @luaL_fileresult(%struct.lua_State* %0, i32 %6, i8* null) #16
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_setlocale(%struct.lua_State*) #0 {
  %2 = tail call i8* @luaL_optlstring(%struct.lua_State* %0, i32 1, i8* null, i64* null) #16
  %3 = tail call i32 @luaL_checkoption(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.515, i64 0, i64 0), i8** getelementptr inbounds ([7 x i8*], [7 x i8*]* @os_setlocale.catnames, i64 0, i64 0)) #16
  %4 = sext i32 %3 to i64
  %5 = getelementptr inbounds [6 x i32], [6 x i32]* @os_setlocale.cat, i64 0, i64 %4
  %6 = load i32, i32* %5, align 4, !tbaa !77
  %7 = tail call i8* @setlocale(i32 %6, i8* %2) #17
  %8 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %7) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_time(%struct.lua_State*) #0 {
  %2 = alloca %struct.tm, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 1
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %25

; <label>:23:                                     ; preds = %17
  %24 = tail call i64 @time(i64* null) #17
  br label %63

; <label>:25:                                     ; preds = %17
  %26 = bitcast %struct.tm* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %26) #7
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 5) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  %27 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0), i32 0, i32 0) #16
  %28 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 0
  store i32 %27, i32* %28, align 8, !tbaa !339
  %29 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0), i32 0, i32 0) #16
  %30 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 1
  store i32 %29, i32* %30, align 4, !tbaa !341
  %31 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0), i32 12, i32 0) #16
  %32 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 2
  store i32 %31, i32* %32, align 8, !tbaa !342
  %33 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0), i32 -1, i32 0) #16
  %34 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 3
  store i32 %33, i32* %34, align 4, !tbaa !343
  %35 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0), i32 -1, i32 1) #16
  %36 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 4
  store i32 %35, i32* %36, align 8, !tbaa !344
  %37 = tail call fastcc i32 @getfield(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0), i32 -1, i32 1900) #16
  %38 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 5
  store i32 %37, i32* %38, align 4, !tbaa !345
  %39 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 -1, i32 0
  %41 = tail call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %40, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0)) #17
  %42 = icmp eq i32 %41, 0
  %43 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  br i1 %42, label %57, label %44

; <label>:44:                                     ; preds = %25
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 -1, i32 0
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 -1, i32 0, i32 1
  %47 = load i8, i8* %46, align 8, !tbaa !22
  %48 = and i8 %47, 15
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %57, label %50

; <label>:50:                                     ; preds = %44
  %51 = icmp eq i8 %47, 1
  br i1 %51, label %52, label %57

; <label>:52:                                     ; preds = %50
  %53 = bitcast %struct.TValue* %45 to i32*
  %54 = load i32, i32* %53, align 8, !tbaa !21
  %55 = icmp ne i32 %54, 0
  %56 = zext i1 %55 to i32
  br label %57

; <label>:57:                                     ; preds = %25, %44, %50, %52
  %58 = phi i32 [ 0, %44 ], [ 1, %50 ], [ %56, %52 ], [ -1, %25 ]
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %43, i64 -1
  store %union.StackValue* %59, %union.StackValue** %8, align 8, !tbaa !20
  %60 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %59, i32 0) #17
  %61 = getelementptr inbounds %struct.tm, %struct.tm* %2, i64 0, i32 8
  store i32 %58, i32* %61, align 8, !tbaa !346
  %62 = call i64 @mktime(%struct.tm* nonnull %2) #17
  call fastcc void @setallfields(%struct.lua_State* nonnull %0, %struct.tm* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %26) #7
  br label %63

; <label>:63:                                     ; preds = %57, %23
  %64 = phi i64 [ %24, %23 ], [ %62, %57 ]
  %65 = icmp eq i64 %64, -1
  br i1 %65, label %66, label %68

; <label>:66:                                     ; preds = %63
  %67 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.502, i64 0, i64 0)) #16
  unreachable

; <label>:68:                                     ; preds = %63
  %69 = bitcast %union.StackValue** %8 to %struct.TValue**
  %70 = load %struct.TValue*, %struct.TValue** %69, align 8, !tbaa !20
  %71 = bitcast %struct.TValue* %70 to i64*
  store i64 %64, i64* %71, align 8, !tbaa !21
  %72 = getelementptr inbounds %struct.TValue, %struct.TValue* %70, i64 0, i32 1
  store i8 35, i8* %72, align 8, !tbaa !22
  %73 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %73, i64 1
  store %union.StackValue* %74, %union.StackValue** %8, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @os_tmpname(%struct.lua_State*) #0 {
  %2 = alloca [20 x i8], align 16
  %3 = getelementptr inbounds [20 x i8], [20 x i8]* %2, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %3) #7
  %4 = call i8* @tmpnam(i8* nonnull %3) #17
  %5 = icmp eq i8* %4, null
  br i1 %5, label %6, label %8

; <label>:6:                                      ; preds = %1
  %7 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.523, i64 0, i64 0)) #16
  unreachable

; <label>:8:                                      ; preds = %1
  %9 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* nonnull %3) #16
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize
declare i64 @clock() local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare %struct.tm* @gmtime(i64*) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare %struct.tm* @localtime(i64*) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @setallfields(%struct.lua_State*, %struct.tm* nocapture readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 0
  %4 = load i32, i32* %3, align 8, !tbaa !339
  %5 = sext i32 %4 to i64
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 35, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %13, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.505, i64 0, i64 0)) #17
  %14 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 1
  %15 = load i32, i32* %14, align 4, !tbaa !341
  %16 = sext i32 %15 to i64
  %17 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %18 = bitcast %struct.TValue* %17 to i64*
  store i64 %16, i64* %18, align 8, !tbaa !21
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 35, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %6, align 8, !tbaa !20
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %22, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.452, i64 0, i64 0)) #17
  %23 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 2
  %24 = load i32, i32* %23, align 8, !tbaa !342
  %25 = sext i32 %24 to i64
  %26 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %27 = bitcast %struct.TValue* %26 to i64*
  store i64 %25, i64* %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 35, i8* %28, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %6, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %31, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.506, i64 0, i64 0)) #17
  %32 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 3
  %33 = load i32, i32* %32, align 4, !tbaa !343
  %34 = sext i32 %33 to i64
  %35 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %36 = bitcast %struct.TValue* %35 to i64*
  store i64 %34, i64* %36, align 8, !tbaa !21
  %37 = getelementptr inbounds %struct.TValue, %struct.TValue* %35, i64 0, i32 1
  store i8 35, i8* %37, align 8, !tbaa !22
  %38 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 1
  store %union.StackValue* %39, %union.StackValue** %6, align 8, !tbaa !20
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %40, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.507, i64 0, i64 0)) #17
  %41 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 4
  %42 = load i32, i32* %41, align 8, !tbaa !344
  %43 = add nsw i32 %42, 1
  %44 = sext i32 %43 to i64
  %45 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %46 = bitcast %struct.TValue* %45 to i64*
  store i64 %44, i64* %46, align 8, !tbaa !21
  %47 = getelementptr inbounds %struct.TValue, %struct.TValue* %45, i64 0, i32 1
  store i8 35, i8* %47, align 8, !tbaa !22
  %48 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 1
  store %union.StackValue* %49, %union.StackValue** %6, align 8, !tbaa !20
  %50 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %50, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.508, i64 0, i64 0)) #17
  %51 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 5
  %52 = load i32, i32* %51, align 4, !tbaa !345
  %53 = add nsw i32 %52, 1900
  %54 = sext i32 %53 to i64
  %55 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %56 = bitcast %struct.TValue* %55 to i64*
  store i64 %54, i64* %56, align 8, !tbaa !21
  %57 = getelementptr inbounds %struct.TValue, %struct.TValue* %55, i64 0, i32 1
  store i8 35, i8* %57, align 8, !tbaa !22
  %58 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 1
  store %union.StackValue* %59, %union.StackValue** %6, align 8, !tbaa !20
  %60 = getelementptr inbounds %union.StackValue, %union.StackValue* %58, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %60, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.509, i64 0, i64 0)) #17
  %61 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 6
  %62 = load i32, i32* %61, align 8, !tbaa !347
  %63 = add nsw i32 %62, 1
  %64 = sext i32 %63 to i64
  %65 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %66 = bitcast %struct.TValue* %65 to i64*
  store i64 %64, i64* %66, align 8, !tbaa !21
  %67 = getelementptr inbounds %struct.TValue, %struct.TValue* %65, i64 0, i32 1
  store i8 35, i8* %67, align 8, !tbaa !22
  %68 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %69 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 1
  store %union.StackValue* %69, %union.StackValue** %6, align 8, !tbaa !20
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %68, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %70, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.510, i64 0, i64 0)) #17
  %71 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 7
  %72 = load i32, i32* %71, align 4, !tbaa !348
  %73 = add nsw i32 %72, 1
  %74 = sext i32 %73 to i64
  %75 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %76 = bitcast %struct.TValue* %75 to i64*
  store i64 %74, i64* %76, align 8, !tbaa !21
  %77 = getelementptr inbounds %struct.TValue, %struct.TValue* %75, i64 0, i32 1
  store i8 35, i8* %77, align 8, !tbaa !22
  %78 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %79 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 1
  store %union.StackValue* %79, %union.StackValue** %6, align 8, !tbaa !20
  %80 = getelementptr inbounds %union.StackValue, %union.StackValue* %78, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* nonnull %80, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.511, i64 0, i64 0)) #17
  %81 = getelementptr inbounds %struct.tm, %struct.tm* %1, i64 0, i32 8
  %82 = load i32, i32* %81, align 8, !tbaa !346
  %83 = icmp slt i32 %82, 0
  br i1 %83, label %93, label %84

; <label>:84:                                     ; preds = %2
  %85 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %86 = icmp ne i32 %82, 0
  %87 = zext i1 %86 to i32
  %88 = bitcast %struct.TValue* %85 to i32*
  store i32 %87, i32* %88, align 8, !tbaa !21
  %89 = getelementptr inbounds %struct.TValue, %struct.TValue* %85, i64 0, i32 1
  store i8 1, i8* %89, align 8, !tbaa !22
  %90 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %91 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 1
  store %union.StackValue* %91, %union.StackValue** %6, align 8, !tbaa !20
  %92 = getelementptr inbounds %union.StackValue, %union.StackValue* %90, i64 -1, i32 0
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %92, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.512, i64 0, i64 0)) #17
  br label %93

; <label>:93:                                     ; preds = %2, %84
  ret void
}

; Function Attrs: nounwind optsize
declare i64 @strftime(i8*, i64, i8*, %struct.tm*) local_unnamed_addr #9

; Function Attrs: nounwind optsize readnone
declare double @difftime(i64, i64) local_unnamed_addr #8

; Function Attrs: optsize
declare i32 @system(i8* nocapture readonly) local_unnamed_addr #11

; Function Attrs: noreturn nounwind optsize
declare void @exit(i32) local_unnamed_addr #15

; Function Attrs: nounwind optsize
declare i32 @remove(i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i32 @rename(i8* nocapture readonly, i8* nocapture readonly) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i8* @setlocale(i32, i8*) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @getfield(%struct.lua_State*, i8*, i32, i32) unnamed_addr #0 {
  %5 = alloca i32, align 4
  %6 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0
  %10 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* nonnull %9, i8* %1) #17
  %11 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 -1, i32* nonnull %5) #16
  %12 = load i32, i32* %5, align 4, !tbaa !77
  %13 = icmp eq i32 %12, 0
  br i1 %13, label %14, label %24

; <label>:14:                                     ; preds = %4
  %15 = icmp eq i32 %10, 0
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %14
  %17 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.520, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:18:                                     ; preds = %14
  %19 = icmp slt i32 %2, 0
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %18
  %21 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.521, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:22:                                     ; preds = %18
  %23 = sext i32 %2 to i64
  br label %32

; <label>:24:                                     ; preds = %4
  %25 = add i64 %11, 1073741823
  %26 = icmp ult i64 %25, 2147483647
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  %28 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.522, i64 0, i64 0), i8* %1) #16
  unreachable

; <label>:29:                                     ; preds = %24
  %30 = sext i32 %3 to i64
  %31 = sub nsw i64 %11, %30
  br label %32

; <label>:32:                                     ; preds = %22, %29
  %33 = phi i64 [ %31, %29 ], [ %23, %22 ]
  %34 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %35 = getelementptr inbounds %union.StackValue, %union.StackValue* %34, i64 -1
  store %union.StackValue* %35, %union.StackValue** %7, align 8, !tbaa !20
  %36 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %35, i32 0) #17
  %37 = trunc i64 %33 to i32
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #7
  ret i32 %37
}

; Function Attrs: nounwind optsize
declare i64 @mktime(%struct.tm* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind optsize
declare i8* @tmpnam(i8*) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_byte(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %6 = load i64, i64* %2, align 8, !tbaa !82
  %7 = icmp sgt i64 %5, 0
  br i1 %7, label %16, label %8

; <label>:8:                                      ; preds = %1
  %9 = icmp eq i64 %5, 0
  %10 = sub nsw i64 0, %6
  %11 = icmp slt i64 %5, %10
  %12 = or i1 %9, %11
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %8
  %14 = add i64 %6, 1
  %15 = add i64 %14, %5
  br label %16

; <label>:16:                                     ; preds = %1, %8, %13
  %17 = phi i64 [ %15, %13 ], [ %5, %1 ], [ 1, %8 ]
  %18 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %5) #17
  %19 = icmp sgt i64 %18, %6
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %16
  %21 = icmp sgt i64 %18, -1
  br i1 %21, label %28, label %22

; <label>:22:                                     ; preds = %20
  %23 = sub nsw i64 0, %6
  %24 = icmp slt i64 %18, %23
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %22
  %26 = add i64 %6, 1
  %27 = add i64 %26, %18
  br label %28

; <label>:28:                                     ; preds = %16, %20, %22, %25
  %29 = phi i64 [ %27, %25 ], [ %6, %16 ], [ %18, %20 ], [ 0, %22 ]
  %30 = icmp ult i64 %29, %17
  br i1 %30, label %60, label %31

; <label>:31:                                     ; preds = %28
  %32 = sub i64 %29, %17
  %33 = icmp ugt i64 %32, 2147483646
  br i1 %33, label %34, label %36

; <label>:34:                                     ; preds = %31
  %35 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  unreachable

; <label>:36:                                     ; preds = %31
  %37 = trunc i64 %32 to i32
  %38 = add i32 %37, 1
  call void @luaL_checkstack(%struct.lua_State* %0, i32 %38, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  %39 = icmp slt i32 %37, 0
  br i1 %39, label %60, label %40

; <label>:40:                                     ; preds = %36
  %41 = add i64 %17, -1
  %42 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %43 = bitcast %union.StackValue** %42 to %struct.TValue**
  %44 = load %struct.TValue*, %struct.TValue** %43, align 8, !tbaa !20
  %45 = zext i32 %38 to i64
  br label %46

; <label>:46:                                     ; preds = %46, %40
  %47 = phi %struct.TValue* [ %59, %46 ], [ %44, %40 ]
  %48 = phi i64 [ %57, %46 ], [ 0, %40 ]
  %49 = add i64 %41, %48
  %50 = getelementptr inbounds i8, i8* %4, i64 %49
  %51 = load i8, i8* %50, align 1, !tbaa !21
  %52 = zext i8 %51 to i64
  %53 = bitcast %struct.TValue* %47 to i64*
  store i64 %52, i64* %53, align 8, !tbaa !21
  %54 = getelementptr inbounds %struct.TValue, %struct.TValue* %47, i64 0, i32 1
  store i8 35, i8* %54, align 8, !tbaa !22
  %55 = load %union.StackValue*, %union.StackValue** %42, align 8, !tbaa !20
  %56 = getelementptr inbounds %union.StackValue, %union.StackValue* %55, i64 1
  store %union.StackValue* %56, %union.StackValue** %42, align 8, !tbaa !20
  %57 = add nuw nsw i64 %48, 1
  %58 = icmp eq i64 %57, %45
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 0, i32 0
  br i1 %58, label %60, label %46

; <label>:60:                                     ; preds = %46, %36, %28
  %61 = phi i32 [ 0, %28 ], [ %38, %36 ], [ %38, %46 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %61
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_char(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %15) #7
  %16 = shl i64 %12, 28
  %17 = ashr exact i64 %16, 32
  %18 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %18, align 8, !tbaa !207
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %20 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %19, %union.anon.6** %20, align 8, !tbaa !206
  %21 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %23 = bitcast i64* %22 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %23, align 8, !tbaa !82
  %24 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %17, i32 -1) #17
  %25 = icmp slt i32 %14, 1
  br i1 %25, label %42, label %26

; <label>:26:                                     ; preds = %1
  %27 = add nuw nsw i64 %13, 1
  %28 = and i64 %27, 4294967295
  br label %29

; <label>:29:                                     ; preds = %36, %26
  %30 = phi i64 [ %40, %36 ], [ 1, %26 ]
  %31 = trunc i64 %30 to i32
  %32 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %31) #16
  %33 = icmp ult i64 %32, 256
  br i1 %33, label %36, label %34

; <label>:34:                                     ; preds = %29
  %35 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %31, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0)) #16
  br label %36

; <label>:36:                                     ; preds = %34, %29
  %37 = trunc i64 %32 to i8
  %38 = add nsw i64 %30, -1
  %39 = getelementptr inbounds i8, i8* %24, i64 %38
  store i8 %37, i8* %39, align 1, !tbaa !21
  %40 = add nuw nsw i64 %30, 1
  %41 = icmp eq i64 %40, %28
  br i1 %41, label %42, label %29

; <label>:42:                                     ; preds = %36, %1
  %43 = load i64, i64* %21, align 8, !tbaa !205
  %44 = add i64 %43, %17
  store i64 %44, i64* %21, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %15) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_dump(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %3) #7
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %1
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %31, label %24

; <label>:24:                                     ; preds = %18
  %25 = icmp eq i8 %21, 1
  br i1 %25, label %26, label %31

; <label>:26:                                     ; preds = %24
  %27 = bitcast %struct.TValue* %19 to i32*
  %28 = load i32, i32* %27, align 8, !tbaa !21
  %29 = icmp ne i32 %28, 0
  %30 = zext i1 %29 to i32
  br label %31

; <label>:31:                                     ; preds = %18, %24, %26
  %32 = phi i32 [ 0, %18 ], [ 1, %24 ], [ %30, %26 ]
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 1, i32 6) #16
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 1) #16
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %33, align 8, !tbaa !207
  %34 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %35 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %34, %union.anon.6** %35, align 8, !tbaa !206
  %36 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %37 = bitcast i64* %36 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %37, align 8, !tbaa !82
  %38 = call i32 @lua_dump(%struct.lua_State* nonnull %0, i32 (%struct.lua_State*, i8*, i64, i8*)* nonnull @writer, i8* nonnull %3, i32 %32) #16
  %39 = icmp eq i32 %38, 0
  br i1 %39, label %42, label %40

; <label>:40:                                     ; preds = %31
  %41 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.543, i64 0, i64 0)) #16
  unreachable

; <label>:42:                                     ; preds = %31
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_find(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_format(%struct.lua_State*) #0 {
  %2 = alloca [10 x i8], align 1
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.luaL_Buffer, align 8
  %6 = alloca [32 x i8], align 16
  %7 = alloca i64, align 8
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 1
  %16 = ptrtoint %union.StackValue* %15 to i64
  %17 = sub i64 %10, %16
  %18 = lshr exact i64 %17, 4
  %19 = trunc i64 %18 to i32
  %20 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %20) #7
  %21 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %4) #16
  %22 = load i64, i64* %4, align 8, !tbaa !82
  %23 = getelementptr inbounds i8, i8* %21, i64 %22
  %24 = bitcast %struct.luaL_Buffer* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %24) #7
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %25, align 8, !tbaa !207
  %26 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 4
  %27 = bitcast %struct.luaL_Buffer* %5 to %union.anon.6**
  store %union.anon.6* %26, %union.anon.6** %27, align 8, !tbaa !206
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 2
  %29 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 1
  %30 = bitcast i64* %29 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %30, align 8, !tbaa !82
  %31 = icmp sgt i64 %22, 0
  br i1 %31, label %32, label %389

; <label>:32:                                     ; preds = %1
  %33 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 0
  %34 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %5, i64 0, i32 0
  %35 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 1
  %36 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 2
  %37 = bitcast i64* %7 to i8*
  %38 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %39 = bitcast i64* %3 to i8*
  %40 = getelementptr inbounds [10 x i8], [10 x i8]* %2, i64 0, i64 0
  br label %41

; <label>:41:                                     ; preds = %32, %385
  %42 = phi i32 [ 1, %32 ], [ %387, %385 ]
  %43 = phi i8* [ %21, %32 ], [ %386, %385 ]
  %44 = load i8, i8* %43, align 1, !tbaa !21
  %45 = icmp eq i8 %44, 37
  br i1 %45, label %61, label %46

; <label>:46:                                     ; preds = %41
  %47 = load i64, i64* %28, align 8, !tbaa !205
  %48 = load i64, i64* %29, align 8, !tbaa !203
  %49 = icmp ult i64 %47, %48
  br i1 %49, label %54, label %50

; <label>:50:                                     ; preds = %46
  %51 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %52 = load i8, i8* %43, align 1, !tbaa !21
  %53 = load i64, i64* %28, align 8, !tbaa !205
  br label %54

; <label>:54:                                     ; preds = %50, %46
  %55 = phi i64 [ %53, %50 ], [ %47, %46 ]
  %56 = phi i8 [ %52, %50 ], [ %44, %46 ]
  %57 = getelementptr inbounds i8, i8* %43, i64 1
  %58 = load i8*, i8** %34, align 8, !tbaa !206
  %59 = add i64 %55, 1
  store i64 %59, i64* %28, align 8, !tbaa !205
  %60 = getelementptr inbounds i8, i8* %58, i64 %55
  store i8 %56, i8* %60, align 1, !tbaa !21
  br label %385

; <label>:61:                                     ; preds = %41
  %62 = getelementptr inbounds i8, i8* %43, i64 1
  %63 = load i8, i8* %62, align 1, !tbaa !21
  %64 = icmp eq i8 %63, 37
  br i1 %64, label %65, label %80

; <label>:65:                                     ; preds = %61
  %66 = load i64, i64* %28, align 8, !tbaa !205
  %67 = load i64, i64* %29, align 8, !tbaa !203
  %68 = icmp ult i64 %66, %67
  br i1 %68, label %73, label %69

; <label>:69:                                     ; preds = %65
  %70 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %71 = load i8, i8* %62, align 1, !tbaa !21
  %72 = load i64, i64* %28, align 8, !tbaa !205
  br label %73

; <label>:73:                                     ; preds = %69, %65
  %74 = phi i64 [ %72, %69 ], [ %66, %65 ]
  %75 = phi i8 [ %71, %69 ], [ 37, %65 ]
  %76 = getelementptr inbounds i8, i8* %43, i64 2
  %77 = load i8*, i8** %34, align 8, !tbaa !206
  %78 = add i64 %74, 1
  store i64 %78, i64* %28, align 8, !tbaa !205
  %79 = getelementptr inbounds i8, i8* %77, i64 %74
  store i8 %75, i8* %79, align 1, !tbaa !21
  br label %385

; <label>:80:                                     ; preds = %61
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %33) #7
  %81 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 120, i32 -1) #17
  %82 = add nsw i32 %42, 1
  %83 = icmp slt i32 %42, %19
  br i1 %83, label %84, label %383

; <label>:84:                                     ; preds = %80
  %85 = load i8, i8* %62, align 1, !tbaa !21
  %86 = icmp eq i8 %85, 0
  br i1 %86, label %102, label %87

; <label>:87:                                     ; preds = %84
  br label %88

; <label>:88:                                     ; preds = %87, %98
  %89 = phi i8 [ %100, %98 ], [ %85, %87 ]
  %90 = phi i8* [ %99, %98 ], [ %62, %87 ]
  %91 = sext i8 %89 to i64
  %92 = and i64 %91, 4294967295
  %93 = icmp ult i64 %92, 64
  %94 = shl i64 1, %92
  %95 = and i64 %94, 325494096527361
  %96 = icmp ne i64 %95, 0
  %97 = and i1 %93, %96
  br i1 %97, label %98, label %102

; <label>:98:                                     ; preds = %88
  %99 = getelementptr inbounds i8, i8* %90, i64 1
  %100 = load i8, i8* %99, align 1, !tbaa !21
  %101 = icmp eq i8 %100, 0
  br i1 %101, label %102, label %88

; <label>:102:                                    ; preds = %98, %88, %84
  %103 = phi i8* [ %62, %84 ], [ %90, %88 ], [ %99, %98 ]
  %104 = phi i8 [ 0, %84 ], [ %89, %88 ], [ 0, %98 ]
  %105 = ptrtoint i8* %103 to i64
  %106 = ptrtoint i8* %62 to i64
  %107 = sub i64 %105, %106
  %108 = icmp ugt i64 %107, 5
  br i1 %108, label %109, label %111

; <label>:109:                                    ; preds = %102
  %110 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.559, i64 0, i64 0)) #17
  unreachable

; <label>:111:                                    ; preds = %102
  %112 = tail call i16** @__ctype_b_loc() #22
  %113 = load i16*, i16** %112, align 8, !tbaa !54
  %114 = zext i8 %104 to i64
  %115 = getelementptr inbounds i16, i16* %113, i64 %114
  %116 = load i16, i16* %115, align 2, !tbaa !324
  %117 = and i16 %116, 2048
  %118 = icmp eq i16 %117, 0
  %119 = getelementptr inbounds i8, i8* %103, i64 1
  %120 = select i1 %118, i8* %103, i8* %119
  %121 = load i8, i8* %120, align 1, !tbaa !21
  %122 = zext i8 %121 to i64
  %123 = getelementptr inbounds i16, i16* %113, i64 %122
  %124 = load i16, i16* %123, align 2, !tbaa !324
  %125 = and i16 %124, 2048
  %126 = icmp eq i16 %125, 0
  %127 = getelementptr inbounds i8, i8* %120, i64 1
  %128 = select i1 %126, i8* %120, i8* %127
  %129 = load i8, i8* %128, align 1, !tbaa !21
  %130 = icmp eq i8 %129, 46
  br i1 %130, label %131, label %150

; <label>:131:                                    ; preds = %111
  %132 = getelementptr inbounds i8, i8* %128, i64 1
  %133 = load i8, i8* %132, align 1, !tbaa !21
  %134 = zext i8 %133 to i64
  %135 = getelementptr inbounds i16, i16* %113, i64 %134
  %136 = load i16, i16* %135, align 2, !tbaa !324
  %137 = and i16 %136, 2048
  %138 = icmp eq i16 %137, 0
  %139 = getelementptr inbounds i8, i8* %128, i64 2
  %140 = select i1 %138, i8* %132, i8* %139
  %141 = load i8, i8* %140, align 1, !tbaa !21
  %142 = zext i8 %141 to i64
  %143 = getelementptr inbounds i16, i16* %113, i64 %142
  %144 = load i16, i16* %143, align 2, !tbaa !324
  %145 = and i16 %144, 2048
  %146 = icmp eq i16 %145, 0
  %147 = getelementptr inbounds i8, i8* %140, i64 1
  %148 = select i1 %146, i8* %140, i8* %147
  %149 = load i8, i8* %148, align 1, !tbaa !21
  br label %150

; <label>:150:                                    ; preds = %131, %111
  %151 = phi i8 [ %129, %111 ], [ %149, %131 ]
  %152 = phi i8* [ %128, %111 ], [ %148, %131 ]
  %153 = zext i8 %151 to i64
  %154 = getelementptr inbounds i16, i16* %113, i64 %153
  %155 = load i16, i16* %154, align 2, !tbaa !324
  %156 = and i16 %155, 2048
  %157 = icmp eq i16 %156, 0
  br i1 %157, label %160, label %158

; <label>:158:                                    ; preds = %150
  %159 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.560, i64 0, i64 0)) #17
  unreachable

; <label>:160:                                    ; preds = %150
  store i8 37, i8* %33, align 16, !tbaa !21
  %161 = ptrtoint i8* %152 to i64
  %162 = sub i64 %161, %106
  %163 = add nsw i64 %162, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %35, i8* nonnull %62, i64 %163, i32 1, i1 false) #7
  %164 = getelementptr inbounds i8, i8* %35, i64 %163
  store i8 0, i8* %164, align 1, !tbaa !21
  %165 = getelementptr inbounds i8, i8* %152, i64 1
  %166 = load i8, i8* %152, align 1, !tbaa !21
  %167 = sext i8 %166 to i32
  switch i32 %167, label %376 [
    i32 99, label %168
    i32 100, label %172
    i32 105, label %172
    i32 111, label %172
    i32 117, label %172
    i32 120, label %172
    i32 88, label %172
    i32 97, label %175
    i32 65, label %175
    i32 101, label %178
    i32 69, label %178
    i32 102, label %178
    i32 103, label %178
    i32 71, label %178
    i32 112, label %191
    i32 113, label %194
    i32 115, label %350
  ]

; <label>:168:                                    ; preds = %160
  %169 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %82) #16
  %170 = trunc i64 %169 to i32
  %171 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %81, i64 120, i8* nonnull %33, i32 %170) #17
  br label %378

; <label>:172:                                    ; preds = %160, %160, %160, %160, %160, %160
  %173 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %82) #16
  call fastcc void @addlenmod(i8* nonnull %33, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.554, i64 0, i64 0)) #16
  %174 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %81, i64 120, i8* nonnull %33, i64 %173) #17
  br label %378

; <label>:175:                                    ; preds = %160, %160
  call fastcc void @addlenmod(i8* nonnull %33, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  %176 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %82) #16
  %177 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %81, i64 120, i8* nonnull %33, double %176) #17
  br label %378

; <label>:178:                                    ; preds = %160, %160, %160, %160, %160
  %179 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %82) #16
  %180 = load i8, i8* %152, align 1, !tbaa !21
  %181 = icmp ne i8 %180, 102
  %182 = call double @llvm.fabs.f64(double %179)
  %183 = fcmp ult double %182, 1.000000e+100
  %184 = or i1 %181, %183
  br i1 %184, label %187, label %185

; <label>:185:                                    ; preds = %178
  %186 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 418, i32 -1) #17
  br label %187

; <label>:187:                                    ; preds = %178, %185
  %188 = phi i8* [ %186, %185 ], [ %81, %178 ]
  %189 = phi i64 [ 418, %185 ], [ 120, %178 ]
  call fastcc void @addlenmod(i8* nonnull %33, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  %190 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %188, i64 %189, i8* nonnull %33, double %179) #17
  br label %378

; <label>:191:                                    ; preds = %160
  %192 = call i8* @lua_topointer(%struct.lua_State* %0, i32 %82) #16
  %193 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %81, i64 120, i8* nonnull %33, i8* %192) #17
  br label %378

; <label>:194:                                    ; preds = %160
  %195 = load i8, i8* %36, align 2, !tbaa !21
  %196 = icmp eq i8 %195, 0
  br i1 %196, label %199, label %197

; <label>:197:                                    ; preds = %194
  %198 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.555, i64 0, i64 0)) #16
  unreachable

; <label>:199:                                    ; preds = %194
  %200 = call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %82) #17
  %201 = getelementptr inbounds %struct.TValue, %struct.TValue* %200, i64 0, i32 1
  %202 = load i8, i8* %201, align 8, !tbaa !22
  %203 = and i8 %202, 15
  %204 = icmp eq i8 %203, 0
  br i1 %204, label %205, label %209

; <label>:205:                                    ; preds = %199
  %206 = load %struct.global_State*, %struct.global_State** %38, align 8, !tbaa !2
  %207 = getelementptr inbounds %struct.global_State, %struct.global_State* %206, i64 0, i32 8
  %208 = icmp eq %struct.TValue* %200, %207
  br i1 %208, label %348, label %209

; <label>:209:                                    ; preds = %205, %199
  %210 = trunc i8 %202 to i4
  switch i4 %210, label %348 [
    i4 4, label %211
    i4 3, label %306
    i4 0, label %346
    i4 1, label %346
  ]

; <label>:211:                                    ; preds = %209
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %39) #7
  %212 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %82, i64* nonnull %3) #17
  %213 = load i64, i64* %3, align 8, !tbaa !82
  %214 = load i64, i64* %28, align 8, !tbaa !205
  %215 = load i64, i64* %29, align 8, !tbaa !203
  %216 = icmp ult i64 %214, %215
  br i1 %216, label %220, label %217

; <label>:217:                                    ; preds = %211
  %218 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %219 = load i64, i64* %28, align 8, !tbaa !205
  br label %220

; <label>:220:                                    ; preds = %217, %211
  %221 = phi i64 [ %219, %217 ], [ %214, %211 ]
  %222 = load i8*, i8** %34, align 8, !tbaa !206
  %223 = add i64 %221, 1
  store i64 %223, i64* %28, align 8, !tbaa !205
  %224 = getelementptr inbounds i8, i8* %222, i64 %221
  store i8 34, i8* %224, align 1, !tbaa !21
  %225 = icmp eq i64 %213, 0
  br i1 %225, label %294, label %226

; <label>:226:                                    ; preds = %220
  br label %227

; <label>:227:                                    ; preds = %226, %291
  %228 = phi i64 [ %230, %291 ], [ %213, %226 ]
  %229 = phi i8* [ %292, %291 ], [ %212, %226 ]
  %230 = add i64 %228, -1
  %231 = load i8, i8* %229, align 1, !tbaa !21
  switch i8 %231, label %256 [
    i8 34, label %232
    i8 92, label %232
    i8 10, label %232
  ]

; <label>:232:                                    ; preds = %227, %227, %227
  %233 = load i64, i64* %28, align 8, !tbaa !205
  %234 = load i64, i64* %29, align 8, !tbaa !203
  %235 = icmp ult i64 %233, %234
  br i1 %235, label %239, label %236

; <label>:236:                                    ; preds = %232
  %237 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %238 = load i64, i64* %28, align 8, !tbaa !205
  br label %239

; <label>:239:                                    ; preds = %236, %232
  %240 = phi i64 [ %238, %236 ], [ %233, %232 ]
  %241 = load i8*, i8** %34, align 8, !tbaa !206
  %242 = add i64 %240, 1
  store i64 %242, i64* %28, align 8, !tbaa !205
  %243 = getelementptr inbounds i8, i8* %241, i64 %240
  store i8 92, i8* %243, align 1, !tbaa !21
  %244 = load i64, i64* %28, align 8, !tbaa !205
  %245 = load i64, i64* %29, align 8, !tbaa !203
  %246 = icmp ult i64 %244, %245
  br i1 %246, label %250, label %247

; <label>:247:                                    ; preds = %239
  %248 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %249 = load i64, i64* %28, align 8, !tbaa !205
  br label %250

; <label>:250:                                    ; preds = %247, %239
  %251 = phi i64 [ %249, %247 ], [ %244, %239 ]
  %252 = load i8, i8* %229, align 1, !tbaa !21
  %253 = load i8*, i8** %34, align 8, !tbaa !206
  %254 = add i64 %251, 1
  store i64 %254, i64* %28, align 8, !tbaa !205
  %255 = getelementptr inbounds i8, i8* %253, i64 %251
  store i8 %252, i8* %255, align 1, !tbaa !21
  br label %291

; <label>:256:                                    ; preds = %227
  %257 = load i16*, i16** %112, align 8, !tbaa !54
  %258 = zext i8 %231 to i64
  %259 = getelementptr inbounds i16, i16* %257, i64 %258
  %260 = load i16, i16* %259, align 2, !tbaa !324
  %261 = and i16 %260, 2
  %262 = icmp eq i16 %261, 0
  br i1 %262, label %277, label %263

; <label>:263:                                    ; preds = %256
  call void @llvm.lifetime.start.p0i8(i64 10, i8* nonnull %40) #7
  %264 = getelementptr inbounds i8, i8* %229, i64 1
  %265 = load i8, i8* %264, align 1, !tbaa !21
  %266 = zext i8 %265 to i64
  %267 = getelementptr inbounds i16, i16* %257, i64 %266
  %268 = load i16, i16* %267, align 2, !tbaa !324
  %269 = and i16 %268, 2048
  %270 = icmp eq i16 %269, 0
  %271 = zext i8 %231 to i32
  br i1 %270, label %272, label %274

; <label>:272:                                    ; preds = %263
  %273 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %40, i64 10, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.563, i64 0, i64 0), i32 %271) #17
  br label %276

; <label>:274:                                    ; preds = %263
  %275 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* nonnull %40, i64 10, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.564, i64 0, i64 0), i32 %271) #17
  br label %276

; <label>:276:                                    ; preds = %274, %272
  call void @luaL_addstring(%struct.luaL_Buffer* nonnull %5, i8* nonnull %40) #17
  call void @llvm.lifetime.end.p0i8(i64 10, i8* nonnull %40) #7
  br label %291

; <label>:277:                                    ; preds = %256
  %278 = load i64, i64* %28, align 8, !tbaa !205
  %279 = load i64, i64* %29, align 8, !tbaa !203
  %280 = icmp ult i64 %278, %279
  br i1 %280, label %285, label %281

; <label>:281:                                    ; preds = %277
  %282 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %283 = load i8, i8* %229, align 1, !tbaa !21
  %284 = load i64, i64* %28, align 8, !tbaa !205
  br label %285

; <label>:285:                                    ; preds = %281, %277
  %286 = phi i64 [ %284, %281 ], [ %278, %277 ]
  %287 = phi i8 [ %283, %281 ], [ %231, %277 ]
  %288 = load i8*, i8** %34, align 8, !tbaa !206
  %289 = add i64 %286, 1
  store i64 %289, i64* %28, align 8, !tbaa !205
  %290 = getelementptr inbounds i8, i8* %288, i64 %286
  store i8 %287, i8* %290, align 1, !tbaa !21
  br label %291

; <label>:291:                                    ; preds = %285, %276, %250
  %292 = getelementptr inbounds i8, i8* %229, i64 1
  %293 = icmp eq i64 %230, 0
  br i1 %293, label %294, label %227

; <label>:294:                                    ; preds = %291, %220
  %295 = load i64, i64* %28, align 8, !tbaa !205
  %296 = load i64, i64* %29, align 8, !tbaa !203
  %297 = icmp ult i64 %295, %296
  br i1 %297, label %301, label %298

; <label>:298:                                    ; preds = %294
  %299 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 1, i32 -1) #17
  %300 = load i64, i64* %28, align 8, !tbaa !205
  br label %301

; <label>:301:                                    ; preds = %298, %294
  %302 = phi i64 [ %300, %298 ], [ %295, %294 ]
  %303 = load i8*, i8** %34, align 8, !tbaa !206
  %304 = add i64 %302, 1
  store i64 %304, i64* %28, align 8, !tbaa !205
  %305 = getelementptr inbounds i8, i8* %303, i64 %302
  store i8 34, i8* %305, align 1, !tbaa !21
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %39) #7
  br label %378

; <label>:306:                                    ; preds = %209
  %307 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %5, i64 120, i32 -1) #17
  %308 = call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %82) #17
  %309 = getelementptr inbounds %struct.TValue, %struct.TValue* %308, i64 0, i32 1
  %310 = load i8, i8* %309, align 8, !tbaa !22
  %311 = icmp eq i8 %310, 35
  br i1 %311, label %336, label %312

; <label>:312:                                    ; preds = %306
  %313 = call double @lua_tonumberx(%struct.lua_State* %0, i32 %82, i32* null) #17
  %314 = fcmp oeq double %313, 0x7FF0000000000000
  br i1 %314, label %333, label %315

; <label>:315:                                    ; preds = %312
  %316 = fcmp oeq double %313, 0xFFF0000000000000
  br i1 %316, label %333, label %317

; <label>:317:                                    ; preds = %315
  %318 = fcmp uno double %313, 0.000000e+00
  br i1 %318, label %333, label %319

; <label>:319:                                    ; preds = %317
  %320 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %307, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.568, i64 0, i64 0), double %313) #17
  %321 = sext i32 %320 to i64
  %322 = call i8* @memchr(i8* %307, i32 46, i64 %321) #21
  %323 = icmp eq i8* %322, null
  br i1 %323, label %324, label %341

; <label>:324:                                    ; preds = %319
  %325 = call %struct.lconv* @localeconv() #17
  %326 = getelementptr inbounds %struct.lconv, %struct.lconv* %325, i64 0, i32 0
  %327 = load i8*, i8** %326, align 8, !tbaa !142
  %328 = load i8, i8* %327, align 1, !tbaa !21
  %329 = sext i8 %328 to i32
  %330 = call i8* @memchr(i8* %307, i32 %329, i64 %321) #21
  %331 = icmp eq i8* %330, null
  br i1 %331, label %341, label %332

; <label>:332:                                    ; preds = %324
  store i8 46, i8* %330, align 1, !tbaa !21
  br label %341

; <label>:333:                                    ; preds = %317, %315, %312
  %334 = phi i8* [ getelementptr inbounds ([7 x i8], [7 x i8]* @.str.565, i64 0, i64 0), %312 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.566, i64 0, i64 0), %315 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.567, i64 0, i64 0), %317 ]
  %335 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %307, i64 120, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.298, i64 0, i64 0), i8* nonnull %334) #17
  br label %341

; <label>:336:                                    ; preds = %306
  %337 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 %82, i32* null) #17
  %338 = icmp eq i64 %337, -9223372036854775808
  %339 = select i1 %338, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.561, i64 0, i64 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.189, i64 0, i64 0)
  %340 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %307, i64 120, i8* %339, i64 %337) #17
  br label %341

; <label>:341:                                    ; preds = %336, %333, %332, %324, %319
  %342 = phi i32 [ %340, %336 ], [ %335, %333 ], [ %320, %332 ], [ %320, %324 ], [ %320, %319 ]
  %343 = sext i32 %342 to i64
  %344 = load i64, i64* %28, align 8, !tbaa !205
  %345 = add i64 %344, %343
  store i64 %345, i64* %28, align 8, !tbaa !205
  br label %378

; <label>:346:                                    ; preds = %209, %209
  %347 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %82, i64* null) #17
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #17
  br label %378

; <label>:348:                                    ; preds = %209, %205
  %349 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %82, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.562, i64 0, i64 0)) #17
  br label %378

; <label>:350:                                    ; preds = %160
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %37) #7
  %351 = call i8* @luaL_tolstring(%struct.lua_State* %0, i32 %82, i64* nonnull %7) #16
  %352 = load i8, i8* %36, align 2, !tbaa !21
  %353 = icmp eq i8 %352, 0
  br i1 %353, label %354, label %355

; <label>:354:                                    ; preds = %350
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #16
  br label %374

; <label>:355:                                    ; preds = %350
  %356 = load i64, i64* %7, align 8, !tbaa !82
  %357 = call i64 @strlen(i8* %351) #21
  %358 = icmp eq i64 %356, %357
  br i1 %358, label %362, label %359

; <label>:359:                                    ; preds = %355
  %360 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %82, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0)) #16
  %361 = load i64, i64* %7, align 8
  br label %362

; <label>:362:                                    ; preds = %359, %355
  %363 = phi i64 [ %361, %359 ], [ %356, %355 ]
  %364 = call i8* @strchr(i8* nonnull %33, i32 46) #21
  %365 = icmp eq i8* %364, null
  %366 = icmp ugt i64 %363, 99
  %367 = and i1 %365, %366
  br i1 %367, label %368, label %369

; <label>:368:                                    ; preds = %362
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %5) #16
  br label %374

; <label>:369:                                    ; preds = %362
  %370 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %81, i64 120, i8* nonnull %33, i8* %351) #17
  %371 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %372 = getelementptr inbounds %union.StackValue, %union.StackValue* %371, i64 -1
  store %union.StackValue* %372, %union.StackValue** %8, align 8, !tbaa !20
  %373 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %372, i32 0) #17
  br label %374

; <label>:374:                                    ; preds = %368, %369, %354
  %375 = phi i32 [ 0, %354 ], [ 0, %368 ], [ %370, %369 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %37) #7
  br label %378

; <label>:376:                                    ; preds = %160
  %377 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.557, i64 0, i64 0), i8* nonnull %33) #16
  unreachable

; <label>:378:                                    ; preds = %168, %172, %175, %187, %191, %374, %301, %341, %346, %348
  %379 = phi i32 [ %375, %374 ], [ %193, %191 ], [ %190, %187 ], [ %177, %175 ], [ %174, %172 ], [ %171, %168 ], [ 0, %301 ], [ 0, %341 ], [ 0, %346 ], [ 0, %348 ]
  %380 = sext i32 %379 to i64
  %381 = load i64, i64* %28, align 8, !tbaa !205
  %382 = add i64 %381, %380
  store i64 %382, i64* %28, align 8, !tbaa !205
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %33) #7
  br label %385

; <label>:383:                                    ; preds = %80
  %384 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %82, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.181, i64 0, i64 0)) #16
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %33) #7
  br label %390

; <label>:385:                                    ; preds = %378, %73, %54
  %386 = phi i8* [ %57, %54 ], [ %76, %73 ], [ %165, %378 ]
  %387 = phi i32 [ %42, %54 ], [ %42, %73 ], [ %82, %378 ]
  %388 = icmp ult i8* %386, %23
  br i1 %388, label %41, label %389

; <label>:389:                                    ; preds = %385, %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %5) #16
  br label %390

; <label>:390:                                    ; preds = %383, %389
  %391 = phi i32 [ %384, %383 ], [ 1, %389 ]
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %24) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %20) #7
  ret i32 %391
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gmatch(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %3) #16
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %9 = load i64, i64* %2, align 8, !tbaa !82
  %10 = icmp sgt i64 %8, 0
  br i1 %10, label %19, label %11

; <label>:11:                                     ; preds = %1
  %12 = icmp eq i64 %8, 0
  %13 = sub nsw i64 0, %9
  %14 = icmp slt i64 %8, %13
  %15 = or i1 %12, %14
  br i1 %15, label %19, label %16

; <label>:16:                                     ; preds = %11
  %17 = add i64 %8, 1
  %18 = add i64 %17, %9
  br label %19

; <label>:19:                                     ; preds = %1, %11, %16
  %20 = phi i64 [ %18, %16 ], [ %8, %1 ], [ 1, %11 ]
  %21 = add i64 %20, -1
  call void @lua_settop(%struct.lua_State* %0, i32 2) #16
  %22 = call i8* @lua_newuserdatauv(%struct.lua_State* %0, i64 576, i32 0) #16
  %23 = load i64, i64* %2, align 8, !tbaa !82
  %24 = icmp ugt i64 %21, %23
  %25 = add i64 %23, 1
  %26 = select i1 %24, i64 %25, i64 %21
  %27 = getelementptr inbounds i8, i8* %22, i64 24
  %28 = load i64, i64* %3, align 8, !tbaa !82
  %29 = getelementptr inbounds i8, i8* %22, i64 48
  %30 = bitcast i8* %29 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %30, align 8, !tbaa !349
  %31 = getelementptr inbounds i8, i8* %22, i64 56
  %32 = bitcast i8* %31 to i32*
  store i32 200, i32* %32, align 8, !tbaa !351
  %33 = bitcast i8* %27 to i8**
  store i8* %6, i8** %33, align 8, !tbaa !352
  %34 = getelementptr inbounds i8, i8* %6, i64 %23
  %35 = getelementptr inbounds i8, i8* %22, i64 32
  %36 = bitcast i8* %35 to i8**
  store i8* %34, i8** %36, align 8, !tbaa !353
  %37 = getelementptr inbounds i8, i8* %7, i64 %28
  %38 = getelementptr inbounds i8, i8* %22, i64 40
  %39 = bitcast i8* %38 to i8**
  store i8* %37, i8** %39, align 8, !tbaa !354
  %40 = getelementptr inbounds i8, i8* %6, i64 %26
  %41 = bitcast i8* %22 to i8**
  store i8* %40, i8** %41, align 8, !tbaa !355
  %42 = getelementptr inbounds i8, i8* %22, i64 8
  %43 = bitcast i8* %42 to i8**
  store i8* %7, i8** %43, align 8, !tbaa !357
  %44 = getelementptr inbounds i8, i8* %22, i64 16
  %45 = bitcast i8* %44 to i8**
  store i8* null, i8** %45, align 8, !tbaa !358
  call void @lua_pushcclosure(%struct.lua_State* %0, i32 (%struct.lua_State*)* nonnull @gmatch_aux, i32 3) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_gsub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca %struct.MatchState, align 8
  %7 = alloca %struct.luaL_Buffer, align 8
  %8 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %8) #7
  %9 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %4) #16
  %11 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %5) #16
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %13 = load %struct.CallInfo*, %struct.CallInfo** %12, align 8, !tbaa !24
  %14 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %13, i64 0, i32 0
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !64
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 3
  %17 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %18 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %19 = icmp ult %union.StackValue* %16, %18
  br i1 %19, label %24, label %20

; <label>:20:                                     ; preds = %1
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %22 = load %struct.global_State*, %struct.global_State** %21, align 8, !tbaa !2
  %23 = getelementptr inbounds %struct.global_State, %struct.global_State* %22, i64 0, i32 8
  br label %26

; <label>:24:                                     ; preds = %1
  %25 = getelementptr inbounds %union.StackValue, %union.StackValue* %16, i64 0, i32 0
  br label %26

; <label>:26:                                     ; preds = %20, %24
  %27 = phi %struct.TValue* [ %23, %20 ], [ %25, %24 ]
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %27, i64 0, i32 1
  %29 = load i8, i8* %28, align 8, !tbaa !22
  %30 = and i8 %29, 15
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %32, label %37

; <label>:32:                                     ; preds = %26
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %34 = load %struct.global_State*, %struct.global_State** %33, align 8, !tbaa !2
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %34, i64 0, i32 8
  %36 = icmp eq %struct.TValue* %27, %35
  br i1 %36, label %39, label %37

; <label>:37:                                     ; preds = %32, %26
  %38 = zext i8 %30 to i32
  br label %39

; <label>:39:                                     ; preds = %32, %37
  %40 = phi i32 [ %38, %37 ], [ -1, %32 ]
  %41 = load i64, i64* %4, align 8, !tbaa !82
  %42 = add i64 %41, 1
  %43 = call i64 @luaL_optinteger(%struct.lua_State* nonnull %0, i32 4, i64 %42) #16
  %44 = load i8, i8* %11, align 1, !tbaa !21
  %45 = icmp eq i8 %44, 94
  %46 = bitcast %struct.MatchState* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %46) #7
  %47 = bitcast %struct.luaL_Buffer* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %47) #7
  %48 = add nsw i32 %40, -3
  %49 = icmp ult i32 %48, 4
  br i1 %49, label %52, label %50

; <label>:50:                                     ; preds = %39
  %51 = call i32 @luaL_typeerror(%struct.lua_State* nonnull %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.569, i64 0, i64 0)) #16
  br label %52

; <label>:52:                                     ; preds = %50, %39
  %53 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %53, align 8, !tbaa !207
  %54 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 4
  %55 = bitcast %struct.luaL_Buffer* %7 to %union.anon.6**
  store %union.anon.6* %54, %union.anon.6** %55, align 8, !tbaa !206
  %56 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 2
  %57 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 1
  %58 = bitcast i64* %57 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %58, align 8, !tbaa !82
  br i1 %45, label %61, label %59

; <label>:59:                                     ; preds = %52
  %60 = load i64, i64* %5, align 8, !tbaa !82
  br label %65

; <label>:61:                                     ; preds = %52
  %62 = getelementptr inbounds i8, i8* %11, i64 1
  %63 = load i64, i64* %5, align 8, !tbaa !82
  %64 = add i64 %63, -1
  store i64 %64, i64* %5, align 8, !tbaa !82
  br label %65

; <label>:65:                                     ; preds = %59, %61
  %66 = phi i64 [ %64, %61 ], [ %60, %59 ]
  %67 = phi i8* [ %62, %61 ], [ %11, %59 ]
  %68 = load i64, i64* %4, align 8, !tbaa !82
  %69 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %69, align 8, !tbaa !349
  %70 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 4
  store i32 200, i32* %70, align 8, !tbaa !351
  %71 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 0
  store i8* %10, i8** %71, align 8, !tbaa !352
  %72 = getelementptr inbounds i8, i8* %10, i64 %68
  %73 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 1
  store i8* %72, i8** %73, align 8, !tbaa !353
  %74 = getelementptr inbounds i8, i8* %67, i64 %66
  %75 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 2
  store i8* %74, i8** %75, align 8, !tbaa !354
  %76 = icmp sgt i64 %43, 0
  br i1 %76, label %77, label %280

; <label>:77:                                     ; preds = %65
  %78 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %6, i64 0, i32 5
  %79 = bitcast i64* %2 to i8*
  %80 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %7, i64 0, i32 0
  %81 = bitcast i8** %3 to i8*
  %82 = xor i1 %45, true
  br label %83

; <label>:83:                                     ; preds = %268, %77
  %84 = phi i8* [ %10, %77 ], [ %272, %268 ]
  %85 = phi i32 [ 0, %77 ], [ %271, %268 ]
  %86 = phi i64 [ 0, %77 ], [ %270, %268 ]
  %87 = phi i8* [ null, %77 ], [ %269, %268 ]
  store i8 0, i8* %78, align 4, !tbaa !359
  %88 = call fastcc i8* @match(%struct.MatchState* nonnull %6, i8* %84, i8* %67) #16
  %89 = icmp eq i8* %88, null
  %90 = icmp eq i8* %88, %87
  %91 = or i1 %89, %90
  br i1 %91, label %251, label %92

; <label>:92:                                     ; preds = %83
  %93 = add nsw i64 %86, 1
  %94 = load %struct.lua_State*, %struct.lua_State** %69, align 8, !tbaa !349
  switch i32 %40, label %131 [
    i32 6, label %95
    i32 5, label %128
  ]

; <label>:95:                                     ; preds = %92
  %96 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %94, i64 0, i32 6
  %97 = bitcast %union.StackValue** %96 to %struct.TValue**
  %98 = load %struct.TValue*, %struct.TValue** %97, align 8, !tbaa !20
  %99 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %94, i64 0, i32 8
  %100 = load %struct.CallInfo*, %struct.CallInfo** %99, align 8, !tbaa !24
  %101 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %100, i64 0, i32 0
  %102 = load %union.StackValue*, %union.StackValue** %101, align 8, !tbaa !64
  %103 = getelementptr inbounds %union.StackValue, %union.StackValue* %102, i64 3
  %104 = bitcast %struct.TValue* %98 to %union.StackValue*
  %105 = icmp ult %union.StackValue* %103, %104
  br i1 %105, label %110, label %106

; <label>:106:                                    ; preds = %95
  %107 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %94, i64 0, i32 7
  %108 = load %struct.global_State*, %struct.global_State** %107, align 8, !tbaa !2
  %109 = getelementptr inbounds %struct.global_State, %struct.global_State* %108, i64 0, i32 8
  br label %112

; <label>:110:                                    ; preds = %95
  %111 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 0, i32 0
  br label %112

; <label>:112:                                    ; preds = %110, %106
  %113 = phi %struct.TValue* [ %109, %106 ], [ %111, %110 ]
  %114 = bitcast %struct.TValue* %113 to i64*
  %115 = bitcast %struct.TValue* %98 to i64*
  %116 = load i64, i64* %114, align 8
  store i64 %116, i64* %115, align 8
  %117 = getelementptr inbounds %struct.TValue, %struct.TValue* %113, i64 0, i32 1
  %118 = load i8, i8* %117, align 8, !tbaa !22
  %119 = getelementptr inbounds %struct.TValue, %struct.TValue* %98, i64 0, i32 1
  store i8 %118, i8* %119, align 8, !tbaa !22
  %120 = load %union.StackValue*, %union.StackValue** %96, align 8, !tbaa !20
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %120, i64 1
  store %union.StackValue* %121, %union.StackValue** %96, align 8, !tbaa !20
  %122 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %6, i8* %84, i8* nonnull %88) #17
  %123 = load %union.StackValue*, %union.StackValue** %96, align 8, !tbaa !20
  %124 = add nsw i32 %122, 1
  %125 = sext i32 %124 to i64
  %126 = sub nsw i64 0, %125
  %127 = getelementptr inbounds %union.StackValue, %union.StackValue* %123, i64 %126
  call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %94, %union.StackValue* %127, i32 1) #17
  br label %212

; <label>:128:                                    ; preds = %92
  call fastcc void @push_onecapture(%struct.MatchState* nonnull %6, i32 0, i8* %84, i8* nonnull %88) #17
  %129 = call i32 @lua_gettable(%struct.lua_State* %94, i32 3) #17
  %130 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %94, i64 0, i32 6
  br label %212

; <label>:131:                                    ; preds = %92
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %79) #7
  %132 = call i8* @lua_tolstring(%struct.lua_State* %94, i32 3, i64* nonnull %2) #17
  %133 = load i64, i64* %2, align 8, !tbaa !82
  %134 = call i8* @memchr(i8* %132, i32 37, i64 %133) #21
  %135 = icmp eq i8* %134, null
  br i1 %135, label %203, label %136

; <label>:136:                                    ; preds = %131
  %137 = ptrtoint i8* %88 to i64
  %138 = ptrtoint i8* %84 to i64
  %139 = sub i64 %137, %138
  %140 = icmp eq i64 %139, 0
  br label %141

; <label>:141:                                    ; preds = %195, %136
  %142 = phi i8* [ %134, %136 ], [ %201, %195 ]
  %143 = phi i8* [ %132, %136 ], [ %196, %195 ]
  %144 = ptrtoint i8* %142 to i64
  %145 = ptrtoint i8* %143 to i64
  %146 = sub i64 %144, %145
  %147 = icmp eq i64 %146, 0
  br i1 %147, label %152, label %148

; <label>:148:                                    ; preds = %141
  %149 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %146, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %149, i8* %143, i64 %146, i32 1, i1 false) #7
  %150 = load i64, i64* %56, align 8, !tbaa !205
  %151 = add i64 %150, %146
  store i64 %151, i64* %56, align 8, !tbaa !205
  br label %152

; <label>:152:                                    ; preds = %148, %141
  %153 = getelementptr inbounds i8, i8* %142, i64 1
  %154 = load i8, i8* %153, align 1, !tbaa !21
  switch i8 %154, label %174 [
    i8 37, label %155
    i8 48, label %169
  ]

; <label>:155:                                    ; preds = %152
  %156 = load i64, i64* %56, align 8, !tbaa !205
  %157 = load i64, i64* %57, align 8, !tbaa !203
  %158 = icmp ult i64 %156, %157
  br i1 %158, label %163, label %159

; <label>:159:                                    ; preds = %155
  %160 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1, i32 -1) #17
  %161 = load i8, i8* %153, align 1, !tbaa !21
  %162 = load i64, i64* %56, align 8, !tbaa !205
  br label %163

; <label>:163:                                    ; preds = %159, %155
  %164 = phi i64 [ %162, %159 ], [ %156, %155 ]
  %165 = phi i8 [ %161, %159 ], [ 37, %155 ]
  %166 = load i8*, i8** %80, align 8, !tbaa !206
  %167 = add i64 %164, 1
  store i64 %167, i64* %56, align 8, !tbaa !205
  %168 = getelementptr inbounds i8, i8* %166, i64 %164
  store i8 %165, i8* %168, align 1, !tbaa !21
  br label %195

; <label>:169:                                    ; preds = %152
  br i1 %140, label %195, label %170

; <label>:170:                                    ; preds = %169
  %171 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %139, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %171, i8* %84, i64 %139, i32 1, i1 false) #7
  %172 = load i64, i64* %56, align 8, !tbaa !205
  %173 = add i64 %172, %139
  store i64 %173, i64* %56, align 8, !tbaa !205
  br label %195

; <label>:174:                                    ; preds = %152
  %175 = tail call i16** @__ctype_b_loc() #22
  %176 = load i16*, i16** %175, align 8, !tbaa !54
  %177 = zext i8 %154 to i64
  %178 = getelementptr inbounds i16, i16* %176, i64 %177
  %179 = load i16, i16* %178, align 2, !tbaa !324
  %180 = and i16 %179, 2048
  %181 = icmp eq i16 %180, 0
  br i1 %181, label %193, label %182

; <label>:182:                                    ; preds = %174
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %81) #7
  %183 = sext i8 %154 to i32
  %184 = add nsw i32 %183, -49
  %185 = call fastcc i64 @get_onecapture(%struct.MatchState* nonnull %6, i32 %184, i8* %84, i8* %88, i8** nonnull %3) #17
  switch i64 %185, label %187 [
    i64 -2, label %186
    i64 0, label %192
  ]

; <label>:186:                                    ; preds = %182
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %7) #17
  br label %192

; <label>:187:                                    ; preds = %182
  %188 = load i8*, i8** %3, align 8, !tbaa !54
  %189 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %185, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %189, i8* %188, i64 %185, i32 1, i1 false) #7
  %190 = load i64, i64* %56, align 8, !tbaa !205
  %191 = add i64 %190, %185
  store i64 %191, i64* %56, align 8, !tbaa !205
  br label %192

; <label>:192:                                    ; preds = %187, %186, %182
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %81) #7
  br label %195

; <label>:193:                                    ; preds = %174
  %194 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %94, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.571, i64 0, i64 0), i32 37) #17
  unreachable

; <label>:195:                                    ; preds = %192, %170, %169, %163
  %196 = getelementptr inbounds i8, i8* %142, i64 2
  %197 = ptrtoint i8* %196 to i64
  %198 = load i64, i64* %2, align 8, !tbaa !82
  %199 = sub i64 %145, %197
  %200 = add i64 %198, %199
  store i64 %200, i64* %2, align 8, !tbaa !82
  %201 = call i8* @memchr(i8* nonnull %196, i32 37, i64 %200) #21
  %202 = icmp eq i8* %201, null
  br i1 %202, label %203, label %141

; <label>:203:                                    ; preds = %195, %131
  %204 = phi i64 [ %133, %131 ], [ %200, %195 ]
  %205 = phi i8* [ %132, %131 ], [ %196, %195 ]
  %206 = icmp eq i64 %204, 0
  br i1 %206, label %211, label %207

; <label>:207:                                    ; preds = %203
  %208 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %204, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %208, i8* %205, i64 %204, i32 1, i1 false) #7
  %209 = load i64, i64* %56, align 8, !tbaa !205
  %210 = add i64 %209, %204
  store i64 %210, i64* %56, align 8, !tbaa !205
  br label %211

; <label>:211:                                    ; preds = %207, %203
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %79) #7
  br label %248

; <label>:212:                                    ; preds = %128, %112
  %213 = phi %union.StackValue** [ %130, %128 ], [ %96, %112 ]
  %214 = load %union.StackValue*, %union.StackValue** %213, align 8, !tbaa !20
  %215 = getelementptr inbounds %union.StackValue, %union.StackValue* %214, i64 -1, i32 0
  %216 = getelementptr inbounds %union.StackValue, %union.StackValue* %214, i64 -1, i32 0, i32 1
  %217 = load i8, i8* %216, align 8, !tbaa !22
  %218 = and i8 %217, 15
  %219 = icmp eq i8 %218, 0
  br i1 %219, label %226, label %220

; <label>:220:                                    ; preds = %212
  %221 = icmp eq i8 %217, 1
  br i1 %221, label %222, label %237

; <label>:222:                                    ; preds = %220
  %223 = bitcast %struct.TValue* %215 to i32*
  %224 = load i32, i32* %223, align 8, !tbaa !21
  %225 = icmp eq i32 %224, 0
  br i1 %225, label %226, label %240

; <label>:226:                                    ; preds = %222, %212
  %227 = getelementptr inbounds %union.StackValue, %union.StackValue* %214, i64 -1
  store %union.StackValue* %227, %union.StackValue** %213, align 8, !tbaa !20
  %228 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %94, %union.StackValue* nonnull %227, i32 0) #17
  %229 = ptrtoint i8* %88 to i64
  %230 = ptrtoint i8* %84 to i64
  %231 = sub i64 %229, %230
  %232 = icmp eq i64 %231, 0
  br i1 %232, label %248, label %233

; <label>:233:                                    ; preds = %226
  %234 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %231, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %234, i8* %84, i64 %231, i32 1, i1 false) #7
  %235 = load i64, i64* %56, align 8, !tbaa !205
  %236 = add i64 %235, %231
  store i64 %236, i64* %56, align 8, !tbaa !205
  br label %248

; <label>:237:                                    ; preds = %220
  %238 = add nsw i8 %218, -3
  %239 = icmp ugt i8 %238, 1
  br i1 %239, label %240, label %247

; <label>:240:                                    ; preds = %237, %222
  %241 = call i32 @lua_type(%struct.lua_State* nonnull %94, i32 -1) #17
  %242 = add nsw i32 %241, 1
  %243 = sext i32 %242 to i64
  %244 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %243
  %245 = load i8*, i8** %244, align 8, !tbaa !54
  %246 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %94, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.570, i64 0, i64 0), i8* %245) #17
  unreachable

; <label>:247:                                    ; preds = %237
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %7) #17
  br label %248

; <label>:248:                                    ; preds = %211, %226, %233, %247
  %249 = phi i32 [ 1, %211 ], [ 1, %247 ], [ 0, %226 ], [ 0, %233 ]
  %250 = or i32 %249, %85
  br label %268

; <label>:251:                                    ; preds = %83
  %252 = load i8*, i8** %73, align 8, !tbaa !353
  %253 = icmp ult i8* %84, %252
  br i1 %253, label %254, label %275

; <label>:254:                                    ; preds = %251
  %255 = load i64, i64* %56, align 8, !tbaa !205
  %256 = load i64, i64* %57, align 8, !tbaa !203
  %257 = icmp ult i64 %255, %256
  br i1 %257, label %261, label %258

; <label>:258:                                    ; preds = %254
  %259 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 1, i32 -1) #17
  %260 = load i64, i64* %56, align 8, !tbaa !205
  br label %261

; <label>:261:                                    ; preds = %258, %254
  %262 = phi i64 [ %260, %258 ], [ %255, %254 ]
  %263 = getelementptr inbounds i8, i8* %84, i64 1
  %264 = load i8, i8* %84, align 1, !tbaa !21
  %265 = load i8*, i8** %80, align 8, !tbaa !206
  %266 = add i64 %262, 1
  store i64 %266, i64* %56, align 8, !tbaa !205
  %267 = getelementptr inbounds i8, i8* %265, i64 %262
  store i8 %264, i8* %267, align 1, !tbaa !21
  br label %268

; <label>:268:                                    ; preds = %248, %261
  %269 = phi i8* [ %88, %248 ], [ %87, %261 ]
  %270 = phi i64 [ %93, %248 ], [ %86, %261 ]
  %271 = phi i32 [ %250, %248 ], [ %85, %261 ]
  %272 = phi i8* [ %88, %248 ], [ %263, %261 ]
  %273 = icmp slt i64 %270, %43
  %274 = and i1 %273, %82
  br i1 %274, label %83, label %275

; <label>:275:                                    ; preds = %268, %251
  %276 = phi i64 [ %86, %251 ], [ %270, %268 ]
  %277 = phi i32 [ %85, %251 ], [ %271, %268 ]
  %278 = phi i8* [ %84, %251 ], [ %272, %268 ]
  %279 = icmp eq i32 %277, 0
  br i1 %279, label %280, label %307

; <label>:280:                                    ; preds = %65, %275
  %281 = phi i64 [ %276, %275 ], [ 0, %65 ]
  %282 = bitcast %union.StackValue** %17 to %struct.TValue**
  %283 = load %struct.TValue*, %struct.TValue** %282, align 8, !tbaa !20
  %284 = load %struct.CallInfo*, %struct.CallInfo** %12, align 8, !tbaa !24
  %285 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %284, i64 0, i32 0
  %286 = load %union.StackValue*, %union.StackValue** %285, align 8, !tbaa !64
  %287 = getelementptr inbounds %union.StackValue, %union.StackValue* %286, i64 1
  %288 = bitcast %struct.TValue* %283 to %union.StackValue*
  %289 = icmp ult %union.StackValue* %287, %288
  br i1 %289, label %294, label %290

; <label>:290:                                    ; preds = %280
  %291 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %292 = load %struct.global_State*, %struct.global_State** %291, align 8, !tbaa !2
  %293 = getelementptr inbounds %struct.global_State, %struct.global_State* %292, i64 0, i32 8
  br label %296

; <label>:294:                                    ; preds = %280
  %295 = getelementptr inbounds %union.StackValue, %union.StackValue* %287, i64 0, i32 0
  br label %296

; <label>:296:                                    ; preds = %290, %294
  %297 = phi %struct.TValue* [ %293, %290 ], [ %295, %294 ]
  %298 = bitcast %struct.TValue* %297 to i64*
  %299 = bitcast %struct.TValue* %283 to i64*
  %300 = load i64, i64* %298, align 8
  store i64 %300, i64* %299, align 8
  %301 = getelementptr inbounds %struct.TValue, %struct.TValue* %297, i64 0, i32 1
  %302 = load i8, i8* %301, align 8, !tbaa !22
  %303 = getelementptr inbounds %struct.TValue, %struct.TValue* %283, i64 0, i32 1
  store i8 %302, i8* %303, align 8, !tbaa !22
  %304 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %305 = getelementptr inbounds %union.StackValue, %union.StackValue* %304, i64 1
  store %union.StackValue* %305, %union.StackValue** %17, align 8, !tbaa !20
  %306 = getelementptr inbounds %union.StackValue, %union.StackValue* %305, i64 0, i32 0
  br label %320

; <label>:307:                                    ; preds = %275
  %308 = bitcast i8** %73 to i64*
  %309 = load i64, i64* %308, align 8, !tbaa !353
  %310 = ptrtoint i8* %278 to i64
  %311 = sub i64 %309, %310
  %312 = icmp eq i64 %311, 0
  br i1 %312, label %317, label %313

; <label>:313:                                    ; preds = %307
  %314 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %7, i64 %311, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %314, i8* %278, i64 %311, i32 1, i1 false) #7
  %315 = load i64, i64* %56, align 8, !tbaa !205
  %316 = add i64 %315, %311
  store i64 %316, i64* %56, align 8, !tbaa !205
  br label %317

; <label>:317:                                    ; preds = %307, %313
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %7) #16
  %318 = bitcast %union.StackValue** %17 to %struct.TValue**
  %319 = load %struct.TValue*, %struct.TValue** %318, align 8, !tbaa !20
  br label %320

; <label>:320:                                    ; preds = %317, %296
  %321 = phi i64 [ %276, %317 ], [ %281, %296 ]
  %322 = phi %struct.TValue* [ %319, %317 ], [ %306, %296 ]
  %323 = bitcast %struct.TValue* %322 to i64*
  store i64 %321, i64* %323, align 8, !tbaa !21
  %324 = getelementptr inbounds %struct.TValue, %struct.TValue* %322, i64 0, i32 1
  store i8 35, i8* %324, align 8, !tbaa !22
  %325 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !20
  %326 = getelementptr inbounds %union.StackValue, %union.StackValue* %325, i64 1
  store %union.StackValue* %326, %union.StackValue** %17, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %47) #7
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %46) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %8) #7
  ret i32 2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_len(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = load i64, i64* %2, align 8, !tbaa !82
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %7 = bitcast %union.StackValue** %6 to %struct.TValue**
  %8 = load %struct.TValue*, %struct.TValue** %7, align 8, !tbaa !20
  %9 = bitcast %struct.TValue* %8 to i64*
  store i64 %5, i64* %9, align 8, !tbaa !21
  %10 = getelementptr inbounds %struct.TValue, %struct.TValue* %8, i64 0, i32 1
  store i8 35, i8* %10, align 8, !tbaa !22
  %11 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !20
  %12 = getelementptr inbounds %union.StackValue, %union.StackValue* %11, i64 1
  store %union.StackValue* %12, %union.StackValue** %6, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_lower(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !82
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !207
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 4
  %10 = bitcast %struct.luaL_Buffer* %3 to %union.anon.6**
  store %union.anon.6* %9, %union.anon.6** %10, align 8, !tbaa !206
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %12 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 1
  %13 = bitcast i64* %12 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %13, align 8, !tbaa !82
  %14 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 %7, i32 -1) #17
  %15 = load i64, i64* %2, align 8, !tbaa !82
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %32, label %17

; <label>:17:                                     ; preds = %1
  %18 = tail call i32** @__ctype_tolower_loc() #22
  br label %19

; <label>:19:                                     ; preds = %17, %19
  %20 = phi i64 [ 0, %17 ], [ %29, %19 ]
  %21 = load i32*, i32** %18, align 8, !tbaa !54
  %22 = getelementptr inbounds i8, i8* %6, i64 %20
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = zext i8 %23 to i64
  %25 = getelementptr inbounds i32, i32* %21, i64 %24
  %26 = load i32, i32* %25, align 4, !tbaa !77
  %27 = trunc i32 %26 to i8
  %28 = getelementptr inbounds i8, i8* %14, i64 %20
  store i8 %27, i8* %28, align 1, !tbaa !21
  %29 = add nuw i64 %20, 1
  %30 = load i64, i64* %2, align 8, !tbaa !82
  %31 = icmp ult i64 %29, %30
  br i1 %31, label %19, label %32

; <label>:32:                                     ; preds = %19, %1
  %33 = phi i64 [ 0, %1 ], [ %30, %19 ]
  %34 = load i64, i64* %11, align 8, !tbaa !205
  %35 = add i64 %34, %33
  store i64 %35, i64* %11, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_match(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @str_find_aux(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_rep(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.luaL_Buffer, align 8
  %5 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %8 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %9 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3) #16
  %10 = icmp slt i64 %8, 1
  br i1 %10, label %11, label %13

; <label>:11:                                     ; preds = %1
  %12 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %58

; <label>:13:                                     ; preds = %1
  %14 = load i64, i64* %2, align 8, !tbaa !82
  %15 = load i64, i64* %3, align 8, !tbaa !82
  %16 = add i64 %15, %14
  %17 = icmp ult i64 %16, %14
  br i1 %17, label %21, label %18

; <label>:18:                                     ; preds = %13
  %19 = udiv i64 2147483647, %8
  %20 = icmp ugt i64 %16, %19
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %18, %13
  %22 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.572, i64 0, i64 0)) #16
  unreachable

; <label>:23:                                     ; preds = %18
  %24 = mul i64 %14, %8
  %25 = add nsw i64 %8, -1
  %26 = mul i64 %15, %25
  %27 = add i64 %26, %24
  %28 = bitcast %struct.luaL_Buffer* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %28) #7
  %29 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %29, align 8, !tbaa !207
  %30 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 4
  %31 = bitcast %struct.luaL_Buffer* %4 to %union.anon.6**
  store %union.anon.6* %30, %union.anon.6** %31, align 8, !tbaa !206
  %32 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 2
  %33 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %4, i64 0, i32 1
  %34 = bitcast i64* %33 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %34, align 8, !tbaa !82
  %35 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %4, i64 %27, i32 -1) #17
  %36 = icmp sgt i64 %8, 1
  %37 = load i64, i64* %2, align 8, !tbaa !82
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %35, i8* %7, i64 %37, i32 1, i1 false)
  br i1 %36, label %38, label %55

; <label>:38:                                     ; preds = %23
  br label %39

; <label>:39:                                     ; preds = %38, %51
  %40 = phi i64 [ %42, %51 ], [ %8, %38 ]
  %41 = phi i8* [ %53, %51 ], [ %35, %38 ]
  %42 = add nsw i64 %40, -1
  %43 = load i64, i64* %2, align 8, !tbaa !82
  %44 = getelementptr inbounds i8, i8* %41, i64 %43
  %45 = load i64, i64* %3, align 8, !tbaa !82
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %51, label %47

; <label>:47:                                     ; preds = %39
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %44, i8* %9, i64 %45, i32 1, i1 false)
  %48 = load i64, i64* %3, align 8, !tbaa !82
  %49 = getelementptr inbounds i8, i8* %44, i64 %48
  %50 = load i64, i64* %2, align 8, !tbaa !82
  br label %51

; <label>:51:                                     ; preds = %39, %47
  %52 = phi i64 [ %50, %47 ], [ %43, %39 ]
  %53 = phi i8* [ %49, %47 ], [ %44, %39 ]
  %54 = icmp sgt i64 %40, 2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %53, i8* %7, i64 %52, i32 1, i1 false)
  br i1 %54, label %39, label %55

; <label>:55:                                     ; preds = %51, %23
  %56 = load i64, i64* %32, align 8, !tbaa !205
  %57 = add i64 %56, %27
  store i64 %57, i64* %32, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %4) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %28) #7
  br label %58

; <label>:58:                                     ; preds = %11, %55
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_reverse(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !82
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !207
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 4
  %10 = bitcast %struct.luaL_Buffer* %3 to %union.anon.6**
  store %union.anon.6* %9, %union.anon.6** %10, align 8, !tbaa !206
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %12 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 1
  %13 = bitcast i64* %12 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %13, align 8, !tbaa !82
  %14 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 %7, i32 -1) #17
  %15 = load i64, i64* %2, align 8, !tbaa !82
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %29, label %17

; <label>:17:                                     ; preds = %1
  br label %18

; <label>:18:                                     ; preds = %17, %18
  %19 = phi i64 [ %27, %18 ], [ %15, %17 ]
  %20 = phi i64 [ %26, %18 ], [ 0, %17 ]
  %21 = xor i64 %20, -1
  %22 = add i64 %19, %21
  %23 = getelementptr inbounds i8, i8* %6, i64 %22
  %24 = load i8, i8* %23, align 1, !tbaa !21
  %25 = getelementptr inbounds i8, i8* %14, i64 %20
  store i8 %24, i8* %25, align 1, !tbaa !21
  %26 = add i64 %20, 1
  %27 = load i64, i64* %2, align 8, !tbaa !82
  %28 = icmp ugt i64 %27, %26
  br i1 %28, label %18, label %29

; <label>:29:                                     ; preds = %18, %1
  %30 = phi i64 [ 0, %1 ], [ %27, %18 ]
  %31 = load i64, i64* %11, align 8, !tbaa !205
  %32 = add i64 %31, %30
  store i64 %32, i64* %11, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_sub(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %6 = load i64, i64* %2, align 8, !tbaa !82
  %7 = icmp sgt i64 %5, 0
  br i1 %7, label %16, label %8

; <label>:8:                                      ; preds = %1
  %9 = icmp eq i64 %5, 0
  %10 = sub nsw i64 0, %6
  %11 = icmp slt i64 %5, %10
  %12 = or i1 %9, %11
  br i1 %12, label %16, label %13

; <label>:13:                                     ; preds = %8
  %14 = add i64 %6, 1
  %15 = add i64 %14, %5
  br label %16

; <label>:16:                                     ; preds = %1, %8, %13
  %17 = phi i64 [ %15, %13 ], [ %5, %1 ], [ 1, %8 ]
  %18 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 -1) #17
  %19 = icmp sgt i64 %18, %6
  br i1 %19, label %28, label %20

; <label>:20:                                     ; preds = %16
  %21 = icmp sgt i64 %18, -1
  br i1 %21, label %28, label %22

; <label>:22:                                     ; preds = %20
  %23 = sub nsw i64 0, %6
  %24 = icmp slt i64 %18, %23
  br i1 %24, label %28, label %25

; <label>:25:                                     ; preds = %22
  %26 = add i64 %6, 1
  %27 = add i64 %26, %18
  br label %28

; <label>:28:                                     ; preds = %16, %20, %22, %25
  %29 = phi i64 [ %27, %25 ], [ %6, %16 ], [ %18, %20 ], [ 0, %22 ]
  %30 = icmp ult i64 %29, %17
  br i1 %30, label %37, label %31

; <label>:31:                                     ; preds = %28
  %32 = getelementptr inbounds i8, i8* %4, i64 %17
  %33 = getelementptr inbounds i8, i8* %32, i64 -1
  %34 = sub i64 1, %17
  %35 = add i64 %34, %29
  %36 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* nonnull %33, i64 %35) #16
  br label %39

; <label>:37:                                     ; preds = %28
  %38 = call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0)) #16
  br label %39

; <label>:39:                                     ; preds = %37, %31
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_upper(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca %struct.luaL_Buffer, align 8
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = bitcast %struct.luaL_Buffer* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %7 = load i64, i64* %2, align 8, !tbaa !82
  %8 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %8, align 8, !tbaa !207
  %9 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 4
  %10 = bitcast %struct.luaL_Buffer* %3 to %union.anon.6**
  store %union.anon.6* %9, %union.anon.6** %10, align 8, !tbaa !206
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 2
  %12 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %3, i64 0, i32 1
  %13 = bitcast i64* %12 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %13, align 8, !tbaa !82
  %14 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %3, i64 %7, i32 -1) #17
  %15 = load i64, i64* %2, align 8, !tbaa !82
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %32, label %17

; <label>:17:                                     ; preds = %1
  %18 = tail call i32** @__ctype_toupper_loc() #22
  br label %19

; <label>:19:                                     ; preds = %17, %19
  %20 = phi i64 [ 0, %17 ], [ %29, %19 ]
  %21 = load i32*, i32** %18, align 8, !tbaa !54
  %22 = getelementptr inbounds i8, i8* %6, i64 %20
  %23 = load i8, i8* %22, align 1, !tbaa !21
  %24 = zext i8 %23 to i64
  %25 = getelementptr inbounds i32, i32* %21, i64 %24
  %26 = load i32, i32* %25, align 4, !tbaa !77
  %27 = trunc i32 %26 to i8
  %28 = getelementptr inbounds i8, i8* %14, i64 %20
  store i8 %27, i8* %28, align 1, !tbaa !21
  %29 = add nuw i64 %20, 1
  %30 = load i64, i64* %2, align 8, !tbaa !82
  %31 = icmp ult i64 %29, %30
  br i1 %31, label %19, label %32

; <label>:32:                                     ; preds = %19, %1
  %33 = phi i64 [ 0, %1 ], [ %30, %19 ]
  %34 = load i64, i64* %11, align 8, !tbaa !205
  %35 = add i64 %34, %33
  store i64 %35, i64* %11, align 8, !tbaa !205
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %3) #17
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %5) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_pack(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca %struct.Header, align 8
  %4 = alloca i8*, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %11) #7
  %12 = bitcast %struct.Header* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %12) #7
  %13 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %13) #7
  %14 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %14, i8** %4, align 8, !tbaa !54
  %15 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %15, align 8, !tbaa !360
  %16 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 1
  store i32 1, i32* %16, align 8, !tbaa !362
  %17 = getelementptr inbounds %struct.Header, %struct.Header* %3, i64 0, i32 2
  store i32 1, i32* %17, align 4, !tbaa !363
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %19 = bitcast %union.StackValue** %18 to %struct.TValue**
  %20 = load %struct.TValue*, %struct.TValue** %19, align 8, !tbaa !20
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  store i8 0, i8* %21, align 8, !tbaa !21
  %22 = load %union.StackValue*, %union.StackValue** %18, align 8, !tbaa !20
  %23 = getelementptr inbounds %union.StackValue, %union.StackValue* %22, i64 1
  store %union.StackValue* %23, %union.StackValue** %18, align 8, !tbaa !20
  %24 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %24, align 8, !tbaa !207
  %25 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %26 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %25, %union.anon.6** %26, align 8, !tbaa !206
  %27 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %28 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %29 = bitcast i64* %28 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %29, align 8, !tbaa !82
  %30 = load i8, i8* %14, align 1, !tbaa !21
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %256, label %32

; <label>:32:                                     ; preds = %1
  %33 = bitcast i32* %5 to i8*
  %34 = bitcast i32* %6 to i8*
  %35 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 0
  %36 = bitcast %union.Ftypes* %7 to i8*
  %37 = bitcast i64* %8 to i8*
  %38 = bitcast i64* %9 to i8*
  %39 = bitcast i64* %10 to i8*
  %40 = bitcast %union.Ftypes* %7 to float*
  %41 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  br label %42

; <label>:42:                                     ; preds = %32, %250
  %43 = phi i32 [ 1, %32 ], [ %252, %250 ]
  %44 = phi i64 [ 0, %32 ], [ %251, %250 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %33) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %34) #7
  %45 = call fastcc i32 @getdetails(%struct.Header* nonnull %3, i64 %44, i8** nonnull %4, i32* nonnull %5, i32* nonnull %6) #16
  %46 = load i32, i32* %6, align 4, !tbaa !77
  %47 = load i32, i32* %5, align 4, !tbaa !77
  %48 = add nsw i32 %47, %46
  %49 = sext i32 %48 to i64
  %50 = add i64 %44, %49
  %51 = add nsw i32 %46, -1
  store i32 %51, i32* %6, align 4, !tbaa !77
  %52 = icmp sgt i32 %46, 0
  br i1 %52, label %53, label %70

; <label>:53:                                     ; preds = %42
  br label %54

; <label>:54:                                     ; preds = %53, %62
  %55 = phi i32 [ %67, %62 ], [ %51, %53 ]
  %56 = load i64, i64* %27, align 8, !tbaa !205
  %57 = load i64, i64* %28, align 8, !tbaa !203
  %58 = icmp ult i64 %56, %57
  br i1 %58, label %62, label %59

; <label>:59:                                     ; preds = %54
  %60 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1, i32 -1) #17
  %61 = load i64, i64* %27, align 8, !tbaa !205
  br label %62

; <label>:62:                                     ; preds = %59, %54
  %63 = phi i64 [ %61, %59 ], [ %56, %54 ]
  %64 = load i8*, i8** %35, align 8, !tbaa !206
  %65 = add i64 %63, 1
  store i64 %65, i64* %27, align 8, !tbaa !205
  %66 = getelementptr inbounds i8, i8* %64, i64 %63
  store i8 0, i8* %66, align 1, !tbaa !21
  %67 = add nsw i32 %55, -1
  %68 = icmp sgt i32 %55, 0
  br i1 %68, label %54, label %69

; <label>:69:                                     ; preds = %62
  store i32 %67, i32* %6, align 4, !tbaa !77
  br label %70

; <label>:70:                                     ; preds = %69, %42
  %71 = add nsw i32 %43, 1
  switch i32 %45, label %250 [
    i32 0, label %72
    i32 1, label %90
    i32 2, label %102
    i32 3, label %144
    i32 4, label %181
    i32 5, label %205
    i32 6, label %237
    i32 7, label %249
    i32 8, label %249
  ]

; <label>:72:                                     ; preds = %70
  %73 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %71) #16
  %74 = icmp slt i32 %47, 8
  br i1 %74, label %75, label %86

; <label>:75:                                     ; preds = %72
  %76 = shl i32 %47, 3
  %77 = add nsw i32 %76, -1
  %78 = zext i32 %77 to i64
  %79 = shl i64 1, %78
  %80 = sub nsw i64 0, %79
  %81 = icmp sge i64 %73, %80
  %82 = icmp slt i64 %73, %79
  %83 = and i1 %81, %82
  br i1 %83, label %86, label %84

; <label>:84:                                     ; preds = %75
  %85 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %71, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.218, i64 0, i64 0)) #16
  br label %86

; <label>:86:                                     ; preds = %84, %75, %72
  %87 = load i32, i32* %16, align 8, !tbaa !362
  %88 = lshr i64 %73, 63
  %89 = trunc i64 %88 to i32
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %73, i32 %87, i32 %47, i32 %89) #16
  br label %250

; <label>:90:                                     ; preds = %70
  %91 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %71) #16
  %92 = icmp slt i32 %47, 8
  br i1 %92, label %93, label %100

; <label>:93:                                     ; preds = %90
  %94 = shl nsw i32 %47, 3
  %95 = zext i32 %94 to i64
  %96 = shl i64 1, %95
  %97 = icmp ult i64 %91, %96
  br i1 %97, label %100, label %98

; <label>:98:                                     ; preds = %93
  %99 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %71, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.573, i64 0, i64 0)) #16
  br label %100

; <label>:100:                                    ; preds = %93, %98, %90
  %101 = load i32, i32* %16, align 8, !tbaa !362
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %91, i32 %101, i32 %47, i32 0) #16
  br label %250

; <label>:102:                                    ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %36) #7
  %103 = sext i32 %47 to i64
  %104 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %103, i32 -1) #17
  %105 = call double @luaL_checknumber(%struct.lua_State* %0, i32 %71) #16
  %106 = icmp eq i32 %47, 4
  br i1 %106, label %107, label %109

; <label>:107:                                    ; preds = %102
  %108 = fptrunc double %105 to float
  store volatile float %108, float* %40, align 8, !tbaa !21
  br label %110

; <label>:109:                                    ; preds = %102
  store volatile double %105, double* %41, align 8, !tbaa !21
  br label %110

; <label>:110:                                    ; preds = %109, %107
  %111 = load i32, i32* %16, align 8, !tbaa !362
  %112 = icmp eq i32 %111, 1
  %113 = icmp eq i32 %47, 0
  br i1 %112, label %114, label %125

; <label>:114:                                    ; preds = %110
  br i1 %113, label %139, label %115

; <label>:115:                                    ; preds = %114
  br label %116

; <label>:116:                                    ; preds = %115, %116
  %117 = phi i8* [ %123, %116 ], [ %104, %115 ]
  %118 = phi i32 [ %120, %116 ], [ %47, %115 ]
  %119 = phi i8* [ %121, %116 ], [ %36, %115 ]
  %120 = add nsw i32 %118, -1
  %121 = getelementptr inbounds i8, i8* %119, i64 1
  %122 = load volatile i8, i8* %119, align 1, !tbaa !21
  %123 = getelementptr inbounds i8, i8* %117, i64 1
  store volatile i8 %122, i8* %117, align 1, !tbaa !21
  %124 = icmp eq i32 %120, 0
  br i1 %124, label %139, label %116

; <label>:125:                                    ; preds = %110
  br i1 %113, label %139, label %126

; <label>:126:                                    ; preds = %125
  %127 = add nsw i32 %47, -1
  %128 = sext i32 %127 to i64
  %129 = getelementptr inbounds i8, i8* %104, i64 %128
  br label %130

; <label>:130:                                    ; preds = %130, %126
  %131 = phi i8* [ %129, %126 ], [ %137, %130 ]
  %132 = phi i32 [ %47, %126 ], [ %134, %130 ]
  %133 = phi i8* [ %36, %126 ], [ %135, %130 ]
  %134 = add nsw i32 %132, -1
  %135 = getelementptr inbounds i8, i8* %133, i64 1
  %136 = load volatile i8, i8* %133, align 1, !tbaa !21
  %137 = getelementptr inbounds i8, i8* %131, i64 -1
  store volatile i8 %136, i8* %131, align 1, !tbaa !21
  %138 = icmp eq i32 %134, 0
  br i1 %138, label %139, label %130

; <label>:139:                                    ; preds = %130, %116, %114, %125
  %140 = load i32, i32* %5, align 4, !tbaa !77
  %141 = sext i32 %140 to i64
  %142 = load i64, i64* %27, align 8, !tbaa !205
  %143 = add i64 %142, %141
  store i64 %143, i64* %27, align 8, !tbaa !205
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %36) #7
  br label %250

; <label>:144:                                    ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %37) #7
  %145 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %71, i64* nonnull %8) #16
  %146 = load i64, i64* %8, align 8, !tbaa !82
  %147 = sext i32 %47 to i64
  %148 = icmp ugt i64 %146, %147
  br i1 %148, label %149, label %152

; <label>:149:                                    ; preds = %144
  %150 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %71, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.574, i64 0, i64 0)) #16
  %151 = load i64, i64* %8, align 8, !tbaa !82
  br label %152

; <label>:152:                                    ; preds = %144, %149
  %153 = phi i64 [ %146, %144 ], [ %151, %149 ]
  %154 = icmp eq i64 %153, 0
  br i1 %154, label %160, label %155

; <label>:155:                                    ; preds = %152
  %156 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %153, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %156, i8* %145, i64 %153, i32 1, i1 false) #7
  %157 = load i64, i64* %27, align 8, !tbaa !205
  %158 = add i64 %157, %153
  store i64 %158, i64* %27, align 8, !tbaa !205
  %159 = load i64, i64* %8, align 8, !tbaa !82
  br label %160

; <label>:160:                                    ; preds = %152, %155
  %161 = phi i64 [ 0, %152 ], [ %159, %155 ]
  %162 = add i64 %161, 1
  store i64 %162, i64* %8, align 8, !tbaa !82
  %163 = icmp ult i64 %161, %147
  br i1 %163, label %164, label %180

; <label>:164:                                    ; preds = %160
  br label %165

; <label>:165:                                    ; preds = %164, %172
  %166 = load i64, i64* %27, align 8, !tbaa !205
  %167 = load i64, i64* %28, align 8, !tbaa !203
  %168 = icmp ult i64 %166, %167
  br i1 %168, label %172, label %169

; <label>:169:                                    ; preds = %165
  %170 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1, i32 -1) #17
  %171 = load i64, i64* %27, align 8, !tbaa !205
  br label %172

; <label>:172:                                    ; preds = %169, %165
  %173 = phi i64 [ %171, %169 ], [ %166, %165 ]
  %174 = load i8*, i8** %35, align 8, !tbaa !206
  %175 = add i64 %173, 1
  store i64 %175, i64* %27, align 8, !tbaa !205
  %176 = getelementptr inbounds i8, i8* %174, i64 %173
  store i8 0, i8* %176, align 1, !tbaa !21
  %177 = load i64, i64* %8, align 8, !tbaa !82
  %178 = add i64 %177, 1
  store i64 %178, i64* %8, align 8, !tbaa !82
  %179 = icmp ult i64 %177, %147
  br i1 %179, label %165, label %180

; <label>:180:                                    ; preds = %172, %160
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %37) #7
  br label %250

; <label>:181:                                    ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %38) #7
  %182 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %71, i64* nonnull %9) #16
  %183 = icmp sgt i32 %47, 7
  br i1 %183, label %192, label %184

; <label>:184:                                    ; preds = %181
  %185 = load i64, i64* %9, align 8, !tbaa !82
  %186 = shl nsw i32 %47, 3
  %187 = zext i32 %186 to i64
  %188 = shl i64 1, %187
  %189 = icmp ult i64 %185, %188
  br i1 %189, label %192, label %190

; <label>:190:                                    ; preds = %184
  %191 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %71, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.575, i64 0, i64 0)) #16
  br label %192

; <label>:192:                                    ; preds = %190, %184, %181
  %193 = load i64, i64* %9, align 8, !tbaa !82
  %194 = load i32, i32* %16, align 8, !tbaa !362
  call fastcc void @packint(%struct.luaL_Buffer* nonnull %2, i64 %193, i32 %194, i32 %47, i32 0) #16
  %195 = load i64, i64* %9, align 8, !tbaa !82
  %196 = icmp eq i64 %195, 0
  br i1 %196, label %202, label %197

; <label>:197:                                    ; preds = %192
  %198 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %195, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %198, i8* %182, i64 %195, i32 1, i1 false) #7
  %199 = load i64, i64* %27, align 8, !tbaa !205
  %200 = add i64 %199, %195
  store i64 %200, i64* %27, align 8, !tbaa !205
  %201 = load i64, i64* %9, align 8, !tbaa !82
  br label %202

; <label>:202:                                    ; preds = %192, %197
  %203 = phi i64 [ 0, %192 ], [ %201, %197 ]
  %204 = add i64 %203, %50
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %38) #7
  br label %250

; <label>:205:                                    ; preds = %70
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %39) #7
  %206 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 %71, i64* nonnull %10) #16
  %207 = call i64 @strlen(i8* %206) #21
  %208 = load i64, i64* %10, align 8, !tbaa !82
  %209 = icmp eq i64 %207, %208
  br i1 %209, label %213, label %210

; <label>:210:                                    ; preds = %205
  %211 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 %71, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.556, i64 0, i64 0)) #16
  %212 = load i64, i64* %10, align 8, !tbaa !82
  br label %213

; <label>:213:                                    ; preds = %210, %205
  %214 = phi i64 [ %212, %210 ], [ %207, %205 ]
  %215 = icmp eq i64 %214, 0
  br i1 %215, label %216, label %218

; <label>:216:                                    ; preds = %213
  %217 = load i64, i64* %27, align 8, !tbaa !205
  br label %222

; <label>:218:                                    ; preds = %213
  %219 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %214, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %219, i8* %206, i64 %214, i32 1, i1 false) #7
  %220 = load i64, i64* %27, align 8, !tbaa !205
  %221 = add i64 %220, %214
  store i64 %221, i64* %27, align 8, !tbaa !205
  br label %222

; <label>:222:                                    ; preds = %216, %218
  %223 = phi i64 [ %217, %216 ], [ %221, %218 ]
  %224 = load i64, i64* %28, align 8, !tbaa !203
  %225 = icmp ult i64 %223, %224
  br i1 %225, label %229, label %226

; <label>:226:                                    ; preds = %222
  %227 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1, i32 -1) #17
  %228 = load i64, i64* %27, align 8, !tbaa !205
  br label %229

; <label>:229:                                    ; preds = %226, %222
  %230 = phi i64 [ %228, %226 ], [ %223, %222 ]
  %231 = load i8*, i8** %35, align 8, !tbaa !206
  %232 = add i64 %230, 1
  store i64 %232, i64* %27, align 8, !tbaa !205
  %233 = getelementptr inbounds i8, i8* %231, i64 %230
  store i8 0, i8* %233, align 1, !tbaa !21
  %234 = load i64, i64* %10, align 8, !tbaa !82
  %235 = add i64 %50, 1
  %236 = add i64 %235, %234
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %39) #7
  br label %250

; <label>:237:                                    ; preds = %70
  %238 = load i64, i64* %27, align 8, !tbaa !205
  %239 = load i64, i64* %28, align 8, !tbaa !203
  %240 = icmp ult i64 %238, %239
  br i1 %240, label %244, label %241

; <label>:241:                                    ; preds = %237
  %242 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 1, i32 -1) #17
  %243 = load i64, i64* %27, align 8, !tbaa !205
  br label %244

; <label>:244:                                    ; preds = %241, %237
  %245 = phi i64 [ %243, %241 ], [ %238, %237 ]
  %246 = load i8*, i8** %35, align 8, !tbaa !206
  %247 = add i64 %245, 1
  store i64 %247, i64* %27, align 8, !tbaa !205
  %248 = getelementptr inbounds i8, i8* %246, i64 %245
  store i8 0, i8* %248, align 1, !tbaa !21
  br label %249

; <label>:249:                                    ; preds = %70, %70, %244
  br label %250

; <label>:250:                                    ; preds = %70, %249, %229, %202, %180, %139, %100, %86
  %251 = phi i64 [ %50, %70 ], [ %50, %249 ], [ %236, %229 ], [ %204, %202 ], [ %50, %180 ], [ %50, %139 ], [ %50, %100 ], [ %50, %86 ]
  %252 = phi i32 [ %71, %70 ], [ %43, %249 ], [ %71, %229 ], [ %71, %202 ], [ %71, %180 ], [ %71, %139 ], [ %71, %100 ], [ %71, %86 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %34) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %33) #7
  %253 = load i8*, i8** %4, align 8, !tbaa !54
  %254 = load i8, i8* %253, align 1, !tbaa !21
  %255 = icmp eq i8 %254, 0
  br i1 %255, label %256, label %42

; <label>:256:                                    ; preds = %250, %1
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %13) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %12) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %11) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_packsize(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %8, i8** %3, align 8, !tbaa !54
  %9 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %9, align 8, !tbaa !360
  %10 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  store i32 1, i32* %10, align 8, !tbaa !362
  %11 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 2
  store i32 1, i32* %11, align 4, !tbaa !363
  %12 = load i8, i8* %8, align 1, !tbaa !21
  %13 = icmp eq i8 %12, 0
  br i1 %13, label %38, label %14

; <label>:14:                                     ; preds = %1
  %15 = bitcast i32* %4 to i8*
  %16 = bitcast i32* %5 to i8*
  br label %17

; <label>:17:                                     ; preds = %14, %33
  %18 = phi i64 [ 0, %14 ], [ %34, %33 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %15) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %16) #7
  %19 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %18, i8** nonnull %3, i32* nonnull %4, i32* nonnull %5) #16
  %20 = or i32 %19, 1
  %21 = icmp eq i32 %20, 5
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %17
  %23 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.581, i64 0, i64 0)) #16
  br label %24

; <label>:24:                                     ; preds = %17, %22
  %25 = load i32, i32* %5, align 4, !tbaa !77
  %26 = load i32, i32* %4, align 4, !tbaa !77
  %27 = add nsw i32 %26, %25
  store i32 %27, i32* %4, align 4, !tbaa !77
  %28 = sext i32 %27 to i64
  %29 = sub nsw i64 2147483647, %28
  %30 = icmp ugt i64 %18, %29
  br i1 %30, label %31, label %33

; <label>:31:                                     ; preds = %24
  %32 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.582, i64 0, i64 0)) #16
  br label %33

; <label>:33:                                     ; preds = %24, %31
  %34 = add i64 %18, %28
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %16) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %15) #7
  %35 = load i8*, i8** %3, align 8, !tbaa !54
  %36 = load i8, i8* %35, align 1, !tbaa !21
  %37 = icmp eq i8 %36, 0
  br i1 %37, label %38, label %17

; <label>:38:                                     ; preds = %33, %1
  %39 = phi i64 [ 0, %1 ], [ %34, %33 ]
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %41 = bitcast %union.StackValue** %40 to %struct.TValue**
  %42 = load %struct.TValue*, %struct.TValue** %41, align 8, !tbaa !20
  %43 = bitcast %struct.TValue* %42 to i64*
  store i64 %39, i64* %43, align 8, !tbaa !21
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %42, i64 0, i32 1
  store i8 35, i8* %44, align 8, !tbaa !22
  %45 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !20
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %45, i64 1
  store %union.StackValue* %46, %union.StackValue** %40, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @str_unpack(%struct.lua_State*) #0 {
  %2 = alloca %struct.Header, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i64, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca %union.Ftypes, align 8
  %8 = bitcast %struct.Header* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %8) #7
  %9 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %9) #7
  %10 = tail call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* null) #16
  store i8* %10, i8** %3, align 8, !tbaa !54
  %11 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %11) #7
  %12 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4) #16
  %13 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %14 = load i64, i64* %4, align 8, !tbaa !82
  %15 = icmp sgt i64 %13, 0
  br i1 %15, label %24, label %16

; <label>:16:                                     ; preds = %1
  %17 = icmp eq i64 %13, 0
  %18 = sub nsw i64 0, %14
  %19 = icmp slt i64 %13, %18
  %20 = or i1 %17, %19
  br i1 %20, label %24, label %21

; <label>:21:                                     ; preds = %16
  %22 = add i64 %13, 1
  %23 = add i64 %22, %14
  br label %24

; <label>:24:                                     ; preds = %1, %16, %21
  %25 = phi i64 [ %23, %21 ], [ %13, %1 ], [ 1, %16 ]
  %26 = add i64 %25, -1
  %27 = icmp ugt i64 %26, %14
  br i1 %27, label %28, label %30

; <label>:28:                                     ; preds = %24
  %29 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0)) #16
  br label %30

; <label>:30:                                     ; preds = %24, %28
  %31 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 0
  store %struct.lua_State* %0, %struct.lua_State** %31, align 8, !tbaa !360
  %32 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 1
  store i32 1, i32* %32, align 8, !tbaa !362
  %33 = getelementptr inbounds %struct.Header, %struct.Header* %2, i64 0, i32 2
  store i32 1, i32* %33, align 4, !tbaa !363
  %34 = load i8, i8* %10, align 1, !tbaa !21
  %35 = icmp eq i8 %34, 0
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %30
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %38 = bitcast %union.StackValue** %37 to %struct.TValue**
  br label %160

; <label>:39:                                     ; preds = %30
  %40 = bitcast i32* %5 to i8*
  %41 = bitcast i32* %6 to i8*
  %42 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %43 = bitcast %union.StackValue** %42 to %struct.TValue**
  %44 = bitcast %union.Ftypes* %7 to i8*
  %45 = bitcast %union.Ftypes* %7 to float*
  %46 = getelementptr inbounds %union.Ftypes, %union.Ftypes* %7, i64 0, i32 0
  br label %47

; <label>:47:                                     ; preds = %39, %152
  %48 = phi i64 [ %26, %39 ], [ %156, %152 ]
  %49 = phi i32 [ 0, %39 ], [ %154, %152 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %40) #7
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %41) #7
  %50 = call fastcc i32 @getdetails(%struct.Header* nonnull %2, i64 %48, i8** nonnull %3, i32* nonnull %5, i32* nonnull %6) #16
  %51 = load i32, i32* %6, align 4, !tbaa !77
  %52 = sext i32 %51 to i64
  %53 = load i32, i32* %5, align 4, !tbaa !77
  %54 = sext i32 %53 to i64
  %55 = add nsw i64 %54, %52
  %56 = load i64, i64* %4, align 8, !tbaa !82
  %57 = sub i64 %56, %48
  %58 = icmp ugt i64 %55, %57
  br i1 %58, label %59, label %61

; <label>:59:                                     ; preds = %47
  %60 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0)) #16
  br label %61

; <label>:61:                                     ; preds = %47, %59
  %62 = add i64 %48, %52
  call void @luaL_checkstack(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.585, i64 0, i64 0)) #16
  %63 = add nsw i32 %49, 1
  switch i32 %50, label %152 [
    i32 0, label %64
    i32 1, label %64
    i32 2, label %75
    i32 3, label %121
    i32 4, label %124
    i32 5, label %138
    i32 7, label %151
    i32 6, label %151
    i32 8, label %151
  ]

; <label>:64:                                     ; preds = %61, %61
  %65 = getelementptr inbounds i8, i8* %12, i64 %62
  %66 = load i32, i32* %32, align 8, !tbaa !362
  %67 = icmp eq i32 %50, 0
  %68 = zext i1 %67 to i32
  %69 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %65, i32 %66, i32 %53, i32 %68) #16
  %70 = load %struct.TValue*, %struct.TValue** %43, align 8, !tbaa !20
  %71 = bitcast %struct.TValue* %70 to i64*
  store i64 %69, i64* %71, align 8, !tbaa !21
  %72 = getelementptr inbounds %struct.TValue, %struct.TValue* %70, i64 0, i32 1
  store i8 35, i8* %72, align 8, !tbaa !22
  %73 = load %union.StackValue*, %union.StackValue** %42, align 8, !tbaa !20
  %74 = getelementptr inbounds %union.StackValue, %union.StackValue* %73, i64 1
  store %union.StackValue* %74, %union.StackValue** %42, align 8, !tbaa !20
  br label %152

; <label>:75:                                     ; preds = %61
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %44) #7
  %76 = getelementptr inbounds i8, i8* %12, i64 %62
  %77 = load i32, i32* %32, align 8, !tbaa !362
  %78 = icmp eq i32 %77, 1
  %79 = icmp eq i32 %53, 0
  br i1 %78, label %80, label %91

; <label>:80:                                     ; preds = %75
  br i1 %79, label %105, label %81

; <label>:81:                                     ; preds = %80
  br label %82

; <label>:82:                                     ; preds = %81, %82
  %83 = phi i8* [ %89, %82 ], [ %44, %81 ]
  %84 = phi i32 [ %86, %82 ], [ %53, %81 ]
  %85 = phi i8* [ %87, %82 ], [ %76, %81 ]
  %86 = add nsw i32 %84, -1
  %87 = getelementptr inbounds i8, i8* %85, i64 1
  %88 = load volatile i8, i8* %85, align 1, !tbaa !21
  %89 = getelementptr inbounds i8, i8* %83, i64 1
  store volatile i8 %88, i8* %83, align 1, !tbaa !21
  %90 = icmp eq i32 %86, 0
  br i1 %90, label %105, label %82

; <label>:91:                                     ; preds = %75
  br i1 %79, label %105, label %92

; <label>:92:                                     ; preds = %91
  %93 = add nsw i32 %53, -1
  %94 = sext i32 %93 to i64
  %95 = getelementptr inbounds i8, i8* %44, i64 %94
  br label %96

; <label>:96:                                     ; preds = %96, %92
  %97 = phi i8* [ %95, %92 ], [ %103, %96 ]
  %98 = phi i32 [ %53, %92 ], [ %100, %96 ]
  %99 = phi i8* [ %76, %92 ], [ %101, %96 ]
  %100 = add nsw i32 %98, -1
  %101 = getelementptr inbounds i8, i8* %99, i64 1
  %102 = load volatile i8, i8* %99, align 1, !tbaa !21
  %103 = getelementptr inbounds i8, i8* %97, i64 -1
  store volatile i8 %102, i8* %97, align 1, !tbaa !21
  %104 = icmp eq i32 %100, 0
  br i1 %104, label %105, label %96

; <label>:105:                                    ; preds = %96, %82, %80, %91
  %106 = load i32, i32* %5, align 4, !tbaa !77
  %107 = icmp eq i32 %106, 4
  br i1 %107, label %108, label %111

; <label>:108:                                    ; preds = %105
  %109 = load volatile float, float* %45, align 8, !tbaa !21
  %110 = fpext float %109 to double
  br label %113

; <label>:111:                                    ; preds = %105
  %112 = load volatile double, double* %46, align 8, !tbaa !21
  br label %113

; <label>:113:                                    ; preds = %111, %108
  %114 = phi double [ %110, %108 ], [ %112, %111 ]
  %115 = load %struct.TValue*, %struct.TValue** %43, align 8, !tbaa !20
  %116 = bitcast %struct.TValue* %115 to double*
  store double %114, double* %116, align 8, !tbaa !21
  %117 = getelementptr inbounds %struct.TValue, %struct.TValue* %115, i64 0, i32 1
  store i8 19, i8* %117, align 8, !tbaa !22
  %118 = load %union.StackValue*, %union.StackValue** %42, align 8, !tbaa !20
  %119 = getelementptr inbounds %union.StackValue, %union.StackValue* %118, i64 1
  store %union.StackValue* %119, %union.StackValue** %42, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %44) #7
  %120 = sext i32 %106 to i64
  br label %152

; <label>:121:                                    ; preds = %61
  %122 = getelementptr inbounds i8, i8* %12, i64 %62
  %123 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %122, i64 %54) #16
  br label %152

; <label>:124:                                    ; preds = %61
  %125 = getelementptr inbounds i8, i8* %12, i64 %62
  %126 = load i32, i32* %32, align 8, !tbaa !362
  %127 = call fastcc i64 @unpackint(%struct.lua_State* %0, i8* %125, i32 %126, i32 %53, i32 0) #16
  %128 = load i64, i64* %4, align 8, !tbaa !82
  %129 = add i64 %62, %54
  %130 = sub i64 %128, %129
  %131 = icmp ugt i64 %127, %130
  br i1 %131, label %132, label %134

; <label>:132:                                    ; preds = %124
  %133 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.584, i64 0, i64 0)) #16
  br label %134

; <label>:134:                                    ; preds = %124, %132
  %135 = getelementptr inbounds i8, i8* %125, i64 %54
  %136 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %135, i64 %127) #16
  %137 = add i64 %127, %62
  br label %152

; <label>:138:                                    ; preds = %61
  %139 = getelementptr inbounds i8, i8* %12, i64 %62
  %140 = call i64 @strlen(i8* %139) #21
  %141 = shl i64 %140, 32
  %142 = ashr exact i64 %141, 32
  %143 = add i64 %142, %62
  %144 = load i64, i64* %4, align 8, !tbaa !82
  %145 = icmp ult i64 %143, %144
  br i1 %145, label %148, label %146

; <label>:146:                                    ; preds = %138
  %147 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.586, i64 0, i64 0)) #16
  br label %148

; <label>:148:                                    ; preds = %146, %138
  %149 = call i8* @lua_pushlstring(%struct.lua_State* %0, i8* %139, i64 %142) #16
  %150 = add i64 %143, 1
  br label %152

; <label>:151:                                    ; preds = %61, %61, %61
  br label %152

; <label>:152:                                    ; preds = %61, %151, %148, %134, %121, %113, %64
  %153 = phi i64 [ %54, %61 ], [ %54, %151 ], [ %54, %148 ], [ %54, %134 ], [ %54, %121 ], [ %120, %113 ], [ %54, %64 ]
  %154 = phi i32 [ %63, %61 ], [ %49, %151 ], [ %63, %148 ], [ %63, %134 ], [ %63, %121 ], [ %63, %113 ], [ %63, %64 ]
  %155 = phi i64 [ %62, %61 ], [ %62, %151 ], [ %150, %148 ], [ %137, %134 ], [ %62, %121 ], [ %62, %113 ], [ %62, %64 ]
  %156 = add i64 %155, %153
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %41) #7
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %40) #7
  %157 = load i8*, i8** %3, align 8, !tbaa !54
  %158 = load i8, i8* %157, align 1, !tbaa !21
  %159 = icmp eq i8 %158, 0
  br i1 %159, label %160, label %47

; <label>:160:                                    ; preds = %152, %36
  %161 = phi %struct.TValue** [ %38, %36 ], [ %43, %152 ]
  %162 = phi %union.StackValue** [ %37, %36 ], [ %42, %152 ]
  %163 = phi i32 [ 0, %36 ], [ %154, %152 ]
  %164 = phi i64 [ %26, %36 ], [ %156, %152 ]
  %165 = add i64 %164, 1
  %166 = load %struct.TValue*, %struct.TValue** %161, align 8, !tbaa !20
  %167 = bitcast %struct.TValue* %166 to i64*
  store i64 %165, i64* %167, align 8, !tbaa !21
  %168 = getelementptr inbounds %struct.TValue, %struct.TValue* %166, i64 0, i32 1
  store i8 35, i8* %168, align 8, !tbaa !22
  %169 = load %union.StackValue*, %union.StackValue** %162, align 8, !tbaa !20
  %170 = getelementptr inbounds %union.StackValue, %union.StackValue* %169, i64 1
  store %union.StackValue* %170, %union.StackValue** %162, align 8, !tbaa !20
  %171 = add nsw i32 %163, 1
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %11) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %9) #7
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %8) #7
  ret i32 %171
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @writer(%struct.lua_State* nocapture readnone, i8* nocapture readonly, i64, i8*) #0 {
  %5 = icmp eq i64 %2, 0
  br i1 %5, label %13, label %6

; <label>:6:                                      ; preds = %4
  %7 = bitcast i8* %3 to %struct.luaL_Buffer*
  %8 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %7, i64 %2, i32 -1) #17
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %1, i64 %2, i32 1, i1 false) #7
  %9 = getelementptr inbounds i8, i8* %3, i64 16
  %10 = bitcast i8* %9 to i64*
  %11 = load i64, i64* %10, align 8, !tbaa !205
  %12 = add i64 %11, %2
  store i64 %12, i64* %10, align 8, !tbaa !205
  br label %13

; <label>:13:                                     ; preds = %4, %6
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @str_find_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca %struct.MatchState, align 8
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = bitcast i64* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %7) #7
  %8 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %9 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 2, i64* nonnull %4) #16
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %11 = load i64, i64* %3, align 8, !tbaa !82
  %12 = icmp sgt i64 %10, 0
  br i1 %12, label %21, label %13

; <label>:13:                                     ; preds = %2
  %14 = icmp eq i64 %10, 0
  %15 = sub nsw i64 0, %11
  %16 = icmp slt i64 %10, %15
  %17 = or i1 %14, %16
  br i1 %17, label %21, label %18

; <label>:18:                                     ; preds = %13
  %19 = add i64 %10, 1
  %20 = add i64 %19, %11
  br label %21

; <label>:21:                                     ; preds = %2, %13, %18
  %22 = phi i64 [ %20, %18 ], [ %10, %2 ], [ 1, %13 ]
  %23 = add i64 %22, -1
  %24 = icmp ult i64 %11, %23
  br i1 %24, label %25, label %32

; <label>:25:                                     ; preds = %21
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = bitcast %union.StackValue** %26 to %struct.TValue**
  %28 = load %struct.TValue*, %struct.TValue** %27, align 8, !tbaa !20
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  store i8 0, i8* %29, align 8, !tbaa !21
  %30 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 1
  store %union.StackValue* %31, %union.StackValue** %26, align 8, !tbaa !20
  br label %188

; <label>:32:                                     ; preds = %21
  %33 = icmp ne i32 %1, 0
  br i1 %33, label %34, label %122

; <label>:34:                                     ; preds = %32
  %35 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %36 = load %struct.CallInfo*, %struct.CallInfo** %35, align 8, !tbaa !24
  %37 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %36, i64 0, i32 0
  %38 = load %union.StackValue*, %union.StackValue** %37, align 8, !tbaa !64
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 4
  %40 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %41 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !20
  %42 = icmp ult %union.StackValue* %39, %41
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 0, i32 0
  br i1 %42, label %48, label %44

; <label>:44:                                     ; preds = %34
  %45 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %46 = load %struct.global_State*, %struct.global_State** %45, align 8, !tbaa !2
  %47 = getelementptr inbounds %struct.global_State, %struct.global_State* %46, i64 0, i32 8
  br label %50

; <label>:48:                                     ; preds = %34
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %39, i64 0, i32 0
  br label %50

; <label>:50:                                     ; preds = %44, %48
  %51 = phi %struct.TValue* [ %47, %44 ], [ %49, %48 ]
  %52 = getelementptr inbounds %struct.TValue, %struct.TValue* %51, i64 0, i32 1
  %53 = load i8, i8* %52, align 8, !tbaa !22
  %54 = and i8 %53, 15
  %55 = icmp eq i8 %54, 0
  br i1 %55, label %62, label %56

; <label>:56:                                     ; preds = %50
  %57 = icmp eq i8 %53, 1
  br i1 %57, label %58, label %74

; <label>:58:                                     ; preds = %56
  %59 = bitcast %struct.TValue* %51 to i32*
  %60 = load i32, i32* %59, align 8, !tbaa !21
  %61 = icmp eq i32 %60, 0
  br i1 %61, label %62, label %74

; <label>:62:                                     ; preds = %50, %58
  %63 = load i64, i64* %4, align 8, !tbaa !82
  br label %64

; <label>:64:                                     ; preds = %69, %62
  %65 = phi i64 [ 0, %62 ], [ %72, %69 ]
  %66 = getelementptr inbounds i8, i8* %9, i64 %65
  %67 = call i8* @strpbrk(i8* %66, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.544, i64 0, i64 0)) #21
  %68 = icmp eq i8* %67, null
  br i1 %68, label %69, label %122

; <label>:69:                                     ; preds = %64
  %70 = call i64 @strlen(i8* %66) #21
  %71 = add i64 %65, 1
  %72 = add i64 %71, %70
  %73 = icmp ugt i64 %72, %63
  br i1 %73, label %74, label %64

; <label>:74:                                     ; preds = %69, %56, %58
  %75 = getelementptr inbounds i8, i8* %8, i64 %23
  %76 = sub i64 %11, %23
  %77 = load i64, i64* %4, align 8, !tbaa !82
  %78 = icmp eq i64 %77, 0
  br i1 %78, label %104, label %79

; <label>:79:                                     ; preds = %74
  %80 = icmp ugt i64 %77, %76
  br i1 %80, label %182, label %81

; <label>:81:                                     ; preds = %79
  %82 = add i64 %77, -1
  %83 = sub i64 %76, %82
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %182, label %85

; <label>:85:                                     ; preds = %81
  %86 = load i8, i8* %9, align 1, !tbaa !21
  %87 = sext i8 %86 to i32
  %88 = getelementptr inbounds i8, i8* %9, i64 1
  br label %89

; <label>:89:                                     ; preds = %98, %85
  %90 = phi i64 [ %83, %85 ], [ %102, %98 ]
  %91 = phi i8* [ %75, %85 ], [ %95, %98 ]
  %92 = call i8* @memchr(i8* %91, i32 %87, i64 %90) #21
  %93 = icmp eq i8* %92, null
  br i1 %93, label %182, label %94

; <label>:94:                                     ; preds = %89
  %95 = getelementptr inbounds i8, i8* %92, i64 1
  %96 = call i32 @memcmp(i8* nonnull %95, i8* nonnull %88, i64 %82) #21
  %97 = icmp eq i32 %96, 0
  br i1 %97, label %106, label %98

; <label>:98:                                     ; preds = %94
  %99 = ptrtoint i8* %95 to i64
  %100 = ptrtoint i8* %91 to i64
  %101 = add i64 %90, %100
  %102 = sub i64 %101, %99
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %182, label %89

; <label>:104:                                    ; preds = %74
  %105 = icmp eq i8* %75, null
  br i1 %105, label %182, label %106

; <label>:106:                                    ; preds = %94, %104
  %107 = phi i8* [ %75, %104 ], [ %92, %94 ]
  %108 = ptrtoint i8* %107 to i64
  %109 = ptrtoint i8* %8 to i64
  %110 = sub i64 %108, %109
  %111 = add nsw i64 %110, 1
  %112 = bitcast %union.StackValue* %41 to i64*
  store i64 %111, i64* %112, align 8, !tbaa !21
  %113 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 0, i32 0, i32 1
  store i8 35, i8* %113, align 8, !tbaa !22
  %114 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !20
  %115 = getelementptr inbounds %union.StackValue, %union.StackValue* %114, i64 1
  store %union.StackValue* %115, %union.StackValue** %40, align 8, !tbaa !20
  %116 = load i64, i64* %4, align 8, !tbaa !82
  %117 = add i64 %116, %110
  %118 = bitcast %union.StackValue* %115 to i64*
  store i64 %117, i64* %118, align 8, !tbaa !21
  %119 = getelementptr inbounds %union.StackValue, %union.StackValue* %114, i64 1, i32 0, i32 1
  store i8 35, i8* %119, align 8, !tbaa !22
  %120 = load %union.StackValue*, %union.StackValue** %40, align 8, !tbaa !20
  %121 = getelementptr inbounds %union.StackValue, %union.StackValue* %120, i64 1
  store %union.StackValue* %121, %union.StackValue** %40, align 8, !tbaa !20
  br label %188

; <label>:122:                                    ; preds = %64, %32
  %123 = bitcast %struct.MatchState* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 552, i8* nonnull %123) #7
  %124 = getelementptr inbounds i8, i8* %8, i64 %23
  %125 = load i8, i8* %9, align 1, !tbaa !21
  %126 = icmp eq i8 %125, 94
  br i1 %126, label %129, label %127

; <label>:127:                                    ; preds = %122
  %128 = load i64, i64* %4, align 8, !tbaa !82
  br label %133

; <label>:129:                                    ; preds = %122
  %130 = getelementptr inbounds i8, i8* %9, i64 1
  %131 = load i64, i64* %4, align 8, !tbaa !82
  %132 = add i64 %131, -1
  store i64 %132, i64* %4, align 8, !tbaa !82
  br label %133

; <label>:133:                                    ; preds = %127, %129
  %134 = phi i64 [ %132, %129 ], [ %128, %127 ]
  %135 = phi i8* [ %130, %129 ], [ %9, %127 ]
  %136 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %136, align 8, !tbaa !349
  %137 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 4
  store i32 200, i32* %137, align 8, !tbaa !351
  %138 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 0
  store i8* %8, i8** %138, align 8, !tbaa !352
  %139 = getelementptr inbounds i8, i8* %8, i64 %11
  %140 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 1
  store i8* %139, i8** %140, align 8, !tbaa !353
  %141 = getelementptr inbounds i8, i8* %135, i64 %134
  %142 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 2
  store i8* %141, i8** %142, align 8, !tbaa !354
  %143 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %5, i64 0, i32 5
  br label %144

; <label>:144:                                    ; preds = %174, %133
  %145 = phi i8* [ %124, %133 ], [ %175, %174 ]
  store i8 0, i8* %143, align 4, !tbaa !359
  %146 = call fastcc i8* @match(%struct.MatchState* nonnull %5, i8* %145, i8* %135) #16
  %147 = icmp eq i8* %146, null
  br i1 %147, label %171, label %148

; <label>:148:                                    ; preds = %144
  br i1 %33, label %149, label %169

; <label>:149:                                    ; preds = %148
  %150 = ptrtoint i8* %145 to i64
  %151 = ptrtoint i8* %8 to i64
  %152 = sub i64 1, %151
  %153 = add i64 %152, %150
  %154 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %155 = bitcast %union.StackValue** %154 to %struct.TValue**
  %156 = load %struct.TValue*, %struct.TValue** %155, align 8, !tbaa !20
  %157 = bitcast %struct.TValue* %156 to i64*
  store i64 %153, i64* %157, align 8, !tbaa !21
  %158 = getelementptr inbounds %struct.TValue, %struct.TValue* %156, i64 0, i32 1
  store i8 35, i8* %158, align 8, !tbaa !22
  %159 = load %union.StackValue*, %union.StackValue** %154, align 8, !tbaa !20
  %160 = getelementptr inbounds %union.StackValue, %union.StackValue* %159, i64 1
  store %union.StackValue* %160, %union.StackValue** %154, align 8, !tbaa !20
  %161 = ptrtoint i8* %146 to i64
  %162 = sub i64 %161, %151
  %163 = bitcast %union.StackValue* %160 to i64*
  store i64 %162, i64* %163, align 8, !tbaa !21
  %164 = getelementptr inbounds %union.StackValue, %union.StackValue* %159, i64 1, i32 0, i32 1
  store i8 35, i8* %164, align 8, !tbaa !22
  %165 = load %union.StackValue*, %union.StackValue** %154, align 8, !tbaa !20
  %166 = getelementptr inbounds %union.StackValue, %union.StackValue* %165, i64 1
  store %union.StackValue* %166, %union.StackValue** %154, align 8, !tbaa !20
  %167 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* null, i8* null) #16
  %168 = add nsw i32 %167, 2
  br label %180

; <label>:169:                                    ; preds = %148
  %170 = call fastcc i32 @push_captures(%struct.MatchState* nonnull %5, i8* %145, i8* nonnull %146) #16
  br label %180

; <label>:171:                                    ; preds = %144
  %172 = load i8*, i8** %140, align 8, !tbaa !353
  %173 = icmp ult i8* %145, %172
  br i1 %173, label %174, label %176

; <label>:174:                                    ; preds = %171
  %175 = getelementptr inbounds i8, i8* %145, i64 1
  br i1 %126, label %176, label %144

; <label>:176:                                    ; preds = %174, %171
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %123) #7
  %177 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %178 = bitcast %union.StackValue** %177 to %struct.TValue**
  %179 = load %struct.TValue*, %struct.TValue** %178, align 8, !tbaa !20
  br label %182

; <label>:180:                                    ; preds = %149, %169
  %181 = phi i32 [ %170, %169 ], [ %168, %149 ]
  call void @llvm.lifetime.end.p0i8(i64 552, i8* nonnull %123) #7
  br label %188

; <label>:182:                                    ; preds = %89, %98, %81, %79, %176, %104
  %183 = phi %union.StackValue** [ %40, %81 ], [ %40, %79 ], [ %177, %176 ], [ %40, %104 ], [ %40, %98 ], [ %40, %89 ]
  %184 = phi %struct.TValue* [ %43, %81 ], [ %43, %79 ], [ %179, %176 ], [ %43, %104 ], [ %43, %98 ], [ %43, %89 ]
  %185 = getelementptr inbounds %struct.TValue, %struct.TValue* %184, i64 0, i32 1
  store i8 0, i8* %185, align 8, !tbaa !21
  %186 = load %union.StackValue*, %union.StackValue** %183, align 8, !tbaa !20
  %187 = getelementptr inbounds %union.StackValue, %union.StackValue* %186, i64 1
  store %union.StackValue* %187, %union.StackValue** %183, align 8, !tbaa !20
  br label %188

; <label>:188:                                    ; preds = %180, %106, %182, %25
  %189 = phi i32 [ 1, %25 ], [ 1, %182 ], [ %181, %180 ], [ 2, %106 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %7) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret i32 %189
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @match(%struct.MatchState*, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 4
  %5 = load i32, i32* %4, align 8, !tbaa !351
  %6 = add nsw i32 %5, -1
  store i32 %6, i32* %4, align 8, !tbaa !351
  %7 = icmp eq i32 %5, 0
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %3
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !349
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.545, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %14 = load i8*, i8** %13, align 8, !tbaa !354
  %15 = icmp eq i8* %14, %2
  br i1 %15, label %241, label %16

; <label>:16:                                     ; preds = %12
  %17 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 0
  %18 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %19 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %20 = bitcast i8** %19 to i64*
  br label %21

; <label>:21:                                     ; preds = %16, %236
  %22 = phi i8* [ %14, %16 ], [ %237, %236 ]
  %23 = phi i8* [ %1, %16 ], [ %239, %236 ]
  %24 = phi i8* [ %2, %16 ], [ %238, %236 ]
  %25 = getelementptr inbounds i8, i8* %23, i64 -1
  br label %29

; <label>:26:                                     ; preds = %143
  %27 = load i8*, i8** %13, align 8, !tbaa !354
  %28 = icmp eq i8* %132, %27
  br i1 %28, label %241, label %29

; <label>:29:                                     ; preds = %21, %26
  %30 = phi i8* [ %22, %21 ], [ %27, %26 ]
  %31 = phi i8* [ %24, %21 ], [ %132, %26 ]
  %32 = load i8, i8* %31, align 1, !tbaa !21
  %33 = sext i8 %32 to i32
  switch i32 %33, label %181 [
    i32 40, label %34
    i32 41, label %43
    i32 36, label %73
    i32 37, label %80
  ]

; <label>:34:                                     ; preds = %29
  %35 = getelementptr inbounds i8, i8* %31, i64 1
  %36 = load i8, i8* %35, align 1, !tbaa !21
  %37 = icmp eq i8 %36, 41
  br i1 %37, label %38, label %41

; <label>:38:                                     ; preds = %34
  %39 = getelementptr inbounds i8, i8* %31, i64 2
  %40 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %23, i8* nonnull %39, i32 -2) #16
  br label %241

; <label>:41:                                     ; preds = %34
  %42 = tail call fastcc i8* @start_capture(%struct.MatchState* nonnull %0, i8* %23, i8* nonnull %35, i32 -1) #16
  br label %241

; <label>:43:                                     ; preds = %29
  %44 = getelementptr inbounds i8, i8* %31, i64 1
  %45 = load i8, i8* %18, align 4, !tbaa !359
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %57, label %47

; <label>:47:                                     ; preds = %43
  %48 = zext i8 %45 to i64
  br label %51

; <label>:49:                                     ; preds = %51
  %50 = icmp sgt i64 %52, 1
  br i1 %50, label %51, label %57

; <label>:51:                                     ; preds = %49, %47
  %52 = phi i64 [ %48, %47 ], [ %53, %49 ]
  %53 = add nsw i64 %52, -1
  %54 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %53, i32 1
  %55 = load i64, i64* %54, align 8, !tbaa !364
  %56 = icmp eq i64 %55, -1
  br i1 %56, label %61, label %49

; <label>:57:                                     ; preds = %49, %43
  %58 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %59 = load %struct.lua_State*, %struct.lua_State** %58, align 8, !tbaa !349
  %60 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %59, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.548, i64 0, i64 0)) #17
  unreachable

; <label>:61:                                     ; preds = %51
  %62 = shl i64 %53, 32
  %63 = ashr exact i64 %62, 32
  %64 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %63
  %65 = bitcast %struct.anon.11* %64 to i64*
  %66 = load i64, i64* %65, align 8, !tbaa !366
  %67 = ptrtoint i8* %23 to i64
  %68 = sub i64 %67, %66
  %69 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %63, i32 1
  store i64 %68, i64* %69, align 8, !tbaa !364
  %70 = tail call fastcc i8* @match(%struct.MatchState* nonnull %0, i8* %23, i8* nonnull %44) #17
  %71 = icmp eq i8* %70, null
  br i1 %71, label %72, label %241

; <label>:72:                                     ; preds = %61
  store i64 -1, i64* %69, align 8, !tbaa !364
  br label %241

; <label>:73:                                     ; preds = %29
  %74 = getelementptr inbounds i8, i8* %31, i64 1
  %75 = icmp eq i8* %74, %30
  br i1 %75, label %76, label %181

; <label>:76:                                     ; preds = %73
  %77 = load i8*, i8** %19, align 8, !tbaa !353
  %78 = icmp eq i8* %23, %77
  %79 = select i1 %78, i8* %23, i8* null
  br label %241

; <label>:80:                                     ; preds = %29
  %81 = getelementptr inbounds i8, i8* %31, i64 1
  %82 = load i8, i8* %81, align 1, !tbaa !21
  %83 = sext i8 %82 to i32
  switch i32 %83, label %181 [
    i32 98, label %84
    i32 102, label %123
    i32 48, label %148
    i32 49, label %148
    i32 50, label %148
    i32 51, label %148
    i32 52, label %148
    i32 53, label %148
    i32 54, label %148
    i32 55, label %148
    i32 56, label %148
    i32 57, label %148
  ]

; <label>:84:                                     ; preds = %80
  %85 = getelementptr inbounds i8, i8* %31, i64 2
  %86 = getelementptr inbounds i8, i8* %30, i64 -1
  %87 = icmp ugt i8* %86, %85
  br i1 %87, label %92, label %88

; <label>:88:                                     ; preds = %84
  %89 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %90 = load %struct.lua_State*, %struct.lua_State** %89, align 8, !tbaa !349
  %91 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %90, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.549, i64 0, i64 0)) #17
  unreachable

; <label>:92:                                     ; preds = %84
  %93 = load i8, i8* %23, align 1, !tbaa !21
  %94 = load i8, i8* %85, align 1, !tbaa !21
  %95 = icmp eq i8 %93, %94
  br i1 %95, label %96, label %241

; <label>:96:                                     ; preds = %92
  %97 = getelementptr inbounds i8, i8* %31, i64 3
  %98 = load i8, i8* %97, align 1, !tbaa !21
  %99 = getelementptr inbounds i8, i8* %23, i64 1
  %100 = load i8*, i8** %19, align 8, !tbaa !353
  %101 = icmp ult i8* %99, %100
  br i1 %101, label %102, label %241

; <label>:102:                                    ; preds = %96
  br label %103

; <label>:103:                                    ; preds = %102, %116
  %104 = phi i8* [ %118, %116 ], [ %99, %102 ]
  %105 = phi i32 [ %117, %116 ], [ 1, %102 ]
  %106 = phi i8* [ %104, %116 ], [ %23, %102 ]
  %107 = load i8, i8* %104, align 1, !tbaa !21
  %108 = icmp eq i8 %107, %98
  br i1 %108, label %109, label %112

; <label>:109:                                    ; preds = %103
  %110 = add nsw i32 %105, -1
  %111 = icmp eq i32 %110, 0
  br i1 %111, label %120, label %116

; <label>:112:                                    ; preds = %103
  %113 = icmp eq i8 %107, %93
  %114 = zext i1 %113 to i32
  %115 = add nsw i32 %105, %114
  br label %116

; <label>:116:                                    ; preds = %112, %109
  %117 = phi i32 [ %110, %109 ], [ %115, %112 ]
  %118 = getelementptr inbounds i8, i8* %104, i64 1
  %119 = icmp ult i8* %118, %100
  br i1 %119, label %103, label %241

; <label>:120:                                    ; preds = %109
  %121 = getelementptr inbounds i8, i8* %106, i64 2
  %122 = getelementptr inbounds i8, i8* %31, i64 4
  br label %236

; <label>:123:                                    ; preds = %80
  %124 = getelementptr inbounds i8, i8* %31, i64 2
  %125 = load i8, i8* %124, align 1, !tbaa !21
  %126 = icmp eq i8 %125, 91
  br i1 %126, label %131, label %127

; <label>:127:                                    ; preds = %123
  %128 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %129 = load %struct.lua_State*, %struct.lua_State** %128, align 8, !tbaa !349
  %130 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %129, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.546, i64 0, i64 0)) #16
  unreachable

; <label>:131:                                    ; preds = %123
  %132 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %124) #16
  %133 = load i8*, i8** %17, align 8, !tbaa !352
  %134 = icmp eq i8* %23, %133
  br i1 %134, label %137, label %135

; <label>:135:                                    ; preds = %131
  %136 = load i8, i8* %25, align 1, !tbaa !21
  br label %137

; <label>:137:                                    ; preds = %131, %135
  %138 = phi i8 [ %136, %135 ], [ 0, %131 ]
  %139 = zext i8 %138 to i32
  %140 = getelementptr inbounds i8, i8* %132, i64 -1
  %141 = tail call fastcc i32 @matchbracketclass(i32 %139, i8* nonnull %124, i8* nonnull %140) #16
  %142 = icmp eq i32 %141, 0
  br i1 %142, label %143, label %241

; <label>:143:                                    ; preds = %137
  %144 = load i8, i8* %23, align 1, !tbaa !21
  %145 = zext i8 %144 to i32
  %146 = tail call fastcc i32 @matchbracketclass(i32 %145, i8* nonnull %124, i8* nonnull %140) #16
  %147 = icmp eq i32 %146, 0
  br i1 %147, label %241, label %26

; <label>:148:                                    ; preds = %80, %80, %80, %80, %80, %80, %80, %80, %80, %80
  %149 = zext i8 %82 to i32
  %150 = add nsw i32 %149, -49
  %151 = icmp ult i8 %82, 49
  br i1 %151, label %161, label %152

; <label>:152:                                    ; preds = %148
  %153 = load i8, i8* %18, align 4, !tbaa !359
  %154 = zext i8 %153 to i32
  %155 = icmp slt i32 %150, %154
  br i1 %155, label %156, label %161

; <label>:156:                                    ; preds = %152
  %157 = sext i32 %150 to i64
  %158 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %157, i32 1
  %159 = load i64, i64* %158, align 8, !tbaa !364
  %160 = icmp eq i64 %159, -1
  br i1 %160, label %161, label %166

; <label>:161:                                    ; preds = %156, %152, %148
  %162 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %163 = load %struct.lua_State*, %struct.lua_State** %162, align 8, !tbaa !349
  %164 = add nsw i32 %149, -48
  %165 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %163, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %164) #17
  unreachable

; <label>:166:                                    ; preds = %156
  %167 = load i64, i64* %20, align 8, !tbaa !353
  %168 = ptrtoint i8* %23 to i64
  %169 = sub i64 %167, %168
  %170 = icmp ult i64 %169, %159
  br i1 %170, label %241, label %171

; <label>:171:                                    ; preds = %166
  %172 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %157, i32 0
  %173 = load i8*, i8** %172, align 8, !tbaa !366
  %174 = tail call i32 @memcmp(i8* %173, i8* %23, i64 %159) #21
  %175 = icmp ne i32 %174, 0
  %176 = getelementptr inbounds i8, i8* %23, i64 %159
  %177 = icmp eq i8* %176, null
  %178 = or i1 %177, %175
  br i1 %178, label %241, label %179

; <label>:179:                                    ; preds = %171
  %180 = getelementptr inbounds i8, i8* %31, i64 2
  br label %236

; <label>:181:                                    ; preds = %29, %80, %73
  %182 = tail call fastcc i8* @classend(%struct.MatchState* %0, i8* nonnull %31) #16
  %183 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %23, i8* nonnull %31, i8* nonnull %182) #16
  %184 = icmp eq i32 %183, 0
  %185 = load i8, i8* %182, align 1, !tbaa !21
  br i1 %184, label %186, label %189

; <label>:186:                                    ; preds = %181
  switch i8 %185, label %241 [
    i8 42, label %187
    i8 63, label %187
    i8 45, label %187
  ]

; <label>:187:                                    ; preds = %186, %186, %186
  %188 = getelementptr inbounds i8, i8* %182, i64 1
  br label %232

; <label>:189:                                    ; preds = %181
  %190 = sext i8 %185 to i32
  switch i32 %190, label %230 [
    i32 63, label %191
    i32 43, label %196
    i32 42, label %198
    i32 45, label %217
  ]

; <label>:191:                                    ; preds = %189
  %192 = getelementptr inbounds i8, i8* %23, i64 1
  %193 = getelementptr inbounds i8, i8* %182, i64 1
  %194 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* nonnull %192, i8* nonnull %193) #16
  %195 = icmp eq i8* %194, null
  br i1 %195, label %232, label %241

; <label>:196:                                    ; preds = %189
  %197 = getelementptr inbounds i8, i8* %23, i64 1
  br label %198

; <label>:198:                                    ; preds = %189, %196
  %199 = phi i8* [ %197, %196 ], [ %23, %189 ]
  br label %200

; <label>:200:                                    ; preds = %200, %198
  %201 = phi i64 [ 0, %198 ], [ %205, %200 ]
  %202 = getelementptr inbounds i8, i8* %199, i64 %201
  %203 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %202, i8* %31, i8* nonnull %182) #17
  %204 = icmp eq i32 %203, 0
  %205 = add nuw nsw i64 %201, 1
  br i1 %204, label %206, label %200

; <label>:206:                                    ; preds = %200
  %207 = getelementptr inbounds i8, i8* %182, i64 1
  br label %210

; <label>:208:                                    ; preds = %210
  %209 = icmp sgt i64 %216, -1
  br i1 %209, label %210, label %241

; <label>:210:                                    ; preds = %206, %208
  %211 = phi i64 [ %201, %206 ], [ %216, %208 ]
  %212 = getelementptr inbounds i8, i8* %199, i64 %211
  %213 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %212, i8* nonnull %207) #17
  %214 = icmp eq i8* %213, null
  %215 = sext i1 %214 to i64
  %216 = add nsw i64 %211, %215
  br i1 %214, label %208, label %241

; <label>:217:                                    ; preds = %189
  %218 = getelementptr inbounds i8, i8* %182, i64 1
  %219 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* %23, i8* nonnull %218) #17
  %220 = icmp eq i8* %219, null
  br i1 %220, label %221, label %241

; <label>:221:                                    ; preds = %217
  br label %225

; <label>:222:                                    ; preds = %225
  %223 = tail call fastcc i8* @match(%struct.MatchState* %0, i8* nonnull %229, i8* nonnull %218) #17
  %224 = icmp eq i8* %223, null
  br i1 %224, label %225, label %241

; <label>:225:                                    ; preds = %221, %222
  %226 = phi i8* [ %229, %222 ], [ %23, %221 ]
  %227 = tail call fastcc i32 @singlematch(%struct.MatchState* %0, i8* %226, i8* %31, i8* nonnull %182) #17
  %228 = icmp eq i32 %227, 0
  %229 = getelementptr inbounds i8, i8* %226, i64 1
  br i1 %228, label %241, label %222

; <label>:230:                                    ; preds = %189
  %231 = getelementptr inbounds i8, i8* %23, i64 1
  br label %232

; <label>:232:                                    ; preds = %230, %191, %187
  %233 = phi i8* [ %188, %187 ], [ %193, %191 ], [ %182, %230 ]
  %234 = phi i8* [ %23, %187 ], [ %23, %191 ], [ %231, %230 ]
  %235 = load i8*, i8** %13, align 8, !tbaa !354
  br label %236

; <label>:236:                                    ; preds = %232, %179, %120
  %237 = phi i8* [ %30, %120 ], [ %30, %179 ], [ %235, %232 ]
  %238 = phi i8* [ %122, %120 ], [ %180, %179 ], [ %233, %232 ]
  %239 = phi i8* [ %121, %120 ], [ %176, %179 ], [ %234, %232 ]
  %240 = icmp eq i8* %238, %237
  br i1 %240, label %241, label %21

; <label>:241:                                    ; preds = %236, %171, %166, %96, %92, %186, %191, %26, %143, %137, %116, %225, %222, %210, %208, %217, %12, %72, %61, %76, %41, %38
  %242 = phi i8* [ %79, %76 ], [ %40, %38 ], [ %42, %41 ], [ %70, %61 ], [ null, %72 ], [ %1, %12 ], [ %219, %217 ], [ %213, %210 ], [ null, %208 ], [ null, %225 ], [ %223, %222 ], [ null, %116 ], [ null, %137 ], [ null, %143 ], [ %23, %26 ], [ null, %186 ], [ %194, %191 ], [ %239, %236 ], [ null, %92 ], [ null, %96 ], [ null, %171 ], [ null, %166 ]
  %243 = load i32, i32* %4, align 8, !tbaa !351
  %244 = add nsw i32 %243, 1
  store i32 %244, i32* %4, align 8, !tbaa !351
  ret i8* %242
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @push_captures(%struct.MatchState* nocapture readonly, i8*, i8*) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %5 = load i8, i8* %4, align 4, !tbaa !359
  %6 = icmp eq i8 %5, 0
  %7 = icmp ne i8* %1, null
  %8 = and i1 %7, %6
  %9 = zext i8 %5 to i32
  %10 = select i1 %8, i32 1, i32 %9
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !349
  tail call void @luaL_checkstack(%struct.lua_State* %12, i32 %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0)) #16
  %13 = icmp eq i32 %10, 0
  br i1 %13, label %19, label %14

; <label>:14:                                     ; preds = %3
  br label %15

; <label>:15:                                     ; preds = %14, %15
  %16 = phi i32 [ %17, %15 ], [ 0, %14 ]
  tail call fastcc void @push_onecapture(%struct.MatchState* %0, i32 %16, i8* %1, i8* %2) #16
  %17 = add nuw nsw i32 %16, 1
  %18 = icmp eq i32 %17, %10
  br i1 %18, label %19, label %15

; <label>:19:                                     ; preds = %15, %3
  ret i32 %10
}

; Function Attrs: nounwind optsize readonly
declare i8* @memchr(i8*, i32, i64) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc i8* @start_capture(%struct.MatchState*, i8*, i8*, i32) unnamed_addr #0 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %6 = load i8, i8* %5, align 4, !tbaa !359
  %7 = icmp ugt i8 %6, 31
  br i1 %7, label %8, label %12

; <label>:8:                                      ; preds = %4
  %9 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %10 = load %struct.lua_State*, %struct.lua_State** %9, align 8, !tbaa !349
  %11 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %10, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.547, i64 0, i64 0)) #16
  unreachable

; <label>:12:                                     ; preds = %4
  %13 = zext i8 %6 to i64
  %14 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 0
  store i8* %1, i8** %14, align 8, !tbaa !366
  %15 = sext i32 %3 to i64
  %16 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %13, i32 1
  store i64 %15, i64* %16, align 8, !tbaa !364
  %17 = add i8 %6, 1
  store i8 %17, i8* %5, align 4, !tbaa !359
  %18 = tail call fastcc i8* @match(%struct.MatchState* nonnull %0, i8* %1, i8* %2) #16
  %19 = icmp eq i8* %18, null
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %12
  %21 = load i8, i8* %5, align 4, !tbaa !359
  %22 = add i8 %21, -1
  store i8 %22, i8* %5, align 4, !tbaa !359
  br label %23

; <label>:23:                                     ; preds = %20, %12
  ret i8* %18
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc nonnull i8* @classend(%struct.MatchState* nocapture readonly, i8* readonly) unnamed_addr #0 {
  %3 = getelementptr inbounds i8, i8* %1, i64 1
  %4 = load i8, i8* %1, align 1, !tbaa !21
  %5 = sext i8 %4 to i32
  switch i32 %5, label %42 [
    i32 37, label %6
    i32 91, label %16
  ]

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %8 = load i8*, i8** %7, align 8, !tbaa !354
  %9 = icmp eq i8* %3, %8
  br i1 %9, label %10, label %14

; <label>:10:                                     ; preds = %6
  %11 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %12 = load %struct.lua_State*, %struct.lua_State** %11, align 8, !tbaa !349
  %13 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %12, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.550, i64 0, i64 0)) #16
  unreachable

; <label>:14:                                     ; preds = %6
  %15 = getelementptr inbounds i8, i8* %1, i64 2
  br label %42

; <label>:16:                                     ; preds = %2
  %17 = load i8, i8* %3, align 1, !tbaa !21
  %18 = icmp eq i8 %17, 94
  %19 = getelementptr inbounds i8, i8* %1, i64 2
  %20 = select i1 %18, i8* %19, i8* %3
  %21 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 2
  %22 = load i8*, i8** %21, align 8, !tbaa !354
  br label %23

; <label>:23:                                     ; preds = %30, %16
  %24 = phi i8* [ %20, %16 ], [ %37, %30 ]
  %25 = icmp eq i8* %24, %22
  br i1 %25, label %26, label %30

; <label>:26:                                     ; preds = %23
  %27 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %28 = load %struct.lua_State*, %struct.lua_State** %27, align 8, !tbaa !349
  %29 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %28, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.551, i64 0, i64 0)) #16
  unreachable

; <label>:30:                                     ; preds = %23
  %31 = getelementptr inbounds i8, i8* %24, i64 1
  %32 = load i8, i8* %24, align 1, !tbaa !21
  %33 = icmp eq i8 %32, 37
  %34 = icmp ult i8* %31, %22
  %35 = getelementptr inbounds i8, i8* %24, i64 2
  %36 = and i1 %34, %33
  %37 = select i1 %36, i8* %35, i8* %31
  %38 = load i8, i8* %37, align 1, !tbaa !21
  %39 = icmp eq i8 %38, 93
  br i1 %39, label %40, label %23

; <label>:40:                                     ; preds = %30
  %41 = getelementptr inbounds i8, i8* %37, i64 1
  br label %42

; <label>:42:                                     ; preds = %2, %40, %14
  %43 = phi i8* [ %41, %40 ], [ %15, %14 ], [ %3, %2 ]
  ret i8* %43
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @matchbracketclass(i32, i8* readonly, i8* readnone) unnamed_addr #12 {
  %4 = getelementptr inbounds i8, i8* %1, i64 1
  %5 = load i8, i8* %4, align 1, !tbaa !21
  %6 = icmp eq i8 %5, 94
  %7 = select i1 %6, i8* %4, i8* %1
  %8 = xor i1 %6, true
  %9 = zext i1 %8 to i32
  %10 = getelementptr inbounds i8, i8* %7, i64 1
  %11 = icmp ult i8* %10, %2
  br i1 %11, label %12, label %43

; <label>:12:                                     ; preds = %3
  br label %13

; <label>:13:                                     ; preds = %12, %39
  %14 = phi i8* [ %41, %39 ], [ %10, %12 ]
  %15 = phi i8* [ %40, %39 ], [ %7, %12 ]
  %16 = load i8, i8* %14, align 1, !tbaa !21
  %17 = icmp eq i8 %16, 37
  %18 = getelementptr inbounds i8, i8* %15, i64 2
  %19 = load i8, i8* %18, align 1, !tbaa !21
  br i1 %17, label %20, label %24

; <label>:20:                                     ; preds = %13
  %21 = zext i8 %19 to i32
  %22 = tail call fastcc i32 @match_class(i32 %0, i32 %21) #16
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %39, label %45

; <label>:24:                                     ; preds = %13
  %25 = icmp eq i8 %19, 45
  br i1 %25, label %26, label %36

; <label>:26:                                     ; preds = %24
  %27 = getelementptr inbounds i8, i8* %15, i64 3
  %28 = icmp ult i8* %27, %2
  br i1 %28, label %29, label %36

; <label>:29:                                     ; preds = %26
  %30 = zext i8 %16 to i32
  %31 = icmp sgt i32 %30, %0
  br i1 %31, label %39, label %32

; <label>:32:                                     ; preds = %29
  %33 = load i8, i8* %27, align 1, !tbaa !21
  %34 = zext i8 %33 to i32
  %35 = icmp slt i32 %34, %0
  br i1 %35, label %39, label %45

; <label>:36:                                     ; preds = %26, %24
  %37 = zext i8 %16 to i32
  %38 = icmp eq i32 %37, %0
  br i1 %38, label %45, label %39

; <label>:39:                                     ; preds = %20, %32, %29, %36
  %40 = phi i8* [ %18, %20 ], [ %27, %32 ], [ %27, %29 ], [ %14, %36 ]
  %41 = getelementptr inbounds i8, i8* %40, i64 1
  %42 = icmp ult i8* %41, %2
  br i1 %42, label %13, label %43

; <label>:43:                                     ; preds = %39, %3
  %44 = xor i32 %9, 1
  br label %45

; <label>:45:                                     ; preds = %36, %32, %20, %43
  %46 = phi i32 [ %44, %43 ], [ %9, %20 ], [ %9, %32 ], [ %9, %36 ]
  ret i32 %46
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @singlematch(%struct.MatchState* nocapture readonly, i8* readonly, i8* readonly, i8* readnone) unnamed_addr #12 {
  %5 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 1
  %6 = load i8*, i8** %5, align 8, !tbaa !353
  %7 = icmp ugt i8* %6, %1
  br i1 %7, label %8, label %24

; <label>:8:                                      ; preds = %4
  %9 = load i8, i8* %1, align 1, !tbaa !21
  %10 = zext i8 %9 to i32
  %11 = load i8, i8* %2, align 1, !tbaa !21
  %12 = sext i8 %11 to i32
  switch i32 %12, label %21 [
    i32 46, label %24
    i32 37, label %13
    i32 91, label %18
  ]

; <label>:13:                                     ; preds = %8
  %14 = getelementptr inbounds i8, i8* %2, i64 1
  %15 = load i8, i8* %14, align 1, !tbaa !21
  %16 = zext i8 %15 to i32
  %17 = tail call fastcc i32 @match_class(i32 %10, i32 %16) #16
  br label %24

; <label>:18:                                     ; preds = %8
  %19 = getelementptr inbounds i8, i8* %3, i64 -1
  %20 = tail call fastcc i32 @matchbracketclass(i32 %10, i8* nonnull %2, i8* nonnull %19) #16
  br label %24

; <label>:21:                                     ; preds = %8
  %22 = icmp eq i8 %11, %9
  %23 = zext i1 %22 to i32
  br label %24

; <label>:24:                                     ; preds = %13, %18, %21, %8, %4
  %25 = phi i32 [ 0, %4 ], [ %23, %21 ], [ %20, %18 ], [ %17, %13 ], [ 1, %8 ]
  ret i32 %25
}

; Function Attrs: nounwind optsize readonly uwtable
define internal fastcc i32 @match_class(i32, i32) unnamed_addr #12 {
  %3 = tail call i32 @tolower(i32 %1) #21
  switch i32 %3, label %88 [
    i32 97, label %4
    i32 99, label %12
    i32 100, label %20
    i32 103, label %28
    i32 108, label %36
    i32 112, label %44
    i32 115, label %52
    i32 117, label %60
    i32 119, label %68
    i32 120, label %76
    i32 122, label %84
  ]

; <label>:4:                                      ; preds = %2
  %5 = tail call i16** @__ctype_b_loc() #22
  %6 = load i16*, i16** %5, align 8, !tbaa !54
  %7 = sext i32 %0 to i64
  %8 = getelementptr inbounds i16, i16* %6, i64 %7
  %9 = load i16, i16* %8, align 2, !tbaa !324
  %10 = and i16 %9, 1024
  %11 = zext i16 %10 to i32
  br label %91

; <label>:12:                                     ; preds = %2
  %13 = tail call i16** @__ctype_b_loc() #22
  %14 = load i16*, i16** %13, align 8, !tbaa !54
  %15 = sext i32 %0 to i64
  %16 = getelementptr inbounds i16, i16* %14, i64 %15
  %17 = load i16, i16* %16, align 2, !tbaa !324
  %18 = and i16 %17, 2
  %19 = zext i16 %18 to i32
  br label %91

; <label>:20:                                     ; preds = %2
  %21 = tail call i16** @__ctype_b_loc() #22
  %22 = load i16*, i16** %21, align 8, !tbaa !54
  %23 = sext i32 %0 to i64
  %24 = getelementptr inbounds i16, i16* %22, i64 %23
  %25 = load i16, i16* %24, align 2, !tbaa !324
  %26 = and i16 %25, 2048
  %27 = zext i16 %26 to i32
  br label %91

; <label>:28:                                     ; preds = %2
  %29 = tail call i16** @__ctype_b_loc() #22
  %30 = load i16*, i16** %29, align 8, !tbaa !54
  %31 = sext i32 %0 to i64
  %32 = getelementptr inbounds i16, i16* %30, i64 %31
  %33 = load i16, i16* %32, align 2, !tbaa !324
  %34 = and i16 %33, -32768
  %35 = zext i16 %34 to i32
  br label %91

; <label>:36:                                     ; preds = %2
  %37 = tail call i16** @__ctype_b_loc() #22
  %38 = load i16*, i16** %37, align 8, !tbaa !54
  %39 = sext i32 %0 to i64
  %40 = getelementptr inbounds i16, i16* %38, i64 %39
  %41 = load i16, i16* %40, align 2, !tbaa !324
  %42 = and i16 %41, 512
  %43 = zext i16 %42 to i32
  br label %91

; <label>:44:                                     ; preds = %2
  %45 = tail call i16** @__ctype_b_loc() #22
  %46 = load i16*, i16** %45, align 8, !tbaa !54
  %47 = sext i32 %0 to i64
  %48 = getelementptr inbounds i16, i16* %46, i64 %47
  %49 = load i16, i16* %48, align 2, !tbaa !324
  %50 = and i16 %49, 4
  %51 = zext i16 %50 to i32
  br label %91

; <label>:52:                                     ; preds = %2
  %53 = tail call i16** @__ctype_b_loc() #22
  %54 = load i16*, i16** %53, align 8, !tbaa !54
  %55 = sext i32 %0 to i64
  %56 = getelementptr inbounds i16, i16* %54, i64 %55
  %57 = load i16, i16* %56, align 2, !tbaa !324
  %58 = and i16 %57, 8192
  %59 = zext i16 %58 to i32
  br label %91

; <label>:60:                                     ; preds = %2
  %61 = tail call i16** @__ctype_b_loc() #22
  %62 = load i16*, i16** %61, align 8, !tbaa !54
  %63 = sext i32 %0 to i64
  %64 = getelementptr inbounds i16, i16* %62, i64 %63
  %65 = load i16, i16* %64, align 2, !tbaa !324
  %66 = and i16 %65, 256
  %67 = zext i16 %66 to i32
  br label %91

; <label>:68:                                     ; preds = %2
  %69 = tail call i16** @__ctype_b_loc() #22
  %70 = load i16*, i16** %69, align 8, !tbaa !54
  %71 = sext i32 %0 to i64
  %72 = getelementptr inbounds i16, i16* %70, i64 %71
  %73 = load i16, i16* %72, align 2, !tbaa !324
  %74 = and i16 %73, 8
  %75 = zext i16 %74 to i32
  br label %91

; <label>:76:                                     ; preds = %2
  %77 = tail call i16** @__ctype_b_loc() #22
  %78 = load i16*, i16** %77, align 8, !tbaa !54
  %79 = sext i32 %0 to i64
  %80 = getelementptr inbounds i16, i16* %78, i64 %79
  %81 = load i16, i16* %80, align 2, !tbaa !324
  %82 = and i16 %81, 4096
  %83 = zext i16 %82 to i32
  br label %91

; <label>:84:                                     ; preds = %2
  %85 = icmp eq i32 %0, 0
  %86 = zext i1 %85 to i32
  %87 = tail call i16** @__ctype_b_loc() #22
  br label %91

; <label>:88:                                     ; preds = %2
  %89 = icmp eq i32 %1, %0
  %90 = zext i1 %89 to i32
  br label %103

; <label>:91:                                     ; preds = %84, %76, %68, %60, %52, %44, %36, %28, %20, %12, %4
  %92 = phi i16** [ %87, %84 ], [ %77, %76 ], [ %69, %68 ], [ %61, %60 ], [ %53, %52 ], [ %45, %44 ], [ %37, %36 ], [ %29, %28 ], [ %21, %20 ], [ %13, %12 ], [ %5, %4 ]
  %93 = phi i32 [ %86, %84 ], [ %83, %76 ], [ %75, %68 ], [ %67, %60 ], [ %59, %52 ], [ %51, %44 ], [ %43, %36 ], [ %35, %28 ], [ %27, %20 ], [ %19, %12 ], [ %11, %4 ]
  %94 = load i16*, i16** %92, align 8, !tbaa !54
  %95 = sext i32 %1 to i64
  %96 = getelementptr inbounds i16, i16* %94, i64 %95
  %97 = load i16, i16* %96, align 2, !tbaa !324
  %98 = and i16 %97, 512
  %99 = icmp eq i16 %98, 0
  %100 = icmp eq i32 %93, 0
  %101 = zext i1 %100 to i32
  %102 = select i1 %99, i32 %101, i32 %93
  br label %103

; <label>:103:                                    ; preds = %91, %88
  %104 = phi i32 [ %90, %88 ], [ %102, %91 ]
  ret i32 %104
}

; Function Attrs: nounwind optsize readonly
declare i32 @tolower(i32) local_unnamed_addr #4

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @push_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*) unnamed_addr #0 {
  %5 = alloca i8*, align 8
  %6 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call fastcc i64 @get_onecapture(%struct.MatchState* %0, i32 %1, i8* %2, i8* %3, i8** nonnull %5) #16
  %8 = icmp eq i64 %7, -2
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %11 = load %struct.lua_State*, %struct.lua_State** %10, align 8, !tbaa !349
  %12 = load i8*, i8** %5, align 8, !tbaa !54
  %13 = tail call i8* @lua_pushlstring(%struct.lua_State* %11, i8* %12, i64 %7) #16
  br label %14

; <label>:14:                                     ; preds = %4, %9
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @get_onecapture(%struct.MatchState* nocapture readonly, i32, i8*, i8*, i8** nocapture) unnamed_addr #0 {
  %6 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 5
  %7 = load i8, i8* %6, align 4, !tbaa !359
  %8 = zext i8 %7 to i32
  %9 = icmp sgt i32 %8, %1
  br i1 %9, label %21, label %10

; <label>:10:                                     ; preds = %5
  %11 = icmp eq i32 %1, 0
  br i1 %11, label %17, label %12

; <label>:12:                                     ; preds = %10
  %13 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %14 = load %struct.lua_State*, %struct.lua_State** %13, align 8, !tbaa !349
  %15 = add nsw i32 %1, 1
  %16 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %14, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.552, i64 0, i64 0), i32 %15) #16
  unreachable

; <label>:17:                                     ; preds = %10
  store i8* %2, i8** %4, align 8, !tbaa !54
  %18 = ptrtoint i8* %3 to i64
  %19 = ptrtoint i8* %2 to i64
  %20 = sub i64 %18, %19
  br label %48

; <label>:21:                                     ; preds = %5
  %22 = sext i32 %1 to i64
  %23 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 1
  %24 = load i64, i64* %23, align 8, !tbaa !364
  %25 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 6, i64 %22, i32 0
  %26 = bitcast i8** %25 to i64*
  %27 = load i64, i64* %26, align 8, !tbaa !366
  %28 = bitcast i8** %4 to i64*
  store i64 %27, i64* %28, align 8, !tbaa !54
  switch i64 %24, label %48 [
    i64 -1, label %29
    i64 -2, label %33
  ]

; <label>:29:                                     ; preds = %21
  %30 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !349
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.553, i64 0, i64 0)) #16
  unreachable

; <label>:33:                                     ; preds = %21
  %34 = getelementptr inbounds %struct.MatchState, %struct.MatchState* %0, i64 0, i32 3
  %35 = load %struct.lua_State*, %struct.lua_State** %34, align 8, !tbaa !349
  %36 = load i64, i64* %26, align 8, !tbaa !366
  %37 = bitcast %struct.MatchState* %0 to i64*
  %38 = load i64, i64* %37, align 8, !tbaa !352
  %39 = add i64 %36, 1
  %40 = sub i64 %39, %38
  %41 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %35, i64 0, i32 6
  %42 = bitcast %union.StackValue** %41 to %struct.TValue**
  %43 = load %struct.TValue*, %struct.TValue** %42, align 8, !tbaa !20
  %44 = bitcast %struct.TValue* %43 to i64*
  store i64 %40, i64* %44, align 8, !tbaa !21
  %45 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 0, i32 1
  store i8 35, i8* %45, align 8, !tbaa !22
  %46 = load %union.StackValue*, %union.StackValue** %41, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 1
  store %union.StackValue* %47, %union.StackValue** %41, align 8, !tbaa !20
  br label %48

; <label>:48:                                     ; preds = %33, %21, %17
  %49 = phi i64 [ %20, %17 ], [ %24, %21 ], [ -2, %33 ]
  ret i64 %49
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @addlenmod(i8*, i8* nocapture readonly) unnamed_addr #0 {
  %3 = tail call i64 @strlen(i8* %0) #21
  %4 = tail call i64 @strlen(i8* %1) #21
  %5 = add i64 %3, -1
  %6 = getelementptr inbounds i8, i8* %0, i64 %5
  %7 = load i8, i8* %6, align 1, !tbaa !21
  %8 = getelementptr inbounds i8, i8* %0, i64 %3
  %9 = getelementptr inbounds i8, i8* %8, i64 -1
  %10 = tail call i8* @strcpy(i8* nonnull %9, i8* %1) #17
  %11 = add i64 %4, %3
  %12 = add i64 %11, -1
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  store i8 %7, i8* %13, align 1, !tbaa !21
  %14 = getelementptr inbounds i8, i8* %0, i64 %11
  store i8 0, i8* %14, align 1, !tbaa !21
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @gmatch_aux(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_touserdata(%struct.lua_State* %0, i32 -1001003) #16
  %3 = getelementptr inbounds i8, i8* %2, i64 24
  %4 = bitcast i8* %3 to %struct.MatchState*
  %5 = getelementptr inbounds i8, i8* %2, i64 48
  %6 = bitcast i8* %5 to %struct.lua_State**
  store %struct.lua_State* %0, %struct.lua_State** %6, align 8, !tbaa !367
  %7 = bitcast i8* %2 to i8**
  %8 = load i8*, i8** %7, align 8, !tbaa !355
  %9 = getelementptr inbounds i8, i8* %2, i64 32
  %10 = bitcast i8* %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !368
  %12 = icmp ugt i8* %8, %11
  br i1 %12, label %33, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds i8, i8* %2, i64 60
  %15 = getelementptr inbounds i8, i8* %2, i64 8
  %16 = bitcast i8* %15 to i8**
  %17 = getelementptr inbounds i8, i8* %2, i64 16
  %18 = bitcast i8* %17 to i8**
  br label %19

; <label>:19:                                     ; preds = %13, %29
  %20 = phi i8* [ %8, %13 ], [ %30, %29 ]
  store i8 0, i8* %14, align 4, !tbaa !359
  %21 = load i8*, i8** %16, align 8, !tbaa !357
  %22 = tail call fastcc i8* @match(%struct.MatchState* nonnull %4, i8* %20, i8* %21) #16
  %23 = icmp eq i8* %22, null
  br i1 %23, label %29, label %24

; <label>:24:                                     ; preds = %19
  %25 = load i8*, i8** %18, align 8, !tbaa !358
  %26 = icmp eq i8* %22, %25
  br i1 %26, label %29, label %27

; <label>:27:                                     ; preds = %24
  store i8* %22, i8** %18, align 8, !tbaa !358
  store i8* %22, i8** %7, align 8, !tbaa !355
  %28 = tail call fastcc i32 @push_captures(%struct.MatchState* nonnull %4, i8* %20, i8* nonnull %22) #16
  br label %33

; <label>:29:                                     ; preds = %24, %19
  %30 = getelementptr inbounds i8, i8* %20, i64 1
  %31 = load i8*, i8** %10, align 8, !tbaa !368
  %32 = icmp ugt i8* %30, %31
  br i1 %32, label %33, label %19

; <label>:33:                                     ; preds = %29, %1, %27
  %34 = phi i32 [ %28, %27 ], [ 0, %1 ], [ 0, %29 ]
  ret i32 %34
}

; Function Attrs: nounwind optsize readnone
declare i32** @__ctype_tolower_loc() local_unnamed_addr #8

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @getdetails(%struct.Header* nocapture, i64, i8** nocapture, i32* nocapture, i32* nocapture) unnamed_addr #0 {
  %6 = alloca i32, align 4
  %7 = tail call fastcc i32 @getoption(%struct.Header* %0, i8** %2, i32* %3) #16
  %8 = bitcast i32* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %8) #7
  %9 = load i32, i32* %3, align 4, !tbaa !77
  store i32 %9, i32* %6, align 4, !tbaa !77
  %10 = icmp eq i32 %7, 7
  br i1 %10, label %11, label %26

; <label>:11:                                     ; preds = %5
  %12 = load i8*, i8** %2, align 8, !tbaa !54
  %13 = load i8, i8* %12, align 1, !tbaa !21
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %21, label %15

; <label>:15:                                     ; preds = %11
  %16 = call fastcc i32 @getoption(%struct.Header* %0, i8** nonnull %2, i32* nonnull %6) #16
  %17 = icmp eq i32 %16, 3
  %18 = load i32, i32* %6, align 4
  %19 = icmp eq i32 %18, 0
  %20 = or i1 %17, %19
  br i1 %20, label %21, label %26

; <label>:21:                                     ; preds = %15, %11
  %22 = phi i32 [ %18, %15 ], [ %9, %11 ]
  %23 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %24 = load %struct.lua_State*, %struct.lua_State** %23, align 8, !tbaa !360
  %25 = tail call i32 @luaL_argerror(%struct.lua_State* %24, i32 1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.576, i64 0, i64 0)) #16
  br label %26

; <label>:26:                                     ; preds = %21, %15, %5
  %27 = phi i32 [ %22, %21 ], [ %18, %15 ], [ %9, %5 ]
  %28 = icmp slt i32 %27, 2
  %29 = icmp eq i32 %7, 3
  %30 = or i1 %29, %28
  br i1 %30, label %50, label %31

; <label>:31:                                     ; preds = %26
  %32 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  %33 = load i32, i32* %32, align 4, !tbaa !363
  %34 = icmp sgt i32 %27, %33
  br i1 %34, label %35, label %36

; <label>:35:                                     ; preds = %31
  store i32 %33, i32* %6, align 4, !tbaa !77
  br label %36

; <label>:36:                                     ; preds = %35, %31
  %37 = phi i32 [ %33, %35 ], [ %27, %31 ]
  %38 = add nsw i32 %37, -1
  %39 = and i32 %38, %37
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %45, label %41

; <label>:41:                                     ; preds = %36
  %42 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %43 = load %struct.lua_State*, %struct.lua_State** %42, align 8, !tbaa !360
  %44 = tail call i32 @luaL_argerror(%struct.lua_State* %43, i32 1, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.577, i64 0, i64 0)) #16
  br label %45

; <label>:45:                                     ; preds = %36, %41
  %46 = trunc i64 %1 to i32
  %47 = and i32 %38, %46
  %48 = sub nsw i32 %37, %47
  %49 = and i32 %48, %38
  br label %50

; <label>:50:                                     ; preds = %26, %45
  %51 = phi i32 [ %49, %45 ], [ 0, %26 ]
  store i32 %51, i32* %4, align 4, !tbaa !77
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %8) #7
  ret i32 %7
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @packint(%struct.luaL_Buffer*, i64, i32, i32, i32) unnamed_addr #0 {
  %6 = sext i32 %3 to i64
  %7 = tail call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* %0, i64 %6, i32 -1) #17
  %8 = trunc i64 %1 to i8
  %9 = icmp ne i32 %2, 0
  %10 = add nsw i32 %3, -1
  %11 = sext i32 %10 to i64
  %12 = select i1 %9, i64 0, i64 %11
  %13 = getelementptr inbounds i8, i8* %7, i64 %12
  store i8 %8, i8* %13, align 1, !tbaa !21
  %14 = icmp sgt i32 %3, 1
  br i1 %14, label %15, label %40

; <label>:15:                                     ; preds = %5
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi i32 [ %25, %16 ], [ 1, %15 ]
  %18 = phi i64 [ %19, %16 ], [ %1, %15 ]
  %19 = lshr i64 %18, 8
  %20 = trunc i64 %19 to i8
  %21 = sub nsw i32 %10, %17
  %22 = select i1 %9, i32 %17, i32 %21
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i8, i8* %7, i64 %23
  store i8 %20, i8* %24, align 1, !tbaa !21
  %25 = add nuw nsw i32 %17, 1
  %26 = icmp eq i32 %25, %3
  br i1 %26, label %27, label %16

; <label>:27:                                     ; preds = %16
  %28 = icmp ne i32 %4, 0
  %29 = icmp sgt i32 %3, 8
  %30 = and i1 %29, %28
  br i1 %30, label %31, label %40

; <label>:31:                                     ; preds = %27
  br label %32

; <label>:32:                                     ; preds = %31, %32
  %33 = phi i32 [ %38, %32 ], [ 8, %31 ]
  %34 = sub nsw i32 %10, %33
  %35 = select i1 %9, i32 %33, i32 %34
  %36 = sext i32 %35 to i64
  %37 = getelementptr inbounds i8, i8* %7, i64 %36
  store i8 -1, i8* %37, align 1, !tbaa !21
  %38 = add nuw nsw i32 %33, 1
  %39 = icmp eq i32 %38, %3
  br i1 %39, label %40, label %32

; <label>:40:                                     ; preds = %32, %5, %27
  %41 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %0, i64 0, i32 2
  %42 = load i64, i64* %41, align 8, !tbaa !205
  %43 = add i64 %42, %6
  store i64 %43, i64* %41, align 8, !tbaa !205
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @getoption(%struct.Header* nocapture, i8** nocapture, i32* nocapture) unnamed_addr #0 {
  %4 = load i8*, i8** %1, align 8, !tbaa !54
  %5 = getelementptr inbounds i8, i8* %4, i64 1
  store i8* %5, i8** %1, align 8, !tbaa !54
  %6 = load i8, i8* %4, align 1, !tbaa !21
  %7 = sext i8 %6 to i32
  store i32 0, i32* %2, align 4, !tbaa !77
  switch i32 %7, label %65 [
    i32 98, label %8
    i32 66, label %9
    i32 104, label %10
    i32 72, label %11
    i32 108, label %12
    i32 76, label %13
    i32 106, label %14
    i32 74, label %15
    i32 84, label %16
    i32 102, label %17
    i32 100, label %18
    i32 110, label %19
    i32 105, label %20
    i32 73, label %22
    i32 115, label %24
    i32 99, label %26
    i32 122, label %70
    i32 120, label %54
    i32 88, label %55
    i32 32, label %69
    i32 60, label %56
    i32 62, label %58
    i32 61, label %60
    i32 33, label %62
  ]

; <label>:8:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:9:                                      ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:10:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:11:                                     ; preds = %3
  store i32 2, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:12:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:13:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:14:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:15:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:16:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:17:                                     ; preds = %3
  store i32 4, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:18:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:19:                                     ; preds = %3
  store i32 8, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:20:                                     ; preds = %3
  %21 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4) #16
  store i32 %21, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:22:                                     ; preds = %3
  %23 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 4) #16
  store i32 %23, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:24:                                     ; preds = %3
  %25 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8) #16
  store i32 %25, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:26:                                     ; preds = %3
  %27 = load i8, i8* %5, align 1, !tbaa !21
  %28 = sext i8 %27 to i32
  %29 = add nsw i32 %28, -48
  %30 = icmp ugt i32 %29, 9
  br i1 %30, label %32, label %31

; <label>:31:                                     ; preds = %26
  br label %33

; <label>:32:                                     ; preds = %26
  store i32 -1, i32* %2, align 4, !tbaa !77
  br label %50

; <label>:33:                                     ; preds = %31, %33
  %34 = phi i8* [ %37, %33 ], [ %5, %31 ]
  %35 = phi i32 [ %41, %33 ], [ 0, %31 ]
  %36 = mul nsw i32 %35, 10
  %37 = getelementptr inbounds i8, i8* %34, i64 1
  store i8* %37, i8** %1, align 8, !tbaa !54
  %38 = load i8, i8* %34, align 1, !tbaa !21
  %39 = sext i8 %38 to i32
  %40 = add i32 %36, -48
  %41 = add i32 %40, %39
  %42 = load i8, i8* %37, align 1, !tbaa !21
  %43 = sext i8 %42 to i32
  %44 = add nsw i32 %43, -48
  %45 = icmp ult i32 %44, 10
  %46 = icmp slt i32 %41, 214748364
  %47 = and i1 %46, %45
  br i1 %47, label %33, label %48

; <label>:48:                                     ; preds = %33
  store i32 %41, i32* %2, align 4, !tbaa !77
  %49 = icmp eq i32 %41, -1
  br i1 %49, label %50, label %70

; <label>:50:                                     ; preds = %32, %48
  %51 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %52 = load %struct.lua_State*, %struct.lua_State** %51, align 8, !tbaa !360
  %53 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %52, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.578, i64 0, i64 0)) #16
  unreachable

; <label>:54:                                     ; preds = %3
  store i32 1, i32* %2, align 4, !tbaa !77
  br label %70

; <label>:55:                                     ; preds = %3
  br label %70

; <label>:56:                                     ; preds = %3
  %57 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %57, align 8, !tbaa !362
  br label %69

; <label>:58:                                     ; preds = %3
  %59 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 0, i32* %59, align 8, !tbaa !362
  br label %69

; <label>:60:                                     ; preds = %3
  %61 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 1
  store i32 1, i32* %61, align 8, !tbaa !362
  br label %69

; <label>:62:                                     ; preds = %3
  %63 = tail call fastcc i32 @getnumlimit(%struct.Header* %0, i8** nonnull %1, i32 8) #16
  %64 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 2
  store i32 %63, i32* %64, align 4, !tbaa !363
  br label %69

; <label>:65:                                     ; preds = %3
  %66 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %67 = load %struct.lua_State*, %struct.lua_State** %66, align 8, !tbaa !360
  %68 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %67, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.579, i64 0, i64 0), i32 %7) #16
  unreachable

; <label>:69:                                     ; preds = %62, %60, %58, %56, %3
  br label %70

; <label>:70:                                     ; preds = %3, %48, %69, %55, %54, %24, %22, %20, %19, %18, %17, %16, %15, %14, %13, %12, %11, %10, %9, %8
  %71 = phi i32 [ 8, %69 ], [ 7, %55 ], [ 6, %54 ], [ 4, %24 ], [ 1, %22 ], [ 0, %20 ], [ 2, %19 ], [ 2, %18 ], [ 2, %17 ], [ 1, %16 ], [ 1, %15 ], [ 0, %14 ], [ 1, %13 ], [ 0, %12 ], [ 1, %11 ], [ 0, %10 ], [ 1, %9 ], [ 0, %8 ], [ 3, %48 ], [ 5, %3 ]
  ret i32 %71
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @getnumlimit(%struct.Header* nocapture readonly, i8** nocapture, i32) unnamed_addr #0 {
  %4 = load i8*, i8** %1, align 8, !tbaa !54
  %5 = load i8, i8* %4, align 1, !tbaa !21
  %6 = sext i8 %5 to i32
  %7 = add nsw i32 %6, -48
  %8 = icmp ugt i32 %7, 9
  br i1 %8, label %25, label %9

; <label>:9:                                      ; preds = %3
  br label %10

; <label>:10:                                     ; preds = %9, %10
  %11 = phi i8* [ %14, %10 ], [ %4, %9 ]
  %12 = phi i32 [ %18, %10 ], [ 0, %9 ]
  %13 = mul nsw i32 %12, 10
  %14 = getelementptr inbounds i8, i8* %11, i64 1
  store i8* %14, i8** %1, align 8, !tbaa !54
  %15 = load i8, i8* %11, align 1, !tbaa !21
  %16 = sext i8 %15 to i32
  %17 = add i32 %13, -48
  %18 = add i32 %17, %16
  %19 = load i8, i8* %14, align 1, !tbaa !21
  %20 = sext i8 %19 to i32
  %21 = add nsw i32 %20, -48
  %22 = icmp ult i32 %21, 10
  %23 = icmp slt i32 %18, 214748364
  %24 = and i1 %23, %22
  br i1 %24, label %10, label %25

; <label>:25:                                     ; preds = %10, %3
  %26 = phi i32 [ %2, %3 ], [ %18, %10 ]
  %27 = add i32 %26, -1
  %28 = icmp ugt i32 %27, 15
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %25
  %30 = getelementptr inbounds %struct.Header, %struct.Header* %0, i64 0, i32 0
  %31 = load %struct.lua_State*, %struct.lua_State** %30, align 8, !tbaa !360
  %32 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %31, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.580, i64 0, i64 0), i32 %26, i32 16) #16
  unreachable

; <label>:33:                                     ; preds = %25
  ret i32 %26
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i64 @unpackint(%struct.lua_State*, i8* nocapture readonly, i32, i32, i32) unnamed_addr #0 {
  %6 = icmp slt i32 %3, 8
  %7 = icmp sgt i32 %3, 0
  br i1 %7, label %8, label %26

; <label>:8:                                      ; preds = %5
  %9 = icmp eq i32 %2, 0
  %10 = add nsw i32 %3, -1
  %11 = select i1 %6, i32 %3, i32 8
  br label %12

; <label>:12:                                     ; preds = %8, %12
  %13 = phi i32 [ %15, %12 ], [ %11, %8 ]
  %14 = phi i64 [ %24, %12 ], [ 0, %8 ]
  %15 = add nsw i32 %13, -1
  %16 = shl i64 %14, 8
  %17 = sub i32 1, %13
  %18 = add i32 %10, %17
  %19 = select i1 %9, i32 %18, i32 %15
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i8, i8* %1, i64 %20
  %22 = load i8, i8* %21, align 1, !tbaa !21
  %23 = zext i8 %22 to i64
  %24 = or i64 %16, %23
  %25 = icmp sgt i32 %13, 1
  br i1 %25, label %12, label %26

; <label>:26:                                     ; preds = %12, %5
  %27 = phi i64 [ 0, %5 ], [ %24, %12 ]
  br i1 %6, label %28, label %37

; <label>:28:                                     ; preds = %26
  %29 = icmp eq i32 %4, 0
  br i1 %29, label %60, label %30

; <label>:30:                                     ; preds = %28
  %31 = shl i32 %3, 3
  %32 = add nsw i32 %31, -1
  %33 = zext i32 %32 to i64
  %34 = shl i64 1, %33
  %35 = xor i64 %27, %34
  %36 = sub i64 %35, %34
  br label %60

; <label>:37:                                     ; preds = %26
  %38 = icmp eq i32 %3, 8
  br i1 %38, label %60, label %39

; <label>:39:                                     ; preds = %37
  %40 = icmp eq i32 %4, 0
  %41 = icmp sgt i64 %27, -1
  %42 = or i1 %40, %41
  %43 = select i1 %42, i32 0, i32 255
  %44 = icmp eq i32 %2, 0
  %45 = add nsw i32 %3, -1
  br label %48

; <label>:46:                                     ; preds = %48
  %47 = icmp slt i32 %57, %3
  br i1 %47, label %48, label %60

; <label>:48:                                     ; preds = %39, %46
  %49 = phi i32 [ 8, %39 ], [ %57, %46 ]
  %50 = sub i32 %45, %49
  %51 = select i1 %44, i32 %50, i32 %49
  %52 = sext i32 %51 to i64
  %53 = getelementptr inbounds i8, i8* %1, i64 %52
  %54 = load i8, i8* %53, align 1, !tbaa !21
  %55 = zext i8 %54 to i32
  %56 = icmp eq i32 %43, %55
  %57 = add nuw nsw i32 %49, 1
  br i1 %56, label %46, label %58

; <label>:58:                                     ; preds = %48
  %59 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.587, i64 0, i64 0), i32 %3) #16
  unreachable

; <label>:60:                                     ; preds = %46, %28, %37, %30
  %61 = phi i64 [ %36, %30 ], [ %27, %28 ], [ %27, %37 ], [ %27, %46 ]
  ret i64 %61
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_add(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.85, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_sub(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.86, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_mul(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.87, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_mod(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_pow(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_div(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 5, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_idiv(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.91, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @arith_unm(%struct.lua_State*) #0 {
  tail call fastcc void @arith(%struct.lua_State* %0, i32 12, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i64 0, i64 0)) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @arith(%struct.lua_State*, i32, i8*) unnamed_addr #0 {
  %4 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 1) #16
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %10, label %6

; <label>:6:                                      ; preds = %3
  %7 = tail call fastcc i32 @tonum(%struct.lua_State* %0, i32 2) #16
  %8 = icmp eq i32 %7, 0
  br i1 %8, label %10, label %9

; <label>:9:                                      ; preds = %6
  tail call void @lua_arith(%struct.lua_State* %0, i32 %1) #16
  br label %50

; <label>:10:                                     ; preds = %6, %3
  tail call void @lua_settop(%struct.lua_State* %0, i32 2) #17
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %12 = load %struct.CallInfo*, %struct.CallInfo** %11, align 8, !tbaa !24
  %13 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %12, i64 0, i32 0
  %14 = load %union.StackValue*, %union.StackValue** %13, align 8, !tbaa !64
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %14, i64 2
  %16 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %17 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %18 = icmp ult %union.StackValue* %15, %17
  br i1 %18, label %23, label %19

; <label>:19:                                     ; preds = %10
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %21 = load %struct.global_State*, %struct.global_State** %20, align 8, !tbaa !2
  %22 = getelementptr inbounds %struct.global_State, %struct.global_State* %21, i64 0, i32 8
  br label %25

; <label>:23:                                     ; preds = %10
  %24 = getelementptr inbounds %union.StackValue, %union.StackValue* %15, i64 0, i32 0
  br label %25

; <label>:25:                                     ; preds = %23, %19
  %26 = phi %struct.TValue* [ %22, %19 ], [ %24, %23 ]
  %27 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  %28 = load i8, i8* %27, align 8, !tbaa !22
  %29 = and i8 %28, 15
  %30 = icmp eq i8 %29, 4
  br i1 %30, label %34, label %31

; <label>:31:                                     ; preds = %25
  %32 = tail call i32 @luaL_getmetafield(%struct.lua_State* nonnull %0, i32 2, i8* %2) #17
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %34, label %47

; <label>:34:                                     ; preds = %31, %25
  %35 = getelementptr inbounds i8, i8* %2, i64 2
  %36 = tail call i32 @lua_type(%struct.lua_State* nonnull %0, i32 -2) #17
  %37 = add nsw i32 %36, 1
  %38 = sext i32 %37 to i64
  %39 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %38
  %40 = load i8*, i8** %39, align 8, !tbaa !54
  %41 = tail call i32 @lua_type(%struct.lua_State* nonnull %0, i32 -1) #17
  %42 = add nsw i32 %41, 1
  %43 = sext i32 %42 to i64
  %44 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %43
  %45 = load i8*, i8** %44, align 8, !tbaa !54
  %46 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.588, i64 0, i64 0), i8* nonnull %35, i8* %40, i8* %45) #17
  unreachable

; <label>:47:                                     ; preds = %31
  tail call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -3, i32 1) #17
  %48 = load %union.StackValue*, %union.StackValue** %16, align 8, !tbaa !20
  %49 = getelementptr inbounds %union.StackValue, %union.StackValue* %48, i64 -3
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %49, i32 1) #17
  br label %50

; <label>:50:                                     ; preds = %47, %9
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @tonum(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 3
  br i1 %8, label %9, label %20

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = bitcast %union.StackValue** %10 to %struct.TValue**
  %12 = load %struct.TValue*, %struct.TValue** %11, align 8, !tbaa !20
  %13 = bitcast %struct.TValue* %4 to i64*
  %14 = bitcast %struct.TValue* %12 to i64*
  %15 = load i64, i64* %13, align 8
  store i64 %15, i64* %14, align 8
  %16 = load i8, i8* %5, align 8, !tbaa !22
  %17 = getelementptr inbounds %struct.TValue, %struct.TValue* %12, i64 0, i32 1
  store i8 %16, i8* %17, align 8, !tbaa !22
  %18 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  store %union.StackValue* %19, %union.StackValue** %10, align 8, !tbaa !20
  br label %40

; <label>:20:                                     ; preds = %2
  %21 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %21) #7
  %22 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 %1, i64* nonnull %3) #16
  %23 = icmp eq i8* %22, null
  br i1 %23, label %38, label %24

; <label>:24:                                     ; preds = %20
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %26 = bitcast %union.StackValue** %25 to %struct.TValue**
  %27 = load %struct.TValue*, %struct.TValue** %26, align 8, !tbaa !20
  %28 = call fastcc i64 @luaO_str2num(i8* nonnull %22, %struct.TValue* %27) #17
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %33, label %30

; <label>:30:                                     ; preds = %24
  %31 = load %union.StackValue*, %union.StackValue** %25, align 8, !tbaa !20
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 1
  store %union.StackValue* %32, %union.StackValue** %25, align 8, !tbaa !20
  br label %33

; <label>:33:                                     ; preds = %24, %30
  %34 = load i64, i64* %3, align 8, !tbaa !82
  %35 = add i64 %34, 1
  %36 = icmp eq i64 %28, %35
  %37 = zext i1 %36 to i32
  br label %38

; <label>:38:                                     ; preds = %20, %33
  %39 = phi i32 [ 0, %20 ], [ %37, %33 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %21) #7
  br label %40

; <label>:40:                                     ; preds = %38, %9
  %41 = phi i32 [ 1, %9 ], [ %39, %38 ]
  ret i32 %41
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tconcat(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = alloca i64, align 8
  %4 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %4) #7
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 5) #16
  %5 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %6 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %6) #7
  %7 = call i8* @luaL_optlstring(%struct.lua_State* %0, i32 2, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i64 0, i64 0), i64* nonnull %3) #16
  %8 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 1) #16
  %9 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 4, i64 %5) #16
  %10 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %10, align 8, !tbaa !207
  %11 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %12 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %11, %union.anon.6** %12, align 8, !tbaa !206
  %13 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 2
  %14 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %15 = bitcast i64* %14 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %15, align 8, !tbaa !82
  %16 = icmp slt i64 %8, %9
  br i1 %16, label %17, label %29

; <label>:17:                                     ; preds = %1
  br label %18

; <label>:18:                                     ; preds = %17, %26
  %19 = phi i64 [ %27, %26 ], [ %8, %17 ]
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %19) #16
  %20 = load i64, i64* %3, align 8, !tbaa !82
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %26, label %22

; <label>:22:                                     ; preds = %18
  %23 = call fastcc i8* @prepbuffsize(%struct.luaL_Buffer* nonnull %2, i64 %20, i32 -1) #17
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %7, i64 %20, i32 1, i1 false) #7
  %24 = load i64, i64* %13, align 8, !tbaa !205
  %25 = add i64 %24, %20
  store i64 %25, i64* %13, align 8, !tbaa !205
  br label %26

; <label>:26:                                     ; preds = %18, %22
  %27 = add nsw i64 %19, 1
  %28 = icmp eq i64 %27, %9
  br i1 %28, label %31, label %18

; <label>:29:                                     ; preds = %1
  %30 = icmp eq i64 %8, %9
  br i1 %30, label %31, label %32

; <label>:31:                                     ; preds = %26, %29
  call fastcc void @addfield(%struct.lua_State* %0, %struct.luaL_Buffer* nonnull %2, i64 %9) #16
  br label %32

; <label>:32:                                     ; preds = %31, %29
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %4) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tinsert(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = add nsw i64 %2, 1
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  switch i32 %15, label %30 [
    i32 2, label %32
    i32 3, label %16
  ]

; <label>:16:                                     ; preds = %1
  %17 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 2) #16
  %18 = add i64 %17, -1
  %19 = icmp ult i64 %18, %3
  br i1 %19, label %22, label %20

; <label>:20:                                     ; preds = %16
  %21 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0)) #16
  br label %22

; <label>:22:                                     ; preds = %20, %16
  %23 = icmp slt i64 %2, %17
  br i1 %23, label %32, label %24

; <label>:24:                                     ; preds = %22
  br label %25

; <label>:25:                                     ; preds = %24, %25
  %26 = phi i64 [ %27, %25 ], [ %3, %24 ]
  %27 = add nsw i64 %26, -1
  %28 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %27) #16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %26) #16
  %29 = icmp sgt i64 %27, %17
  br i1 %29, label %25, label %32

; <label>:30:                                     ; preds = %1
  %31 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.595, i64 0, i64 0)) #16
  unreachable

; <label>:32:                                     ; preds = %25, %22, %1
  %33 = phi i64 [ %3, %1 ], [ %17, %22 ], [ %17, %25 ]
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %33) #16
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tpack(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %3 = bitcast %union.StackValue** %2 to i64*
  %4 = load i64, i64* %3, align 8, !tbaa !20
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 1
  %10 = ptrtoint %union.StackValue* %9 to i64
  %11 = sub i64 %4, %10
  %12 = lshr exact i64 %11, 4
  %13 = trunc i64 %12 to i32
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %13, i32 1) #16
  tail call void @lua_rotate(%struct.lua_State* %0, i32 1, i32 1) #16
  %14 = icmp sgt i32 %13, 0
  br i1 %14, label %15, label %22

; <label>:15:                                     ; preds = %1
  %16 = shl i64 %11, 28
  %17 = ashr exact i64 %16, 32
  br label %18

; <label>:18:                                     ; preds = %15, %18
  %19 = phi i64 [ %17, %15 ], [ %20, %18 ]
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %19) #16
  %20 = add nsw i64 %19, -1
  %21 = icmp sgt i64 %19, 1
  br i1 %21, label %18, label %22

; <label>:22:                                     ; preds = %18, %1
  %23 = shl i64 %11, 28
  %24 = ashr exact i64 %23, 32
  %25 = bitcast %union.StackValue** %2 to %struct.TValue**
  %26 = load %struct.TValue*, %struct.TValue** %25, align 8, !tbaa !20
  %27 = bitcast %struct.TValue* %26 to i64*
  store i64 %24, i64* %27, align 8, !tbaa !21
  %28 = getelementptr inbounds %struct.TValue, %struct.TValue* %26, i64 0, i32 1
  store i8 35, i8* %28, align 8, !tbaa !22
  %29 = load %union.StackValue*, %union.StackValue** %2, align 8, !tbaa !20
  %30 = getelementptr inbounds %union.StackValue, %union.StackValue* %29, i64 1
  store %union.StackValue* %30, %union.StackValue** %2, align 8, !tbaa !20
  %31 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %32 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %31, i64 0, i32 0
  %33 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !64
  %34 = icmp ult %union.StackValue* %33, %29
  br i1 %34, label %39, label %35

; <label>:35:                                     ; preds = %22
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %37 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %38 = getelementptr inbounds %struct.global_State, %struct.global_State* %37, i64 0, i32 8
  br label %41

; <label>:39:                                     ; preds = %22
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %33, i64 1, i32 0
  br label %41

; <label>:41:                                     ; preds = %35, %39
  %42 = phi %struct.TValue* [ %38, %35 ], [ %40, %39 ]
  tail call fastcc void @auxsetstr(%struct.lua_State* nonnull %0, %struct.TValue* nonnull %42, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.16, i64 0, i64 0)) #17
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tunpack(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %4 = load %struct.CallInfo*, %struct.CallInfo** %3, align 8, !tbaa !24
  %5 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %4, i64 0, i32 0
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !64
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 3
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %10 = icmp ult %union.StackValue* %7, %9
  br i1 %10, label %15, label %11

; <label>:11:                                     ; preds = %1
  %12 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %13 = load %struct.global_State*, %struct.global_State** %12, align 8, !tbaa !2
  %14 = getelementptr inbounds %struct.global_State, %struct.global_State* %13, i64 0, i32 8
  br label %17

; <label>:15:                                     ; preds = %1
  %16 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 0, i32 0
  br label %17

; <label>:17:                                     ; preds = %11, %15
  %18 = phi %struct.TValue* [ %14, %11 ], [ %16, %15 ]
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %18, i64 0, i32 1
  %20 = load i8, i8* %19, align 8, !tbaa !22
  %21 = and i8 %20, 15
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %25

; <label>:23:                                     ; preds = %17
  %24 = tail call i64 @luaL_len(%struct.lua_State* nonnull %0, i32 1) #16
  br label %27

; <label>:25:                                     ; preds = %17
  %26 = tail call i64 @luaL_checkinteger(%struct.lua_State* nonnull %0, i32 3) #16
  br label %27

; <label>:27:                                     ; preds = %25, %23
  %28 = phi i64 [ %24, %23 ], [ %26, %25 ]
  %29 = icmp slt i64 %28, %2
  br i1 %29, label %50, label %30

; <label>:30:                                     ; preds = %27
  %31 = sub i64 %28, %2
  %32 = icmp ugt i64 %31, 2147483646
  br i1 %32, label %38, label %33

; <label>:33:                                     ; preds = %30
  %34 = trunc i64 %31 to i32
  %35 = add i32 %34, 1
  %36 = tail call i32 @lua_checkstack(%struct.lua_State* nonnull %0, i32 %35) #16
  %37 = icmp eq i32 %36, 0
  br i1 %37, label %38, label %40

; <label>:38:                                     ; preds = %33, %30
  %39 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.596, i64 0, i64 0)) #16
  unreachable

; <label>:40:                                     ; preds = %33
  %41 = icmp sgt i64 %28, %2
  br i1 %41, label %42, label %48

; <label>:42:                                     ; preds = %40
  br label %43

; <label>:43:                                     ; preds = %42, %43
  %44 = phi i64 [ %46, %43 ], [ %2, %42 ]
  %45 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %44) #16
  %46 = add nsw i64 %44, 1
  %47 = icmp eq i64 %46, %28
  br i1 %47, label %48, label %43

; <label>:48:                                     ; preds = %43, %40
  %49 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %28) #16
  br label %50

; <label>:50:                                     ; preds = %27, %48
  %51 = phi i32 [ %35, %48 ], [ 0, %27 ]
  ret i32 %51
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tremove(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = tail call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 %2) #16
  %4 = icmp ne i64 %3, %2
  %5 = add i64 %3, -1
  %6 = icmp ugt i64 %5, %2
  %7 = and i1 %4, %6
  br i1 %7, label %8, label %10

; <label>:8:                                      ; preds = %1
  %9 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.594, i64 0, i64 0)) #16
  br label %10

; <label>:10:                                     ; preds = %1, %8
  %11 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %3) #16
  %12 = icmp slt i64 %3, %2
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %10
  br label %14

; <label>:14:                                     ; preds = %13, %14
  %15 = phi i64 [ %16, %14 ], [ %3, %13 ]
  %16 = add nsw i64 %15, 1
  %17 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %16) #16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %15) #16
  %18 = icmp eq i64 %16, %2
  br i1 %18, label %19, label %14

; <label>:19:                                     ; preds = %14, %10
  %20 = phi i64 [ %3, %10 ], [ %2, %14 ]
  %21 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %22 = bitcast %union.StackValue** %21 to %struct.TValue**
  %23 = load %struct.TValue*, %struct.TValue** %22, align 8, !tbaa !20
  %24 = getelementptr inbounds %struct.TValue, %struct.TValue* %23, i64 0, i32 1
  store i8 0, i8* %24, align 8, !tbaa !21
  %25 = load %union.StackValue*, %union.StackValue** %21, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 1
  store %union.StackValue* %26, %union.StackValue** %21, align 8, !tbaa !20
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %20) #16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @tmove(%struct.lua_State*) #0 {
  %2 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 3) #16
  %4 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 4) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %6 = load %struct.CallInfo*, %struct.CallInfo** %5, align 8, !tbaa !24
  %7 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %6, i64 0, i32 0
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !64
  %9 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 5
  %10 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %11 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %12 = icmp ult %union.StackValue* %9, %11
  br i1 %12, label %17, label %13

; <label>:13:                                     ; preds = %1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %15 = load %struct.global_State*, %struct.global_State** %14, align 8, !tbaa !2
  %16 = getelementptr inbounds %struct.global_State, %struct.global_State* %15, i64 0, i32 8
  br label %19

; <label>:17:                                     ; preds = %1
  %18 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 0, i32 0
  br label %19

; <label>:19:                                     ; preds = %13, %17
  %20 = phi %struct.TValue* [ %16, %13 ], [ %18, %17 ]
  %21 = getelementptr inbounds %struct.TValue, %struct.TValue* %20, i64 0, i32 1
  %22 = load i8, i8* %21, align 8, !tbaa !22
  %23 = and i8 %22, 15
  %24 = icmp eq i8 %23, 0
  %25 = select i1 %24, i32 1, i32 5
  tail call fastcc void @checktab(%struct.lua_State* nonnull %0, i32 1, i32 1) #16
  tail call fastcc void @checktab(%struct.lua_State* nonnull %0, i32 %25, i32 2) #16
  %26 = icmp slt i64 %3, %2
  br i1 %26, label %70, label %27

; <label>:27:                                     ; preds = %19
  %28 = icmp sgt i64 %2, 0
  %29 = add nsw i64 %2, 9223372036854775807
  %30 = icmp slt i64 %3, %29
  %31 = or i1 %28, %30
  br i1 %31, label %34, label %32

; <label>:32:                                     ; preds = %27
  %33 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 3, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.597, i64 0, i64 0)) #16
  br label %34

; <label>:34:                                     ; preds = %32, %27
  %35 = sub nsw i64 %3, %2
  %36 = sub i64 9223372036854775807, %35
  %37 = icmp sgt i64 %4, %36
  br i1 %37, label %38, label %40

; <label>:38:                                     ; preds = %34
  %39 = tail call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 4, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.598, i64 0, i64 0)) #16
  br label %40

; <label>:40:                                     ; preds = %34, %38
  %41 = icmp sle i64 %4, %3
  %42 = icmp sgt i64 %4, %2
  %43 = and i1 %41, %42
  br i1 %43, label %44, label %48

; <label>:44:                                     ; preds = %40
  br i1 %24, label %60, label %45

; <label>:45:                                     ; preds = %44
  %46 = tail call i32 @lua_compare(%struct.lua_State* nonnull %0, i32 1, i32 %25, i32 0) #16
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %48, label %60

; <label>:48:                                     ; preds = %40, %45
  %49 = icmp slt i64 %35, 0
  br i1 %49, label %70, label %50

; <label>:50:                                     ; preds = %48
  %51 = add i64 %3, 1
  %52 = sub i64 %51, %2
  br label %53

; <label>:53:                                     ; preds = %53, %50
  %54 = phi i64 [ 0, %50 ], [ %58, %53 ]
  %55 = add nsw i64 %54, %2
  %56 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %55) #16
  %57 = add nsw i64 %54, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %25, i64 %57) #16
  %58 = add nuw nsw i64 %54, 1
  %59 = icmp eq i64 %58, %52
  br i1 %59, label %70, label %53

; <label>:60:                                     ; preds = %44, %45
  %61 = icmp sgt i64 %35, -1
  br i1 %61, label %62, label %70

; <label>:62:                                     ; preds = %60
  br label %63

; <label>:63:                                     ; preds = %62, %63
  %64 = phi i64 [ %68, %63 ], [ %35, %62 ]
  %65 = add nsw i64 %64, %2
  %66 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %65) #16
  %67 = add nsw i64 %64, %4
  tail call void @lua_seti(%struct.lua_State* %0, i32 %25, i64 %67) #16
  %68 = add nsw i64 %64, -1
  %69 = icmp sgt i64 %64, 0
  br i1 %69, label %63, label %70

; <label>:70:                                     ; preds = %53, %63, %60, %48, %19
  %71 = bitcast %union.StackValue** %10 to %struct.TValue**
  %72 = load %struct.TValue*, %struct.TValue** %71, align 8, !tbaa !20
  %73 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %25) #17
  %74 = bitcast %struct.TValue* %73 to i64*
  %75 = bitcast %struct.TValue* %72 to i64*
  %76 = load i64, i64* %74, align 8
  store i64 %76, i64* %75, align 8
  %77 = getelementptr inbounds %struct.TValue, %struct.TValue* %73, i64 0, i32 1
  %78 = load i8, i8* %77, align 8, !tbaa !22
  %79 = getelementptr inbounds %struct.TValue, %struct.TValue* %72, i64 0, i32 1
  store i8 %78, i8* %79, align 8, !tbaa !22
  %80 = load %union.StackValue*, %union.StackValue** %10, align 8, !tbaa !20
  %81 = getelementptr inbounds %union.StackValue, %union.StackValue* %80, i64 1
  store %union.StackValue* %81, %union.StackValue** %10, align 8, !tbaa !20
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @sort(%struct.lua_State*) #0 {
  tail call fastcc void @checktab(%struct.lua_State* %0, i32 1, i32 7) #16
  %2 = tail call i64 @luaL_len(%struct.lua_State* %0, i32 1) #16
  %3 = icmp sgt i64 %2, 1
  br i1 %3, label %4, label %32

; <label>:4:                                      ; preds = %1
  %5 = icmp slt i64 %2, 2147483647
  br i1 %5, label %8, label %6

; <label>:6:                                      ; preds = %4
  %7 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.599, i64 0, i64 0)) #16
  br label %8

; <label>:8:                                      ; preds = %6, %4
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %10 = load %struct.CallInfo*, %struct.CallInfo** %9, align 8, !tbaa !24
  %11 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %10, i64 0, i32 0
  %12 = load %union.StackValue*, %union.StackValue** %11, align 8, !tbaa !64
  %13 = getelementptr inbounds %union.StackValue, %union.StackValue* %12, i64 2
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %16 = icmp ult %union.StackValue* %13, %15
  br i1 %16, label %21, label %17

; <label>:17:                                     ; preds = %8
  %18 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %19 = load %struct.global_State*, %struct.global_State** %18, align 8, !tbaa !2
  %20 = getelementptr inbounds %struct.global_State, %struct.global_State* %19, i64 0, i32 8
  br label %23

; <label>:21:                                     ; preds = %8
  %22 = getelementptr inbounds %union.StackValue, %union.StackValue* %13, i64 0, i32 0
  br label %23

; <label>:23:                                     ; preds = %17, %21
  %24 = phi %struct.TValue* [ %20, %17 ], [ %22, %21 ]
  %25 = getelementptr inbounds %struct.TValue, %struct.TValue* %24, i64 0, i32 1
  %26 = load i8, i8* %25, align 8, !tbaa !22
  %27 = and i8 %26, 15
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %30, label %29

; <label>:29:                                     ; preds = %23
  tail call void @luaL_checktype(%struct.lua_State* nonnull %0, i32 2, i32 6) #16
  br label %30

; <label>:30:                                     ; preds = %23, %29
  tail call void @lua_settop(%struct.lua_State* nonnull %0, i32 2) #16
  %31 = trunc i64 %2 to i32
  tail call fastcc void @auxsort(%struct.lua_State* nonnull %0, i32 1, i32 %31, i32 0) #16
  br label %32

; <label>:32:                                     ; preds = %30, %1
  ret i32 0
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @checktab(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* %0, i32 %1) #17
  %5 = getelementptr inbounds %struct.TValue, %struct.TValue* %4, i64 0, i32 1
  %6 = load i8, i8* %5, align 8, !tbaa !22
  %7 = and i8 %6, 15
  %8 = icmp eq i8 %7, 5
  br i1 %8, label %43, label %9

; <label>:9:                                      ; preds = %3
  %10 = tail call i32 @lua_getmetatable(%struct.lua_State* %0, i32 %1) #16
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %42, label %12

; <label>:12:                                     ; preds = %9
  %13 = and i32 %2, 1
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %19, label %15

; <label>:15:                                     ; preds = %12
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i64 0, i64 0)) #17
  %17 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 -2) #17
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %42, label %19

; <label>:19:                                     ; preds = %15, %12
  %20 = phi i32 [ 2, %15 ], [ 1, %12 ]
  %21 = and i32 %2, 2
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %29, label %23

; <label>:23:                                     ; preds = %19
  %24 = add nuw nsw i32 %20, 1
  %25 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.80, i64 0, i64 0)) #17
  %26 = xor i32 %20, -1
  %27 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 %26) #17
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %42, label %29

; <label>:29:                                     ; preds = %23, %19
  %30 = phi i32 [ %24, %23 ], [ %20, %19 ]
  %31 = and i32 %2, 4
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %39, label %33

; <label>:33:                                     ; preds = %29
  %34 = add nsw i32 %30, 1
  %35 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.83, i64 0, i64 0)) #17
  %36 = xor i32 %30, -1
  %37 = tail call i32 @lua_rawget(%struct.lua_State* %0, i32 %36) #17
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %42, label %39

; <label>:39:                                     ; preds = %33, %29
  %40 = phi i32 [ %34, %33 ], [ %30, %29 ]
  %41 = xor i32 %40, -1
  tail call void @lua_settop(%struct.lua_State* %0, i32 %41) #16
  br label %43

; <label>:42:                                     ; preds = %15, %23, %33, %9
  tail call void @luaL_checktype(%struct.lua_State* %0, i32 %1, i32 5) #16
  br label %43

; <label>:43:                                     ; preds = %3, %39, %42
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @addfield(%struct.lua_State*, %struct.luaL_Buffer*, i64) unnamed_addr #0 {
  %4 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %2) #16
  %5 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %6 = load %union.StackValue*, %union.StackValue** %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 -1, i32 0, i32 1
  %8 = load i8, i8* %7, align 8, !tbaa !22
  %9 = and i8 %8, 15
  %10 = add nsw i8 %9, -3
  %11 = icmp ugt i8 %10, 1
  br i1 %11, label %12, label %19

; <label>:12:                                     ; preds = %3
  %13 = tail call i32 @lua_type(%struct.lua_State* nonnull %0, i32 -1) #16
  %14 = add nsw i32 %13, 1
  %15 = sext i32 %14 to i64
  %16 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %15
  %17 = load i8*, i8** %16, align 8, !tbaa !54
  %18 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.593, i64 0, i64 0), i8* %17, i64 %2) #16
  unreachable

; <label>:19:                                     ; preds = %3
  tail call void @luaL_addvalue(%struct.luaL_Buffer* %1) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @auxsort(%struct.lua_State*, i32, i32, i32) unnamed_addr #0 {
  %5 = alloca [4 x i32], align 16
  %6 = icmp ugt i32 %2, %1
  br i1 %6, label %7, label %180

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %9 = bitcast %union.StackValue** %8 to %struct.TValue**
  %10 = bitcast [4 x i32]* %5 to i8*
  %11 = bitcast [4 x i32]* %5 to i64*
  %12 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i64 2
  %13 = bitcast i32* %12 to i64*
  br label %14

; <label>:14:                                     ; preds = %7, %177
  %15 = phi i32 [ %3, %7 ], [ %178, %177 ]
  %16 = phi i32 [ %2, %7 ], [ %154, %177 ]
  %17 = phi i32 [ %1, %7 ], [ %153, %177 ]
  %18 = zext i32 %17 to i64
  %19 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %18) #16
  %20 = zext i32 %16 to i64
  %21 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %20) #16
  %22 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %23 = icmp eq i32 %22, 0
  br i1 %23, label %25, label %24

; <label>:24:                                     ; preds = %14
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %18) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %20) #17
  br label %29

; <label>:25:                                     ; preds = %14
  %26 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %27 = getelementptr inbounds %union.StackValue, %union.StackValue* %26, i64 -2
  store %union.StackValue* %27, %union.StackValue** %8, align 8, !tbaa !20
  %28 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %27, i32 0) #17
  br label %29

; <label>:29:                                     ; preds = %25, %24
  %30 = sub i32 %16, %17
  %31 = icmp eq i32 %30, 1
  br i1 %31, label %180, label %32

; <label>:32:                                     ; preds = %29
  %33 = icmp ult i32 %30, 100
  %34 = icmp eq i32 %15, 0
  %35 = or i1 %33, %34
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %32
  %37 = add i32 %16, %17
  %38 = lshr i32 %37, 1
  br label %45

; <label>:39:                                     ; preds = %32
  %40 = lshr i32 %30, 2
  %41 = shl nuw nsw i32 %40, 1
  %42 = urem i32 %15, %41
  %43 = add i32 %40, %17
  %44 = add i32 %43, %42
  br label %45

; <label>:45:                                     ; preds = %39, %36
  %46 = phi i32 [ %38, %36 ], [ %44, %39 ]
  %47 = zext i32 %46 to i64
  %48 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %47) #16
  %49 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %18) #16
  %50 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -2, i32 -1) #16
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %53, label %52

; <label>:52:                                     ; preds = %45
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %47) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %18) #17
  br label %65

; <label>:53:                                     ; preds = %45
  %54 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %54, i64 -1
  store %union.StackValue* %55, %union.StackValue** %8, align 8, !tbaa !20
  %56 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %55, i32 0) #17
  %57 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %20) #16
  %58 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #16
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %61, label %60

; <label>:60:                                     ; preds = %53
  tail call void @lua_seti(%struct.lua_State* nonnull %0, i32 1, i64 %47) #17
  tail call void @lua_seti(%struct.lua_State* nonnull %0, i32 1, i64 %20) #17
  br label %65

; <label>:61:                                     ; preds = %53
  %62 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %62, i64 -2
  store %union.StackValue* %63, %union.StackValue** %8, align 8, !tbaa !20
  %64 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %63, i32 0) #17
  br label %65

; <label>:65:                                     ; preds = %60, %61, %52
  %66 = icmp eq i32 %30, 2
  br i1 %66, label %180, label %67

; <label>:67:                                     ; preds = %65
  %68 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %47) #16
  %69 = load %struct.TValue*, %struct.TValue** %9, align 8, !tbaa !20
  %70 = getelementptr inbounds %struct.TValue, %struct.TValue* %69, i64 -1
  %71 = bitcast %struct.TValue* %70 to i64*
  %72 = bitcast %struct.TValue* %69 to i64*
  %73 = load i64, i64* %71, align 8
  store i64 %73, i64* %72, align 8
  %74 = getelementptr inbounds %struct.TValue, %struct.TValue* %69, i64 -1, i32 1
  %75 = load i8, i8* %74, align 8, !tbaa !22
  %76 = getelementptr inbounds %struct.TValue, %struct.TValue* %69, i64 0, i32 1
  store i8 %75, i8* %76, align 8, !tbaa !22
  %77 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %78 = getelementptr inbounds %union.StackValue, %union.StackValue* %77, i64 1
  store %union.StackValue* %78, %union.StackValue** %8, align 8, !tbaa !20
  %79 = add i32 %16, -1
  %80 = zext i32 %79 to i64
  %81 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %80) #16
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %47) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %80) #17
  br label %82

; <label>:82:                                     ; preds = %138, %67
  %83 = phi i32 [ %17, %67 ], [ %108, %138 ]
  %84 = phi i32 [ %79, %67 ], [ %135, %138 ]
  %85 = add i32 %83, 1
  %86 = zext i32 %85 to i64
  %87 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %86) #17
  %88 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #17
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %107, label %90

; <label>:90:                                     ; preds = %82
  br label %91

; <label>:91:                                     ; preds = %90, %96
  %92 = phi i32 [ %100, %96 ], [ %85, %90 ]
  %93 = icmp eq i32 %92, %79
  br i1 %93, label %94, label %96

; <label>:94:                                     ; preds = %91
  %95 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0)) #17
  unreachable

; <label>:96:                                     ; preds = %91
  %97 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %98 = getelementptr inbounds %union.StackValue, %union.StackValue* %97, i64 -1
  store %union.StackValue* %98, %union.StackValue** %8, align 8, !tbaa !20
  %99 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %98, i32 0) #17
  %100 = add i32 %92, 1
  %101 = zext i32 %100 to i64
  %102 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %101) #17
  %103 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -1, i32 -2) #17
  %104 = icmp eq i32 %103, 0
  br i1 %104, label %105, label %91

; <label>:105:                                    ; preds = %96
  %106 = zext i32 %100 to i64
  br label %107

; <label>:107:                                    ; preds = %105, %82
  %108 = phi i32 [ %85, %82 ], [ %100, %105 ]
  %109 = phi i64 [ %86, %82 ], [ %106, %105 ]
  %110 = add i32 %84, -1
  %111 = zext i32 %110 to i64
  %112 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %111) #17
  %113 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -3, i32 -1) #17
  %114 = icmp eq i32 %113, 0
  %115 = icmp ult i32 %110, %108
  br i1 %114, label %134, label %116

; <label>:116:                                    ; preds = %107
  br label %117

; <label>:117:                                    ; preds = %116, %122
  %118 = phi i1 [ %131, %122 ], [ %115, %116 ]
  %119 = phi i32 [ %126, %122 ], [ %110, %116 ]
  br i1 %118, label %120, label %122

; <label>:120:                                    ; preds = %117
  %121 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.600, i64 0, i64 0)) #17
  unreachable

; <label>:122:                                    ; preds = %117
  %123 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %124 = getelementptr inbounds %union.StackValue, %union.StackValue* %123, i64 -1
  store %union.StackValue* %124, %union.StackValue** %8, align 8, !tbaa !20
  %125 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %124, i32 0) #17
  %126 = add i32 %119, -1
  %127 = zext i32 %126 to i64
  %128 = tail call i32 @lua_geti(%struct.lua_State* %0, i32 1, i64 %127) #17
  %129 = tail call fastcc i32 @sort_comp(%struct.lua_State* %0, i32 -3, i32 -1) #17
  %130 = icmp eq i32 %129, 0
  %131 = icmp ult i32 %126, %108
  br i1 %130, label %132, label %117

; <label>:132:                                    ; preds = %122
  %133 = zext i32 %126 to i64
  br label %134

; <label>:134:                                    ; preds = %132, %107
  %135 = phi i32 [ %110, %107 ], [ %126, %132 ]
  %136 = phi i64 [ %111, %107 ], [ %133, %132 ]
  %137 = phi i1 [ %115, %107 ], [ %131, %132 ]
  br i1 %137, label %139, label %138

; <label>:138:                                    ; preds = %134
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %109) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %136) #17
  br label %82

; <label>:139:                                    ; preds = %134
  %140 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !20
  %141 = getelementptr inbounds %union.StackValue, %union.StackValue* %140, i64 -1
  store %union.StackValue* %141, %union.StackValue** %8, align 8, !tbaa !20
  %142 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %141, i32 0) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %80) #17
  tail call void @lua_seti(%struct.lua_State* %0, i32 1, i64 %109) #17
  %143 = sub i32 %108, %17
  %144 = sub i32 %16, %108
  %145 = icmp ult i32 %143, %144
  br i1 %145, label %146, label %149

; <label>:146:                                    ; preds = %139
  %147 = add i32 %108, -1
  tail call fastcc void @auxsort(%struct.lua_State* nonnull %0, i32 %17, i32 %147, i32 %15) #16
  %148 = add i32 %108, 1
  br label %152

; <label>:149:                                    ; preds = %139
  %150 = add i32 %108, 1
  tail call fastcc void @auxsort(%struct.lua_State* nonnull %0, i32 %150, i32 %16, i32 %15) #16
  %151 = add i32 %108, -1
  br label %152

; <label>:152:                                    ; preds = %149, %146
  %153 = phi i32 [ %148, %146 ], [ %17, %149 ]
  %154 = phi i32 [ %16, %146 ], [ %151, %149 ]
  %155 = phi i32 [ %143, %146 ], [ %144, %149 ]
  %156 = sub i32 %154, %153
  %157 = lshr i32 %156, 7
  %158 = icmp ugt i32 %157, %155
  br i1 %158, label %159, label %177

; <label>:159:                                    ; preds = %152
  %160 = tail call i64 @clock() #17
  %161 = tail call i64 @time(i64* null) #17
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %10) #7
  store i64 %160, i64* %11, align 16
  store i64 %161, i64* %13, align 8
  br label %162

; <label>:162:                                    ; preds = %162, %159
  %163 = phi i64 [ 0, %159 ], [ %169, %162 ]
  %164 = phi <4 x i32> [ zeroinitializer, %159 ], [ %168, %162 ]
  %165 = getelementptr inbounds [4 x i32], [4 x i32]* %5, i64 0, i64 %163
  %166 = bitcast i32* %165 to <4 x i32>*
  %167 = load <4 x i32>, <4 x i32>* %166, align 16, !tbaa !77
  %168 = add <4 x i32> %167, %164
  %169 = add i64 %163, 4
  %170 = icmp eq i64 %163, 0
  br i1 %170, label %171, label %162, !llvm.loop !369

; <label>:171:                                    ; preds = %162
  %172 = shufflevector <4 x i32> %168, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %173 = add <4 x i32> %168, %172
  %174 = shufflevector <4 x i32> %173, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %175 = add <4 x i32> %173, %174
  %176 = extractelement <4 x i32> %175, i32 0
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %10) #7
  br label %177

; <label>:177:                                    ; preds = %171, %152
  %178 = phi i32 [ %15, %152 ], [ %176, %171 ]
  %179 = icmp ugt i32 %154, %153
  br i1 %179, label %14, label %180

; <label>:180:                                    ; preds = %177, %65, %29, %4
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @sort_comp(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %5 = load %struct.CallInfo*, %struct.CallInfo** %4, align 8, !tbaa !24
  %6 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %5, i64 0, i32 0
  %7 = load %union.StackValue*, %union.StackValue** %6, align 8, !tbaa !64
  %8 = getelementptr inbounds %union.StackValue, %union.StackValue* %7, i64 2
  %9 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %11 = icmp ult %union.StackValue* %8, %10
  br i1 %11, label %16, label %12

; <label>:12:                                     ; preds = %3
  %13 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %14 = load %struct.global_State*, %struct.global_State** %13, align 8, !tbaa !2
  %15 = getelementptr inbounds %struct.global_State, %struct.global_State* %14, i64 0, i32 8
  br label %18

; <label>:16:                                     ; preds = %3
  %17 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %18

; <label>:18:                                     ; preds = %12, %16
  %19 = phi %struct.TValue* [ %15, %12 ], [ %17, %16 ]
  %20 = getelementptr inbounds %struct.TValue, %struct.TValue* %19, i64 0, i32 1
  %21 = load i8, i8* %20, align 8, !tbaa !22
  %22 = and i8 %21, 15
  %23 = icmp eq i8 %22, 0
  br i1 %23, label %24, label %31

; <label>:24:                                     ; preds = %18
  %25 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %26 = load %struct.global_State*, %struct.global_State** %25, align 8, !tbaa !2
  %27 = getelementptr inbounds %struct.global_State, %struct.global_State* %26, i64 0, i32 8
  %28 = icmp eq %struct.TValue* %19, %27
  br i1 %28, label %31, label %29

; <label>:29:                                     ; preds = %24
  %30 = tail call i32 @lua_compare(%struct.lua_State* nonnull %0, i32 %1, i32 %2, i32 1) #16
  br label %86

; <label>:31:                                     ; preds = %18, %24
  br i1 %11, label %36, label %32

; <label>:32:                                     ; preds = %31
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %34 = load %struct.global_State*, %struct.global_State** %33, align 8, !tbaa !2
  %35 = getelementptr inbounds %struct.global_State, %struct.global_State* %34, i64 0, i32 8
  br label %38

; <label>:36:                                     ; preds = %31
  %37 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 0, i32 0
  br label %38

; <label>:38:                                     ; preds = %32, %36
  %39 = phi %struct.TValue* [ %35, %32 ], [ %37, %36 ]
  %40 = bitcast %struct.TValue* %39 to i64*
  %41 = bitcast %union.StackValue* %10 to i64*
  %42 = load i64, i64* %40, align 8
  store i64 %42, i64* %41, align 8
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %39, i64 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !22
  %45 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 0, i32 0, i32 1
  store i8 %44, i8* %45, align 8, !tbaa !22
  %46 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %47 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 1
  store %union.StackValue* %47, %union.StackValue** %9, align 8, !tbaa !20
  %48 = add nsw i32 %1, -1
  %49 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %48) #17
  %50 = bitcast %struct.TValue* %49 to i64*
  %51 = bitcast %union.StackValue* %47 to i64*
  %52 = load i64, i64* %50, align 8
  store i64 %52, i64* %51, align 8
  %53 = getelementptr inbounds %struct.TValue, %struct.TValue* %49, i64 0, i32 1
  %54 = load i8, i8* %53, align 8, !tbaa !22
  %55 = getelementptr inbounds %union.StackValue, %union.StackValue* %46, i64 1, i32 0, i32 1
  store i8 %54, i8* %55, align 8, !tbaa !22
  %56 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %57 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 1
  store %union.StackValue* %57, %union.StackValue** %9, align 8, !tbaa !20
  %58 = add nsw i32 %2, -2
  %59 = tail call fastcc %struct.TValue* @index2value(%struct.lua_State* nonnull %0, i32 %58) #17
  %60 = bitcast %struct.TValue* %59 to i64*
  %61 = bitcast %union.StackValue* %57 to i64*
  %62 = load i64, i64* %60, align 8
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds %struct.TValue, %struct.TValue* %59, i64 0, i32 1
  %64 = load i8, i8* %63, align 8, !tbaa !22
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %56, i64 1, i32 0, i32 1
  store i8 %64, i8* %65, align 8, !tbaa !22
  %66 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %67 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 1
  store %union.StackValue* %67, %union.StackValue** %9, align 8, !tbaa !20
  %68 = getelementptr inbounds %union.StackValue, %union.StackValue* %66, i64 -2
  tail call fastcc void @luaD_callnoyield(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %68, i32 1) #17
  %69 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !20
  %70 = getelementptr inbounds %union.StackValue, %union.StackValue* %69, i64 -1, i32 0
  %71 = getelementptr inbounds %union.StackValue, %union.StackValue* %69, i64 -1, i32 0, i32 1
  %72 = load i8, i8* %71, align 8, !tbaa !22
  %73 = and i8 %72, 15
  %74 = icmp eq i8 %73, 0
  br i1 %74, label %82, label %75

; <label>:75:                                     ; preds = %38
  %76 = icmp eq i8 %72, 1
  br i1 %76, label %77, label %82

; <label>:77:                                     ; preds = %75
  %78 = bitcast %struct.TValue* %70 to i32*
  %79 = load i32, i32* %78, align 8, !tbaa !21
  %80 = icmp ne i32 %79, 0
  %81 = zext i1 %80 to i32
  br label %82

; <label>:82:                                     ; preds = %38, %75, %77
  %83 = phi i32 [ 0, %38 ], [ 1, %75 ], [ %81, %77 ]
  %84 = getelementptr inbounds %union.StackValue, %union.StackValue* %69, i64 -1
  store %union.StackValue* %84, %union.StackValue** %9, align 8, !tbaa !20
  %85 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %84, i32 0) #17
  br label %86

; <label>:86:                                     ; preds = %82, %29
  %87 = phi i32 [ %30, %29 ], [ %83, %82 ]
  ret i32 %87
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @byteoffset(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 2) #16
  %6 = icmp sgt i64 %5, -1
  %7 = load i64, i64* %2, align 8
  %8 = add i64 %7, 1
  %9 = select i1 %6, i64 1, i64 %8
  %10 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %9) #16
  %11 = load i64, i64* %2, align 8, !tbaa !82
  %12 = icmp sgt i64 %10, -1
  br i1 %12, label %19, label %13

; <label>:13:                                     ; preds = %1
  %14 = sub i64 0, %10
  %15 = icmp ult i64 %11, %14
  br i1 %15, label %25, label %16

; <label>:16:                                     ; preds = %13
  %17 = add i64 %10, 1
  %18 = add i64 %17, %11
  br label %19

; <label>:19:                                     ; preds = %1, %16
  %20 = phi i64 [ %18, %16 ], [ %10, %1 ]
  %21 = icmp sgt i64 %20, 0
  br i1 %21, label %22, label %25

; <label>:22:                                     ; preds = %19
  %23 = add nsw i64 %20, -1
  %24 = icmp sgt i64 %23, %11
  br i1 %24, label %25, label %28

; <label>:25:                                     ; preds = %13, %22, %19
  %26 = phi i64 [ %23, %22 ], [ %20, %19 ], [ 0, %13 ]
  %27 = call i32 @luaL_argerror(%struct.lua_State* %0, i32 3, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.604, i64 0, i64 0)) #16
  br label %28

; <label>:28:                                     ; preds = %22, %25
  %29 = phi i64 [ %23, %22 ], [ %26, %25 ]
  %30 = icmp eq i64 %5, 0
  br i1 %30, label %31, label %43

; <label>:31:                                     ; preds = %28
  %32 = icmp sgt i64 %29, 0
  br i1 %32, label %33, label %99

; <label>:33:                                     ; preds = %31
  br label %34

; <label>:34:                                     ; preds = %33, %40
  %35 = phi i64 [ %41, %40 ], [ %29, %33 ]
  %36 = getelementptr inbounds i8, i8* %4, i64 %35
  %37 = load i8, i8* %36, align 1, !tbaa !21
  %38 = and i8 %37, -64
  %39 = icmp eq i8 %38, -128
  br i1 %39, label %40, label %99

; <label>:40:                                     ; preds = %34
  %41 = add nsw i64 %35, -1
  %42 = icmp sgt i64 %35, 1
  br i1 %42, label %34, label %99

; <label>:43:                                     ; preds = %28
  %44 = getelementptr inbounds i8, i8* %4, i64 %29
  %45 = load i8, i8* %44, align 1, !tbaa !21
  %46 = and i8 %45, -64
  %47 = icmp eq i8 %46, -128
  br i1 %47, label %48, label %50

; <label>:48:                                     ; preds = %43
  %49 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.605, i64 0, i64 0)) #16
  unreachable

; <label>:50:                                     ; preds = %43
  %51 = icmp slt i64 %5, 0
  br i1 %51, label %52, label %73

; <label>:52:                                     ; preds = %50
  %53 = icmp sgt i64 %29, 0
  br i1 %53, label %54, label %106

; <label>:54:                                     ; preds = %52
  br label %55

; <label>:55:                                     ; preds = %54, %69
  %56 = phi i64 [ %60, %69 ], [ %29, %54 ]
  %57 = phi i64 [ %70, %69 ], [ %5, %54 ]
  br label %58

; <label>:58:                                     ; preds = %64, %55
  %59 = phi i64 [ %56, %55 ], [ %60, %64 ]
  %60 = add nsw i64 %59, -1
  %61 = icmp sgt i64 %59, 1
  br i1 %61, label %64, label %62

; <label>:62:                                     ; preds = %58
  %63 = add nsw i64 %57, 1
  br label %95

; <label>:64:                                     ; preds = %58
  %65 = getelementptr inbounds i8, i8* %4, i64 %60
  %66 = load i8, i8* %65, align 1, !tbaa !21
  %67 = and i8 %66, -64
  %68 = icmp eq i8 %67, -128
  br i1 %68, label %58, label %69

; <label>:69:                                     ; preds = %64
  %70 = add nsw i64 %57, 1
  %71 = icmp slt i64 %57, -1
  %72 = and i1 %71, %61
  br i1 %72, label %55, label %95

; <label>:73:                                     ; preds = %50
  %74 = add nsw i64 %5, -1
  %75 = icmp sgt i64 %5, 1
  %76 = load i64, i64* %2, align 8
  %77 = icmp slt i64 %29, %76
  %78 = and i1 %75, %77
  br i1 %78, label %79, label %95

; <label>:79:                                     ; preds = %73
  br label %80

; <label>:80:                                     ; preds = %79, %90
  %81 = phi i64 [ %91, %90 ], [ %74, %79 ]
  %82 = phi i64 [ %85, %90 ], [ %29, %79 ]
  br label %83

; <label>:83:                                     ; preds = %83, %80
  %84 = phi i64 [ %82, %80 ], [ %85, %83 ]
  %85 = add nsw i64 %84, 1
  %86 = getelementptr inbounds i8, i8* %4, i64 %85
  %87 = load i8, i8* %86, align 1, !tbaa !21
  %88 = and i8 %87, -64
  %89 = icmp eq i8 %88, -128
  br i1 %89, label %83, label %90

; <label>:90:                                     ; preds = %83
  %91 = add nsw i64 %81, -1
  %92 = icmp sgt i64 %81, 1
  %93 = icmp slt i64 %85, %76
  %94 = and i1 %92, %93
  br i1 %94, label %80, label %95

; <label>:95:                                     ; preds = %90, %69, %62, %73
  %96 = phi i64 [ %74, %73 ], [ %63, %62 ], [ %70, %69 ], [ %91, %90 ]
  %97 = phi i64 [ %29, %73 ], [ %60, %62 ], [ %60, %69 ], [ %85, %90 ]
  %98 = icmp eq i64 %96, 0
  br i1 %98, label %99, label %106

; <label>:99:                                     ; preds = %40, %34, %31, %95
  %100 = phi i64 [ %97, %95 ], [ %29, %31 ], [ %41, %40 ], [ %35, %34 ]
  %101 = add nsw i64 %100, 1
  %102 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %103 = bitcast %union.StackValue** %102 to %struct.TValue**
  %104 = load %struct.TValue*, %struct.TValue** %103, align 8, !tbaa !20
  %105 = bitcast %struct.TValue* %104 to i64*
  store i64 %101, i64* %105, align 8, !tbaa !21
  br label %110

; <label>:106:                                    ; preds = %52, %95
  %107 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %108 = bitcast %union.StackValue** %107 to %struct.TValue**
  %109 = load %struct.TValue*, %struct.TValue** %108, align 8, !tbaa !20
  br label %110

; <label>:110:                                    ; preds = %99, %106
  %111 = phi %struct.TValue* [ %104, %99 ], [ %109, %106 ]
  %112 = phi i8 [ 35, %99 ], [ 0, %106 ]
  %113 = phi %union.StackValue** [ %102, %99 ], [ %107, %106 ]
  %114 = getelementptr inbounds %struct.TValue, %struct.TValue* %111, i64 0, i32 1
  store i8 %112, i8* %114, align 8, !tbaa !21
  %115 = load %union.StackValue*, %union.StackValue** %113, align 8, !tbaa !20
  %116 = getelementptr inbounds %union.StackValue, %union.StackValue* %115, i64 1
  store %union.StackValue* %116, %union.StackValue** %113, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @codepoint(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = alloca i32, align 4
  %4 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %4) #7
  %5 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %6 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %7 = load i64, i64* %2, align 8, !tbaa !82
  %8 = icmp sgt i64 %6, -1
  br i1 %8, label %15, label %9

; <label>:9:                                      ; preds = %1
  %10 = sub i64 0, %6
  %11 = icmp ult i64 %7, %10
  br i1 %11, label %15, label %12

; <label>:12:                                     ; preds = %9
  %13 = add i64 %6, 1
  %14 = add i64 %13, %7
  br label %15

; <label>:15:                                     ; preds = %1, %9, %12
  %16 = phi i64 [ %14, %12 ], [ %6, %1 ], [ 0, %9 ]
  %17 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 %16) #16
  %18 = load i64, i64* %2, align 8, !tbaa !82
  %19 = icmp sgt i64 %17, -1
  br i1 %19, label %26, label %20

; <label>:20:                                     ; preds = %15
  %21 = sub i64 0, %17
  %22 = icmp ult i64 %18, %21
  br i1 %22, label %26, label %23

; <label>:23:                                     ; preds = %20
  %24 = add i64 %17, 1
  %25 = add i64 %24, %18
  br label %26

; <label>:26:                                     ; preds = %15, %20, %23
  %27 = phi i64 [ %25, %23 ], [ %17, %15 ], [ 0, %20 ]
  %28 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %29 = load %struct.CallInfo*, %struct.CallInfo** %28, align 8, !tbaa !24
  %30 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %29, i64 0, i32 0
  %31 = load %union.StackValue*, %union.StackValue** %30, align 8, !tbaa !64
  %32 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 4
  %33 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %34 = load %union.StackValue*, %union.StackValue** %33, align 8, !tbaa !20
  %35 = icmp ult %union.StackValue* %32, %34
  br i1 %35, label %40, label %36

; <label>:36:                                     ; preds = %26
  %37 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %38 = load %struct.global_State*, %struct.global_State** %37, align 8, !tbaa !2
  %39 = getelementptr inbounds %struct.global_State, %struct.global_State* %38, i64 0, i32 8
  br label %42

; <label>:40:                                     ; preds = %26
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %32, i64 0, i32 0
  br label %42

; <label>:42:                                     ; preds = %36, %40
  %43 = phi %struct.TValue* [ %39, %36 ], [ %41, %40 ]
  %44 = getelementptr inbounds %struct.TValue, %struct.TValue* %43, i64 0, i32 1
  %45 = load i8, i8* %44, align 8, !tbaa !22
  %46 = and i8 %45, 15
  %47 = icmp eq i8 %46, 0
  br i1 %47, label %55, label %48

; <label>:48:                                     ; preds = %42
  %49 = icmp eq i8 %45, 1
  br i1 %49, label %50, label %55

; <label>:50:                                     ; preds = %48
  %51 = bitcast %struct.TValue* %43 to i32*
  %52 = load i32, i32* %51, align 8, !tbaa !21
  %53 = icmp eq i32 %52, 0
  %54 = zext i1 %53 to i32
  br label %55

; <label>:55:                                     ; preds = %42, %48, %50
  %56 = phi i32 [ 1, %42 ], [ 0, %48 ], [ %54, %50 ]
  %57 = icmp sgt i64 %16, 0
  br i1 %57, label %61, label %58

; <label>:58:                                     ; preds = %55
  %59 = call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0)) #16
  %60 = load i64, i64* %2, align 8, !tbaa !82
  br label %61

; <label>:61:                                     ; preds = %58, %55
  %62 = phi i64 [ %60, %58 ], [ %18, %55 ]
  %63 = icmp sgt i64 %27, %62
  br i1 %63, label %64, label %66

; <label>:64:                                     ; preds = %61
  %65 = call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.606, i64 0, i64 0)) #16
  br label %66

; <label>:66:                                     ; preds = %61, %64
  %67 = icmp slt i64 %27, %16
  br i1 %67, label %98, label %68

; <label>:68:                                     ; preds = %66
  %69 = sub nsw i64 %27, %16
  %70 = icmp sgt i64 %69, 2147483646
  br i1 %70, label %71, label %73

; <label>:71:                                     ; preds = %68
  %72 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  unreachable

; <label>:73:                                     ; preds = %68
  %74 = trunc i64 %69 to i32
  %75 = add nsw i32 %74, 1
  call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 %75, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.541, i64 0, i64 0)) #16
  %76 = getelementptr inbounds i8, i8* %5, i64 %27
  %77 = add nsw i64 %16, -1
  %78 = getelementptr inbounds i8, i8* %5, i64 %77
  %79 = bitcast i32* %3 to i8*
  %80 = bitcast %union.StackValue** %33 to %struct.TValue**
  br label %81

; <label>:81:                                     ; preds = %73, %88
  %82 = phi i32 [ 0, %73 ], [ %96, %88 ]
  %83 = phi i8* [ %78, %73 ], [ %84, %88 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %79) #7
  %84 = call fastcc i8* @utf8_decode(i8* %83, i32* nonnull %3, i32 %56) #16
  %85 = icmp eq i8* %84, null
  br i1 %85, label %86, label %88

; <label>:86:                                     ; preds = %81
  %87 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0)) #16
  unreachable

; <label>:88:                                     ; preds = %81
  %89 = load i32, i32* %3, align 4, !tbaa !77
  %90 = zext i32 %89 to i64
  %91 = load %struct.TValue*, %struct.TValue** %80, align 8, !tbaa !20
  %92 = bitcast %struct.TValue* %91 to i64*
  store i64 %90, i64* %92, align 8, !tbaa !21
  %93 = getelementptr inbounds %struct.TValue, %struct.TValue* %91, i64 0, i32 1
  store i8 35, i8* %93, align 8, !tbaa !22
  %94 = load %union.StackValue*, %union.StackValue** %33, align 8, !tbaa !20
  %95 = getelementptr inbounds %union.StackValue, %union.StackValue* %94, i64 1
  store %union.StackValue* %95, %union.StackValue** %33, align 8, !tbaa !20
  %96 = add nuw nsw i32 %82, 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %79) #7
  %97 = icmp ult i8* %84, %76
  br i1 %97, label %81, label %98

; <label>:98:                                     ; preds = %88, %66
  %99 = phi i32 [ 0, %66 ], [ %96, %88 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %4) #7
  ret i32 %99
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @utfchar(%struct.lua_State*) #0 {
  %2 = alloca %struct.luaL_Buffer, align 8
  %3 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %4 = bitcast %union.StackValue** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20
  %6 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %7 = load %struct.CallInfo*, %struct.CallInfo** %6, align 8, !tbaa !24
  %8 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %7, i64 0, i32 0
  %9 = load %union.StackValue*, %union.StackValue** %8, align 8, !tbaa !64
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %9, i64 1
  %11 = ptrtoint %union.StackValue* %10 to i64
  %12 = sub i64 %5, %11
  %13 = lshr exact i64 %12, 4
  %14 = trunc i64 %13 to i32
  %15 = icmp eq i32 %14, 1
  br i1 %15, label %16, label %17

; <label>:16:                                     ; preds = %1
  tail call fastcc void @pushutfchar(%struct.lua_State* nonnull %0, i32 1) #16
  br label %31

; <label>:17:                                     ; preds = %1
  %18 = bitcast %struct.luaL_Buffer* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 1056, i8* nonnull %18) #7
  %19 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 3
  store %struct.lua_State* %0, %struct.lua_State** %19, align 8, !tbaa !207
  %20 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 4
  %21 = bitcast %struct.luaL_Buffer* %2 to %union.anon.6**
  store %union.anon.6* %20, %union.anon.6** %21, align 8, !tbaa !206
  %22 = getelementptr inbounds %struct.luaL_Buffer, %struct.luaL_Buffer* %2, i64 0, i32 1
  %23 = bitcast i64* %22 to <2 x i64>*
  store <2 x i64> <i64 1024, i64 0>, <2 x i64>* %23, align 8, !tbaa !82
  %24 = icmp slt i32 %14, 1
  br i1 %24, label %30, label %25

; <label>:25:                                     ; preds = %17
  br label %26

; <label>:26:                                     ; preds = %25, %26
  %27 = phi i32 [ %28, %26 ], [ 1, %25 ]
  call fastcc void @pushutfchar(%struct.lua_State* %0, i32 %27) #16
  call void @luaL_addvalue(%struct.luaL_Buffer* nonnull %2) #16
  %28 = add nuw nsw i32 %27, 1
  %29 = icmp eq i32 %27, %14
  br i1 %29, label %30, label %26

; <label>:30:                                     ; preds = %26, %17
  call void @luaL_pushresult(%struct.luaL_Buffer* nonnull %2) #16
  call void @llvm.lifetime.end.p0i8(i64 1056, i8* nonnull %18) #7
  br label %31

; <label>:31:                                     ; preds = %30, %16
  ret i32 1
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @utflen(%struct.lua_State*) #0 {
  %2 = alloca i64, align 8
  %3 = bitcast i64* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %3) #7
  %4 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %2) #16
  %5 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 2, i64 1) #16
  %6 = load i64, i64* %2, align 8, !tbaa !82
  %7 = icmp sgt i64 %5, -1
  br i1 %7, label %14, label %8

; <label>:8:                                      ; preds = %1
  %9 = sub i64 0, %5
  %10 = icmp ult i64 %6, %9
  br i1 %10, label %14, label %11

; <label>:11:                                     ; preds = %8
  %12 = add i64 %5, 1
  %13 = add i64 %12, %6
  br label %14

; <label>:14:                                     ; preds = %1, %8, %11
  %15 = phi i64 [ %13, %11 ], [ %5, %1 ], [ 0, %8 ]
  %16 = call i64 @luaL_optinteger(%struct.lua_State* %0, i32 3, i64 -1) #16
  %17 = load i64, i64* %2, align 8, !tbaa !82
  %18 = icmp sgt i64 %16, -1
  br i1 %18, label %25, label %19

; <label>:19:                                     ; preds = %14
  %20 = sub i64 0, %16
  %21 = icmp ult i64 %17, %20
  br i1 %21, label %25, label %22

; <label>:22:                                     ; preds = %19
  %23 = add i64 %16, 1
  %24 = add i64 %23, %17
  br label %25

; <label>:25:                                     ; preds = %14, %19, %22
  %26 = phi i64 [ %24, %22 ], [ %16, %14 ], [ 0, %19 ]
  %27 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %28 = load %struct.CallInfo*, %struct.CallInfo** %27, align 8, !tbaa !24
  %29 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %28, i64 0, i32 0
  %30 = load %union.StackValue*, %union.StackValue** %29, align 8, !tbaa !64
  %31 = getelementptr inbounds %union.StackValue, %union.StackValue* %30, i64 4
  %32 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %33 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !20
  %34 = icmp ult %union.StackValue* %31, %33
  br i1 %34, label %39, label %35

; <label>:35:                                     ; preds = %25
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %37 = load %struct.global_State*, %struct.global_State** %36, align 8, !tbaa !2
  %38 = getelementptr inbounds %struct.global_State, %struct.global_State* %37, i64 0, i32 8
  br label %41

; <label>:39:                                     ; preds = %25
  %40 = getelementptr inbounds %union.StackValue, %union.StackValue* %31, i64 0, i32 0
  br label %41

; <label>:41:                                     ; preds = %35, %39
  %42 = phi %struct.TValue* [ %38, %35 ], [ %40, %39 ]
  %43 = getelementptr inbounds %struct.TValue, %struct.TValue* %42, i64 0, i32 1
  %44 = load i8, i8* %43, align 8, !tbaa !22
  %45 = and i8 %44, 15
  %46 = icmp eq i8 %45, 0
  br i1 %46, label %54, label %47

; <label>:47:                                     ; preds = %41
  %48 = icmp eq i8 %44, 1
  br i1 %48, label %49, label %54

; <label>:49:                                     ; preds = %47
  %50 = bitcast %struct.TValue* %42 to i32*
  %51 = load i32, i32* %50, align 8, !tbaa !21
  %52 = icmp eq i32 %51, 0
  %53 = zext i1 %52 to i32
  br label %54

; <label>:54:                                     ; preds = %41, %47, %49
  %55 = phi i32 [ 1, %41 ], [ 0, %47 ], [ %53, %49 ]
  %56 = icmp sgt i64 %15, 0
  br i1 %56, label %57, label %60

; <label>:57:                                     ; preds = %54
  %58 = add nsw i64 %15, -1
  %59 = icmp sgt i64 %58, %17
  br i1 %59, label %60, label %64

; <label>:60:                                     ; preds = %57, %54
  %61 = phi i64 [ %58, %57 ], [ %15, %54 ]
  %62 = call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.583, i64 0, i64 0)) #16
  %63 = load i64, i64* %2, align 8, !tbaa !82
  br label %64

; <label>:64:                                     ; preds = %57, %60
  %65 = phi i64 [ %17, %57 ], [ %63, %60 ]
  %66 = phi i64 [ %58, %57 ], [ %61, %60 ]
  %67 = icmp sgt i64 %26, %65
  br i1 %67, label %68, label %70

; <label>:68:                                     ; preds = %64
  %69 = call i32 @luaL_argerror(%struct.lua_State* nonnull %0, i32 3, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.609, i64 0, i64 0)) #16
  br label %70

; <label>:70:                                     ; preds = %64, %68
  %71 = icmp slt i64 %66, %26
  br i1 %71, label %72, label %94

; <label>:72:                                     ; preds = %70
  %73 = ptrtoint i8* %4 to i64
  br label %74

; <label>:74:                                     ; preds = %72, %89
  %75 = phi i64 [ 0, %72 ], [ %92, %89 ]
  %76 = phi i64 [ %66, %72 ], [ %91, %89 ]
  %77 = getelementptr inbounds i8, i8* %4, i64 %76
  %78 = call fastcc i8* @utf8_decode(i8* %77, i32* null, i32 %55) #16
  %79 = icmp eq i8* %78, null
  br i1 %79, label %80, label %89

; <label>:80:                                     ; preds = %74
  %81 = bitcast %union.StackValue** %32 to %struct.TValue**
  %82 = load %struct.TValue*, %struct.TValue** %81, align 8, !tbaa !20
  %83 = getelementptr inbounds %struct.TValue, %struct.TValue* %82, i64 0, i32 1
  store i8 0, i8* %83, align 8, !tbaa !21
  %84 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !20
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 1
  store %union.StackValue* %85, %union.StackValue** %32, align 8, !tbaa !20
  %86 = add nsw i64 %76, 1
  %87 = bitcast %union.StackValue* %85 to i64*
  store i64 %86, i64* %87, align 8, !tbaa !21
  %88 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 1, i32 0, i32 1
  br label %100

; <label>:89:                                     ; preds = %74
  %90 = ptrtoint i8* %78 to i64
  %91 = sub i64 %90, %73
  %92 = add nuw nsw i64 %75, 1
  %93 = icmp slt i64 %91, %26
  br i1 %93, label %74, label %94

; <label>:94:                                     ; preds = %89, %70
  %95 = phi i64 [ 0, %70 ], [ %92, %89 ]
  %96 = bitcast %union.StackValue** %32 to %struct.TValue**
  %97 = load %struct.TValue*, %struct.TValue** %96, align 8, !tbaa !20
  %98 = bitcast %struct.TValue* %97 to i64*
  store i64 %95, i64* %98, align 8, !tbaa !21
  %99 = getelementptr inbounds %struct.TValue, %struct.TValue* %97, i64 0, i32 1
  br label %100

; <label>:100:                                    ; preds = %80, %94
  %101 = phi i8* [ %88, %80 ], [ %99, %94 ]
  %102 = phi i32 [ 2, %80 ], [ 1, %94 ]
  store i8 35, i8* %101, align 8, !tbaa !22
  %103 = load %union.StackValue*, %union.StackValue** %32, align 8, !tbaa !20
  %104 = getelementptr inbounds %union.StackValue, %union.StackValue* %103, i64 1
  store %union.StackValue* %104, %union.StackValue** %32, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %3) #7
  ret i32 %102
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @iter_codes(%struct.lua_State*) #0 {
  %2 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %3 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %4 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %3, i64 0, i32 0
  %5 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !64
  %6 = getelementptr inbounds %union.StackValue, %union.StackValue* %5, i64 2
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %9 = icmp ult %union.StackValue* %6, %8
  br i1 %9, label %14, label %10

; <label>:10:                                     ; preds = %1
  %11 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %12 = load %struct.global_State*, %struct.global_State** %11, align 8, !tbaa !2
  %13 = getelementptr inbounds %struct.global_State, %struct.global_State* %12, i64 0, i32 8
  br label %16

; <label>:14:                                     ; preds = %1
  %15 = getelementptr inbounds %union.StackValue, %union.StackValue* %6, i64 0, i32 0
  br label %16

; <label>:16:                                     ; preds = %10, %14
  %17 = phi %struct.TValue* [ %13, %10 ], [ %15, %14 ]
  %18 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  %19 = load i8, i8* %18, align 8, !tbaa !22
  %20 = and i8 %19, 15
  %21 = icmp eq i8 %20, 0
  br i1 %21, label %22, label %24

; <label>:22:                                     ; preds = %16
  %23 = tail call i8* @luaL_checklstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  br label %33

; <label>:24:                                     ; preds = %16
  %25 = icmp eq i8 %19, 1
  br i1 %25, label %28, label %26

; <label>:26:                                     ; preds = %24
  %27 = tail call i8* @luaL_checklstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  br label %34

; <label>:28:                                     ; preds = %24
  %29 = bitcast %struct.TValue* %17 to i32*
  %30 = load i32, i32* %29, align 8, !tbaa !21
  %31 = icmp eq i32 %30, 0
  %32 = tail call i8* @luaL_checklstring(%struct.lua_State* nonnull %0, i32 1, i64* null) #16
  br i1 %31, label %33, label %34

; <label>:33:                                     ; preds = %22, %28
  br label %34

; <label>:34:                                     ; preds = %26, %28, %33
  %35 = phi i32 (%struct.lua_State*)* [ @iter_auxstrict, %33 ], [ @iter_auxlax, %28 ], [ @iter_auxlax, %26 ]
  %36 = bitcast %union.StackValue** %7 to %struct.TValue**
  %37 = load %struct.TValue*, %struct.TValue** %36, align 8, !tbaa !20
  %38 = bitcast %struct.TValue* %37 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* %35, i32 (%struct.lua_State*)** %38, align 8, !tbaa !21
  %39 = getelementptr inbounds %struct.TValue, %struct.TValue* %37, i64 0, i32 1
  store i8 38, i8* %39, align 8, !tbaa !22
  %40 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %41 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1
  store %union.StackValue* %41, %union.StackValue** %7, align 8, !tbaa !20
  %42 = load %struct.CallInfo*, %struct.CallInfo** %2, align 8, !tbaa !24
  %43 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %42, i64 0, i32 0
  %44 = load %union.StackValue*, %union.StackValue** %43, align 8, !tbaa !64
  %45 = icmp ult %union.StackValue* %44, %40
  br i1 %45, label %50, label %46

; <label>:46:                                     ; preds = %34
  %47 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %48 = load %struct.global_State*, %struct.global_State** %47, align 8, !tbaa !2
  %49 = getelementptr inbounds %struct.global_State, %struct.global_State* %48, i64 0, i32 8
  br label %52

; <label>:50:                                     ; preds = %34
  %51 = getelementptr inbounds %union.StackValue, %union.StackValue* %44, i64 1, i32 0
  br label %52

; <label>:52:                                     ; preds = %46, %50
  %53 = phi %struct.TValue* [ %49, %46 ], [ %51, %50 ]
  %54 = bitcast %struct.TValue* %53 to i64*
  %55 = bitcast %union.StackValue* %41 to i64*
  %56 = load i64, i64* %54, align 8
  store i64 %56, i64* %55, align 8
  %57 = getelementptr inbounds %struct.TValue, %struct.TValue* %53, i64 0, i32 1
  %58 = load i8, i8* %57, align 8, !tbaa !22
  %59 = getelementptr inbounds %union.StackValue, %union.StackValue* %40, i64 1, i32 0, i32 1
  store i8 %58, i8* %59, align 8, !tbaa !22
  %60 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %61 = getelementptr inbounds %union.StackValue, %union.StackValue* %60, i64 1
  store %union.StackValue* %61, %union.StackValue** %7, align 8, !tbaa !20
  %62 = bitcast %union.StackValue* %61 to i64*
  store i64 0, i64* %62, align 8, !tbaa !21
  %63 = getelementptr inbounds %union.StackValue, %union.StackValue* %60, i64 1, i32 0, i32 1
  store i8 35, i8* %63, align 8, !tbaa !22
  %64 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  %65 = getelementptr inbounds %union.StackValue, %union.StackValue* %64, i64 1
  store %union.StackValue* %65, %union.StackValue** %7, align 8, !tbaa !20
  ret i32 3
}

; Function Attrs: norecurse nounwind optsize uwtable
define internal fastcc i8* @utf8_decode(i8* readonly, i32*, i32) unnamed_addr #2 {
  %4 = load i8, i8* %0, align 1, !tbaa !21
  %5 = zext i8 %4 to i32
  %6 = icmp sgt i8 %4, -1
  br i1 %6, label %47, label %7

; <label>:7:                                      ; preds = %3
  %8 = and i32 %5, 64
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %30, label %10

; <label>:10:                                     ; preds = %7
  br label %11

; <label>:11:                                     ; preds = %10, %21
  %12 = phi i64 [ %15, %21 ], [ 0, %10 ]
  %13 = phi i32 [ %24, %21 ], [ 0, %10 ]
  %14 = phi i32 [ %25, %21 ], [ %5, %10 ]
  %15 = add nuw i64 %12, 1
  %16 = getelementptr inbounds i8, i8* %0, i64 %15
  %17 = load i8, i8* %16, align 1, !tbaa !21
  %18 = zext i8 %17 to i32
  %19 = and i32 %18, 192
  %20 = icmp eq i32 %19, 128
  br i1 %20, label %21, label %61

; <label>:21:                                     ; preds = %11
  %22 = shl i32 %13, 6
  %23 = and i32 %18, 63
  %24 = or i32 %23, %22
  %25 = shl i32 %14, 1
  %26 = and i32 %14, 32
  %27 = icmp eq i32 %26, 0
  br i1 %27, label %28, label %11

; <label>:28:                                     ; preds = %21
  %29 = trunc i64 %15 to i32
  br label %30

; <label>:30:                                     ; preds = %28, %7
  %31 = phi i32 [ %5, %7 ], [ %25, %28 ]
  %32 = phi i32 [ 0, %7 ], [ %24, %28 ]
  %33 = phi i32 [ 0, %7 ], [ %29, %28 ]
  %34 = and i32 %31, 127
  %35 = mul nsw i32 %33, 5
  %36 = shl i32 %34, %35
  %37 = or i32 %36, %32
  %38 = icmp ugt i32 %33, 5
  %39 = icmp slt i32 %37, 0
  %40 = or i1 %38, %39
  br i1 %40, label %61, label %41

; <label>:41:                                     ; preds = %30
  %42 = zext i32 %33 to i64
  %43 = getelementptr inbounds [6 x i32], [6 x i32]* @utf8_decode.limits, i64 0, i64 %42
  %44 = load i32, i32* %43, align 4, !tbaa !77
  %45 = icmp ult i32 %37, %44
  %46 = getelementptr inbounds i8, i8* %0, i64 %42
  br i1 %45, label %61, label %47

; <label>:47:                                     ; preds = %41, %3
  %48 = phi i8* [ %0, %3 ], [ %46, %41 ]
  %49 = phi i32 [ %5, %3 ], [ %37, %41 ]
  %50 = icmp eq i32 %2, 0
  br i1 %50, label %56, label %51

; <label>:51:                                     ; preds = %47
  %52 = icmp ugt i32 %49, 1114111
  %53 = and i32 %49, -2048
  %54 = icmp eq i32 %53, 55296
  %55 = or i1 %52, %54
  br i1 %55, label %61, label %56

; <label>:56:                                     ; preds = %51, %47
  %57 = icmp eq i32* %1, null
  br i1 %57, label %59, label %58

; <label>:58:                                     ; preds = %56
  store i32 %49, i32* %1, align 4, !tbaa !77
  br label %59

; <label>:59:                                     ; preds = %56, %58
  %60 = getelementptr inbounds i8, i8* %48, i64 1
  br label %61

; <label>:61:                                     ; preds = %11, %41, %30, %51, %59
  %62 = phi i8* [ %60, %59 ], [ null, %51 ], [ null, %30 ], [ null, %41 ], [ null, %11 ]
  ret i8* %62
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @pushutfchar(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = tail call i64 @luaL_checkinteger(%struct.lua_State* %0, i32 %1) #16
  %4 = icmp ult i64 %3, 2147483648
  br i1 %4, label %7, label %5

; <label>:5:                                      ; preds = %2
  %6 = tail call i32 @luaL_argerror(%struct.lua_State* %0, i32 %1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.542, i64 0, i64 0)) #16
  br label %7

; <label>:7:                                      ; preds = %5, %2
  %8 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.608, i64 0, i64 0), i64 %3) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @iter_auxlax(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 0) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @iter_auxstrict(%struct.lua_State*) #0 {
  %2 = tail call fastcc i32 @iter_aux(%struct.lua_State* %0, i32 1) #16
  ret i32 %2
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @iter_aux(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  %5 = bitcast i64* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %5) #7
  %6 = call i8* @luaL_checklstring(%struct.lua_State* %0, i32 1, i64* nonnull %3) #16
  %7 = call i64 @lua_tointegerx(%struct.lua_State* %0, i32 2, i32* null) #16
  %8 = icmp slt i64 %7, 1
  br i1 %8, label %9, label %11

; <label>:9:                                      ; preds = %2
  %10 = load i64, i64* %3, align 8, !tbaa !82
  br label %23

; <label>:11:                                     ; preds = %2
  %12 = add nsw i64 %7, -1
  %13 = load i64, i64* %3, align 8, !tbaa !82
  %14 = icmp sgt i64 %7, %13
  br i1 %14, label %23, label %15

; <label>:15:                                     ; preds = %11
  br label %16

; <label>:16:                                     ; preds = %15, %16
  %17 = phi i64 [ %22, %16 ], [ %7, %15 ]
  %18 = getelementptr inbounds i8, i8* %6, i64 %17
  %19 = load i8, i8* %18, align 1, !tbaa !21
  %20 = and i8 %19, -64
  %21 = icmp eq i8 %20, -128
  %22 = add nsw i64 %17, 1
  br i1 %21, label %16, label %23

; <label>:23:                                     ; preds = %16, %9, %11
  %24 = phi i64 [ %13, %11 ], [ %10, %9 ], [ %13, %16 ]
  %25 = phi i64 [ %12, %11 ], [ 0, %9 ], [ %17, %16 ]
  %26 = icmp slt i64 %25, %24
  br i1 %26, label %27, label %49

; <label>:27:                                     ; preds = %23
  %28 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %28) #7
  %29 = getelementptr inbounds i8, i8* %6, i64 %25
  %30 = call fastcc i8* @utf8_decode(i8* %29, i32* nonnull %4, i32 %1) #16
  %31 = icmp eq i8* %30, null
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %27
  %33 = call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.607, i64 0, i64 0)) #16
  unreachable

; <label>:34:                                     ; preds = %27
  %35 = add nsw i64 %25, 1
  %36 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %37 = bitcast %union.StackValue** %36 to %struct.TValue**
  %38 = load %struct.TValue*, %struct.TValue** %37, align 8, !tbaa !20
  %39 = bitcast %struct.TValue* %38 to i64*
  store i64 %35, i64* %39, align 8, !tbaa !21
  %40 = getelementptr inbounds %struct.TValue, %struct.TValue* %38, i64 0, i32 1
  store i8 35, i8* %40, align 8, !tbaa !22
  %41 = load %union.StackValue*, %union.StackValue** %36, align 8, !tbaa !20
  %42 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1
  store %union.StackValue* %42, %union.StackValue** %36, align 8, !tbaa !20
  %43 = load i32, i32* %4, align 4, !tbaa !77
  %44 = zext i32 %43 to i64
  %45 = bitcast %union.StackValue* %42 to i64*
  store i64 %44, i64* %45, align 8, !tbaa !21
  %46 = getelementptr inbounds %union.StackValue, %union.StackValue* %41, i64 1, i32 0, i32 1
  store i8 35, i8* %46, align 8, !tbaa !22
  %47 = load %union.StackValue*, %union.StackValue** %36, align 8, !tbaa !20
  %48 = getelementptr inbounds %union.StackValue, %union.StackValue* %47, i64 1
  store %union.StackValue* %48, %union.StackValue** %36, align 8, !tbaa !20
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %28) #7
  br label %49

; <label>:49:                                     ; preds = %23, %34
  %50 = phi i32 [ 2, %34 ], [ 0, %23 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %5) #7
  ret i32 %50
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @print_version() unnamed_addr #0 {
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %2 = tail call i64 @fwrite(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.621, i64 0, i64 0), i64 1, i64 51, %struct._IO_FILE* %1) #16
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %4 = tail call i32 @fputc(i32 10, %struct._IO_FILE* %3)
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %6 = tail call i32 @fflush(%struct._IO_FILE* %5) #16
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @createargtable(%struct.lua_State*, i8** nocapture readonly, i32, i32) unnamed_addr #0 {
  %5 = icmp eq i32 %3, %2
  %6 = select i1 %5, i32 0, i32 %3
  %7 = add nsw i32 %6, 1
  %8 = sub nsw i32 %2, %7
  tail call void @lua_createtable(%struct.lua_State* %0, i32 %8, i32 %7) #16
  %9 = icmp sgt i32 %2, 0
  br i1 %9, label %10, label %22

; <label>:10:                                     ; preds = %4
  %11 = zext i32 %2 to i64
  br label %12

; <label>:12:                                     ; preds = %12, %10
  %13 = phi i64 [ 0, %10 ], [ %20, %12 ]
  %14 = getelementptr inbounds i8*, i8** %1, i64 %13
  %15 = load i8*, i8** %14, align 8, !tbaa !54
  %16 = tail call i8* @lua_pushstring(%struct.lua_State* %0, i8* %15) #16
  %17 = trunc i64 %13 to i32
  %18 = sub nsw i32 %17, %6
  %19 = sext i32 %18 to i64
  tail call void @lua_rawseti(%struct.lua_State* %0, i32 -2, i64 %19) #16
  %20 = add nuw nsw i64 %13, 1
  %21 = icmp eq i64 %20, %11
  br i1 %21, label %22, label %12

; <label>:22:                                     ; preds = %12, %4
  %23 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %24 = load %struct.global_State*, %struct.global_State** %23, align 8, !tbaa !2
  %25 = getelementptr inbounds %struct.global_State, %struct.global_State* %24, i64 0, i32 7, i32 0, i32 0
  %26 = bitcast %struct.GCObject** %25 to %struct.Table**
  %27 = load %struct.Table*, %struct.Table** %26, align 8, !tbaa !21
  %28 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %27, i64 2) #17
  tail call fastcc void @auxsetstr(%struct.lua_State* %0, %struct.TValue* %28, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.622, i64 0, i64 0)) #17
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc void @doREPL(%struct.lua_State*) unnamed_addr #0 {
  %2 = alloca %struct.CallS, align 8
  %3 = alloca i64, align 8
  %4 = alloca %struct.LoadS, align 8
  %5 = alloca i64, align 8
  %6 = alloca %struct.LoadS, align 8
  %7 = load i64, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !54
  store i8* null, i8** @progname, align 8, !tbaa !54
  call void @lua_settop(%struct.lua_State* %0, i32 0) #17
  %8 = call fastcc i32 @pushline(%struct.lua_State* %0, i32 1) #17
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %119, label %10

; <label>:10:                                     ; preds = %1
  %11 = bitcast %struct.LoadS* %6 to i8*
  %12 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 0
  %13 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %6, i64 0, i32 1
  %14 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %15 = bitcast i64* %5 to i8*
  %16 = bitcast %struct.LoadS* %4 to i8*
  %17 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %4, i64 0, i32 0
  %18 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %4, i64 0, i32 1
  %19 = bitcast %union.StackValue** %14 to i64*
  %20 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %21 = bitcast i64* %3 to i8*
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = bitcast %struct.CallS* %2 to i8*
  %24 = getelementptr inbounds %struct.CallS, %struct.CallS* %2, i64 0, i32 0
  %25 = getelementptr inbounds %struct.CallS, %struct.CallS* %2, i64 0, i32 1
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 11
  %27 = bitcast %union.StackValue** %26 to i64*
  br label %28

; <label>:28:                                     ; preds = %10, %116
  %29 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %30 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.636, i64 0, i64 0), i8* %29) #17
  %31 = call i64 @strlen(i8* nonnull %30) #21
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #7
  store i8* %30, i8** %12, align 8, !tbaa !211
  store i64 %31, i64* %13, align 8, !tbaa !213
  %32 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #7
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %34, label %41

; <label>:34:                                     ; preds = %28
  call void @lua_rotate(%struct.lua_State* %0, i32 -2, i32 -1) #17
  %35 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %36 = getelementptr inbounds %union.StackValue, %union.StackValue* %35, i64 -1
  store %union.StackValue* %36, %union.StackValue** %14, align 8, !tbaa !20
  %37 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %36, i32 0) #17
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 1, i32 -1) #17
  %38 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %39 = getelementptr inbounds %union.StackValue, %union.StackValue* %38, i64 -1
  store %union.StackValue* %39, %union.StackValue** %14, align 8, !tbaa !20
  %40 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %39, i32 0) #17
  br label %77

; <label>:41:                                     ; preds = %28
  %42 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %43 = getelementptr inbounds %union.StackValue, %union.StackValue* %42, i64 -2
  store %union.StackValue* %43, %union.StackValue** %14, align 8, !tbaa !20
  %44 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %43, i32 0) #17
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %15) #7
  %45 = call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* nonnull %5) #17
  %46 = load i64, i64* %5, align 8, !tbaa !82
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #7
  store i8* %45, i8** %17, align 8, !tbaa !211
  store i64 %46, i64* %18, align 8, !tbaa !213
  %47 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #7
  %48 = icmp eq i32 %47, 3
  br i1 %48, label %49, label %72

; <label>:49:                                     ; preds = %41
  br label %50

; <label>:50:                                     ; preds = %49, %66
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %21) #7
  %51 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* nonnull %3) #17
  %52 = load i64, i64* %3, align 8, !tbaa !82
  %53 = icmp ugt i64 %52, 4
  br i1 %53, label %54, label %59

; <label>:54:                                     ; preds = %50
  %55 = getelementptr inbounds i8, i8* %51, i64 %52
  %56 = getelementptr inbounds i8, i8* %55, i64 -5
  %57 = call i32 @strcmp(i8* nonnull %56, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i64 0, i64 0)) #21
  %58 = icmp eq i32 %57, 0
  br i1 %58, label %60, label %59

; <label>:59:                                     ; preds = %54, %50
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %21) #7
  br label %72

; <label>:60:                                     ; preds = %54
  %61 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %62 = getelementptr inbounds %union.StackValue, %union.StackValue* %61, i64 -1
  store %union.StackValue* %62, %union.StackValue** %14, align 8, !tbaa !20
  %63 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %62, i32 0) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %21) #7
  %64 = call fastcc i32 @pushline(%struct.lua_State* nonnull %0, i32 0) #17
  %65 = icmp eq i32 %64, 0
  br i1 %65, label %72, label %66

; <label>:66:                                     ; preds = %60
  %67 = call i8* @lua_pushstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.300, i64 0, i64 0)) #17
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 -2, i32 1) #17
  call void @lua_concat(%struct.lua_State* nonnull %0, i32 3) #17
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %15) #7
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %15) #7
  %68 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 1, i64* nonnull %5) #17
  %69 = load i64, i64* %5, align 8, !tbaa !82
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #7
  store i8* %68, i8** %17, align 8, !tbaa !211
  store i64 %69, i64* %18, align 8, !tbaa !213
  %70 = call i32 @lua_load(%struct.lua_State* nonnull %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %16, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i64 0, i64 0), i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #7
  %71 = icmp eq i32 %70, 3
  br i1 %71, label %50, label %72

; <label>:72:                                     ; preds = %60, %66, %41, %59
  %73 = phi i32 [ 3, %59 ], [ %47, %41 ], [ 3, %60 ], [ %70, %66 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %15) #7
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 1, i32 -1) #17
  %74 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %75 = getelementptr inbounds %union.StackValue, %union.StackValue* %74, i64 -1
  store %union.StackValue* %75, %union.StackValue** %14, align 8, !tbaa !20
  %76 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %75, i32 0) #17
  switch i32 %73, label %113 [
    i32 -1, label %119
    i32 0, label %77
  ]

; <label>:77:                                     ; preds = %72, %34
  %78 = call fastcc i32 @docall(%struct.lua_State* nonnull %0, i32 0, i32 -1) #16
  %79 = icmp eq i32 %78, 0
  br i1 %79, label %80, label %113

; <label>:80:                                     ; preds = %77
  %81 = load i64, i64* %19, align 8, !tbaa !20
  %82 = load %struct.CallInfo*, %struct.CallInfo** %20, align 8, !tbaa !24
  %83 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %82, i64 0, i32 0
  %84 = load %union.StackValue*, %union.StackValue** %83, align 8, !tbaa !64
  %85 = getelementptr inbounds %union.StackValue, %union.StackValue* %84, i64 1
  %86 = ptrtoint %union.StackValue* %85 to i64
  %87 = sub i64 %81, %86
  %88 = lshr exact i64 %87, 4
  %89 = trunc i64 %88 to i32
  %90 = icmp sgt i32 %89, 0
  br i1 %90, label %91, label %116

; <label>:91:                                     ; preds = %80
  call void @luaL_checkstack(%struct.lua_State* nonnull %0, i32 20, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.637, i64 0, i64 0)) #17
  %92 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %93 = getelementptr inbounds %struct.global_State, %struct.global_State* %92, i64 0, i32 7, i32 0, i32 0
  %94 = bitcast %struct.GCObject** %93 to %struct.Table**
  %95 = load %struct.Table*, %struct.Table** %94, align 8, !tbaa !21
  %96 = call fastcc %struct.TValue* @luaH_getint(%struct.Table* %95, i64 2) #17
  %97 = call fastcc i32 @auxgetstr(%struct.lua_State* nonnull %0, %struct.TValue* %96, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.312, i64 0, i64 0)) #17
  call void @lua_rotate(%struct.lua_State* nonnull %0, i32 1, i32 1) #17
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %23) #7
  %98 = load %union.StackValue*, %union.StackValue** %14, align 8, !tbaa !20
  %99 = shl i64 %87, 28
  %100 = add i64 %99, 4294967296
  %101 = ashr exact i64 %100, 32
  %102 = sub nsw i64 0, %101
  %103 = getelementptr inbounds %union.StackValue, %union.StackValue* %98, i64 %102
  store %union.StackValue* %103, %union.StackValue** %24, align 8, !tbaa !159
  %104 = ptrtoint %union.StackValue* %103 to i64
  store i32 0, i32* %25, align 8, !tbaa !161
  %105 = load i64, i64* %27, align 8, !tbaa !23
  %106 = sub i64 %104, %105
  %107 = call fastcc i32 @luaD_pcall(%struct.lua_State* nonnull %0, void (%struct.lua_State*, i8*)* nonnull @f_call, i8* nonnull %23, i64 %106, i64 0) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %23) #7
  %108 = icmp eq i32 %107, 0
  br i1 %108, label %116, label %109

; <label>:109:                                    ; preds = %91
  %110 = load i8*, i8** @progname, align 8, !tbaa !54
  %111 = call i8* @lua_tolstring(%struct.lua_State* nonnull %0, i32 -1, i64* null) #17
  %112 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.638, i64 0, i64 0), i8* %111) #17
  call fastcc void @l_message(i8* %110, i8* nonnull %112) #17
  br label %116

; <label>:113:                                    ; preds = %72, %77
  %114 = phi i32 [ %78, %77 ], [ %73, %72 ]
  %115 = call fastcc i32 @report(%struct.lua_State* nonnull %0, i32 %114) #16
  br label %116

; <label>:116:                                    ; preds = %109, %91, %80, %113
  call void @lua_settop(%struct.lua_State* nonnull %0, i32 0) #17
  %117 = call fastcc i32 @pushline(%struct.lua_State* nonnull %0, i32 1) #17
  %118 = icmp eq i32 %117, 0
  br i1 %118, label %119, label %28

; <label>:119:                                    ; preds = %72, %116, %1
  call void @lua_settop(%struct.lua_State* %0, i32 0) #16
  %120 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %121 = call i32 @fputc(i32 10, %struct._IO_FILE* %120)
  %122 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %123 = call i32 @fflush(%struct._IO_FILE* %122) #16
  store i64 %7, i64* bitcast (i8** @progname to i64*), align 8, !tbaa !54
  ret void
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @dostring(%struct.lua_State*, i8*, i8*) unnamed_addr #0 {
  %4 = alloca %struct.LoadS, align 8
  %5 = tail call i64 @strlen(i8* %1) #21
  %6 = bitcast %struct.LoadS* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %6) #7
  %7 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %4, i64 0, i32 0
  store i8* %1, i8** %7, align 8, !tbaa !211
  %8 = getelementptr inbounds %struct.LoadS, %struct.LoadS* %4, i64 0, i32 1
  store i64 %5, i64* %8, align 8, !tbaa !213
  %9 = call i32 @lua_load(%struct.lua_State* %0, i8* (%struct.lua_State*, i8*, i64*)* nonnull @getS, i8* nonnull %6, i8* %2, i8* null) #17
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %6) #7
  %10 = call fastcc i32 @dochunk(%struct.lua_State* %0, i32 %9) #16
  ret i32 %10
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @dochunk(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %4, label %6

; <label>:4:                                      ; preds = %2
  %5 = tail call fastcc i32 @docall(%struct.lua_State* %0, i32 0, i32 0) #16
  br label %6

; <label>:6:                                      ; preds = %4, %2
  %7 = phi i32 [ %5, %4 ], [ %1, %2 ]
  %8 = tail call fastcc i32 @report(%struct.lua_State* %0, i32 %7) #16
  ret i32 %8
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @docall(%struct.lua_State*, i32, i32) unnamed_addr #0 {
  %4 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %5 = bitcast %union.StackValue** %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !20
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %8 = load %struct.CallInfo*, %struct.CallInfo** %7, align 8, !tbaa !24
  %9 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %8, i64 0, i32 0
  %10 = load %union.StackValue*, %union.StackValue** %9, align 8, !tbaa !64
  %11 = getelementptr inbounds %union.StackValue, %union.StackValue* %10, i64 1
  %12 = ptrtoint %union.StackValue* %11 to i64
  %13 = sub i64 %6, %12
  %14 = lshr exact i64 %13, 4
  %15 = trunc i64 %14 to i32
  %16 = sub nsw i32 %15, %1
  %17 = inttoptr i64 %6 to %struct.TValue*
  %18 = inttoptr i64 %6 to i32 (%struct.lua_State*)**
  store i32 (%struct.lua_State*)* @msghandler, i32 (%struct.lua_State*)** %18, align 8, !tbaa !21
  %19 = getelementptr inbounds %struct.TValue, %struct.TValue* %17, i64 0, i32 1
  store i8 38, i8* %19, align 8, !tbaa !22
  %20 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %21 = getelementptr inbounds %union.StackValue, %union.StackValue* %20, i64 1
  store %union.StackValue* %21, %union.StackValue** %4, align 8, !tbaa !20
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 1) #16
  store %struct.lua_State* %0, %struct.lua_State** @globalL, align 8, !tbaa !54
  %22 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* nonnull @laction) #17
  %23 = tail call i32 @lua_pcallk(%struct.lua_State* %0, i32 %1, i32 %2, i32 %16, i64 0, i32 (%struct.lua_State*, i32, i64)* null) #16
  %24 = tail call void (i32)* @__sysv_signal(i32 2, void (i32)* null) #17
  tail call void @lua_rotate(%struct.lua_State* %0, i32 %16, i32 -1) #16
  %25 = load %union.StackValue*, %union.StackValue** %4, align 8, !tbaa !20
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %25, i64 -1
  store %union.StackValue* %26, %union.StackValue** %4, align 8, !tbaa !20
  %27 = tail call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %26, i32 0) #17
  ret i32 %23
}

; Function Attrs: nounwind optsize uwtable
define internal i32 @msghandler(%struct.lua_State*) #0 {
  %2 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 1, i64* null) #16
  %3 = icmp eq i8* %2, null
  br i1 %3, label %4, label %46

; <label>:4:                                      ; preds = %1
  %5 = tail call i32 @luaL_callmeta(%struct.lua_State* %0, i32 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i64 0, i64 0)) #16
  %6 = icmp eq i32 %5, 0
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %8 = load %union.StackValue*, %union.StackValue** %7, align 8, !tbaa !20
  br i1 %6, label %14, label %9

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds %union.StackValue, %union.StackValue* %8, i64 -1, i32 0, i32 1
  %11 = load i8, i8* %10, align 8, !tbaa !22
  %12 = and i8 %11, 15
  %13 = icmp eq i8 %12, 4
  br i1 %13, label %48, label %14

; <label>:14:                                     ; preds = %4, %9
  %15 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 8
  %16 = load %struct.CallInfo*, %struct.CallInfo** %15, align 8, !tbaa !24
  %17 = getelementptr inbounds %struct.CallInfo, %struct.CallInfo* %16, i64 0, i32 0
  %18 = load %union.StackValue*, %union.StackValue** %17, align 8, !tbaa !64
  %19 = getelementptr inbounds %union.StackValue, %union.StackValue* %18, i64 1
  %20 = icmp ult %union.StackValue* %19, %8
  br i1 %20, label %25, label %21

; <label>:21:                                     ; preds = %14
  %22 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %23 = load %struct.global_State*, %struct.global_State** %22, align 8, !tbaa !2
  %24 = getelementptr inbounds %struct.global_State, %struct.global_State* %23, i64 0, i32 8
  br label %27

; <label>:25:                                     ; preds = %14
  %26 = getelementptr inbounds %union.StackValue, %union.StackValue* %19, i64 0, i32 0
  br label %27

; <label>:27:                                     ; preds = %21, %25
  %28 = phi %struct.TValue* [ %24, %21 ], [ %26, %25 ]
  %29 = getelementptr inbounds %struct.TValue, %struct.TValue* %28, i64 0, i32 1
  %30 = load i8, i8* %29, align 8, !tbaa !22
  %31 = and i8 %30, 15
  %32 = icmp eq i8 %31, 0
  br i1 %32, label %33, label %38

; <label>:33:                                     ; preds = %27
  %34 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %35 = load %struct.global_State*, %struct.global_State** %34, align 8, !tbaa !2
  %36 = getelementptr inbounds %struct.global_State, %struct.global_State* %35, i64 0, i32 8
  %37 = icmp eq %struct.TValue* %28, %36
  br i1 %37, label %41, label %38

; <label>:38:                                     ; preds = %33, %27
  %39 = add nuw nsw i8 %31, 1
  %40 = zext i8 %39 to i64
  br label %41

; <label>:41:                                     ; preds = %33, %38
  %42 = phi i64 [ %40, %38 ], [ 0, %33 ]
  %43 = getelementptr inbounds [12 x i8*], [12 x i8*]* @luaT_typenames_, i64 0, i64 %42
  %44 = load i8*, i8** %43, align 8, !tbaa !54
  %45 = tail call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.625, i64 0, i64 0), i8* %44) #16
  br label %46

; <label>:46:                                     ; preds = %41, %1
  %47 = phi i8* [ %45, %41 ], [ %2, %1 ]
  tail call void @luaL_traceback(%struct.lua_State* %0, %struct.lua_State* %0, i8* nonnull %47, i32 1) #16
  br label %48

; <label>:48:                                     ; preds = %9, %46
  ret i32 1
}

; Function Attrs: nounwind optsize
declare void (i32)* @__sysv_signal(i32, void (i32)*) local_unnamed_addr #9

; Function Attrs: nounwind optsize uwtable
define internal void @laction(i32) #0 {
  %2 = tail call void (i32)* @__sysv_signal(i32 %0, void (i32)* null) #17
  %3 = load %struct.lua_State*, %struct.lua_State** @globalL, align 8, !tbaa !54
  tail call void @lua_sethook(%struct.lua_State* %3, void (%struct.lua_State*, %struct.lua_Debug*)* nonnull @lstop, i32 11, i32 1) #16
  ret void
}

; Function Attrs: noreturn nounwind optsize uwtable
define internal void @lstop(%struct.lua_State*, %struct.lua_Debug* nocapture readnone) #5 {
  tail call void @lua_sethook(%struct.lua_State* %0, void (%struct.lua_State*, %struct.lua_Debug*)* null, i32 0, i32 0) #16
  %3 = tail call i32 (%struct.lua_State*, i8*, ...) @luaL_error(%struct.lua_State* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.626, i64 0, i64 0)) #16
  unreachable
}

; Function Attrs: nounwind optsize uwtable
define internal fastcc i32 @pushline(%struct.lua_State*, i32) unnamed_addr #0 {
  %3 = alloca [512 x i8], align 16
  %4 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %4) #7
  %5 = icmp ne i32 %1, 0
  %6 = select i1 %5, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.632, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.633, i64 0, i64 0)
  %7 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 7
  %8 = load %struct.global_State*, %struct.global_State** %7, align 8, !tbaa !2
  %9 = getelementptr inbounds %struct.global_State, %struct.global_State* %8, i64 0, i32 7, i32 0, i32 0
  %10 = bitcast %struct.GCObject** %9 to %struct.Table**
  %11 = load %struct.Table*, %struct.Table** %10, align 8, !tbaa !21
  %12 = tail call fastcc %struct.TValue* @luaH_getint(%struct.Table* %11, i64 2) #17
  %13 = tail call fastcc i32 @auxgetstr(%struct.lua_State* %0, %struct.TValue* %12, i8* %6) #17
  %14 = tail call i8* @lua_tolstring(%struct.lua_State* %0, i32 -1, i64* null) #17
  %15 = icmp eq i8* %14, null
  %16 = select i1 %5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.634, i64 0, i64 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.635, i64 0, i64 0)
  %17 = select i1 %15, i8* %16, i8* %14
  %18 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %19 = tail call i32 @fputs(i8* %17, %struct._IO_FILE* %18) #16
  %20 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8, !tbaa !54
  %21 = tail call i32 @fflush(%struct._IO_FILE* %20) #16
  %22 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8, !tbaa !54
  %23 = call i8* @fgets(i8* nonnull %4, i32 512, %struct._IO_FILE* %22) #16
  %24 = icmp eq i8* %23, null
  br i1 %24, label %48, label %25

; <label>:25:                                     ; preds = %2
  %26 = getelementptr inbounds %struct.lua_State, %struct.lua_State* %0, i64 0, i32 6
  %27 = load %union.StackValue*, %union.StackValue** %26, align 8, !tbaa !20
  %28 = getelementptr inbounds %union.StackValue, %union.StackValue* %27, i64 -1
  store %union.StackValue* %28, %union.StackValue** %26, align 8, !tbaa !20
  %29 = call fastcc i32 @luaF_close(%struct.lua_State* nonnull %0, %union.StackValue* nonnull %28, i32 0) #17
  %30 = call i64 @strlen(i8* nonnull %4) #21
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %38, label %32

; <label>:32:                                     ; preds = %25
  %33 = add i64 %30, -1
  %34 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 %33
  %35 = load i8, i8* %34, align 1, !tbaa !21
  %36 = icmp eq i8 %35, 10
  br i1 %36, label %37, label %38

; <label>:37:                                     ; preds = %32
  store i8 0, i8* %34, align 1, !tbaa !21
  br label %38

; <label>:38:                                     ; preds = %25, %37, %32
  %39 = phi i64 [ %33, %37 ], [ %30, %32 ], [ 0, %25 ]
  %40 = load i8, i8* %4, align 16
  %41 = icmp eq i8 %40, 61
  %42 = and i1 %5, %41
  br i1 %42, label %43, label %46

; <label>:43:                                     ; preds = %38
  %44 = getelementptr inbounds [512 x i8], [512 x i8]* %3, i64 0, i64 1
  %45 = call i8* (%struct.lua_State*, i8*, ...) @lua_pushfstring(%struct.lua_State* nonnull %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.631, i64 0, i64 0), i8* nonnull %44) #16
  br label %48

; <label>:46:                                     ; preds = %38
  %47 = call i8* @lua_pushlstring(%struct.lua_State* nonnull %0, i8* nonnull %4, i64 %39) #16
  br label %48

; <label>:48:                                     ; preds = %43, %46, %2
  %49 = phi i32 [ 0, %2 ], [ 1, %46 ], [ 1, %43 ]
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %4) #7
  ret i32 %49
}

; Function Attrs: nounwind optsize
declare i32 @fputs(i8* nocapture readonly, %struct._IO_FILE* nocapture) local_unnamed_addr #9

; Function Attrs: nounwind
declare i32 @fputc(i32, %struct._IO_FILE* nocapture) local_unnamed_addr #7

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

attributes #0 = { nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { norecurse nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { norecurse nounwind optsize readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind optsize readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { noreturn nounwind optsize uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { norecurse nounwind optsize readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind optsize readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { argmemonly nounwind optsize readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #12 = { nounwind optsize readonly uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #13 = { nounwind optsize returns_twice "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #14 = { nounwind readnone speculatable }
attributes #15 = { noreturn nounwind optsize "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #16 = { optsize }
attributes #17 = { nounwind optsize }
attributes #18 = { noreturn optsize }
attributes #19 = { noreturn nounwind optsize }
attributes #20 = { nounwind optsize returns_twice }
attributes #21 = { nounwind optsize readonly }
attributes #22 = { nounwind optsize readnone }
attributes #23 = { cold optsize }
attributes #24 = { cold }
attributes #25 = { cold nounwind optsize }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"lua_State", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !7, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !8, i64 96, !4, i64 160, !9, i64 168, !10, i64 176, !10, i64 180, !10, i64 184, !10, i64 188, !10, i64 192}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"short", !5, i64 0}
!8 = !{!"CallInfo", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !5, i64 32, !5, i64 56, !7, i64 60, !7, i64 62}
!9 = !{!"long", !5, i64 0}
!10 = !{!"int", !5, i64 0}
!11 = !{!12, !9, i64 24}
!12 = !{!"global_State", !4, i64 0, !4, i64 8, !9, i64 16, !9, i64 24, !9, i64 32, !9, i64 40, !13, i64 48, !14, i64 64, !14, i64 80, !10, i64 96, !5, i64 100, !5, i64 101, !5, i64 102, !5, i64 103, !5, i64 104, !5, i64 105, !5, i64 106, !5, i64 107, !5, i64 108, !5, i64 109, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !5, i64 272, !5, i64 472, !5, i64 544, !4, i64 1392, !4, i64 1400}
!13 = !{!"stringtable", !4, i64 0, !10, i64 8, !10, i64 12}
!14 = !{!"TValue", !5, i64 0, !5, i64 8}
!15 = !{!12, !5, i64 100}
!16 = !{!3, !5, i64 9}
!17 = !{!3, !5, i64 8}
!18 = !{!12, !4, i64 112}
!19 = !{!3, !4, i64 0}
!20 = !{!3, !4, i64 16}
!21 = !{!5, !5, i64 0}
!22 = !{!14, !5, i64 8}
!23 = !{!3, !4, i64 56}
!24 = !{!3, !4, i64 32}
!25 = !{!3, !7, i64 12}
!26 = !{!3, !10, i64 180}
!27 = !{!3, !4, i64 80}
!28 = !{!3, !4, i64 88}
!29 = !{!3, !10, i64 176}
!30 = !{!3, !4, i64 160}
!31 = !{!3, !10, i64 192}
!32 = !{!3, !10, i64 184}
!33 = !{!3, !5, i64 11}
!34 = !{!3, !4, i64 64}
!35 = !{!3, !5, i64 10}
!36 = !{!3, !9, i64 168}
!37 = !{!3, !10, i64 188}
!38 = !{!12, !4, i64 256}
!39 = !{!12, !5, i64 105}
!40 = !{!12, !5, i64 102}
!41 = !{!12, !9, i64 40}
!42 = !{!12, !5, i64 101}
!43 = !{!12, !9, i64 16}
!44 = !{!12, !5, i64 103}
!45 = !{!12, !9, i64 32}
!46 = !{!12, !4, i64 120}
!47 = !{!12, !5, i64 107}
!48 = !{!12, !5, i64 104}
!49 = !{!12, !4, i64 192}
!50 = !{!12, !4, i64 208}
!51 = !{!12, !4, i64 128}
!52 = !{!12, !4, i64 232}
!53 = !{!12, !4, i64 200}
!54 = !{!4, !4, i64 0}
!55 = !{!12, !4, i64 216}
!56 = !{!12, !4, i64 224}
!57 = !{!12, !5, i64 108}
!58 = !{!12, !5, i64 109}
!59 = !{!12, !4, i64 0}
!60 = !{!12, !4, i64 8}
!61 = !{!"branch_weights", i32 1, i32 2000}
!62 = !{!3, !4, i64 48}
!63 = !{!8, !7, i64 62}
!64 = !{!8, !4, i64 0}
!65 = !{!8, !7, i64 60}
!66 = !{!8, !4, i64 8}
!67 = !{!68, !4, i64 16}
!68 = !{!"UpVal", !4, i64 0, !5, i64 8, !5, i64 9, !4, i64 16, !5, i64 24}
!69 = !{!68, !5, i64 9}
!70 = !{!71, !5, i64 9}
!71 = !{!"GCObject", !4, i64 0, !5, i64 8, !5, i64 9}
!72 = !{!68, !5, i64 8}
!73 = !{!"branch_weights", i32 2000, i32 1}
!74 = !{!12, !4, i64 264}
!75 = !{!76, !5, i64 8}
!76 = !{!"TString", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !5, i64 16}
!77 = !{!10, !10, i64 0}
!78 = !{!12, !10, i64 96}
!79 = !{!12, !5, i64 72}
!80 = !{!12, !4, i64 248}
!81 = !{!12, !5, i64 106}
!82 = !{!9, !9, i64 0}
!83 = !{!84, !10, i64 208}
!84 = !{!"lua_longjmp", !4, i64 0, !5, i64 8, !10, i64 208}
!85 = !{!84, !4, i64 0}
!86 = !{!71, !5, i64 8}
!87 = !{!71, !4, i64 0}
!88 = !{!89, !4, i64 40}
!89 = !{!"Table", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !10, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!90 = !{!89, !5, i64 10}
!91 = !{!89, !4, i64 16}
!92 = !{!89, !10, i64 12}
!93 = !{!89, !5, i64 11}
!94 = !{!13, !4, i64 0}
!95 = !{!13, !10, i64 12}
!96 = !{!12, !4, i64 184}
!97 = distinct !{!97, !98}
!98 = !{!"llvm.loop.isvectorized", i32 1}
!99 = !{!76, !5, i64 10}
!100 = !{!12, !5, i64 88}
!101 = !{!12, !4, i64 176}
!102 = !{!12, !4, i64 48}
!103 = !{!12, !10, i64 60}
!104 = !{!3, !4, i64 40}
!105 = !{!8, !4, i64 16}
!106 = !{!107, !4, i64 128}
!107 = !{!"lua_Debug", !10, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !9, i64 40, !10, i64 48, !10, i64 52, !10, i64 56, !5, i64 60, !5, i64 61, !5, i64 62, !5, i64 63, !7, i64 64, !7, i64 66, !5, i64 68, !4, i64 128}
!108 = !{!109, !10, i64 36}
!109 = !{!"Proto", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !5, i64 11, !5, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120}
!110 = !{!109, !4, i64 104}
!111 = !{!112, !10, i64 8}
!112 = !{!"LocVar", !4, i64 0, !10, i64 8, !10, i64 12}
!113 = !{!112, !10, i64 12}
!114 = !{!112, !4, i64 0}
!115 = !{!109, !5, i64 11}
!116 = !{!109, !4, i64 64}
!117 = !{!8, !4, i64 24}
!118 = !{!107, !4, i64 32}
!119 = !{!107, !9, i64 40}
!120 = !{!107, !10, i64 52}
!121 = !{!107, !10, i64 56}
!122 = !{!109, !4, i64 112}
!123 = !{!76, !5, i64 11}
!124 = !{!109, !10, i64 44}
!125 = !{!109, !10, i64 48}
!126 = !{!107, !4, i64 24}
!127 = !{!107, !10, i64 48}
!128 = !{!107, !5, i64 60}
!129 = !{!107, !5, i64 62}
!130 = !{!107, !5, i64 61}
!131 = !{!109, !5, i64 10}
!132 = !{!107, !5, i64 63}
!133 = !{!107, !4, i64 16}
!134 = !{!107, !7, i64 66}
!135 = !{!107, !7, i64 64}
!136 = !{!109, !10, i64 28}
!137 = !{!109, !4, i64 88}
!138 = !{!139, !5, i64 10}
!139 = !{!"CClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!140 = !{!141, !141, i64 0}
!141 = !{!"double", !5, i64 0}
!142 = !{!143, !4, i64 0}
!143 = !{!"lconv", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !5, i64 80, !5, i64 81, !5, i64 82, !5, i64 83, !5, i64 84, !5, i64 85, !5, i64 86, !5, i64 87, !5, i64 88, !5, i64 89, !5, i64 90, !5, i64 91, !5, i64 92, !5, i64 93}
!144 = !{!145, !145, i64 0}
!145 = !{!"long long", !5, i64 0}
!146 = !{!89, !5, i64 9}
!147 = !{!89, !4, i64 32}
!148 = !{!76, !5, i64 9}
!149 = !{!13, !10, i64 8}
!150 = !{!76, !10, i64 12}
!151 = !{!152, !10, i64 12}
!152 = !{!"BuffFS", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!153 = !{!152, !10, i64 8}
!154 = !{!152, !4, i64 0}
!155 = !{!139, !4, i64 24}
!156 = !{!89, !4, i64 24}
!157 = !{!12, !4, i64 144}
!158 = !{!109, !5, i64 12}
!159 = !{!160, !4, i64 0}
!160 = !{!"CallS", !4, i64 0, !10, i64 8}
!161 = !{!160, !10, i64 8}
!162 = !{!163, !4, i64 32}
!163 = !{!"Zio", !9, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32}
!164 = !{!163, !4, i64 16}
!165 = !{!163, !4, i64 24}
!166 = !{!167, !4, i64 0}
!167 = !{!"SParser", !4, i64 0, !168, i64 8, !169, i64 32, !4, i64 80, !4, i64 88}
!168 = !{!"Mbuffer", !4, i64 0, !9, i64 8, !9, i64 16}
!169 = !{!"Dyndata", !170, i64 0, !171, i64 16, !171, i64 32}
!170 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12}
!171 = !{!"Labellist", !4, i64 0, !10, i64 8, !10, i64 12}
!172 = !{!167, !4, i64 88}
!173 = !{!167, !4, i64 80}
!174 = !{!167, !10, i64 44}
!175 = !{!167, !4, i64 48}
!176 = !{!167, !10, i64 60}
!177 = !{!167, !4, i64 64}
!178 = !{!167, !10, i64 76}
!179 = !{!167, !4, i64 8}
!180 = !{!167, !9, i64 24}
!181 = !{!167, !4, i64 32}
!182 = !{!183, !5, i64 10}
!183 = !{!"LClosure", !4, i64 0, !5, i64 8, !5, i64 9, !5, i64 10, !4, i64 16, !4, i64 24, !5, i64 32}
!184 = !{!185, !4, i64 0}
!185 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16, !10, i64 24, !10, i64 28}
!186 = !{!185, !4, i64 8}
!187 = !{!185, !4, i64 16}
!188 = !{!185, !10, i64 24}
!189 = !{!185, !10, i64 28}
!190 = !{!109, !10, i64 16}
!191 = !{!12, !4, i64 1400}
!192 = !{!12, !4, i64 1392}
!193 = !{!194, !9, i64 16}
!194 = !{!"Udata", !4, i64 0, !5, i64 8, !5, i64 9, !7, i64 10, !9, i64 16, !4, i64 24, !4, i64 32, !5, i64 40}
!195 = !{!194, !7, i64 10}
!196 = !{!194, !4, i64 24}
!197 = !{!183, !4, i64 24}
!198 = !{!109, !4, i64 80}
!199 = !{!200, !4, i64 0}
!200 = !{!"Upvaldesc", !4, i64 0, !5, i64 8, !5, i64 9}
!201 = !{!183, !5, i64 9}
!202 = !{!107, !4, i64 8}
!203 = !{!204, !9, i64 8}
!204 = !{!"luaL_Buffer", !4, i64 0, !9, i64 8, !9, i64 16, !4, i64 24, !5, i64 32}
!205 = !{!204, !9, i64 16}
!206 = !{!204, !4, i64 0}
!207 = !{!204, !4, i64 24}
!208 = !{!209, !4, i64 8}
!209 = !{!"LoadF", !10, i64 0, !4, i64 8, !5, i64 16}
!210 = !{!209, !10, i64 0}
!211 = !{!212, !4, i64 0}
!212 = !{!"LoadS", !4, i64 0, !9, i64 8}
!213 = !{!212, !9, i64 8}
!214 = !{!215, !4, i64 0}
!215 = !{!"luaL_Reg", !4, i64 0, !4, i64 8}
!216 = !{!215, !4, i64 8}
!217 = !{!218, !4, i64 8}
!218 = !{!"luaL_Stream", !4, i64 0, !4, i64 8}
!219 = !{!218, !4, i64 0}
!220 = !{!109, !10, i64 24}
!221 = !{!109, !4, i64 72}
!222 = !{!109, !10, i64 32}
!223 = !{!109, !4, i64 56}
!224 = !{!109, !10, i64 20}
!225 = !{!109, !4, i64 96}
!226 = !{!109, !10, i64 40}
!227 = !{!12, !4, i64 136}
!228 = !{!12, !4, i64 152}
!229 = !{!12, !4, i64 168}
!230 = !{!12, !4, i64 160}
!231 = !{!89, !4, i64 48}
!232 = !{!194, !4, i64 32}
!233 = !{!194, !5, i64 9}
!234 = !{!109, !5, i64 9}
!235 = !{!3, !4, i64 72}
!236 = !{!12, !4, i64 240}
!237 = !{!12, !10, i64 56}
!238 = !{!239, !10, i64 0}
!239 = !{!"AbsLineInfo", !10, i64 0, !10, i64 4}
!240 = !{!200, !5, i64 8}
!241 = !{!200, !5, i64 9}
!242 = !{!107, !10, i64 0}
!243 = !{i64 0, i64 8, !54, i64 0, i64 8, !54, i64 0, i64 4, !77, i64 0, i64 8, !54, i64 0, i64 8, !144, i64 0, i64 8, !140, i64 8, i64 1, !21, i64 9, i64 1, !21, i64 12, i64 4, !77, i64 16, i64 8, !54, i64 16, i64 8, !54, i64 16, i64 4, !77, i64 16, i64 8, !54, i64 16, i64 8, !144, i64 16, i64 8, !140, i64 0, i64 8, !54, i64 0, i64 8, !54, i64 0, i64 4, !77, i64 0, i64 8, !54, i64 0, i64 8, !144, i64 0, i64 8, !140, i64 8, i64 1, !21}
!244 = !{!163, !9, i64 0}
!245 = !{!163, !4, i64 8}
!246 = !{!247, !4, i64 16}
!247 = !{!"", !4, i64 0, !4, i64 8, !4, i64 16}
!248 = !{!247, !4, i64 0}
!249 = !{!247, !4, i64 8}
!250 = !{!251, !4, i64 80}
!251 = !{!"LexState", !10, i64 0, !10, i64 4, !10, i64 8, !252, i64 16, !252, i64 32, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104}
!252 = !{!"Token", !10, i64 0, !5, i64 8}
!253 = !{!254, !4, i64 0}
!254 = !{!"FuncState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40, !10, i64 44, !10, i64 48, !10, i64 52, !10, i64 56, !10, i64 60, !7, i64 64, !5, i64 66, !5, i64 67, !5, i64 68, !5, i64 69, !5, i64 70}
!255 = !{!251, !4, i64 72}
!256 = !{!251, !4, i64 88}
!257 = !{!169, !10, i64 40}
!258 = !{!169, !10, i64 24}
!259 = !{!169, !10, i64 8}
!260 = !{!251, !10, i64 16}
!261 = !{!251, !4, i64 56}
!262 = !{!251, !10, i64 0}
!263 = !{!251, !10, i64 32}
!264 = !{!251, !4, i64 64}
!265 = !{!251, !10, i64 4}
!266 = !{!251, !10, i64 8}
!267 = !{!251, !4, i64 96}
!268 = !{!251, !4, i64 104}
!269 = !{!168, !4, i64 0}
!270 = !{!168, !9, i64 16}
!271 = !{!254, !4, i64 8}
!272 = !{!254, !4, i64 16}
!273 = !{!251, !4, i64 48}
!274 = !{!254, !10, i64 32}
!275 = !{!254, !10, i64 40}
!276 = !{!254, !10, i64 36}
!277 = !{!254, !10, i64 44}
!278 = !{!254, !10, i64 52}
!279 = !{!254, !10, i64 48}
!280 = !{!254, !10, i64 56}
!281 = !{!254, !10, i64 60}
!282 = !{!283, !5, i64 18}
!283 = !{!"BlockCnt", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19}
!284 = !{!283, !5, i64 16}
!285 = !{!283, !10, i64 8}
!286 = !{!283, !10, i64 12}
!287 = !{!283, !5, i64 17}
!288 = !{!283, !5, i64 19}
!289 = !{!283, !4, i64 0}
!290 = !{!254, !4, i64 24}
!291 = !{!292, !10, i64 16}
!292 = !{!"expdesc", !5, i64 0, !5, i64 8, !10, i64 16, !10, i64 20}
!293 = !{!292, !10, i64 20}
!294 = !{!292, !5, i64 0}
!295 = !{i64 0, i64 4, !77, i64 8, i64 8, !140, i64 8, i64 8, !144, i64 8, i64 8, !54}
!296 = !{!239, !10, i64 4}
!297 = !{!254, !5, i64 67}
!298 = !{!254, !5, i64 66}
!299 = !{!254, !5, i64 70}
!300 = !{!254, !7, i64 64}
!301 = !{!254, !5, i64 69}
!302 = !{!168, !9, i64 8}
!303 = !{!254, !5, i64 68}
!304 = !{!169, !4, i64 0}
!305 = !{!306, !7, i64 0}
!306 = !{!"Vardesc", !7, i64 0}
!307 = !{!169, !4, i64 32}
!308 = !{!309, !4, i64 0}
!309 = !{!"Labeldesc", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16, !5, i64 17}
!310 = !{!309, !10, i64 12}
!311 = !{!309, !5, i64 16}
!312 = !{!309, !10, i64 8}
!313 = !{!314, !4, i64 0}
!314 = !{!"LHS_assign", !4, i64 0, !292, i64 8}
!315 = !{!314, !5, i64 8}
!316 = !{!171, !10, i64 8}
!317 = !{!171, !4, i64 0}
!318 = !{!309, !5, i64 17}
!319 = !{!169, !4, i64 16}
!320 = !{!321, !5, i64 0}
!321 = !{!"", !5, i64 0, !5, i64 1}
!322 = !{!321, !5, i64 1}
!323 = !{i64 0, i64 4, !21, i64 8, i64 8, !144, i64 8, i64 8, !140, i64 8, i64 4, !77, i64 8, i64 2, !324, i64 10, i64 1, !21, i64 16, i64 4, !77, i64 20, i64 4, !77}
!324 = !{!7, !7, i64 0}
!325 = !{!326, !10, i64 40}
!326 = !{!"ConsControl", !292, i64 0, !4, i64 24, !10, i64 32, !10, i64 36, !10, i64 40}
!327 = !{!326, !10, i64 32}
!328 = !{!326, !10, i64 36}
!329 = !{!326, !4, i64 24}
!330 = !{!326, !5, i64 0}
!331 = !{i64 0, i64 8, !54, i64 8, i64 4, !77, i64 12, i64 4, !77, i64 16, i64 1, !21, i64 17, i64 1, !21}
!332 = !{!333, !4, i64 0}
!333 = !{!"UBox", !4, i64 0, !9, i64 8}
!334 = !{!333, !9, i64 8}
!335 = !{!336, !4, i64 0}
!336 = !{!"", !4, i64 0, !10, i64 8, !10, i64 12, !5, i64 16}
!337 = !{!336, !10, i64 12}
!338 = !{!336, !10, i64 8}
!339 = !{!340, !10, i64 0}
!340 = !{!"tm", !10, i64 0, !10, i64 4, !10, i64 8, !10, i64 12, !10, i64 16, !10, i64 20, !10, i64 24, !10, i64 28, !10, i64 32, !9, i64 40, !4, i64 48}
!341 = !{!340, !10, i64 4}
!342 = !{!340, !10, i64 8}
!343 = !{!340, !10, i64 12}
!344 = !{!340, !10, i64 16}
!345 = !{!340, !10, i64 20}
!346 = !{!340, !10, i64 32}
!347 = !{!340, !10, i64 24}
!348 = !{!340, !10, i64 28}
!349 = !{!350, !4, i64 24}
!350 = !{!"MatchState", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !10, i64 32, !5, i64 36, !5, i64 40}
!351 = !{!350, !10, i64 32}
!352 = !{!350, !4, i64 0}
!353 = !{!350, !4, i64 8}
!354 = !{!350, !4, i64 16}
!355 = !{!356, !4, i64 0}
!356 = !{!"GMatchState", !4, i64 0, !4, i64 8, !4, i64 16, !350, i64 24}
!357 = !{!356, !4, i64 8}
!358 = !{!356, !4, i64 16}
!359 = !{!350, !5, i64 36}
!360 = !{!361, !4, i64 0}
!361 = !{!"Header", !4, i64 0, !10, i64 8, !10, i64 12}
!362 = !{!361, !10, i64 8}
!363 = !{!361, !10, i64 12}
!364 = !{!365, !9, i64 8}
!365 = !{!"", !4, i64 0, !9, i64 8}
!366 = !{!365, !4, i64 0}
!367 = !{!356, !4, i64 48}
!368 = !{!356, !4, i64 32}
!369 = distinct !{!369, !98}
